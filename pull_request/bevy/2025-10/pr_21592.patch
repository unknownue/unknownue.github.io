diff --git a/Cargo.toml b/Cargo.toml
index b82b3729e2da6..62c51df4caeb1 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -384,10 +384,10 @@ bevy_dev_tools = ["bevy_internal/bevy_dev_tools"]
 bevy_camera_controller = ["bevy_internal/bevy_camera_controller"]
 
 # Enables the free cam from bevy_camera_controller
-free_cam = ["bevy_internal/free_cam"]
+free_camera = ["bevy_internal/free_camera"]
 
-# Enables the pan cam from bevy_camera_controller
-pan_cam = ["bevy_internal/pan_cam"]
+# Enables the pan camera from bevy_camera_controller
+pan_camera = ["bevy_internal/pan_camera"]
 
 # Enable the Bevy Remote Protocol
 bevy_remote = ["bevy_internal/bevy_remote"]
@@ -1258,7 +1258,7 @@ wasm = true
 name = "decal"
 path = "examples/3d/decal.rs"
 doc-scrape-examples = true
-required-features = ["free_cam"]
+required-features = ["free_camera"]
 
 [package.metadata.example.decal]
 name = "Decal"
@@ -1370,7 +1370,7 @@ wasm = true
 name = "shadow_biases"
 path = "examples/3d/shadow_biases.rs"
 doc-scrape-examples = true
-required-features = ["free_cam"]
+required-features = ["free_camera"]
 
 [package.metadata.example.shadow_biases]
 name = "Shadow Biases"
@@ -1393,7 +1393,7 @@ wasm = true
 name = "skybox"
 path = "examples/3d/skybox.rs"
 doc-scrape-examples = true
-required-features = ["free_cam"]
+required-features = ["free_camera"]
 
 [package.metadata.example.skybox]
 name = "Skybox"
@@ -1405,7 +1405,7 @@ wasm = true
 name = "solari"
 path = "examples/3d/solari.rs"
 doc-scrape-examples = true
-required-features = ["bevy_solari", "https", "free_cam"]
+required-features = ["bevy_solari", "https", "free_camera"]
 
 [package.metadata.example.solari]
 name = "Solari"
@@ -1519,7 +1519,7 @@ wasm = false
 name = "meshlet"
 path = "examples/3d/meshlet.rs"
 doc-scrape-examples = true
-required-features = ["meshlet", "https", "free_cam"]
+required-features = ["meshlet", "https", "free_camera"]
 
 [package.metadata.example.meshlet]
 name = "Meshlet"
@@ -3297,7 +3297,7 @@ wasm = false
 name = "scene_viewer"
 path = "examples/tools/scene_viewer/main.rs"
 doc-scrape-examples = true
-required-features = ["free_cam"]
+required-features = ["free_camera"]
 
 [package.metadata.example.scene_viewer]
 name = "Scene Viewer"
@@ -4073,7 +4073,7 @@ wasm = true
 name = "3d_gizmos"
 path = "examples/gizmos/3d_gizmos.rs"
 doc-scrape-examples = true
-required-features = ["free_cam"]
+required-features = ["free_camera"]
 
 [package.metadata.example.3d_gizmos]
 name = "3D Gizmos"
@@ -4220,14 +4220,14 @@ category = "Camera"
 wasm = true
 
 [[example]]
-name = "free_cam_controller"
-path = "examples/camera/free_cam_controller.rs"
+name = "free_camera_controller"
+path = "examples/camera/free_camera_controller.rs"
 doc-scrape-examples = true
-required-features = ["free_cam"]
+required-features = ["free_camera"]
 
-[package.metadata.example.free_cam_controller]
-name = "Free cam camera controller"
-description = "Shows the default free cam camera controller."
+[package.metadata.example.free_camera_controller]
+name = "Free Camera controller"
+description = "Demonstrates the FreeCamera controller for 3D scenes."
 category = "Camera"
 wasm = true
 
@@ -4836,13 +4836,13 @@ category = "Shaders"
 wasm = true
 
 [[example]]
-name = "pan_cam_controller"
-path = "examples/camera/pan_cam_controller.rs"
+name = "pan_camera_controller"
+path = "examples/camera/pan_camera_controller.rs"
 doc-scrape-examples = true
-required-features = ["pan_cam"]
+required-features = ["pan_camera"]
 
-[package.metadata.example.pan_cam_controller]
-name = "Pan Cam"
-description = "Example Pan-Cam Styled Camera Controller for 2D scenes"
+[package.metadata.example.pan_camera_controller]
+name = "Pan Camera"
+description = "Example Pan-Camera Styled Camera Controller for 2D scenes"
 category = "Camera"
 wasm = true
diff --git a/crates/bevy_camera_controller/Cargo.toml b/crates/bevy_camera_controller/Cargo.toml
index 7191ad479045c..482f46cab3153 100644
--- a/crates/bevy_camera_controller/Cargo.toml
+++ b/crates/bevy_camera_controller/Cargo.toml
@@ -29,8 +29,8 @@ bevy_reflect = ["dep:bevy_reflect"]
 libm = ["bevy_math/libm"]
 
 # Camera controllers
-free_cam = []
-pan_cam = []
+free_camera = []
+pan_camera = []
 
 [lints]
 workspace = true
diff --git a/crates/bevy_camera_controller/src/free_cam.rs b/crates/bevy_camera_controller/src/free_camera.rs
similarity index 72%
rename from crates/bevy_camera_controller/src/free_cam.rs
rename to crates/bevy_camera_controller/src/free_camera.rs
index 37a064d00ba98..b46be5f61223e 100644
--- a/crates/bevy_camera_controller/src/free_cam.rs
+++ b/crates/bevy_camera_controller/src/free_camera.rs
@@ -1,19 +1,18 @@
 //! A camera controller that allows the user to move freely around the scene.
 //!
-//! Free cams are helpful for exploring large scenes, level editors and for debugging.
+//! Free cameras are helpful for exploring large scenes, level editors and for debugging.
 //! They are rarely useful as-is for gameplay,
 //! as they allow the user to move freely in all directions,
 //! which can be disorienting, and they can clip through objects and terrain.
 //!
-//! You may have heard of a "fly cam" before,
-//! which are a kind of free cam designed for fluid "flying" movement and quickly surveying large areas.
-//! By contrast, the default settings of this particular free cam are optimized for precise control.
+//! You may have heard of a "fly camera" — a type of free camera designed for fluid "flying" movement and quickly surveying large areas.
+//! By contrast, the default settings of this particular free camera are optimized for precise control.
 //!
-//! To use this controller, add [`FreeCamPlugin`] to your app,
-//! and attach the [`FreeCam`] component to your camera entity.
-//! The required [`FreeCamState`] component will be added automatically.
+//! To use this controller, add [`FreeCameraPlugin`] to your app,
+//! and attach the [`FreeCamera`] component to your camera entity.
+//! The required [`FreeCameraState`] component will be added automatically.
 //!
-//! To configure the settings of this controller, modify the fields of the [`FreeCam`] component.
+//! To configure the settings of this controller, modify the fields of the [`FreeCamera`] component.
 
 use bevy_app::{App, Plugin, RunFixedMainLoop, RunFixedMainLoopSystems};
 use bevy_camera::Camera;
@@ -33,16 +32,16 @@ use core::{f32::consts::*, fmt};
 
 /// A freecam-style camera controller plugin.
 ///
-/// Use the [`FreeCam`] struct to add and customize the controller for a camera entity.
-/// The camera's dynamic state is managed by the [`FreeCamState`] struct.
-pub struct FreeCamPlugin;
+/// Use the [`FreeCamera`] struct to add and customize the controller for a camera entity.
+/// The camera's dynamic state is managed by the [`FreeCameraState`] struct.
+pub struct FreeCameraPlugin;
 
-impl Plugin for FreeCamPlugin {
+impl Plugin for FreeCameraPlugin {
     fn build(&self, app: &mut App) {
         // This ordering is required so that both fixed update and update systems can see the results correctly
         app.add_systems(
             RunFixedMainLoop,
-            run_freecam_controller.in_set(RunFixedMainLoopSystems::BeforeFixedMainLoop),
+            run_freecamera_controller.in_set(RunFixedMainLoopSystems::BeforeFixedMainLoop),
         );
     }
 }
@@ -54,7 +53,7 @@ impl Plugin for FreeCamPlugin {
 /// it because it felt nice.
 const RADIANS_PER_DOT: f32 = 1.0 / 180.0;
 
-/// Stores the settings for the [`FreeCam`] controller.
+/// Stores the settings for the [`FreeCamera`] controller.
 ///
 /// This component defines static configuration for camera controls,
 /// including movement speed, sensitivity, and input bindings.
@@ -62,14 +61,14 @@ const RADIANS_PER_DOT: f32 = 1.0 / 180.0;
 /// From the controller’s perspective, this data is treated as immutable,
 /// but it may be modified externally (e.g., by a settings UI) at runtime.
 ///
-/// Add this component to a [`Camera`] entity to enable freecam controls.
-/// The associated dynamic state is automatically handled by [`FreeCamState`],
+/// Add this component to a [`Camera`] entity to enable `FreeCamera` controls.
+/// The associated dynamic state is automatically handled by [`FreeCameraState`],
 /// which is added to the entity as a required component.
 ///
-/// To activate the controller, add the [`FreeCamPlugin`] to your [`App`].
+/// To activate the controller, add the [`FreeCameraPlugin`] to your [`App`].
 #[derive(Component)]
-#[require(FreeCamState)]
-pub struct FreeCam {
+#[require(FreeCameraState)]
+pub struct FreeCamera {
     /// Multiplier for pitch and yaw rotation speed.
     pub sensitivity: f32,
     /// [`KeyCode`] for forward translation.
@@ -84,8 +83,8 @@ pub struct FreeCam {
     pub key_up: KeyCode,
     /// [`KeyCode`] for down translation.
     pub key_down: KeyCode,
-    /// [`KeyCode`] to use [`run_speed`](FreeCam::run_speed) instead of
-    /// [`walk_speed`](FreeCam::walk_speed) for translation.
+    /// [`KeyCode`] to use [`run_speed`](FreeCamera::run_speed) instead of
+    /// [`walk_speed`](FreeCamera::walk_speed) for translation.
     pub key_run: KeyCode,
     /// [`MouseButton`] for grabbing the mouse focus.
     pub mouse_key_cursor_grab: MouseButton,
@@ -95,14 +94,14 @@ pub struct FreeCam {
     pub walk_speed: f32,
     /// Base multiplier for running translation speed.
     pub run_speed: f32,
-    /// Multiplier for how the mouse scroll wheel modifies [`walk_speed`](FreeCam::walk_speed)
-    /// and [`run_speed`](FreeCam::run_speed).
+    /// Multiplier for how the mouse scroll wheel modifies [`walk_speed`](FreeCamera::walk_speed)
+    /// and [`run_speed`](FreeCamera::run_speed).
     pub scroll_factor: f32,
-    /// Friction factor used to exponentially decay [`velocity`](FreeCamState::velocity) over time.
+    /// Friction factor used to exponentially decay [`velocity`](FreeCameraState::velocity) over time.
     pub friction: f32,
 }
 
-impl Default for FreeCam {
+impl Default for FreeCamera {
     fn default() -> Self {
         Self {
             sensitivity: 0.2,
@@ -123,12 +122,12 @@ impl Default for FreeCam {
     }
 }
 
-impl fmt::Display for FreeCam {
+impl fmt::Display for FreeCamera {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         write!(
             f,
             "
-Freecam Controls:
+Freecamera Controls:
     Mouse\t- Move camera orientation
     Scroll\t- Adjust movement speed
     {:?}\t- Hold to grab cursor
@@ -150,30 +149,30 @@ Freecam Controls:
     }
 }
 
-/// Tracks the runtime state of a [`FreeCam`] controller.
+/// Tracks the runtime state of a [`FreeCamera`] controller.
 ///
 /// This component holds dynamic data that changes during camera operation,
 /// such as pitch, yaw, velocity, and whether the controller is currently enabled.
 ///
-/// It is automatically added to any entity that has a [`FreeCam`] component,
-/// and is updated by the [`FreeCamPlugin`] systems in response to user input.
+/// It is automatically added to any entity that has a [`FreeCamera`] component,
+/// and is updated by the [`FreeCameraPlugin`] systems in response to user input.
 #[derive(Component)]
-pub struct FreeCamState {
-    /// Enables [`FreeCam`] controls when `true`.
+pub struct FreeCameraState {
+    /// Enables [`FreeCamera`] controls when `true`.
     pub enabled: bool,
-    /// Internal flag indicating if this controller has been initialized by the [`FreeCamPlugin`].
+    /// Internal flag indicating if this controller has been initialized by the [`FreeCameraPlugin`].
     initialized: bool,
-    /// This [`FreeCam`]'s pitch rotation.
+    /// This [`FreeCamera`]'s pitch rotation.
     pub pitch: f32,
-    /// This [`FreeCam`]'s yaw rotation.
+    /// This [`FreeCamera`]'s yaw rotation.
     pub yaw: f32,
     /// Multiplier applied to movement speed.
     pub speed_multiplier: f32,
-    /// This [`FreeCam`]'s translation velocity.
+    /// This [`FreeCamera`]'s translation velocity.
     pub velocity: Vec3,
 }
 
-impl Default for FreeCamState {
+impl Default for FreeCameraState {
     fn default() -> Self {
         Self {
             enabled: true,
@@ -188,11 +187,11 @@ impl Default for FreeCamState {
 
 /// Updates the camera's position and orientation based on user input.
 ///
-/// - [`FreeCam`] contains static configuration such as key bindings, movement speed, and sensitivity.
-/// - [`FreeCamState`] stores the dynamic runtime state, including pitch, yaw, velocity, and enable flags.
+/// - [`FreeCamera`] contains static configuration such as key bindings, movement speed, and sensitivity.
+/// - [`FreeCameraState`] stores the dynamic runtime state, including pitch, yaw, velocity, and enable flags.
 ///
-/// This system is typically added via the [`FreeCamPlugin`].
-pub fn run_freecam_controller(
+/// This system is typically added via the [`FreeCameraPlugin`].
+pub fn run_freecamera_controller(
     time: Res<Time<Real>>,
     mut windows: Query<(&Window, &mut CursorOptions)>,
     accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
@@ -201,11 +200,11 @@ pub fn run_freecam_controller(
     key_input: Res<ButtonInput<KeyCode>>,
     mut toggle_cursor_grab: Local<bool>,
     mut mouse_cursor_grab: Local<bool>,
-    mut query: Query<(&mut Transform, &mut FreeCamState, &FreeCam), With<Camera>>,
+    mut query: Query<(&mut Transform, &mut FreeCameraState, &FreeCamera), With<Camera>>,
 ) {
     let dt = time.delta_secs();
 
-    let Ok((mut transform, mut state, controller)) = query.single_mut() else {
+    let Ok((mut transform, mut state, config)) = query.single_mut() else {
         return;
     };
 
@@ -214,11 +213,11 @@ pub fn run_freecam_controller(
         state.yaw = yaw;
         state.pitch = pitch;
         state.initialized = true;
-        info!("{}", *controller);
+        info!("{}", *config);
     }
 
     if !state.enabled {
-        // don't keep the cursor grabbed if the controller was disabled.
+        // don't keep the cursor grabbed if the camera controller was disabled.
         if *toggle_cursor_grab || *mouse_cursor_grab {
             *toggle_cursor_grab = false;
             *mouse_cursor_grab = false;
@@ -240,41 +239,41 @@ pub fn run_freecam_controller(
         }
     };
     scroll += amount;
-    state.speed_multiplier += scroll * controller.scroll_factor;
+    state.speed_multiplier += scroll * config.scroll_factor;
     // Clamp the speed multiplier for safety
     state.speed_multiplier = state.speed_multiplier.clamp(0.0, f32::MAX);
 
     // Handle key input
     let mut axis_input = Vec3::ZERO;
-    if key_input.pressed(controller.key_forward) {
+    if key_input.pressed(config.key_forward) {
         axis_input.z += 1.0;
     }
-    if key_input.pressed(controller.key_back) {
+    if key_input.pressed(config.key_back) {
         axis_input.z -= 1.0;
     }
-    if key_input.pressed(controller.key_right) {
+    if key_input.pressed(config.key_right) {
         axis_input.x += 1.0;
     }
-    if key_input.pressed(controller.key_left) {
+    if key_input.pressed(config.key_left) {
         axis_input.x -= 1.0;
     }
-    if key_input.pressed(controller.key_up) {
+    if key_input.pressed(config.key_up) {
         axis_input.y += 1.0;
     }
-    if key_input.pressed(controller.key_down) {
+    if key_input.pressed(config.key_down) {
         axis_input.y -= 1.0;
     }
 
     let mut cursor_grab_change = false;
-    if key_input.just_pressed(controller.keyboard_key_toggle_cursor_grab) {
+    if key_input.just_pressed(config.keyboard_key_toggle_cursor_grab) {
         *toggle_cursor_grab = !*toggle_cursor_grab;
         cursor_grab_change = true;
     }
-    if mouse_button_input.just_pressed(controller.mouse_key_cursor_grab) {
+    if mouse_button_input.just_pressed(config.mouse_key_cursor_grab) {
         *mouse_cursor_grab = true;
         cursor_grab_change = true;
     }
-    if mouse_button_input.just_released(controller.mouse_key_cursor_grab) {
+    if mouse_button_input.just_released(config.mouse_key_cursor_grab) {
         *mouse_cursor_grab = false;
         cursor_grab_change = true;
     }
@@ -282,14 +281,14 @@ pub fn run_freecam_controller(
 
     // Update velocity
     if axis_input != Vec3::ZERO {
-        let max_speed = if key_input.pressed(controller.key_run) {
-            controller.run_speed * state.speed_multiplier
+        let max_speed = if key_input.pressed(config.key_run) {
+            config.run_speed * state.speed_multiplier
         } else {
-            controller.walk_speed * state.speed_multiplier
+            config.walk_speed * state.speed_multiplier
         };
         state.velocity = axis_input.normalize() * max_speed;
     } else {
-        let friction = controller.friction.clamp(0.0, f32::MAX);
+        let friction = config.friction.clamp(0.0, f32::MAX);
         state.velocity.smooth_nudge(&Vec3::ZERO, friction, dt);
         if state.velocity.length_squared() < 1e-6 {
             state.velocity = Vec3::ZERO;
@@ -328,9 +327,9 @@ pub fn run_freecam_controller(
     if accumulated_mouse_motion.delta != Vec2::ZERO && cursor_grab {
         // Apply look update
         state.pitch = (state.pitch
-            - accumulated_mouse_motion.delta.y * RADIANS_PER_DOT * controller.sensitivity)
+            - accumulated_mouse_motion.delta.y * RADIANS_PER_DOT * config.sensitivity)
             .clamp(-PI / 2., PI / 2.);
-        state.yaw -= accumulated_mouse_motion.delta.x * RADIANS_PER_DOT * controller.sensitivity;
+        state.yaw -= accumulated_mouse_motion.delta.x * RADIANS_PER_DOT * config.sensitivity;
         transform.rotation = Quat::from_euler(EulerRot::ZYX, 0.0, state.yaw, state.pitch);
     }
 }
diff --git a/crates/bevy_camera_controller/src/lib.rs b/crates/bevy_camera_controller/src/lib.rs
index 056e84c7b39e6..3356e4e87f5d4 100644
--- a/crates/bevy_camera_controller/src/lib.rs
+++ b/crates/bevy_camera_controller/src/lib.rs
@@ -17,12 +17,12 @@
 //! These features are all off by default; to enable them,
 //! you need to specify the desired features in your Cargo.toml file.
 //!
-//! For example, to enable the `free_cam` camera controller,
+//! For example, to enable the `free_camera` camera controller,
 //! you would add the following to your Cargo.toml:
 //!
 //! ```toml
 //! [dependencies]
-//! bevy = { version = "0.X", features = ["free_cam"] }
+//! bevy = { version = "0.X", features = ["free_camera"] }
 //! ```
 //!
 //! Once the correct feature is enabled,
@@ -38,8 +38,8 @@
 
 #![warn(missing_docs)]
 
-#[cfg(feature = "free_cam")]
-pub mod free_cam;
+#[cfg(feature = "free_camera")]
+pub mod free_camera;
 
-#[cfg(feature = "pan_cam")]
-pub mod pan_cam;
+#[cfg(feature = "pan_camera")]
+pub mod pan_camera;
diff --git a/crates/bevy_camera_controller/src/pan_cam.rs b/crates/bevy_camera_controller/src/pan_camera.rs
similarity index 80%
rename from crates/bevy_camera_controller/src/pan_cam.rs
rename to crates/bevy_camera_controller/src/pan_camera.rs
index 2d79c8b818ff5..283bd10562a50 100644
--- a/crates/bevy_camera_controller/src/pan_cam.rs
+++ b/crates/bevy_camera_controller/src/pan_camera.rs
@@ -1,9 +1,9 @@
-//! A camera controller for 2D scenes that supports panning and zooming.
+//! A controller for 2D cameras that supports panning, zooming, and rotation.
 //!
-//! To use this controller, add [`PanCamPlugin`] to your app,
-//! and insert a [`PanCam`] component into your camera entity.
+//! To use this controller, add [`PanCameraPlugin`] to your app,
+//! and insert a [`PanCamera`] component into your camera entity.
 //!
-//! To configure the settings of this controller, modify the fields of the [`PanCam`] component.
+//! To configure the settings of this controller, modify the fields of the [`PanCamera`] component.
 
 use bevy_app::{App, Plugin, RunFixedMainLoop, RunFixedMainLoopSystems};
 use bevy_camera::Camera;
@@ -17,28 +17,28 @@ use bevy_transform::prelude::Transform;
 
 use core::{f32::consts::*, fmt};
 
-/// A pancam-style camera controller plugin.
+/// A plugin that enables 2D camera panning and zooming controls.
 ///
-/// Use [`PanCam`] to add a pancam controller to a camera entity,
-/// and change its values to customize the controls and change its behavior.
-pub struct PanCamPlugin;
+/// Add this plugin to your [`App`] to enable [`PanCamera`] behavior
+/// on any camera entity that has the [`PanCamera`] component.
+pub struct PanCameraPlugin;
 
-impl Plugin for PanCamPlugin {
+impl Plugin for PanCameraPlugin {
     fn build(&self, app: &mut App) {
         app.add_systems(
             RunFixedMainLoop,
-            run_pancam_controller.in_set(RunFixedMainLoopSystems::BeforeFixedMainLoop),
+            run_pancamera_controller.in_set(RunFixedMainLoopSystems::BeforeFixedMainLoop),
         );
     }
 }
 
-/// Pancam controller settings and state.
+/// Configuration and state for a 2D panning camera controller.
 ///
-/// Add this component to a [`Camera`] entity and add [`PanCamPlugin`]
-/// to your [`App`] to enable pancam controls.
+/// Add this component to a [`Camera`] entity to enable keyboard and mouse controls
+/// for panning, zooming, and optional rotation. Requires the [`PanCameraPlugin`].
 #[derive(Component)]
-pub struct PanCam {
-    /// Enables this [`PanCam`] when `true`.
+pub struct PanCamera {
+    /// Enables this [`PanCamera`] when `true`.
     pub enabled: bool,
     /// Current zoom level (factor applied to camera scale).
     pub zoom_factor: f32,
@@ -46,13 +46,13 @@ pub struct PanCam {
     pub min_zoom: f32,
     /// Maximum allowed zoom level.
     pub max_zoom: f32,
-    /// This [`PanCam`]'s zoom sensitivity.
+    /// Translation speed for panning movement.
     pub zoom_speed: f32,
     /// [`KeyCode`] to zoom in.
     pub key_zoom_in: Option<KeyCode>,
     /// [`KeyCode`] to zoom out.
     pub key_zoom_out: Option<KeyCode>,
-    /// This [`PanCam`]'s translation speed.
+    /// This [`PanCamera`]'s translation speed.
     pub pan_speed: f32,
     /// [`KeyCode`] for upward translation.
     pub key_up: Option<KeyCode>,
@@ -70,7 +70,7 @@ pub struct PanCam {
     pub key_rotate_cw: Option<KeyCode>,
 }
 
-/// Provides the default values for the `PanCam` controller.
+/// Provides the default values for the `PanCamera` controller.
 ///
 /// The default settings are:
 /// - Zoom factor: 1.0
@@ -83,10 +83,10 @@ pub struct PanCam {
 /// - Move left/right: A/D
 /// - Rotation speed: PI (radiradians per second)
 /// - Rotation ccw/cw: Q/E
-impl Default for PanCam {
-    /// Provides the default values for the `PanCam` controller.
+impl Default for PanCamera {
+    /// Provides the default values for the `PanCamera` controller.
     ///
-    /// Users can override these values by manually creating a `PanCam` instance
+    /// Users can override these values by manually creating a `PanCamera` instance
     /// or modifying the default instance.
     fn default() -> Self {
         Self {
@@ -109,18 +109,18 @@ impl Default for PanCam {
     }
 }
 
-impl PanCam {
+impl PanCamera {
     fn key_to_string(key: &Option<KeyCode>) -> String {
         key.map_or("None".to_string(), |k| format!("{:?}", k))
     }
 }
 
-impl fmt::Display for PanCam {
+impl fmt::Display for PanCamera {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         write!(
             f,
             "
-PanCam Controls:
+PanCamera Controls:
   Move Up / Down    - {} / {}
   Move Left / Right - {} / {}
   Rotate CCW / CW   - {} / {}
@@ -138,18 +138,18 @@ PanCam Controls:
     }
 }
 
-/// This system is typically added via the [`PanCamPlugin`].
+/// This system is typically added via the [`PanCameraPlugin`].
 ///
 /// Reads inputs and then moves the camera entity according
-/// to the settings given in [`PanCam`].
+/// to the settings given in [`PanCamera`].
 ///
 /// **Note**: The zoom applied in this controller is linear. The zoom factor is directly adjusted
 /// based on the input (either from the mouse scroll or keyboard).
-fn run_pancam_controller(
+fn run_pancamera_controller(
     time: Res<Time<Real>>,
     key_input: Res<ButtonInput<KeyCode>>,
     accumulated_mouse_scroll: Res<AccumulatedMouseScroll>,
-    mut query: Query<(&mut Transform, &mut PanCam), With<Camera>>,
+    mut query: Query<(&mut Transform, &mut PanCamera), With<Camera>>,
 ) {
     let dt = time.delta_secs();
 
diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index 0a477401e207b..d8ef5050f0a57 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -309,8 +309,8 @@ bevy_dev_tools = ["dep:bevy_dev_tools"]
 
 # Provides a collection of prebuilt camera controllers
 bevy_camera_controller = ["dep:bevy_camera_controller"]
-free_cam = ["bevy_camera_controller/free_cam"]
-pan_cam = ["bevy_camera_controller/pan_cam"]
+free_camera = ["bevy_camera_controller/free_camera"]
+pan_camera = ["bevy_camera_controller/pan_camera"]
 
 # Enable support for the Bevy Remote Protocol
 bevy_remote = ["dep:bevy_remote", "serialize"]
diff --git a/docs/cargo_features.md b/docs/cargo_features.md
index eed65e7833613..3238b54ab792b 100644
--- a/docs/cargo_features.md
+++ b/docs/cargo_features.md
@@ -124,7 +124,7 @@ This is the complete `bevy` cargo feature list, without "profiles" or "collectio
 |file_watcher|Enables watching the filesystem for Bevy Asset hot-reloading|
 |flac|FLAC audio format support|
 |force_disable_dlss|Forcibly disable DLSS so that cargo build --all-features works without the DLSS SDK being installed. Not meant for users.|
-|free_cam|Enables the free cam from bevy_camera_controller|
+|free_camera|Enables the free cam from bevy_camera_controller|
 |ghost_nodes|Experimental support for nodes that are ignored for UI layouting|
 |gif|GIF image format support|
 |glam_assert|Enable assertions to check the validity of parameters passed to glam|
@@ -144,7 +144,7 @@ This is the complete `bevy` cargo feature list, without "profiles" or "collectio
 |morph_animation|Enables bevy_mesh and bevy_animation morph weight support|
 |mp3|MP3 audio format support|
 |multi_threaded|Enables multithreaded parallelism in the engine. Disabling it forces all engine tasks to run on a single thread.|
-|pan_cam|Enables the pan cam from bevy_camera_controller|
+|pan_camera|Enables the pan camera from bevy_camera_controller|
 |pbr_anisotropy_texture|Enable support for anisotropy texture in the `StandardMaterial`, at the risk of blowing past the global, per-shader texture limit on older/lower-end GPUs|
 |pbr_clustered_decals|Enable support for Clustered Decals|
 |pbr_light_textures|Enable support for Light Textures|
diff --git a/examples/3d/decal.rs b/examples/3d/decal.rs
index 3a5328acf6c06..623227cf2ffd9 100644
--- a/examples/3d/decal.rs
+++ b/examples/3d/decal.rs
@@ -3,7 +3,7 @@
 
 use bevy::{
     anti_alias::fxaa::Fxaa,
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
     core_pipeline::prepass::DepthPrepass,
     pbr::decal::{ForwardDecal, ForwardDecalMaterial, ForwardDecalMaterialExt},
     prelude::*,
@@ -13,7 +13,7 @@ use rand_chacha::ChaCha8Rng;
 
 fn main() {
     App::new()
-        .add_plugins((DefaultPlugins, FreeCamPlugin))
+        .add_plugins((DefaultPlugins, FreeCameraPlugin))
         .add_systems(Startup, setup)
         .run();
 }
@@ -44,7 +44,7 @@ fn setup(
     commands.spawn((
         Name::new("Camera"),
         Camera3d::default(),
-        FreeCam::default(),
+        FreeCamera::default(),
         // Must enable the depth prepass to render forward decals
         DepthPrepass,
         // Must disable MSAA to use decals on WebGPU
diff --git a/examples/3d/meshlet.rs b/examples/3d/meshlet.rs
index 1b7ce67c387ca..e707de6ed8837 100644
--- a/examples/3d/meshlet.rs
+++ b/examples/3d/meshlet.rs
@@ -3,7 +3,7 @@
 // Note: This example showcases the meshlet API, but is not the type of scene that would benefit from using meshlets.
 
 use bevy::{
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
     light::{CascadeShadowConfigBuilder, DirectionalLightShadowMap},
     pbr::experimental::meshlet::{MeshletMesh3d, MeshletPlugin},
     prelude::*,
@@ -23,7 +23,7 @@ fn main() {
                 cluster_buffer_slots: 1 << 14,
             },
             MaterialPlugin::<MeshletDebugMaterial>::default(),
-            FreeCamPlugin,
+            FreeCameraPlugin,
         ))
         .add_systems(Startup, setup)
         .run();
@@ -46,7 +46,7 @@ fn setup(
             intensity: 150.0,
             ..default()
         },
-        FreeCam::default(),
+        FreeCamera::default(),
     ));
 
     commands.spawn((
diff --git a/examples/3d/parallax_mapping.rs b/examples/3d/parallax_mapping.rs
index 752b0a7b97fcc..dad166adf61ef 100644
--- a/examples/3d/parallax_mapping.rs
+++ b/examples/3d/parallax_mapping.rs
@@ -29,7 +29,7 @@ struct Spin {
 
 /// The camera, used to move camera on click.
 #[derive(Component)]
-struct FreeCamController;
+struct FreeCameraController;
 
 const DEPTH_CHANGE_RATE: f32 = 0.1;
 const DEPTH_UPDATE_STEP: f32 = 0.03;
@@ -185,7 +185,7 @@ const CAMERA_POSITIONS: &[Transform] = &[
 ];
 
 fn move_camera(
-    mut camera: Single<&mut Transform, With<FreeCamController>>,
+    mut camera: Single<&mut Transform, With<FreeCameraController>>,
     mut current_view: Local<usize>,
     button: Res<ButtonInput<MouseButton>>,
 ) {
@@ -217,7 +217,7 @@ fn setup(
     commands.spawn((
         Camera3d::default(),
         Transform::from_xyz(1.5, 1.5, 1.5).looking_at(Vec3::ZERO, Vec3::Y),
-        FreeCamController,
+        FreeCameraController,
     ));
 
     // represent the light source as a sphere
diff --git a/examples/3d/shadow_biases.rs b/examples/3d/shadow_biases.rs
index a309b328e4e09..2e07209ffa41a 100644
--- a/examples/3d/shadow_biases.rs
+++ b/examples/3d/shadow_biases.rs
@@ -1,7 +1,7 @@
 //! Demonstrates how shadow biases affect shadows in a 3d scene.
 
 use bevy::{
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
     light::ShadowFilteringMethod,
     prelude::*,
 };
@@ -9,7 +9,7 @@ use bevy::{
 fn main() {
     App::new()
         .add_plugins(DefaultPlugins)
-        .add_plugins(FreeCamPlugin)
+        .add_plugins(FreeCameraPlugin)
         .add_systems(Startup, setup)
         .add_systems(
             Update,
@@ -68,7 +68,7 @@ fn setup(
     commands.spawn((
         Camera3d::default(),
         Transform::from_xyz(-1.0, 1.0, 1.0).looking_at(Vec3::new(-1.0, 1.0, 0.0), Vec3::Y),
-        FreeCam::default(),
+        FreeCamera::default(),
         ShadowFilteringMethod::Hardware2x2,
     ));
 
diff --git a/examples/3d/skybox.rs b/examples/3d/skybox.rs
index 31fdcc8872262..07ce649b2bded 100644
--- a/examples/3d/skybox.rs
+++ b/examples/3d/skybox.rs
@@ -2,7 +2,7 @@
 
 use bevy::{
     anti_alias::taa::TemporalAntiAliasing,
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
     core_pipeline::Skybox,
     image::CompressedImageFormats,
     pbr::ScreenSpaceAmbientOcclusion,
@@ -36,7 +36,7 @@ const CUBEMAPS: &[(&str, CompressedImageFormats)] = &[
 fn main() {
     App::new()
         .add_plugins(DefaultPlugins)
-        .add_plugins(FreeCamPlugin)
+        .add_plugins(FreeCameraPlugin)
         .add_systems(Startup, setup)
         .add_systems(
             Update,
@@ -74,7 +74,7 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
         TemporalAntiAliasing::default(),
         ScreenSpaceAmbientOcclusion::default(),
         Transform::from_xyz(0.0, 0.0, 8.0).looking_at(Vec3::ZERO, Vec3::Y),
-        FreeCam::default(),
+        FreeCamera::default(),
         Skybox {
             image: skybox_handle.clone(),
             brightness: 1000.0,
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 547bc68dfae81..6449b40d2bb66 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -3,7 +3,7 @@
 use argh::FromArgs;
 use bevy::{
     camera::CameraMainTextureUsages,
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
     gltf::GltfMaterialName,
     prelude::*,
     render::render_resource::TextureUsages,
@@ -38,7 +38,7 @@ fn main() {
         "5417916c-0291-4e3f-8f65-326c1858ab96" // Don't copy paste this - generate your own UUID!
     )));
 
-    app.add_plugins((DefaultPlugins, SolariPlugins, FreeCamPlugin))
+    app.add_plugins((DefaultPlugins, SolariPlugins, FreeCameraPlugin))
         .insert_resource(args)
         .add_systems(Startup, setup);
 
@@ -115,7 +115,7 @@ fn setup(
             clear_color: ClearColorConfig::Custom(Color::BLACK),
             ..default()
         },
-        FreeCam {
+        FreeCamera {
             walk_speed: 3.0,
             run_speed: 10.0,
             ..Default::default()
diff --git a/examples/README.md b/examples/README.md
index 056f737351f95..a04524e21cd7d 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -285,8 +285,8 @@ Example | Description
 [Camera Orbit](../examples/camera/camera_orbit.rs) | Shows how to orbit a static scene using pitch, yaw, and roll.
 [Custom Projection](../examples/camera/custom_projection.rs) | Shows how to create custom camera projections.
 [First person view model](../examples/camera/first_person_view_model.rs) | A first-person camera that uses a world model and a view model with different field of views (FOV)
-[Free cam camera controller](../examples/camera/free_cam_controller.rs) | Shows the default free cam camera controller.
-[Pan Cam](../examples/camera/pan_cam_controller.rs) | Example Pan-Cam Styled Camera Controller for 2D scenes
+[Free Camera controller](../examples/camera/free_camera_controller.rs) | Demonstrates the FreeCamera controller for 3D scenes.
+[Pan Camera](../examples/camera/pan_camera_controller.rs) | Example Pan-Camera Styled Camera Controller for 2D scenes
 [Projection Zoom](../examples/camera/projection_zoom.rs) | Shows how to zoom orthographic and perspective projection cameras.
 [Screen Shake](../examples/camera/2d_screen_shake.rs) | A simple 2D screen shake effect
 
diff --git a/examples/camera/free_cam_controller.rs b/examples/camera/free_camera_controller.rs
similarity index 80%
rename from examples/camera/free_cam_controller.rs
rename to examples/camera/free_camera_controller.rs
index 05240e5c4e9c4..d7ebde14629aa 100644
--- a/examples/camera/free_cam_controller.rs
+++ b/examples/camera/free_camera_controller.rs
@@ -1,14 +1,14 @@
-//! This example showcases the default freecam camera controller.
+//! This example showcases the default `FreeCamera` camera controller.
 //!
-//! The default freecam controller is useful for exploring large scenes, debugging and editing purposes. To use it,
-//! simply add the [`FreeCamPlugin`] to your [`App`] and attach the [`FreeCam`] component to the camera entity you
+//! The default `FreeCamera` controller is useful for exploring large scenes, debugging and editing purposes. To use it,
+//! simply add the [`FreeCameraPlugin`] to your [`App`] and attach the [`FreeCamera`] component to the camera entity you
 //! wish to control.
 //!
 //! ## Default Controls
 //!
 //! This controller has a simple 6-axis control scheme, and mouse controls for camera orientation. There are also
 //! bindings for capturing the mouse, both while holding the button and toggle, a run feature that increases the
-//! max speed, and scrolling changes the movement speed. All keybinds can be changed by editing the [`FreeCam`]
+//! max speed, and scrolling changes the movement speed. All keybinds can be changed by editing the [`FreeCamera`]
 //! component.
 //!
 //! | Default Key Binding | Action                 |
@@ -21,7 +21,7 @@
 //! | Left shift          | Run                    |
 //! | Scroll wheel        | Change movement speed  |
 //!
-//! The movement speed, sensitivity and friction can also be changed by the [`FreeCam`] component.
+//! The movement speed, sensitivity and friction can also be changed by the [`FreeCamera`] component.
 //!
 //! ## Example controls
 //!
@@ -41,7 +41,7 @@
 use std::f32::consts::{FRAC_PI_4, PI};
 
 use bevy::{
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin, FreeCamState},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin, FreeCameraState},
     color::palettes::tailwind,
     prelude::*,
 };
@@ -49,8 +49,8 @@ use bevy::{
 fn main() {
     App::new()
         .add_plugins(DefaultPlugins)
-        // Plugin that enables freecam functionality
-        .add_plugins(FreeCamPlugin)
+        // Plugin that enables FreeCamera functionality
+        .add_plugins(FreeCameraPlugin)
         // Example code plugins
         .add_plugins((CameraPlugin, CameraSettingsPlugin, ScenePlugin))
         .run();
@@ -68,10 +68,10 @@ fn spawn_camera(mut commands: Commands) {
     commands.spawn((
         Camera3d::default(),
         Transform::from_xyz(0.0, 1.0, 0.0).looking_to(Vec3::X, Vec3::Y),
-        // This component stores all camera settings and state, which is used by the FreeCamPlugin to
+        // This component stores all camera settings and state, which is used by the FreeCameraPlugin to
         // control it. These properties can be changed at runtime, but beware the controller system is
         // constantly using and modifying those values unless the enabled field is false.
-        FreeCam {
+        FreeCamera {
             sensitivity: 0.2,
             friction: 25.0,
             walk_speed: 3.0,
@@ -93,7 +93,7 @@ impl Plugin for CameraSettingsPlugin {
 #[derive(Component)]
 struct InfoText;
 
-fn spawn_text(mut commands: Commands, freecam_query: Query<&FreeCam>) {
+fn spawn_text(mut commands: Commands, free_camera_query: Query<&FreeCamera>) {
     commands.spawn((
         Node {
             position_type: PositionType::Absolute,
@@ -101,7 +101,10 @@ fn spawn_text(mut commands: Commands, freecam_query: Query<&FreeCam>) {
             left: px(12),
             ..default()
         },
-        children![Text::new(format!("{}", freecam_query.single().unwrap()))],
+        children![Text::new(format!(
+            "{}",
+            free_camera_query.single().unwrap()
+        ))],
     ));
     commands.spawn((
         Node {
@@ -131,51 +134,51 @@ fn spawn_text(mut commands: Commands, freecam_query: Query<&FreeCam>) {
 }
 
 fn update_camera_settings(
-    mut camera_query: Query<(&mut FreeCam, &mut FreeCamState)>,
+    mut camera_query: Query<(&mut FreeCamera, &mut FreeCameraState)>,
     input: Res<ButtonInput<KeyCode>>,
 ) {
-    let (mut free_cam, mut free_cam_state) = camera_query.single_mut().unwrap();
+    let (mut free_camera, mut free_camera_state) = camera_query.single_mut().unwrap();
 
     if input.pressed(KeyCode::KeyZ) {
-        free_cam.sensitivity = (free_cam.sensitivity - 0.005).max(0.005);
+        free_camera.sensitivity = (free_camera.sensitivity - 0.005).max(0.005);
     }
     if input.pressed(KeyCode::KeyX) {
-        free_cam.sensitivity += 0.005;
+        free_camera.sensitivity += 0.005;
     }
     if input.pressed(KeyCode::KeyC) {
-        free_cam.friction = (free_cam.friction - 0.2).max(0.0);
+        free_camera.friction = (free_camera.friction - 0.2).max(0.0);
     }
     if input.pressed(KeyCode::KeyV) {
-        free_cam.friction += 0.2;
+        free_camera.friction += 0.2;
     }
     if input.pressed(KeyCode::KeyF) {
-        free_cam.scroll_factor = (free_cam.scroll_factor - 0.02).max(0.02);
+        free_camera.scroll_factor = (free_camera.scroll_factor - 0.02).max(0.02);
     }
     if input.pressed(KeyCode::KeyG) {
-        free_cam.scroll_factor += 0.02;
+        free_camera.scroll_factor += 0.02;
     }
     if input.just_pressed(KeyCode::KeyB) {
-        free_cam_state.enabled = !free_cam_state.enabled;
+        free_camera_state.enabled = !free_camera_state.enabled;
     }
 }
 
 fn update_text(
     mut text_query: Query<&mut Text, With<InfoText>>,
-    camera_query: Query<(&FreeCam, &FreeCamState)>,
+    camera_query: Query<(&FreeCamera, &FreeCameraState)>,
 ) {
     let mut text = text_query.single_mut().unwrap();
 
-    let (free_cam, free_cam_state) = camera_query.single().unwrap();
+    let (free_camera, free_camera_state) = camera_query.single().unwrap();
 
     text.0 = format!(
         "Enabled: {},\nSensitivity: {:.03}\nFriction: {:.01}\nScroll factor: {:.02}\nWalk Speed: {:.02}\nRun Speed: {:.02}\nSpeed: {:.02}",
-        free_cam_state.enabled,
-        free_cam.sensitivity,
-        free_cam.friction,
-        free_cam.scroll_factor,
-        free_cam.walk_speed,
-        free_cam.run_speed,
-        free_cam_state.velocity.length(),
+        free_camera_state.enabled,
+        free_camera.sensitivity,
+        free_camera.friction,
+        free_camera.scroll_factor,
+        free_camera.walk_speed,
+        free_camera.run_speed,
+        free_camera_state.velocity.length(),
     );
 }
 
diff --git a/examples/camera/pan_cam_controller.rs b/examples/camera/pan_camera_controller.rs
similarity index 60%
rename from examples/camera/pan_cam_controller.rs
rename to examples/camera/pan_camera_controller.rs
index effda2944e7eb..adac25d0e1111 100644
--- a/examples/camera/pan_cam_controller.rs
+++ b/examples/camera/pan_camera_controller.rs
@@ -1,26 +1,26 @@
-//! Example for `PanCam`, demonstrating basic camera controls such as panning and zooming.
+//! Example for `PanCamera`, demonstrating basic camera controls such as panning and zooming.
 //!
-//! This example shows how to use the `PanCam` controller on a 2D camera in Bevy. The camera
+//! This example shows how to use the `PanCamera` controller on a 2D camera in Bevy. The camera
 //! can be panned with keyboard inputs (arrow keys or WASD) and zoomed in/out using the mouse
-//! wheel or the +/- keys. The camera starts with the default `PanCam` settings, which can
+//! wheel or the +/- keys. The camera starts with the default `PanCamera` settings, which can
 //! be customized.
 //!
 //! Controls:
 //! - Arrow keys (or WASD) to pan the camera.
 //! - Mouse scroll wheel or +/- to zoom in/out.
 
-use bevy::camera_controller::pan_cam::{PanCam, PanCamPlugin};
+use bevy::camera_controller::pan_camera::{PanCamera, PanCameraPlugin};
 use bevy::prelude::*;
 
 fn main() {
     App::new()
         .add_plugins(DefaultPlugins)
-        .add_plugins(PanCamPlugin) // Adds the PanCam plugin to enable camera panning and zooming controls.
+        .add_plugins(PanCameraPlugin) // Adds the PanCamera plugin to enable camera panning and zooming controls.
         .add_systems(Startup, (setup, spawn_text).chain())
         .run();
 }
 
-fn spawn_text(mut commands: Commands, camera: Query<&PanCam>) {
+fn spawn_text(mut commands: Commands, camera: Query<&PanCamera>) {
     commands.spawn((
         Node {
             position_type: PositionType::Absolute,
@@ -33,8 +33,8 @@ fn spawn_text(mut commands: Commands, camera: Query<&PanCam>) {
 }
 
 fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
-    // Spawn a 2D Camera with default PanCam settings
-    commands.spawn((Camera2d, PanCam::default()));
+    // Spawn a 2D Camera with default PanCamera settings
+    commands.spawn((Camera2d, PanCamera::default()));
 
     commands.spawn(Sprite::from_image(
         asset_server.load("branding/bevy_bird_dark.png"),
diff --git a/examples/gizmos/3d_gizmos.rs b/examples/gizmos/3d_gizmos.rs
index a28c571101086..6297f5e2530a6 100644
--- a/examples/gizmos/3d_gizmos.rs
+++ b/examples/gizmos/3d_gizmos.rs
@@ -1,7 +1,7 @@
 //! This example demonstrates Bevy's immediate mode drawing API intended for visual debugging.
 
 use bevy::{
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
     color::palettes::css::*,
     prelude::*,
 };
@@ -9,7 +9,7 @@ use std::f32::consts::PI;
 
 fn main() {
     App::new()
-        .add_plugins((DefaultPlugins, FreeCamPlugin))
+        .add_plugins((DefaultPlugins, FreeCameraPlugin))
         .init_gizmo_group::<MyRoundGizmos>()
         .add_systems(Startup, setup)
         .add_systems(Update, (draw_example_collection, update_config))
@@ -52,7 +52,7 @@ fn setup(
     commands.spawn((
         Camera3d::default(),
         Transform::from_xyz(0., 1.5, 6.).looking_at(Vec3::ZERO, Vec3::Y),
-        FreeCam::default(),
+        FreeCamera::default(),
     ));
     // plane
     commands.spawn((
diff --git a/examples/tools/scene_viewer/main.rs b/examples/tools/scene_viewer/main.rs
index 7c2ba31247d5f..7a33843c78626 100644
--- a/examples/tools/scene_viewer/main.rs
+++ b/examples/tools/scene_viewer/main.rs
@@ -12,7 +12,7 @@ use argh::FromArgs;
 use bevy::{
     asset::UnapprovedPathMode,
     camera::primitives::{Aabb, Sphere},
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
     core_pipeline::prepass::{DeferredPrepass, DepthPrepass},
     gltf::GltfPlugin,
     pbr::DefaultOpaqueRendererMethod,
@@ -95,7 +95,7 @@ fn main() {
                 use_model_forward_direction: args.use_model_forward_direction.unwrap_or(false),
                 ..default()
             }),
-        FreeCamPlugin,
+        FreeCameraPlugin,
         SceneViewerPlugin,
         MorphViewerPlugin,
     ))
@@ -175,7 +175,7 @@ fn setup_scene_after_load(
         projection.far = projection.far.max(size * 10.0);
 
         let walk_speed = size * 3.0;
-        let camera_controller = FreeCam {
+        let camera_controller = FreeCamera {
             walk_speed,
             run_speed: 3.0 * walk_speed,
             ..default()
diff --git a/examples/tools/scene_viewer/scene_viewer_plugin.rs b/examples/tools/scene_viewer/scene_viewer_plugin.rs
index 8ac99bf942c3d..7565307003c66 100644
--- a/examples/tools/scene_viewer/scene_viewer_plugin.rs
+++ b/examples/tools/scene_viewer/scene_viewer_plugin.rs
@@ -4,8 +4,8 @@
 //! - Insert an initialized `SceneHandle` resource into your App's `AssetServer`.
 
 use bevy::{
-    camera_controller::free_cam::FreeCam, gltf::Gltf, input::common_conditions::input_just_pressed,
-    prelude::*, scene::InstanceId,
+    camera_controller::free_camera::FreeCamera, gltf::Gltf,
+    input::common_conditions::input_just_pressed, prelude::*, scene::InstanceId,
 };
 
 use std::{f32::consts::*, fmt};
@@ -199,8 +199,8 @@ fn camera_tracker(
     mut camera_tracker: ResMut<CameraTracker>,
     keyboard_input: Res<ButtonInput<KeyCode>>,
     mut queries: ParamSet<(
-        Query<(Entity, &mut Camera), (Added<Camera>, Without<FreeCam>)>,
-        Query<(Entity, &mut Camera), (Added<Camera>, With<FreeCam>)>,
+        Query<(Entity, &mut Camera), (Added<Camera>, Without<FreeCamera>)>,
+        Query<(Entity, &mut Camera), (Added<Camera>, With<FreeCamera>)>,
         Query<&mut Camera>,
     )>,
 ) {
diff --git a/release-content/release-notes/camera_controllers.md b/release-content/release-notes/camera_controllers.md
index d6968d34043b2..599ac905bf9dc 100644
--- a/release-content/release-notes/camera_controllers.md
+++ b/release-content/release-notes/camera_controllers.md
@@ -20,30 +20,30 @@ To that end, we've created `bevy_camera_controller`: giving us a place to store,
 that we need for easy development, and yes, an eventual Editor.
 We're kicking it off with a couple of camera controllers, detailed below.
 
-### `FreeCam`
+### `FreeCamera`
 
-The first camera controller that we've introduced is a "free cam", designed for quickly moving around a scene,
+The first camera controller that we've introduced is a "free camera", designed for quickly moving around a scene,
 completely ignoring both physics and geometry.
-You may have heard of a "flycam" controller before, which is a specialization of a "free cam" controller
+You may have heard of a "fly camera" controller before, which is a specialization of a "free camera" controller
 designed for fast and fluid movement for covering large amounts of terrain.
 
-To add a free cam controller to your project (typically under a `dev_mode` feature flag),
-add the `FreeCamPlugin` and the `FreeCam` component to your camera entity.
+To add a free camera controller to your project (typically under a `dev_mode` feature flag),
+add the `FreeCameraPlugin` and the `FreeCamera` component to your camera entity.
 
-To configure the settings (speed, behavior, keybindings) or enable / disable the controller modify the `FreeCam` component.
+To configure the settings (speed, behavior, keybindings) or enable / disable the controller modify the `FreeCamera` component.
 We've done our best to select good defaults, but the details of your scene (especially the scale!) will make a big
 difference to what feels right.
 
-### `PanCam`
+### `PanCamera`
 
-The `PanCam` controller is a simple and effective tool designed for 2D games or any project where you need
+The `PanCamera` controller is a simple and effective tool designed for 2D games or any project where you need
 to pan the camera and zoom in/out with ease. It allows you to move the camera using the WASD keys and zoom
 in and out with the mouse wheel or +/- keys.
 
-By adding the `PanCamPlugin` and attaching the `PanCam` component to your camera entity, you can quickly add
+By adding the `PanCameraPlugin` and attaching the `PanCamera` component to your camera entity, you can quickly add
 this controller to your project.
 
-To configure the camera's zoom levels, speed, or keybindings, simply modify the `PanCam` component. The default
+To configure the camera's zoom levels, speed, or keybindings, simply modify the `PanCamera` component. The default
 settings should work well for most use cases, but you can adjust them based on your specific needs, especially
 for large-scale or high-resolution 2D scenes.
 
