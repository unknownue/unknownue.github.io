diff --git a/crates/bevy_ecs/src/entity_disabling.rs b/crates/bevy_ecs/src/entity_disabling.rs
index 2460d72ab64d2..dd116e882278e 100644
--- a/crates/bevy_ecs/src/entity_disabling.rs
+++ b/crates/bevy_ecs/src/entity_disabling.rs
@@ -308,47 +308,50 @@ mod tests {
     #[derive(Component)]
     struct CustomDisabled;
 
+    #[derive(Component)]
+    struct Dummy;
+
     #[test]
     fn multiple_disabling_components() {
         let mut world = World::new();
         world.register_disabling_component::<CustomDisabled>();
 
         // Use powers of two so we can uniquely identify the set of matching archetypes from the count.
-        world.spawn_empty();
-        world.spawn_batch((0..2).map(|_| Disabled));
-        world.spawn_batch((0..4).map(|_| CustomDisabled));
-        world.spawn_batch((0..8).map(|_| (Disabled, CustomDisabled)));
+        world.spawn(Dummy);
+        world.spawn_batch((0..2).map(|_| (Dummy, Disabled)));
+        world.spawn_batch((0..4).map(|_| (Dummy, CustomDisabled)));
+        world.spawn_batch((0..8).map(|_| (Dummy, Disabled, CustomDisabled)));
 
-        let mut query = world.query::<()>();
+        let mut query = world.query::<&Dummy>();
         assert_eq!(1, query.iter(&world).count());
 
-        let mut query = world.query::<EntityRef>();
+        let mut query = world.query_filtered::<EntityRef, With<Dummy>>();
         assert_eq!(1, query.iter(&world).count());
 
-        let mut query = world.query::<EntityMut>();
+        let mut query = world.query_filtered::<EntityMut, With<Dummy>>();
         assert_eq!(1, query.iter(&world).count());
 
-        let mut query = world.query_filtered::<(), With<Disabled>>();
+        let mut query = world.query_filtered::<&Dummy, With<Disabled>>();
         assert_eq!(2, query.iter(&world).count());
 
-        let mut query = world.query::<Has<Disabled>>();
+        let mut query = world.query_filtered::<Has<Disabled>, With<Dummy>>();
         assert_eq!(3, query.iter(&world).count());
 
-        let mut query = world.query_filtered::<(), With<CustomDisabled>>();
+        let mut query = world.query_filtered::<&Dummy, With<CustomDisabled>>();
         assert_eq!(4, query.iter(&world).count());
 
-        let mut query = world.query::<Has<CustomDisabled>>();
+        let mut query = world.query_filtered::<Has<CustomDisabled>, With<Dummy>>();
         assert_eq!(5, query.iter(&world).count());
 
-        let mut query = world.query_filtered::<(), (With<Disabled>, With<CustomDisabled>)>();
+        let mut query = world.query_filtered::<&Dummy, (With<Disabled>, With<CustomDisabled>)>();
         assert_eq!(8, query.iter(&world).count());
 
-        let mut query = world.query::<(Has<Disabled>, Has<CustomDisabled>)>();
+        let mut query = world.query_filtered::<(Has<Disabled>, Has<CustomDisabled>), With<Dummy>>();
         assert_eq!(15, query.iter(&world).count());
 
         // This seems like it ought to count as a mention of `Disabled`, but it does not.
         // We don't consider read access, since that would count `EntityRef` as a mention of *all* components.
-        let mut query = world.query::<Option<&Disabled>>();
+        let mut query = world.query_filtered::<Option<&Disabled>, With<Dummy>>();
         assert_eq!(1, query.iter(&world).count());
     }
 }
diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index d2f59ac29f83d..a281f4b7d5853 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -1644,11 +1644,9 @@ mod tests {
 
         let mut q1 = world.query::<&A>();
         let mut q2 = world.query::<&SparseStored>();
-        let mut q3 = world.query::<()>();
 
         assert_eq!(q1.query(&world).count(), 1);
         assert_eq!(q2.query(&world).count(), 1);
-        assert_eq!(q3.query(&world).count(), 2);
 
         world.clear_entities();
 
@@ -1662,11 +1660,6 @@ mod tests {
             0,
             "world should not contain sparse set components"
         );
-        assert_eq!(
-            q3.query(&world).count(),
-            0,
-            "world should not have any entities"
-        );
         assert_eq!(
             world.resource::<ResA>().0,
             0,
@@ -1796,7 +1789,7 @@ mod tests {
     fn try_insert_batch() {
         let mut world = World::default();
         let e0 = world.spawn(A(0)).id();
-        let e1 = Entity::from_raw_u32(1).unwrap();
+        let e1 = Entity::from_raw_u32(10_000).unwrap();
 
         let values = vec![(e0, (A(1), B(0))), (e1, (A(0), B(1)))];
 
@@ -1820,7 +1813,7 @@ mod tests {
     fn try_insert_batch_if_new() {
         let mut world = World::default();
         let e0 = world.spawn(A(0)).id();
-        let e1 = Entity::from_raw_u32(1).unwrap();
+        let e1 = Entity::from_raw_u32(10_000).unwrap();
 
         let values = vec![(e0, (A(1), B(0))), (e1, (A(0), B(1)))];
 
diff --git a/crates/bevy_ecs/src/query/builder.rs b/crates/bevy_ecs/src/query/builder.rs
index 8ba34a34f9ee7..4df8a615db617 100644
--- a/crates/bevy_ecs/src/query/builder.rs
+++ b/crates/bevy_ecs/src/query/builder.rs
@@ -288,6 +288,9 @@ mod tests {
     #[derive(Component, PartialEq, Debug)]
     struct C(usize);
 
+    #[derive(Component)]
+    struct D;
+
     #[test]
     fn builder_with_without_static() {
         let mut world = World::new();
@@ -332,11 +335,11 @@ mod tests {
     #[test]
     fn builder_or() {
         let mut world = World::new();
-        world.spawn((A(0), B(0)));
-        world.spawn(B(0));
-        world.spawn(C(0));
+        world.spawn((A(0), B(0), D));
+        world.spawn((B(0), D));
+        world.spawn((C(0), D));
 
-        let mut query_a = QueryBuilder::<Entity>::new(&mut world)
+        let mut query_a = QueryBuilder::<&D>::new(&mut world)
             .or(|builder| {
                 builder.with::<A>();
                 builder.with::<B>();
@@ -344,7 +347,7 @@ mod tests {
             .build();
         assert_eq!(2, query_a.iter(&world).count());
 
-        let mut query_b = QueryBuilder::<Entity>::new(&mut world)
+        let mut query_b = QueryBuilder::<&D>::new(&mut world)
             .or(|builder| {
                 builder.with::<A>();
                 builder.without::<B>();
@@ -353,7 +356,7 @@ mod tests {
         dbg!(&query_b.component_access);
         assert_eq!(2, query_b.iter(&world).count());
 
-        let mut query_c = QueryBuilder::<Entity>::new(&mut world)
+        let mut query_c = QueryBuilder::<&D>::new(&mut world)
             .or(|builder| {
                 builder.with::<A>();
                 builder.with::<B>();
@@ -426,13 +429,15 @@ mod tests {
     #[test]
     fn builder_provide_access() {
         let mut world = World::new();
-        world.spawn((A(0), B(1)));
+        world.spawn((A(0), B(1), D));
 
         let mut query =
-            QueryBuilder::<(Entity, FilteredEntityRef, FilteredEntityMut)>::new(&mut world)
-                .data::<&mut A>()
-                .data::<&B>()
-                .build();
+            QueryBuilder::<(Entity, FilteredEntityRef, FilteredEntityMut), With<D>>::new(
+                &mut world,
+            )
+            .data::<&mut A>()
+            .data::<&B>()
+            .build();
 
         // The `FilteredEntityRef` only has read access, so the `FilteredEntityMut` can have read access without conflicts
         let (_entity, entity_ref_1, mut entity_ref_2) = query.single_mut(&mut world).unwrap();
@@ -444,10 +449,12 @@ mod tests {
         assert!(entity_ref_2.get_mut::<B>().is_none());
 
         let mut query =
-            QueryBuilder::<(Entity, FilteredEntityMut, FilteredEntityMut)>::new(&mut world)
-                .data::<&mut A>()
-                .data::<&B>()
-                .build();
+            QueryBuilder::<(Entity, FilteredEntityMut, FilteredEntityMut), With<D>>::new(
+                &mut world,
+            )
+            .data::<&mut A>()
+            .data::<&B>()
+            .build();
 
         // The first `FilteredEntityMut` has write access to A, so the second one cannot have write access
         let (_entity, mut entity_ref_1, mut entity_ref_2) = query.single_mut(&mut world).unwrap();
@@ -460,7 +467,7 @@ mod tests {
         assert!(entity_ref_2.get::<B>().is_some());
         assert!(entity_ref_2.get_mut::<B>().is_none());
 
-        let mut query = QueryBuilder::<(FilteredEntityMut, &mut A, &B)>::new(&mut world)
+        let mut query = QueryBuilder::<(FilteredEntityMut, &mut A, &B), With<D>>::new(&mut world)
             .data::<&mut A>()
             .data::<&mut B>()
             .build();
@@ -472,7 +479,7 @@ mod tests {
         assert!(entity_ref.get::<B>().is_some());
         assert!(entity_ref.get_mut::<B>().is_none());
 
-        let mut query = QueryBuilder::<(FilteredEntityMut, &mut A, &B)>::new(&mut world)
+        let mut query = QueryBuilder::<(FilteredEntityMut, &mut A, &B), With<D>>::new(&mut world)
             .data::<EntityMut>()
             .build();
 
@@ -483,9 +490,10 @@ mod tests {
         assert!(entity_ref.get::<B>().is_some());
         assert!(entity_ref.get_mut::<B>().is_none());
 
-        let mut query = QueryBuilder::<(FilteredEntityMut, EntityMutExcept<A>)>::new(&mut world)
-            .data::<EntityMut>()
-            .build();
+        let mut query =
+            QueryBuilder::<(FilteredEntityMut, EntityMutExcept<A>), With<D>>::new(&mut world)
+                .data::<EntityMut>()
+                .build();
 
         // Removing `EntityMutExcept<A>` just leaves A
         let (mut entity_ref_1, _entity_ref_2) = query.single_mut(&mut world).unwrap();
@@ -494,9 +502,10 @@ mod tests {
         assert!(entity_ref_1.get::<B>().is_none());
         assert!(entity_ref_1.get_mut::<B>().is_none());
 
-        let mut query = QueryBuilder::<(FilteredEntityMut, EntityRefExcept<A>)>::new(&mut world)
-            .data::<EntityMut>()
-            .build();
+        let mut query =
+            QueryBuilder::<(FilteredEntityMut, EntityRefExcept<A>), With<D>>::new(&mut world)
+                .data::<EntityMut>()
+                .build();
 
         // Removing `EntityRefExcept<A>` just leaves A, plus read access
         let (mut entity_ref_1, _entity_ref_2) = query.single_mut(&mut world).unwrap();
diff --git a/crates/bevy_ecs/src/query/iter.rs b/crates/bevy_ecs/src/query/iter.rs
index 13e69ce3cb969..1b8b8f1d9c4ec 100644
--- a/crates/bevy_ecs/src/query/iter.rs
+++ b/crates/bevy_ecs/src/query/iter.rs
@@ -2658,7 +2658,7 @@ mod tests {
 
     use crate::component::Component;
     use crate::entity::Entity;
-    use crate::prelude::World;
+    use crate::prelude::{With, World};
 
     #[derive(Component, Debug, PartialEq, PartialOrd, Clone, Copy)]
     struct A(f32);
@@ -2666,16 +2666,19 @@ mod tests {
     #[component(storage = "SparseSet")]
     struct Sparse(usize);
 
+    #[derive(Component)]
+    struct Marker;
+
     #[test]
     fn query_iter_sorts() {
         let mut world = World::new();
         for i in 0..100 {
-            world.spawn(A(i as f32));
-            world.spawn((A(i as f32), Sparse(i)));
-            world.spawn(Sparse(i));
+            world.spawn((A(i as f32), Marker));
+            world.spawn((A(i as f32), Sparse(i), Marker));
+            world.spawn((Sparse(i), Marker));
         }
 
-        let mut query = world.query::<Entity>();
+        let mut query = world.query_filtered::<Entity, With<Marker>>();
 
         let sort = query.iter(&world).sort::<Entity>().collect::<Vec<_>>();
         assert_eq!(sort.len(), 300);
diff --git a/crates/bevy_ecs/src/query/state.rs b/crates/bevy_ecs/src/query/state.rs
index 91a979fa2e5e7..045bd841298d8 100644
--- a/crates/bevy_ecs/src/query/state.rs
+++ b/crates/bevy_ecs/src/query/state.rs
@@ -1821,6 +1821,9 @@ mod tests {
     #[derive(Component, PartialEq, Debug)]
     struct C(usize);
 
+    #[derive(Component)]
+    struct D;
+
     #[test]
     fn can_transmute_to_more_general() {
         let mut world = World::new();
@@ -1854,7 +1857,7 @@ mod tests {
         world.register_component::<A>();
         let entity = world.spawn(A(10)).id();
 
-        let q = world.query::<()>();
+        let q = world.query_filtered::<(), With<A>>();
         let mut q = q.transmute::<Entity>(&world);
         assert_eq!(q.single(&world).unwrap(), entity);
     }
@@ -2169,30 +2172,30 @@ mod tests {
     #[test]
     fn query_respects_default_filters() {
         let mut world = World::new();
-        world.spawn((A(0), B(0)));
-        world.spawn((B(0), C(0)));
-        world.spawn(C(0));
+        world.spawn((A(0), B(0), D));
+        world.spawn((B(0), C(0), D));
+        world.spawn((C(0), D));
 
         world.register_disabling_component::<C>();
 
         // Without<C> only matches the first entity
-        let mut query = QueryState::<()>::new(&mut world);
+        let mut query = QueryState::<&D>::new(&mut world);
         assert_eq!(1, query.iter(&world).count());
 
         // With<C> matches the last two entities
-        let mut query = QueryState::<(), With<C>>::new(&mut world);
+        let mut query = QueryState::<&D, With<C>>::new(&mut world);
         assert_eq!(2, query.iter(&world).count());
 
         // Has should bypass the filter entirely
-        let mut query = QueryState::<Has<C>>::new(&mut world);
+        let mut query = QueryState::<(&D, Has<C>)>::new(&mut world);
         assert_eq!(3, query.iter(&world).count());
 
         // Allow should bypass the filter entirely
-        let mut query = QueryState::<(), Allow<C>>::new(&mut world);
+        let mut query = QueryState::<&D, Allow<C>>::new(&mut world);
         assert_eq!(3, query.iter(&world).count());
 
         // Other filters should still be respected
-        let mut query = QueryState::<Has<C>, Without<B>>::new(&mut world);
+        let mut query = QueryState::<(&D, Has<C>), Without<B>>::new(&mut world);
         assert_eq!(1, query.iter(&world).count());
     }
 
@@ -2203,23 +2206,26 @@ mod tests {
     #[component(storage = "SparseSet")]
     struct Sparse;
 
+    #[derive(Component)]
+    struct Dummy;
+
     #[test]
     fn query_default_filters_updates_is_dense() {
         let mut world = World::new();
-        world.spawn((Table, Sparse));
-        world.spawn(Table);
-        world.spawn(Sparse);
+        world.spawn((Dummy, Table, Sparse));
+        world.spawn((Dummy, Table));
+        world.spawn((Dummy, Sparse));
 
-        let mut query = QueryState::<()>::new(&mut world);
+        let mut query = QueryState::<&Dummy>::new(&mut world);
         // There are no sparse components involved thus the query is dense
         assert!(query.is_dense);
         assert_eq!(3, query.query(&world).count());
 
         world.register_disabling_component::<Sparse>();
 
-        let mut query = QueryState::<()>::new(&mut world);
+        let mut query = QueryState::<&Dummy>::new(&mut world);
         // The query doesn't ask for sparse components, but the default filters adds
-        // a sparse components thus it is NOT dense
+        // a sparse component thus it is NOT dense
         assert!(!query.is_dense);
         assert_eq!(1, query.query(&world).count());
 
@@ -2227,7 +2233,7 @@ mod tests {
         df.register_disabling_component(world.register_component::<Table>());
         world.insert_resource(df);
 
-        let mut query = QueryState::<()>::new(&mut world);
+        let mut query = QueryState::<&Dummy>::new(&mut world);
         // If the filter is instead a table components, the query can still be dense
         assert!(query.is_dense);
         assert_eq!(1, query.query(&world).count());
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index 2b9fe4319b973..a0551a4892224 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -1342,14 +1342,14 @@ mod tests {
     #[test]
     fn system_state_spawned() {
         let mut world = World::default();
-        world.spawn_empty();
+        world.spawn(A);
         let spawn_tick = world.change_tick();
 
-        let mut system_state: SystemState<Option<Single<SpawnDetails, Spawned>>> =
+        let mut system_state: SystemState<Option<Single<(&A, SpawnDetails), Spawned>>> =
             SystemState::new(&mut world);
         {
             let query = system_state.get(&world);
-            assert_eq!(query.unwrap().spawn_tick(), spawn_tick);
+            assert_eq!(query.unwrap().1.spawn_tick(), spawn_tick);
         }
 
         {
diff --git a/crates/bevy_ecs/src/world/entity_access/mod.rs b/crates/bevy_ecs/src/world/entity_access/mod.rs
index aa852d0106260..d8fd509f758e5 100644
--- a/crates/bevy_ecs/src/world/entity_access/mod.rs
+++ b/crates/bevy_ecs/src/world/entity_access/mod.rs
@@ -40,6 +40,9 @@ mod tests {
     #[component(storage = "SparseSet")]
     struct TestComponent2(u32);
 
+    #[derive(Component)]
+    struct Marker;
+
     #[test]
     fn entity_ref_get_by_id() {
         let mut world = World::new();
@@ -465,9 +468,9 @@ mod tests {
         world.register_component::<TestComponent>();
         world.register_component::<TestComponent2>();
 
-        world.spawn(TestComponent(0)).insert(TestComponent2(0));
+        world.spawn((TestComponent(0), TestComponent2(0), Marker));
 
-        let mut query = world.query::<EntityRefExcept<TestComponent>>();
+        let mut query = world.query_filtered::<EntityRefExcept<TestComponent>, With<Marker>>();
 
         let mut found = false;
         for entity_ref in query.iter_mut(&mut world) {
@@ -521,11 +524,14 @@ mod tests {
     #[test]
     fn entity_ref_except_doesnt_conflict() {
         let mut world = World::new();
-        world.spawn(TestComponent(0)).insert(TestComponent2(0));
+        world.spawn((TestComponent(0), TestComponent2(0), Marker));
 
         world.run_system_once(system).unwrap();
 
-        fn system(_: Query<&mut TestComponent>, query: Query<EntityRefExcept<TestComponent>>) {
+        fn system(
+            _: Query<&mut TestComponent, With<Marker>>,
+            query: Query<EntityRefExcept<TestComponent>, With<Marker>>,
+        ) {
             for entity_ref in query.iter() {
                 assert!(matches!(
                     entity_ref.get::<TestComponent2>(),
@@ -540,9 +546,9 @@ mod tests {
     #[test]
     fn entity_mut_except() {
         let mut world = World::new();
-        world.spawn(TestComponent(0)).insert(TestComponent2(0));
+        world.spawn((TestComponent(0), TestComponent2(0), Marker));
 
-        let mut query = world.query::<EntityMutExcept<TestComponent>>();
+        let mut query = world.query_filtered::<EntityMutExcept<TestComponent>, With<Marker>>();
 
         let mut found = false;
         for mut entity_mut in query.iter_mut(&mut world) {
@@ -603,11 +609,14 @@ mod tests {
     #[test]
     fn entity_mut_except_doesnt_conflict() {
         let mut world = World::new();
-        world.spawn(TestComponent(0)).insert(TestComponent2(0));
+        world.spawn((TestComponent(0), TestComponent2(0), Marker));
 
         world.run_system_once(system).unwrap();
 
-        fn system(_: Query<&mut TestComponent>, mut query: Query<EntityMutExcept<TestComponent>>) {
+        fn system(
+            _: Query<&mut TestComponent, With<Marker>>,
+            mut query: Query<EntityMutExcept<TestComponent>, With<Marker>>,
+        ) {
             for mut entity_mut in query.iter_mut() {
                 assert!(entity_mut
                     .get_mut::<TestComponent2>()
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index 8f013b52ec7db..9d60968ffef47 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -69,7 +69,7 @@ use bevy_ptr::{move_as_ptr, MovingPtr, OwningPtr, Ptr};
 use bevy_utils::prelude::DebugName;
 use core::{any::TypeId, fmt};
 use log::warn;
-use unsafe_world_cell::{UnsafeEntityCell, UnsafeWorldCell};
+use unsafe_world_cell::UnsafeWorldCell;
 
 /// Stores and exposes operations on [entities](Entity), [components](Component), resources,
 /// and their associated metadata.
@@ -964,55 +964,6 @@ impl World {
         unsafe { entities.fetch_mut(cell) }
     }
 
-    /// Returns an [`Entity`] iterator of current entities.
-    ///
-    /// This is useful in contexts where you only have read-only access to the [`World`].
-    #[deprecated(since = "0.17.0", note = "use world.query::<EntityRef>()` instead")]
-    #[inline]
-    pub fn iter_entities(&self) -> impl Iterator<Item = EntityRef<'_>> + '_ {
-        self.archetypes.iter().flat_map(|archetype| {
-            archetype
-                .entities_with_location()
-                .map(|(entity, location)| {
-                    // SAFETY: entity exists and location accurately specifies the archetype where the entity is stored.
-                    let cell = UnsafeEntityCell::new(
-                        self.as_unsafe_world_cell_readonly(),
-                        entity,
-                        location,
-                        self.last_change_tick,
-                        self.read_change_tick(),
-                    );
-                    // SAFETY: `&self` gives read access to the entire world.
-                    unsafe { EntityRef::new(cell) }
-                })
-        })
-    }
-
-    /// Returns a mutable iterator over all entities in the `World`.
-    #[deprecated(since = "0.17.0", note = "use world.query::<EntityMut>()` instead")]
-    pub fn iter_entities_mut(&mut self) -> impl Iterator<Item = EntityMut<'_>> + '_ {
-        let last_change_tick = self.last_change_tick;
-        let change_tick = self.change_tick();
-        let world_cell = self.as_unsafe_world_cell();
-        world_cell.archetypes().iter().flat_map(move |archetype| {
-            archetype
-                .entities_with_location()
-                .map(move |(entity, location)| {
-                    // SAFETY: entity exists and location accurately specifies the archetype where the entity is stored.
-                    let cell = UnsafeEntityCell::new(
-                        world_cell,
-                        entity,
-                        location,
-                        last_change_tick,
-                        change_tick,
-                    );
-                    // SAFETY: We have exclusive access to the entire world. We only create one borrow for each entity,
-                    // so none will conflict with one another.
-                    unsafe { EntityMut::new(cell) }
-                })
-        })
-    }
-
     /// Simultaneously provides access to entity data and a command queue, which
     /// will be applied when the world is next flushed.
     ///
@@ -3716,7 +3667,7 @@ mod tests {
         vec::Vec,
     };
     use bevy_ecs_macros::Component;
-    use bevy_platform::collections::{HashMap, HashSet};
+    use bevy_platform::collections::HashSet;
     use bevy_utils::prelude::DebugName;
     use core::{
         any::TypeId,
@@ -4130,127 +4081,6 @@ mod tests {
         );
     }
 
-    #[test]
-    fn iterate_entities() {
-        let mut world = World::new();
-        let mut entity_counters = <HashMap<_, _>>::default();
-
-        let iterate_and_count_entities = |world: &World, entity_counters: &mut HashMap<_, _>| {
-            entity_counters.clear();
-            #[expect(deprecated, reason = "remove this test in 0.17.0")]
-            for entity in world.iter_entities() {
-                let counter = entity_counters.entry(entity.id()).or_insert(0);
-                *counter += 1;
-            }
-        };
-
-        // Adding one entity and validating iteration
-        let ent0 = world.spawn((Foo, Bar, Baz)).id();
-
-        iterate_and_count_entities(&world, &mut entity_counters);
-        assert_eq!(entity_counters[&ent0], 1);
-        assert_eq!(entity_counters.len(), 1);
-
-        // Spawning three more entities and then validating iteration
-        let ent1 = world.spawn((Foo, Bar)).id();
-        let ent2 = world.spawn((Bar, Baz)).id();
-        let ent3 = world.spawn((Foo, Baz)).id();
-
-        iterate_and_count_entities(&world, &mut entity_counters);
-
-        assert_eq!(entity_counters[&ent0], 1);
-        assert_eq!(entity_counters[&ent1], 1);
-        assert_eq!(entity_counters[&ent2], 1);
-        assert_eq!(entity_counters[&ent3], 1);
-        assert_eq!(entity_counters.len(), 4);
-
-        // Despawning first entity and then validating the iteration
-        assert!(world.despawn(ent0));
-
-        iterate_and_count_entities(&world, &mut entity_counters);
-
-        assert_eq!(entity_counters[&ent1], 1);
-        assert_eq!(entity_counters[&ent2], 1);
-        assert_eq!(entity_counters[&ent3], 1);
-        assert_eq!(entity_counters.len(), 3);
-
-        // Spawning three more entities, despawning three and then validating the iteration
-        let ent4 = world.spawn(Foo).id();
-        let ent5 = world.spawn(Bar).id();
-        let ent6 = world.spawn(Baz).id();
-
-        assert!(world.despawn(ent2));
-        assert!(world.despawn(ent3));
-        assert!(world.despawn(ent4));
-
-        iterate_and_count_entities(&world, &mut entity_counters);
-
-        assert_eq!(entity_counters[&ent1], 1);
-        assert_eq!(entity_counters[&ent5], 1);
-        assert_eq!(entity_counters[&ent6], 1);
-        assert_eq!(entity_counters.len(), 3);
-
-        // Despawning remaining entities and then validating the iteration
-        assert!(world.despawn(ent1));
-        assert!(world.despawn(ent5));
-        assert!(world.despawn(ent6));
-
-        iterate_and_count_entities(&world, &mut entity_counters);
-
-        assert_eq!(entity_counters.len(), 0);
-    }
-
-    #[test]
-    fn iterate_entities_mut() {
-        #[derive(Component, PartialEq, Debug)]
-        struct A(i32);
-
-        #[derive(Component, PartialEq, Debug)]
-        struct B(i32);
-
-        let mut world = World::new();
-
-        let a1 = world.spawn(A(1)).id();
-        let a2 = world.spawn(A(2)).id();
-        let b1 = world.spawn(B(1)).id();
-        let b2 = world.spawn(B(2)).id();
-
-        #[expect(deprecated, reason = "remove this test in 0.17.0")]
-        for mut entity in world.iter_entities_mut() {
-            if let Some(mut a) = entity.get_mut::<A>() {
-                a.0 -= 1;
-            }
-        }
-        assert_eq!(world.entity(a1).get(), Some(&A(0)));
-        assert_eq!(world.entity(a2).get(), Some(&A(1)));
-        assert_eq!(world.entity(b1).get(), Some(&B(1)));
-        assert_eq!(world.entity(b2).get(), Some(&B(2)));
-
-        #[expect(deprecated, reason = "remove this test in 0.17.0")]
-        for mut entity in world.iter_entities_mut() {
-            if let Some(mut b) = entity.get_mut::<B>() {
-                b.0 *= 2;
-            }
-        }
-        assert_eq!(world.entity(a1).get(), Some(&A(0)));
-        assert_eq!(world.entity(a2).get(), Some(&A(1)));
-        assert_eq!(world.entity(b1).get(), Some(&B(2)));
-        assert_eq!(world.entity(b2).get(), Some(&B(4)));
-
-        #[expect(deprecated, reason = "remove this test in 0.17.0")]
-        let mut entities = world.iter_entities_mut().collect::<Vec<_>>();
-        entities.sort_by_key(|e| e.get::<A>().map(|a| a.0).or(e.get::<B>().map(|b| b.0)));
-        let (a, b) = entities.split_at_mut(2);
-        core::mem::swap(
-            &mut a[1].get_mut::<A>().unwrap().0,
-            &mut b[0].get_mut::<B>().unwrap().0,
-        );
-        assert_eq!(world.entity(a1).get(), Some(&A(0)));
-        assert_eq!(world.entity(a2).get(), Some(&A(2)));
-        assert_eq!(world.entity(b1).get(), Some(&B(1)));
-        assert_eq!(world.entity(b2).get(), Some(&B(4)));
-    }
-
     #[test]
     fn spawn_empty_bundle() {
         let mut world = World::new();
diff --git a/crates/bevy_input_focus/src/tab_navigation.rs b/crates/bevy_input_focus/src/tab_navigation.rs
index b8ce6a8d95375..2fa41082a2578 100644
--- a/crates/bevy_input_focus/src/tab_navigation.rs
+++ b/crates/bevy_input_focus/src/tab_navigation.rs
@@ -447,7 +447,7 @@ mod tests {
         let mut system_state: SystemState<TabNavigation> = SystemState::new(world);
         let tab_navigation = system_state.get(world);
         assert_eq!(tab_navigation.tabgroup_query.iter().count(), 1);
-        assert_eq!(tab_navigation.tabindex_query.iter().count(), 2);
+        assert!(tab_navigation.tabindex_query.iter().count() >= 2);
 
         let next_entity =
             tab_navigation.navigate(&InputFocus::from_entity(tab_entity_1), NavAction::Next);
@@ -480,7 +480,7 @@ mod tests {
         let mut system_state: SystemState<TabNavigation> = SystemState::new(world);
         let tab_navigation = system_state.get(world);
         assert_eq!(tab_navigation.tabgroup_query.iter().count(), 2);
-        assert_eq!(tab_navigation.tabindex_query.iter().count(), 4);
+        assert!(tab_navigation.tabindex_query.iter().count() >= 4);
 
         let next_entity =
             tab_navigation.navigate(&InputFocus::from_entity(tab_entity_1), NavAction::Next);
