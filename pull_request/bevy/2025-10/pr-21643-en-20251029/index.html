<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21643 Fix GLTF files being broken when loaded from custom asset sources.
        
    </title><meta content="#21643 Fix GLTF files being broken when loaded from custom asset sources." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-10/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-10-29</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-10/pr-21643-zh-cn-20251029>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix GLTF files being broken when loaded from custom asset sources.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21643<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Assets, S-Ready-For-Final-Review, D-Straightforward, A-glTF<li><strong>Created</strong>: 2025-10-23T19:16:24Z<li><strong>Merged</strong>: 2025-10-29T19:56:19Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Fixes #10903</ul><h2 id=solution>Solution</h2><ul><li>Stop using <code>Path::join</code> for joining asset paths and instead use <code>AssetPath::resolve_embed</code>.</ul><h2 id=testing>Testing</h2><ul><li>Added 2 tests!</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a fundamental issue in Bevy’s GLTF loader where embedded assets like images and buffers failed to load correctly when the GLTF file came from custom asset sources. The problem stemmed from using filesystem-specific path operations that didn’t account for Bevy’s asset system abstraction.<p>The core issue was in how the loader resolved relative paths for embedded assets. When loading a GLTF file, it contains references to external resources like images and binary buffers using relative URIs. The original implementation used <code>Path::join</code> to combine these relative paths with the parent directory of the GLTF file:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Problematic code
</span><span style=color:#fa6e32>let</span><span> parent </span><span style=color:#ed9366>=</span><span> load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>parent</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> image_path </span><span style=color:#ed9366>=</span><span> parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>join</span><span>(uri)</span><span style=color:#61676ccc>;
</span></code></pre><p>This approach worked for filesystem-based asset sources but broke completely for custom asset sources like memory-based loaders, network streams, or archives. The <code>Path::join</code> operation assumes a filesystem context and doesn’t understand Bevy’s asset path system with custom schemes like <code>custom://</code>.<p>The solution replaces all instances of <code>Path::join</code> with <code>AssetPath::resolve_embed</code>, which is specifically designed to handle relative path resolution within Bevy’s asset system:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// After: Fixed code
</span><span style=color:#fa6e32>let</span><span> image_path </span><span style=color:#ed9366>=</span><span> load_context
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>asset_path</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>resolve_embed</span><span>(uri)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"all URIs were already validated when we initially loaded textures"</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>This change required updates in multiple locations throughout the GLTF loader:<ul><li>Texture loading in <code>gltf_ext/texture.rs</code><li>Image loading in the main loader module<li>Buffer loading for binary data</ul><p>The implementation also needed to handle potential errors properly. The PR added new error variants <code>InvalidBufferUri</code> and <code>InvalidImageUri</code> to provide better error messages when path resolution fails:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// New error handling
</span><span style=color:#fa6e32>let</span><span> buffer_path </span><span style=color:#ed9366>=</span><span> load_context
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>asset_path</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>resolve_embed</span><span>(uri)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map_err</span><span>(|</span><span style=color:#ff8f40>err</span><span>| GltfError</span><span style=color:#ed9366>::</span><span>InvalidBufferUri(uri</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_owned</span><span>()</span><span style=color:#61676ccc>,</span><span> err))</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre><p>To ensure the fix was comprehensive, the PR included two new test cases that specifically test loading GLTF files from custom asset sources. These tests create a memory-based asset source and verify that both buffers and images can be loaded successfully:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>reads_buffer_in_custom_asset_source</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test implementation
</span><span>}
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>] 
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>reads_images_in_custom_asset_source</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test implementation
</span><span>}
</span></code></pre><p>The tests use a custom asset source with the scheme <code>custom://</code> and verify that the GLTF loader can successfully resolve and load embedded assets through Bevy’s asset system rather than relying on filesystem operations.<p>This change maintains backward compatibility for filesystem-based asset loading while enabling support for any custom asset source that implements Bevy’s asset reader interface. The fix is minimal and focused, changing only the path resolution mechanism without affecting the core GLTF parsing logic.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[GLTF Loader] --> B[Custom Asset Source]
</span><span>    A --> C[File System Source]
</span><span>    B --> D[resolve_embed]
</span><span>    C --> D
</span><span>    D --> E[Load Embedded Assets]
</span><span>    E --> F[Images]
</span><span>    E --> G[Buffers]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-gltf-src-loader-mod-rs-177-16><code>crates/bevy_gltf/src/loader/mod.rs</code> (+177/-16)</h3><p>This file contains the main GLTF loader implementation. The key changes include:<ol><li><strong>Path Resolution Updates</strong>: Replaced <code>Path::join</code> with <code>AssetPath::resolve_embed</code> in multiple locations<li><strong>Error Handling</strong>: Added new error variants for invalid URIs<li><strong>Testing</strong>: Added comprehensive tests for custom asset sources</ol><p>Key code changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Filesystem-specific path joining
</span><span style=color:#fa6e32>let</span><span> parent_path </span><span style=color:#ed9366>=</span><span> load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>parent</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> image_path </span><span style=color:#ed9366>=</span><span> parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>join</span><span>(uri)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Asset system-aware path resolution  
</span><span style=color:#fa6e32>let</span><span> image_path </span><span style=color:#ed9366>=</span><span> gltf_path
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>resolve_embed</span><span>(uri)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map_err</span><span>(|</span><span style=color:#ff8f40>err</span><span>| GltfError</span><span style=color:#ed9366>::</span><span>InvalidImageUri(uri</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_owned</span><span>()</span><span style=color:#61676ccc>,</span><span> err))</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-gltf-src-loader-gltf-ext-texture-rs-4-2><code>crates/bevy_gltf/src/loader/gltf_ext/texture.rs</code> (+4/-2)</h3><p>This file handles texture loading within the GLTF loader. The change ensures texture URIs are resolved correctly in custom asset sources.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> parent </span><span style=color:#ed9366>=</span><span> load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>parent</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> image_path </span><span style=color:#ed9366>=</span><span> parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>join</span><span>(uri)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> image_path </span><span style=color:#ed9366>=</span><span> load_context
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>asset_path</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>resolve_embed</span><span>(uri)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"all URIs were already validated when we initially loaded textures"</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/books/0.13/assets/ target=_blank>Bevy Asset System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html target=_blank>GLTF 2.0 Specification</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/10903 target=_blank>Issue #10903: GLTF embedded assets fail with custom asset sources</a></ul><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_gltf/src/loader/gltf_ext/texture.rs b/crates/bevy_gltf/src/loader/gltf_ext/texture.rs
</span><span>index 0ea16936a6344..f39646b8cfd18 100644
</span><span style=color:#c594c5>--- a/crates/bevy_gltf/src/loader/gltf_ext/texture.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_gltf/src/loader/gltf_ext/texture.rs
</span><span style=color:#c594c5>@@ -30,8 +30,10 @@ </span><span style=color:#399ee6>pub(crate) fn texture_handle(
</span><span>             if let Ok(_data_uri) = DataUri::parse(uri) {
</span><span>                 load_context.get_label_handle(texture_label(texture).to_string())
</span><span>             } else {
</span><span style=color:#f07171>-                let parent = load_context.path().parent().unwrap();
</span><span style=color:#f07171>-                let image_path = parent.join(uri);
</span><span style=color:#86b300>+                let image_path = load_context
</span><span style=color:#86b300>+                    .asset_path()
</span><span style=color:#86b300>+                    .resolve_embed(uri)
</span><span style=color:#86b300>+                    .expect("all URIs were already validated when we initially loaded textures");
</span><span>                 load_context.load(image_path)
</span><span>             }
</span><span>         }
</span><span>diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
</span><span>index 4c651b0dc9ac7..f840a2c23a4da 100644
</span><span style=color:#c594c5>--- a/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>@@ -2,17 +2,13 @@ </span><span style=color:#399ee6>mod extensions;
</span><span> mod gltf_ext;
</span><span> 
</span><span> use alloc::sync::Arc;
</span><span style=color:#f07171>-use std::{
</span><span style=color:#f07171>-    io::Error,
</span><span style=color:#f07171>-    path::{Path, PathBuf},
</span><span style=color:#f07171>-    sync::Mutex,
</span><span style=color:#f07171>-};
</span><span style=color:#86b300>+use std::{io::Error, sync::Mutex};
</span><span> 
</span><span> #[cfg(feature = "bevy_animation")]
</span><span> use bevy_animation::{prelude::*, AnimatedBy, AnimationTargetId};
</span><span> use bevy_asset::{
</span><span style=color:#f07171>-    io::Reader, AssetLoadError, AssetLoader, Handle, LoadContext, ReadAssetBytesError,
</span><span style=color:#f07171>-    RenderAssetUsages,
</span><span style=color:#86b300>+    io::Reader, AssetLoadError, AssetLoader, AssetPath, Handle, LoadContext, ParseAssetPathError,
</span><span style=color:#86b300>+    ReadAssetBytesError, RenderAssetUsages,
</span><span> };
</span><span> use bevy_camera::{
</span><span>     primitives::Aabb, visibility::Visibility, Camera, Camera3d, OrthographicProjection,
</span><span style=color:#c594c5>@@ -103,6 +99,9 @@ </span><span style=color:#399ee6>pub enum GltfError {
</span><span>     /// Unsupported buffer format.
</span><span>     #[error("unsupported buffer format")]
</span><span>     BufferFormatUnsupported,
</span><span style=color:#86b300>+    /// The buffer URI was unable to be resolved with respect to the asset path.
</span><span style=color:#86b300>+    #[error("invalid buffer uri: {0}. asset path error={1}")]
</span><span style=color:#86b300>+    InvalidBufferUri(String, ParseAssetPathError),
</span><span>     /// Invalid image mime type.
</span><span>     #[error("invalid image mime type: {0}")]
</span><span>     #[from(ignore)]
</span><span style=color:#c594c5>@@ -110,6 +109,9 @@ </span><span style=color:#399ee6>pub enum GltfError {
</span><span>     /// Error when loading a texture. Might be due to a disabled image file format feature.
</span><span>     #[error("You may need to add the feature for the file format: {0}")]
</span><span>     ImageError(#[from] TextureError),
</span><span style=color:#86b300>+    /// The image URI was unable to be resolved with respect to the asset path.
</span><span style=color:#86b300>+    #[error("invalid image uri: {0}. asset path error={1}")]
</span><span style=color:#86b300>+    InvalidImageUri(String, ParseAssetPathError),
</span><span>     /// Failed to read bytes from an asset path.
</span><span>     #[error("failed to read bytes from an asset path: {0}")]
</span><span>     ReadAssetBytesError(#[from] ReadAssetBytesError),
</span><span style=color:#c594c5>@@ -595,12 +597,11 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>         let mut _texture_handles = Vec::new();
</span><span>         if gltf.textures().len() == 1 || cfg!(target_arch = "wasm32") {
</span><span>             for texture in gltf.textures() {
</span><span style=color:#f07171>-                let parent_path = load_context.path().parent().unwrap();
</span><span>                 let image = load_image(
</span><span>                     texture,
</span><span>                     &buffer_data,
</span><span>                     &linear_textures,
</span><span style=color:#f07171>-                    parent_path,
</span><span style=color:#86b300>+                    load_context.asset_path(),
</span><span>                     loader.supported_compressed_formats,
</span><span>                     default_sampler,
</span><span>                     settings,
</span><span style=color:#c594c5>@@ -613,7 +614,7 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>             IoTaskPool::get()
</span><span>                 .scope(|scope| {
</span><span>                     gltf.textures().for_each(|gltf_texture| {
</span><span style=color:#f07171>-                        let parent_path = load_context.path().parent().unwrap();
</span><span style=color:#86b300>+                        let asset_path = load_context.asset_path().clone();
</span><span>                         let linear_textures = &linear_textures;
</span><span>                         let buffer_data = &buffer_data;
</span><span>                         scope.spawn(async move {
</span><span style=color:#c594c5>@@ -621,7 +622,7 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>                                 gltf_texture,
</span><span>                                 buffer_data,
</span><span>                                 linear_textures,
</span><span style=color:#f07171>-                                parent_path,
</span><span style=color:#86b300>+                                &asset_path,
</span><span>                                 loader.supported_compressed_formats,
</span><span>                                 default_sampler,
</span><span>                                 settings,
</span><span style=color:#c594c5>@@ -1079,7 +1080,7 @@ </span><span style=color:#399ee6>async fn load_image<'a, 'b>(
</span><span>     gltf_texture: gltf::Texture<'a>,
</span><span>     buffer_data: &[Vec&LTu8>],
</span><span>     linear_textures: &HashSet&LTusize>,
</span><span style=color:#f07171>-    parent_path: &'b Path,
</span><span style=color:#86b300>+    gltf_path: &'b AssetPath<'b>,
</span><span>     supported_compressed_formats: CompressedImageFormats,
</span><span>     default_sampler: &ImageSamplerDescriptor,
</span><span>     settings: &GltfLoaderSettings,
</span><span style=color:#c594c5>@@ -1129,7 +1130,9 @@ </span><span style=color:#399ee6>async fn load_image<'a, 'b>(
</span><span>                     label: GltfAssetLabel::Texture(gltf_texture.index()),
</span><span>                 })
</span><span>             } else {
</span><span style=color:#f07171>-                let image_path = parent_path.join(uri);
</span><span style=color:#86b300>+                let image_path = gltf_path
</span><span style=color:#86b300>+                    .resolve_embed(uri)
</span><span style=color:#86b300>+                    .map_err(|err| GltfError::InvalidImageUri(uri.to_owned(), err))?;
</span><span>                 Ok(ImageOrPath::Path {
</span><span>                     path: image_path,
</span><span>                     is_srgb,
</span><span style=color:#c594c5>@@ -1740,7 +1743,10 @@ </span><span style=color:#399ee6>async fn load_buffers(
</span><span>                     Ok(_) => return Err(GltfError::BufferFormatUnsupported),
</span><span>                     Err(()) => {
</span><span>                         // TODO: Remove this and add dep
</span><span style=color:#f07171>-                        let buffer_path = load_context.path().parent().unwrap().join(uri);
</span><span style=color:#86b300>+                        let buffer_path = load_context
</span><span style=color:#86b300>+                            .asset_path()
</span><span style=color:#86b300>+                            .resolve_embed(uri)
</span><span style=color:#86b300>+                            .map_err(|err| GltfError::InvalidBufferUri(uri.to_owned(), err))?;
</span><span>                         load_context.read_asset_bytes(buffer_path).await?
</span><span>                     }
</span><span>                 };
</span><span style=color:#c594c5>@@ -1802,7 +1808,7 @@ </span><span style=color:#399ee6>enum ImageOrPath {
</span><span>         label: GltfAssetLabel,
</span><span>     },
</span><span>     Path {
</span><span style=color:#f07171>-        path: PathBuf,
</span><span style=color:#86b300>+        path: AssetPath<'static>,
</span><span>         is_srgb: bool,
</span><span>         sampler_descriptor: ImageSamplerDescriptor,
</span><span>     },
</span><span style=color:#c594c5>@@ -1904,12 +1910,14 @@ </span><span style=color:#399ee6>mod test {
</span><span>             memory::{Dir, MemoryAssetReader},
</span><span>             AssetSource, AssetSourceId,
</span><span>         },
</span><span style=color:#f07171>-        AssetApp, AssetPlugin, AssetServer, Assets, Handle, LoadState,
</span><span style=color:#86b300>+        AssetApp, AssetLoader, AssetPlugin, AssetServer, Assets, Handle, LoadState,
</span><span>     };
</span><span>     use bevy_ecs::{resource::Resource, world::World};
</span><span style=color:#86b300>+    use bevy_image::{Image, ImageLoaderSettings};
</span><span>     use bevy_log::LogPlugin;
</span><span>     use bevy_mesh::skinning::SkinnedMeshInverseBindposes;
</span><span>     use bevy_mesh::MeshPlugin;
</span><span style=color:#86b300>+    use bevy_pbr::StandardMaterial;
</span><span>     use bevy_scene::ScenePlugin;
</span><span> 
</span><span>     fn test_app(dir: Dir) -> App {
</span><span style=color:#c594c5>@@ -2327,4 +2335,157 @@ </span><span style=color:#399ee6>mod test {
</span><span>         assert_eq!(skinned_node.children.len(), 2);
</span><span>         assert_eq!(skinned_node.skin.as_ref(), Some(&gltf_root.skins[0]));
</span><span>     }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    fn test_app_custom_asset_source() -> (App, Dir) {
</span><span style=color:#86b300>+        let dir = Dir::default();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+        let custom_reader = MemoryAssetReader { root: dir.clone() };
</span><span style=color:#86b300>+        // Create a default asset source so we definitely don't try to read from disk.
</span><span style=color:#86b300>+        app.register_asset_source(
</span><span style=color:#86b300>+            AssetSourceId::Default,
</span><span style=color:#86b300>+            AssetSource::build().with_reader(move || {
</span><span style=color:#86b300>+                Box::new(MemoryAssetReader {
</span><span style=color:#86b300>+                    root: Dir::default(),
</span><span style=color:#86b300>+                })
</span><span style=color:#86b300>+            }),
</span><span style=color:#86b300>+        )
</span><span style=color:#86b300>+        .register_asset_source(
</span><span style=color:#86b300>+            "custom",
</span><span style=color:#86b300>+            AssetSource::build().with_reader(move || Box::new(custom_reader.clone())),
</span><span style=color:#86b300>+        )
</span><span style=color:#86b300>+        .add_plugins((
</span><span style=color:#86b300>+            LogPlugin::default(),
</span><span style=color:#86b300>+            TaskPoolPlugin::default(),
</span><span style=color:#86b300>+            AssetPlugin::default(),
</span><span style=color:#86b300>+            ScenePlugin,
</span><span style=color:#86b300>+            MeshPlugin,
</span><span style=color:#86b300>+            crate::GltfPlugin::default(),
</span><span style=color:#86b300>+        ));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.finish();
</span><span style=color:#86b300>+        app.cleanup();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        (app, dir)
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn reads_buffer_in_custom_asset_source() {
</span><span style=color:#86b300>+        let (mut app, dir) = test_app_custom_asset_source();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        dir.insert_asset_text(
</span><span style=color:#86b300>+            Path::new("abc.gltf"),
</span><span style=color:#86b300>+            r#"
</span><span style=color:#86b300>+{
</span><span style=color:#86b300>+    "asset": {
</span><span style=color:#86b300>+        "version": "2.0"
</span><span style=color:#86b300>+    },
</span><span style=color:#86b300>+    "buffers": [
</span><span style=color:#86b300>+        {
</span><span style=color:#86b300>+            "uri": "abc.bin",
</span><span style=color:#86b300>+            "byteLength": 3
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    ]
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+"#,
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+        // We don't care that the buffer contains reasonable info since we won't actually use it.
</span><span style=color:#86b300>+        dir.insert_asset_text(Path::new("abc.bin"), "Sup");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_server = app.world().resource::&LTAssetServer>().clone();
</span><span style=color:#86b300>+        let handle: Handle&LTGltf> = asset_server.load("custom://abc.gltf");
</span><span style=color:#86b300>+        run_app_until(&mut app, |_world| {
</span><span style=color:#86b300>+            let load_state = asset_server.get_load_state(handle.id()).unwrap();
</span><span style=color:#86b300>+            match load_state {
</span><span style=color:#86b300>+                LoadState::Loaded => Some(()),
</span><span style=color:#86b300>+                LoadState::Failed(err) => panic!("{err}"),
</span><span style=color:#86b300>+                _ => None,
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn reads_images_in_custom_asset_source() {
</span><span style=color:#86b300>+        let (mut app, dir) = test_app_custom_asset_source();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.init_asset::&LTStandardMaterial>();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Note: We need the material here since otherwise we don't store the texture handle, which
</span><span style=color:#86b300>+        // can result in the image getting dropped leading to the gltf never being loaded with
</span><span style=color:#86b300>+        // dependencies.
</span><span style=color:#86b300>+        dir.insert_asset_text(
</span><span style=color:#86b300>+            Path::new("abc.gltf"),
</span><span style=color:#86b300>+            r#"
</span><span style=color:#86b300>+{
</span><span style=color:#86b300>+    "asset": {
</span><span style=color:#86b300>+        "version": "2.0"
</span><span style=color:#86b300>+    },
</span><span style=color:#86b300>+    "textures": [
</span><span style=color:#86b300>+        {
</span><span style=color:#86b300>+            "source": 0,
</span><span style=color:#86b300>+            "sampler": 0
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    ],
</span><span style=color:#86b300>+    "images": [
</span><span style=color:#86b300>+        {
</span><span style=color:#86b300>+            "uri": "abc.png"
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    ],
</span><span style=color:#86b300>+    "samplers": [
</span><span style=color:#86b300>+        {
</span><span style=color:#86b300>+            "magFilter": 9729,
</span><span style=color:#86b300>+            "minFilter": 9729
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    ],
</span><span style=color:#86b300>+    "materials": [
</span><span style=color:#86b300>+        {
</span><span style=color:#86b300>+            "pbrMetallicRoughness": {
</span><span style=color:#86b300>+                "baseColorTexture": {
</span><span style=color:#86b300>+                    "index": 0,
</span><span style=color:#86b300>+                    "texCoord": 0
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    ]
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+"#,
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+        // We don't care that the image contains reasonable info since we won't actually use it.
</span><span style=color:#86b300>+        dir.insert_asset_text(Path::new("abc.png"), "Sup");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        /// A fake loader to avoid actually loading any image data and just return an image.
</span><span style=color:#86b300>+        struct FakePngLoader;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        impl AssetLoader for FakePngLoader {
</span><span style=color:#86b300>+            type Asset = Image;
</span><span style=color:#86b300>+            type Error = std::io::Error;
</span><span style=color:#86b300>+            type Settings = ImageLoaderSettings;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            async fn load(
</span><span style=color:#86b300>+                &self,
</span><span style=color:#86b300>+                _reader: &mut dyn bevy_asset::io::Reader,
</span><span style=color:#86b300>+                _settings: &Self::Settings,
</span><span style=color:#86b300>+                _load_context: &mut bevy_asset::LoadContext<'_>,
</span><span style=color:#86b300>+            ) -> Result&LTSelf::Asset, Self::Error> {
</span><span style=color:#86b300>+                Ok(Image::default())
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            fn extensions(&self) -> &[&str] {
</span><span style=color:#86b300>+                &["png"]
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.init_asset::&LTImage>()
</span><span style=color:#86b300>+            .register_asset_loader(FakePngLoader);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_server = app.world().resource::&LTAssetServer>().clone();
</span><span style=color:#86b300>+        let handle: Handle&LTGltf> = asset_server.load("custom://abc.gltf");
</span><span style=color:#86b300>+        run_app_until(&mut app, |_world| {
</span><span style=color:#86b300>+            // Note: we can't assert for failure since it's the nested load that fails, not the GLTF
</span><span style=color:#86b300>+            // load.
</span><span style=color:#86b300>+            asset_server
</span><span style=color:#86b300>+                .is_loaded_with_dependencies(&handle)
</span><span style=color:#86b300>+                .then_some(())
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+    }
</span><span> }
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-10/pr_21643.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>