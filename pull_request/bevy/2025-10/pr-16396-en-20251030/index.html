<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #16396 Allow dense iteration for FilteredEntity(Ref|Mut) in more cases.
        
    </title><meta content="#16396 Allow dense iteration for FilteredEntity(Ref|Mut) in more cases." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-10/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-10-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-10/pr-16396-zh-cn-20251030>中文</a></div></div><div class=pr-content><h1 id=allow-dense-iteration-for-filteredentity-ref-mut-in-more-cases>Allow dense iteration for FilteredEntity(Ref|Mut) in more cases.</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Allow dense iteration for FilteredEntity(Ref|Mut) in more cases.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/16396<li><strong>Author</strong>: chescock<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Performance, S-Ready-For-Final-Review, D-Complex, X-Uncontroversial, D-Unsafe<li><strong>Created</strong>: 2024-11-15T18:30:49Z<li><strong>Merged</strong>: 2025-10-30T03:19:01Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Improve the performance of some dynamic queries with <code>FilteredEntity(Ref|Mut)</code> by allowing dense iteration in more cases, and remove a call to the sort-of deprecated <code>Access::component_reads_and_writes()</code> method.<p><code>QueryBuilder</code> currently requires sparse iteration if any sparse set components may be read. We do need sparse iteration if sparse set components are used in the filters, but <code>FilteredEntityRef</code> can still perform dense iteration when reading optional components or when reading all components.<p>Note that the optional case is different from <code>Option</code>, which performs sparse iteration when the inner query is sparse so that it can cache whether the inner query matches for an entire archetype.<h2 id=solution>Solution</h2><p>Change <code>FilteredEntity(Ref|Mut)</code> to have <code>IS_DENSE = true</code>. It used to require sparse iteration in order to filter the <code>Access</code> for each archetype, but #15207 changed it to copy the entire access.<p>Change <code>QueryBuilder::is_dense()</code> to check <code>D::IS_DENSE && F::IS_DENSE</code> instead of looking at the component reads and writes.<br> <code>QueryBuilder::is_dense()</code> still checks the <em>filters</em>, so <code>builder.data::<&Sparse>()</code> will still cause sparse iteration, but <code>builder.data::&LTOption<&Sparse>>()</code> no longer will.<p>I believe this is sound, even in the presence of query transmutes. The only <code>WorldQuery</code> implementations that rely on a sparse query being sparse for soundness are <code>&</code>, <code>&mut</code>, <code>Ref</code>, and <code>Mut</code>, but they can only be transmuted to if the component is in the <code>required</code> set. If a dynamic query has the component in the <code>required</code> set, then it appears in the filters and the query will use sparse iteration.<p>Note that <code>Option</code> and <code>Has</code> will misbehave and report <code>None</code> and <code>false</code> for all entities if they do a dense query while wrapping a sparse component, but they won’t cause UB. And it’s already possible to hit that case by transmuting from <code>Query&LTEntityMut></code> to <code>Query&LTOption<&Sparse>></code>.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a performance optimization in Bevy’s ECS system by enabling dense iteration for <code>FilteredEntityRef</code> and <code>FilteredEntityMut</code> queries in more scenarios. The core issue was that these query types were unnecessarily falling back to sparse iteration, which is slower, even when the query structure would allow for the more efficient dense iteration.<p>The problem stemmed from how <code>QueryBuilder</code> determined iteration strategy. Previously, it would check if any sparse set components might be read and pessimistically default to sparse iteration. However, after PR #15207 changed how <code>FilteredEntity(Ref|Mut)</code> handles access filtering, the original justification for requiring sparse iteration no longer applied. The system was being overly conservative.<p>The solution involved two key changes. First, the <code>IS_DENSE</code> constants for <code>FilteredEntityRef</code> and <code>FilteredEntityMut</code> were changed from <code>false</code> to <code>true</code>, indicating these query types can support dense iteration. Second, the logic in <code>QueryBuilder::is_dense()</code> was refactored to rely on the <code>IS_DENSE</code> flags of the query data and filter types, rather than examining component accesses directly.<p>This change enables an important performance optimization: queries with optional sparse components can now use dense iteration. For example, <code>builder.data::&LTOption<&Sparse>>()</code> will now use dense iteration, while <code>builder.data::<&Sparse>()</code> (which requires the sparse component) will still correctly use sparse iteration.<p>The implementation maintains safety through careful design. Only query types that absolutely require sparse iteration for correctness (like <code>&</code>, <code>&mut</code>, <code>Ref</code>, and <code>Mut</code> with sparse components) will force sparse iteration by adding components to the required set. The system ensures that if a query has sparse components in its required set, it will always use sparse iteration.<p>One known limitation is that <code>Option<&Sparse></code> and <code>Has&LTSparse></code> queries may behave incorrectly when using dense iteration, reporting <code>None</code> and <code>false</code> for all entities. However, this doesn’t cause undefined behavior and was already possible through query transmutation. The PR includes tests to document this behavior.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[FilteredEntityRef] --> B[QueryBuilder]
</span><span>    C[FilteredEntityMut] --> B
</span><span>    B --> D[is_dense logic]
</span><span>    D --> E[Check D::IS_DENSE && F::IS_DENSE]
</span><span>    E --> F[Check filter storage types]
</span><span>    F --> G[Dense iteration allowed]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-query-fetch-rs><code>crates/bevy_ecs/src/query/fetch.rs</code></h3><p>This file contains the core <code>WorldQuery</code> implementations. The key change was updating the <code>IS_DENSE</code> constants for the filtered entity types.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>IS_DENSE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>IS_DENSE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;
</span></code></pre><p>This change tells the query system that <code>FilteredEntityRef</code> and <code>FilteredEntityMut</code> can support dense iteration, which is the foundation for the performance improvements.<h3 id=crates-bevy-ecs-src-query-builder-rs><code>crates/bevy_ecs/src/query/builder.rs</code></h3><p>The main logic change happened in the <code>is_dense()</code> method, which now uses a more straightforward approach based on type flags rather than component access analysis.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(component_accesses) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>access</span><span style=color:#ed9366>.</span><span style=color:#f07171>access</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_iter_component_access</span><span>() </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Access is unbounded, pessimistically assume it's sparse.
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>}</span><span style=color:#61676ccc>;
</span><span>
</span><span>component_accesses
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>access</span><span>| </span><span style=color:#ed9366>*</span><span>access</span><span style=color:#ed9366>.</span><span style=color:#f07171>index</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>all</span><span>(is_dense)
</span><span>    </span><span style=color:#ed9366>&& !</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>access</span><span style=color:#ed9366>.</span><span style=color:#f07171>access</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>has_read_all_components</span><span>()
</span><span>    </span><span style=color:#ed9366>&& </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>access</span><span style=color:#ed9366>.</span><span style=color:#f07171>with_filters</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>all</span><span>(is_dense)
</span><span>    </span><span style=color:#ed9366>&& </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>access</span><span style=color:#ed9366>.</span><span style=color:#f07171>without_filters</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>all</span><span>(is_dense)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>D</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>IS_DENSE
</span><span>    </span><span style=color:#ed9366>&& </span><span>F</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>IS_DENSE
</span><span>    </span><span style=color:#ed9366>&& </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>access</span><span style=color:#ed9366>.</span><span style=color:#f07171>with_filters</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>all</span><span>(is_dense)
</span><span>    </span><span style=color:#ed9366>&& </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>access</span><span style=color:#ed9366>.</span><span style=color:#f07171>without_filters</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>all</span><span>(is_dense)
</span></code></pre><p>The new implementation is cleaner and removes the dependency on the deprecated <code>Access::component_reads_and_writes()</code> method.<h3 id=crates-bevy-ecs-src-query-state-rs><code>crates/bevy_ecs/src/query/state.rs</code></h3><p>This file handles query state management, particularly for query transmutation. The changes ensure that when queries are transmuted, the dense/sparse classification is preserved correctly.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Key addition - preserving is_dense during transmutation:
</span><span style=color:#fa6e32>let</span><span> is_dense </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>is_dense</span><span style=color:#61676ccc>;
</span></code></pre><p>The extensive comments explain the safety reasoning, particularly how the <code>FilteredAccess::required</code> set ensures that queries requiring sparse iteration remain sparse even after transmutation.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/ecs/ target=_blank>Bevy ECS Documentation</a> - Official Bevy ECS documentation<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/15207 target=_blank>PR #15207</a> - Previous PR that changed how FilteredEntity access works<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/16397 target=_blank>Issue #16397</a> - Related issue documenting the Option/Has limitation with dense iteration</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-10/pr_16396.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>