<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21589 Remove `#[derive(Resource, Component)]` from tests
        
    </title><meta content="#21589 Remove `#[derive(Resource, Component)]` from tests" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-10/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-10-19</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-10/pr-21589-en-20251019>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=remove-derive-resource-component-from-tests>Remove <code>#[derive(Resource, Component)]</code> from tests</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Remove <code>#[derive(Resource, Component)]</code> from tests<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21589<li><strong>Author</strong>: Trashtalk217<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-ECS, C-Code-Quality, S-Ready-For-Final-Review, C-Testing<li><strong>Created</strong>: 2025-10-18T14:07:25Z<li><strong>Merged</strong>: 2025-10-19T20:04:52Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>多个测试在单个结构体上同时派生 <code>Resource</code> 和 <code>Component</code>。在当前的资源即组件计划 (#19731) 中，这会导致冲突。<h2 id=solution>Solution</h2><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource</span><span style=color:#61676ccc>,</span><span> Component)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span style=color:#61676ccc>;
</span></code></pre><p>变为<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>ResA</span><span style=color:#61676ccc>;
</span></code></pre><p>并且相应地修改测试。<p>有一个测试必须被移除，因为它专门测试了同一个查询可以同时查询同名的资源和组件。这个测试现在不再有意义，所以我移除了它。<h2 id=testing>Testing</h2><p>我通过在 <code>Resource</code> 派生宏中添加代码来测试这些更改，该代码也会派生 <code>Component</code>，因此任何冲突都会在运行 <code>cargo build</code> 时显示出来。<h2 id=future-work>Future work</h2><p><code>bevy_light</code> 中的 <code>AmbientLight</code> 仍然同时派生两者，但由于这需要更多工作，我将其留到以后处理。<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个PR解决了一个即将到来的架构冲突问题。在Bevy引擎的ECS（Entity Component System）中，资源和组件是两个核心概念，但随着#19731计划的推进，同一个类型同时作为资源和组件使用会产生冲突。<p>问题的核心在于测试代码中的便利性写法。开发者为了测试方便，经常在同一个结构体上同时派生<code>Resource</code>和<code>Component</code>特性。这在当前版本中工作正常，但在新的“资源即组件“架构下，这种模式会导致类型冲突，因为系统无法区分一个类型应该被视为资源还是组件。<p>解决方案是进行类型分离。对于每个原来同时作为资源和组件的类型，现在创建两个独立的类型：一个专门作为组件，另一个专门作为资源。命名约定通常是保持组件名称不变，而资源类型加上<code>Res</code>前缀。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource</span><span style=color:#61676ccc>,</span><span> Component)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>ResA</span><span style=color:#61676ccc>;
</span></code></pre><p>这种修改不仅解决了类型冲突问题，还使代码意图更加明确。在系统参数中，<code>Res&LTA></code>和<code>Query<&A></code>现在引用的是完全不同的类型，避免了潜在的混淆。<p>一个值得注意的修改是移除了专门测试同名资源和组件查询的测试用例。这个测试在旧的架构下验证了系统能够正确处理同名的资源和组件，但在新的分离架构下，这个测试已经失去了意义，因为现在资源和组件必须是不同的类型。<p>测试策略也很实用：通过在<code>Resource</code>派生宏中添加临时代码来强制检测冲突。这种方法有效地验证了所有修改都正确解决了类型冲突问题。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[TestBool Component] --> B[Performance Benchmarks]
</span><span>    C[TestResource Resource] --> B
</span><span>    D[A Component] --> E[ECS Core Tests]
</span><span>    F[ResA Resource] --> E
</span><span>    G[W Component] --> H[Command System Tests]
</span><span>    I[V Resource] --> H
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-lib-rs-14-12><code>crates/bevy_ecs/src/lib.rs</code> (+14/-12)</h3><p>这是ECS核心模块的测试文件，包含了最广泛的修改。主要变化是将原来同时作为组件和资源的类型分离。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Resource</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Copy)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span>(</span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Copy)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span>(</span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>ResA</span><span>(</span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ecs-src-schedule-mod-rs-0-18><code>crates/bevy_ecs/src/schedule/mod.rs</code> (+0/-18)</h3><p>移除了一个不再相关的测试用例，这个测试专门验证同名资源和组件不冲突的行为。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Removed test:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>shared_resource_mut_component</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    world</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert_resource</span><span>(</span><span style=color:#ff8f40>RC</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> schedule </span><span style=color:#ed9366>= </span><span>Schedule</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>    schedule</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>((|_: ResMut&LTRC>| {}</span><span style=color:#61676ccc>, </span><span>|_: Query<</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> RC>| {}))</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#ed9366>_ =</span><span> schedule</span><span style=color:#ed9366>.</span><span style=color:#f07171>initialize</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> world)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(schedule</span><span style=color:#ed9366>.</span><span style=color:#f07171>graph</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>conflicting_systems</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-system-commands-mod-rs-17-14><code>crates/bevy_ecs/src/system/commands/mod.rs</code> (+17/-14)</h3><p>命令系统的测试更新，反映了资源和组件类型的分离。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>W</span><span>&LTT>(T)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>W</span><span>&LTT>(T)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>V</span><span>&LTT>(T)</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ecs-src-system-mod-rs-44-27><code>crates/bevy_ecs/src/system/mod.rs</code> (+44/-27)</h3><p>系统模块的测试进行了大规模重构，为每个原来的复合类型创建了独立的资源和组件类型。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before components:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Resource</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After components:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>A</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// New resources:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>ResA</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=benches-benches-bevy-ecs-scheduling-run-condition-rs-4-2><code>benches/benches/bevy_ecs/scheduling/run_condition.rs</code> (+4/-2)</h3><p>性能基准测试也相应更新，确保测试场景仍然有效。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>TestBool</span><span>(pub </span><span style=color:#fa6e32>bool</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>TestBool</span><span>(pub </span><span style=color:#fa6e32>bool</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>TestResource</span><span>(pub </span><span style=color:#fa6e32>bool</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/ecs/ target=_blank>Bevy ECS Guide</a> - Bevy官方ECS文档<li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros target=_blank>Rust Derive Macros</a> - Rust派生宏的官方文档<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/discussions/19731 target=_blank>Component vs Resource in ECS</a> - Bevy中组件与资源的讨论</ul><h1 id=full-code-diff>Full Code Diff</h1><p>diff –git a/benches/benches/bevy_ecs/scheduling/run_condition.rs b/benches/benches/bevy_ecs/scheduling/run_condition.rs index 9c40cf396e047..083ed177d2f7a 100644 — a/benches/benches/bevy_ecs/scheduling/run_condition.rs +++ b/benches/benches/bevy_ecs/scheduling/run_condition.rs @@ -55,7 +55,7 @@ pub fn run_condition_no(criterion: &mut Criterion) { group.finish(); }<p>-#[derive(Component, Resource)] +#[derive(Component)] struct TestBool(pub bool);<p>pub fn run_condition_yes_with_query(criterion: &mut Criterion) { @@ -86,14 +86,17 @@ pub fn run_condition_yes_with_query(criterion: &mut Criterion) { group.finish(); }<p>+#[derive(Resource)] +struct TestResource(pub bool); + pub fn run_condition_yes_with_resource(criterion: &mut Criterion) { let mut world = World::new();<ul><li>world.insert_resource(TestBool(true));</ul><ul><li>world.insert_resource(TestResource(true)); let mut group = criterion.benchmark_group(“run_condition/yes_using_resource”); group.warm_up_time(core::time::Duration::from_millis(500)); group.measurement_time(core::time::Duration::from_secs(3)); fn empty() {}</ul><ul><li>fn yes_with_resource(res: Res<testbool>) -> bool { <ul><li>fn yes_with_resource(res: Res<testresource>) -> bool { res.0 } for amount in [10, 100, 1_000] { diff –git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs index 2e9174bf2404c..d2f59ac29f83d 100644 — a/crates/bevy_ecs/src/lib.rs +++ b/crates/bevy_ecs/src/lib.rs @@ -178,8 +178,10 @@ mod tests { }; use std::sync::Mutex; <ul><li>#[derive(Component, Resource, Debug, PartialEq, Eq, Hash, Clone, Copy)]</ul> <ul><li>#[derive(Component, Debug, PartialEq, Eq, Hash, Clone, Copy)] struct A(usize);<li>#[derive(Resource, Debug, PartialEq, Eq)]<li>struct ResA(usize); #[derive(Component, Debug, PartialEq, Eq, Hash, Clone, Copy)] struct B(usize); #[derive(Component, Debug, PartialEq, Eq, Clone, Copy)] @@ -1421,10 +1423,10 @@ mod tests { #[test] fn non_send_resource_points_to_distinct_data() { let mut world = World::default();</ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(A(123));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_non_send_resource(A(456));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert_eq!(*world.resource::&LTA>(), A(123));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert_eq!(*world.non_send_resource::&LTA>(), A(456));
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(ResA(123));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_non_send_resource(ResA(456));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert_eq!(*world.resource::&LTResA>(), ResA(123));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert_eq!(*world.non_send_resource::&LTResA>(), ResA(456));
</span></code></pre> <p>}</p> <p>#[test] @@ -1570,13 +1572,13 @@ mod tests { #[test] fn resource_scope() { let mut world = World::default();</p></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.try_resource_scope::&LTA, _>(|_, _| {}).is_none());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(A(0));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.resource_scope(|world: &mut World, mut value: Mut&LTA>| {
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.try_resource_scope::&LTResA, _>(|_, _| {}).is_none());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(ResA(0));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.resource_scope(|world: &mut World, mut value: Mut&LTResA>| {
</span><span>       value.0 += 1;
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       assert!(!world.contains_resource::&LTA>());
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       assert!(!world.contains_resource::&LTResA>());
</span><span>   });
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert_eq!(world.resource::&LTA>().0, 1);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert_eq!(world.resource::&LTResA>().0, 1);
</span></code></pre> <p>}</p> <p>#[test] @@ -1636,7 +1638,7 @@ mod tests { fn clear_entities() { let mut world = World::default();</p></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(A(0));
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(ResA(0));
</span><span>   world.spawn(A(1));
</span><span>   world.spawn(SparseStored(1));
</span></code></pre></ul> <p>@@ -1666,7 +1668,7 @@ mod tests { “world should not have any entities” ); assert_eq!(</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       world.resource::&LTA>().0,
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       world.resource::&LTResA>().0,
</span><span>       0,
</span><span>       "world should still contain resources"
</span><span>   );
</span></code></pre></ul> <p>diff –git a/crates/bevy_ecs/src/schedule/mod.rs b/crates/bevy_ecs/src/schedule/mod.rs index a03825f9eda56..2d935d32d1b63 100644 — a/crates/bevy_ecs/src/schedule/mod.rs +++ b/crates/bevy_ecs/src/schedule/mod.rs @@ -795,9 +795,6 @@ mod tests { #[derive(Message)] struct E;</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[derive(Resource, Component)]
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   struct RC;
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn empty_system() {}
</span><span>   fn res_system(_res: Res&LTR>) {}
</span><span>   fn resmut_system(_res: ResMut&LTR>) {}
</span></code></pre></ul> <p>@@ -957,21 +954,6 @@ mod tests { assert_eq!(schedule.graph().conflicting_systems().len(), 3); }</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   /// Test that when a struct is both a Resource and a Component, they do not
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   /// conflict with each other.
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[test]
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn shared_resource_mut_component() {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       let mut world = World::new();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       world.insert_resource(RC);
</span></code></pre><li><li><pre style=color:#61676c;background-color:#fafafa><code><span>       let mut schedule = Schedule::default();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       schedule.add_systems((|_: ResMut&LTRC>| {}, |_: Query<&mut RC>| {}));
</span></code></pre><li><li><pre style=color:#61676c;background-color:#fafafa><code><span>       let _ = schedule.initialize(&mut world);
</span></code></pre><li><li><pre style=color:#61676c;background-color:#fafafa><code><span>       assert_eq!(schedule.graph().conflicting_systems().len(), 0);
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[test]
</span><span>   fn resource_mut_and_entity_ref() {
</span><span>       let mut world = World::new();
</span></code></pre></ul> <p>diff –git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs index 35afc7a96a3ac..1385061bc2f7e 100644 — a/crates/bevy_ecs/src/system/commands/mod.rs +++ b/crates/bevy_ecs/src/system/commands/mod.rs @@ -2477,16 +2477,19 @@ mod tests { } }</p> <ul><li>#[derive(Component, Resource)]</ul> <ul><li><p>#[derive(Component)] struct W<t>(T); <li><p>#[derive(Resource)]</p></li> <li><p>struct V<t>(T); <li><p>fn simple_command(world: &mut World) { world.spawn((W(0u32), W(42u64))); }</p> <p>impl FromWorld for W<string> { fn from_world(world: &mut World) -> Self { <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       let v = world.resource::&LTW&LTusize>>();
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       let v = world.resource::&LTV&LTusize>>();
</span><span>       Self("*".repeat(v.0))
</span><span>   }
</span></code></pre> } @@ -2527,7 +2530,7 @@ mod tests { .or_insert(W(42)); queue.apply(&mut world); assert_eq!(42, world.get::&LTW<u64>>(entity).unwrap().0); <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(W(5_usize));
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(V(5_usize));
</span><span>   let mut commands = Commands::new(&mut queue, &world);
</span><span>   commands.entity(entity).entry::&LTW&LTString>>().or_from_world();
</span><span>   queue.apply(&mut world);
</span></code></pre></ul> <p>@@ -2744,22 +2747,22 @@ mod tests { let mut queue = CommandQueue::default(); { let mut commands = Commands::new(&mut queue, &world);</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(W(123i32));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(W(456.0f64));
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(V(123i32));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(V(456.0f64));
</span><span>   }
</span><span>
</span><span>   queue.apply(&mut world);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTW&LTi32>>());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTW&LTf64>>());
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTV&LTi32>>());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTV&LTf64>>());
</span><span>
</span><span>   {
</span><span>       let mut commands = Commands::new(&mut queue, &world);
</span><span>       // test resource removal
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.remove_resource::&LTW&LTi32>>();
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.remove_resource::&LTV&LTi32>>();
</span><span>   }
</span><span>   queue.apply(&mut world);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(!world.contains_resource::&LTW&LTi32>>());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTW&LTf64>>());
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(!world.contains_resource::&LTV&LTi32>>());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTV&LTf64>>());
</span></code></pre> <p>}</p> <p>#[test] @@ -2832,17 +2835,17 @@ mod tests { let mut queue_1 = CommandQueue::default(); { let mut commands = Commands::new(&mut queue_1, &world);</p></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(W(123i32));
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(V(123i32));
</span><span>   }
</span><span>   let mut queue_2 = CommandQueue::default();
</span><span>   {
</span><span>       let mut commands = Commands::new(&mut queue_2, &world);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(W(456.0f64));
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       commands.insert_resource(V(456.0f64));
</span><span>   }
</span><span>   queue_1.append(&mut queue_2);
</span><span>   queue_1.apply(&mut world);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTW&LTi32>>());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTW&LTf64>>());
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTV&LTi32>>());
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   assert!(world.contains_resource::&LTV&LTf64>>());
</span></code></pre> <p>}</p> <p>#[test] diff –git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs index 22b6db8e4e936..2b9fe4319b973 100644 — a/crates/bevy_ecs/src/system/mod.rs +++ b/crates/bevy_ecs/src/system/mod.rs @@ -432,19 +432,32 @@ mod tests { No, }</p></ul> <ul><li>#[derive(Component, Resource, Debug, Eq, PartialEq, Default)]</ul> <ul><li>#[derive(Component, Debug, Eq, PartialEq, Default)] struct A;</ul> <ul><li>#[derive(Component, Resource)]</ul> <ul><li>#[derive(Component)] struct B;</ul> <ul><li>#[derive(Component, Resource)]</ul> <ul><li>#[derive(Component)] struct C;</ul> <ul><li>#[derive(Component, Resource)]</ul> <ul><li>#[derive(Component)] struct D;</ul> <ul><li>#[derive(Component, Resource)]</ul> <ul><li>#[derive(Component)] struct E;</ul> <ul><li>#[derive(Component, Resource)]</ul> <ul><li><p>#[derive(Component)] struct F;</p><li><p>#[derive(Resource)]</p><li><p>struct ResA;</p><li><p>#[derive(Resource)]</p><li><p>struct ResB;</p><li><p>#[derive(Resource)]</p><li><p>struct ResC;</p><li><p>#[derive(Resource)]</p><li><p>struct ResD;</p><li><p>#[derive(Resource)]</p><li><p>struct ResE;</p><li><p>#[derive(Resource)]</p><li><p>struct ResF;</p><li><p>#[derive(Component, Debug)] struct W<t>(T); <p>@@ -913,8 +926,8 @@ mod tests { fn test_for_conflicting_resources&LTMarker, S: IntoSystem<(), (), Marker>>(sys: S) { let mut world = World::default(); world.insert_resource(BufferRes::default());</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(A);
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(B);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(ResA);
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(ResB);
</span><span>   run_system(&mut world, sys);
</span></code></pre> }</ul> <p>@@ -941,7 +954,7 @@ mod tests {</p> <pre style=color:#61676c;background-color:#fafafa><code><span> #[test]
</span><span> fn nonconflicting_system_resources() {
</span></code></pre> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn sys(_: Local&LTBufferRes>, _: ResMut&LTBufferRes>, _: Local&LTA>, _: ResMut&LTA>) {}
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn sys(_: Local&LTBufferRes>, _: ResMut&LTBufferRes>, _: Local&LTA>, _: ResMut&LTResA>) {}
</span><span>   test_for_conflicting_resources(sys);
</span></code></pre> }</ul> <p>@@ -1156,9 +1169,9 @@ mod tests {</p> <pre style=color:#61676c;background-color:#fafafa><code><span> #[test]
</span><span> fn get_system_conflicts() {
</span></code></pre> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn sys_x(_: Res&LTA>, _: Res&LTB>, _: Query<(&C, &D)>) {}
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn sys_x(_: Res&LTResA>, _: Res&LTResB>, _: Query<(&C, &D)>) {}
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn sys_y(_: Res&LTA>, _: ResMut&LTB>, _: Query<(&C, &mut D)>) {}
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn sys_y(_: Res&LTResA>, _: ResMut&LTResB>, _: Query<(&C, &mut D)>) {}
</span><span>
</span><span>   let mut world = World::default();
</span><span>   let mut x = IntoSystem::into_system(sys_x);
</span></code></pre></ul> <p>@@ -1169,7 +1182,7 @@ mod tests { let conflicts = x_access.get_conflicts(&y_access); let b_id = world .components()</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       .get_resource_id(TypeId::of::&LTB>())
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       .get_resource_id(TypeId::of::&LTResB>())
</span><span>       .unwrap();
</span><span>   let d_id = world.components().get_id(TypeId::of::&LTD>()).unwrap();
</span><span>   assert_eq!(conflicts, vec![b_id, d_id].into());
</span></code></pre></ul> <p>@@ -1202,12 +1215,12 @@ mod tests { #[test] fn can_have_16_parameters() { fn sys_x(</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTA>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTB>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTC>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTD>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTE>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTF>,
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTResA>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTResB>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTResC>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTResD>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTResE>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       _: Res&LTResF>,
</span><span>       _: Query<&A>,
</span><span>       _: Query<&B>,
</span><span>       _: Query<&C>,
</span></code></pre></ul> <p>@@ -1221,12 +1234,12 @@ mod tests { } fn sys_y( _: (</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTA>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTB>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTC>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTD>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTE>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTF>,
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTResA>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTResB>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTResC>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTResD>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTResE>,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Res&LTResF>,
</span><span>           Query<&A>,
</span><span>           Query<&B>,
</span><span>           Query<&C>,
</span></code></pre></ul> <p>@@ -1392,19 +1405,23 @@ mod tests { reason = “This test exists to show that read-only world-only queries can return data that lives as long as <code>'world</code>.” )] fn long_life_test() {</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   struct ResourceHolder<'w> {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       value: &'w ResA,
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   struct Holder<'w> {
</span><span>       value: &'w A,
</span><span>   }
</span><span>
</span><span>   struct State {
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       state: SystemState&LTRes<'static, A>>,
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       state: SystemState&LTRes<'static, ResA>>,
</span><span>       state_q: SystemState&LTQuery<'static, 'static, &'static A>>,
</span><span>   }
</span><span>
</span><span>   impl State {
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       fn hold_res<'w>(&mut self, world: &'w World) -> Holder<'w> {
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       fn hold_res<'w>(&mut self, world: &'w World) -> ResourceHolder<'w> {
</span><span>           let a = self.state.get(world);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>           Holder {
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>           ResourceHolder {
</span><span>               value: a.into_inner(),
</span><span>           }
</span><span>       }
</span></code></pre></ul> <p>diff –git a/crates/bevy_ecs/src/system/system.rs b/crates/bevy_ecs/src/system/system.rs index 8986ec812a462..456e9522bdcad 100644 — a/crates/bevy_ecs/src/system/system.rs +++ b/crates/bevy_ecs/src/system/system.rs @@ -459,10 +459,9 @@ mod tests {</p> <pre style=color:#61676c;background-color:#fafafa><code><span> #[test]
</span><span> fn run_system_once() {
</span></code></pre> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[derive(Resource)]
</span><span>   struct T(usize);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   impl Resource for T {}
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn system(In(n): In&LTusize>, mut commands: Commands) -> usize {
</span><span>       commands.insert_resource(T(n));
</span><span>       n + 1
</span></code></pre></ul> <p>@@ -522,8 +521,9 @@ mod tests {</p> <pre style=color:#61676c;background-color:#fafafa><code><span> #[test]
</span><span> fn run_system_once_invalid_params() {
</span></code></pre> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[derive(Resource)]
</span><span>   struct T;
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   impl Resource for T {}
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn system(_: Res&LTT>) {}
</span><span>
</span><span>   let mut world = World::default();
</span></code></pre></ul> <p>diff –git a/crates/bevy_ecs/src/system/system_registry.rs b/crates/bevy_ecs/src/system/system_registry.rs index 576773bb70b6e..9719fb4311981 100644 — a/crates/bevy_ecs/src/system/system_registry.rs +++ b/crates/bevy_ecs/src/system/system_registry.rs @@ -995,8 +995,9 @@ mod tests { use crate::system::RegisteredSystemError; use alloc::string::ToString;</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[derive(Resource)]
</span><span>   struct T;
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   impl Resource for T {}
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   fn system(_: Res&LTT>) {}
</span><span>
</span><span>   let mut world = World::new();
</span></code></pre></ul> <p>diff –git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs index 024c127aab8b2..6bee7953b13a3 100644 — a/crates/bevy_ecs/src/world/mod.rs +++ b/crates/bevy_ecs/src/world/mod.rs @@ -3735,7 +3735,7 @@ mod tests { Drop(ID), }</p> <ul><li>#[derive(Resource, Component)]</ul> <ul><li><p>#[derive(Component)] struct MayPanicInDrop { drop_log: Arc&LTMutex&LTVec<droplogitem>>>, expected_panic_flag: Arc<atomicbool>, diff –git a/crates/bevy_scene/src/dynamic_scene_builder.rs b/crates/bevy_scene/src/dynamic_scene_builder.rs index feddacfdfb091..3acef88a1c8bb 100644 — a/crates/bevy_scene/src/dynamic_scene_builder.rs +++ b/crates/bevy_scene/src/dynamic_scene_builder.rs @@ -703,19 +703,24 @@ mod tests { <p>#[test] fn should_use_from_reflect() {</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[derive(Resource, Component, Reflect)]
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[reflect(Resource, Component)]
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[derive(Component, Reflect)]
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[reflect(Component)]
</span><span>   struct SomeType(i32);
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[derive(Resource, Reflect)]
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   #[reflect(Resource)]
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   struct SomeResource(i32);
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   let mut world = World::default();
</span><span>   let atr = AppTypeRegistry::default();
</span><span>   {
</span><span>       let mut register = atr.write();
</span><span>       register.register::&LTSomeType>();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       register.register::&LTSomeResource>();
</span><span>   }
</span><span>   world.insert_resource(atr);
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(SomeType(123));
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   world.insert_resource(SomeResource(123));
</span><span>   let entity = world.spawn(SomeType(123)).id();
</span><span>
</span><span>   let scene = DynamicSceneBuilder::from_world(&world)
</span></code></pre></ul> <p>@@ -733,6 +738,6 @@ mod tests { assert!(resource .try_as_reflect() .expect(“resource should be concrete due to <code>FromReflect</code>”)</p> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       .is::&LTSomeType>());
</span></code></pre></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       .is::&LTSomeResource>());
</span></code></pre> } }</ul> <pre style=color:#61676c;background-color:#fafafa><code></code></pre>    <div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-10/pr_21589.patch id=patch-info style=display:none></div>  <div class=bottom-spacer></div> 