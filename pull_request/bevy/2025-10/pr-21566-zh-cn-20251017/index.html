<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21566 Add tests to document three separate asset issues.
        
    </title><meta content="#21566 Add tests to document three separate asset issues." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-10/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-10-17</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-10/pr-21566-en-20251017>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=add-tests-to-document-three-separate-asset-issues>Add tests to document three separate asset issues</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Add tests to document three separate asset issues.<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/21566<li><strong>作者</strong>: andriyDev<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: A-Assets, S-Ready-For-Final-Review, C-Testing, D-Straightforward<li><strong>创建时间</strong>: 2025-10-16T21:11:01Z<li><strong>合并时间</strong>: 2025-10-17T00:41:17Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h1 id=mu-biao>目标</h1><ul><li>添加测试来“展示“ #20651、#12756 和 #21564 的问题。</ul><h2 id=jie-jue-fang-an>解决方案</h2><ul><li>添加了一些测试！</ul><h2 id=ce-shi>测试</h2><ul><li>是的</ul><h2 id=zhe-ge-pull-requestde-gu-shi>这个Pull Request的故事</h2><p>这个Pull Request的核心目的是通过编写测试用例来记录和验证三个独立的资产系统问题。在软件开发中，当发现bug时，编写重现问题的测试是修复过程的关键第一步。<p><strong>问题背景与测试策略</strong><p>开发者面临三个不同的资产系统问题，这些问题分别由不同的GitHub issue跟踪：<ul><li>#21564: 相同资产使用不同设置加载时产生相同句柄<li>#12756: 加载两个子资产时意外启动两次加载过程<li>#20651: 当资产仍然存活时，获取强句柄无法防止重新加载</ul><p>开发者采用了直接有效的测试策略：为每个问题编写独立的测试用例，这些测试暂时断言当前错误的行为，并包含注释说明在相应问题修复后应该如何更新断言。<p><strong>测试实现细节</strong><p>第一个测试 <code>same_asset_different_settings</code> 验证资产加载器设置功能。它创建了一个自定义的 <code>U8Asset</code> 和 <code>U8Loader</code>，其中资产值直接从加载器设置中复制：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ed9366>_</span><span>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> dyn Reader,
</span><span>    </span><span style=color:#ff8f40>settings</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Settings,
</span><span>    </span><span style=color:#ed9366>_</span><span>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>LoadContext<'</span><span style=color:#ed9366>_</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Asset, </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Error> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(U8Asset(settings</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>))
</span><span>}
</span></code></pre><p>测试使用相同路径但不同设置值(1和2)加载资产两次。理想情况下，这应该产生两个不同的句柄和不同的资产值，但由于#21564的问题，目前产生相同的句柄和值。<p>第二个测试 <code>loading_two_subassets_does_not_start_two_loads</code> 验证子资产加载行为。它创建了一个加载器，在单个加载操作中注册两个带标签的子资产：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_labeled_asset</span><span>(</span><span style=color:#86b300>"A"</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>,</span><span> TestAsset)</span><span style=color:#61676ccc>;
</span><span>load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_labeled_asset</span><span>(</span><span style=color:#86b300>"B"</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>,</span><span> TestAsset)</span><span style=color:#61676ccc>;
</span></code></pre><p>测试然后分别加载两个子资产 <code>test.txt#A</code> 和 <code>test.txt#B</code>。在正常情况下，这应该只启动一次加载操作，但由于#12756的问题，目前会启动两次加载。<p>第三个测试 <code>get_strong_handle_prevents_reload_when_asset_still_alive</code> 验证强句柄的生命周期管理。测试首先加载一个资产，然后通过 <code>get_strong_handle</code> 获取新的强句柄：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> new_handle </span><span style=color:#ed9366>=</span><span> app
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span>resource_mut</span><span style=color:#ed9366>::</span><span>&LTAssets&LTTestAsset>>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>get_strong_handle</span><span>(original_handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p>在丢弃原始句柄后，资产应该仍然存活，因为新句柄保持引用。当再次尝试加载相同资产时，系统应该重用现有资产而不是启动新加载。但由于#20651的问题，目前会启动第二次加载。<p><strong>工程价值与模式</strong><p>这种测试方法体现了几个重要的工程实践：<ol><li><strong>问题隔离</strong>: 每个测试专注于一个特定问题，便于理解和调试<li><strong>临时断言</strong>: 测试当前断言错误行为，但包含清晰的注释说明预期的正确行为<li><strong>回归防护</strong>: 为未来的修复提供验证基础，确保修复不会引入回归</ol><p>测试使用了Bevy资产系统的核心组件，包括 <code>AssetLoader</code> trait、<code>AssetServer</code>、<code>LoadContext</code> 和句柄管理，展示了资产加载管道的实际使用模式。<h2 id=ke-shi-hua-biao-shi>可视化表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[AssetServer] --> B[AssetLoader]
</span><span>    B --> C[LoadContext]
</span><span>    C --> D[Subasset A]
</span><span>    C --> E[Subasset B]
</span><span>    F[Handle Management] --> G[Strong Handle]
</span><span>    F --> H[Weak Handle]
</span><span>    I[Loader Settings] --> J[Asset Creation]
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><p><strong>crates/bevy_asset/src/lib.rs</strong> (+227/-0)<p>这个文件添加了三个新的测试函数来验证资产系统的三个不同问题：<ol><li><code>same_asset_different_settings</code> - 测试资产加载器设置功能</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>same_asset_different_settings</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 测试使用不同设置加载相同资产两次
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 这应该产生两个不同的资产
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 测试实现细节
</span><span>}
</span></code></pre><ol start=2><li><code>loading_two_subassets_does_not_start_two_loads</code> - 测试子资产加载行为</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>] 
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>loading_two_subassets_does_not_start_two_loads</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 测试加载两个子资产不应该启动两次加载
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 测试实现细节
</span><span>}
</span></code></pre><ol start=3><li><code>get_strong_handle_prevents_reload_when_asset_still_alive</code> - 测试强句柄生命周期管理</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get_strong_handle_prevents_reload_when_asset_still_alive</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 测试当资产仍然存活时，获取强句柄应该防止重新加载
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 测试实现细节
</span><span>}
</span></code></pre><p>每个测试都包含：<ul><li>自定义资产加载器实现<li>内存资产源设置<li>应用初始化和资产注册<li>当前错误行为的断言，附带修复后的预期行为注释</ul><h2 id=jin-yi-bu-yue-du>进一步阅读</h2><p>建议阅读以下资源来深入了解相关概念：<ol><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/books/assets/ target=_blank>Bevy资产系统文档</a> - Bevy官方资产系统指南<li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch11-00-testing.html target=_blank>Rust测试框架</a> - Rust标准测试方法<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/21564 target=_blank>GitHub Issue #21564</a> - 资产设置处理问题<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/12756 target=_blank>GitHub Issue #12756</a> - 子资产加载问题<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/20651 target=_blank>GitHub Issue #20651</a> - 强句柄生命周期管理问题</ol><h2 id=wan-zheng-dai-ma-chai-yi>完整代码差异</h2><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
</span><span>index 2a185c50f5a15..92ff7a9b22941 100644
</span><span style=color:#c594c5>--- a/crates/bevy_asset/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_asset/src/lib.rs
</span><span style=color:#c594c5>@@ -3258,4 +3258,231 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         // This assertion exists to "prove" that this problem exists.
</span><span>         assert!(processed_dir.get_asset(gltfx_path).is_none());
</span><span>     }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn same_asset_different_settings() {
</span><span style=color:#86b300>+        // Test loading the same asset twice with different settings. This should
</span><span style=color:#86b300>+        // produce two distinct assets.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // First, implement an asset that's a single u8, whose value is copied from
</span><span style=color:#86b300>+        // the loader settings.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        #[derive(Asset, TypePath)]
</span><span style=color:#86b300>+        struct U8Asset(u8);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        #[derive(Serialize, Deserialize, Default)]
</span><span style=color:#86b300>+        struct U8LoaderSettings(u8);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        struct U8Loader;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        impl AssetLoader for U8Loader {
</span><span style=color:#86b300>+            type Asset = U8Asset;
</span><span style=color:#86b300>+            type Settings = U8LoaderSettings;
</span><span style=color:#86b300>+            type Error = crate::loader::LoadDirectError;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            async fn load(
</span><span style=color:#86b300>+                &self,
</span><span style=color:#86b300>+                _: &mut dyn Reader,
</span><span style=color:#86b300>+                settings: &Self::Settings,
</span><span style=color:#86b300>+                _: &mut LoadContext<'_>,
</span><span style=color:#86b300>+            ) -> Result&LTSelf::Asset, Self::Error> {
</span><span style=color:#86b300>+                Ok(U8Asset(settings.0))
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            fn extensions(&self) -> &[&str] {
</span><span style=color:#86b300>+                &["u8"]
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Create a test asset.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let dir = Dir::default();
</span><span style=color:#86b300>+        dir.insert_asset(Path::new("test.u8"), &[]);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_source = AssetSource::build()
</span><span style=color:#86b300>+            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Set up the app.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.register_asset_source(AssetSourceId::Default, asset_source)
</span><span style=color:#86b300>+            .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
</span><span style=color:#86b300>+            .init_asset::&LTU8Asset>()
</span><span style=color:#86b300>+            .register_asset_loader(U8Loader);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_server = app.world().resource::&LTAssetServer>();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Load the test asset twice but with different settings.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        fn load(asset_server: &AssetServer, path: &'static str, value: u8) -> Handle&LTU8Asset> {
</span><span style=color:#86b300>+            asset_server.load_with_settings::&LTU8Asset, U8LoaderSettings>(
</span><span style=color:#86b300>+                path,
</span><span style=color:#86b300>+                move |s: &mut U8LoaderSettings| s.0 = value,
</span><span style=color:#86b300>+            )
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let handle_1 = load(asset_server, "test.u8", 1);
</span><span style=color:#86b300>+        let handle_2 = load(asset_server, "test.u8", 2);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Handles should be different.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // These handles should be different, but due to
</span><span style=color:#86b300>+        // https://github.com/bevyengine/bevy/pull/21564, they are not. Once 21564 is fixed, we
</span><span style=color:#86b300>+        // should replace these expects.
</span><span style=color:#86b300>+        //
</span><span style=color:#86b300>+        // assert_ne!(handle_1, handle_2);
</span><span style=color:#86b300>+        assert_eq!(handle_1, handle_2);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        run_app_until(&mut app, |world| {
</span><span style=color:#86b300>+            let (Some(asset_1), Some(asset_2)) = (
</span><span style=color:#86b300>+                world.resource::&LTAssets&LTU8Asset>>().get(&handle_1),
</span><span style=color:#86b300>+                world.resource::&LTAssets&LTU8Asset>>().get(&handle_2),
</span><span style=color:#86b300>+            ) else {
</span><span style=color:#86b300>+                return None;
</span><span style=color:#86b300>+            };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            // Values should match the settings.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            // These values should be different, but due to
</span><span style=color:#86b300>+            // https://github.com/bevyengine/bevy/pull/21564, they are not. Once 21564 is fixed, we
</span><span style=color:#86b300>+            // should replace these expects.
</span><span style=color:#86b300>+            //
</span><span style=color:#86b300>+            // assert_eq!(asset_1.0, 1);
</span><span style=color:#86b300>+            // assert_eq!(asset_2.0, 2);
</span><span style=color:#86b300>+            assert_eq!(asset_1.0, asset_2.0);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            Some(())
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn loading_two_subassets_does_not_start_two_loads() {
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let dir = Dir::default();
</span><span style=color:#86b300>+        dir.insert_asset(Path::new("test.txt"), &[]);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_source = AssetSource::build()
</span><span style=color:#86b300>+            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.register_asset_source(AssetSourceId::Default, asset_source)
</span><span style=color:#86b300>+            .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
</span><span style=color:#86b300>+            .init_asset::&LTTestAsset>();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        struct TwoSubassetLoader;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        impl AssetLoader for TwoSubassetLoader {
</span><span style=color:#86b300>+            type Asset = TestAsset;
</span><span style=color:#86b300>+            type Settings = ();
</span><span style=color:#86b300>+            type Error = std::io::Error;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            async fn load(
</span><span style=color:#86b300>+                &self,
</span><span style=color:#86b300>+                _reader: &mut dyn Reader,
</span><span style=color:#86b300>+                _settings: &Self::Settings,
</span><span style=color:#86b300>+                load_context: &mut LoadContext<'_>,
</span><span style=color:#86b300>+            ) -> Result&LTSelf::Asset, Self::Error> {
</span><span style=color:#86b300>+                load_context.add_labeled_asset("A".into(), TestAsset);
</span><span style=color:#86b300>+                load_context.add_labeled_asset("B".into(), TestAsset);
</span><span style=color:#86b300>+                Ok(TestAsset)
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            fn extensions(&self) -> &[&str] {
</span><span style=color:#86b300>+                &["txt"]
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.register_asset_loader(TwoSubassetLoader);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_server = app.world().resource::&LTAssetServer>().clone();
</span><span style=color:#86b300>+        let _subasset_1: Handle&LTTestAsset> = asset_server.load("test.txt#A");
</span><span style=color:#86b300>+        let _subasset_2: Handle&LTTestAsset> = asset_server.load("test.txt#B");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Due to https://github.com/bevyengine/bevy/issues/12756, this expectation fails. Once
</span><span style=color:#86b300>+        // #12756 is fixed, we should swap these asserts.
</span><span style=color:#86b300>+        //
</span><span style=color:#86b300>+        // assert_eq!(get_started_load_count(app.world()), 1);
</span><span style=color:#86b300>+        assert_eq!(get_started_load_count(app.world()), 2);
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn get_strong_handle_prevents_reload_when_asset_still_alive() {
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let dir = Dir::default();
</span><span style=color:#86b300>+        dir.insert_asset(Path::new("test.txt"), &[]);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_source = AssetSource::build()
</span><span style=color:#86b300>+            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.register_asset_source(AssetSourceId::Default, asset_source)
</span><span style=color:#86b300>+            .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
</span><span style=color:#86b300>+            .init_asset::&LTTestAsset>();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        struct TrivialLoader;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        impl AssetLoader for TrivialLoader {
</span><span style=color:#86b300>+            type Asset = TestAsset;
</span><span style=color:#86b300>+            type Settings = ();
</span><span style=color:#86b300>+            type Error = std::io::Error;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            async fn load(
</span><span style=color:#86b300>+                &self,
</span><span style=color:#86b300>+                _reader: &mut dyn Reader,
</span><span style=color:#86b300>+                _settings: &Self::Settings,
</span><span style=color:#86b300>+                _load_context: &mut LoadContext<'_>,
</span><span style=color:#86b300>+            ) -> Result&LTSelf::Asset, Self::Error> {
</span><span style=color:#86b300>+                Ok(TestAsset)
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            fn extensions(&self) -> &[&str] {
</span><span style=color:#86b300>+                &["txt"]
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.register_asset_loader(TrivialLoader);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let asset_server = app.world().resource::&LTAssetServer>().clone();
</span><span style=color:#86b300>+        let original_handle: Handle&LTTestAsset> = asset_server.load("test.txt");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Wait for the asset to load.
</span><span style=color:#86b300>+        run_app_until(&mut app, |world| {
</span><span style=color:#86b300>+            world
</span><span style=color:#86b300>+                .resource::&LTAssets&LTTestAsset>>()
</span><span style=color:#86b300>+                .get(&original_handle)
</span><span style=color:#86b300>+                .map(|_| ())
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        assert_eq!(get_started_load_count(app.world()), 1);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Get a new strong handle from the original handle's ID.
</span><span style=color:#86b300>+        let new_handle = app
</span><span style=color:#86b300>+            .world_mut()
</span><span style=color:#86b300>+            .resource_mut::&LTAssets&LTTestAsset>>()
</span><span style=color:#86b300>+            .get_strong_handle(original_handle.id())
</span><span style=color:#86b300>+            .unwrap();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Drop the original handle. This should still leave the asset alive.
</span><span style=color:#86b300>+        drop(original_handle);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+        assert!(app
</span><span style=color:#86b300>+            .world()
</span><span style=color:#86b300>+            .resource::&LTAssets&LTTestAsset>>()
</span><span style=color:#86b300>+            .get(&new_handle)
</span><span style=color:#86b300>+            .is_some());
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let _other_handle: Handle&LTTestAsset> = asset_server.load("test.txt");
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+        // The asset server should **not** have started a new load, since the asset is still alive.
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Due to https://github.com/bevyengine/bevy/issues/20651, we do get a second load. Once
</span><span style=color:#86b300>+        // #20651 is fixed, we should swap these asserts.
</span><span style=color:#86b300>+        //
</span><span style=color:#86b300>+        // assert_eq!(get_started_load_count(app.world()), 1);
</span><span style=color:#86b300>+        assert_eq!(get_started_load_count(app.world()), 2);
</span><span style=color:#86b300>+    }
</span><span> }
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-10/pr_21566.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>