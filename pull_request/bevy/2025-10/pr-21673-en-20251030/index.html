<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21673 Add tests for asset processing under hot reloading and across asset sources.
        
    </title><meta content="#21673 Add tests for asset processing under hot reloading and across asset sources." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-10/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-10-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-10/pr-21673-zh-cn-20251030>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add tests for asset processing under hot reloading and across asset sources.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21673<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Assets, S-Ready-For-Final-Review, C-Testing, D-Straightforward<li><strong>Created</strong>: 2025-10-28T07:20:10Z<li><strong>Merged</strong>: 2025-10-30T16:20:13Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Trying to rewrite asset processing to be dynamic is hard, especially since we don’t have tests verifying all the situations asset processing is supposed to be able to handle!</ul><h2 id=solution>Solution</h2><ul><li>Add a couple more tests! One to check that processing multiple sources works, and another to check that sending asset events triggers processing (including processing of dependent processing).</ul><h2 id=testing>Testing</h2><ul><li>;)</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a critical gap in Bevy’s asset processing system testing infrastructure. The core problem was straightforward: when working on dynamic asset processing improvements, developers lacked comprehensive tests that could validate the system’s behavior across different scenarios, particularly involving multiple asset sources and hot reloading.<p>The solution approach focused on building robust test coverage that simulates real-world asset processing scenarios. The developer recognized that asset processing needs to handle complex dependency chains and cross-source asset references reliably. Rather than making functional changes to the asset processing logic itself, this PR strengthens the test suite to ensure future changes don’t break existing functionality.<p>The implementation centers around two key test scenarios. First, the test infrastructure was refactored to support multiple asset sources simultaneously. The <code>create_app_with_asset_processor</code> function was enhanced to accept a list of extra source names and return structured <code>ProcessingDirs</code> for each source, complete with event channels for simulating file system changes. This setup allows tests to verify that assets from different sources are processed independently and correctly.<p>Second, the tests validate that asset processing properly handles hot reloading scenarios. The <code>run_app_until_finished_processing</code> function was updated with a fixed iteration count to handle race conditions in multithreaded environments where asset events might compete with processor state transitions.<p>The technical insights from this implementation reveal several important patterns. The test infrastructure now properly simulates asset watchers through <code>FakeWatcher</code> and event channels, allowing tests to trigger reprocessing by sending <code>AssetSourceEvent::ModifiedAsset</code> events. The use of <code>Arc&LTMutex&LTu32>></code> counters in the nested asset test provides a reliable way to track how many times processing occurs, which is crucial for validating that dependencies are reprocessed correctly.<p>The impact of these tests is significant for the Bevy asset system’s reliability. They provide concrete validation that:<ul><li>Assets from multiple sources are processed independently<li>Hot reloading triggers reprocessing of modified assets<li>Dependency chains across different asset sources work correctly<li>Unchanged assets aren’t unnecessarily reprocessed</ul><p>These tests will serve as critical guardrails during future refactoring of the asset processing system, particularly the planned dynamic asset processing improvements mentioned in the PR description.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[Test Infrastructure] --> B[Multi-Source Processing Test]
</span><span>    A --> C[Hot Reloading Test]
</span><span>    
</span><span>    B --> D[Default Source]
</span><span>    B --> E[Custom Source 1]
</span><span>    B --> F[Custom Source 2]
</span><span>    
</span><span>    C --> G[Dependency Chain]
</span><span>    C --> H[Event-Driven Reprocessing]
</span><span>    C --> I[Process Counting]
</span><span>    
</span><span>    G --> J[Cross-Source Dependencies]
</span><span>    H --> K[ModifiedAsset Events]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-asset-src-processor-tests-rs-501-64><code>crates/bevy_asset/src/processor/tests.rs</code> (+501/-64)</h3><p>This file received substantial additions to support comprehensive testing of asset processing across multiple sources and under hot reloading conditions.<p><strong>Key Changes:</strong><ol><li><strong>Enhanced Test Infrastructure</strong>: The <code>create_app_with_asset_processor</code> function was completely refactored to support multiple asset sources:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Single source setup
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>create_app_with_asset_processor</span><span>() </span><span style=color:#61676ccc>-></span><span> AppWithProcessor
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Multi-source setup  
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>create_app_with_asset_processor</span><span>(</span><span style=color:#ff8f40>extra_sources</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[String]) </span><span style=color:#61676ccc>-></span><span> AppWithProcessor
</span></code></pre><p>The new implementation uses a builder pattern with <code>UnfinishedProcessingDirs</code> to properly handle the asynchronous nature of asset watcher setup.<ol start=2><li><strong>New Test: Multi-Source Processing</strong>: Added <code>asset_processor_processes_all_sources</code> test that validates processing across default and custom sources:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>asset_processor_processes_all_sources</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> AppWithProcessor {
</span><span>        </span><span style=color:#fa6e32>mut</span><span> app</span><span style=color:#61676ccc>,
</span><span>        default_source_dirs</span><span style=color:#61676ccc>:</span><span> ProcessingDirs { source</span><span style=color:#61676ccc>:</span><span> default_source_dir</span><span style=color:#61676ccc>,</span><span> processed</span><span style=color:#61676ccc>:</span><span> default_processed_dir</span><span style=color:#61676ccc>,</span><span> source_event_sender</span><span style=color:#61676ccc>:</span><span> default_source_events }</span><span style=color:#61676ccc>,
</span><span>        extra_sources_dirs</span><span style=color:#61676ccc>,
</span><span>    } </span><span style=color:#ed9366>= </span><span style=color:#f07171>create_app_with_asset_processor</span><span>(</span><span style=color:#ed9366>&</span><span>[</span><span style=color:#86b300>"custom_1"</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"custom_2"</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()])</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test setup and assertions for multiple sources
</span><span>}
</span></code></pre><ol start=3><li><strong>New Test: Hot Reloading with Dependencies</strong>: Added <code>nested_loads_of_processed_asset_reprocesses_on_reload</code> test that validates dependency chain reprocessing:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>nested_loads_of_processed_asset_reprocesses_on_reload</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Complex test setup with cross-source dependencies and process counting
</span><span>    </span><span style=color:#fa6e32>let</span><span> process_counter </span><span style=color:#ed9366>= </span><span>Arc</span><span style=color:#ed9366>::</span><span>new(Mutex</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>0</span><span>))</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test validates that modifying a leaf asset reprocesses all dependent assets
</span><span>}
</span></code></pre><ol start=4><li><strong>Test Infrastructure Improvements</strong>: Added helper structures and functions:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Clone)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>ProcessingDirs </span><span>{
</span><span>    source</span><span style=color:#61676ccc>:</span><span> Dir,
</span><span>    processed</span><span style=color:#61676ccc>:</span><span> Dir,
</span><span>    source_event_sender</span><span style=color:#61676ccc>: </span><span>async_channel</span><span style=color:#ed9366>::</span><span>Sender&LTAssetSourceEvent>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>read_asset_as_string</span><span>(</span><span style=color:#ff8f40>dir</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Dir, </span><span style=color:#ff8f40>path</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Path) </span><span style=color:#61676ccc>-></span><span> String {
</span><span>    </span><span style=color:#fa6e32>let</span><span> bytes </span><span style=color:#ed9366>=</span><span> dir</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_asset</span><span>(path)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>str</span><span style=color:#ed9366>::</span><span>from_utf8(bytes</span><span style=color:#ed9366>.</span><span style=color:#f07171>value</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_string</span><span>()
</span><span>}
</span></code></pre><p>These changes provide the foundation for testing complex asset processing scenarios that mirror real-world use cases.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/assets/ target=_blank>Bevy Asset System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/assets/processing/ target=_blank>Asset Processing in Bevy</a><li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/ target=_blank>Async Programming in Rust</a><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Test-driven_development target=_blank>Test-Driven Development Principles</a></ul><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_asset/src/processor/tests.rs b/crates/bevy_asset/src/processor/tests.rs
</span><span>index 3cf62817a2159..133fde43ee3fd 100644
</span><span style=color:#c594c5>--- a/crates/bevy_asset/src/processor/tests.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_asset/src/processor/tests.rs
</span><span style=color:#c594c5>@@ -2,12 +2,18 @@ </span><span style=color:#399ee6>use alloc::{
</span><span>     boxed::Box,
</span><span>     collections::BTreeMap,
</span><span>     string::{String, ToString},
</span><span style=color:#86b300>+    sync::Arc,
</span><span>     vec,
</span><span>     vec::Vec,
</span><span> };
</span><span style=color:#86b300>+use bevy_platform::{
</span><span style=color:#86b300>+    collections::HashMap,
</span><span style=color:#86b300>+    sync::{Mutex, PoisonError},
</span><span style=color:#86b300>+};
</span><span> use bevy_reflect::TypePath;
</span><span> use core::marker::PhantomData;
</span><span> use futures_lite::AsyncWriteExt;
</span><span style=color:#86b300>+use ron::ser::PrettyConfig;
</span><span> use serde::{Deserialize, Serialize};
</span><span> use std::path::Path;
</span><span> 
</span><span style=color:#c594c5>@@ -18,7 +24,7 @@ </span><span style=color:#399ee6>use bevy_tasks::BoxedFuture;
</span><span> use crate::{
</span><span>     io::{
</span><span>         memory::{Dir, MemoryAssetReader, MemoryAssetWriter},
</span><span style=color:#f07171>-        AssetSource, AssetSourceId, Reader,
</span><span style=color:#86b300>+        AssetSource, AssetSourceEvent, AssetSourceId, AssetWatcher, Reader,
</span><span>     },
</span><span>     processor::{
</span><span>         AssetProcessor, LoadTransformAndSave, LogEntry, ProcessorState, ProcessorTransactionLog,
</span><span style=color:#c594c5>@@ -30,39 +36,99 @@ </span><span style=color:#399ee6>use crate::{
</span><span>     Asset, AssetApp, AssetLoader, AssetMode, AssetPath, AssetPlugin, LoadContext,
</span><span> };
</span><span> 
</span><span style=color:#86b300>+#[derive(Clone)]
</span><span style=color:#86b300>+struct ProcessingDirs {
</span><span style=color:#86b300>+    source: Dir,
</span><span style=color:#86b300>+    processed: Dir,
</span><span style=color:#86b300>+    source_event_sender: async_channel::Sender&LTAssetSourceEvent>,
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span> struct AppWithProcessor {
</span><span>     app: App,
</span><span style=color:#f07171>-    source_dir: Dir,
</span><span style=color:#f07171>-    processed_dir: Dir,
</span><span style=color:#86b300>+    default_source_dirs: ProcessingDirs,
</span><span style=color:#86b300>+    extra_sources_dirs: HashMap&LTString, ProcessingDirs>,
</span><span> }
</span><span> 
</span><span style=color:#f07171>-fn create_app_with_asset_processor() -> AppWithProcessor {
</span><span style=color:#86b300>+fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor {
</span><span>     let mut app = App::new();
</span><span style=color:#f07171>-    let source_dir = Dir::default();
</span><span style=color:#f07171>-    let processed_dir = Dir::default();
</span><span> 
</span><span style=color:#f07171>-    let source_memory_reader = MemoryAssetReader {
</span><span style=color:#f07171>-        root: source_dir.clone(),
</span><span style=color:#f07171>-    };
</span><span style=color:#f07171>-    let processed_memory_reader = MemoryAssetReader {
</span><span style=color:#f07171>-        root: processed_dir.clone(),
</span><span style=color:#f07171>-    };
</span><span style=color:#f07171>-    let processed_memory_writer = MemoryAssetWriter {
</span><span style=color:#f07171>-        root: processed_dir.clone(),
</span><span style=color:#f07171>-    };
</span><span style=color:#86b300>+    struct UnfinishedProcessingDirs {
</span><span style=color:#86b300>+        source: Dir,
</span><span style=color:#86b300>+        processed: Dir,
</span><span style=color:#86b300>+        // The receiver channel for the source event sender for the unprocessed source.
</span><span style=color:#86b300>+        source_event_sender_receiver:
</span><span style=color:#86b300>+            async_channel::Receiver&LTasync_channel::Sender&LTAssetSourceEvent>>,
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    impl UnfinishedProcessingDirs {
</span><span style=color:#86b300>+        fn finish(self) -> ProcessingDirs {
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: self.source,
</span><span style=color:#86b300>+                processed: self.processed,
</span><span style=color:#86b300>+                // The processor listens for events on the source unconditionally, and we enable
</span><span style=color:#86b300>+                // watching for the processed source, so both of these channels will be filled.
</span><span style=color:#86b300>+                source_event_sender: self.source_event_sender_receiver.recv_blocking().unwrap(),
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    fn create_source(app: &mut App, source_id: AssetSourceId<'static>) -> UnfinishedProcessingDirs {
</span><span style=color:#86b300>+        let source_dir = Dir::default();
</span><span style=color:#86b300>+        let processed_dir = Dir::default();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let source_memory_reader = MemoryAssetReader {
</span><span style=color:#86b300>+            root: source_dir.clone(),
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+        let processed_memory_reader = MemoryAssetReader {
</span><span style=color:#86b300>+            root: processed_dir.clone(),
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+        let processed_memory_writer = MemoryAssetWriter {
</span><span style=color:#86b300>+            root: processed_dir.clone(),
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let (source_event_sender_sender, source_event_sender_receiver) = async_channel::bounded(1);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        struct FakeWatcher;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        impl AssetWatcher for FakeWatcher {}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.register_asset_source(
</span><span style=color:#86b300>+            source_id,
</span><span style=color:#86b300>+            AssetSource::build()
</span><span style=color:#86b300>+                .with_reader(move || Box::new(source_memory_reader.clone()))
</span><span style=color:#86b300>+                .with_watcher(move |sender: async_channel::Sender&LTAssetSourceEvent>| {
</span><span style=color:#86b300>+                    source_event_sender_sender.send_blocking(sender).unwrap();
</span><span style=color:#86b300>+                    Some(Box::new(FakeWatcher))
</span><span style=color:#86b300>+                })
</span><span style=color:#86b300>+                .with_processed_reader(move || Box::new(processed_memory_reader.clone()))
</span><span style=color:#86b300>+                .with_processed_writer(move |_| Some(Box::new(processed_memory_writer.clone()))),
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        UnfinishedProcessingDirs {
</span><span style=color:#86b300>+            source: source_dir,
</span><span style=color:#86b300>+            processed: processed_dir,
</span><span style=color:#86b300>+            source_event_sender_receiver,
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let default_source_dirs = create_source(&mut app, AssetSourceId::Default);
</span><span> 
</span><span style=color:#f07171>-    app.register_asset_source(
</span><span style=color:#f07171>-        AssetSourceId::Default,
</span><span style=color:#f07171>-        AssetSource::build()
</span><span style=color:#f07171>-            .with_reader(move || Box::new(source_memory_reader.clone()))
</span><span style=color:#f07171>-            .with_processed_reader(move || Box::new(processed_memory_reader.clone()))
</span><span style=color:#f07171>-            .with_processed_writer(move |_| Some(Box::new(processed_memory_writer.clone()))),
</span><span style=color:#f07171>-    )
</span><span style=color:#f07171>-    .add_plugins((
</span><span style=color:#86b300>+    let extra_sources_dirs = extra_sources
</span><span style=color:#86b300>+        .iter()
</span><span style=color:#86b300>+        .map(|source_name| {
</span><span style=color:#86b300>+            (
</span><span style=color:#86b300>+                source_name.clone(),
</span><span style=color:#86b300>+                create_source(&mut app, AssetSourceId::Name(source_name.clone().into())),
</span><span style=color:#86b300>+            )
</span><span style=color:#86b300>+        })
</span><span style=color:#86b300>+        .collect::&LTVec<_>>();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    app.add_plugins((
</span><span>         TaskPoolPlugin::default(),
</span><span>         AssetPlugin {
</span><span>             mode: AssetMode::Processed,
</span><span>             use_asset_processor_override: Some(true),
</span><span style=color:#86b300>+            watch_for_changes_override: Some(true),
</span><span>             ..Default::default()
</span><span>         },
</span><span>     ));
</span><span style=color:#c594c5>@@ -113,14 +179,25 @@ </span><span style=color:#399ee6>fn create_app_with_asset_processor() -> AppWithProcessor {
</span><span>         .set_log_factory(Box::new(FakeTransactionLogFactory))
</span><span>         .unwrap();
</span><span> 
</span><span style=color:#86b300>+    // Now that we've built the app, finish all the processing dirs.
</span><span style=color:#86b300>+
</span><span>     AppWithProcessor {
</span><span>         app,
</span><span style=color:#f07171>-        source_dir,
</span><span style=color:#f07171>-        processed_dir,
</span><span style=color:#86b300>+        default_source_dirs: default_source_dirs.finish(),
</span><span style=color:#86b300>+        extra_sources_dirs: extra_sources_dirs
</span><span style=color:#86b300>+            .into_iter()
</span><span style=color:#86b300>+            .map(|(name, dirs)| (name, dirs.finish()))
</span><span style=color:#86b300>+            .collect(),
</span><span>     }
</span><span> }
</span><span> 
</span><span> fn run_app_until_finished_processing(app: &mut App) {
</span><span style=color:#86b300>+    // If the original source changes through an AssetSourceEvent, we'll be racing (on
</span><span style=color:#86b300>+    // multithreaded) between this and processor thread switching the state to `Processing`. So do a
</span><span style=color:#86b300>+    // fixed number of iterations so the processor thread is likely to win.
</span><span style=color:#86b300>+    for _ in 0..5 {
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+    }
</span><span>     run_app_until(app, |world| {
</span><span>         if bevy_tasks::block_on(world.resource::&LTAssetProcessor>().get_state())
</span><span>             == ProcessorState::Finished
</span><span style=color:#c594c5>@@ -162,7 +239,7 @@ </span><span style=color:#399ee6>impl AssetSaver for CoolTextSaver {
</span><span>             // another file to do so.
</span><span>             embedded_dependencies: vec![],
</span><span>         };
</span><span style=color:#f07171>-        let ron = ron::ser::to_string(&ron).unwrap();
</span><span style=color:#86b300>+        let ron = ron::ser::to_string_pretty(&ron, PrettyConfig::new().new_line("\n")).unwrap();
</span><span>         writer.write_all(ron.as_bytes()).await?;
</span><span>         Ok(())
</span><span>     }
</span><span style=color:#c594c5>@@ -199,6 +276,19 @@ </span><span style=color:#399ee6>impl&LTM: MutateAsset&LTA>, A: Asset> AssetTransformer for RootAssetTransformer&LTM, A
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#86b300>+struct AddText(String);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+impl MutateAsset&LTCoolText> for AddText {
</span><span style=color:#86b300>+    fn mutate(&self, text: &mut CoolText) {
</span><span style=color:#86b300>+        text.text.push_str(&self.0);
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn read_asset_as_string(dir: &Dir, path: &Path) -> String {
</span><span style=color:#86b300>+    let bytes = dir.get_asset(path).unwrap();
</span><span style=color:#86b300>+    str::from_utf8(bytes.value()).unwrap().to_string()
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span> #[test]
</span><span> fn no_meta_or_default_processor_copies_asset() {
</span><span>     // Assets without a meta file or a default processor should still be accessible in the
</span><span style=color:#c594c5>@@ -209,9 +299,14 @@ </span><span style=color:#399ee6>fn no_meta_or_default_processor_copies_asset() {
</span><span> 
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#f07171>-        source_dir,
</span><span style=color:#f07171>-        processed_dir,
</span><span style=color:#f07171>-    } = create_app_with_asset_processor();
</span><span style=color:#86b300>+        default_source_dirs:
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: source_dir,
</span><span style=color:#86b300>+                processed: processed_dir,
</span><span style=color:#86b300>+                ..
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        ..
</span><span style=color:#86b300>+    } = create_app_with_asset_processor(&[]);
</span><span> 
</span><span>     let path = Path::new("abc.cool.ron");
</span><span>     let source_asset = r#"(
</span><span style=color:#c594c5>@@ -234,17 +329,14 @@ </span><span style=color:#399ee6>fn no_meta_or_default_processor_copies_asset() {
</span><span> fn asset_processor_transforms_asset_default_processor() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#f07171>-        source_dir,
</span><span style=color:#f07171>-        processed_dir,
</span><span style=color:#f07171>-    } = create_app_with_asset_processor();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    struct AddText;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    impl MutateAsset&LTCoolText> for AddText {
</span><span style=color:#f07171>-        fn mutate(&self, text: &mut CoolText) {
</span><span style=color:#f07171>-            text.text.push_str("_def");
</span><span style=color:#f07171>-        }
</span><span style=color:#f07171>-    }
</span><span style=color:#86b300>+        default_source_dirs:
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: source_dir,
</span><span style=color:#86b300>+                processed: processed_dir,
</span><span style=color:#86b300>+                ..
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        ..
</span><span style=color:#86b300>+    } = create_app_with_asset_processor(&[]);
</span><span> 
</span><span>     type CoolTextProcessor = LoadTransformAndSave<
</span><span>         CoolTextLoader,
</span><span style=color:#c594c5>@@ -253,7 +345,7 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_default_processor() {
</span><span>     >;
</span><span>     app.register_asset_loader(CoolTextLoader)
</span><span>         .register_asset_processor(CoolTextProcessor::new(
</span><span style=color:#f07171>-            RootAssetTransformer::new(AddText),
</span><span style=color:#86b300>+            RootAssetTransformer::new(AddText("_def".into())),
</span><span>             CoolTextSaver,
</span><span>         ))
</span><span>         .set_default_asset_processor::&LTCoolTextProcessor>("cool.ron");
</span><span style=color:#c594c5>@@ -275,7 +367,12 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_default_processor() {
</span><span>     let processed_asset = str::from_utf8(processed_asset.value()).unwrap();
</span><span>     assert_eq!(
</span><span>         processed_asset,
</span><span style=color:#f07171>-        r#"(text:"abc_def",dependencies:[],embedded_dependencies:[],sub_texts:[])"#
</span><span style=color:#86b300>+        r#"(
</span><span style=color:#86b300>+    text: "abc_def",
</span><span style=color:#86b300>+    dependencies: [],
</span><span style=color:#86b300>+    embedded_dependencies: [],
</span><span style=color:#86b300>+    sub_texts: [],
</span><span style=color:#86b300>+)"#
</span><span>     );
</span><span> }
</span><span> 
</span><span style=color:#c594c5>@@ -283,17 +380,14 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_default_processor() {
</span><span> fn asset_processor_transforms_asset_with_meta() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#f07171>-        source_dir,
</span><span style=color:#f07171>-        processed_dir,
</span><span style=color:#f07171>-    } = create_app_with_asset_processor();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    struct AddText;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    impl MutateAsset&LTCoolText> for AddText {
</span><span style=color:#f07171>-        fn mutate(&self, text: &mut CoolText) {
</span><span style=color:#f07171>-            text.text.push_str("_def");
</span><span style=color:#f07171>-        }
</span><span style=color:#f07171>-    }
</span><span style=color:#86b300>+        default_source_dirs:
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: source_dir,
</span><span style=color:#86b300>+                processed: processed_dir,
</span><span style=color:#86b300>+                ..
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        ..
</span><span style=color:#86b300>+    } = create_app_with_asset_processor(&[]);
</span><span> 
</span><span>     type CoolTextProcessor = LoadTransformAndSave<
</span><span>         CoolTextLoader,
</span><span style=color:#c594c5>@@ -302,7 +396,7 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_with_meta() {
</span><span>     >;
</span><span>     app.register_asset_loader(CoolTextLoader)
</span><span>         .register_asset_processor(CoolTextProcessor::new(
</span><span style=color:#f07171>-            RootAssetTransformer::new(AddText),
</span><span style=color:#86b300>+            RootAssetTransformer::new(AddText("_def".into())),
</span><span>             CoolTextSaver,
</span><span>         ));
</span><span> 
</span><span style=color:#c594c5>@@ -319,7 +413,7 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_with_meta() {
</span><span>     source_dir.insert_meta_text(path, r#"(
</span><span>     meta_format_version: "1.0",
</span><span>     asset: Process(
</span><span style=color:#f07171>-        processor: "bevy_asset::processor::process::LoadTransformAndSave&LTbevy_asset::tests::CoolTextLoader, bevy_asset::processor::tests::RootAssetTransformer&LTbevy_asset::processor::tests::asset_processor_transforms_asset_with_meta::AddText, bevy_asset::tests::CoolText>, bevy_asset::processor::tests::CoolTextSaver>",
</span><span style=color:#86b300>+        processor: "bevy_asset::processor::process::LoadTransformAndSave&LTbevy_asset::tests::CoolTextLoader, bevy_asset::processor::tests::RootAssetTransformer&LTbevy_asset::processor::tests::AddText, bevy_asset::tests::CoolText>, bevy_asset::processor::tests::CoolTextSaver>",
</span><span>         settings: (
</span><span>             loader_settings: (),
</span><span>             transformer_settings: (),
</span><span style=color:#c594c5>@@ -334,7 +428,12 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_with_meta() {
</span><span>     let processed_asset = str::from_utf8(processed_asset.value()).unwrap();
</span><span>     assert_eq!(
</span><span>         processed_asset,
</span><span style=color:#f07171>-        r#"(text:"abc_def",dependencies:[],embedded_dependencies:[],sub_texts:[])"#
</span><span style=color:#86b300>+        r#"(
</span><span style=color:#86b300>+    text: "abc_def",
</span><span style=color:#86b300>+    dependencies: [],
</span><span style=color:#86b300>+    embedded_dependencies: [],
</span><span style=color:#86b300>+    sub_texts: [],
</span><span style=color:#86b300>+)"#
</span><span>     );
</span><span> }
</span><span> 
</span><span style=color:#c594c5>@@ -462,8 +561,6 @@ </span><span style=color:#399ee6>impl AssetSaver for FakeBsnSaver {
</span><span>     ) -> Result<(), Self::Error> {
</span><span>         use std::io::{Error, ErrorKind};
</span><span> 
</span><span style=color:#f07171>-        use ron::ser::PrettyConfig;
</span><span style=color:#f07171>-
</span><span>         let ron_string =
</span><span>             ron::ser::to_string_pretty(asset.get(), PrettyConfig::new().new_line("\n"))
</span><span>                 .map_err(|err| Error::new(ErrorKind::InvalidData, err))?;
</span><span style=color:#c594c5>@@ -477,9 +574,14 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_processed_assets() {
</span><span> 
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#f07171>-        source_dir,
</span><span style=color:#f07171>-        processed_dir,
</span><span style=color:#f07171>-    } = create_app_with_asset_processor();
</span><span style=color:#86b300>+        default_source_dirs:
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: source_dir,
</span><span style=color:#86b300>+                processed: processed_dir,
</span><span style=color:#86b300>+                ..
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        ..
</span><span style=color:#86b300>+    } = create_app_with_asset_processor(&[]);
</span><span> 
</span><span>     // This processor loads a gltf file, converts it to BSN and then saves out the BSN.
</span><span>     type GltfProcessor = LoadTransformAndSave&LTFakeGltfLoader, GltfToBsn, FakeBsnSaver>;
</span><span style=color:#c594c5>@@ -543,9 +645,14 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_processed_assets() {
</span><span> fn asset_processor_loading_can_read_source_assets() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#f07171>-        source_dir,
</span><span style=color:#f07171>-        processed_dir,
</span><span style=color:#f07171>-    } = create_app_with_asset_processor();
</span><span style=color:#86b300>+        default_source_dirs:
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: source_dir,
</span><span style=color:#86b300>+                processed: processed_dir,
</span><span style=color:#86b300>+                ..
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        ..
</span><span style=color:#86b300>+    } = create_app_with_asset_processor(&[]);
</span><span> 
</span><span>     #[derive(Serialize, Deserialize)]
</span><span>     struct FakeGltfxData {
</span><span style=color:#c594c5>@@ -726,3 +833,333 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_source_assets() {
</span><span>     // This assertion exists to "prove" that this problem exists.
</span><span>     assert!(processed_dir.get_asset(gltfx_path).is_none());
</span><span> }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#[test]
</span><span style=color:#86b300>+fn asset_processor_processes_all_sources() {
</span><span style=color:#86b300>+    let AppWithProcessor {
</span><span style=color:#86b300>+        mut app,
</span><span style=color:#86b300>+        default_source_dirs:
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: default_source_dir,
</span><span style=color:#86b300>+                processed: default_processed_dir,
</span><span style=color:#86b300>+                source_event_sender: default_source_events,
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        extra_sources_dirs,
</span><span style=color:#86b300>+    } = create_app_with_asset_processor(&["custom_1".into(), "custom_2".into()]);
</span><span style=color:#86b300>+    let ProcessingDirs {
</span><span style=color:#86b300>+        source: custom_1_source_dir,
</span><span style=color:#86b300>+        processed: custom_1_processed_dir,
</span><span style=color:#86b300>+        source_event_sender: custom_1_source_events,
</span><span style=color:#86b300>+    } = extra_sources_dirs["custom_1"].clone();
</span><span style=color:#86b300>+    let ProcessingDirs {
</span><span style=color:#86b300>+        source: custom_2_source_dir,
</span><span style=color:#86b300>+        processed: custom_2_processed_dir,
</span><span style=color:#86b300>+        source_event_sender: custom_2_source_events,
</span><span style=color:#86b300>+    } = extra_sources_dirs["custom_2"].clone();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    type AddTextProcessor = LoadTransformAndSave<
</span><span style=color:#86b300>+        CoolTextLoader,
</span><span style=color:#86b300>+        RootAssetTransformer&LTAddText, CoolText>,
</span><span style=color:#86b300>+        CoolTextSaver,
</span><span style=color:#86b300>+    >;
</span><span style=color:#86b300>+    app.init_asset::&LTCoolText>()
</span><span style=color:#86b300>+        .init_asset::&LTSubText>()
</span><span style=color:#86b300>+        .register_asset_loader(CoolTextLoader)
</span><span style=color:#86b300>+        .register_asset_processor(AddTextProcessor::new(
</span><span style=color:#86b300>+            RootAssetTransformer::new(AddText(" processed".into())),
</span><span style=color:#86b300>+            CoolTextSaver,
</span><span style=color:#86b300>+        ))
</span><span style=color:#86b300>+        .set_default_asset_processor::&LTAddTextProcessor>("cool.ron");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // All the assets will have the same path, but they will still be separately processed since
</span><span style=color:#86b300>+    // they are in different sources.
</span><span style=color:#86b300>+    let path = Path::new("asset.cool.ron");
</span><span style=color:#86b300>+    let serialize_as_cool_text = |text: &str| {
</span><span style=color:#86b300>+        let cool_text_ron = CoolTextRon {
</span><span style=color:#86b300>+            text: text.into(),
</span><span style=color:#86b300>+            dependencies: vec![],
</span><span style=color:#86b300>+            embedded_dependencies: vec![],
</span><span style=color:#86b300>+            sub_texts: vec![],
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+        ron::ser::to_string_pretty(&cool_text_ron, PrettyConfig::new().new_line("\n")).unwrap()
</span><span style=color:#86b300>+    };
</span><span style=color:#86b300>+    default_source_dir.insert_asset_text(path, &serialize_as_cool_text("default asset"));
</span><span style=color:#86b300>+    custom_1_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 1 asset"));
</span><span style=color:#86b300>+    custom_2_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 2 asset"));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // Check that all the assets are processed.
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&default_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("default asset processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_1_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("custom 1 asset processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_2_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("custom 2 asset processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // Update the default source asset and notify the watcher.
</span><span style=color:#86b300>+    default_source_dir.insert_asset_text(path, &serialize_as_cool_text("default asset changed"));
</span><span style=color:#86b300>+    default_source_events
</span><span style=color:#86b300>+        .send_blocking(AssetSourceEvent::ModifiedAsset(path.to_path_buf()))
</span><span style=color:#86b300>+        .unwrap();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // Check that all the assets are processed again.
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&default_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("default asset changed processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_1_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("custom 1 asset processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_2_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("custom 2 asset processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // Update the custom source assets and notify the watchers.
</span><span style=color:#86b300>+    custom_1_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 1 asset changed"));
</span><span style=color:#86b300>+    custom_2_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 2 asset changed"));
</span><span style=color:#86b300>+    custom_1_source_events
</span><span style=color:#86b300>+        .send_blocking(AssetSourceEvent::ModifiedAsset(path.to_path_buf()))
</span><span style=color:#86b300>+        .unwrap();
</span><span style=color:#86b300>+    custom_2_source_events
</span><span style=color:#86b300>+        .send_blocking(AssetSourceEvent::ModifiedAsset(path.to_path_buf()))
</span><span style=color:#86b300>+        .unwrap();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // Check that all the assets are processed again.
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&default_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("default asset changed processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_1_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("custom 1 asset changed processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_2_processed_dir, path),
</span><span style=color:#86b300>+        serialize_as_cool_text("custom 2 asset changed processed")
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#[test]
</span><span style=color:#86b300>+fn nested_loads_of_processed_asset_reprocesses_on_reload() {
</span><span style=color:#86b300>+    let AppWithProcessor {
</span><span style=color:#86b300>+        mut app,
</span><span style=color:#86b300>+        default_source_dirs:
</span><span style=color:#86b300>+            ProcessingDirs {
</span><span style=color:#86b300>+                source: default_source_dir,
</span><span style=color:#86b300>+                processed: default_processed_dir,
</span><span style=color:#86b300>+                source_event_sender: default_source_events,
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        extra_sources_dirs,
</span><span style=color:#86b300>+    } = create_app_with_asset_processor(&["custom".into()]);
</span><span style=color:#86b300>+    let ProcessingDirs {
</span><span style=color:#86b300>+        source: custom_source_dir,
</span><span style=color:#86b300>+        processed: custom_processed_dir,
</span><span style=color:#86b300>+        source_event_sender: custom_source_events,
</span><span style=color:#86b300>+    } = extra_sources_dirs["custom"].clone();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[derive(Serialize, Deserialize)]
</span><span style=color:#86b300>+    enum NesterSerialized {
</span><span style=color:#86b300>+        Leaf(String),
</span><span style=color:#86b300>+        Path(String),
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[derive(Asset, TypePath)]
</span><span style=color:#86b300>+    struct Nester {
</span><span style=color:#86b300>+        value: String,
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    struct NesterLoader;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    impl AssetLoader for NesterLoader {
</span><span style=color:#86b300>+        type Asset = Nester;
</span><span style=color:#86b300>+        type Settings = ();
</span><span style=color:#86b300>+        type Error = std::io::Error;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        async fn load(
</span><span style=color:#86b300>+            &self,
</span><span style=color:#86b300>+            reader: &mut dyn Reader,
</span><span style=color:#86b300>+            _settings: &Self::Settings,
</span><span style=color:#86b300>+            load_context: &mut LoadContext<'_>,
</span><span style=color:#86b300>+        ) -> Result&LTSelf::Asset, Self::Error> {
</span><span style=color:#86b300>+            let mut bytes = vec![];
</span><span style=color:#86b300>+            reader.read_to_end(&mut bytes).await?;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            let serialized: NesterSerialized = ron::de::from_bytes(&bytes).unwrap();
</span><span style=color:#86b300>+            Ok(match serialized {
</span><span style=color:#86b300>+                NesterSerialized::Leaf(value) => Nester { value },
</span><span style=color:#86b300>+                NesterSerialized::Path(path) => {
</span><span style=color:#86b300>+                    let loaded_asset = load_context.loader().immediate().load(path).await.unwrap();
</span><span style=color:#86b300>+                    loaded_asset.take()
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+            })
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        fn extensions(&self) -> &[&str] {
</span><span style=color:#86b300>+            &["nest"]
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    struct AddTextToNested(String, Arc&LTMutex&LTu32>>);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    impl MutateAsset&LTNester> for AddTextToNested {
</span><span style=color:#86b300>+        fn mutate(&self, asset: &mut Nester) {
</span><span style=color:#86b300>+            asset.value.push_str(&self.0);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            *self.1.lock().unwrap_or_else(PoisonError::into_inner) += 1;
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    fn serialize_as_leaf(value: String) -> String {
</span><span style=color:#86b300>+        let serialized = NesterSerialized::Leaf(value);
</span><span style=color:#86b300>+        ron::ser::to_string(&serialized).unwrap()
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    struct NesterSaver;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    impl AssetSaver for NesterSaver {
</span><span style=color:#86b300>+        type Asset = Nester;
</span><span style=color:#86b300>+        type Error = std::io::Error;
</span><span style=color:#86b300>+        type Settings = ();
</span><span style=color:#86b300>+        type OutputLoader = NesterLoader;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        async fn save(
</span><span style=color:#86b300>+            &self,
</span><span style=color:#86b300>+            writer: &mut crate::io::Writer,
</span><span style=color:#86b300>+            asset: crate::saver::SavedAsset<'_, Self::Asset>,
</span><span style=color:#86b300>+            _settings: &Self::Settings,
</span><span style=color:#86b300>+        ) -> Result<&LTSelf::OutputLoader as AssetLoader>::Settings, Self::Error> {
</span><span style=color:#86b300>+            let serialized = serialize_as_leaf(asset.get().value.clone());
</span><span style=color:#86b300>+            writer.write_all(serialized.as_bytes()).await
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let process_counter = Arc::new(Mutex::new(0));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    type NesterProcessor = LoadTransformAndSave<
</span><span style=color:#86b300>+        NesterLoader,
</span><span style=color:#86b300>+        RootAssetTransformer&LTAddTextToNested, Nester>,
</span><span style=color:#86b300>+        NesterSaver,
</span><span style=color:#86b300>+    >;
</span><span style=color:#86b300>+    app.init_asset::&LTNester>()
</span><span style=color:#86b300>+        .register_asset_loader(NesterLoader)
</span><span style=color:#86b300>+        .register_asset_processor(NesterProcessor::new(
</span><span style=color:#86b300>+            RootAssetTransformer::new(AddTextToNested("-ref".into(), process_counter.clone())),
</span><span style=color:#86b300>+            NesterSaver,
</span><span style=color:#86b300>+        ))
</span><span style=color:#86b300>+        .set_default_asset_processor::&LTNesterProcessor>("nest");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // This test also checks that processing of nested assets can occur across asset sources.
</span><span style=color:#86b300>+    custom_source_dir.insert_asset_text(
</span><span style=color:#86b300>+        Path::new("top.nest"),
</span><span style=color:#86b300>+        &ron::ser::to_string(&NesterSerialized::Path("middle.nest".into())).unwrap(),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    default_source_dir.insert_asset_text(
</span><span style=color:#86b300>+        Path::new("middle.nest"),
</span><span style=color:#86b300>+        &ron::ser::to_string(&NesterSerialized::Path("custom://bottom.nest".into())).unwrap(),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    custom_source_dir
</span><span style=color:#86b300>+        .insert_asset_text(Path::new("bottom.nest"), &serialize_as_leaf("leaf".into()));
</span><span style=color:#86b300>+    default_source_dir.insert_asset_text(
</span><span style=color:#86b300>+        Path::new("unrelated.nest"),
</span><span style=color:#86b300>+        &serialize_as_leaf("unrelated".into()),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // The initial processing step should have processed all assets.
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_processed_dir, Path::new("bottom.nest")),
</span><span style=color:#86b300>+        serialize_as_leaf("leaf-ref".into())
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&default_processed_dir, Path::new("middle.nest")),
</span><span style=color:#86b300>+        serialize_as_leaf("leaf-ref-ref".into())
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&custom_processed_dir, Path::new("top.nest")),
</span><span style=color:#86b300>+        serialize_as_leaf("leaf-ref-ref-ref".into())
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+    assert_eq!(
</span><span style=color:#86b300>+        read_asset_as_string(&default_processed_dir, Path::new("unrelated.nest")),
</span><span style=color:#86b300>+        serialize_as_leaf("unrelated-ref".into())
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let get_process_count = || {
</span><span style=color:#86b300>+        *process_counter
</span><span style=color:#86b300>+            .lock()
</span><span style=color:#86b300>+            .unwrap_or_else(PoisonError::into_inner)
</span><span style=color:#86b300>+    };
</span><span style=color:#86b300>+   </span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-10/pr_21673.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>