diff --git a/benches/benches/bevy_ecs/entity_cloning.rs b/benches/benches/bevy_ecs/entity_cloning.rs
index 44ffa1d52b993..8f1bdb82b8baf 100644
--- a/benches/benches/bevy_ecs/entity_cloning.rs
+++ b/benches/benches/bevy_ecs/entity_cloning.rs
@@ -159,7 +159,7 @@ fn single(c: &mut Criterion) {
     group.finish();
 }
 
-/// Benchmarks cloning an an entity and its 50 descendents, each with only 1 component.
+/// Benchmarks cloning an entity and its 50 descendents, each with only 1 component.
 fn hierarchy_tall(c: &mut Criterion) {
     let mut group = c.benchmark_group(bench!("hierarchy_tall"));
 
@@ -175,7 +175,7 @@ fn hierarchy_tall(c: &mut Criterion) {
     group.finish();
 }
 
-/// Benchmarks cloning an an entity and its 50 direct children, each with only 1 component.
+/// Benchmarks cloning an entity and its 50 direct children, each with only 1 component.
 fn hierarchy_wide(c: &mut Criterion) {
     let mut group = c.benchmark_group(bench!("hierarchy_wide"));
 
diff --git a/benches/benches/bevy_picking/ray_mesh_intersection.rs b/benches/benches/bevy_picking/ray_mesh_intersection.rs
index 2f49a7a9145e7..7a0bf91901426 100644
--- a/benches/benches/bevy_picking/ray_mesh_intersection.rs
+++ b/benches/benches/bevy_picking/ray_mesh_intersection.rs
@@ -44,7 +44,7 @@ fn create_mesh(vertices_per_side: u32) -> SimpleMesh {
         // All vertices have the same normal.
         normals.push([0.0, 1.0, 0.0]);
 
-        // Extend the indices for for all vertices except for the final row and column, since
+        // Extend the indices for all vertices except for the final row and column, since
         // indices are "between" points.
         if p % vertices_per_side != vertices_per_side - 1
             && p / vertices_per_side != vertices_per_side - 1
diff --git a/crates/bevy_asset/src/processor/mod.rs b/crates/bevy_asset/src/processor/mod.rs
index 79d7305da146f..68c26a6effdca 100644
--- a/crates/bevy_asset/src/processor/mod.rs
+++ b/crates/bevy_asset/src/processor/mod.rs
@@ -82,7 +82,7 @@ use {
 /// A "background" asset processor that reads asset values from a source [`AssetSource`] (which corresponds to an [`AssetReader`](crate::io::AssetReader) / [`AssetWriter`](crate::io::AssetWriter) pair),
 /// processes them in some way, and writes them to a destination [`AssetSource`].
 ///
-/// This will create .meta files (a human-editable serialized form of [`AssetMeta`]) in the source [`AssetSource`] for assets that
+/// This will create .meta files (a human-editable serialized form of [`AssetMeta`]) in the source [`AssetSource`] for assets
 /// that can be loaded and/or processed. This enables developers to configure how each asset should be loaded and/or processed.
 ///
 /// [`AssetProcessor`] can be run in the background while a Bevy App is running. Changes to assets will be automatically detected and hot-reloaded.
diff --git a/crates/bevy_asset/src/server/info.rs b/crates/bevy_asset/src/server/info.rs
index 6d8a4da28ecdb..435d6bb4ccf2b 100644
--- a/crates/bevy_asset/src/server/info.rs
+++ b/crates/bevy_asset/src/server/info.rs
@@ -242,7 +242,7 @@ impl AssetInfos {
                 } else {
                     // Asset meta exists, but all live handles were dropped. This means the `track_assets` system
                     // hasn't been run yet to remove the current asset
-                    // (note that this is guaranteed to be transactional with the `track_assets` system because
+                    // (note that this is guaranteed to be transactional with the `track_assets` system
                     // because it locks the AssetInfos collection)
 
                     // We must create a new strong handle for the existing id and ensure that the drop of the old
diff --git a/crates/bevy_ecs/src/entity/index_map.rs b/crates/bevy_ecs/src/entity/index_map.rs
index 9067b12ca28b2..3e94f51362c29 100644
--- a/crates/bevy_ecs/src/entity/index_map.rs
+++ b/crates/bevy_ecs/src/entity/index_map.rs
@@ -588,7 +588,7 @@ impl<V> Slice<V> {
         IntoKeys(self.into_boxed_inner().into_keys(), PhantomData)
     }
 
-    /// Return an iterator over mutable references to the the values of the map slice.
+    /// Return an iterator over mutable references to the values of the map slice.
     ///
     /// Equivalent to [`map::Slice::values_mut`].
     pub fn values_mut(&mut self) -> ValuesMut<'_, Entity, V> {
diff --git a/crates/bevy_ecs/src/observer/system_param.rs b/crates/bevy_ecs/src/observer/system_param.rs
index 3391d3eb4d26c..c82e19b7ab09c 100644
--- a/crates/bevy_ecs/src/observer/system_param.rs
+++ b/crates/bevy_ecs/src/observer/system_param.rs
@@ -24,7 +24,7 @@ use core::{
 /// The entity involved *does not* have to have these components, but the observer will only be
 /// triggered if the event matches the components in `B`.
 ///
-/// This is used to to avoid providing a generic argument in your event, as is done for [`Add`]
+/// This is used to avoid providing a generic argument in your event, as is done for [`Add`]
 /// and the other lifecycle events.
 ///
 /// Providing multiple components in this bundle will cause this event to be triggered by any
diff --git a/crates/bevy_ecs/src/schedule/graph/tarjan_scc.rs b/crates/bevy_ecs/src/schedule/graph/tarjan_scc.rs
index 23584cab95f38..5b66722d884f5 100644
--- a/crates/bevy_ecs/src/schedule/graph/tarjan_scc.rs
+++ b/crates/bevy_ecs/src/schedule/graph/tarjan_scc.rs
@@ -13,7 +13,7 @@ use crate::schedule::graph::{DiGraph, GraphNodeId};
 /// [1]: https://homepages.ecs.vuw.ac.nz/~djp/files/P05.pdf
 /// [2]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
 ///
-/// Returns each strongly strongly connected component (scc).
+/// Returns each strongly connected component (scc).
 /// The order of node ids within each scc is arbitrary, but the order of
 /// the sccs is their postorder (reverse topological sort).
 pub(crate) fn new_tarjan_scc<N: GraphNodeId, S: BuildHasher>(
@@ -102,7 +102,7 @@ impl<
     /// [1]: https://homepages.ecs.vuw.ac.nz/~djp/files/P05.pdf
     /// [2]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
     ///
-    /// Returns `Some` for each strongly strongly connected component (scc).
+    /// Returns `Some` for each strongly connected component (scc).
     /// The order of node ids within each scc is arbitrary, but the order of
     /// the sccs is their postorder (reverse topological sort).
     fn next_scc(&mut self) -> Option<&[N]> {
diff --git a/crates/bevy_ecs/src/storage/table/column.rs b/crates/bevy_ecs/src/storage/table/column.rs
index 7211d04cae8ba..239a7bfeb7244 100644
--- a/crates/bevy_ecs/src/storage/table/column.rs
+++ b/crates/bevy_ecs/src/storage/table/column.rs
@@ -71,7 +71,7 @@ impl Column {
     /// # Safety
     /// - `last_element_index` must be the index of the last element—stored in the highest place in memory.
     /// - `row.as_usize()` <= `last_element_index`
-    /// -   The caller should update the their saved length to reflect the change (decrement it by 1).
+    /// -   The caller should update their saved length to reflect the change (decrement it by 1).
     pub(crate) unsafe fn swap_remove_and_drop_unchecked(
         &mut self,
         last_element_index: usize,
@@ -118,7 +118,7 @@ impl Column {
     /// # Safety
     /// - `last_element_index` must be the index of the last element—stored in the highest place in memory.
     /// - `row.as_usize()` <= `last_element_index`
-    /// -   The caller should update the their saved length to reflect the change (decrement it by 1).
+    /// -   The caller should update their saved length to reflect the change (decrement it by 1).
     pub(crate) unsafe fn swap_remove_and_forget_unchecked(
         &mut self,
         last_element_index: usize,
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index c126efcd8d839..024c127aab8b2 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -4138,7 +4138,7 @@ mod tests {
 
         let iterate_and_count_entities = |world: &World, entity_counters: &mut HashMap<_, _>| {
             entity_counters.clear();
-            #[expect(deprecated, reason = "remove this test in in 0.17.0")]
+            #[expect(deprecated, reason = "remove this test in 0.17.0")]
             for entity in world.iter_entities() {
                 let counter = entity_counters.entry(entity.id()).or_insert(0);
                 *counter += 1;
@@ -4227,7 +4227,7 @@ mod tests {
         assert_eq!(world.entity(b1).get(), Some(&B(1)));
         assert_eq!(world.entity(b2).get(), Some(&B(2)));
 
-        #[expect(deprecated, reason = "remove this test in in 0.17.0")]
+        #[expect(deprecated, reason = "remove this test in 0.17.0")]
         for mut entity in world.iter_entities_mut() {
             if let Some(mut b) = entity.get_mut::<B>() {
                 b.0 *= 2;
@@ -4238,7 +4238,7 @@ mod tests {
         assert_eq!(world.entity(b1).get(), Some(&B(2)));
         assert_eq!(world.entity(b2).get(), Some(&B(4)));
 
-        #[expect(deprecated, reason = "remove this test in in 0.17.0")]
+        #[expect(deprecated, reason = "remove this test in 0.17.0")]
         let mut entities = world.iter_entities_mut().collect::<Vec<_>>();
         entities.sort_by_key(|e| e.get::<A>().map(|a| a.0).or(e.get::<B>().map(|b| b.0)));
         let (a, b) = entities.split_at_mut(2);
diff --git a/crates/bevy_picking/src/events.rs b/crates/bevy_picking/src/events.rs
index 5659cb331ef98..1e3ec18f38851 100644
--- a/crates/bevy_picking/src/events.rs
+++ b/crates/bevy_picking/src/events.rs
@@ -437,7 +437,7 @@ pub struct PickingMessageWriters<'w> {
 ///
 /// When the pointer goes from hovering entity A to entity B, entity A will
 /// receive [`Out`] and then entity B will receive [`Over`]. No entity will ever
-/// receive both an [`Over`] and and a [`Out`] event during the same frame.
+/// receive both an [`Over`] and an [`Out`] event during the same frame.
 ///
 /// When we account for event bubbling, this is no longer true. When the hovering focus shifts
 /// between children, parent entities may receive redundant [`Out`] → [`Over`] pairs.
diff --git a/crates/bevy_ptr/src/lib.rs b/crates/bevy_ptr/src/lib.rs
index cd7e07ddee243..99cd38b6ab4ca 100644
--- a/crates/bevy_ptr/src/lib.rs
+++ b/crates/bevy_ptr/src/lib.rs
@@ -473,7 +473,7 @@ impl<'a, T, A: IsAligned> MovingPtr<'a, T, A> {
     ///
     /// # Safety
     /// - `inner` must point to valid value of `T`.
-    /// - If the `A` type parameter is [`Aligned`] then `inner` must be be [properly aligned] for `T`.
+    /// - If the `A` type parameter is [`Aligned`] then `inner` must be [properly aligned] for `T`.
     /// - `inner` must have correct provenance to allow read and writes of the pointee type.
     /// - The lifetime `'a` must be constrained such that this [`MovingPtr`] will stay valid and nothing
     ///   else can read or mutate the pointee while this [`MovingPtr`] is live.
@@ -812,7 +812,7 @@ impl<'a, A: IsAligned> Ptr<'a, A> {
     ///
     /// # Safety
     /// - `inner` must point to valid value of whatever the pointee type is.
-    /// - If the `A` type parameter is [`Aligned`] then `inner` must be be [properly aligned]for the pointee type.
+    /// - If the `A` type parameter is [`Aligned`] then `inner` must be [properly aligned] for the pointee type.
     /// - `inner` must have correct provenance to allow reads of the pointee type.
     /// - The lifetime `'a` must be constrained such that this [`Ptr`] will stay valid and nothing
     ///   can mutate the pointee while this [`Ptr`] is live except through an [`UnsafeCell`].
@@ -838,7 +838,7 @@ impl<'a, A: IsAligned> Ptr<'a, A> {
     ///
     /// # Safety
     /// - `T` must be the erased pointee type for this [`Ptr`].
-    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be be [properly aligned]
+    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be [properly aligned]
     ///   for the pointee type `T`.
     ///
     /// [properly aligned]: https://doc.rust-lang.org/std/ptr/index.html#alignment
@@ -873,7 +873,7 @@ impl<'a, A: IsAligned> PtrMut<'a, A> {
     ///
     /// # Safety
     /// - `inner` must point to valid value of whatever the pointee type is.
-    /// - If the `A` type parameter is [`Aligned`] then `inner` must be be [properly aligned] for the pointee type.
+    /// - If the `A` type parameter is [`Aligned`] then `inner` must be [properly aligned] for the pointee type.
     /// - `inner` must have correct provenance to allow read and writes of the pointee type.
     /// - The lifetime `'a` must be constrained such that this [`PtrMut`] will stay valid and nothing
     ///   else can read or mutate the pointee while this [`PtrMut`] is live.
@@ -897,7 +897,7 @@ impl<'a, A: IsAligned> PtrMut<'a, A> {
     ///
     /// # Safety
     /// - `T` must be the erased pointee type for this [`PtrMut`].
-    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be be [properly aligned]
+    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be [properly aligned]
     ///   for the pointee type `T`.
     ///
     /// [properly aligned]: https://doc.rust-lang.org/std/ptr/index.html#alignment
@@ -983,7 +983,7 @@ impl<'a, A: IsAligned> OwningPtr<'a, A> {
     ///
     /// # Safety
     /// - `T` must be the erased pointee type for this [`OwningPtr`].
-    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be be [properly aligned]
+    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be [properly aligned]
     ///   for the pointee type `T`.
     ///
     /// [properly aligned]: https://doc.rust-lang.org/std/ptr/index.html#alignment
@@ -1007,7 +1007,7 @@ impl<'a, A: IsAligned> OwningPtr<'a, A> {
     ///
     /// # Safety
     /// - `T` must be the erased pointee type for this [`OwningPtr`].
-    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be be [properly aligned]
+    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be [properly aligned]
     ///   for the pointee type `T`.
     ///
     /// [properly aligned]: https://doc.rust-lang.org/std/ptr/index.html#alignment
@@ -1208,7 +1208,7 @@ macro_rules! move_as_ptr {
     };
 }
 
-/// Helper macro used by [`deconstruct_moving_ptr`] to to extract
+/// Helper macro used by [`deconstruct_moving_ptr`] to extract
 /// the pattern from `field: pattern` or `field` shorthand.
 #[macro_export]
 #[doc(hidden)]
diff --git a/crates/bevy_reflect/derive/src/from_reflect.rs b/crates/bevy_reflect/derive/src/from_reflect.rs
index bf7867903e84c..c2e5240995a8d 100644
--- a/crates/bevy_reflect/derive/src/from_reflect.rs
+++ b/crates/bevy_reflect/derive/src/from_reflect.rs
@@ -210,7 +210,7 @@ fn impl_struct_internal(
 /// Get the collection of ignored field definitions
 ///
 /// Each value of the `MemberValuePair` is a token stream that generates a
-/// a default value for the ignored field.
+/// default value for the ignored field.
 fn get_ignored_fields(reflect_struct: &ReflectStruct) -> MemberValuePair {
     MemberValuePair::new(
         reflect_struct
diff --git a/crates/bevy_reflect/src/lib.rs b/crates/bevy_reflect/src/lib.rs
index 9649d23470b61..6c6dfadb46edd 100644
--- a/crates/bevy_reflect/src/lib.rs
+++ b/crates/bevy_reflect/src/lib.rs
@@ -814,7 +814,7 @@ pub mod __macro_exports {
 
             static REGISTRATION_FNS: Mutex<Vec<fn(&mut TypeRegistry)>> = Mutex::new(Vec::new());
 
-            /// Adds adds a new registration function for [`TypeRegistry`]
+            /// Adds a new registration function for [`TypeRegistry`]
             pub fn push_registration_fn(registration_fn: fn(&mut TypeRegistry)) {
                 REGISTRATION_FNS.lock().unwrap().push(registration_fn);
             }
diff --git a/crates/bevy_render/src/renderer/mod.rs b/crates/bevy_render/src/renderer/mod.rs
index d5fe24a9a3940..cbc93d3b2a5c3 100644
--- a/crates/bevy_render/src/renderer/mod.rs
+++ b/crates/bevy_render/src/renderer/mod.rs
@@ -473,7 +473,7 @@ pub async fn initialize_renderer(
 /// The context with all information required to interact with the GPU.
 ///
 /// The [`RenderDevice`] is used to create render resources and the
-/// the [`CommandEncoder`] is used to record a series of GPU operations.
+/// [`CommandEncoder`] is used to record a series of GPU operations.
 pub struct RenderContext<'w> {
     render_device: RenderDevice,
     command_encoder: Option<CommandEncoder>,
diff --git a/crates/bevy_state/src/state/state_set.rs b/crates/bevy_state/src/state/state_set.rs
index e060f299e3346..b7e16900eef17 100644
--- a/crates/bevy_state/src/state/state_set.rs
+++ b/crates/bevy_state/src/state/state_set.rs
@@ -57,7 +57,7 @@ pub trait StateSet: StateSetSealed {
 /// The isolation works because it is implemented for both S & [`Option<S>`], and has the `RawState` associated type
 /// that allows it to know what the resource in the world should be. We can then essentially "unwrap" it in our
 /// `StateSet` implementation - and the behavior of that unwrapping will depend on the arguments expected by the
-/// the [`ComputedStates`] & [`SubStates]`.
+/// [`ComputedStates`] & [`SubStates]`.
 trait InnerStateSet: Sized {
     type RawState: States;
 
diff --git a/release-content/migration-guides/extracted_uinodes_z_order.md b/release-content/migration-guides/extracted_uinodes_z_order.md
index b0bdd2a1fdf93..4f6fd4ef41596 100644
--- a/release-content/migration-guides/extracted_uinodes_z_order.md
+++ b/release-content/migration-guides/extracted_uinodes_z_order.md
@@ -5,7 +5,7 @@ pull_requests: [19691]
 
 `ExtractedUiNode`’s `stack_index` field has been renamed to `z_order` and its type changed from `u32` to `f32`.
 Previously `stack_index` would be converted into an `f32` after extraction during the `Render` schedule, then
-offsets would be applied applied to determine draw order before sorting (lowest value rendered first).
+offsets would be applied to determine draw order before sorting (lowest value rendered first).
 For example, a node's fill color is given an offset of `0.` and a box shadow is given an offset of `-0.1`, so that
 the shadow will be drawn behind the node.
 
diff --git a/release-content/migration-guides/removed_simple_executor.md b/release-content/migration-guides/removed_simple_executor.md
index 73b4585d98f78..02bbcfdb600de 100644
--- a/release-content/migration-guides/removed_simple_executor.md
+++ b/release-content/migration-guides/removed_simple_executor.md
@@ -7,8 +7,8 @@ Bevy has removed the previously deprecated `SimpleExecutor`, one of the `SystemE
 The `MultiThreadedExecutor` is great at large schedules and async heavy work, and the `SingleThreadedExecutor` is good at smaller schedules or schedules that have fewer parallelizable systems.
 So what was `SimpleExecutor` good at? Not much. That's why it was removed. Removing it reduced some maintenance and consistency burdens on maintainers, allowing them to focus on more exciting features!
 
-If you were using `SimpleExecutor`, consider upgrading to `SingleThreadedExecutor` instead, or try `MultiThreadedExecutor` if if fits the schedule.
-It's worth mentioning that `SimpleExecutor` ran deferred commands inbetween *each* system, regardless of it it was needed.
+If you were using `SimpleExecutor`, consider upgrading to `SingleThreadedExecutor` instead, or try `MultiThreadedExecutor` if it fits the schedule.
+It's worth mentioning that `SimpleExecutor` ran deferred commands inbetween *each* system, regardless of if it was needed.
 The other executors are more efficient about this, but that means they need extra information about when to run those commands.
 In most schedules, that information comes from the contents and ordering of systems, via `before`, `after`, `chain`, etc.
 If a schedule that was previously using `SimpleExecutor` still needs commands from one system to be applied before another system runs,
