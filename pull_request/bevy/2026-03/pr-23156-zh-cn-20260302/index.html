<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23156 fix: reparenting perf
        
    </title><meta content="#23156 fix: reparenting perf" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-03/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-03-02</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-03/pr-23156-en-20260302>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=fix-reparenting-perf>fix: reparenting perf</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: fix: reparenting perf<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/23156<li><strong>作者</strong>: aevyrie<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: C-性能优化, S-准备最终评审, A-应用, X-无争议, D-直接明了<li><strong>创建时间</strong>: 2026-02-26T07:52:32Z<li><strong>合并时间</strong>: 2026-03-02T00:07:00Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h3 id=mu-biao>目标</h3><p><code>HierarchyPropagatePlugin</code> 包含一个系统 <code>update_reparented</code>，它每一帧都会扫描每个具有关系组件 <code>R</code> 的实体，以检测 <code>Changed&LTR></code>。这意味着即使没有任何变化，每一帧也需要迭代所有子实体。这是一个显著的每帧开销，且随着子实体数量的增加而线性增长。<p>修复 #23155<h3 id=jie-jue-fang-an>解决方案</h3><p>将 <code>update_reparented</code> 系统及其 <code>Changed&LTR></code> 查询替换为两个反应式生命周期观察器（reactive lifecycle observers）：<ul><li><strong><code>on_r_inserted</code></strong>: 注册在 <code>On&LTInsert, R></code> 上，仅当 <code>R</code> 实际被插入到实体上时触发。如果新的父实体有 <code>Inherited&LTC></code>，则将其复制到实体上，否则从实体中移除。<li><strong><code>on_r_removed</code></strong>: 注册在 <code>On&LTRemove, R></code> 上，仅当 <code>R</code> 实际从实体中移除时触发。如果实体继承了 <code>Inherited&LTC></code>，则移除它。</ul><p>这将 O(n) 的每帧扫描替换为 O(1) 的按事件反应。<h3 id=guan-yu-bian-geng-mutations-de-shuo-ming>关于变更（mutations）的说明</h3><p><code>Changed&LTR></code> 也能检测到对 <code>R</code> 的直接变更（mutation），而 <code>On&LTInsert, R></code> 则不能。<p>据我所知，这是可以安全忽略的；<strong>请审查此逻辑的正确性！</strong><p>像 <code>ChildOf</code> 这样的关系组件必须只能通过 <code>insert</code> 来更改，绝不能通过直接变更（direct mutation）。这是因为 <code>R</code> 带有通过组件钩子（component hooks）强制执行的簿记语义。插入一个新值会触发钩子，将实体从旧父实体的 <code>RelationshipTarget</code> 中移除，并添加到新的父实体中。通过 <code>Mut&LTR></code> 直接变更会完全绕过这些钩子，使得旧父实体和新父实体的 <code>RelationshipTarget</code> 处于不一致状态。任何这样做的应用程序都已经存在一个 bug。<code>On&LTInsert, R></code> 对于<strong>首次添加</strong>和替换（使用新值重新插入）都会触发，这涵盖了关系可能变化的每一种有效方式：<table><thead><tr><th>情况<th>旧方法（<code>Changed&LTR></code>）<th>新方法（<code>On&LTInsert, R></code> / <code>On&LTRemove, R></code>）<tbody><tr><td>带有 <code>R</code> 的新子实体生成（spawn）<td>✅<td>✅ 通过 <code>On&LTInsert, R></code><tr><td>实体重新分配父级（<code>insert(R)</code>）<td>✅<td>✅ 通过 <code>On&LTInsert, R></code><tr><td><code>R</code> 被移除（实体成为孤儿）<td>✅ 通过 <code>orphaned</code> 查询<td>✅ 通过 <code>On&LTRemove, R></code><tr><td>通过 <code>Mut&LTR></code> 直接变更 <code>R</code><td>✅<td>❌ 不支持：破坏关系不变性</table><h3 id=ce-shi>测试</h3><p>所有现有的传播测试都通过了，包括：<ul><li><code>test_reparented</code>：移动到不传播的父实体的实体会丢失 <code>Inherited&LTC></code><li><code>test_reparented_with_prior</code>：在两个传播父实体之间移动的实体会获取新值<li><code>test_remove_orphan</code>：移除了 <code>R</code> 的实体会丢失 <code>Inherited&LTC></code></ul><h2 id=guan-yu-ci-ci-prde-gu-shi>关于此次PR的故事</h2><h3 id=wen-ti-he-bei-jing>问题和背景</h3><p><code>HierarchyPropagatePlugin</code> 是 Bevy 引擎中用于组件继承的核心插件，它允许组件值在实体层次结构中自动传播。在 #23155 中，开发者识别到了一个性能问题：<code>update_reparented</code> 系统每一帧都会扫描所有带有特定关系组件（例如 <code>ChildOf</code>）的实体，检查它们的关系是否发生了变化（使用 <code>Changed&LTR></code> 查询）。这导致了 O(n) 的每帧开销，其中 n 是子实体的数量，即使场景中没有任何变化。<p>这种设计的问题是显而易见的：为了检测少数可能的变化，系统需要遍历所有相关实体。在一个大型场景中，可能有成千上万的子实体，这种开销会迅速累积，影响整体性能。<h3 id=jie-jue-fang-an-tu-jing>解决方案途径</h3><p>开发者采用了一种事件驱动（event-driven）的解决方案，利用 Bevy 新增的观察器（observer）系统。其核心思路是：与其每一帧主动扫描检查变化，不如监听实际发生的事件（插入或移除关系组件）。这样，只有真正发生变化时才会执行相应逻辑。<p>技术上，他们用两个观察器（<code>On&LTInsert, R></code> 和 <code>On&LTRemove, R></code>）替换了原来的 <code>Changed&LTR></code> 查询。这涉及到一个关键的设计决策：是否要放弃对直接组件变更（<code>Mut&LTR></code>）的检测。经过分析，开发者认为关系组件（如 <code>ChildOf</code>）不应该通过 <code>Mut</code> 直接修改，因为这会绕过必要的簿记钩子，导致数据不一致。因此，放弃对这种“非法“操作的支持是合理的。<h3 id=ju-ti-shi-xian>具体实现</h3><p>实现主要集中在 <code>propagate.rs</code> 文件中。原来的 <code>update_reparented</code> 系统被移除，代之以两个新的观察器函数：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Add/remove [`Inherited::&LTC>`] when an entity gains or changes its `R` relationship
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>on_r_inserted</span><span><
</span><span>    C</span><span style=color:#61676ccc>:</span><span> Component </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Clone </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>PartialEq</span><span>,
</span><span>    F</span><span style=color:#61676ccc>:</span><span> QueryFilter </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>'static</span><span>,
</span><span>    R</span><span style=color:#61676ccc>:</span><span> Relationship,
</span><span>>(
</span><span>    </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span>On&LTInsert, R>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#ff8f40>query</span><span style=color:#61676ccc>: </span><span>Query<(</span><span style=color:#ed9366>&</span><span>R, Has&LTInherited&LTC>>), (Without&LTPropagate&LTC>>, F)>,
</span><span>    </span><span style=color:#ff8f40>relations</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span>Inherited&LTC>, Without&LTPropagateStop&LTC>>>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>((relation</span><span style=color:#61676ccc>,</span><span> has_inherited)) </span><span style=color:#ed9366>=</span><span> query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(event</span><span style=color:#ed9366>.</span><span>entity) </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(inherited) </span><span style=color:#ed9366>=</span><span> relations</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(relation</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>()) {
</span><span>        commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(event</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_insert</span><span>(inherited</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>    } </span><span style=color:#fa6e32>else if</span><span> has_inherited {
</span><span>        commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(event</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#ed9366>.</span><span>try_remove</span><span style=color:#ed9366>::</span><span>&LTInherited&LTC>>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>这个函数只在关系组件 <code>R</code> 被插入时触发。它检查新父实体是否拥有 <code>Inherited&LTC></code> 组件：如果有，则将其复制到当前实体；如果当前实体原本有 <code>Inherited&LTC></code> 但新父实体没有，则移除它。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Remove [`Inherited::&LTC>`] when an entity loses its `R` relationship
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>on_r_removed</span><span>&LTC</span><span style=color:#61676ccc>:</span><span> Component </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Clone </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>PartialEq</span><span>, F</span><span style=color:#61676ccc>:</span><span> QueryFilter </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>'static</span><span>, R</span><span style=color:#61676ccc>:</span><span> Relationship>(
</span><span>    </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span>On&LTRemove, R>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#ff8f40>query</span><span style=color:#61676ccc>: </span><span>Query<(), (With&LTInherited&LTC>>, Without&LTPropagate&LTC>>, F)>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> query</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(event</span><span style=color:#ed9366>.</span><span>entity) {
</span><span>        commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(event</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#ed9366>.</span><span>try_remove</span><span style=color:#ed9366>::</span><span>&LTInherited&LTC>>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>这个函数处理关系组件被移除的情况。如果实体失去了关系组件并且本身有 <code>Inherited&LTC></code>，则将其移除。<p>这两个观察器函数通过 <code>app.add_observer()</code> 注册，而不是作为常规系统添加到调度中。这意味着它们仅在相应事件发生时执行，而不是每一帧都执行。<h3 id=ji-shu-dong-cha>技术洞察</h3><p>这个 PR 展示了几个重要的工程模式：<ol><li><p><strong>从轮询（polling）到事件驱动（event-driven）的转变</strong>：这是性能优化的经典模式。当变化频率远低于检查频率时，事件驱动方法能显著减少不必要的计算。</p><li><p><strong>利用框架新特性</strong>：这次修改依赖于 Bevy 的观察器系统，这是一个相对较新的特性。它允许开发者编写只在特定事件（如组件插入、移除）发生时触发的系统。</p><li><p><strong>有意识地放弃对边缘情况的支持</strong>：开发者明确决定不支持通过 <code>Mut</code> 直接修改关系组件，因为这种用法本身会导致不一致状态。这是一个合理的权衡：优化了常见路径（合法使用）的性能，同时明确标示出不受支持的用法。</p><li><p><strong>向后兼容性</strong>：所有现有测试都通过，表明这次重构保持了原有功能的正确性。</p></ol><h3 id=ying-xiang>影响</h3><p>这次修改的直接影响是显著减少了处理实体重新分配父级（reparenting）时的 CPU 开销。特别是对于大型场景，性能提升会更加明显。从架构角度看，这次修改使代码更加简洁且意图更明确：每个函数只处理一个特定的事件，而不是在一个复杂的查询中混合多种情况。<p>需要注意的是，这种方法假设关系组件不会被直接变更（mutation）。如果确实有代码通过 <code>Mut&LTR></code> 修改关系组件，那么这些代码现在会表现出不同的行为：继承的组件可能不会正确更新。开发者应该将这些用法迁移到正确的 <code>insert</code> 操作。<h2 id=ke-shi-hua-biao-shi>可视化表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    subgraph "之前的方法"
</span><span>        A[每帧系统 update_reparented] --> B[扫描所有具有关系组件 R 的实体]
</span><span>        B --> C{是否 Changed&LTR>?}
</span><span>        C -->|是| D[更新继承组件]
</span><span>        C -->|否| E[继续扫描下一个]
</span><span>    end
</span><span>    
</span><span>    subgraph "之后的方法"
</span><span>        F[观察器 on_r_inserted] --> G[仅当 R 插入时触发]
</span><span>        H[观察器 on_r_removed] --> I[仅当 R 移除时触发]
</span><span>        G --> J[更新继承组件]
</span><span>        I --> K[移除继承组件]
</span><span>    end
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><h3 id=crates-bevy-app-src-propagate-rs-35-20><code>crates/bevy_app/src/propagate.rs</code> (+35/-20)</h3><p>这是本次 PR 中唯一修改的文件。主要变化包括：<ol><li><strong>移除每帧扫描系统</strong>：<code>update_reparented</code> 系统被完全移除，不再每帧扫描所有实体。<li><strong>添加事件驱动的观察器</strong>：添加了两个新的观察器函数 <code>on_r_inserted</code> 和 <code>on_r_removed</code>，它们只在特定事件发生时执行。<li><strong>插件注册更新</strong>：在 <code>HierarchyPropagatePlugin</code> 中，不再将 <code>update_reparented</code> 添加到调度中，而是注册两个观察器。</ol><p>主要代码变化：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：在调度系统中包含 update_reparented
</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>schedule</span><span style=color:#61676ccc>,
</span><span>    (
</span><span>        update_source</span><span style=color:#ed9366>::</span><span>&LTC, F, R></span><span style=color:#61676ccc>,
</span><span>        update_reparented</span><span style=color:#ed9366>::</span><span>&LTC, F, R></span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// 每帧执行的系统
</span><span>        update_removed_limit</span><span style=color:#ed9366>::</span><span>&LTC, F, R></span><span style=color:#61676ccc>,
</span><span>        propagate_inherited</span><span style=color:#ed9366>::</span><span>&LTC, F, R></span><span style=color:#61676ccc>,
</span><span>        propagate_output</span><span style=color:#ed9366>::</span><span>&LTC, F></span><span style=color:#61676ccc>,
</span><span>    )
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>chain</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>in_set</span><span>(PropagateSet</span><span style=color:#ed9366>::</span><span>&LTC></span><span style=color:#ed9366>::</span><span>default())</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：移除 update_reparented，添加观察器
</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>schedule</span><span style=color:#61676ccc>,
</span><span>    (
</span><span>        update_source</span><span style=color:#ed9366>::</span><span>&LTC, F, R></span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// update_reparented 被移除
</span><span>        update_removed_limit</span><span style=color:#ed9366>::</span><span>&LTC, F, R></span><span style=color:#61676ccc>,
</span><span>        propagate_inherited</span><span style=color:#ed9366>::</span><span>&LTC, F, R></span><span style=color:#61676ccc>,
</span><span>        propagate_output</span><span style=color:#ed9366>::</span><span>&LTC, F></span><span style=color:#61676ccc>,
</span><span>    )
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>chain</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>in_set</span><span>(PropagateSet</span><span style=color:#ed9366>::</span><span>&LTC></span><span style=color:#ed9366>::</span><span>default())</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(on_r_inserted</span><span style=color:#ed9366>::</span><span>&LTC, F, R>)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// 添加观察器
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(on_r_removed</span><span style=color:#ed9366>::</span><span>&LTC, F, R>)</span><span style=color:#61676ccc>;
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：update_reparented 函数（完整查询每帧执行）
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>update_reparented</span><span>&LTC</span><span style=color:#61676ccc>:</span><span> Component </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Clone </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>PartialEq</span><span>, F</span><span style=color:#61676ccc>:</span><span> QueryFilter, R</span><span style=color:#61676ccc>:</span><span> Relationship>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#ff8f40>moved</span><span style=color:#61676ccc>: </span><span>Query<(Entity, </span><span style=color:#ed9366>&</span><span>R, </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>Inherited&LTC>>), (Changed&LTR>, Without&LTPropagate&LTC>>, F)>,
</span><span>    </span><span style=color:#ff8f40>relations</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span>Inherited&LTC>, Without&LTPropagateStop&LTC>>>,
</span><span>    </span><span style=color:#ff8f40>orphaned</span><span style=color:#61676ccc>: </span><span>Query&LTEntity, (With&LTInherited&LTC>>, Without&LTPropagate&LTC>>, Without&LTR>, F)>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>for </span><span>(entity</span><span style=color:#61676ccc>,</span><span> relation</span><span style=color:#61676ccc>,</span><span> maybe_inherited) </span><span style=color:#ed9366>in &</span><span>moved {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(inherited) </span><span style=color:#ed9366>=</span><span> relations</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(relation</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>()) {
</span><span>            commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_insert</span><span>(inherited</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>        } </span><span style=color:#fa6e32>else if</span><span> maybe_inherited</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() {
</span><span>            commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)</span><span style=color:#ed9366>.</span><span>try_remove</span><span style=color:#ed9366>::</span><span>&LTInherited&LTC>>()</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>for</span><span> orphan </span><span style=color:#ed9366>in &</span><span>orphaned {
</span><span>        commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(orphan)</span><span style=color:#ed9366>.</span><span>try_remove</span><span style=color:#ed9366>::</span><span>&LTInherited&LTC>>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：on_r_inserted 观察器（仅在插入事件时触发）
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>on_r_inserted</span><span><
</span><span>    C</span><span style=color:#61676ccc>:</span><span> Component </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Clone </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>PartialEq</span><span>,
</span><span>    F</span><span style=color:#61676ccc>:</span><span> QueryFilter </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>'static</span><span>,
</span><span>    R</span><span style=color:#61676ccc>:</span><span> Relationship,
</span><span>>(
</span><span>    </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span>On&LTInsert, R>,  </span><span style=color:#abb0b6;font-style:italic>// 事件参数
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#ff8f40>query</span><span style=color:#61676ccc>: </span><span>Query<(</span><span style=color:#ed9366>&</span><span>R, Has&LTInherited&LTC>>), (Without&LTPropagate&LTC>>, F)>,
</span><span>    </span><span style=color:#ff8f40>relations</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span>Inherited&LTC>, Without&LTPropagateStop&LTC>>>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>((relation</span><span style=color:#61676ccc>,</span><span> has_inherited)) </span><span style=color:#ed9366>=</span><span> query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(event</span><span style=color:#ed9366>.</span><span>entity) </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(inherited) </span><span style=color:#ed9366>=</span><span> relations</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(relation</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>()) {
</span><span>        commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(event</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_insert</span><span>(inherited</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>    } </span><span style=color:#fa6e32>else if</span><span> has_inherited {
</span><span>        commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(event</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#ed9366>.</span><span>try_remove</span><span style=color:#ed9366>::</span><span>&LTInherited&LTC>>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h2 id=jin-yi-bu-yue-du>进一步阅读</h2><ol><li><p><strong>Bevy 观察器系统</strong>：了解 Bevy 的事件观察器模式，这是本次优化依赖的核心机制。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy/latest/bevy/ecs/observer/index.html target=_blank>Bevy 观察器文档</a></ul><li><p><strong>实体组件系统（ECS）模式</strong>：理解 ECS 架构中组件、系统和实体之间的关系。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Entity_component_system target=_blank>ECS 模式概述</a></ul><li><p><strong>性能优化模式：从轮询到事件驱动</strong>：深入探讨这种架构转变的性能优势和使用场景。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Event-driven_architecture target=_blank>事件驱动架构</a></ul><li><p><strong>Bevy 中的层次结构和继承</strong>：了解 Bevy 如何处理实体间的父子关系和组件传播。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy/latest/bevy/hierarchy/index.html target=_blank>Bevy Hierarchy 模块</a></ul></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-03/pr_23156.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>