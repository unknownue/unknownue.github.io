<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23090 Add a `DelayedCommands` helper to support arbitrary delayed commands
        
    </title><meta content="#23090 Add a `DelayedCommands` helper to support arbitrary delayed commands" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-25</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-23090-zh-cn-20260225>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Add a <code>DelayedCommands</code> helper to support arbitrary delayed commands<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add a <code>DelayedCommands</code> helper to support arbitrary delayed commands<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/23090<li><strong>Author</strong>: Runi-c<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-ECS, S-Ready-For-Final-Review, A-Time, M-Release-Note, D-Modest<li><strong>Created</strong>: 2026-02-21T00:42:37Z<li><strong>Merged</strong>: 2026-02-25T00:04:33Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>A generalized mechanism for “doing something later” is desirable for many games, especially when it comes to gameplay logic and VFX.<li>Fixes https://github.com/bevyengine/bevy/issues/15129<li>Closes #20155</ul><h2 id=solution>Solution</h2><ul><li>Build off the work in https://github.com/bevyengine/bevy/pull/20155#issuecomment-3702483127, especially @laundmo’s comment.<li>Add a <code>DelayedCommands</code> helper obtainable via <code>commands.delayed()</code> that owns <code>CommandQueue</code>s and hands out new <code>Commands</code> bound to them.<li>When the <code>DelayedCommands</code> helper is dropped, push spawn commands onto the host <code>Commands</code> to spawn the queues as <code>DelayedCommandQueue</code> entities.<li>The entities are ticked by a new system added by <code>TimePlugin</code>. When the timer fires, the queue is submitted onto that system’s <code>Commands</code>.</ul><h2 id=testing>Testing</h2><ul><li>Added a new test in <code>bevy_time</code> and it seems to work.<li>I’m not very familiar with doing hacky things like using <code>Drop</code> like this and would therefore appreciate careful review and guidance if changes are requested.</ul><hr><h2 id=showcase>Showcase</h2><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>my_cool_system</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// fairly unobtrusive one-line delayed spawn
</span><span>    commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>delayed</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>secs</span><span>(</span><span style=color:#ff8f40>0.1</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(DummyComponent)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// the DelayedCommands can be stored to reuse more tersely
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> delayed </span><span style=color:#ed9366>=</span><span> commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>delayed</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// allocation happens immediately so you can even queue
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// further operations on entities that aren't spawned yet
</span><span>    </span><span style=color:#fa6e32>let</span><span> entity </span><span style=color:#ed9366>=</span><span> delayed</span><span style=color:#ed9366>.</span><span style=color:#f07171>secs</span><span>(</span><span style=color:#ff8f40>0.5</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_empty</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()</span><span style=color:#61676ccc>;
</span><span>    delayed</span><span style=color:#ed9366>.</span><span style=color:#f07171>secs</span><span>(</span><span style=color:#ff8f40>0.7</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(DummyComponent)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// `delayed.secs` and `delayed.duration` both simply return a
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// `Commands` rebound to the stored `CommandQueue`, so you can additionally
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// just store that and reuse it to queue multiple commands with the same delay
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> in_1_sec </span><span style=color:#ed9366>=</span><span> delayed</span><span style=color:#ed9366>.</span><span style=color:#f07171>duration</span><span>(Duration</span><span style=color:#ed9366>::</span><span>from_secs_f32(</span><span style=color:#ff8f40>1.0</span><span>))</span><span style=color:#61676ccc>;
</span><span>    in_1_sec</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(DummyComponent)</span><span style=color:#61676ccc>;
</span><span>    in_1_sec</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(DummyComponent)</span><span style=color:#61676ccc>;
</span><span>    in_1_sec</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(DummyComponent)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>In game development, scheduling actions to occur after a delay is a common requirement. Whether it’s spawning projectiles with a wind-up animation, timing power-up effects, or creating visual feedback with delays, developers frequently need to execute ECS commands at specific times in the future. Prior to this PR, Bevy lacked a built-in, general-purpose mechanism for this. Developers had to implement their own solutions using timers, custom components, and systems, which often led to boilerplate code and inconsistent patterns across different projects.<p>The GitHub issue #15129 specifically requested such a feature, and PR #20155 had previously explored the concept but wasn’t merged. This PR builds upon the discussion in that previous PR, particularly leveraging insights from @laundmo’s comment about using <code>CommandQueue</code> entities with timer components.<h3 id=the-solution-approach>The Solution Approach</h3><p>The developer chose an approach that integrates cleanly with Bevy’s existing ECS patterns. The core insight was to leverage the existing <code>CommandQueue</code> type, which already provides deferred command execution, and combine it with timer functionality. Instead of creating an entirely new system, the solution extends the existing <code>Commands</code> API with a new <code>delayed()</code> method that returns a helper type.<p>The key design decisions were:<ol><li><strong>API Ergonomics</strong>: Make the API feel natural as an extension of the existing <code>Commands</code> system<li><strong>Optimization</strong>: Group commands by delay duration to minimize entity creation<li><strong>Automatic Cleanup</strong>: Use Rust’s <code>Drop</code> trait to automatically submit delayed commands when the helper goes out of scope<li><strong>Entity Pre-allocation</strong>: Allow entity IDs to be allocated immediately so they can be referenced in subsequent delayed commands</ol><h3 id=the-implementation>The Implementation</h3><p>The implementation introduces several new components that work together:<p><strong>1. Core Data Structures</strong> The <code>DelayedCommands</code> struct is the main interface that developers interact with. It internally maintains a HashMap of <code>CommandQueue</code>s keyed by duration:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>DelayedCommands</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Used to own queues and deduplicate them by their duration.
</span><span>    queues</span><span style=color:#61676ccc>: </span><span>HashMap&LTDuration, CommandQueue>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// The wrapped `Commands` - used to provision out new `Commands`
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// and to spawn the queues as entities when the struct is dropped.
</span><span>    commands</span><span style=color:#61676ccc>: </span><span>Commands<</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>>,
</span><span>}
</span></code></pre><p>The <code>DelayedCommandQueue</code> component stores the actual command queue along with its scheduled execution time:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>DelayedCommandQueue </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// The elapsed time from startup when `queue` should be submitted.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>submit_at</span><span style=color:#61676ccc>:</span><span> Duration,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// The queue to be submitted when time is up.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>queue</span><span style=color:#61676ccc>:</span><span> CommandQueue,
</span><span>}
</span></code></pre><p><strong>2. API Extension Pattern</strong> The PR follows Bevy’s pattern of using extension traits to add functionality to core types. The <code>DelayedCommandsExt</code> trait extends <code>Commands</code> with the <code>delayed()</code> method:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>DelayedCommandsExt</span><span><'w> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>delayed</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span>DelayedCommands<</span><span style=color:#fa6e32>'w</span><span>, '</span><span style=color:#ed9366>_</span><span>></span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This pattern keeps the API discoverable and maintains consistency with other Bevy extensions.<p><strong>3. Smart Drop Implementation</strong> The clever use of the <code>Drop</code> trait ensures that delayed commands are automatically submitted when the <code>DelayedCommands</code> instance goes out of scope:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> Drop </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>DelayedCommands</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>submit</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>submit()</code> method converts relative durations to absolute times and spawns <code>DelayedCommandQueue</code> entities:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>submit</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> queues </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self
</span><span>        </span><span style=color:#ed9366>.</span><span>queues
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|(</span><span style=color:#ff8f40>submit_at</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>queue</span><span>)| DelayedCommandQueue { submit_at</span><span style=color:#61676ccc>,</span><span> queue })
</span><span>        </span><span style=color:#ed9366>.</span><span>collect</span><span style=color:#ed9366>::</span><span><</span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#ed9366>_</span><span>>>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>queue</span><span>(</span><span style=color:#fa6e32>move </span><span style=color:#ed9366>|</span><span>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World</span><span style=color:#ed9366>| </span><span>{
</span><span>        </span><span style=color:#fa6e32>let</span><span> time </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span>resource</span><span style=color:#ed9366>::</span><span>&LTTime>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> elapsed </span><span style=color:#ed9366>=</span><span> time</span><span style=color:#ed9366>.</span><span style=color:#f07171>elapsed</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>for</span><span> queue </span><span style=color:#ed9366>in</span><span> queues</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// Turn relative delays into absolute elapsed times
</span><span>            queue</span><span style=color:#ed9366>.</span><span>submit_at </span><span style=color:#ed9366>+=</span><span> elapsed</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        </span><span style=color:#f07171>spawn_batch</span><span>(queues)</span><span style=color:#ed9366>.</span><span style=color:#f07171>apply</span><span>(world)</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><strong>4. Execution System</strong> A new system <code>check_delayed_command_queues</code> runs in the <code>PreUpdate</code> schedule (added by <code>TimePlugin</code>) to process delayed commands:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>check_delayed_command_queues</span><span>(
</span><span>    </span><span style=color:#ff8f40>queues</span><span style=color:#61676ccc>: </span><span>Query<(Entity, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> DelayedCommandQueue)>,
</span><span>    </span><span style=color:#ff8f40>time</span><span style=color:#61676ccc>: </span><span>Res&LTTime>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> elapsed </span><span style=color:#ed9366>=</span><span> time</span><span style=color:#ed9366>.</span><span style=color:#f07171>elapsed</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for </span><span>(e</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> queue) </span><span style=color:#ed9366>in</span><span> queues {
</span><span>        </span><span style=color:#fa6e32>if</span><span> queue</span><span style=color:#ed9366>.</span><span>submit_at </span><span style=color:#ed9366><=</span><span> elapsed {
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// Write the contained delayed commands to the world.
</span><span>            commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>append</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> queue</span><span style=color:#ed9366>.</span><span>queue)</span><span style=color:#61676ccc>;
</span><span>            commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(e)</span><span style=color:#ed9366>.</span><span style=color:#f07171>despawn</span><span>()</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p><strong>5. Supporting Infrastructure</strong> The PR also adds a new <code>rebound_to()</code> method to <code>Commands</code> that allows creating a new <code>Commands</code> instance bound to a different queue:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>rebound_to</span><span><</span><span style=color:#fa6e32>'q</span><span>>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>queue</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'q mut</span><span> CommandQueue) </span><span style=color:#61676ccc>-> </span><span>Commands<</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'q</span><span>> {
</span><span>    Commands</span><span style=color:#ed9366>::</span><span>new_from_entities(queue</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>allocator</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>entities)
</span><span>}
</span></code></pre><p>This is essential for the implementation because it allows <code>DelayedCommands</code> to create <code>Commands</code> instances that write to its internal queues instead of the main world queue.<h3 id=technical-insights>Technical Insights</h3><p><strong>Entity ID Pre-allocation</strong>: One of the subtle but important features is that entity IDs are allocated immediately when <code>spawn_empty()</code> is called, even though the entity won’t be created until the delay expires. This allows developers to reference the entity in subsequent delayed commands, enabling patterns like:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> entity </span><span style=color:#ed9366>=</span><span> delayed</span><span style=color:#ed9366>.</span><span style=color:#f07171>secs</span><span>(</span><span style=color:#ff8f40>0.5</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_empty</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()</span><span style=color:#61676ccc>;
</span><span>delayed</span><span style=color:#ed9366>.</span><span style=color:#f07171>secs</span><span>(</span><span style=color:#ff8f40>0.7</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(DummyComponent)</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>Duration Deduplication</strong>: By using a HashMap keyed by duration, the implementation efficiently groups all commands with the same delay into a single <code>DelayedCommandQueue</code> entity. This reduces entity count and improves performance for scenarios where many commands share the same delay.<p><strong>Time Conversion</strong>: The implementation converts relative durations to absolute elapsed times during submission. This ensures that delays are measured from the time of submission rather than from when the command was originally queued, which is more intuitive for game logic.<p><strong>Limitation Note</strong>: The implementation currently only works with the default <code>Time</code> resource (virtual time). The documentation explicitly notes this limitation and suggests that developers needing custom clock behavior should implement their own solution.<h3 id=the-impact>The Impact</h3><p>This PR provides a clean, ergonomic solution for a common game development requirement. The API is designed to be intuitive for developers already familiar with Bevy’s <code>Commands</code> system. The implementation is efficient, leveraging existing ECS patterns while adding minimal overhead.<p>The feature enables new gameplay patterns and visual effects that were previously more cumbersome to implement. For example, the included demo shows how to create ripple effects with distance-based delays, which would have required custom timer management before this PR.<p>From a codebase perspective, the changes are well-contained:<ul><li>A new module in <code>bevy_time</code> for the delayed commands functionality<li>A small addition to the <code>Commands</code> API for queue rebinding<li>Integration into <code>TimePlugin</code> to run the checking system<li>Documentation and examples to demonstrate usage</ul><p>The implementation also serves as a good example of how to extend Bevy’s ECS patterns in a way that feels native to the engine.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Commands.delayed] --> B[DelayedCommands]
</span><span>    B --> C[HashMap&LTDuration, CommandQueue>]
</span><span>    B --> D[Drop Implementation]
</span><span>    D --> E[Spawn DelayedCommandQueue Entities]
</span><span>    F[TimePlugin] --> G[check_delayed_command_queues System]
</span><span>    E --> H[DelayedCommandQueue Component]
</span><span>    H --> G
</span><span>    G --> I[Submit Commands to World]
</span><span>    G --> J[Despawn Queue Entity]
</span><span>    
</span><span>    K[rebound_to Method] --> L[Commands Writing to Custom Queue]
</span><span>    L --> C
</span><span>    
</span><span>    style A fill:#e1f5fe
</span><span>    style F fill:#f3e5f5
</span><span>    style I fill:#e8f5e8
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-time-src-delayed-commands-rs-224-0><code>crates/bevy_time/src/delayed_commands.rs</code> (+224/-0)</h3><p>This new file contains the core implementation of the delayed commands feature:<ul><li><code>DelayedCommands</code> struct and its methods<li><code>DelayedCommandQueue</code> component<li><code>DelayedCommandsExt</code> trait for extending <code>Commands</code><li><code>check_delayed_command_queues</code> system<li>Comprehensive test suite</ul><p>Key code snippet showing the main API:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> </span><span style=color:#399ee6>DelayedCommands</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Return a [`Commands`] whose commands will be delayed by `duration`.
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>must_use </span><span style=color:#ed9366>= </span><span style=color:#86b300>"The returned Commands must be used to submit commands with this delay."</span><span>]
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>duration</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>duration</span><span style=color:#61676ccc>:</span><span> Duration) </span><span style=color:#61676ccc>-> </span><span>Commands<</span><span style=color:#fa6e32>'w</span><span>, '</span><span style=color:#ed9366>_</span><span>> {
</span><span>        </span><span style=color:#fa6e32>let</span><span> queue </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>queues</span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>(duration)</span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>rebound_to</span><span>(queue)
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Return a [`Commands`] whose commands will be delayed by `secs` seconds.
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>must_use </span><span style=color:#ed9366>= </span><span style=color:#86b300>"The returned Commands must be used to submit commands with this delay."</span><span>]
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>secs</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>secs</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#61676ccc>-> </span><span>Commands<</span><span style=color:#fa6e32>'w</span><span>, '</span><span style=color:#ed9366>_</span><span>> {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>duration</span><span>(Duration</span><span style=color:#ed9366>::</span><span>from_secs_f32(secs))
</span><span>    }
</span><span>}
</span></code></pre><h3 id=examples-ecs-delayed-commands-rs-60-0><code>examples/ecs/delayed_commands.rs</code> (+60/-0)</h3><p>A new example demonstrating practical usage with a visual effect:<ul><li>Creates a grid of squares<li>When clicked, changes square colors with distance-based delays<li>Shows how to use the delayed commands API in a real scenario</ul><p>Key code snippet showing the example’s main logic:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>click</span><span>(
</span><span>    </span><span style=color:#ff8f40>click</span><span style=color:#61676ccc>: </span><span>On&LTPointer&LTClick>>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#ff8f40>squares</span><span style=color:#61676ccc>: </span><span>Query<(Entity, </span><span style=color:#ed9366>&</span><span>Transform), With&LTBlinkySquare>>,
</span><span>    </span><span style=color:#ff8f40>cameras</span><span style=color:#61676ccc>: </span><span>Query<(</span><span style=color:#ed9366>&</span><span>Camera, </span><span style=color:#ed9366>&</span><span>GlobalTransform)>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let </span><span>(camera</span><span style=color:#61676ccc>,</span><span> camera_transform) </span><span style=color:#ed9366>=</span><span> cameras</span><span style=color:#ed9366>.</span><span style=color:#f07171>single</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> delayed </span><span style=color:#ed9366>=</span><span> commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>delayed</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for </span><span>(entity</span><span style=color:#61676ccc>,</span><span> transform) </span><span style=color:#ed9366>in</span><span> squares</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span><span>        </span><span style=color:#fa6e32>let</span><span> mouse_world_pos </span><span style=color:#ed9366>=</span><span> camera
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>viewport_to_world_2d</span><span>(camera_transform</span><span style=color:#61676ccc>,</span><span> click</span><span style=color:#ed9366>.</span><span>pointer_location</span><span style=color:#ed9366>.</span><span>position)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#fa6e32>let</span><span> dist </span><span style=color:#ed9366>=</span><span> mouse_world_pos</span><span style=color:#ed9366>.</span><span style=color:#f07171>distance</span><span>(transform</span><span style=color:#ed9366>.</span><span>translation</span><span style=color:#ed9366>.</span><span style=color:#f07171>truncate</span><span>())</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> delay </span><span style=color:#ed9366>=</span><span> dist </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>1000.0</span><span style=color:#61676ccc>;
</span><span>        delayed
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>secs</span><span>(delay)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(Sprite</span><span style=color:#ed9366>::</span><span>from_color(Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>WHITE</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>SQUARE_SIZE</span><span>))</span><span style=color:#61676ccc>;
</span><span>        delayed
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>secs</span><span>(delay </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>0.1</span><span>)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(Sprite</span><span style=color:#ed9366>::</span><span>from_color(Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>BLACK</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>SQUARE_SIZE</span><span>))</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-system-commands-mod-rs-14-0><code>crates/bevy_ecs/src/system/commands/mod.rs</code> (+14/-0)</h3><p>Adds the <code>rebound_to</code> method to <code>Commands</code>, which is essential for the implementation:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>rebound_to</span><span><</span><span style=color:#fa6e32>'q</span><span>>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>queue</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'q mut</span><span> CommandQueue) </span><span style=color:#61676ccc>-> </span><span>Commands<</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'q</span><span>> {
</span><span>    Commands</span><span style=color:#ed9366>::</span><span>new_from_entities(queue</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>allocator</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>entities)
</span><span>}
</span></code></pre><h3 id=crates-bevy-time-src-lib-rs-11-0><code>crates/bevy_time/src/lib.rs</code> (+11/-0)</h3><p>Integrates the delayed commands system into the TimePlugin:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>Plugin </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>TimePlugin </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>build</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... existing code ...
</span><span>        app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(PreUpdate</span><span style=color:#61676ccc>,</span><span> check_delayed_command_queues)
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... more existing code ...
</span><span>    }
</span><span>}
</span></code></pre><h3 id=cargo-toml-11-0><code>Cargo.toml</code> (+11/-0)</h3><p>Adds the new example to the workspace:<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[[</span><span style=color:#399ee6>example</span><span>]]
</span><span style=color:#399ee6>name </span><span>= </span><span style=color:#86b300>"delayed_commands"
</span><span style=color:#399ee6>path </span><span>= </span><span style=color:#86b300>"examples/ecs/delayed_commands.rs"
</span><span style=color:#399ee6>doc-scrape-examples </span><span>= </span><span style=color:#ff8f40>true
</span><span>
</span><span>[</span><span style=color:#399ee6>package</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>metadata</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>example</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>delayed_commands</span><span>]
</span><span style=color:#399ee6>name </span><span>= </span><span style=color:#86b300>"Delayed Commands"
</span><span style=color:#399ee6>description </span><span>= </span><span style=color:#86b300>"Demonstrates how to schedule ECS commands with a delay"
</span><span style=color:#399ee6>category </span><span>= </span><span style=color:#86b300>"ECS (Entity Component System)"
</span><span style=color:#399ee6>wasm </span><span>= </span><span style=color:#ff8f40>true
</span></code></pre><h3 id=release-content-release-notes-delayed-commands-md-28-0><code>release-content/release-notes/delayed_commands.md</code> (+28/-0)</h3><p>Adds release notes documenting the new feature and its usage patterns.<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy Commands System</strong>: Understanding Bevy’s command system is fundamental to using this feature effectively. The <a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/programming/commands.html target=_blank>Bevy Cheatbook section on Commands</a> provides a good overview.</p><li><p><strong>ECS Patterns</strong>: The <a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/ecs-intro/ target=_blank>Bevy ECS Guide</a> explains the Entity Component System patterns that this feature builds upon.</p><li><p><strong>Time Management in Games</strong>: For broader context on why delayed commands are useful, game development resources on <a rel="noopener nofollow noreferrer" href=https://gameprogrammingpatterns.com/game-loop.html target=_blank>game loops and timing</a> provide helpful background.</p><li><p><strong>Rust Drop Trait</strong>: The implementation uses Rust’s <code>Drop</code> trait creatively. The <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch15-03-drop.html target=_blank>Rust Book chapter on Drop</a> explains this pattern.</p><li><p><strong>Previous Discussion</strong>: The <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/20155 target=_blank>original PR #20155</a> and its discussion provide historical context and alternative approaches that were considered.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23090.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>