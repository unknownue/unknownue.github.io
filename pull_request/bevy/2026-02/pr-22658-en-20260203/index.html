<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22658 Amortize the cost of freeing entities
        
    </title><meta content="#22658 Amortize the cost of freeing entities" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-03</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22658-zh-cn-20260203>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Amortize the cost of freeing entities<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22658<li><strong>Author</strong>: ElliottjPierce<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Performance, S-Ready-For-Final-Review<li><strong>Created</strong>: 2026-01-23T05:02:19Z<li><strong>Merged</strong>: 2026-02-03T02:40:30Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>The biggest drawback of #18670 was that it made freeing <code>Entity</code>’s back to the allocator 4x slower. That meant a 20% regression in despawn performance. This PR vastly improves the performance of the entity allocator for freeing entities.<h2 id=solution>Solution</h2><p>Add a local free list in pace in the main entity allocator. This is an <code>ArrayVec</code> called <code>quick_free</code>. When an entity is freed, add it to the <code>quick_free</code>. If it is full, flush the array to the full shared allocator.<p>Currently the array has length 64, taking 512 bytes. Since this is directly included in the already massive <code>World</code> type, I don’t think this is an issue, and I would guess boxing it would hurt performance here. It also means that there will be at most 64 freed entities that simply can’t be allocated. This reduces the worst case maximum entity count from 4,294,967,296 to 4,294,967,232 (big deal).<p>This also adds a new <code>free_many</code> function that is very fast compared to doing them one by one.<h2 id=testing>Testing</h2><ul><li>CI and benches.</ul><hr><h2 id=showcase>Showcase</h2><p>Here are some rough benchmarks on my M2 MAX:<pre class=language-txt data-lang=txt style=color:#61676c;background-color:#fafafa><code class=language-txt data-lang=txt><span>group                                        post_quick_free_list                   pre_quick_free_list                    pre_remote_reservation
</span><span>-----                                        --------------------                   -------------------                    ----------------------
</span><span>entity_allocator_free/10000_entities         1.00     29.7±0.48µs        ? ?/sec    1.31     38.9±0.97µs        ? ?/sec    1.00     29.8±0.85µs        ? ?/sec
</span><span>entity_allocator_free/100_entities           1.00   393.3±26.21ns        ? ?/sec    1.35   531.8±26.34ns        ? ?/sec    1.14   446.7±11.32ns        ? ?/sec
</span><span>entity_allocator_free/1_entities             1.00      4.6±2.17ns        ? ?/sec    42.27  195.3±32.49ns        ? ?/sec    4.25     19.6±8.67ns        ? ?/sec
</span><span>entity_allocator_free_bulk/10000_entities    1.00      8.7±0.36µs        ? ?/sec
</span><span>entity_allocator_free_bulk/100_entities      1.00   240.9±31.01ns        ? ?/sec
</span><span>entity_allocator_free_bulk/1_entities        1.00   206.8±39.95ns        ? ?/sec
</span></code></pre><p>Looking at the cost of freeing 1,000 entities, this makes the new allocator exactly as fast as the pre-#18670 one, 30% faster than main. The new <code>free_many</code> takes 8.7µs to free 1,000 entities where the optimized <code>free</code> takes <code>29.7</code>, so another big win there.<p>This should make up the 20% regression to despawning. It might be even faster than pre-#18670 if we increase 64 to 128 or something, but I think that’s unnecessary. This could also much improve performance for despawning scenes if we can find a way to make use of <code>free_many</code>, but that’s a different task.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a performance regression introduced by a previous change (#18670) that made entity deallocation 4 times slower. The developer needed to restore the performance of entity freeing operations without sacrificing the benefits of the previous implementation.<p>The core issue was that after PR #18670, every entity free operation required synchronization with a shared allocator, which incurred significant overhead. This was particularly problematic for despawn operations, where entities are frequently freed in batches.<p>The solution implements a batching strategy by adding a local free list to the main entity allocator. Instead of immediately synchronizing with the shared allocator on every free operation, freed entities are first added to a local buffer. Only when this buffer reaches capacity does it get flushed to the shared allocator. This amortizes the synchronization cost across multiple free operations.<p>The implementation adds an <code>ArrayVec&LTEntity, 128></code> called <code>local_free</code> to the <code>Allocator</code> struct. This fixed-capacity buffer (initially 128 entities) is stored inline within the allocator to avoid heap allocation overhead. When the buffer is full, it’s flushed to the shared allocator using a new <code>free_many</code> method that processes all entities in a single batch.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// In crates/bevy_ecs/src/entity/remote_allocator.rs
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>super</span><span>) </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Allocator </span><span>{
</span><span>    shared</span><span style=color:#61676ccc>: </span><span>Arc&LTSharedAllocator>,
</span><span>    local_free</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTArrayVec&LTEntity, 128>>,
</span><span>}
</span></code></pre><p>The <code>free_many</code> method provides significant performance benefits by avoiding repeated synchronization overhead. It first attempts to add entities to the local free list, and only falls back to the shared allocator if the local list doesn’t have enough capacity.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>super</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>free_many</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>entities</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[Entity]) {
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>local_free</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_extend_from_slice</span><span>(entities)</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_err</span><span>() {
</span><span>        </span><span style=color:#fa6e32>unsafe </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>shared</span><span style=color:#ed9366>.</span><span>free</span><span style=color:#ed9366>.</span><span style=color:#f07171>free</span><span>(entities)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>This approach trades a small amount of memory (512 bytes for 64 entities) for significantly improved performance. The worst-case impact is minimal: it reduces the maximum possible entity count from 4,294,967,296 to 4,294,967,232, which is negligible for practical applications.<p>The benchmarks show impressive results: freeing single entities is now 42x faster than before, and the new <code>free_many</code> method provides even better performance for batch operations. For 10,000 entities, <code>free_many</code> completes in 8.7µs compared to 29.7µs for individual frees, a 3.4x improvement.<p>The implementation required changes across multiple layers of the ECS:<ol><li>The underlying <code>FreeList</code> in the shared allocator was modified to accept slices of entities<li>The <code>Allocator</code> struct gained the local buffer and new methods<li>The public <code>EntityAllocator</code> interface exposed the new <code>free_many</code> method<li>Benchmarks were updated to use the new batch API<li>Tests were adjusted to accommodate the changed allocation behavior</ol><p>This optimization is particularly valuable for game engines where entities are frequently created and destroyed. By reducing the cost of entity deallocation, it improves overall system performance, especially in scenarios with heavy entity churn like scene loading/unloading or particle systems.<p>The decision to use a fixed-size <code>ArrayVec</code> rather than a dynamically sized vector is intentional: it avoids heap allocations and provides predictable memory usage. The buffer size of 128 entities was chosen as a balance between memory overhead and performance benefit, though this could be tuned based on usage patterns.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[EntityAllocator.free_many] --> B[Allocator.free_many]
</span><span>    B --> C{Local Free List Capacity?}
</span><span>    C -->|Has Space| D[Add to local_free ArrayVec]
</span><span>    C -->|Full| E[Flush to SharedAllocator]
</span><span>    D --> F[Continue]
</span><span>    E --> F
</span><span>    
</span><span>    G[EntityAllocator.free] --> H[Allocator.free]
</span><span>    H --> I{local_free full?}
</span><span>    I -->|No| J[Push to local_free]
</span><span>    I -->|Yes| K[Flush to SharedAllocator]
</span><span>    J --> L[Complete]
</span><span>    K --> J
</span><span>    
</span><span>    M[SharedAllocator.free] --> N[FreeList.free with slice]
</span><span>    N --> O[Atomic Operations]
</span><span>    O --> P[Update Free List State]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-entity-remote-allocator-rs-49-14><code>crates/bevy_ecs/src/entity/remote_allocator.rs</code> (+49/-14)</h3><p>This file contains the core implementation changes. The <code>Allocator</code> struct was extended with a local free list buffer, and new methods were added for batch freeing.<p>Key changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Added to Allocator struct
</span><span>local_free</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTArrayVec&LTEntity, 128>></span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// New method implementation
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>super</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>free_many</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>entities</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[Entity]) {
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>local_free</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_extend_from_slice</span><span>(entities)</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_err</span><span>() {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// SAFETY: We have `&mut self`.
</span><span>        </span><span style=color:#fa6e32>unsafe </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>shared</span><span style=color:#ed9366>.</span><span>free</span><span style=color:#ed9366>.</span><span style=color:#f07171>free</span><span>(entities)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-entity-mod-rs-8-0><code>crates/bevy_ecs/src/entity/mod.rs</code> (+8/-0)</h3><p>This file exposes the new <code>free_many</code> method through the public <code>EntityAllocator</code> interface.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>free_many</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>freed</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[Entity]) {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>inner</span><span style=color:#ed9366>.</span><span style=color:#f07171>free_many</span><span>(freed)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=benches-benches-bevy-ecs-world-entity-allocator-rs-27-8><code>benches/benches/bevy_ecs/world/entity_allocator.rs</code> (+27/-8)</h3><p>New benchmarks were added to measure the performance of batch freeing operations, and existing benchmarks were updated to use <code>free_many</code> for setup.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// New benchmark group
</span><span style=color:#fa6e32>let mut</span><span> group </span><span style=color:#ed9366>=</span><span> criterion</span><span style=color:#ed9366>.</span><span style=color:#f07171>benchmark_group</span><span>(</span><span style=color:#86b300>"entity_allocator_free_bulk"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Updated existing benchmarks to use free_many
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>free_many</span><span>(</span><span style=color:#ed9366>&</span><span>entities)</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ecs-src-entity-map-entities-rs-6-8><code>crates/bevy_ecs/src/entity/map_entities.rs</code> (+6/-8)</h3><p>Test updates to accommodate the changed allocation behavior. Tests now check the state of freed entities directly rather than assuming immediate reallocation.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Checking next allocated entity
</span><span style=color:#fa6e32>let</span><span> entity </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_empty</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Checking freed entity state directly
</span><span style=color:#fa6e32>let</span><span> freed_dead_ref </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entities</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>resolve_from_index</span><span>(dead_ref</span><span style=color:#ed9366>.</span><span style=color:#f07171>index</span><span>())</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ecs-cargo-toml-3-3><code>crates/bevy_ecs/Cargo.toml</code> (+3/-3)</h3><p>Dependency changes to make <code>arrayvec</code> a required dependency rather than optional.<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span style=color:#abb0b6;font-style:italic># Before: Optional dependency
</span><span style=color:#399ee6>arrayvec </span><span>= { </span><span style=color:#399ee6>version </span><span>= </span><span style=color:#86b300>"0.7.4"</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>default-features </span><span>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>optional </span><span>= </span><span style=color:#ff8f40>true </span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic># After: Required dependency
</span><span style=color:#399ee6>arrayvec </span><span>= { </span><span style=color:#399ee6>version </span><span>= </span><span style=color:#86b300>"0.7.4"</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>default-features </span><span>= </span><span style=color:#ff8f40>false </span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy ECS Documentation</strong>: The official Bevy ECS documentation provides context on entity management and allocation strategies.<li><strong>ArrayVec Documentation</strong>: Understanding the <code>ArrayVec</code> type from the <code>arrayvec</code> crate, which provides stack-allocated vector-like behavior.<li><strong>Amortized Analysis</strong>: Concepts of amortized time complexity in algorithms and data structures.<li><strong>Memory Allocation Strategies</strong>: Different approaches to memory allocation and deallocation in game engines.<li><strong>Atomic Operations and Synchronization</strong>: Details on the atomic operations used in the shared allocator for thread-safe entity management.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22658.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>