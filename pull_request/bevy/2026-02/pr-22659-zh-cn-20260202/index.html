<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22659 Benchmark remote allocation
        
    </title><meta content="#22659 Benchmark remote allocation" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-02</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-22659-en-20260202>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=benchmark-remote-allocation>Benchmark remote allocation</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Benchmark remote allocation<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22659<li><strong>Author</strong>: ElliottjPierce<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-ECS, S-Ready-For-Review, C-Benchmarks<li><strong>Created</strong>: 2026-01-23T05:16:36Z<li><strong>Merged</strong>: 2026-02-02T23:26:53Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>在 #18670 之后，我们有了一个 <code>RemoteAllocator</code>，但我们没有将其与非远程分配器进行比较的基准测试。这个 PR 只是添加了那些基准测试。<p>我不知道我们是否真的需要这些基准测试，但拥有它们似乎是合理的，而且制作它没有花费时间，所以我想把它发出来。<h3 id=jie-jue-fang-an>解决方案</h3><p>添加 <code>entity_allocator_allocate_fresh_remote</code> 和 <code>entity_allocator_allocate_reused_remote</code> 基准测试组。<h3 id=ce-shi>测试</h3><ul><li>CI, benchmarks</ul><hr><h3 id=zhan-shi>展示</h3><pre class=language-txt data-lang=txt style=color:#61676c;background-color:#fafafa><code class=language-txt data-lang=txt><span>entity_allocator_allocate_fresh/10000_entities            1.00     22.8±0.29µs        ? ?/sec
</span><span>entity_allocator_allocate_fresh/100_entities              1.00    227.9±6.37ns        ? ?/sec
</span><span>entity_allocator_allocate_fresh/1_entities                1.00      6.2±3.83ns        ? ?/sec
</span><span>entity_allocator_allocate_fresh_bulk/10000_entities       1.00     19.9±0.25µs        ? ?/sec
</span><span>entity_allocator_allocate_fresh_bulk/100_entities         1.00    227.5±6.95ns        ? ?/sec
</span><span>entity_allocator_allocate_fresh_bulk/1_entities           1.00     11.5±4.69ns        ? ?/sec
</span><span>entity_allocator_allocate_fresh_remote/10000_entities     1.00     19.4±0.32µs        ? ?/sec
</span><span>entity_allocator_allocate_fresh_remote/100_entities       1.00    174.2±3.63ns        ? ?/sec
</span><span>entity_allocator_allocate_fresh_remote/1_entities         1.00      3.5±3.02ns        ? ?/sec
</span><span>entity_allocator_allocate_reused/10000_entities           1.00     21.5±0.37µs        ? ?/sec
</span><span>entity_allocator_allocate_reused/100_entities             1.00   233.3±11.77ns        ? ?/sec
</span><span>entity_allocator_allocate_reused/1_entities               1.00      8.3±3.70ns        ? ?/sec
</span><span>entity_allocator_allocate_reused_bulk/10000_entities      1.00     20.4±0.64µs        ? ?/sec
</span><span>entity_allocator_allocate_reused_bulk/100_entities        1.00   261.5±45.59ns        ? ?/sec
</span><span>entity_allocator_allocate_reused_bulk/1_entities          1.00    19.7±10.77ns        ? ?/sec
</span><span>entity_allocator_allocate_reused_remote/10000_entities    1.00     77.9±1.53µs        ? ?/sec
</span><span>entity_allocator_allocate_reused_remote/100_entities      1.00   774.9±16.28ns        ? ?/sec
</span><span>entity_allocator_allocate_reused_remote/1_entities        1.00      7.3±3.60ns        ? ?/sec
</span></code></pre><p>长话短说，远程分配比非远程分配慢大约3倍。综合考虑，我认为这相当不错。<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个 PR 始于一个简单的观察：在 Bevy 的 ECS（实体组件系统）中，PR #18670 引入了一个新组件——<code>RemoteAllocator</code>。这个分配器允许在不需要持有对整个 <code>World</code> 的引用（例如在异步上下文中）的情况下分配实体（Entity）。虽然功能已经实现，但代码库中缺少一个关键信息：它的性能表现如何？与非远程分配器相比，它的开销有多大？为了填补这个空白，作者提交了这个 PR，为 <code>RemoteAllocator</code> 添加了基准测试。<p>性能基准测试对于理解系统的开销和做出明智的工程决策至关重要。缺少对 <code>RemoteAllocator</code> 的基准测试意味着开发者无法量化使用它所带来的性能影响。添加这些基准测试的目的很直接：提供客观数据，帮助开发者在需要远程实体分配的场合（如异步任务）评估其成本效益。<p>解决方案的实现遵循了现有基准测试的模式，保持了代码的一致性。在 <code>entity_allocator.rs</code> 基准测试文件中，作者添加了两个新的基准测试组：<ol><li><strong><code>entity_allocator_allocate_fresh_remote</code></strong>：测试从远程分配器分配全新的实体。<li><strong><code>entity_allocator_allocate_reused_remote</code></strong>：测试从远程分配器重用之前释放的实体ID。</ol><p>这两个组分别对应了 <code>EntityAllocator</code> 已有的 <code>allocate_fresh</code> 和 <code>allocate_reused</code> 基准测试，形成了清晰的对比。每个基准测试组都使用标准的 <code>criterion</code> 库设置，循环测试 1、100 和 10000 个实体分配，以观察不同规模下的性能。<p>一个关键的技术细节体现在基准测试的设置代码中。对于重用分配的测试，需要先创建并释放一批实体，以填充分配器的“空闲列表”，模拟重用场景。这通过以下步骤实现：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let mut</span><span> entities </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span style=color:#ed9366>::</span><span>from_iter(world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc_many</span><span>(entity_count))</span><span style=color:#61676ccc>;
</span><span>entities
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>(</span><span style=color:#ed9366>..</span><span>)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>for_each</span><span>(|</span><span style=color:#ff8f40>e</span><span>| world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>free</span><span>(e))</span><span style=color:#61676ccc>;
</span></code></pre><p>之后，才构建远程分配器进行测试。<p>此外，为了顺利编写基准测试，需要对 <code>EntityAllocator::build_remote_allocator</code> 方法进行一个微小的、但重要的签名变更。原来的方法需要 <code>&mut self</code> 的可变引用：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>build_remote_allocator</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> RemoteAllocator {
</span></code></pre><p>然而，在基准测试的闭包中，我们通常只持有对 <code>EntityAllocator</code> 的不可变引用（通过 <code>world.entity_allocator()</code>）。由于构建 <code>RemoteAllocator</code> 本质上只是获取一个内部结构的共享引用（<code>&self.inner</code>）来创建新实例，并不需要修改原分配器本身，因此将其签名改为接受不可变引用是合理的：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>build_remote_allocator</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> RemoteAllocator {
</span></code></pre><p>这一行修改（在 <code>crates/bevy_ecs/src/entity/mod.rs</code> 中）虽然微小，但确保了 API 的易用性和逻辑正确性，使得在只读上下文中创建远程分配器成为可能，这与其设计初衷（在异步等无法获得可变引用的场景中使用）是吻合的。<p>运行基准测试后得到的数据揭示了明确的性能特征。如 PR 描述中的结果所示，对于“全新分配”（fresh allocation），远程和非远程分配器的性能非常接近，远程分配器甚至在某些情况下略快（可能是测量波动）。然而，对于“重用分配”（reused allocation），远程分配器的开销变得明显，大约是非远程分配器的 3 倍（例如，10000 个实体分配耗时 77.9µs 对比 21.5µs）。<p>这个性能差异是预期的。<code>RemoteAllocator</code> 需要通过内部同步机制（如原子操作或锁）与主 <code>EntityAllocator</code> 协调，特别是在回收和分配已释放的 ID 时，这比直接访问拥有所有权的分配器有更高的开销。作者得出的结论——“综合考虑，我认为这相当不错”——是合理的。对于一个用于特定场景（如异步）的工具，3倍的开销在许多情况下是可以接受的，尤其是考虑到它提供的便利性。<p>最终，这个 PR 以一种轻量、非侵入性的方式，为 Bevy ECS 的一个关键基础设施组件补充了重要的性能度量。它没有改变任何核心逻辑，只是增加了观察和评估的手段。这些基准测试现在将成为项目持续集成的一部分，帮助防止未来更改导致 <code>RemoteAllocator</code> 性能意外回归，并为所有开发者提供了关于其成本的确切数据，以便在架构设计时做出更明智的选择。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    subgraph “基准测试 (Benchmarks)”
</span><span>        B_Fresh[entity_allocator_allocate_fresh]
</span><span>        B_Reused[entity_allocator_allocate_reused]
</span><span>        B_FreshRemote[entity_allocator_allocate_fresh_remote]
</span><span>        B_ReusedRemote[entity_allocator_allocate_reused_remote]
</span><span>    end
</span><span>
</span><span>    EA[EntityAllocator] -->|build_remote_allocator| RA[RemoteAllocator]
</span><span>    
</span><span>    B_Fresh -->|测试| EA
</span><span>    B_Reused -->|测试| EA
</span><span>    B_FreshRemote -->|测试| RA
</span><span>    B_ReusedRemote -->|测试| RA
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-benches-benches-bevy-ecs-world-entity-allocator-rs-53-0>1. <code>benches/benches/bevy_ecs/world/entity_allocator.rs</code> (+53/-0)</h3><p><strong>描述</strong>：此文件是 ECS 实体分配器基准测试的入口。PR 在此添加了两个新的基准测试组，用于测量 <code>RemoteAllocator</code> 的性能。 <strong>关键修改</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 添加了“远程分配-全新实体”基准测试组
</span><span style=color:#fa6e32>let mut</span><span> group </span><span style=color:#ed9366>=</span><span> criterion</span><span style=color:#ed9366>.</span><span style=color:#f07171>benchmark_group</span><span>(</span><span style=color:#86b300>"entity_allocator_allocate_fresh_remote"</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// ... 基准测试配置 ...
</span><span style=color:#fa6e32>for</span><span> entity_count </span><span style=color:#ed9366>in </span><span style=color:#ff8f40>ENTITY_COUNTS </span><span>{
</span><span>    group</span><span style=color:#ed9366>.</span><span style=color:#f07171>bench_function</span><span>(</span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{entity_count}</span><span style=color:#86b300>_entities"</span><span>)</span><span style=color:#61676ccc>, </span><span>|</span><span style=color:#ff8f40>bencher</span><span>| {
</span><span>        bencher</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_batched_ref</span><span>(
</span><span>            || {
</span><span>                </span><span style=color:#fa6e32>let</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>                world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>build_remote_allocator</span><span>() </span><span style=color:#abb0b6;font-style:italic>// 使用不可变引用构建
</span><span>            }</span><span style=color:#61676ccc>,
</span><span>            |</span><span style=color:#ff8f40>remote</span><span>| {
</span><span>                </span><span style=color:#fa6e32>for </span><span style=color:#ed9366>_ in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span>entity_count {
</span><span>                    </span><span style=color:#fa6e32>let</span><span> entity </span><span style=color:#ed9366>=</span><span> remote</span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 执行远程分配
</span><span>                    </span><span style=color:#f07171>black_box</span><span>(entity)</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            }</span><span style=color:#61676ccc>,
</span><span>            BatchSize</span><span style=color:#ed9366>::</span><span>SmallInput</span><span style=color:#61676ccc>,
</span><span>        )</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 添加了“远程分配-重用实体”基准测试组
</span><span style=color:#fa6e32>let mut</span><span> group </span><span style=color:#ed9366>=</span><span> criterion</span><span style=color:#ed9366>.</span><span style=color:#f07171>benchmark_group</span><span>(</span><span style=color:#86b300>"entity_allocator_allocate_reused_remote"</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// ... 基准测试配置 ...
</span><span style=color:#fa6e32>for</span><span> entity_count </span><span style=color:#ed9366>in </span><span style=color:#ff8f40>ENTITY_COUNTS </span><span>{
</span><span>    group</span><span style=color:#ed9366>.</span><span style=color:#f07171>bench_function</span><span>(</span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{entity_count}</span><span style=color:#86b300>_entities"</span><span>)</span><span style=color:#61676ccc>, </span><span>|</span><span style=color:#ff8f40>bencher</span><span>| {
</span><span>        bencher</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_batched_ref</span><span>(
</span><span>            || {
</span><span>                </span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>                </span><span style=color:#abb0b6;font-style:italic>// 预分配并释放实体，以填充重用池
</span><span>                </span><span style=color:#fa6e32>let mut</span><span> entities </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span style=color:#ed9366>::</span><span>from_iter(world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc_many</span><span>(entity_count))</span><span style=color:#61676ccc>;
</span><span>                entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>(</span><span style=color:#ed9366>..</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>for_each</span><span>(|</span><span style=color:#ff8f40>e</span><span>| world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>free</span><span>(e))</span><span style=color:#61676ccc>;
</span><span>                world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>build_remote_allocator</span><span>() </span><span style=color:#abb0b6;font-style:italic>// 使用不可变引用构建
</span><span>            }</span><span style=color:#61676ccc>,
</span><span>            |</span><span style=color:#ff8f40>remote</span><span>| {
</span><span>                </span><span style=color:#fa6e32>for </span><span style=color:#ed9366>_ in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span>entity_count {
</span><span>                    </span><span style=color:#fa6e32>let</span><span> entity </span><span style=color:#ed9366>=</span><span> remote</span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 执行远程分配（期望重用ID）
</span><span>                    </span><span style=color:#f07171>black_box</span><span>(entity)</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            }</span><span style=color:#61676ccc>,
</span><span>            BatchSize</span><span style=color:#ed9366>::</span><span>SmallInput</span><span style=color:#61676ccc>,
</span><span>        )</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><strong>与PR目的的关系</strong>：这些新增的代码块直接实现了 PR 的目标——为 <code>RemoteAllocator</code> 创建基准测试，使其能够与现有的非远程分配基准测试进行对比。<h3 id=2-crates-bevy-ecs-src-entity-mod-rs-1-1>2. <code>crates/bevy_ecs/src/entity/mod.rs</code> (+1/-1)</h3><p><strong>描述</strong>：此文件包含 <code>EntityAllocator</code> 的定义。PR 修改了 <code>build_remote_allocator</code> 方法的签名，使其接受不可变引用 <code>&self</code> 而非可变引用 <code>&mut self</code>。 <strong>关键修改</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>build_remote_allocator</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> RemoteAllocator {
</span><span>    RemoteAllocator</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>inner)
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>build_remote_allocator</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> RemoteAllocator {
</span><span>    RemoteAllocator</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>inner)
</span><span>}
</span></code></pre><p><strong>与PR目的的关系</strong>：这一修改是功能性的，它使基准测试（以及其他任何只持有不可变引用的代码）能够创建 <code>RemoteAllocator</code>。同时，它也提升了 API 的易用性和逻辑一致性，因为构建一个远程视图并不需要改变原始分配器的状态。<h2 id=further-reading>Further Reading</h2><ol><li><strong>PR #18670</strong>: 原始引入了 <code>RemoteAllocator</code> 的 PR。阅读它可以理解 <code>RemoteAllocator</code> 的设计动机、实现细节和使用场景。<li><strong>Criterion.rs Documentation</strong>: 本 PR 使用的 Rust 基准测试库。了解其 API 可以帮助你理解基准测试的设置和运行原理。<li><strong>Bevy ECS 官方文档</strong>: 查看关于实体（Entity）和 <code>EntityAllocator</code> 的章节，以深入了解 Bevy ECS 的核心数据结构和其分配机制。<li><strong>《Systems Performance: Enterprise and the Cloud》</strong>: 对于想深入理解性能分析与基准测试的工程师，这是一本经典的资源。</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22659.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>