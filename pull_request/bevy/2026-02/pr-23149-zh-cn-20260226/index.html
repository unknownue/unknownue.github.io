<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23149 `DetectChanges::is_changed_after`
        
    </title><meta content="#23149 `DetectChanges::is_changed_after`" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-26</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-23149-en-20260226>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: <code>DetectChanges::is_changed_after</code><li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/23149<li><strong>Author</strong>: chescock<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-ECS, C-Usability, S-Ready-For-Final-Review<li><strong>Created</strong>: 2026-02-25T16:17:01Z<li><strong>Merged</strong>: 2026-02-26T00:34:18Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h3 id=mu-biao>目标</h3><p>让比较 <code>Ref</code> 之间的 ticks 变得更加容易。<p>在 #23106 中使用的比较 changed ticks 的模式看起来非常强大！但是 <code>Tick::is_newer_than</code> 的第二个 <code>Tick</code> 参数使得使用起来很别扭，并且要求开发者了解 <code>SystemChangeTick</code> 这个系统参数。这很傻，因为 <code>Ref</code> <em>已经拥有</em> 这些 ticks。<h3 id=jie-jue-fang-an>解决方案</h3><p>引入 <code>DetectChanges::is_changed_after</code>、<code>DetectChanges::is_added_after</code> 和 <code>SpawnDetails::is_spawned_after</code> 方法。这些方法在适当的 tick 上调用 <code>Tick::is_newer_than</code>，并使用已经存储的 <code>last_run</code> tick。<h3 id=shi-li-zhan-shi>示例展示</h3><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span style=color:#f07171>-        if transform
</span><span style=color:#f07171>-            .last_changed()
</span><span style=color:#f07171>-            .is_newer_than(previous.last_changed(), system_change_tick.this_run())
</span><span style=color:#f07171>-        {
</span><span style=color:#86b300>+        if transform.is_changed_after(previous.last_changed()) {
</span></code></pre><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个 PR 始于一个具体的开发者体验问题。在 Bevy 的 ECS 系统中，变更检测（change detection）是一个核心机制，它允许系统（system）高效地检查组件或资源自上次运行以来是否被修改。系统通过比较 ticks（一种单调递增的计数器）来实现这一点。每个变更都会被标记一个 tick，而每个系统也会跟踪它上次运行的 tick（<code>last_run</code>）和当前的 world tick（<code>this_run</code>）。<p>问题出现在开发者需要比较两个不同实体的变更时间点时。例如，一个系统可能想要检查 <code>Source</code> 组件是否在 <code>Target</code> 组件之后被修改，以决定是否需要更新 <code>Target</code>。在 PR #23106 中展示的模式，即使用 <code>Tick::is_newer_than</code> 方法，虽然功能强大，但 API 使用起来很繁琐。<p>原有的方法调用如下：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(previous</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>()</span><span style=color:#61676ccc>,</span><span> system_change_tick</span><span style=color:#ed9366>.</span><span style=color:#f07171>this_run</span><span>())
</span></code></pre><p>开发者必须：<ol><li>从两个 <code>Ref</code> 中分别获取 <code>last_changed()</code> tick。<li>显式传入 <code>system_change_tick.this_run()</code> 作为第三个参数。</ol><p>这里的关键洞察是：对于一个已经存在的 <code>Ref</code>（例如 <code>transform: Ref&LTTransform></code>），它内部已经包含了进行比较所需的所有状态信息。<code>Ref</code> 结构体内部存储了 <code>Ticks</code>，其中就包括 <code>last_run</code> 和 <code>this_run</code>。强迫开发者从外部传入 <code>system_change_tick</code> 是多余且容易出错的。开发者甚至需要知道 <code>SystemChangeTick</code> 这个系统参数的存在。<p>因此，解决方案很直接：在 <code>DetectChanges</code> trait 上提供一个新的方法，利用 <code>Ref</code> 自身已有的信息来完成比较。这就是 <code>is_changed_after</code> 和 <code>is_added_after</code> 方法的由来。<p>从技术实现上看，这个 PR 采取了最小化且一致的方法。核心改动发生在 <code>crates/bevy_ecs/src/change_detection/traits.rs</code> 文件。开发者首先在 <code>DetectChanges</code> trait 的定义中增加了两个新的方法签名：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_added_after</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>other</span><span style=color:#61676ccc>:</span><span> Tick) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_changed_after</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>other</span><span style=color:#61676ccc>:</span><span> Tick) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool</span><span style=color:#61676ccc>;
</span></code></pre><p>并且为 <code>is_changed_after</code> 编写了详细的文档和示例，展示了其典型用例：仅在源组件比目标组件更新时才进行转换。<p>接下来，需要为所有实现了 <code>DetectChanges</code> trait 的类型提供这两个方法的默认实现。这里运用了 Bevy ECS 代码库中已有的一个宏模式 <code>change_detection_impl!</code>。这个宏原本用于为 <code>Ref</code>、<code>Mut</code> 等类型生成 <code>is_added</code> 和 <code>is_changed</code> 的实现。PR 巧妙地修改了这个宏，使其也生成新的 <code>is_added_after</code> 和 <code>is_changed_after</code> 方法。<p>更重要的是，修改将原有的 <code>is_added</code> 和 <code>is_changed</code> 的实现重构为基于新方法：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_added</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_added_after</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>ticks</span><span style=color:#ed9366>.</span><span>last_run) </span><span style=color:#abb0b6;font-style:italic>// 之前是直接调用 is_newer_than
</span><span>}
</span></code></pre><p>这是一种良好的重构实践：让高层 API (<code>is_added</code>) 建立在更基础、更灵活的 API (<code>is_added_after</code>) 之上，避免了代码重复，并保证了行为的一致性。<p>同样的逻辑也应用到了 <code>MutUntyped</code> 类型（在 <code>params.rs</code> 中）和 <code>SpawnDetails</code> 类型（在 <code>fetch.rs</code> 中），为后者新增了 <code>is_spawned_after</code> 方法。<p>完成核心 API 的添加后，PR 的作者进一步展示了新 API 的优势：清理代码库中已有的、使用旧模式的地方。这包括：<ol><li><code>observer/runner.rs</code> 和 <code>system/system_registry.rs</code> 中关于热重载（hotpatching）的检查逻辑。原本冗长的 <code>map</code> 和 <code>is_newer_than</code> 调用被简洁的 <code>is_none_or</code> 和 <code>is_changed_after</code> 组合所替代。这显著提高了代码的可读性。<li><code>bevy_pbr/src/prepass/mod.rs</code> 中的一个具体系统函数 <code>update_mesh_previous_global_transforms</code>。这正是 PR 描述中展示的 diff 所对应的代码。这个改动移除了对 <code>system_change_tick</code> 参数的依赖，并使函数签名和函数体都更加清晰。</ol><p>从工程角度看，这个 PR 是一个典型的“开发者体验”优化。它没有改变系统的核心行为或性能特征（所有方法都是 <code>#[inline]</code> 的，编译后应该与直接调用 <code>is_newer_than</code> 等效），但极大地改善了 API 的易用性和代码的简洁性。它遵循了“让简单的事情简单，让复杂的事情可能”的原则。现在，比较两个变更 tick 变成了一行直观的代码，开发者无需再关心底层的 tick 比较机制。<p>这个改动也体现了良好的软件设计原则：封装。<code>Ref</code> 现在提供了一个更高级别的抽象，隐藏了 <code>last_run</code> 和 <code>this_run</code> 的内部细节，使得调用代码不再依赖于这些实现细节。这使得未来的内部重构（如果需要调整 tick 比较逻辑）变得更加容易，因为影响范围被限制在了 <code>DetectChanges</code> trait 的实现内部。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    subgraph "Core Traits"
</span><span>        A[DetectChanges Trait]
</span><span>    end
</span><span>
</span><span>    subgraph "Implementors"
</span><span>        B[Ref&amplt;T&ampgt;]
</span><span>        C[Mut&amplt;T&ampgt;]
</span><span>        D[MutUntyped]
</span><span>    end
</span><span>
</span><span>    subgraph "Utility Structs"
</span><span>        E[SpawnDetails]
</span><span>    end
</span><span>
</span><span>    subgraph "Consumers / Usage Sites"
</span><span>        F[Observer System]
</span><span>        G[Hotpatching Check]
</span><span>        H[PBR Prepass System]
</span><span>    end
</span><span>
</span><span>    A -- defines --> B
</span><span>    A -- defines --> C
</span><span>    A -- defines --> D
</span><span>    E -- provides similar API --> A
</span><span>
</span><span>    B -- used via --> F
</span><span>    B -- used via --> G
</span><span>    C -- used via --> H
</span><span>    D -- used via --> G
</span></code></pre><p><em>图示说明：<code>DetectChanges</code> trait 是新增 API 的源头。多个类型（<code>Ref</code>, <code>Mut</code>, <code>MutUntyped</code>）实现了它。<code>SpawnDetails</code> 虽然不是该 trait 的实现者，但提供了语义相同的 <code>is_spawned_after</code> 方法。代码库中的多个使用点（消费者）更新为使用这些新方法，简化了逻辑。</em><h2 id=key-files-changed>Key Files Changed</h2><ol><li><p><strong><code>crates/bevy_ecs/src/change_detection/traits.rs</code> (+47/-3)</strong></p> <ul><li><strong>目的</strong>: 这是 PR 的核心。在此定义了新的 trait 方法，并更新了宏来为所有相关类型生成实现。<li><strong>关键改动</strong>: <ul><li>在 <code>DetectChanges</code> trait 中新增 <code>is_added_after</code> 和 <code>is_changed_after</code> 方法声明及文档。<li>修改 <code>change_detection_impl!</code> 宏，使其生成新方法的实现，并重构现有 <code>is_added</code>/<code>is_changed</code> 方法以调用新方法。</ul><li><strong>代码示例 (核心新增部分)</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Returns `true` if this value was added after the `other` tick.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_added_after</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>other</span><span style=color:#61676ccc>:</span><span> Tick) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>/// Returns `true` if this value was added or mutably dereferenced
</span><span style=color:#abb0b6;font-style:italic>/// after the `other` tick.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_changed_after</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>other</span><span style=color:#61676ccc>:</span><span> Tick) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool</span><span style=color:#61676ccc>;
</span></code></pre><li><strong>与整体的关系</strong>: 建立了新的、更易用的公共 API。</ul><li><p><strong><code>crates/bevy_ecs/src/change_detection/params.rs</code> (+12/-6)</strong></p> <ul><li><strong>目的</strong>: 为 <code>MutUntyped</code> 类型实现新的 <code>DetectChanges</code> 方法。<li><strong>关键改动</strong>: 为 <code>MutUntyped</code> 手动实现了 <code>is_added_after</code> 和 <code>is_changed_after</code>，并同样重构了 <code>is_added</code> 和 <code>is_changed</code> 来调用它们。<li><strong>代码示例 (实现逻辑)</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_added_after</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>other</span><span style=color:#61676ccc>:</span><span> Tick) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>ticks</span><span style=color:#ed9366>.</span><span>added</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(other</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>ticks</span><span style=color:#ed9366>.</span><span>this_run)
</span><span>}
</span></code></pre><li><strong>与整体的关系</strong>: 确保所有实现了 <code>DetectChanges</code> 的类型都有一致的新 API。</ul><li><p><strong><code>crates/bevy_ecs/src/query/fetch.rs</code> (+8/-1)</strong></p> <ul><li><strong>目的</strong>: 为 <code>SpawnDetails</code> 增加对称的 <code>is_spawned_after</code> 方法，保持 API 一致性。<li><strong>关键改动</strong>: 新增 <code>is_spawned_after</code> 方法，并重构 <code>is_spawned</code> 来调用它。<li><strong>代码示例</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>is_spawned_after</span><span>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>other</span><span style=color:#61676ccc>:</span><span> Tick) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>spawn_tick</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(other</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>this_run)
</span><span>}
</span></code></pre><li><strong>与整体的关系</strong>: 将“比较 tick”的便利性扩展到了实体生成（spawning）的检测场景。</ul><li><p><strong><code>crates/bevy_ecs/src/observer/runner.rs</code> (+1/-5) & <code>crates/bevy_ecs/src/system/system_registry.rs</code> (+1/-5)</strong></p> <ul><li><strong>目的</strong>: 利用新 API 简化现有代码，展示其优势。<li><strong>关键改动</strong>: 将复杂的 <code>map</code> + <code>is_newer_than</code> 链式调用替换为更简洁的 <code>is_none_or</code> + <code>is_changed_after</code>。<li><strong>代码示例 (之前 vs 之后)</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>r</span><span>| r</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>((</span><span style=color:#ed9366>*</span><span>system)</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_last_run</span><span>()</span><span style=color:#61676ccc>,</span><span> world</span><span style=color:#ed9366>.</span><span style=color:#f07171>change_tick</span><span>()))
</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>true</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none_or</span><span>(|</span><span style=color:#ff8f40>r</span><span>| r</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_changed_after</span><span>((</span><span style=color:#ed9366>*</span><span>system)</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_last_run</span><span>()))
</span></code></pre><li><strong>与整体的关系</strong>: 证明了新 API 的实际价值，使代码更清晰、更易读。</ul><li><p><strong><code>crates/bevy_pbr/src/prepass/mod.rs</code> (+1/-5)</strong></p> <ul><li><strong>目的</strong>: 在真实的使用场景中应用新 API，并移除不必要的系统参数。<li><strong>关键改动</strong>: 使用 <code>is_changed_after</code> 替换原有的 tick 比较逻辑，并因此可以从函数签名中删除 <code>system_change_tick: SystemChangeTick</code> 参数。<li><strong>代码示例 (PR描述中的diff)</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 这个改动直接来自PR描述，是最直观的示例。
</span><span style=color:#fa6e32>if</span><span> transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_changed_after</span><span>(previous</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>()) {
</span></code></pre><li><strong>与整体的关系</strong>: 提供了新 API 在游戏引擎具体子系统（这里是渲染预处理）中提升代码质量的典型案例。</ul></ol><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy 官方文档 - Change Detection</strong>:</p> <ul><li>链接: <a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/change-detection/ target=_blank>https://bevyengine.org/learn/book/change-detection/</a><li>说明: 了解 Bevy 变更检测机制的基础概念和工作原理。</ul><li><p><strong>Rust 语言 Trait 系统</strong>:</p> <ul><li>链接: <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch10-02-traits.html target=_blank>The Rust Programming Language - Traits</a><li>说明: 理解 trait 如何作为 Rust 中定义共享行为的关键机制，这是本 PR 扩展 API 的基础。</ul><li><p><strong>软件设计 - 封装与抽象</strong>:</p> <ul><li>说明: 学习如何通过提供更高级别的 API 来隐藏实现细节，改善开发者体验并降低耦合度。本 PR 是实践这一原则的很好例子。</ul><li><p><strong>PR #23106</strong>:</p> <ul><li>链接: <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/23106 target=_blank>https://github.com/bevyengine/bevy/pull/23106</a><li>说明: 本 PR 所引用的先前工作，其中展示了使用底层 <code>Tick::is_newer_than</code> 的模式，是本次 API 改进的灵感来源。</ul></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23149.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>