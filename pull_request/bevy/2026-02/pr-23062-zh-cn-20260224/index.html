<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23062
        
    </title><meta content=#23062 property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-24</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-23062-en-20260224>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=ji-ben-zi-xun>基本資訊</h2><ul><li><strong>標題</strong>: Fix volumetric rendering order problem<li><strong>PR 連結</strong>: https://github.com/bevyengine/bevy/pull/23062<li><strong>作者</strong>: dan-dozen<li><strong>狀態</strong>: MERGED<li><strong>標籤</strong>: C-Bug, D-Trivial, A-Rendering, S-Ready-For-Final-Review<li><strong>建立時間</strong>: 2026-02-19T22:00:00Z<li><strong>合併時間</strong>: 2026-02-24T03:08:28Z<li><strong>合併者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻譯</h2><h1 id=objective>Objective</h1><ul><li>修復體積霧（volumetric fog）在其他網格（meshes）後方渲染的問題。修復了 https://github.com/bevyengine/bevy/issues/17429</ul><h2 id=solution>Solution</h2><ul><li>更新著色器，使其在位於其他幾何體後方時不進行渲染。</ul><h2 id=testing>Testing</h2><ul><li>在 macOS 15.7.3 (24G419) Apple M3 Pro 上測試。<li>需要在其他平台上測試。<li>可透過 patch 這個變更（https://github.com/dan-dozen/bevy/pull/1/changes）並執行 <code>examples/3d/volumetric_fog.rs</code> 來測試。如果需要，我也樂意將對範例的修改包含進來。</ul><hr><h2 id=showcase>Showcase</h2><details><summary>點擊查看展示</summary> <p>在修改前，可以看到體積霧出現在房屋內部，即使它位於前牆後方： <img alt="Screenshot 2026-02-19 at 4 59 03 PM" height=860 src=https://github.com/user-attachments/assets/a5ab1a19-ca39-453f-b6c4-8a667d8a5a88 width=1392></p> <p>修改後，體積霧不再可見： <img alt="Screenshot 2026-02-19 at 4 57 56 PM" height=860 src=https://github.com/user-attachments/assets/88d05951-a3fb-4a05-a85c-ddee31884b5c width=1392></p></details><hr><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>這次的 PR 解決了一個體積渲染中的視覺錯誤。問題的核心在於體積霧的著色器計算深度時，沒有正確處理被不透明（opaque）物體完全遮擋的情況。<p><strong>問題與上下文</strong> 在即時渲染中，體積效果（如霧、煙）通常使用射線步進（ray marching）技術，沿著從相機到場景中某點的視線累積顏色和透明度。為了正確渲染，必須知道體積的起點（通常是相機的近平面或第一個透明表面）和終點（第一個不透明表面的深度）。問題發生在 <code>volumetric_fog.wgsl</code> 的片段著色器中。原始程式碼使用 <code>abs(end_depth_view - start_depth_view)</code> 計算 <code>ray_length_view</code>。這會導致一個問題：當體積霧的終點深度（<code>end_depth_view</code>）小於起點深度（<code>start_depth_view</code>）時，意味著體積霧完全位於當前像素所對應的第一個不透明表面之後，本應被完全遮擋。然而，<code>abs()</code> 函數會將負的長度轉為正數，著色器仍會繼續執行射線步進，最終渲染出本不該出現的霧，造成視覺穿幫（如霧出現在實心牆壁的內部或後方）。<p><strong>解決方案與實作</strong> 解決方案直接且有效。著色器需要識別何時體積霧被完全遮擋，並提前退出渲染。PR 作者將計算 <code>ray_length_view</code> 的公式從 <code>abs(end_depth_view - start_depth_view)</code> 改為 <code>max(0.0, end_depth_view - start_depth_view)</code>。這個改變確保了射線長度永遠為非負值。如果 <code>end_depth_view</code> 小於 <code>start_depth_view</code>，表示體積位於不透明表面之後，<code>max</code> 函數會將結果設為 0.0。<p>接著，新增了一個條件判斷：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>if (ray_length_view == 0.0) {
</span><span>    return vec4(0.0, 0.0, 0.0, 0.0);
</span><span>}
</span></code></pre><p>如果射線長度為零，意味著體積被完全遮擋，片段著色器會立即返回一個完全透明的顏色（RGBA 均為 0），從而跳過所有後續昂貴的射線步進計算。這不僅修復了視覺錯誤，也提升了在遮擋情況下的效能。<p>這個修復屬於「D-Trivial」（瑣碎）分類，因為它只修改了幾行程式碼，邏輯清晰，沒有引入複雜的依賴或架構變更。它專注於解決一個具體的渲染管線（rendering pipeline）問題。<p><strong>技術洞察</strong> 這個問題凸顯了在體積渲染中深度測試（depth testing）的重要性。對於不透明物體，GPU 的深度緩衝（depth buffer）和深度測試可以自動處理遮擋。但對於像霧這樣的體積效果，它們是使用 alpha 混合在後處理（post-processing）階段繪製的，因此需要手動在著色器中進行深度比較來模擬遮擋。原程式碼的 <code>abs()</code> 可能是一個疏忽，或者最初是為了處理某些邊界情況，但它錯誤地處理了最常見的遮擋情況。<p><strong>影響</strong> 這個修復的影響非常具體且正面：<ol><li><strong>視覺正確性</strong>：消除了體積霧穿過不透明表面的錯誤，使渲染結果更符合物理直覺。<li><strong>效能微優化</strong>：在完全遮擋的像素上提前終止著色器執行，節省了不必要的計算。<li><strong>程式碼清晰度</strong>：新的邏輯（<code>max</code> 和提前返回）比使用 <code>abs</code> 更明確地傳達了「僅在前方渲染」的意圖。</ol><p>總的來說，這是一個小而重要的修正，展示了即使在成熟的渲染引擎中，基礎的數學運算選擇也可能導致明顯的視覺錯誤，而清晰的邏輯和對渲染管線的理解是解決這類問題的關鍵。<h2 id=shi-jue-hua-biao-shi>視覺化表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[片段著色器開始] --> B[計算 start_depth_view 和 end_depth_view]
</span><span>    B --> C{計算 ray_length_view = max(0.0, end - start)}
</span><span>    C --> D{ray_length_view == 0.0?}
</span><span>    D -->|是，體積被遮擋| E[提前返回透明顏色 vec4(0.0)]
</span><span>    D -->|否，體積可見| F[繼續執行射線步進計算體積霧]
</span><span>    F --> G[返回計算出的霧顏色]
</span><span>    E --> H[著色器結束]
</span><span>    G --> H
</span></code></pre><h2 id=guan-jian-dang-an-bian-geng>關鍵檔案變更</h2><ul><li><p><strong><code>crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl</code></strong> (+7/-1) 這是此次 PR 唯一修改的檔案，包含了修復體積霧渲染順序問題的核心邏輯。</p> <ol><li><strong>變更內容與原因</strong>：修改了射線長度的計算方式，並在射線長度為零（表示完全遮擋）時讓著色器提前退出，以避免渲染本應被遮擋的體積霧。<li><strong>程式碼片段</strong>：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 修改前：
</span><span>let ray_length_view = abs(end_depth_view - start_depth_view);
</span></code></pre> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 修改後：
</span><span>let ray_length_view = max(0.0, end_depth_view - start_depth_view);
</span><span>// If the end is behind the start of the first opaque pixel, then we know it
</span><span>// is occluded, and we don't need to render it
</span><span>if (ray_length_view == 0.0) {
</span><span>    return vec4(0.0, 0.0, 0.0, 0.0);
</span><span>}
</span></code></pre><li><strong>與 PR 目的的關聯</strong>：這兩行改動直接實現了 PR 的目標——防止體積霧在被其他幾何體遮擋時仍然被渲染。<code>max</code> 函數確保了可見的射線長度，而 <code>if</code> 語句則處理了不可見（被遮擋）的情況。</ol></ul><h2 id=further-reading>Further Reading</h2><p>若想深入了解此 PR 涉及的相關概念與技術，可以參考以下資源：<ol><li><strong>Bevy 渲染手冊 (Bevy Render Book)</strong>：了解 Bevy 的渲染架構與管線。<li><strong>WebGPU 與 WGSL 規範</strong>：理解著色器語言語義，特別是座標系統與深度處理。<li><strong>體積渲染 (Volume Rendering) 與射線步進 (Ray Marching)</strong> 的基礎理論： <ul><li>“Real-Time Volume Graphics” 相關論文或教程。<li>關於如何在後處理階段整合深度緩衝來進行遮蔽測試。</ul><li><strong>深度緩衝 (Z-Buffer) 與深度測試 (Depth Test)</strong>：電腦圖學中處理物件前後遮擋關係的標準方法。</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23062.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>