diff --git a/crates/bevy_diagnostic/src/diagnostic.rs b/crates/bevy_diagnostic/src/diagnostic.rs
index 17943ae60d308..0a8ed6a73c0bf 100644
--- a/crates/bevy_diagnostic/src/diagnostic.rs
+++ b/crates/bevy_diagnostic/src/diagnostic.rs
@@ -376,10 +376,10 @@ impl<'w, 's> Diagnostics<'w, 's> {
 struct DiagnosticsBuffer(HashMap<DiagnosticPath, DiagnosticMeasurement, PassHash>);
 
 impl SystemBuffer for DiagnosticsBuffer {
-    fn apply(
+    fn queue(
         &mut self,
         _system_meta: &bevy_ecs::system::SystemMeta,
-        world: &mut bevy_ecs::world::World,
+        mut world: bevy_ecs::world::DeferredWorld,
     ) {
         let Some(mut diagnostics) = world.get_resource_mut::<DiagnosticsStore>() else {
             // `SystemBuffer::apply` is called even if the system never runs. If a user uses
diff --git a/crates/bevy_ecs/src/system/commands/parallel_scope.rs b/crates/bevy_ecs/src/system/commands/parallel_scope.rs
index f5ad7a69a3d57..5fb2dbeddecec 100644
--- a/crates/bevy_ecs/src/system/commands/parallel_scope.rs
+++ b/crates/bevy_ecs/src/system/commands/parallel_scope.rs
@@ -4,6 +4,7 @@ use crate::{
     entity::{Entities, EntityAllocator},
     prelude::World,
     system::{Deferred, SystemBuffer, SystemMeta, SystemParam},
+    world::DeferredWorld,
 };
 
 use super::{CommandQueue, Commands};
@@ -64,6 +65,15 @@ impl SystemBuffer for ParallelCommandQueue {
             cq.apply(world);
         }
     }
+
+    #[inline]
+    fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
+        #[cfg(feature = "trace")]
+        let _system_span = _system_meta.commands_span.enter();
+        for cq in self.thread_queues.iter_mut() {
+            world.commands().append(cq);
+        }
+    }
 }
 
 impl<'w, 's> ParallelCommands<'w, 's> {
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index dd1c116c3c731..8b756b0d92045 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -1179,9 +1179,14 @@ unsafe impl<'a, T: FromWorld + Send + 'static> SystemParam for Local<'a, T> {
 /// so you should try to minimize the time spent in [`SystemBuffer::apply`].
 pub trait SystemBuffer: FromWorld + Send + 'static {
     /// Applies any deferred mutations to the [`World`].
-    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World);
+    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+        self.queue(system_meta, world.into());
+    }
     /// Queues any deferred mutations to be applied at the next [`ApplyDeferred`](crate::prelude::ApplyDeferred).
-    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld) {}
+    ///
+    /// To queue structural changes to [`DeferredWorld`], a command queue of the [`DeferredWorld`]
+    /// should be used via [`commands`](crate::world::DeferredWorld::commands).
+    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld);
 }
 
 /// A [`SystemParam`] that stores a buffer which gets applied to the [`World`] during
@@ -1202,6 +1207,7 @@ pub trait SystemBuffer: FromWorld + Send + 'static {
 ///
 /// ```
 /// # use bevy_ecs::prelude::*;
+/// # use bevy_ecs::world::DeferredWorld;
 /// // Tracks whether or not there is a threat the player should be aware of.
 /// #[derive(Resource, Default)]
 /// pub struct Alarm(bool);
@@ -1237,7 +1243,7 @@ pub trait SystemBuffer: FromWorld + Send + 'static {
 /// impl SystemBuffer for AlarmFlag {
 ///     // When `AlarmFlag` is used in a system, this function will get
 ///     // called the next time buffers are applied via ApplyDeferred.
-///     fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+///     fn queue(&mut self, system_meta: &SystemMeta, mut world: DeferredWorld) {
 ///         if self.0 {
 ///             world.resource_mut::<Alarm>().0 = true;
 ///             self.0 = false;
diff --git a/crates/bevy_gizmos/src/gizmos.rs b/crates/bevy_gizmos/src/gizmos.rs
index b16ed88f3ebc0..cb368561787a5 100644
--- a/crates/bevy_gizmos/src/gizmos.rs
+++ b/crates/bevy_gizmos/src/gizmos.rs
@@ -16,7 +16,7 @@ use bevy_ecs::{
         Deferred, ReadOnlySystemParam, Res, SystemBuffer, SystemMeta, SystemParam,
         SystemParamValidationError,
     },
-    world::{unsafe_world_cell::UnsafeWorldCell, World},
+    world::{unsafe_world_cell::UnsafeWorldCell, DeferredWorld, World},
 };
 use bevy_math::{bounding::Aabb3d, Isometry2d, Isometry3d, Vec2, Vec3};
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
@@ -347,7 +347,7 @@ where
     Config: GizmoConfigGroup,
     Clear: 'static + Send + Sync,
 {
-    fn apply(&mut self, _system_meta: &SystemMeta, world: &mut World) {
+    fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
         let mut storage = world.resource_mut::<GizmoStorage<Config, Clear>>();
         storage.list_positions.append(&mut self.list_positions);
         storage.list_colors.append(&mut self.list_colors);
diff --git a/crates/bevy_render/src/renderer/render_context.rs b/crates/bevy_render/src/renderer/render_context.rs
index 6ace7d63cc2d4..850091ddfb06e 100644
--- a/crates/bevy_render/src/renderer/render_context.rs
+++ b/crates/bevy_render/src/renderer/render_context.rs
@@ -103,7 +103,7 @@ impl RenderContextState {
 }
 
 impl SystemBuffer for RenderContextState {
-    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+    fn queue(&mut self, system_meta: &SystemMeta, mut world: DeferredWorld) {
         let _span = info_span!("RenderContextState::apply", system = %system_meta.name()).entered();
 
         let inner = &mut *self.0;
@@ -120,8 +120,6 @@ impl SystemBuffer for RenderContextState {
 
         inner.render_device = None;
     }
-
-    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld) {}
 }
 
 /// A system parameter that provides access to a command encoder and render device for issuing
diff --git a/release-content/migration-guides/system_buffer_queue.md b/release-content/migration-guides/system_buffer_queue.md
new file mode 100644
index 0000000000000..41e4db02d4b9f
--- /dev/null
+++ b/release-content/migration-guides/system_buffer_queue.md
@@ -0,0 +1,33 @@
+---
+title: "`SystemBuffer` requires `queue()` to be implemented"
+pull_requests: [22832]
+---
+
+`SystemBuffer` now requires `queue()` to be implemented, instead of `apply().`
+`apply()`'s default implementation now delegates to `queue()`.
+
+This is to ensure that a `SystemBuffer` used in an Observer context applies its changes.
+In most cases, if `apply()` does not change the `World` structurally,
+`apply()` and `queue()` can mutate the `World` directly in the same way.
+
+If `apply()` does not change the `World` structurally, `apply()` should be changed to `queue()`:
+
+```rust
+// 0.18
+impl SystemBuffer for MySystemBuffer {
+  fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+    // your impl here
+  }
+}
+
+// 0.19
+impl SystemBuffer for MySystemBuffer {
+  fn queue(&mut self, system_meta: &SystemMeta, mut world: DeferredWorld) {
+    // your impl here, using a DeferredWorld instead
+  }
+}
+```
+
+If `apply()` does change the `World` structurally, implement both `apply()` and `queue()`.
+To queue structural changes to a `DeferredWorld`, add the structural changes to its command queue,
+accessible via `world.commands()`.
