<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22734 Mesh::deduplicate_vertices
        
    </title><meta content="#22734 Mesh::deduplicate_vertices" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-04</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22734-zh-cn-20260204>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Mesh::deduplicate_vertices<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Mesh::deduplicate_vertices<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22734<li><strong>Author</strong>: Smerom<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, A-Math, D-Modest<li><strong>Created</strong>: 2026-01-29T07:23:22Z<li><strong>Merged</strong>: 2026-02-04T19:21:03Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Adopted from #16016: resolved merge conflicts and updated api to match what’s available for the inverse <code>Mesh::duplicate_vertices</code> method.<h1 id=objective>Objective</h1><p>Current Mesh is not easy to create programmatically: a developer has either: - generate duplicate vertices - or do non-trivial logic of dealing with indices<h2 id=solution>Solution</h2><p>Currently there’s Mesh::duplicate_vertices operation which flattens vertices by removing indices.<p>This PR proposes inverse operation: Mesh::deduplicate_vertices: if index is not set, deduplicate vertex data and create an index.<p>So for quick experiments, when startup time may be not as important as amount of data, mesh can be generated without dealing with indices, and then Mesh::deduplicate_vertices will generate an index.<h2 id=testing>Testing</h2><p>Unit test added.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>When creating meshes programmatically in Bevy, developers face a choice between two suboptimal approaches. The first approach is to generate duplicate vertices - meaning each triangle gets its own set of three vertices even when vertices are shared between triangles. This approach is simple to implement but wastes memory and processing power since identical vertex data gets stored and processed multiple times.<p>The second approach requires implementing index-based mesh generation, where vertices are stored once and triangles reference them via indices. While more memory-efficient, this requires developers to write non-trivial deduplication logic or carefully construct their meshes to avoid duplicates from the start. This adds complexity to mesh generation code, especially for quick prototypes or experimental features where development speed is more important than optimization.<p>Bevy already had a <code>Mesh::duplicate_vertices</code> method that did the opposite transformation: it took an indexed mesh and flattened it by removing the index buffer and duplicating vertex data for each triangle. However, there was no corresponding method to go from a non-indexed mesh with potential duplicates back to an indexed, deduplicated mesh.<h3 id=the-solution-approach>The Solution Approach</h3><p>The developer adopted and updated an existing PR (#16016) that had become stale due to merge conflicts and API changes. The solution adds two new methods to the <code>Mesh</code> struct: <code>merge_duplicate_vertices()</code> for in-place mutation and <code>with_merge_duplicate_vertices()</code> for a consuming version that returns a new mesh.<p>The core insight is that this operation should only work on meshes without existing indices. If a mesh already has indices set, the operation returns an error, though the documentation suggests calling <code>duplicate_vertices()</code> first and then <code>merge_duplicate_vertices()</code> as a workaround for indexed meshes that might still have duplicate vertices.<p>The implementation uses a hash map to detect duplicate vertices efficiently. Each vertex is represented by all its attribute data (position, UVs, normals, etc.), and vertices are considered equal only if all their attributes match byte-for-byte. This ensures correctness even when vertices share position but differ in other attributes like UV coordinates.<h3 id=the-implementation>The Implementation</h3><p>The main implementation lives in the <code>merge_duplicate_vertices()</code> method in <code>mesh.rs</code>. Here’s how it works:<p>First, the method checks if indices are already set, returning an error if they are:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>match </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_indices</span><span>() {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(MeshMergeDuplicateVerticesError</span><span style=color:#ed9366>::</span><span>IndicesAlreadySet)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(err) </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>match</span><span> err {
</span><span>        MeshAccessError</span><span style=color:#ed9366>::</span><span>ExtractedToRenderWorld </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(err</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#61676ccc>,
</span><span>        MeshAccessError</span><span style=color:#ed9366>::</span><span>NotFound </span><span style=color:#ed9366>=> </span><span>()</span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>The method creates a <code>VertexRef</code> struct that acts as a lightweight reference to a vertex in the original mesh:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>VertexRef</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    mesh_attributes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a </span><span>BTreeMap&LTMeshVertexAttributeId, MeshAttributeData>,
</span><span>    i</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>}
</span></code></pre><p>This struct implements <code>Hash</code> and <code>Eq</code> by comparing the byte representation of all vertex attributes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>> Hash </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>VertexRef</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>hash</span><span>&LTH</span><span style=color:#61676ccc>:</span><span> Hasher>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>state</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> H) {
</span><span>        </span><span style=color:#fa6e32>for</span><span> values </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>mesh_attributes</span><span style=color:#ed9366>.</span><span style=color:#f07171>values</span><span>() {
</span><span>            values</span><span style=color:#ed9366>.</span><span>values</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_bytes_at</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>i)</span><span style=color:#ed9366>.</span><span style=color:#f07171>hash</span><span>(state)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The deduplication process then iterates through all vertices, using a hash map to track unique vertices:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let mut</span><span> vertex_to_new_index</span><span style=color:#61676ccc>: </span><span>HashMap&LTVertexRef, </span><span style=color:#fa6e32>u32</span><span>> </span><span style=color:#ed9366>= </span><span>HashMap</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let mut</span><span> indices </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span style=color:#ed9366>::</span><span>with_capacity(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>count_vertices</span><span>())</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>for</span><span> i </span><span style=color:#ed9366>in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>count_vertices</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> vertex_ref </span><span style=color:#ed9366>=</span><span> VertexRef {
</span><span>        mesh_attributes</span><span style=color:#61676ccc>:</span><span> old_attributes</span><span style=color:#61676ccc>,
</span><span>        i</span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> j </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> vertex_to_new_index</span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>(vertex_ref) {
</span><span>        hash_map</span><span style=color:#ed9366>::</span><span>Entry</span><span style=color:#ed9366>::</span><span>Occupied(e) </span><span style=color:#ed9366>=> *</span><span>e</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>()</span><span style=color:#61676ccc>,
</span><span>        hash_map</span><span style=color:#ed9366>::</span><span>Entry</span><span style=color:#ed9366>::</span><span>Vacant(e) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            e</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(len)</span><span style=color:#61676ccc>;
</span><span>            vertex_ref</span><span style=color:#ed9366>.</span><span style=color:#f07171>push_to</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> new_attributes)</span><span style=color:#61676ccc>;
</span><span>            len
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    indices</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(j)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The <code>VertexAttributeValues</code> enum in <code>vertex.rs</code> gets several new helper methods to support this operation:<ol><li><code>new()</code> - Creates an empty vertex attribute container of a specific format<li><code>get_bytes_at()</code> - Gets the byte representation of a vertex at a specific index<li><code>push_from()</code> - Copies a vertex from one attribute container to another<li><code>shrink_to_fit()</code> - Reduces memory usage after building the new attribute vectors</ol><p>The <code>push_from()</code> method is particularly interesting because it uses exhaustive pattern matching to ensure type safety:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>push_from</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>VertexAttributeValues, </span><span style=color:#ff8f40>i</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>) {
</span><span>    </span><span style=color:#fa6e32>match </span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#61676ccc>,</span><span> source) {
</span><span>        (VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Float32(this)</span><span style=color:#61676ccc>, </span><span>VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Float32(source)) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            this</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(source[i])</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        (VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Float32(</span><span style=color:#ed9366>_</span><span>)</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>=> </span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"Mismatched vertex attribute values"</span><span>)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... many more variants for each attribute type
</span><span>    }
</span><span>}
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>The implementation makes careful use of Rust’s type system to ensure correctness. The exhaustive pattern matching in <code>push_from()</code> guarantees at compile time that we handle all possible vertex attribute type combinations, and the runtime panic for mismatched types provides a clear error message if there’s a programming error.<p>The <code>VertexRef</code> struct is a clever optimization that avoids copying vertex data during the deduplication process. Instead of creating new vertex data structures for comparison, it references the original data and compares bytes directly. This is important for performance since vertex data can be large.<p>The error handling follows Bevy’s established patterns, with a dedicated error enum <code>MeshMergeDuplicateVerticesError</code> that properly converts from <code>MeshAccessError</code> using the <code>From</code> trait.<h3 id=the-impact>The Impact</h3><p>This PR adds a valuable utility function to Bevy’s mesh API. Developers can now:<ol><li>Generate meshes simply without worrying about indices during initial development<li>Optimize those meshes later with a single method call<li>Round-trip between indexed and non-indexed representations when needed</ol><p>The unit test demonstrates the functionality with a practical example: a quad made of two triangles where some vertices are duplicates. The test verifies that:<ul><li>Deduplication reduces 6 vertices to 5 unique vertices<li>The index buffer is correctly generated with 6 indices<li>Calling <code>duplicate_vertices()</code> after deduplication restores the original vertex count<li>The original and restored vertex data match exactly</ul><p>This functionality is particularly useful for:<ul><li>Procedural mesh generation where deduplication logic would be complex<li>Importing mesh data from formats that don’t use indices<li>Optimizing meshes generated by external tools or algorithms<li>Educational examples where simplicity is more important than performance</ul><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Non-indexed Mesh with Duplicates] --> B[merge_duplicate_vertices]
</span><span>    B --> C[Indexed Mesh without Duplicates]
</span><span>    C --> D[duplicate_vertices]
</span><span>    D --> A
</span><span>    
</span><span>    E[VertexRef struct] --> F[Hash and Compare by Bytes]
</span><span>    F --> G[HashMap for Deduplication]
</span><span>    G --> H[New Attribute Vectors]
</span><span>    G --> I[New Index Buffer]
</span><span>    
</span><span>    J[VertexAttributeValues] --> K[new: Create Empty]
</span><span>    J --> L[get_bytes_at: Get Bytes for Hashing]
</span><span>    J --> M[push_from: Copy Vertex]
</span><span>    J --> N[shrink_to_fit: Optimize Memory]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-mesh-src-mesh-rs-187-2><code>crates/bevy_mesh/src/mesh.rs</code> (+187/-2)</h3><p>This file contains the main implementation of the <code>merge_duplicate_vertices</code> method and related functionality.<p><strong>Key changes:</strong><ol><li>Added <code>merge_duplicate_vertices()</code> and <code>with_merge_duplicate_vertices()</code> methods to the <code>Mesh</code> struct<li>Added <code>MeshMergeDuplicateVerticesError</code> enum for error handling<li>Added comprehensive unit test for the new functionality</ol><p><strong>Code snippet showing the core algorithm:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>merge_duplicate_vertices</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), MeshMergeDuplicateVerticesError> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... error checking
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> vertex_to_new_index</span><span style=color:#61676ccc>: </span><span>HashMap&LTVertexRef, </span><span style=color:#fa6e32>u32</span><span>> </span><span style=color:#ed9366>= </span><span>HashMap</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> indices </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span style=color:#ed9366>::</span><span>with_capacity(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>count_vertices</span><span>())</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>for</span><span> i </span><span style=color:#ed9366>in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>count_vertices</span><span>() {
</span><span>        </span><span style=color:#fa6e32>let</span><span> vertex_ref </span><span style=color:#ed9366>=</span><span> VertexRef {
</span><span>            mesh_attributes</span><span style=color:#61676ccc>:</span><span> old_attributes</span><span style=color:#61676ccc>,
</span><span>            i</span><span style=color:#61676ccc>,
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> j </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> vertex_to_new_index</span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>(vertex_ref) {
</span><span>            hash_map</span><span style=color:#ed9366>::</span><span>Entry</span><span style=color:#ed9366>::</span><span>Occupied(e) </span><span style=color:#ed9366>=> *</span><span>e</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>()</span><span style=color:#61676ccc>,
</span><span>            hash_map</span><span style=color:#ed9366>::</span><span>Entry</span><span style=color:#ed9366>::</span><span>Vacant(e) </span><span style=color:#ed9366>=> </span><span>{
</span><span>                e</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(len)</span><span style=color:#61676ccc>;
</span><span>                vertex_ref</span><span style=color:#ed9366>.</span><span style=color:#f07171>push_to</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> new_attributes)</span><span style=color:#61676ccc>;
</span><span>                len
</span><span>            }
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        indices</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(j)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... update mesh with new attributes and indices
</span><span>}
</span></code></pre><h3 id=crates-bevy-mesh-src-vertex-rs-265-1><code>crates/bevy_mesh/src/vertex.rs</code> (+265/-1)</h3><p>This file extends the <code>VertexAttributeValues</code> enum with helper methods needed for vertex deduplication.<p><strong>Key changes:</strong><ol><li>Added <code>new()</code> method to create empty vertex attribute containers<li>Added <code>get_bytes_at()</code> method for byte-level comparison of vertices<li>Added <code>push_from()</code> method to copy vertices between containers<li>Added <code>shrink_to_fit()</code> method to optimize memory usage</ol><p><strong>Code snippet showing the byte extraction method:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get_bytes_at</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>i</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#fa6e32>u8</span><span>] {
</span><span>    </span><span style=color:#fa6e32>match </span><span style=color:#55b4d4;font-style:italic>self </span><span>{
</span><span>        VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Float32(values) </span><span style=color:#ed9366>=> </span><span style=color:#f07171>bytes_of</span><span>(</span><span style=color:#ed9366>&</span><span>values[i])</span><span style=color:#61676ccc>,
</span><span>        VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Sint32(values) </span><span style=color:#ed9366>=> </span><span style=color:#f07171>bytes_of</span><span>(</span><span style=color:#ed9366>&</span><span>values[i])</span><span style=color:#61676ccc>,
</span><span>        VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Uint32(values) </span><span style=color:#ed9366>=> </span><span style=color:#f07171>bytes_of</span><span>(</span><span style=color:#ed9366>&</span><span>values[i])</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... many more variants for each attribute type
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy Mesh Documentation</strong>: <a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_mesh/latest/bevy_mesh/ target=_blank>https://docs.rs/bevy_mesh/latest/bevy_mesh/</a><li><strong>Original PR #16016</strong>: The original implementation that this PR was adapted from<li><strong>Vertex Buffers and Index Buffers in Computer Graphics</strong>: Understanding the difference between indexed and non-indexed geometry representations<li><strong>Rust HashMap and Hashing</strong>: How Rust’s hash maps work and best practices for implementing custom Hash traits<li><strong>Mesh Optimization Techniques</strong>: Common algorithms for mesh optimization including vertex deduplication, triangle stripping, and LOD generation</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22734.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>