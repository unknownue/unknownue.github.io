<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21831 Implement per-pixel linked list for OIT
        
    </title><meta content="#21831 Implement per-pixel linked list for OIT" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-05</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-21831-zh-cn-20260205>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Implement per-pixel linked list for OIT<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21831<li><strong>Author</strong>: beicause<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, C-Refinement, D-Shaders, S-Ready-For-Review<li><strong>Created</strong>: 2025-11-14T02:22:56Z<li><strong>Merged</strong>: 2026-02-05T21:40:10Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>The current OIT stores viewport-sized fragments per layer. It uses much more memory than it can be.<h2 id=solution>Solution</h2><p>Implements per-pixel linked list for OIT, which saves memory and can handle more layers. The implementation references https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/oit_linked_lists<h2 id=testing>Testing</h2><p>Tested with the <code>order_independent_transparency</code> example. I also added a new scene in it.<details><img alt=屏幕截图_20251114_100337 height=1098 src=https://github.com/user-attachments/assets/cd76a6be-69db-4700-88a8-34a2ab140c16 width=1763></details><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>The existing Order Independent Transparency (OIT) implementation in Bevy used a fixed-size layer approach. For each pixel on screen, it allocated storage for N fragments (where N was <code>OrderIndependentTransparencySettings::layer_count</code>). This approach had significant memory inefficiency because it allocated memory for every possible fragment in every pixel, regardless of whether that pixel actually contained that many transparent fragments.<p>The memory usage scaled with screen resolution multiplied by layer count, which could become prohibitive for high-resolution displays. For example, at 4K resolution (3840x2160) with 8 layers, the system needed to allocate storage for 66 million fragments, even if most pixels had only 0-2 transparent fragments.<h3 id=the-solution-approach>The Solution Approach</h3><p>This PR implements a per-pixel linked list approach, which is a more memory-efficient data structure for OIT. Instead of pre-allocating fixed slots per pixel, it maintains:<ol><li>A global pool of fragment nodes (<code>nodes</code> buffer)<li>A per-pixel head pointer array (<code>heads</code> buffer)<li>An atomic counter for node allocation (<code>atomic_counter</code> buffer)</ol><p>This approach only allocates memory for actual fragments that exist in the scene, significantly reducing memory usage for typical scenes where transparent objects are sparse. The implementation references the Khronos Vulkan Samples’ linked list OIT implementation, adapting it for Bevy’s architecture and WebGPU compatibility.<h3 id=the-implementation>The Implementation</h3><p>The core change replaces the previous <code>BufferVec&LTUVec2></code> for layers and <code>BufferVec&LTi32></code> for layer IDs with three new buffers:<ol><li><code>nodes</code>: Stores <code>OitFragmentNode</code> structs containing color (RGB9E5 encoded), depth+alpha (packed 24-bit depth + 8-bit alpha), and a <code>next</code> pointer<li><code>heads</code>: Array of head pointers, one per screen pixel<li><code>atomic_counter</code>: Single atomic counter for allocating new nodes</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_core_pipeline/src/oit/mod.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>OitBuffers </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>layers</span><span style=color:#61676ccc>: </span><span>BufferVec&LTUVec2>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>layer_ids</span><span style=color:#61676ccc>: </span><span>BufferVec<</span><span style=color:#fa6e32>i32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>settings</span><span style=color:#61676ccc>: </span><span>DynamicUniformBuffer&LTOrderIndependentTransparencySettings>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>OitBuffers </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>settings</span><span style=color:#61676ccc>: </span><span>DynamicUniformBuffer&LTOrderIndependentTransparencySettings>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>nodes_capacity</span><span style=color:#61676ccc>: </span><span>UniformBuffer<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>nodes</span><span style=color:#61676ccc>: </span><span>UninitBufferVec&LTOitFragmentNode>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>heads</span><span style=color:#61676ccc>: </span><span>UninitBufferVec<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>atomic_counter</span><span style=color:#61676ccc>: </span><span>UninitBufferVec<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>}
</span></code></pre><p>The fragment insertion in the shader changed from writing to a fixed array index to atomically allocating a node and updating the linked list:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// File: crates/bevy_core_pipeline/src/oit/oit_draw.wgsl
</span><span>// Before (simplified):
</span><span>let layer_index = screen_index + layer_id * buffer_size;
</span><span>let rgb9e5_color = bevy_pbr::rgb9e5::vec3_to_rgb9e5_(color.rgb);
</span><span>let depth_alpha = pack_24bit_depth_8bit_alpha(position.z, color.a);
</span><span>oit_layers[layer_index] = vec2(rgb9e5_color, depth_alpha);
</span><span>
</span><span>// After:
</span><span>var new_node_index = atomicAdd(&oit_atomic_counter, 1u);
</span><span>var node: OitFragmentNode;
</span><span>node.next = atomicExchange(&oit_heads[screen_index], new_node_index + 1u) - 1u;
</span><span>node.color = bevy_pbr::rgb9e5::vec3_to_rgb9e5_(color.rgb);
</span><span>node.depth_alpha = pack_24bit_depth_8bit_alpha(position.z, color.a);
</span><span>oit_nodes[new_node_index] = node;
</span></code></pre><p>The resolve pass also changed significantly. Instead of processing a fixed-size array, it now traverses the linked list, sorts fragments by depth, and handles cases where there are more fragments than the sort buffer can hold:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// File: crates/bevy_core_pipeline/src/oit/resolve/oit_resolve.wgsl
</span><span>// Key algorithm:
</span><span>var current_node = head;
</span><span>var sorted_frag_count = 0u;
</span><span>while current_node != LINKED_LIST_END_SENTINEL {
</span><span>    let fragment_node = nodes[current_node];
</span><span>    current_node = fragment_node.next;
</span><span>    
</span><span>    if sorted_frag_count < SORTED_FRAGMENT_MAX_COUNT {
</span><span>        // Insert into sorted array
</span><span>    } else if fragment_list[0].depth_alpha > fragment_node.depth_alpha {
</span><span>        // Blend nearest and insert
</span><span>    } else {
</span><span>        // Blend early (approximation)
</span><span>    }
</span><span>}
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>Several important technical details in this implementation:<ol><li><p><strong>Memory Layout Optimization</strong>: The depth and alpha are packed into a single 32-bit value with depth in the higher bits. This allows depth comparisons to work directly on the packed value without unpacking, since <code>depth(a) < depth(b) <=> packed(a) < packed(b)</code>.</p><li><p><strong>Sentinel Values</strong>: The implementation uses <code>u32::MAX</code> (0xFFFFFFFF) as the end-of-list sentinel, but stores <code>head + 1</code> in the heads buffer to avoid writing <code>u32::MAX</code> from the CPU. WGPU guarantees buffers are zero-initialized, so <code>0</code> becomes the sentinel after subtracting 1.</p><li><p><strong>Approximate Sorting</strong>: When there are more fragments than <code>sorted_fragment_max_count</code>, the system uses an approximation algorithm that either blends fragments early (if they’re behind all sorted fragments) or blends the nearest sorted fragment and inserts the new one.</p><li><p><strong>Thread Safety</strong>: Atomic operations ensure thread-safe insertion into the linked list from multiple fragments writing to the same pixel concurrently.</p><li><p><strong>Buffer Management</strong>: The system dynamically resizes buffers based on camera requirements and completely releases them when no cameras use OIT, preventing memory waste.</p></ol><h3 id=the-impact>The Impact</h3><p>This PR provides significant improvements:<ol><li><p><strong>Memory Efficiency</strong>: Memory usage now scales with actual fragment count rather than worst-case scenario. For scenes with sparse transparency, this can reduce OIT memory usage by 90% or more.</p><li><p><strong>Flexibility</strong>: The linked list can handle more fragments per pixel than the previous fixed-layer approach, limited only by total buffer capacity.</p><li><p><strong>Performance</strong>: While atomic operations add some overhead, the reduced memory bandwidth and ability to handle more complex transparency scenarios efficiently often results in better overall performance.</p><li><p><strong>Integration</strong>: The changes maintain backward compatibility with existing OIT settings while providing more control via <code>sorted_fragment_max_count</code> and <code>fragments_per_pixel_average</code>.</p></ol><p>The implementation also fixes synchronization issues by ensuring the transparent pass only runs when the OIT resolve pipeline is ready, preventing corrupted linked lists from concurrent buffer modifications.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Transparent Mesh Rendering] --> B[oit_draw.wgsl]
</span><span>    B --> C[Atomic Node Allocation]
</span><span>    C --> D[Nodes Buffer]
</span><span>    B --> E[Head Pointer Update]
</span><span>    E --> F[Heads Buffer]
</span><span>    B --> G[Atomic Counter Increment]
</span><span>    G --> H[Atomic Counter Buffer]
</span><span>    
</span><span>    I[OIT Resolve Pass] --> J[oit_resolve.wgsl]
</span><span>    J --> K[Traverse Linked List]
</span><span>    K --> L[Sort Fragments]
</span><span>    L --> M[Blend with Approximation]
</span><span>    M --> N[Final Color Output]
</span><span>    
</span><span>    F --> K
</span><span>    D --> K
</span><span>    H --> J
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-core-pipeline-src-oit-mod-rs-129-118><code>crates/bevy_core_pipeline/src/oit/mod.rs</code> (+129/-118)</h3><p><strong>What changed</strong>: Complete restructuring of OIT buffer management from fixed layers to linked list. <strong>Why changed</strong>: To implement per-pixel linked list OIT for better memory efficiency.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Key change: New buffer structure
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>OitBuffers </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>settings</span><span style=color:#61676ccc>: </span><span>DynamicUniformBuffer&LTOrderIndependentTransparencySettings>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>nodes_capacity</span><span style=color:#61676ccc>: </span><span>UniformBuffer<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>nodes</span><span style=color:#61676ccc>: </span><span>UninitBufferVec&LTOitFragmentNode>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>heads</span><span style=color:#61676ccc>: </span><span>UninitBufferVec<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>atomic_counter</span><span style=color:#61676ccc>: </span><span>UninitBufferVec<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>}
</span></code></pre><h3 id=crates-bevy-core-pipeline-src-oit-resolve-oit-resolve-wgsl-95-63><code>crates/bevy_core_pipeline/src/oit/resolve/oit_resolve.wgsl</code> (+95/-63)</h3><p><strong>What changed</strong>: Complete rewrite of the resolve shader to traverse linked lists instead of fixed arrays. <strong>Why changed</strong>: To process the new linked list data structure and implement the fragment sorting algorithm.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Key algorithm: Linked list traversal and sorting
</span><span>while current_node != LINKED_LIST_END_SENTINEL {
</span><span>    let fragment_node = nodes[current_node];
</span><span>    current_node = fragment_node.next;
</span><span>    // ... sorting and blending logic
</span><span>}
</span></code></pre><h3 id=examples-3d-order-independent-transparency-rs-110-4><code>examples/3d/order_independent_transparency.rs</code> (+110/-4)</h3><p><strong>What changed</strong>: Added new test scenes including quads and auto-instancing test. <strong>Why changed</strong>: To demonstrate and test the new OIT implementation with more complex scenarios.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// New test scene: Multiple overlapping transparent quads
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>spawn_quads</span><span>(
</span><span>    </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Commands,
</span><span>    </span><span style=color:#ff8f40>meshes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>Assets&LTMesh>,
</span><span>    </span><span style=color:#ff8f40>materials</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>Assets&LTStandardMaterial>,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Spawn multiple overlapping transparent quads with different colors and alphas
</span><span>}
</span></code></pre><h3 id=crates-bevy-core-pipeline-src-oit-resolve-mod-rs-45-21><code>crates/bevy_core_pipeline/src/oit/resolve/mod.rs</code> (+45/-21)</h3><p><strong>What changed</strong>: Updated pipeline creation and bind groups to support the new buffer layout. <strong>Why changed</strong>: To accommodate the three new storage buffers (nodes, heads, atomic_counter) instead of two.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Updated required storage buffers count
</span><span style=color:#fa6e32>pub const </span><span style=color:#ff8f40>OIT_REQUIRED_STORAGE_BUFFERS</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>3</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-pbr-src-render-mesh-view-bindings-rs-33-21><code>crates/bevy_pbr/src/render/mesh_view_bindings.rs</code> (+33/-21)</h3><p><strong>What changed</strong>: Updated bind group layout and preparation to include the new OIT buffers. <strong>Why changed</strong>: To bind the nodes, heads, and atomic_counter buffers to the shader.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Updated bind group entries for OIT
</span><span style=color:#fa6e32>if</span><span> has_oit {
</span><span>    entries </span><span style=color:#ed9366>=</span><span> entries</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend_with_indices</span><span>((
</span><span>        (</span><span style=color:#ff8f40>27</span><span style=color:#61676ccc>,</span><span> oit_settings_binding)</span><span style=color:#61676ccc>,
</span><span>        (</span><span style=color:#ff8f40>28</span><span style=color:#61676ccc>,</span><span> oit_nodes_capacity)</span><span style=color:#61676ccc>,
</span><span>        (</span><span style=color:#ff8f40>29</span><span style=color:#61676ccc>,</span><span> oit_nodes)</span><span style=color:#61676ccc>,
</span><span>        (</span><span style=color:#ff8f40>30</span><span style=color:#61676ccc>,</span><span> oit_heads)</span><span style=color:#61676ccc>,
</span><span>        (</span><span style=color:#ff8f40>31</span><span style=color:#61676ccc>,</span><span> oit_atomic_counter)</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Khronos Vulkan Samples - OIT Linked Lists</strong>: The reference implementation this PR is based on: https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/oit_linked_lists</p><li><p><strong>Order Independent Transparency Techniques</strong>: Survey paper comparing different OIT methods including linked lists, depth peeling, and stochastic transparency.</p><li><p><strong>WebGPU Atomic Operations</strong>: Documentation on atomic operations in WebGPU/WGSL, which are crucial for thread-safe linked list construction.</p><li><p><strong>RGB9E5 Encoding</strong>: The color encoding format used for compact color storage in the fragment nodes.</p><li><p><strong>Bevy Rendering Architecture</strong>: Understanding Bevy’s ECS-based render graph and how OIT integrates with the main transparent pass.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_21831.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>