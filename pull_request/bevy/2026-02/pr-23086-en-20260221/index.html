<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23086 Fix buffered channel memory leak
        
    </title><meta content="#23086 Fix buffered channel memory leak" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-21</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-23086-zh-cn-20260221>中文</a></div></div><div class=pr-content><h1 id=fix-buffered-channel-memory-leak>Fix buffered channel memory leak</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix buffered channel memory leak<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/23086<li><strong>Author</strong>: aevyrie<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, S-Ready-For-Final-Review, P-Regression, A-Transform, A-Tasks<li><strong>Created</strong>: 2026-02-20T23:05:09Z<li><strong>Merged</strong>: 2026-02-21T11:08:19Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><p>This PR description is already in English, so no translation is needed:<h1 id=objective>Objective</h1><ul><li>Fix a possible memory leak when a producer and consumer are on different threads and never switch.</ul><h2 id=solution>Solution</h2><ul><li>Set a maximum size for the object pool to avoid unbounded growth.</ul><h2 id=testing>Testing</h2><ul><li>Reproduced leak in <code>bevy_city</code> with moving cars.<li>Verified leak is no longer present with this patch.</ul><p>Closes #23038 Introduced in #22297<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The issue began with a regression introduced in PR #22297, where the buffered channel implementation in Bevy’s task system was optimized to use a pool of reusable vectors for message passing. While this optimization reduced allocation overhead, it created a subtle edge case that could lead to unbounded memory growth under specific thread scheduling conditions.<p>At the core of the problem was the behavior of <code>RecycledVec</code>, a wrapper type that automatically returns message buffers to the channel’s pool when dropped. The original implementation unconditionally pushed every cleared vector back into a thread-local pool. This worked well when producer and consumer threads alternated or when the system had balanced communication patterns. However, when a producer thread continuously sent messages to a consumer on a different thread without the consumer ever running on the producer’s thread, the thread-local pool would accumulate vectors without bound.<p>Consider a scenario where Thread A produces messages and Thread B consumes them. Each time Thread A sends a message, it allocates a vector or reuses one from its thread-local pool. When the consumer on Thread B processes the message and drops the <code>RecycledVec</code>, the vector gets pushed into Thread B’s thread-local pool. The problem arises because Thread A never executes on Thread B, so it never has the opportunity to reclaim those vectors. This creates a one-way flow of vectors from Thread A’s allocation pool to Thread B’s retention pool, leading to linear memory growth proportional to the number of messages sent.<p>The fix introduces two key changes. First, it adds a maximum size limit to the object pool with a constant <code>MAX_POOL_SIZE</code> set to 8. This prevents unbounded growth by discarding excess vectors rather than storing them indefinitely. Second, it centralizes the recycling logic into a new <code>recycle</code> method on <code>BufferedChannel</code>, ensuring consistent behavior across both the <code>RecycledVec</code> drop implementation and the <code>BufferedSender::flush</code> method.<p>Here’s the core of the fix:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Send</span><span>> </span><span style=color:#399ee6>BufferedChannel</span><span>&LTT> {
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>MAX_POOL_SIZE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>8</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>recycle</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>chunk</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTT>) {
</span><span>        </span><span style=color:#fa6e32>if</span><span> chunk</span><span style=color:#ed9366>.</span><span style=color:#f07171>capacity</span><span>() </span><span style=color:#ed9366>< </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>chunk_size {
</span><span>            </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        chunk</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> pool </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>borrow_local_mut</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if</span><span> pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() </span><span style=color:#ed9366>< </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX_POOL_SIZE </span><span>{
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// Only push to the pool if it's not full
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// Avoids memory leak if the sender and receiver never switch threads
</span><span>            pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(chunk)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The method checks two conditions before recycling a vector: it must have sufficient capacity (at least <code>self.chunk_size</code>), and the pool must have available slots below the maximum size. Vectors that don’t meet these criteria are simply dropped, allowing the Rust allocator to reclaim their memory.<p>The fix also changes the <code>Drop</code> implementation for <code>RecycledVec</code> to use this centralized recycling logic:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>, T</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Send</span><span>> Drop </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>RecycledVec</span><span><</span><span style=color:#fa6e32>'a</span><span>, T> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(buffer) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>channel</span><span style=color:#ed9366>.</span><span style=color:#f07171>recycle</span><span>(buffer)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Additionally, the <code>BufferedSender::flush</code> method was updated to use the same recycling logic and was made public. This change allows external code to explicitly flush buffered messages, which could be useful for scenarios where you want to ensure messages are sent without waiting for the sender to be dropped.<p>The choice of <code>MAX_POOL_SIZE = 8</code> represents a reasonable trade-off between memory efficiency and allocation performance. A pool of 8 vectors provides good reuse opportunities for bursty message patterns while preventing excessive memory retention. The value is small enough that the memory overhead is negligible even in worst-case scenarios where every thread retains its maximum pool size.<p>The fix was validated by reproducing the leak in the <code>bevy_city</code> example with moving cars, where the continuous spawning and despawning of entities could trigger the pathological thread behavior. After applying the patch, memory usage stabilized, confirming that the leak was resolved.<p>This issue highlights an important consideration in concurrent programming: object pools that rely on thread-local storage must account for the possibility of unbalanced thread workloads. Without proper bounds checking, such pools can transform performance optimizations into memory leaks. The solution demonstrates a common pattern in Rust systems programming—using RAII (Resource Acquisition Is Initialization) with careful drop implementations to manage resources, combined with explicit bounds checking to prevent resource exhaustion.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[BufferedChannel] --> B[Thread-local Pool]
</span><span>    B --> C{Is pool full?}
</span><span>    C -->|No| D[Store vector in pool]
</span><span>    C -->|Yes| E[Drop vector]
</span><span>    
</span><span>    F[Producer Thread] --> G[Send message]
</span><span>    G --> H[Allocate/Reuse vector]
</span><span>    H --> I[Consumer Thread processes]
</span><span>    I --> J[RecycledVec dropped]
</span><span>    J --> K[Call channel.recycle()]
</span><span>    K --> C
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-utils-src-buffered-channel-rs-21-5><code>crates/bevy_utils/src/buffered_channel.rs</code> (+21/-5)</h3><p>This file contains the buffered channel implementation used for task communication in Bevy’s ECS (Entity Component System). The changes fix a memory leak in the object pool used to recycle message vectors.<p><strong>Key changes:</strong><ol><li>Added a <code>MAX_POOL_SIZE</code> constant and <code>recycle</code> method to <code>BufferedChannel</code><li>Updated <code>RecycledVec</code> drop implementation to use centralized recycling<li>Updated <code>BufferedSender::flush</code> to use the same recycling logic and made it public</ol><p><strong>Code snippets:</strong><p>Before the fix, vectors were unconditionally pushed to the pool:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>, T</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Send</span><span>> Drop </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>RecycledVec</span><span><</span><span style=color:#fa6e32>'a</span><span>, T> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#fa6e32>mut</span><span> buffer) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>            buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>channel</span><span style=color:#ed9366>.</span><span>pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>borrow_local_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(buffer)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>After the fix, recycling is bounded:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Send</span><span>> </span><span style=color:#399ee6>BufferedChannel</span><span>&LTT> {
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>MAX_POOL_SIZE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>8</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>recycle</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>chunk</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTT>) {
</span><span>        </span><span style=color:#fa6e32>if</span><span> chunk</span><span style=color:#ed9366>.</span><span style=color:#f07171>capacity</span><span>() </span><span style=color:#ed9366>< </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>chunk_size {
</span><span>            </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        chunk</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> pool </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>borrow_local_mut</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if</span><span> pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() </span><span style=color:#ed9366>< </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX_POOL_SIZE </span><span>{
</span><span>            pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(chunk)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>, T</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Send</span><span>> Drop </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>RecycledVec</span><span><</span><span style=color:#fa6e32>'a</span><span>, T> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(buffer) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>channel</span><span style=color:#ed9366>.</span><span style=color:#f07171>recycle</span><span>(buffer)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>flush</code> method was also updated:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>flush</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(buffer) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>() {
</span><span>            </span><span style=color:#fa6e32>let </span><span style=color:#ed9366>_ = </span><span>bevy_platform</span><span style=color:#ed9366>::</span><span>future</span><span style=color:#ed9366>::</span><span>block_on(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>tx</span><span style=color:#ed9366>.</span><span style=color:#f07171>send</span><span>(buffer))</span><span style=color:#61676ccc>;
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>channel</span><span style=color:#ed9366>.</span><span>pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>borrow_local_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(buffer)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>flush</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(buffer) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>() {
</span><span>            </span><span style=color:#fa6e32>let </span><span style=color:#ed9366>_ = </span><span>bevy_platform</span><span style=color:#ed9366>::</span><span>future</span><span style=color:#ed9366>::</span><span>block_on(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>tx</span><span style=color:#ed9366>.</span><span style=color:#f07171>send</span><span>(buffer))</span><span style=color:#61676ccc>;
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>channel</span><span style=color:#ed9366>.</span><span style=color:#f07171>recycle</span><span>(buffer)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Rust RAII Pattern</strong>: The <code>Drop</code> trait implementation in this PR follows the RAII pattern common in Rust. Understanding this pattern is essential for resource management in Rust applications.</p><li><p><strong>Thread-Local Storage in Rust</strong>: The fix addresses a specific issue with thread-local object pools. The Rust standard library’s <code>thread_local!</code> macro and <code>LocalKey</code> type are relevant for understanding the context.</p><li><p><strong>Bounded Object Pools</strong>: The concept of bounded pools is a common solution to prevent resource exhaustion in concurrent systems. The “Leaky Bucket” algorithm and other rate-limiting patterns share similar principles.</p><li><p><strong>Bevy Task System</strong>: Understanding how Bevy’s ECS uses channels for task communication provides context for why this bug was significant. The Bevy documentation on tasks and async systems would be helpful.</p><li><p><strong>Memory Leak Detection in Rust</strong>: While Rust prevents many memory safety issues, logical memory leaks (like this one) can still occur. Tools like Valgrind, heaptrack, or Rust’s built-in allocation tracking can help identify such issues.</p><li><p><strong>PR #22297</strong>: Reviewing the original PR that introduced the regression provides insight into the optimization that inadvertently caused the leak.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23086.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>