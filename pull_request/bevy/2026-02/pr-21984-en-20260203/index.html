<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21984 Contiguous access
        
    </title><meta content="#21984 Contiguous access" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-03</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-21984-zh-cn-20260203>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Contiguous access<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Contiguous access<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21984<li><strong>Author</strong>: Jenya705<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-ECS, C-Performance, S-Ready-For-Review, D-Complex, M-Release-Note, D-Unsafe<li><strong>Created</strong>: 2025-11-30T15:04:09Z<li><strong>Merged</strong>: 2026-02-03T00:45:33Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Enables accessing slices from tables directly via Queries.<p>Fixes: #21861<h2 id=solution>Solution</h2><p>One new trait:<ul><li><code>ContiguousQueryData</code> allows to fetch all values from tables all at once (an implementation for <code>&T</code> returns a slice of components in the set table, for <code>&mut T</code> returns a mutable slice of components in the set table as well as a struct with methods to set update ticks (to match the <code>fetch</code> implementation))</ul><p>Methods <code>contiguous_iter</code>, <code>contiguous_iter_mut</code> and similar in <code>Query</code> and <code>QueryState</code> making possible to iterate using these traits.<p>Macro <code>QueryData</code> was updated to support contiguous items when <code>contiguous(target)</code> attribute is added (a target can be <code>all</code>, <code>mutable</code> and <code>immutable</code>, refer to the <code>custom_query_param</code> example)<h2 id=testing>Testing</h2><ul><li><code>sparse_set_contiguous_query</code> test verifies that you can’t use <code>next_contiguous</code> with sparse set components<li><code>test_contiguous_query_data</code> test verifies that returned values are valid<li><code>base_contiguous</code> benchmark (file is named <code>iter_simple_contiguous.rs</code>)<li><code>base_no_detection</code> benchmark (file is named <code>iter_simple_no_detection.rs</code>)<li><code>base_no_detection_contiguous</code> benchmark (file is named <code>iter_simple_no_detection_contiguous.rs</code>)<li><code>base_contiguous_avx2</code> benchmark (file is named <code>iter_simple_contiguous_avx2.rs</code>)</ul><hr><h2 id=showcase>Showcase</h2><p>Examples <code>contiguous_query</code>, <code>custom_query_param</code><h3 id=example>Example</h3><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// - self.0 is a World
</span><span style=color:#abb0b6;font-style:italic>// - self.1 is a QueryState
</span><span style=color:#abb0b6;font-style:italic>// - velocity is a slice of components with Vec3 inside.
</span><span style=color:#abb0b6;font-style:italic>// - position is a data structure which implements Deref/DerefMut and IntoIterator methods to access the slice
</span><span style=color:#abb0b6;font-style:italic>// as well as mechanism to update update ticks (which it does automatically on dereference), 
</span><span style=color:#abb0b6;font-style:italic>// which may be bypassed via `bypass_change_detection` methods.
</span><span style=color:#fa6e32>for </span><span>(velocity</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> position) </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1.</span><span style=color:#f07171>contiguous_iter_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>() {
</span><span>    </span><span style=color:#f07171>assert!</span><span>(velocity</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() </span><span style=color:#ed9366>==</span><span> position</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for </span><span>(v</span><span style=color:#61676ccc>,</span><span> p) </span><span style=color:#ed9366>in</span><span> velocity</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>zip</span><span>(position</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>()) {
</span><span>        p</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>+=</span><span> v</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h3 id=benchmarks>Benchmarks</h3><p>Code for <code>base</code> benchmark:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Transform</span><span>(Mat4)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Position</span><span>(Vec3)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Rotation</span><span>(Vec3)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Velocity</span><span>(Vec3)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Benchmark</span><span><</span><span style=color:#fa6e32>'w</span><span>>(World, QueryState<(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'w</span><span> Velocity, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'w mut</span><span> Position)</span><span style=color:#ed9366>></span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>> </span><span style=color:#399ee6>Benchmark</span><span><</span><span style=color:#fa6e32>'w</span><span>> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>new</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>
</span><span>        world</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_batch</span><span>(core</span><span style=color:#ed9366>::</span><span>iter</span><span style=color:#ed9366>::</span><span>repeat_n(
</span><span>            (
</span><span>                Transform(Mat4</span><span style=color:#ed9366>::</span><span>from_scale(Vec3</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ONE</span><span>))</span><span style=color:#61676ccc>,
</span><span>                Position(Vec3</span><span style=color:#ed9366>::</span><span>X)</span><span style=color:#61676ccc>,
</span><span>                Rotation(Vec3</span><span style=color:#ed9366>::</span><span>X)</span><span style=color:#61676ccc>,
</span><span>                Velocity(Vec3</span><span style=color:#ed9366>::</span><span>X)</span><span style=color:#61676ccc>,
</span><span>            )</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ff8f40>10_000</span><span style=color:#61676ccc>,
</span><span>        ))</span><span style=color:#61676ccc>;
</span><span>
</span><span>        </span><span style=color:#fa6e32>let</span><span> query </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span>query</span><span style=color:#ed9366>::</span><span><(</span><span style=color:#ed9366>&</span><span>Velocity, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Position)>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>Self</span><span>(world</span><span style=color:#61676ccc>,</span><span> query)
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>(never)]
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>run</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#fa6e32>for </span><span>(velocity</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> position) </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1.</span><span style=color:#f07171>iter_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>) {
</span><span>            position</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>+=</span><span> velocity</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Iterating over 10000 entities from <strong>a single</strong> table and increasing a 3-dimensional vector from component <code>Position</code> by a 3-dimensional vector from component <code>Velocity</code><table><thead><tr><th>Name<th>Time<th>Time (AVX2)<th>Description<tbody><tr><td>base<td>5.5828 µs<td>5.5122 µs<td>Iteration over components<tr><td>base_contiguous<td>4.8825 µs<td>1.8665 µs<td>Iteration over contiguous chunks<tr><td>base_contiguous_avx2<td>2.0740 µs<td>1.8665 µs<td>Iteration over contiguous chunks with enforced avx2 optimizations<tr><td>base_no_detection<td>4.8065 µs<td>4.7723 µs<td>Iteration over components while bypassing change detection through <code>bypass_change_detection()</code> method<tr><td>base_no_detection_contiguous<td>4.3979 µs<td>1.5797 µs<td>Iteration over components without registering update ticks</table><p>Using contiguous ‘iterator’ makes the program a little bit faster and it can be further vectorized to make it even faster<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR introduces a new way to iterate over ECS queries in Bevy: contiguous iteration. The core problem being addressed is that standard query iteration processes entities one by one, which can miss optimization opportunities like auto-vectorization when operating on large groups of components stored contiguously in memory.<h3 id=the-problem-and-context>The Problem and Context</h3><p>In Bevy’s ECS, components are stored in tables when they use table storage. When iterating over a query with standard methods like <code>iter()</code> or <code>iter_mut()</code>, the system fetches components entity by entity. This approach works well for general-purpose iteration but doesn’t take advantage of the fact that components of the same type within a table are stored in contiguous memory blocks.<p>The issue #21861 highlighted the need for accessing these contiguous slices directly. Without this capability, developers couldn’t leverage SIMD instructions or batch processing optimizations that require operating on arrays of data rather than individual elements. This was particularly relevant for performance-critical systems like physics simulations or particle systems that process thousands of entities with the same component layout.<h3 id=the-solution-approach>The Solution Approach</h3><p>The solution introduces a new trait called <code>ContiguousQueryData</code> that extends the existing query system. Instead of fetching components one entity at a time, implementations of this trait can fetch entire slices of components from a table in one operation. The approach maintains compatibility with existing query patterns while adding new capabilities.<p>Key engineering decisions included:<ol><li>Creating new iterator types (<code>QueryContiguousIter</code>) that operate at the table level rather than the entity level<li>Extending the <code>QueryData</code> derive macro to support generating contiguous item types<li>Ensuring the feature only works with “dense” queries (those using table storage, not sparse sets)<li>Maintaining change detection semantics through new types like <code>ContiguousMut</code> and <code>ContiguousRef</code></ol><h3 id=the-implementation>The Implementation</h3><p>The implementation adds the <code>ContiguousQueryData</code> trait to the query system:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>ContiguousQueryData</span><span>: ArchetypeQueryData {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Contiguous</span><span style=color:#ed9366><</span><span style=color:#fa6e32>'w</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>'s</span><span style=color:#ed9366>></span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>fetch_contiguous</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>>(
</span><span>        </span><span style=color:#ff8f40>state</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'s Self</span><span style=color:#ed9366>::</span><span>State,
</span><span>        </span><span style=color:#ff8f40>fetch</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>Fetch<</span><span style=color:#fa6e32>'w</span><span>>,
</span><span>        </span><span style=color:#ff8f40>entities</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'w</span><span> [Entity],
</span><span>    ) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Contiguous<</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>></span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>For basic component references, the implementations are straightforward:<ul><li><code>&T</code> returns <code>&[T]</code> (a slice of immutable components)<li><code>&mut T</code> returns <code>ContiguousMut&LTT></code> (which contains a mutable slice plus change tracking)</ul><p>The <code>ContiguousMut</code> type deserves special attention because it handles change detection correctly:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ContiguousMut</span><span><</span><span style=color:#fa6e32>'w</span><span>, T> {
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) value</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'w mut</span><span> [T],
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) ticks</span><span style=color:#61676ccc>: </span><span>ContiguousComponentTicksMut<</span><span style=color:#fa6e32>'w</span><span>>,
</span><span>}
</span></code></pre><p>When you dereference <code>ContiguousMut</code> (via <code>DerefMut</code>), it automatically marks all components in the slice as changed. This matches the behavior of individual <code>&mut T</code> references but does it efficiently in bulk.<p>The query system gains new methods to use these contiguous iterators:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>, D</span><span style=color:#61676ccc>:</span><span> QueryData, F</span><span style=color:#61676ccc>:</span><span> QueryFilter> </span><span style=color:#399ee6>Query</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>, D, F> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>contiguous_iter_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTQueryContiguousIter<'</span><span style=color:#ed9366>_</span><span>, </span><span style=color:#fa6e32>'s</span><span>, D, F>>
</span><span>    </span><span style=color:#fa6e32>where
</span><span>        D</span><span style=color:#61676ccc>:</span><span> ContiguousQueryData,
</span><span>        F</span><span style=color:#61676ccc>:</span><span> ArchetypeFilter,
</span><span>    {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>reborrow</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>contiguous_iter_inner</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>ok</span><span>()
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>ArchetypeFilter</code> constraint is important: only filters that work at the archetype level (like <code>With&LTT></code> and <code>Without&LTT></code>) can be used with contiguous iteration. Filters that need to check individual entities (like <code>Changed&LTT></code>) cannot be used because contiguous iteration operates on whole tables at once.<h3 id=technical-insights>Technical Insights</h3><p>The implementation reveals several interesting technical details:<ol><li><p><strong>Storage Type Awareness</strong>: Contiguous iteration only works with table storage. The system checks if a query is “dense” (using only table storage) before allowing contiguous iteration. Sparse set components cannot be iterated contiguously because they don’t store components in contiguous arrays.</p><li><p><strong>Change Detection at Scale</strong>: The <code>ContiguousComponentTicksMut</code> type manages change ticks for entire slices. It provides methods like <code>mark_all_as_changed()</code> that efficiently update all ticks in the slice, which is more efficient than updating ticks individually.</p><li><p><strong>Bypassing Change Detection</strong>: Like individual mutable references, <code>ContiguousMut</code> provides a <code>bypass_change_detection()</code> method that returns a mutable slice without updating change ticks. This is useful for performance when you know change detection isn’t needed.</p><li><p><strong>Zero-Cost Abstraction</strong>: When you use contiguous iteration with <code>&T</code>, the implementation returns a direct slice reference <code>&[T]</code> with no wrapper type. This means there’s zero overhead compared to manually accessing the underlying storage.</p><li><p><strong>Filter Constraints</strong>: The requirement for <code>ArchetypeFilter</code> ensures that filters can be evaluated at table granularity. This is a compile-time guarantee that prevents using filters that would require per-entity checks.</p></ol><h3 id=the-impact>The Impact</h3><p>The benchmarks show significant performance improvements:<ul><li><strong>Standard contiguous iteration</strong>: ~12.5% faster than regular iteration (4.88 µs vs 5.58 µs)<li><strong>AVX2-optimized contiguous iteration</strong>: ~66% faster than regular iteration (1.87 µs vs 5.51 µs)<li><strong>Contiguous without change detection</strong>: ~21% faster than regular iteration without change detection (4.40 µs vs 4.81 µs)</ul><p>The performance gains come from several factors:<ol><li>Reduced iteration overhead (processing tables instead of entities)<li>Better cache locality when operating on contiguous memory<li>Enabling compiler auto-vectorization<li>Explicit SIMD optimizations (like the AVX2 example)</ol><p>Beyond performance, this feature enables new patterns in Bevy systems. Developers can now write algorithms that process components in batches, which is particularly useful for:<ul><li>Mathematical operations on large datasets<li>Physics simulations<li>Particle systems<li>Any system where the same operation applies to many entities</ul><p>The implementation maintains full backward compatibility—existing queries continue to work unchanged. Developers can opt into contiguous iteration where it makes sense for their performance requirements.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Query] --> B{Is dense?}
</span><span>    B -->|No| C[Regular iteration]
</span><span>    B -->|Yes| D[Contiguous iteration]
</span><span>    D --> E[Table 1]
</span><span>    D --> F[Table 2]
</span><span>    D --> G[Table N]
</span><span>    E --> H[&[T] slice]
</span><span>    F --> I[ContiguousMut&LTT>]
</span><span>    G --> J[Other contiguous types]
</span><span>    H --> K[Auto-vectorization possible]
</span><span>    I --> K
</span><span>    J --> K
</span><span>    C --> L[Entity-by-entity]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><p><strong><code>crates/bevy_ecs/src/change_detection/params.rs</code> (+705/-1)</strong></p> <ul><li>Added new types: <code>ContiguousComponentTicksRef</code>, <code>ContiguousComponentTicksMut</code>, <code>ContiguousRef</code>, <code>ContiguousMut</code><li>These types provide slice-based access to component values and their change ticks<li>Key addition: <code>ContiguousMut</code> which combines a mutable slice with change detection</ul><li><p><strong><code>crates/bevy_ecs/src/query/fetch.rs</code> (+467/-9)</strong></p> <ul><li>Added <code>ContiguousQueryData</code> trait definition<li>Implemented <code>ContiguousQueryData</code> for common query types: <code>&T</code>, <code>&mut T</code>, <code>Entity</code>, <code>Ref&LTT></code>, <code>Mut&LTT></code>, <code>Option&LTT></code>, <code>Has&LTT></code>, tuples, and <code>AnyOf</code><li>Added comprehensive tests for contiguous query functionality</ul><li><p><strong><code>crates/bevy_ecs/macros/src/query_data.rs</code> (+204/-3)</strong></p> <ul><li>Extended the <code>QueryData</code> derive macro to support <code>#[query_data(contiguous(target))]</code> attribute<li>Generates additional types for contiguous iteration: <code>XContiguousItem</code> and <code>XReadOnlyContiguousItem</code><li>Supports targets: <code>all</code>, <code>mutable</code>, <code>immutable</code></ul><li><p><strong><code>crates/bevy_ecs/src/system/query.rs</code> (+100/-2)</strong></p> <ul><li>Added new methods to <code>Query</code>: <code>contiguous_iter()</code>, <code>contiguous_iter_mut()</code>, <code>contiguous_iter_inner()</code><li>These methods return <code>Option&LTQueryContiguousIter></code> (None if query isn’t dense)</ul><li><p><strong><code>crates/bevy_ecs/src/query/iter.rs</code> (+92/-2)</strong></p> <ul><li>Added <code>QueryContiguousIter</code> struct for iterating over tables contiguously<li>Implemented <code>Iterator</code> for <code>QueryContiguousIter</code> that yields contiguous chunks</ul></ol><p>Example of the key change in <code>fetch.rs</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTT</span><span style=color:#61676ccc>:</span><span> Component> ContiguousQueryData </span><span style=color:#fa6e32>for </span><span style=color:#ed9366>&</span><span style=color:#399ee6>T </span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Contiguous</span><span style=color:#ed9366><</span><span style=color:#fa6e32>'w</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>'s</span><span style=color:#ed9366>> = &</span><span style=color:#fa6e32>'w </span><span>[T]</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>fetch_contiguous</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>>(
</span><span>        </span><span style=color:#ff8f40>_state</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'s Self</span><span style=color:#ed9366>::</span><span>State,
</span><span>        </span><span style=color:#ff8f40>fetch</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>Fetch<</span><span style=color:#fa6e32>'w</span><span>>,
</span><span>        </span><span style=color:#ff8f40>entities</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'w</span><span> [Entity],
</span><span>    ) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Contiguous<</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> {
</span><span>        fetch</span><span style=color:#ed9366>.</span><span>components</span><span style=color:#ed9366>.</span><span style=color:#f07171>extract</span><span>(
</span><span>            |</span><span style=color:#ff8f40>table</span><span>| {
</span><span>                </span><span style=color:#abb0b6;font-style:italic>// SAFETY: The caller ensures `set_table` was previously called
</span><span>                </span><span style=color:#fa6e32>let</span><span> table </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ table</span><span style=color:#ed9366>.</span><span style=color:#f07171>debug_checked_unwrap</span><span>() }</span><span style=color:#61676ccc>;
</span><span>                </span><span style=color:#abb0b6;font-style:italic>// SAFETY: `table` is `entities.len()` long
</span><span>                </span><span style=color:#fa6e32>unsafe </span><span>{ table</span><span style=color:#ed9366>.</span><span style=color:#f07171>cast</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_slice_unchecked</span><span>(entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()) }
</span><span>            }</span><span style=color:#61676ccc>,
</span><span>            |_| {
</span><span>                </span><span style=color:#abb0b6;font-style:italic>// Sparse set case - unreachable for dense queries
</span><span>                core</span><span style=color:#ed9366>::</span><span>hint</span><span style=color:#ed9366>::</span><span>unreachable_unchecked()</span><span style=color:#61676ccc>;
</span><span>            }</span><span style=color:#61676ccc>,
</span><span>        )
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy ECS Documentation</strong>: https://bevyengine.org/learn/book/ecs/<li><strong>SIMD Programming Guide</strong>: https://doc.rust-lang.org/std/simd/index.html<li><strong>Data-Oriented Design Resources</strong>: https://github.com/dbartolini/data-oriented-design<li><strong>Change Detection in Bevy</strong>: https://bevyengine.org/learn/book/change-detection/<li><strong>Rust Performance Book</strong>: https://nnethercote.github.io/perf-book/</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_21984.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>