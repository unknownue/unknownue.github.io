<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23074 `testbed_2d` texture atlas builder scene
        
    </title><meta content="#23074 `testbed_2d` texture atlas builder scene" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-24</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-23074-en-20260224>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><p><code>testbed_2d</code> texture atlas builder scene<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: <code>testbed_2d</code> texture atlas builder scene<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/23074<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Examples, C-Testing, D-Straightforward, S-Ready-For-Final-Review<li><strong>Created</strong>: 2026-02-20T11:17:30Z<li><strong>Merged</strong>: 2026-02-24T01:58:40Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>添加一个展示<code>TextureAtlasBuilder</code>输出的场景。<h2 id=jie-jue-fang-an>解决方案</h2><p>添加一个展示纹理图集纹理及其填充(padding)的场景，展示绘制子图像时如何影响它们。<h2 id=ce-shi>测试</h2><pre style=color:#61676c;background-color:#fafafa><code><span>cargo run --example testbed_2d -- textureatlasbuilder
</span></code></pre><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个PR为Bevy的<code>testbed_2d</code>示例添加了一个新的场景，专门用于演示<code>TextureAtlasBuilder</code>的功能。<code>TextureAtlasBuilder</code>是Bevy中一个用于将多个小纹理组合成单个大纹理的工具，这对于优化渲染性能至关重要，因为它减少了渲染调用次数。<p><strong>问题与背景</strong>： 在实际的2D游戏开发中，处理大量小纹理时，如果每个纹理都单独提交渲染，会造成大量的GPU状态切换和绘制调用。纹理图集(texture atlas)技术通过将多个小纹理打包到一个大纹理中来解决这个问题。Bevy的<code>TextureAtlasBuilder</code>提供了自动化的图集构建功能，但开发者需要一个直观的方式来理解其行为，特别是填充(padding)对最终结果的影响。<p><strong>解决方案方法</strong>： 开发者选择在现有的<code>testbed_2d</code>示例中添加一个新的场景。这个选择是合理的，因为<code>testbed_2d</code>已经是一个展示各种2D功能的示例应用，添加新的场景可以保持代码组织的一致性。新场景需要直观展示有填充和无填充两种情况下的图集效果。<p><strong>实现细节</strong>： 新增的<code>texture_atlas_builder</code>模块创建了两个图集进行对比：一个没有填充(padding)，另一个有2像素的填充。每个图集包含四个28×28像素的纯色图像（红、绿、蓝、黄）。图集总大小为64×64像素，这意味着四个28×28的图像（每个784像素）加上填充后能够刚好适应64×64（4096像素）的空间。<p>关键的技术细节在于填充是如何工作的：<ul><li>没有填充时，图像在图集中紧密排列<li>有填充时，图像之间会有间隔，这可以防止纹理采样时出现边缘混合(bleeding)问题</ul><p>代码展示了如何正确使用<code>TextureAtlasBuilder</code> API：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let mut</span><span> texture_atlas_builder </span><span style=color:#ed9366>= </span><span>TextureAtlasBuilder</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>texture_atlas_builder
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>initial_size</span><span>(</span><span style=color:#ff8f40>ATLAS_SIZE</span><span>)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max_size</span><span>(</span><span style=color:#ff8f40>ATLAS_SIZE</span><span>)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>padding</span><span>(padding)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>for</span><span> image </span><span style=color:#ed9366>in &</span><span>images {
</span><span>    texture_atlas_builder</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_texture</span><span>(</span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,</span><span> image)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>构建完成后，代码创建了两个版本的图集纹理：一个使用线性采样（默认），另一个使用最近邻采样。最近邻采样版本用于显示放大的图集，保持像素化外观，便于开发者观察细节。<p><strong>技术洞察</strong>： 这个实现展示了几个重要的概念：<ol><li><strong>纹理图集构建流程</strong>：如何从多个独立图像构建图集<li><strong>填充的重要性</strong>：填充防止了纹理边缘混合，这在旋转、缩放或使用特定纹理过滤时特别重要<li><strong>纹理采样模式</strong>：不同采样模式对最终渲染效果的影响<li><strong>锚点系统</strong>：Bevy的锚点系统如何与图集配合工作</ol><p>场景中还使用了<code>ShowAabbGizmo</code>来显示图集的边界框，这提供了额外的视觉参考。<p><strong>影响</strong>： 这个示例场景为Bevy开发者提供了一个重要的学习工具。通过可视化对比，开发者可以更容易地理解：<ul><li>填充如何影响图集布局<li>图集中的子图像如何被访问和使用<li>不同的纹理采样模式如何影响最终渲染</ul><p>这对于优化2D游戏性能至关重要，因为正确的图集使用可以显著减少绘制调用数量。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[testbed_2d主程序] --> B[场景枚举 Scene]
</span><span>    B --> C[TextureAtlasBuilder场景]
</span><span>    C --> D[texture_atlas_builder模块]
</span><span>    D --> E[setup函数]
</span><span>    E --> F[创建无填充图集]
</span><span>    E --> G[创建有填充图集]
</span><span>    F --> H[生成纯色图像]
</span><span>    F --> I[使用TextureAtlasBuilder]
</span><span>    G --> H
</span><span>    G --> I
</span><span>    I --> J[输出纹理和布局]
</span><span>    J --> K[渲染对比显示]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=examples-testbed-2d-rs-119-1><code>examples/testbed/2d.rs</code> (+119/-1)</h3><p>这是唯一的修改文件，添加了一个新的场景到现有的<code>testbed_2d</code>示例中。<p><strong>主要修改：</strong><ol><li><strong>场景枚举扩展</strong>：在<code>Scene</code>枚举中添加了<code>TextureAtlasBuilder</code>变体<li><strong>场景切换逻辑更新</strong>：更新了<code>Next</code> trait的实现，将新场景加入循环<li><strong>系统注册</strong>：在main函数中注册新场景的setup系统<li><strong>新模块实现</strong>：添加了<code>texture_atlas_builder</code>模块及其<code>setup</code>函数</ol><p><strong>代码示例：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 在Scene枚举中添加新变体
</span><span style=color:#fa6e32>enum </span><span style=color:#399ee6>Scene </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 其他变体
</span><span>    TextureAtlasBuilder</span><span style=color:#61676ccc>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 更新场景切换逻辑
</span><span style=color:#fa6e32>impl </span><span>Next </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Scene </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>next</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#fa6e32>match </span><span style=color:#55b4d4;font-style:italic>self </span><span>{
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// ... 其他匹配
</span><span>            Scene</span><span style=color:#ed9366>::</span><span>Gizmos </span><span style=color:#ed9366>=> </span><span>Scene</span><span style=color:#ed9366>::</span><span>TextureAtlasBuilder</span><span style=color:#61676ccc>,
</span><span>            Scene</span><span style=color:#ed9366>::</span><span>TextureAtlasBuilder </span><span style=color:#ed9366>=> </span><span>Scene</span><span style=color:#ed9366>::</span><span>Shapes</span><span style=color:#61676ccc>,
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在main函数中注册系统
</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>    OnEnter(Scene</span><span style=color:#ed9366>::</span><span>TextureAtlasBuilder)</span><span style=color:#61676ccc>,
</span><span>    texture_atlas_builder</span><span style=color:#ed9366>::</span><span>setup</span><span style=color:#61676ccc>,
</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 新模块的实现
</span><span style=color:#fa6e32>mod </span><span style=color:#399ee6>texture_atlas_builder </span><span>{
</span><span>    </span><span style=color:#fa6e32>use </span><span>bevy</span><span style=color:#ed9366>::</span><span>{
</span><span>        asset</span><span style=color:#ed9366>::</span><span>RenderAssetUsages</span><span style=color:#61676ccc>,
</span><span>        image</span><span style=color:#ed9366>::</span><span>ImageSampler</span><span style=color:#61676ccc>,
</span><span>        prelude</span><span style=color:#ed9366>::*</span><span style=color:#61676ccc>,
</span><span>        render</span><span style=color:#ed9366>::</span><span>render_resource</span><span style=color:#ed9366>::</span><span>{Extent3d</span><span style=color:#61676ccc>,</span><span> TextureDimension</span><span style=color:#61676ccc>,</span><span> TextureFormat}</span><span style=color:#61676ccc>,
</span><span>        sprite</span><span style=color:#ed9366>::</span><span>Anchor</span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 常量定义
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ATLAS_SIZE</span><span style=color:#61676ccc>:</span><span> UVec2 </span><span style=color:#ed9366>= </span><span>UVec2</span><span style=color:#ed9366>::</span><span>splat(</span><span style=color:#ff8f40>64</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>IMAGE_SIZE</span><span style=color:#61676ccc>:</span><span> UVec2 </span><span style=color:#ed9366>= </span><span>UVec2</span><span style=color:#ed9366>::</span><span>splat(</span><span style=color:#ff8f40>28</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>PADDING_SIZE</span><span style=color:#61676ccc>:</span><span> UVec2 </span><span style=color:#ed9366>= </span><span>UVec2</span><span style=color:#ed9366>::</span><span>splat(</span><span style=color:#ff8f40>2</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ATLAS_SCALE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4.</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>IMAGE_SCALE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4.</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>setup</span><span>(
</span><span>        </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>        </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>textures</span><span style=color:#61676ccc>: </span><span>ResMut&LTAssets&LTImage>>,
</span><span>        </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>texture_atlases</span><span style=color:#61676ccc>: </span><span>ResMut&LTAssets&LTTextureAtlasLayout>>,
</span><span>    ) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... 实现细节
</span><span>    }
</span><span>}
</span></code></pre><p>这些修改与PR的整体目标完全一致：创建一个展示<code>TextureAtlasBuilder</code>功能的场景，帮助开发者理解图集构建和填充的效果。<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy官方文档 - TextureAtlasBuilder</strong>: 了解API的详细使用方法<li><strong>纹理图集最佳实践</strong>: 学习游戏开发中纹理打包的最佳实践<li><strong>GPU渲染优化</strong>: 理解纹理图集如何减少绘制调用并提高性能<li><strong>纹理采样和过滤</strong>: 深入了解不同采样模式（如最近邻vs双线性）的影响<li><strong>Bevy的ECS架构</strong>: 理解示例中使用的Commands、Resources和组件系统</ol><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/examples/testbed/2d.rs b/examples/testbed/2d.rs
</span><span>index 9f1ca518b26b1..1247ee07e0ac9 100644
</span><span style=color:#c594c5>--- a/examples/testbed/2d.rs
</span><span style=color:#c594c5>+++ b/examples/testbed/2d.rs
</span><span style=color:#c594c5>@@ -30,6 +30,10 @@ </span><span style=color:#399ee6>fn main() {
</span><span>         .add_systems(OnEnter(Scene::Sprite), sprite::setup)
</span><span>         .add_systems(OnEnter(Scene::SpriteSlicing), sprite_slicing::setup)
</span><span>         .add_systems(OnEnter(Scene::Gizmos), gizmos::setup)
</span><span style=color:#86b300>+        .add_systems(
</span><span style=color:#86b300>+            OnEnter(Scene::TextureAtlasBuilder),
</span><span style=color:#86b300>+            texture_atlas_builder::setup,
</span><span style=color:#86b300>+        )
</span><span>         .add_systems(Update, switch_scene)
</span><span>         .add_systems(Update, gizmos::draw_gizmos.run_if(in_state(Scene::Gizmos)));
</span><span> 
</span><span style=color:#c594c5>@@ -53,6 +57,7 @@ </span><span style=color:#399ee6>enum Scene {
</span><span>     Sprite,
</span><span>     SpriteSlicing,
</span><span>     Gizmos,
</span><span style=color:#86b300>+    TextureAtlasBuilder,
</span><span> }
</span><span> 
</span><span> impl std::str::FromStr for Scene {
</span><span style=color:#c594c5>@@ -78,7 +83,8 @@ </span><span style=color:#399ee6>impl Next for Scene {
</span><span>             Scene::Text => Scene::Sprite,
</span><span>             Scene::Sprite => Scene::SpriteSlicing,
</span><span>             Scene::SpriteSlicing => Scene::Gizmos,
</span><span style=color:#f07171>-            Scene::Gizmos => Scene::Shapes,
</span><span style=color:#86b300>+            Scene::Gizmos => Scene::TextureAtlasBuilder,
</span><span style=color:#86b300>+            Scene::TextureAtlasBuilder => Scene::Shapes,
</span><span>         }
</span><span>     }
</span><span> }
</span><span style=color:#c594c5>@@ -422,3 +428,115 @@ </span><span style=color:#399ee6>mod gizmos {
</span><span>         }
</span><span>     }
</span><span> }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+mod texture_atlas_builder {
</span><span style=color:#86b300>+    use bevy::{
</span><span style=color:#86b300>+        asset::RenderAssetUsages,
</span><span style=color:#86b300>+        image::ImageSampler,
</span><span style=color:#86b300>+        prelude::*,
</span><span style=color:#86b300>+        render::render_resource::{Extent3d, TextureDimension, TextureFormat},
</span><span style=color:#86b300>+        sprite::Anchor,
</span><span style=color:#86b300>+    };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    const ATLAS_SIZE: UVec2 = UVec2::splat(64);
</span><span style=color:#86b300>+    const IMAGE_SIZE: UVec2 = UVec2::splat(28);
</span><span style=color:#86b300>+    const PADDING_SIZE: UVec2 = UVec2::splat(2);
</span><span style=color:#86b300>+    const ATLAS_SCALE: f32 = 4.;
</span><span style=color:#86b300>+    const IMAGE_SCALE: f32 = 4.;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    pub fn setup(
</span><span style=color:#86b300>+        mut commands: Commands,
</span><span style=color:#86b300>+        mut textures: ResMut&LTAssets&LTImage>>,
</span><span style=color:#86b300>+        mut texture_atlases: ResMut&LTAssets&LTTextureAtlasLayout>>,
</span><span style=color:#86b300>+    ) {
</span><span style=color:#86b300>+        commands.spawn((Camera2d, DespawnOnExit(super::Scene::TextureAtlasBuilder)));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        for (i, padding) in [UVec2::ZERO, PADDING_SIZE].into_iter().enumerate() {
</span><span style=color:#86b300>+            // generate solid red green and blue and yellow images
</span><span style=color:#86b300>+            let images = [
</span><span style=color:#86b300>+                [255, 0, 0, 255],
</span><span style=color:#86b300>+                [0, 255, 0, 255],
</span><span style=color:#86b300>+                [0, 0, 255, 255],
</span><span style=color:#86b300>+                [255, 255, 0, 255],
</span><span style=color:#86b300>+            ]
</span><span style=color:#86b300>+            .map(|pixel| {
</span><span style=color:#86b300>+                Image::new_fill(
</span><span style=color:#86b300>+                    Extent3d {
</span><span style=color:#86b300>+                        width: 28,
</span><span style=color:#86b300>+                        height: 28,
</span><span style=color:#86b300>+                        depth_or_array_layers: 1,
</span><span style=color:#86b300>+                    },
</span><span style=color:#86b300>+                    TextureDimension::D2,
</span><span style=color:#86b300>+                    &pixel,
</span><span style=color:#86b300>+                    TextureFormat::Rgba8UnormSrgb,
</span><span style=color:#86b300>+                    RenderAssetUsages::MAIN_WORLD | RenderAssetUsages::RENDER_WORLD,
</span><span style=color:#86b300>+                )
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            let mut texture_atlas_builder = TextureAtlasBuilder::default();
</span><span style=color:#86b300>+            texture_atlas_builder
</span><span style=color:#86b300>+                .initial_size(ATLAS_SIZE)
</span><span style=color:#86b300>+                .max_size(ATLAS_SIZE)
</span><span style=color:#86b300>+                .padding(padding);
</span><span style=color:#86b300>+            for image in &images {
</span><span style=color:#86b300>+                texture_atlas_builder.add_texture(None, image);
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            let (atlas_layout, _, atlas_texture) = texture_atlas_builder.build().expect(
</span><span style=color:#86b300>+                "The images are 28 pixels square, so they should fit with 4 pixels left over",
</span><span style=color:#86b300>+            );
</span><span style=color:#86b300>+            let atlas_layout = texture_atlases.add(atlas_layout);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            let mut nearest_atlas_image = atlas_texture.clone();
</span><span style=color:#86b300>+            nearest_atlas_image.sampler = ImageSampler::nearest();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            let atlas_handle = textures.add(atlas_texture);
</span><span style=color:#86b300>+            let nearest_atlas_handle = textures.add(nearest_atlas_image);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            let position = ((2. * i as f32 - 1.) * (0.625 * ATLAS_SIZE.x as f32 * ATLAS_SCALE))
</span><span style=color:#86b300>+                .round()
</span><span style=color:#86b300>+                * Vec3::X;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            commands.spawn((
</span><span style=color:#86b300>+                Sprite {
</span><span style=color:#86b300>+                    image: nearest_atlas_handle,
</span><span style=color:#86b300>+                    custom_size: Some(ATLAS_SIZE.as_vec2() * ATLAS_SCALE),
</span><span style=color:#86b300>+                    ..default()
</span><span style=color:#86b300>+                },
</span><span style=color:#86b300>+                Anchor::BOTTOM_CENTER,
</span><span style=color:#86b300>+                ShowAabbGizmo::default(),
</span><span style=color:#86b300>+                DespawnOnExit(super::Scene::TextureAtlasBuilder),
</span><span style=color:#86b300>+                Transform::from_translation(position),
</span><span style=color:#86b300>+            ));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            for (index, anchor) in [
</span><span style=color:#86b300>+                Anchor::BOTTOM_RIGHT,
</span><span style=color:#86b300>+                Anchor::BOTTOM_LEFT,
</span><span style=color:#86b300>+                Anchor::TOP_LEFT,
</span><span style=color:#86b300>+                Anchor::TOP_RIGHT,
</span><span style=color:#86b300>+            ]
</span><span style=color:#86b300>+            .into_iter()
</span><span style=color:#86b300>+            .enumerate()
</span><span style=color:#86b300>+            {
</span><span style=color:#86b300>+                commands.spawn((
</span><span style=color:#86b300>+                    Sprite {
</span><span style=color:#86b300>+                        image: atlas_handle.clone(),
</span><span style=color:#86b300>+                        texture_atlas: Some(TextureAtlas {
</span><span style=color:#86b300>+                            layout: atlas_layout.clone(),
</span><span style=color:#86b300>+                            index,
</span><span style=color:#86b300>+                        }),
</span><span style=color:#86b300>+                        custom_size: Some(IMAGE_SIZE.as_vec2() * IMAGE_SCALE),
</span><span style=color:#86b300>+                        ..default()
</span><span style=color:#86b300>+                    },
</span><span style=color:#86b300>+                    Transform::from_translation(
</span><span style=color:#86b300>+                        position
</span><span style=color:#86b300>+                            + -2.
</span><span style=color:#86b300>+                                * IMAGE_SCALE
</span><span style=color:#86b300>+                                * (Vec3::Y * IMAGE_SIZE.y as f32 + anchor.as_vec().extend(0.)),
</span><span style=color:#86b300>+                    ),
</span><span style=color:#86b300>+                    anchor,
</span><span style=color:#86b300>+                ));
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23074.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>