diff --git a/Cargo.toml b/Cargo.toml
index d28f6fb2fbd31..879b296af38cf 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -33,6 +33,7 @@ members = [
   # Examples of large bevy scenes.
   "examples/large_scenes/bistro",
   "examples/large_scenes/caldera_hotel",
+  "examples/large_scenes/bevy_city",
   # Mipmap generator for testing large bevy scenes with mips and texture compression.
   "examples/large_scenes/mipmap_generator",
   # Benchmarks
diff --git a/examples/large_scenes/bevy_city/Cargo.toml b/examples/large_scenes/bevy_city/Cargo.toml
new file mode 100644
index 0000000000000..efdc1155e969e
--- /dev/null
+++ b/examples/large_scenes/bevy_city/Cargo.toml
@@ -0,0 +1,17 @@
+[package]
+name = "bevy_city"
+version = "0.1.0"
+edition = "2024"
+publish = false
+license = "MIT OR Apache-2.0"
+
+[dependencies]
+bevy = { path = "../../../", features = [
+  "https",
+  "free_camera",
+  "experimental_bevy_feathers",
+] }
+
+argh = "0.1"
+noise = "0.9.0"
+rand = "0.10.0"
diff --git a/examples/large_scenes/bevy_city/README.md b/examples/large_scenes/bevy_city/README.md
new file mode 100644
index 0000000000000..4b1d494d1ed54
--- /dev/null
+++ b/examples/large_scenes/bevy_city/README.md
@@ -0,0 +1,6 @@
+# bevy_city
+
+A procedurally generated city using assets from [kenney](https://kenney.nl)
+
+This project was inspired by <https://flecs-hub.github.io/traffic/etc/>.
+Currently it doesn't do any traffic simulation but the goal is to have a similar simulation but using bevy_ecs.
diff --git a/examples/large_scenes/bevy_city/src/assets.rs b/examples/large_scenes/bevy_city/src/assets.rs
new file mode 100644
index 0000000000000..1db9a7bb78f91
--- /dev/null
+++ b/examples/large_scenes/bevy_city/src/assets.rs
@@ -0,0 +1,233 @@
+use bevy::{color::palettes::css::WHITE, prelude::*};
+use rand::RngExt;
+
+#[derive(Resource)]
+pub struct CityAssets {
+    pub cars: Vec<Handle<Scene>>,
+    pub crossroad: Handle<Scene>,
+    pub road_straight: Handle<Scene>,
+    pub high_density: Buildings,
+    pub medium_density: Buildings,
+    pub low_density: Buildings,
+    pub ground_tile: (
+        Handle<Mesh>,
+        Handle<StandardMaterial>,
+        Handle<StandardMaterial>,
+    ),
+    pub tree_small: Handle<Scene>,
+    pub tree_large: Handle<Scene>,
+    pub path_stones_long: Handle<Scene>,
+    pub fence: Handle<Scene>,
+}
+
+impl CityAssets {
+    pub fn get_random_car<R: RngExt>(&self, rng: &mut R) -> Handle<Scene> {
+        self.cars[rng.random_range(0..self.cars.len())].clone()
+    }
+}
+
+pub struct Buildings {
+    meshes: Vec<Handle<Mesh>>,
+    materials: Vec<Handle<StandardMaterial>>,
+}
+
+impl Buildings {
+    pub fn get_random_building<R: RngExt>(
+        &self,
+        rng: &mut R,
+    ) -> (Mesh3d, MeshMaterial3d<StandardMaterial>) {
+        let mesh = self.meshes[rng.random_range(0..self.meshes.len())].clone();
+        let material = self.materials[rng.random_range(0..self.materials.len())].clone();
+        (Mesh3d(mesh), MeshMaterial3d(material))
+    }
+}
+
+pub fn load_assets(
+    mut commands: Commands,
+    asset_server: Res<AssetServer>,
+    mut materials: ResMut<Assets<StandardMaterial>>,
+) {
+    let base_url = "https://github.com/bevyengine/bevy_asset_files/raw/main/kenney";
+
+    let cars = {
+        // TODO generate color variations
+        [
+            "hatchback-sports",
+            "suv",
+            "suv-luxury",
+            "sedan",
+            "sedan-sports",
+            "truck",
+            "truck-flat",
+            "van",
+            "delivery",
+            "delivery-flat",
+            "taxi",
+            "garbage-truck",
+            "ambulance",
+            "police",
+            "firetruck",
+        ]
+        .iter()
+        .map(|t| {
+            asset_server
+                .load(GltfAssetLabel::Scene(0).from_asset(format!("{base_url}/car-kit/{t}.glb")))
+        })
+        .collect::<Vec<_>>()
+    };
+
+    let crossroad = asset_server.load(
+        GltfAssetLabel::Scene(0)
+            .from_asset(format!("{base_url}/city-kit-roads/road-crossroad-path.glb")),
+    );
+    let road_straight = asset_server.load(
+        GltfAssetLabel::Scene(0).from_asset(format!("{base_url}/city-kit-roads/road-straight.glb")),
+    );
+
+    let high_density = {
+        let materials = ["colormap", "variation-a", "variation-b"]
+            .iter()
+            .map(|variation| {
+                materials.add(StandardMaterial {
+                    base_color_texture: Some(asset_server.load(format!(
+                        "{base_url}/city-kit-commercial/Textures/{variation}.png"
+                    ))),
+                    ..Default::default()
+                })
+            })
+            .collect::<Vec<_>>();
+
+        let mut meshes = ["a", "b", "c", "d", "e"]
+            .iter()
+            .map(|t| {
+                asset_server.load(
+                    GltfAssetLabel::Primitive {
+                        mesh: 0,
+                        primitive: 0,
+                    }
+                    .from_asset(format!(
+                        "{base_url}/city-kit-commercial/building-skyscraper-{t}.glb"
+                    )),
+                )
+            })
+            .collect::<Vec<_>>();
+        meshes.extend(["m", "l"].iter().map(|t| {
+            asset_server.load(
+                GltfAssetLabel::Primitive {
+                    mesh: 0,
+                    primitive: 0,
+                }
+                .from_asset(format!("{base_url}/city-kit-commercial/building-{t}.glb")),
+            )
+        }));
+
+        Buildings { meshes, materials }
+    };
+
+    let medium_density = {
+        let materials = ["colormap", "variation-a", "variation-b"]
+            .iter()
+            .map(|variation| {
+                materials.add(StandardMaterial {
+                    base_color_texture: Some(asset_server.load(format!(
+                        "{base_url}/city-kit-commercial/Textures/{variation}.png"
+                    ))),
+                    ..Default::default()
+                })
+            })
+            .collect::<Vec<_>>();
+        let meshes = ["a", "b", "c", "d", "f", "g", "h"]
+            .iter()
+            .map(|t| {
+                asset_server.load(
+                    GltfAssetLabel::Primitive {
+                        mesh: 0,
+                        primitive: 0,
+                    }
+                    .from_asset(format!("{base_url}/city-kit-commercial/building-{t}.glb")),
+                )
+            })
+            .collect::<Vec<_>>();
+
+        Buildings { meshes, materials }
+    };
+    let low_density = {
+        let materials = ["colormap", "variation-a", "variation-b", "variation-c"]
+            .iter()
+            .map(|variation| {
+                materials.add(StandardMaterial {
+                    base_color_texture: Some(asset_server.load(format!(
+                        "{base_url}/city-kit-suburban/Textures/{variation}.png"
+                    ))),
+                    ..Default::default()
+                })
+            })
+            .collect::<Vec<_>>();
+        let meshes = ["b", "c", "d", "e", "f", "g", "h", "i", "k", "l", "o", "u"]
+            .iter()
+            .map(|t| {
+                asset_server.load(
+                    GltfAssetLabel::Primitive {
+                        mesh: 0,
+                        primitive: 0,
+                    }
+                    .from_asset(format!(
+                        "{base_url}/city-kit-suburban/building-type-{t}.glb"
+                    )),
+                )
+            })
+            .collect::<Vec<_>>();
+
+        Buildings { meshes, materials }
+    };
+
+    let ground_tile = {
+        let mesh = asset_server.load(
+            GltfAssetLabel::Primitive {
+                mesh: 0,
+                primitive: 0,
+            }
+            .from_asset(format!("{base_url}/city-kit-roads/tile-low.glb")),
+        );
+        // TODO use this once https://github.com/bevyengine/bevy/pull/22943 is merged
+        // let default_material: Handle<StandardMaterial> = asset_server.load(format!(
+        //     "ground_tile/tile-low.glb#{}/std",
+        //     GltfAssetLabel::DefaultMaterial
+        // ));
+        let white_material = materials.add(StandardMaterial::from_color(WHITE));
+        let grass_material =
+            materials.add(StandardMaterial::from_color(Color::srgb_u8(97, 203, 139)));
+
+        (mesh, white_material, grass_material)
+    };
+
+    let tree_small: Handle<Scene> = asset_server.load(
+        GltfAssetLabel::Scene(0).from_asset(format!("{base_url}/city-kit-suburban/tree-small.glb")),
+    );
+    let tree_large: Handle<Scene> = asset_server.load(
+        GltfAssetLabel::Scene(0).from_asset(format!("{base_url}/city-kit-suburban/tree-large.glb")),
+    );
+
+    let path_stones_long: Handle<Scene> = asset_server.load(
+        GltfAssetLabel::Scene(0)
+            .from_asset(format!("{base_url}/city-kit-suburban/path-stones-long.glb")),
+    );
+
+    let fence: Handle<Scene> = asset_server.load(
+        GltfAssetLabel::Scene(0).from_asset(format!("{base_url}/city-kit-suburban/fence.glb")),
+    );
+
+    commands.insert_resource(CityAssets {
+        cars,
+        crossroad,
+        road_straight,
+        high_density,
+        medium_density,
+        low_density,
+        ground_tile,
+        tree_small,
+        tree_large,
+        path_stones_long,
+        fence,
+    });
+}
diff --git a/examples/large_scenes/bevy_city/src/generate_city.rs b/examples/large_scenes/bevy_city/src/generate_city.rs
new file mode 100644
index 0000000000000..46aa5594e4cc8
--- /dev/null
+++ b/examples/large_scenes/bevy_city/src/generate_city.rs
@@ -0,0 +1,351 @@
+use bevy::prelude::*;
+use noise::{NoiseFn, OpenSimplex};
+use rand::{rngs::SmallRng, RngExt, SeedableRng};
+
+use crate::{assets::CityAssets, Car, Road};
+
+#[derive(Component)]
+pub struct CityRoot;
+
+/// Spawns a grid of city blocks
+///
+/// For simplicity we spawn the roads and buildings in this pattern
+///
+/// X-------
+/// | B B B
+/// | B B B
+///
+/// X = crossroad, B = buildings
+///
+/// This way we can easily tile each city block
+/// Each city block is 5.5 units x 4.0 units.
+///
+/// Every asset gets spawned relative to the crossroad position
+pub fn spawn_city(commands: &mut Commands, assets: &CityAssets, seed: u64, size: u32) {
+    let mut rng = SmallRng::seed_from_u64(seed);
+    let noise = OpenSimplex::new(rng.random());
+    let noise_scale = 0.025;
+
+    commands
+        .spawn((CityRoot, Transform::default(), Visibility::default()))
+        .with_children(|commands| {
+            let half_size = size as i32 / 2;
+            for x in -half_size..half_size {
+                for z in -half_size..half_size {
+                    // scale the position to match the city block size
+                    let x = x as f32 * 5.5;
+                    let z = z as f32 * 4.0;
+                    let offset = Vec3::new(x, 0.0, z);
+
+                    spawn_roads_and_cars(commands, assets, &mut rng, offset);
+
+                    let density = noise.get([
+                        offset.x as f64 * noise_scale,
+                        offset.z as f64 * noise_scale,
+                        0.0,
+                    ]) * 0.5
+                        + 0.5;
+
+                    let forest = 0.45;
+                    let low_density = 0.6;
+                    let medium_density = 0.7;
+
+                    let ground_tile_scale = Vec3::new(4.5, 1.0, 3.0);
+                    commands.spawn((
+                        Mesh3d(assets.ground_tile.0.clone()),
+                        if density < low_density {
+                            MeshMaterial3d(assets.ground_tile.2.clone())
+                        } else {
+                            MeshMaterial3d(assets.ground_tile.1.clone())
+                        },
+                        Transform::from_translation(
+                            Vec3::new(0.5, -0.5005, 0.5) + ground_tile_scale / 2.0 + offset,
+                        )
+                        .with_scale(ground_tile_scale),
+                    ));
+
+                    if density < forest {
+                        spawn_forest(commands, assets, &mut rng, offset);
+                    } else if density < low_density {
+                        spawn_low_density(commands, assets, &mut rng, offset);
+                    } else if density < medium_density {
+                        spawn_medium_density(commands, assets, &mut rng, offset);
+                    } else {
+                        spawn_high_density(commands, assets, &mut rng, offset);
+                    }
+                }
+            }
+        });
+}
+
+fn spawn_roads_and_cars<R: RngExt>(
+    commands: &mut ChildSpawnerCommands,
+    assets: &CityAssets,
+    rng: &mut R,
+    offset: Vec3,
+) {
+    let x = offset.x;
+    let z = offset.z;
+
+    commands.spawn((
+        SceneRoot(assets.crossroad.clone()),
+        Transform::from_xyz(x, 0.0, z),
+    ));
+
+    let max_car_density = 0.4;
+
+    // When spawning roads we rotate and stretch a single road asset instead of spawning multiple
+    // road segments
+
+    // NOTE most of the magic numbers were hand tweaked for something that looks visually nice
+
+    // horizontal road
+    let car_count = 9;
+    commands
+        .spawn((
+            Transform::from_translation(offset),
+            Visibility::default(),
+            Road {
+                start: Vec3::new(0.75, 0.0, 0.0),
+                end: Vec3::new(0.75 + (0.5 * car_count as f32), 0.0, 0.0),
+            },
+        ))
+        .with_children(|commands| {
+            commands.spawn((
+                SceneRoot(assets.road_straight.clone()),
+                Transform::from_translation(Vec3::new(2.75, 0.0, 0.0))
+                    .with_scale(Vec3::new(4.5, 1.0, 1.0)),
+            ));
+
+            for i in 0..car_count {
+                let car_pos = Vec3::new(0.0, 0.0, 0.75 + i as f32 * 0.5);
+
+                if rng.random::<f32>() < max_car_density {
+                    commands.spawn((
+                        SceneRoot(assets.get_random_car(rng)),
+                        Transform::from_translation(car_pos + Vec3::new(0.0, 0.0, -0.15))
+                            .with_scale(Vec3::splat(0.15))
+                            .with_rotation(Quat::from_axis_angle(
+                                Vec3::Y,
+                                3.0 * std::f32::consts::FRAC_PI_2,
+                            )),
+                        Car {
+                            distance_traveled: i as f32 * 0.5,
+                            dir: -1.0,
+                            offset: Vec3::new(4.25, 0.0, -0.15),
+                        },
+                    ));
+                }
+
+                if rng.random::<f32>() < max_car_density {
+                    commands.spawn((
+                        SceneRoot(assets.get_random_car(rng)),
+                        Transform::from_translation(car_pos + Vec3::new(0.0, 0.0, 0.15))
+                            .with_scale(Vec3::splat(0.15))
+                            .with_rotation(Quat::from_axis_angle(
+                                Vec3::Y,
+                                std::f32::consts::FRAC_PI_2,
+                            )),
+                        Car {
+                            distance_traveled: i as f32 * 0.5,
+                            dir: 1.0,
+                            offset: Vec3::new(-0.25, 0.0, 0.15),
+                        },
+                    ));
+                }
+            }
+        });
+
+    // vertical road
+    let car_count = 6;
+    commands
+        .spawn((
+            Transform::from_translation(offset),
+            Visibility::default(),
+            Road {
+                start: Vec3::new(0.0, 0.0, 0.75),
+                end: Vec3::new(0.0, 0.0, 0.75 + (0.5 * car_count as f32)),
+            },
+        ))
+        .with_children(|commands| {
+            commands.spawn((
+                SceneRoot(assets.road_straight.clone()),
+                Transform::from_translation(Vec3::new(0.0, 0.0, 2.0))
+                    .with_scale(Vec3::new(3.0, 1.0, 1.0))
+                    .with_rotation(Quat::from_axis_angle(Vec3::Y, std::f32::consts::FRAC_PI_2)),
+            ));
+
+            for i in 0..car_count {
+                let car_pos = Vec3::new(0.0, 0.0, 0.75 + i as f32 * 0.5);
+
+                if rng.random::<f32>() < max_car_density {
+                    commands.spawn((
+                        SceneRoot(assets.get_random_car(rng)),
+                        Transform::from_translation(car_pos + Vec3::new(0.15, 0.0, 0.0))
+                            .with_scale(Vec3::splat(0.15)),
+                        Car {
+                            distance_traveled: i as f32 * 0.5,
+                            dir: 1.0,
+                            offset: Vec3::new(-0.15, 0.0, -0.25),
+                        },
+                    ));
+                }
+
+                if rng.random::<f32>() < max_car_density {
+                    commands.spawn((
+                        SceneRoot(assets.get_random_car(rng)),
+                        Transform::from_translation(car_pos + Vec3::new(-0.15, 0.0, 0.0))
+                            .with_scale(Vec3::splat(0.15))
+                            .with_rotation(Quat::from_axis_angle(Vec3::Y, std::f32::consts::PI)),
+                        Car {
+                            distance_traveled: i as f32 * 0.5,
+                            dir: -1.0,
+                            offset: Vec3::new(0.15, 0.0, 2.75),
+                        },
+                    ));
+                }
+            }
+        });
+}
+
+fn spawn_low_density<R: RngExt>(
+    commands: &mut ChildSpawnerCommands,
+    assets: &CityAssets,
+    rng: &mut R,
+    offset: Vec3,
+) {
+    for x in 1..=2 {
+        let x_factor = 1.8;
+        commands.spawn((
+            assets.low_density.get_random_building(rng),
+            Transform::from_translation(Vec3::new(x as f32 * x_factor, 0.0, 1.25) + offset),
+        ));
+        commands.spawn((
+            assets.low_density.get_random_building(rng),
+            Transform::from_translation(Vec3::new(x as f32 * x_factor, 0.0, 2.75) + offset)
+                .with_rotation(Quat::from_axis_angle(Vec3::Y, std::f32::consts::PI)),
+        ));
+    }
+    for i in 0..=6 {
+        commands.spawn((
+            SceneRoot(assets.fence.clone()),
+            Transform::from_translation(Vec3::new(2.75, 0.0, 0.75 + i as f32 * 0.4) + offset)
+                .with_rotation(Quat::from_axis_angle(Vec3::Y, std::f32::consts::FRAC_PI_2)),
+        ));
+    }
+    for z in 0..=8 {
+        commands.spawn((
+            SceneRoot(assets.tree_small.clone()),
+            Transform::from_translation(Vec3::new(0.75, 0.0, 0.75 + z as f32 * 0.3) + offset),
+        ));
+        commands.spawn((
+            SceneRoot(assets.tree_small.clone()),
+            Transform::from_translation(Vec3::new(4.75, 0.0, 0.75 + z as f32 * 0.3) + offset),
+        ));
+    }
+}
+
+fn spawn_medium_density<R: RngExt>(
+    commands: &mut ChildSpawnerCommands,
+    assets: &CityAssets,
+    rng: &mut R,
+    offset: Vec3,
+) {
+    let x_factor = 0.9;
+    for x in 1..=5 {
+        commands.spawn((
+            assets.medium_density.get_random_building(rng),
+            Transform::from_translation(Vec3::new(x as f32 * x_factor, 0.0, 1.0) + offset),
+        ));
+
+        for tree_x in 0..=1 {
+            let tree_x = tree_x as f32 * 0.5;
+            if x == 5 && tree_x == 0.5 {
+                break;
+            }
+            commands.spawn((
+                SceneRoot(assets.tree_large.clone()),
+                Transform::from_translation(
+                    Vec3::new(tree_x + x as f32 * x_factor, 0.0, 1.75) + offset,
+                ),
+            ));
+            commands.spawn((
+                SceneRoot(assets.tree_large.clone()),
+                Transform::from_translation(
+                    Vec3::new(tree_x + x as f32 * x_factor, 0.0, 2.25) + offset,
+                ),
+            ));
+        }
+
+        commands.spawn((
+            assets.medium_density.get_random_building(rng),
+            Transform::from_translation(Vec3::new(x as f32 * x_factor, 0.0, 3.0) + offset)
+                .with_rotation(Quat::from_axis_angle(Vec3::Y, std::f32::consts::PI)),
+        ));
+    }
+
+    for x in 0..=10 {
+        commands.spawn((
+            SceneRoot(assets.path_stones_long.clone()),
+            Transform::from_translation(Vec3::new(0.75 + (x as f32 * 0.4), 0.02, 2.0) + offset)
+                .with_scale(Vec3::new(1.0, 2.0, 1.0))
+                .with_rotation(Quat::from_axis_angle(Vec3::Y, std::f32::consts::FRAC_PI_2)),
+        ));
+        commands.spawn((
+            SceneRoot(assets.fence.clone()),
+            Transform::from_translation(Vec3::new(0.75 + (x as f32 * 0.4), 0.02, 1.85) + offset),
+        ));
+        commands.spawn((
+            SceneRoot(assets.fence.clone()),
+            Transform::from_translation(Vec3::new(0.75 + (x as f32 * 0.4), 0.02, 2.15) + offset),
+        ));
+    }
+}
+
+fn spawn_high_density<R: RngExt>(
+    commands: &mut ChildSpawnerCommands,
+    assets: &CityAssets,
+    rng: &mut R,
+    offset: Vec3,
+) {
+    for x in 0..3 {
+        let x = x as f32;
+        commands.spawn((
+            assets.high_density.get_random_building(rng),
+            Transform::from_translation(Vec3::new(1.25 + x * 1.5, 0.0, 1.25) + offset),
+        ));
+        commands.spawn((
+            assets.high_density.get_random_building(rng),
+            Transform::from_translation(Vec3::new(1.25 + x * 1.5, 0.0, 2.75) + offset)
+                .with_rotation(Quat::from_axis_angle(Vec3::Y, std::f32::consts::PI)),
+        ));
+    }
+}
+
+fn spawn_forest<R: RngExt>(
+    commands: &mut ChildSpawnerCommands,
+    assets: &CityAssets,
+    rng: &mut R,
+    offset: Vec3,
+) {
+    for x in 0..=12 {
+        for z in 0..=8 {
+            let transform = Transform::from_translation(
+                Vec3::new(x as f32, 0.0, z as f32) * Vec3::new(0.325, 0.0, 0.3)
+                    + Vec3::new(0.75, 0.0, 0.85)
+                    + offset,
+            );
+
+            match rng.random_range(0..3) {
+                0 => {}
+                1 => {
+                    commands.spawn((SceneRoot(assets.tree_small.clone()), transform));
+                }
+                2 => {
+                    commands.spawn((SceneRoot(assets.tree_large.clone()), transform));
+                }
+                _ => {}
+            }
+        }
+    }
+}
diff --git a/examples/large_scenes/bevy_city/src/main.rs b/examples/large_scenes/bevy_city/src/main.rs
new file mode 100644
index 0000000000000..81902e94c01eb
--- /dev/null
+++ b/examples/large_scenes/bevy_city/src/main.rs
@@ -0,0 +1,158 @@
+//! A procedurally generated city
+
+use argh::FromArgs;
+use assets::{load_assets, CityAssets};
+use bevy::{
+    anti_alias::taa::TemporalAntiAliasing,
+    camera::{Exposure, Hdr},
+    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
+    color::palettes::css::WHITE,
+    feathers::{dark_theme::create_dark_theme, theme::UiTheme, FeathersPlugins},
+    light::{atmosphere::ScatteringMedium, Atmosphere, AtmosphereEnvironmentMapLight},
+    pbr::{
+        wireframe::{WireframeConfig, WireframePlugin},
+        AtmosphereSettings, ContactShadows,
+    },
+    post_process::bloom::Bloom,
+    prelude::*,
+    window::{PresentMode, WindowResolution},
+    winit::WinitSettings,
+};
+
+use crate::settings::Settings;
+use crate::{generate_city::spawn_city, settings::setup_settings_ui};
+
+mod assets;
+mod generate_city;
+mod settings;
+
+#[derive(FromArgs, Resource, Clone)]
+/// Config
+pub struct Args {
+    /// seed
+    #[argh(option, default = "42")]
+    seed: u64,
+
+    /// size
+    #[argh(option, default = "30")]
+    size: u32,
+}
+
+fn main() {
+    let args: Args = argh::from_env();
+
+    App::new()
+        .add_plugins((
+            DefaultPlugins.set(WindowPlugin {
+                primary_window: Some(Window {
+                    title: "bevy_city".into(),
+                    resolution: WindowResolution::new(1920, 1080).with_scale_factor_override(1.0),
+                    present_mode: PresentMode::AutoNoVsync,
+                    ..default()
+                }),
+                ..default()
+            }),
+            FreeCameraPlugin,
+            FeathersPlugins,
+            WireframePlugin::default(),
+        ))
+        .insert_resource(args.clone())
+        .insert_resource(ClearColor(Color::BLACK))
+        .insert_resource(WinitSettings::continuous())
+        .init_resource::<Settings>()
+        .insert_resource(UiTheme(create_dark_theme()))
+        .insert_resource(WireframeConfig {
+            global: false,
+            default_color: WHITE.into(),
+        })
+        .add_systems(
+            Startup,
+            (
+                setup,
+                setup_settings_ui,
+                load_assets,
+                setup_city.after(load_assets),
+            ),
+        )
+        .add_systems(Update, simulate_cars)
+        .run();
+}
+
+fn setup(mut commands: Commands, mut scattering_mediums: ResMut<Assets<ScatteringMedium>>) {
+    commands.spawn((
+        Camera3d::default(),
+        Hdr,
+        Transform::from_xyz(15.0, 10.0, 20.0).looking_at(Vec3::ZERO, Vec3::Y),
+        FreeCamera::default(),
+        Atmosphere::earthlike(scattering_mediums.add(ScatteringMedium::default())),
+        AtmosphereSettings::default(),
+        // The directional light illuminance used in this scene is
+        // quite bright, so raising the exposure compensation helps
+        // bring the scene to a nicer brightness range.
+        Exposure { ev100: 13.0 },
+        // Bloom gives the sun a much more natural look.
+        Bloom::NATURAL,
+        // Enables the atmosphere to drive reflections and ambient lighting (IBL) for this view
+        AtmosphereEnvironmentMapLight::default(),
+        Msaa::Off,
+        TemporalAntiAliasing::default(),
+        ContactShadows::default(),
+    ));
+
+    commands.spawn((
+        DirectionalLight {
+            shadow_maps_enabled: Settings::default().shadow_maps_enabled,
+            contact_shadows_enabled: Settings::default().contact_shadows_enabled,
+            illuminance: light_consts::lux::RAW_SUNLIGHT,
+            ..default()
+        },
+        Transform::from_xyz(1.0, 0.15, 1.0).looking_at(Vec3::ZERO, Vec3::Y),
+    ));
+}
+
+fn setup_city(mut commands: Commands, assets: Res<CityAssets>, args: Res<Args>) {
+    spawn_city(&mut commands, &assets, args.seed, args.size);
+}
+
+#[derive(Component)]
+struct Road {
+    start: Vec3,
+    end: Vec3,
+}
+
+#[derive(Component)]
+struct Car {
+    offset: Vec3,
+    distance_traveled: f32,
+    dir: f32,
+}
+
+fn simulate_cars(
+    settings: Res<Settings>,
+    roads: Query<(&Road, &Transform, &Children), Without<Car>>,
+    mut cars: Query<(&mut Car, &mut Transform), Without<Road>>,
+    time: Res<Time>,
+) {
+    if !settings.simulate_cars {
+        return;
+    }
+    let speed = 1.5;
+
+    for (road, _, children) in &roads {
+        for child in children {
+            let Ok((mut car, mut car_transform)) = cars.get_mut(*child) else {
+                continue;
+            };
+
+            car.distance_traveled += speed * time.delta_secs();
+            let road_len = (road.end - road.start).length();
+            if car.distance_traveled > road_len {
+                car.distance_traveled = 0.0;
+            }
+            let direction = (road.end - road.start).normalize() * car.dir;
+
+            let progress = car.distance_traveled / road_len;
+            car_transform.translation = (road.start + car.offset) + direction * road_len * progress;
+        }
+    }
+}
diff --git a/examples/large_scenes/bevy_city/src/settings.rs b/examples/large_scenes/bevy_city/src/settings.rs
new file mode 100644
index 0000000000000..8a20fdc9c250e
--- /dev/null
+++ b/examples/large_scenes/bevy_city/src/settings.rs
@@ -0,0 +1,148 @@
+use bevy::{
+    camera_controller::free_camera::FreeCameraState,
+    feathers::{
+        self,
+        controls::{button, checkbox, ButtonProps},
+        theme::{ThemeBackgroundColor, ThemedText},
+    },
+    pbr::wireframe::WireframeConfig,
+    prelude::*,
+    ui::Checked,
+    ui_widgets::{checkbox_self_update, observe, Activate, ValueChange},
+};
+use rand::RngExt;
+
+use crate::assets::CityAssets;
+use crate::generate_city::{spawn_city, CityRoot};
+
+#[derive(Resource)]
+pub struct Settings {
+    pub simulate_cars: bool,
+    pub shadow_maps_enabled: bool,
+    pub contact_shadows_enabled: bool,
+    pub wireframe_enabled: bool,
+}
+
+impl Default for Settings {
+    fn default() -> Self {
+        Self {
+            simulate_cars: true,
+            shadow_maps_enabled: true,
+            contact_shadows_enabled: true,
+            wireframe_enabled: false,
+        }
+    }
+}
+
+pub fn setup_settings_ui(mut commands: Commands) {
+    commands.spawn((
+        Node {
+            position_type: PositionType::Absolute,
+            top: Val::Px(10.0),
+            right: Val::Px(10.0),
+            padding: UiRect::all(Val::Px(8.0)),
+            ..default()
+        },
+        ThemeBackgroundColor(feathers::tokens::WINDOW_BG),
+        observe(
+            |_: On<Pointer<Over>>, mut free_camera_state: Single<&mut FreeCameraState>| {
+                free_camera_state.enabled = false;
+            },
+        ),
+        observe(
+            |_: On<Pointer<Out>>, mut free_camera_state: Single<&mut FreeCameraState>| {
+                free_camera_state.enabled = true;
+            },
+        ),
+        children![(
+            Node {
+                display: Display::Flex,
+                flex_direction: FlexDirection::Column,
+                align_items: AlignItems::Stretch,
+                justify_content: JustifyContent::Start,
+                row_gap: px(8),
+                ..default()
+            },
+            children![
+                (Text("Settings".to_owned())),
+                (
+                    checkbox(Checked, Spawn((Text::new("Simulate Cars"), ThemedText))),
+                    observe(checkbox_self_update),
+                    observe(
+                        |change: On<ValueChange<bool>>, mut settings: ResMut<Settings>| {
+                            settings.simulate_cars = change.value;
+                        }
+                    )
+                ),
+                (
+                    checkbox(
+                        Checked,
+                        Spawn((Text::new("Shadow maps enabled"), ThemedText))
+                    ),
+                    observe(checkbox_self_update),
+                    observe(
+                        |change: On<ValueChange<bool>>,
+                         mut settings: ResMut<Settings>,
+                         mut directional_lights: Query<&mut DirectionalLight>| {
+                            settings.shadow_maps_enabled = change.value;
+                            for mut light in &mut directional_lights {
+                                light.shadow_maps_enabled = change.value;
+
+                            }
+                        }
+                    )
+                ),
+                (
+                    checkbox(
+                        Checked,
+                        Spawn((Text::new("Contact shadows enabled"), ThemedText))
+                    ),
+                    observe(checkbox_self_update),
+                    observe(
+                        |change: On<ValueChange<bool>>,
+                         mut settings: ResMut<Settings>,
+                         mut directional_lights: Query<&mut DirectionalLight>| {
+                            settings.contact_shadows_enabled = change.value;
+                            for mut light in &mut directional_lights {
+                                light.contact_shadows_enabled = change.value;
+
+                            }
+                        }
+                    )
+                ),
+                (
+                    checkbox((), Spawn((Text::new("Wireframe Enabled"), ThemedText))),
+                    observe(checkbox_self_update),
+                    observe(
+                        |change: On<ValueChange<bool>>,
+                         mut settings: ResMut<Settings>,
+                         mut wireframe_config: ResMut<WireframeConfig>| {
+                            settings.wireframe_enabled = change.value;
+                            wireframe_config.global = change.value;
+                        }
+                    )
+                ),
+                (
+                    button(
+                        ButtonProps::default(),
+                        (),
+                        Spawn((Text::new("Regenerate City"), ThemedText))
+                    ),
+                    observe(
+                        |_activate: On<Activate>,
+                         mut commands: Commands,
+                         city_root: Single<Entity, With<CityRoot>>,
+                         assets: Res<CityAssets>| {
+                            commands.entity(*city_root).despawn();
+
+                            let mut rng = rand::rng();
+                            let seed = rng.random::<u64>();
+                            println!("new seed: {seed}");
+                            spawn_city(&mut commands, &assets, seed, 32);
+                        }
+                    )
+                ),
+            ]
+        )],
+    ));
+}
