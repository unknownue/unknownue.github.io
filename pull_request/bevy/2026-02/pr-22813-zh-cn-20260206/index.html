<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22813 Batch prepasses that use depth only
        
    </title><meta content="#22813 Batch prepasses that use depth only" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-06</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-22813-en-20260206>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=ji-ben-zi-xun>基本资讯</h2><ul><li><strong>标题</strong>: Batch prepasses that use depth only<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/22813<li><strong>作者</strong>: tychedelia<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review<li><strong>创建时间</strong>: 2026-02-05T08:15:58Z<li><strong>合并时间</strong>: 2026-02-06T19:45:59Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><p>对于不需要访问材质数据或写入法线/运动矢量的预处理器( prepasses )，我们可以将它们批量处理。为此，我们存储一个新的绘制命令，该命令绑定一个空绑定组(empty bind group)来替代材质绑定，并在批次集键(batch set key)中为材质ID添加<code>None</code>。<p>测试：<pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> many_cubes</span><span style=color:#ff8f40> --release</span><span style=color:#ed9366> --</span><span> --shadows --material-texture-count 10
</span></code></pre><p>主分支： <img alt=image height=174 src=https://github.com/user-attachments/assets/bafdb7a2-e119-423e-a7a8-e527dbcfa81a width=368><p>本PR： <img alt=image height=174 src=https://github.com/user-attachments/assets/c852e879-1801-450e-a1ed-207871544b83 width=368><h2 id=zhe-ge-prde-gu-shi>这个PR的故事</h2><p>这个PR的核心问题是优化渲染性能，具体来说是为了解决深度预处理器(depth-only prepasses)无法有效批量处理的问题。在Bevy的渲染系统中，预处理器用于生成深度、法线和其他G-buffer数据，但某些预处理器（特别是仅深度预处理器）实际上不需要访问材质数据。<h3 id=wen-ti-fen-xi>问题分析</h3><p>在原始实现中，所有预处理器都绑定材质绑定组(material bind group)，即使它们实际上不需要材质数据。这导致即使多个对象使用不同的材质，只要它们在同一个深度预处理器中，也无法被批处理。每个材质绑定组都成为一个独立的批次，增加了绘制调用(draw calls)的数量。<p>问题关键点：<ol><li>深度预处理器（如阴影贴图生成）只需要顶点位置和深度信息，不需要材质纹理或属性<li>当前的批处理系统将材质ID作为批次键的一部分，导致相同几何体但不同材质的对象无法批处理<li>这限制了渲染性能，特别是在具有大量不同材质的场景中</ol><h3 id=jie-jue-fang-an>解决方案</h3><p>作者采用了一个直接的方法：对于仅深度预处理器，使用空的绑定组替代材质绑定组，并在批次键中省略材质ID。这样，所有使用仅深度预处理器的几何体都可以被批量处理，无论它们使用什么材质。<p>具体实现分为几个关键部分：<h4 id=1-xin-de-hui-zhi-han-shu-he-biao-qian>1. 新的绘制函数和标签</h4><p>首先，需要定义新的绘制函数类型来处理深度预处理器。在<code>material.rs</code>中添加了两个新的绘制函数标签：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(DrawFunctionLabel</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>PrepassOpaqueDepthOnlyDrawFunction</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(DrawFunctionLabel</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ShadowsDepthOnlyDrawFunction</span><span style=color:#61676ccc>;
</span></code></pre><p>这些标签用于区分常规预处理器和深度预处理器。<h4 id=2-guan-dao-zhuan-ye-hua-diao-zheng>2. 管道专业化调整</h4><p>在<code>prepass/mod.rs</code>中，关键改变在<code>PrepassPipeline::specialize</code>方法中。系统需要识别何时使用空绑定组：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_depth_only_opaque_prepass</span><span>(</span><span style=color:#ff8f40>mesh_key</span><span style=color:#61676ccc>:</span><span> MeshPipelineKey) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    mesh_key</span><span style=color:#ed9366>.</span><span style=color:#f07171>intersection</span><span>(MeshPipelineKey</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ALL_PREPASS_BITS</span><span>) </span><span style=color:#ed9366>== </span><span>MeshPipelineKey</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>DEPTH_PREPASS
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在specialize方法中：
</span><span style=color:#fa6e32>if </span><span style=color:#f07171>is_depth_only_opaque_prepass</span><span>(mesh_key) </span><span style=color:#ed9366>&& !</span><span>emulate_unclipped_depth {
</span><span>    bind_group_layouts</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>empty_layout</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    bind_group_layouts</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(
</span><span>        material_properties
</span><span>            </span><span style=color:#ed9366>.</span><span>material_layout
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这里的关键判断逻辑是：如果预处理器是深度预处理器（只需要深度），且不需要模拟未裁剪深度(unclipped depth emulation)，则使用空绑定组布局。<h4 id=3-huan-cun-kuo-zhan>3. 缓存扩展</h4><p>原来的材质管道缓存只存储了管道ID，现在需要额外存储绘制函数ID，以确定应该使用哪个绘制函数：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span>map</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap<(Tick, CachedRenderPipelineId)></span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span>map</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap<(Tick, CachedRenderPipelineId, DrawFunctionId)></span><span style=color:#61676ccc>,
</span></code></pre><p>这个改变反映在<code>SpecializedPrepassMaterialViewPipelineCache</code>和<code>SpecializedShadowMaterialViewPipelineCache</code>中。<h4 id=4-xin-de-xuan-ran-ming-ling>4. 新的渲染命令</h4><p>为了支持空材质绑定组，添加了新的渲染命令<code>SetPrepassEmptyMaterialBindGroup</code>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>SetPrepassEmptyMaterialBindGroup</span><span><</span><span style=color:#fa6e32>const</span><span> I</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>></span><span style=color:#61676ccc>;
</span></code></pre><p>该命令绑定一个空绑定组到指定的绑定点。然后定义了一个新的绘制命令组合：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub type </span><span style=color:#399ee6>DrawDepthOnlyPrepass </span><span style=color:#ed9366>= </span><span>(
</span><span>    SetItemPipeline</span><span style=color:#61676ccc>,
</span><span>    SetPrepassViewBindGroup&LT0></span><span style=color:#61676ccc>,
</span><span>    SetPrepassViewEmptyBindGroup&LT1></span><span style=color:#61676ccc>,
</span><span>    SetMeshBindGroup&LT2></span><span style=color:#61676ccc>,
</span><span>    SetPrepassEmptyMaterialBindGroup&LT3></span><span style=color:#61676ccc>,
</span><span>    DrawMesh</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>与常规的<code>DrawPrepass</code>相比，关键区别在于使用了<code>SetPrepassEmptyMaterialBindGroup</code>而不是<code>SetMaterialBindGroup</code>。<h4 id=5-pi-chu-li-luo-ji-diao-zheng>5. 批处理逻辑调整</h4><p>在<code>queue_prepass_material_meshes</code>和<code>queue_shadows</code>函数中，当处理深度预处理器时，将<code>material_bind_group_index</code>设置为<code>None</code>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> material_bind_group_index </span><span style=color:#ed9366>=
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(draw_function) </span><span style=color:#ed9366>==</span><span> depth_only_draw_function {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>None
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(material</span><span style=color:#ed9366>.</span><span>binding</span><span style=color:#ed9366>.</span><span>group</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>    }</span><span style=color:#61676ccc>;
</span></code></pre><p>这允许批处理系统忽略材质差异，将不同材质的几何体批处理在一起。<h4 id=6-biao-zhi-wei-kuo-zhan>6. 标志位扩展</h4><p>为了正确识别哪些预处理器需要读取材质数据，在<code>MeshPipelineKey</code>中添加了新标志位：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>const </span><span style=color:#ff8f40>PREPASS_READS_MATERIAL </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1 </span><span style=color:#ed9366><< </span><span style=color:#ff8f40>24</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ALL_PREPASS_BITS </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>DEPTH_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>    </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>NORMAL_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>    </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>DEFERRED_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>    </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MOTION_VECTOR_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>    </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAY_DISCARD</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>    </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>PREPASS_READS_MATERIAL</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=ji-shu-jian-jie>技术见解</h3><p>这个PR展示了几个重要的渲染优化技术：<ol><li><p><strong>基于使用模式的差异化处理</strong>：不是所有预处理器都需要相同的数据，深度预处理器是一个特例，可以优化。</p><li><p><strong>空绑定组的使用</strong>：当着色器不需要某些数据时，使用空绑定组可以避免不必要的GPU状态切换。</p><li><p><strong>批处理键优化</strong>：通过从批处理键中移除不必要的信息（材质ID），可以增加批处理机会。</p><li><p><strong>条件性专业化</strong>：渲染管道根据使用情况动态专业化，这是现代渲染引擎的关键特性。</p></ol><p>值得注意的是，这种优化有几个前提条件：<ul><li>着色器必须能够处理缺少材质数据的情况<li>深度预处理器确实不需要材质数据<li>系统需要正确识别深度预处理器和其他预处理器的区别</ul><h3 id=xing-neng-ying-xiang>性能影响</h3><p>从提供的性能对比图可以看出，这个优化带来了明显的性能提升。在<code>many_cubes</code>示例中，使用10个不同材质纹理时，性能有了显著改善。<p>关键性能收益包括：<ul><li>减少绘制调用数量<li>减少GPU状态切换<li>提高GPU利用率</ul><h3 id=qian-zai-wen-ti-he-zhu-yi-shi-xiang>潜在问题和注意事项</h3><ol><li><p><strong>未裁剪深度模拟</strong>：当需要模拟未裁剪深度时，仍然需要运行片段着色器，因此不能使用空材质绑定组。</p><li><p><strong>向后兼容性</strong>：这个改变是向后兼容的，因为只增加了新的绘制路径，没有修改现有功能。</p><li><p><strong>着色器复杂度</strong>：着色器需要能够处理空绑定组的情况，可能需要额外的分支或条件编译。</p></ol><h2 id=shi-jue-biao-shi>视觉表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[预处理器系统] --> B{是否需要材质数据?}
</span><span>    B -->|是| C[使用常规绘制路径 DrawPrepass]
</span><span>    B -->|否| D[使用深度绘制路径 DrawDepthOnlyPrepass]
</span><span>    C --> E[绑定材质绑定组]
</span><span>    D --> F[绑定空材质绑定组]
</span><span>    E --> G[材质ID包含在批次键中]
</span><span>    F --> H[材质ID从批次键中省略]
</span><span>    G --> I[基于材质进行批处理]
</span><span>    H --> J[跨材质批处理]
</span><span>    
</span><span>    K[MeshPipelineKey] --> L[判断预处理器类型]
</span><span>    L --> M[深度预处理器]
</span><span>    L --> N[法线预处理器]
</span><span>    L --> O[运动矢量预处理器]
</span><span>    L --> P[延迟预处理器]
</span><span>    
</span><span>    M --> B
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><h3 id=crates-bevy-pbr-src-prepass-mod-rs-134-85><code>crates/bevy_pbr/src/prepass/mod.rs</code> (+134/-85)</h3><p><strong>修改内容</strong>：这是主要的修改文件，实现了深度预处理器的批处理逻辑。<p><strong>关键修改</strong>：<ol><li>添加了<code>is_depth_only_opaque_prepass</code>函数来判断是否为深度预处理器<li>修改了管道专业化逻辑，为深度预处理器使用空绑定组<li>扩展了缓存数据结构以存储绘制函数ID<li>添加了新的渲染命令<code>SetPrepassEmptyMaterialBindGroup</code><li>定义了新的绘制命令组合<code>DrawDepthOnlyPrepass</code></ol><p><strong>代码示例</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 判断是否为深度预处理器
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_depth_only_opaque_prepass</span><span>(</span><span style=color:#ff8f40>mesh_key</span><span style=color:#61676ccc>:</span><span> MeshPipelineKey) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    mesh_key</span><span style=color:#ed9366>.</span><span style=color:#f07171>intersection</span><span>(MeshPipelineKey</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ALL_PREPASS_BITS</span><span>) </span><span style=color:#ed9366>== </span><span>MeshPipelineKey</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>DEPTH_PREPASS
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 新的绘制命令组合
</span><span style=color:#fa6e32>pub type </span><span style=color:#399ee6>DrawDepthOnlyPrepass </span><span style=color:#ed9366>= </span><span>(
</span><span>    SetItemPipeline</span><span style=color:#61676ccc>,
</span><span>    SetPrepassViewBindGroup&LT0></span><span style=color:#61676ccc>,
</span><span>    SetPrepassViewEmptyBindGroup&LT1></span><span style=color:#61676ccc>,
</span><span>    SetMeshBindGroup&LT2></span><span style=color:#61676ccc>,
</span><span>    SetPrepassEmptyMaterialBindGroup&LT3></span><span style=color:#61676ccc>,
</span><span>    DrawMesh</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-pbr-src-render-light-rs-39-12><code>crates/bevy_pbr/src/render/light.rs</code> (+39/-12)</h3><p><strong>修改内容</strong>：扩展阴影渲染系统以支持深度预处理器批处理。<p><strong>关键修改</strong>：<ol><li>修改了<code>SpecializedShadowMaterialViewPipelineCache</code>以存储绘制函数ID<li>在<code>specialize_shadows</code>中为深度阴影选择合适的绘制函数<li>在<code>queue_shadows</code>中为深度阴影设置<code>material_bind_group_index</code>为<code>None</code></ol><p><strong>代码示例</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前的缓存结构
</span><span>map</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap<(Tick, CachedRenderPipelineId)></span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后的缓存结构  
</span><span>map</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap<(Tick, CachedRenderPipelineId, DrawFunctionId)></span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在队列函数中的使用
</span><span style=color:#fa6e32>let</span><span> material_bind_group_index </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(draw_function) </span><span style=color:#ed9366>==</span><span> depth_only_draw_function {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>None
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(material</span><span style=color:#ed9366>.</span><span>binding</span><span style=color:#ed9366>.</span><span>group</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-pbr-src-material-rs-17-0><code>crates/bevy_pbr/src/material.rs</code> (+17/-0)</h3><p><strong>修改内容</strong>：添加新的绘制函数标签并注册新的绘制命令。<p><strong>关键修改</strong>：<ol><li>添加了<code>PrepassOpaqueDepthOnlyDrawFunction</code>和<code>ShadowsDepthOnlyDrawFunction</code>标签<li>注册了<code>DrawDepthOnlyPrepass</code>渲染命令<li>在<code>queue_material_meshes</code>中包含了新的绘制函数</ol><p><strong>代码示例</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(DrawFunctionLabel</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>PrepassOpaqueDepthOnlyDrawFunction</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(DrawFunctionLabel</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ShadowsDepthOnlyDrawFunction</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 注册渲染命令
</span><span style=color:#ed9366>.</span><span>add_render_command</span><span style=color:#ed9366>::</span><span>&LTShadow, DrawDepthOnlyPrepass>()
</span></code></pre><h3 id=crates-bevy-pbr-src-render-mesh-rs-9-1><code>crates/bevy_pbr/src/render/mesh.rs</code> (+9/-1)</h3><p><strong>修改内容</strong>：扩展<code>MeshPipelineKey</code>以支持预处理器材质读取标志。<p><strong>关键修改</strong>：<ol><li>添加了<code>PREPASS_READS_MATERIAL</code>标志位<li>定义了<code>ALL_PREPASS_BITS</code>组合标志</ol><p><strong>代码示例</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>const </span><span style=color:#ff8f40>PREPASS_READS_MATERIAL            </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1 </span><span style=color:#ed9366><< </span><span style=color:#ff8f40>24</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ALL_PREPASS_BITS                  </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>DEPTH_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>                                        </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>NORMAL_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>                                        </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>DEFERRED_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>                                        </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MOTION_VECTOR_PREPASS</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>                                        </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAY_DISCARD</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()
</span><span>                                        </span><span style=color:#ed9366>| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>PREPASS_READS_MATERIAL</span><span style=color:#ed9366>.</span><span style=color:#f07171>bits</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=jin-yi-bu-yue-du>进一步阅读</h2><ol><li><strong>Bevy渲染架构文档</strong>：了解Bevy的ECS渲染系统如何工作<li><strong>WebGPU/DirectX12/Vulkan绑定组设计</strong>：理解现代图形API中绑定组的最佳实践<li><strong>渲染批处理技术</strong>：深入学习渲染批处理的原理和实现<li><strong>延迟渲染和G-buffer</strong>：了解预处理器在延迟渲染管线中的作用<li><strong>GPU驱动优化</strong>：了解减少绘制调用和状态切换对性能的影响</ol><p>相关资源：<ul><li><a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/features/render-pipelines.html target=_blank>Bevy渲染管线指南</a><li><a rel="noopener nofollow noreferrer" href=https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-groups.html target=_blank>WebGPU绑定组设计模式</a><li><a rel="noopener nofollow noreferrer" href=https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-7-hardware-occlusion-queries-made-useful target=_blank>现代渲染引擎中的批处理技术</a></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22813.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>