diff --git a/crates/bevy_ecs/src/reflect/component.rs b/crates/bevy_ecs/src/reflect/component.rs
index c38deeb31683c..ec564500c6daa 100644
--- a/crates/bevy_ecs/src/reflect/component.rs
+++ b/crates/bevy_ecs/src/reflect/component.rs
@@ -69,6 +69,7 @@ use crate::{
         FilteredEntityRef, World,
     },
 };
+use alloc::boxed::Box;
 use bevy_reflect::{FromReflect, FromType, PartialReflect, Reflect, TypePath, TypeRegistry};
 use bevy_utils::prelude::DebugName;
 
@@ -115,6 +116,8 @@ pub struct ReflectComponentFns {
     ),
     /// Function pointer implementing [`ReflectComponent::remove()`].
     pub remove: fn(&mut EntityWorldMut),
+    /// Function pointer implementing [`ReflectComponent::take()`].
+    pub take: fn(&mut EntityWorldMut) -> Option<Box<dyn Reflect>>,
     /// Function pointer implementing [`ReflectComponent::contains()`].
     pub contains: fn(FilteredEntityRef) -> bool,
     /// Function pointer implementing [`ReflectComponent::reflect()`].
@@ -188,6 +191,11 @@ impl ReflectComponent {
         (self.0.remove)(entity);
     }
 
+    /// Removes this [`Component`] from the entity and returns its previous value.
+    pub fn take(&self, entity: &mut EntityWorldMut) -> Option<Box<dyn Reflect>> {
+        (self.0.take)(entity)
+    }
+
     /// Returns whether entity contains this [`Component`]
     pub fn contains<'w, 's>(&self, entity: impl Into<FilteredEntityRef<'w, 's>>) -> bool {
         (self.0.contains)(entity.into())
@@ -349,6 +357,11 @@ impl<C: Component + Reflect + TypePath> FromType<C> for ReflectComponent {
             remove: |entity| {
                 entity.remove::<C>();
             },
+            take: |entity| {
+                entity
+                    .take::<C>()
+                    .map(|component| Box::new(component).into_reflect())
+            },
             contains: |entity| entity.contains::<C>(),
             copy: |source_world, destination_world, source_entity, destination_entity, registry| {
                 let source_component = source_world.get::<C>(source_entity).unwrap();
diff --git a/crates/bevy_ecs/src/reflect/entity_commands.rs b/crates/bevy_ecs/src/reflect/entity_commands.rs
index 0dcfca68ee3ae..140c96eba440a 100644
--- a/crates/bevy_ecs/src/reflect/entity_commands.rs
+++ b/crates/bevy_ecs/src/reflect/entity_commands.rs
@@ -6,7 +6,7 @@ use crate::{
     world::EntityWorldMut,
 };
 use alloc::{borrow::Cow, boxed::Box};
-use bevy_reflect::{PartialReflect, TypeRegistry};
+use bevy_reflect::{PartialReflect, Reflect, TypeRegistry};
 
 /// An extension trait for [`EntityCommands`] for reflection related functions
 pub trait ReflectCommandExt {
@@ -268,7 +268,7 @@ impl<'w> EntityWorldMut<'w> {
     ///
     /// # Note
     ///
-    /// Prefer to use the typed [`EntityCommands::remove`] if possible. Removing a reflected component
+    /// Prefer to use the typed [`EntityWorldMut::remove`] if possible. Removing a reflected component
     /// is much slower.
     pub fn remove_reflect(&mut self, component_type_path: Cow<'static, str>) -> &mut Self {
         self.assert_not_despawned();
@@ -304,6 +304,54 @@ impl<'w> EntityWorldMut<'w> {
         });
         self
     }
+
+    /// Takes from the entity the component or bundle with the given type path registered in [`AppTypeRegistry`].
+    ///
+    /// Does nothing and returns None if the type is a component and the entity does not have a component of the same type,
+    /// if the type is a bundle and the entity does not contain **every** component in the bundle,
+    /// or if [`AppTypeRegistry`] does not contain the reflection data for the given component.
+    ///
+    /// # Panics
+    ///
+    /// - If the entity has been despawned while this `EntityWorldMut` is still alive.
+    /// - If [`AppTypeRegistry`] is not present in the [`World`](crate::world::World).
+    ///
+    /// # Note
+    ///
+    /// Prefer to use the typed [`EntityWorldMut::take`] if possible. Taking a reflected component
+    /// is much slower.
+    pub fn take_reflect(
+        &mut self,
+        component_type_path: Cow<'static, str>,
+    ) -> Option<Box<dyn Reflect>> {
+        self.assert_not_despawned();
+        self.resource_scope(|entity, registry: Mut<AppTypeRegistry>| {
+            let type_registry = &registry.as_ref().read();
+            take_reflect_with_registry_ref(entity, type_registry, component_type_path)
+        })
+    }
+
+    /// Same as [`take_reflect`](EntityWorldMut::take_reflect), but using
+    /// the `T` resource as type registry instead of `AppTypeRegistry`.
+    ///
+    /// Does nothing and returns None if the type is a component and the entity does not have a component of the same type,
+    /// if the type is a bundle and the entity does not contain **every** component in the bundle,
+    /// or if [`AppTypeRegistry`] does not contain the reflection data for the given component.
+    ///
+    /// # Panics
+    ///
+    /// - If the entity has been despawned while this `EntityWorldMut` is still alive.
+    /// - If [`AppTypeRegistry`] is not present in the [`World`](crate::world::World).
+    pub fn take_reflect_with_registry<T: Resource + AsRef<TypeRegistry>>(
+        &mut self,
+        component_type_path: Cow<'static, str>,
+    ) -> Option<Box<dyn Reflect>> {
+        self.assert_not_despawned();
+        self.resource_scope(|entity, registry: Mut<T>| {
+            let type_registry = registry.as_ref().as_ref();
+            take_reflect_with_registry_ref(entity, type_registry, component_type_path)
+        })
+    }
 }
 
 /// Helper function to add a reflect component or bundle to a given entity
@@ -345,6 +393,22 @@ fn remove_reflect_with_registry_ref(
     }
 }
 
+/// Helper function to take a reflect component or bundle from a given entity
+fn take_reflect_with_registry_ref(
+    entity: &mut EntityWorldMut,
+    type_registry: &TypeRegistry,
+    component_type_path: Cow<'static, str>,
+) -> Option<Box<dyn Reflect>> {
+    let type_registration = type_registry.get_with_type_path(&component_type_path)?;
+    if let Some(reflect_component) = type_registration.data::<ReflectComponent>() {
+        reflect_component.take(entity)
+    } else if let Some(reflect_bundle) = type_registration.data::<ReflectBundle>() {
+        reflect_bundle.take(entity)
+    } else {
+        None
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use crate::{
