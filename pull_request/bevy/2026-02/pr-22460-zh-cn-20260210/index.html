<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22460 Add tools to avoid unnecessary `AssetEvent::Modified` events that lead to rendering performance costs (#16751)
        
    </title><meta content="#22460 Add tools to avoid unnecessary `AssetEvent::Modified` events that lead to rendering performance costs (#16751)" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-10</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-22460-en-20260210>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add tools to avoid unnecessary <code>AssetEvent::Modified</code> events that lead to rendering performance costs (#16751)<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22460<li><strong>Author</strong>: MatrixDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Assets, C-Performance, S-Ready-For-Final-Review, M-Migration-Guide, D-Modest<li><strong>Created</strong>: 2026-01-09T17:39:56Z<li><strong>Merged</strong>: 2026-02-10T19:08:38Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>目标</strong><ul><li>修复 #16751</ul><p><strong>解决方案</strong><ul><li><code>Assets::get_mut</code> 现在返回一个包装器类型 <code>AssetMut</code>，而不是 <code>&mut impl Asset</code>。<li><code>AssetMut</code> 实现了 <code>Deref</code> 和 <code>DerefMut</code>。<li><code>DerefMut</code> 将资产标记为已更改。<li>当 <code>AssetMut</code> 被丢弃时，仅当资产被标记为已更改时，才会将 <code>AssetEvent::Modified</code> 事件添加到队列中。</ul><p><strong>测试</strong><ul><li>你测试过这些更改吗？如果是，如何测试的？ <ul><li>没有添加单元测试，更改非常直接。<li>测试项目：https://github.com/MatrixDev/bevy-feature-16751-test。 <ul><li>使用更改：约 100 fps。<li>未使用更改：约 15 fps。</ul></ul><li>是否有任何部分需要更多测试？ <ul><li>我不认为这会破坏任何功能或增加明显的开销。<li><code>AssetEvent::Modified</code> 现在将在资产被修改之后发送，而不是之前。这应该不会影响任何功能，但仍然值得注意。</ul><li>其他人（审阅者）如何测试你的更改？他们需要了解什么具体事项吗？ <ul><li>拥有大量实体，这些实体不断更新其材质。<li>这些材质的属性应以阶梯方式（例如每 0.1 秒更改一次颜色）进行动画处理。<li>仅在值实际更改时更新材质：</ul></ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if</span><span> material</span><span style=color:#ed9366>.</span><span>base_color </span><span style=color:#ed9366>!=</span><span> new_color {
</span><span>    material</span><span style=color:#ed9366>.</span><span>base_color </span><span style=color:#ed9366>=</span><span> new_color</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ul><li>如果相关，你在哪些平台上测试了这些更改，是否有无法测试的重要平台？ <ul><li>在 macOS (Macbook M1) 上测试过<li>不是平台特定的问题</ul></ul><p>PS：这是我的第一个 PR，请不要评判得太严格。<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=wen-ti-yu-bei-jing>问题与背景</h3><p>在 Bevy 中，资产系统是引擎的核心部分，它管理着纹理、材质、网格等资源。当资产被修改时，系统需要触发 <code>AssetEvent::Modified</code> 事件，以便下游系统（如渲染器）能够知道需要更新其内部状态。问题在于，在 PR #22460 被合并之前，<code>Assets::get_mut</code> 方法的设计存在一个关键的性能缺陷：<strong>无论资产是否真的被修改，调用该方法都会立即触发 <code>AssetEvent::Modified</code> 事件。</strong><p>考虑一个常见场景：一个系统需要检查材质的颜色是否已经改变，只有在实际发生变化时才更新它。开发者可能会这样写代码：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let mut</span><span> material </span><span style=color:#ed9366>=</span><span> materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(handle)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>if</span><span> material</span><span style=color:#ed9366>.</span><span>base_color </span><span style=color:#ed9366>!=</span><span> new_color {
</span><span>    material</span><span style=color:#ed9366>.</span><span>base_color </span><span style=color:#ed9366>=</span><span> new_color</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>在旧实现中，即使 <code>if</code> 条件为 <code>false</code> 且 <code>base_color</code> 未被修改，<code>get_mut</code> 的调用本身也会触发一个 <code>Modified</code> 事件。这个不必要的事件会导致一系列昂贵的操作：<ol><li>材质提取系统被唤醒并重新处理该材质。<li>GPU 资源可能被重新分配或更新。<li>对于大量实体和频繁检查的情况，这会引发严重的性能问题。</ol><p>问题 #16751 指出了这一点，特别是在材质属性以阶梯方式（step-wise）动画化时，性能影响非常显著。作者的测试项目显示，在没有修复的情况下帧率降至约 15 FPS，而修复后达到约 100 FPS，这证实了性能开销是真实且巨大的。<h3 id=jie-jue-fang-an-si-lu>解决方案思路</h3><p>为了解决这个问题，PR 引入了一个核心思路：<strong>将“获取可变引用”与“标记为已修改”这两个操作解耦</strong>。资产的修改检测应该更加精确，只有当开发者实际通过可变引用写入资产时才触发事件。<p>这借鉴了 Bevy ECS 系统中 <code>ResMut</code> 和 <code>Mut</code> 包装器的模式，它们也使用了类似的变化检测机制。解决方案是创建一个新的包装器类型 <code>AssetMut</code>，它封装了对资产的可变引用，并负责跟踪该引用是否被用于实际的写操作。<h3 id=ju-ti-shi-xian>具体实现</h3><p>实现的核心是在 <code>crates/bevy_asset/src/assets.rs</code> 文件中。主要改动包括：<ol><li><p><strong>修改 <code>Assets::get_mut</code> 的签名和实现</strong>：</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>id</span><span style=color:#61676ccc>:</span><span> impl </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTAssetId&LTA>>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> A>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>id</span><span style=color:#61676ccc>:</span><span> impl </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTAssetId&LTA>>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTAssetMut<'</span><span style=color:#ed9366>_</span><span>, A>>
</span></code></pre> <p>方法不再直接返回 <code>&mut A</code>，而是返回一个 <code>AssetMut<'_, A></code> 结构体。</p><li><p><strong>引入 <code>AssetMut</code> 包装器</strong>：</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>AssetMut</span><span><</span><span style=color:#fa6e32>'a</span><span>, A</span><span style=color:#61676ccc>:</span><span> Asset> {
</span><span>    asset</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a mut</span><span> A,
</span><span>    guard</span><span style=color:#61676ccc>: </span><span>AssetMutChangeNotifier<</span><span style=color:#fa6e32>'a</span><span>, A>,
</span><span>}
</span></code></pre> <p><code>AssetMut</code> 包含了对资产的实际引用（<code>asset</code>）和一个负责变化检测的“守卫”（<code>guard</code>）。</p><li><p><strong>通过 <code>Deref</code> 和 <code>DerefMut</code> 实现透明访问</strong>： <code>AssetMut</code> 实现了 <code>Deref</code> 和 <code>DerefMut</code> trait。这是整个设计的巧妙之处：</p> <ul><li><code>Deref</code>（不可变解引用）允许只读访问资产，而<strong>不会</strong>将其标记为已更改。<li><code>DerefMut</code>（可变解引用）在调用时，会通过守卫将资产标记为已更改。</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>, A</span><span style=color:#61676ccc>:</span><span> Asset> DerefMut </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>AssetMut</span><span><</span><span style=color:#fa6e32>'a</span><span>, A> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>Target {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>guard</span><span style=color:#ed9366>.</span><span>changed </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 关键行：标记为已更改
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>asset
</span><span>    }
</span><span>}
</span></code></pre><li><p><strong>引入 <code>AssetMutChangeNotifier</code> 守卫</strong>： 这个结构体负责跟踪更改状态，并在被丢弃时决定是否发送事件。</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>AssetMutChangeNotifier</span><span><</span><span style=color:#fa6e32>'a</span><span>, A</span><span style=color:#61676ccc>:</span><span> Asset> {
</span><span>    changed</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>, </span><span style=color:#abb0b6;font-style:italic>// 跟踪是否发生了更改
</span><span>    asset_id</span><span style=color:#61676ccc>: </span><span>AssetId&LTA>,
</span><span>    queued_events</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a mut </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTAssetEvent&LTA>>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>, A</span><span style=color:#61676ccc>:</span><span> Asset> Drop </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>AssetMutChangeNotifier</span><span><</span><span style=color:#fa6e32>'a</span><span>, A> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>changed {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>queued_events
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(AssetEvent</span><span style=color:#ed9366>::</span><span>Modified { id</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>asset_id })</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre> <p>守卫的 <code>Drop</code> 实现确保了事件发送的延迟性：事件仅在 <code>AssetMut</code> 生命周期结束且资产被标记为已更改时被推入队列。这也解决了 PR 描述中提到的一个细微变化：<code>Modified</code> 事件现在在资产修改后发送，而不是之前，但这在逻辑上更合理，不太可能引发问题。</p><li><p><strong>提供显式控制方法</strong>： <code>AssetMut</code> 还提供了几个方法，让开发者可以更精细地控制行为：</p> <ul><li><code>into_inner()</code>: 将资产标记为已更改并返回可变引用。<li><code>into_inner_untracked()</code>: 返回可变引用但不标记为已更改。<li><code>bypass_change_detection()</code>: 一个风险较高的“逃生舱口”，允许直接访问内部引用而不触发任何更改检测，用于需要避免无限递归等特殊情况。</ul></ol><h3 id=ji-shu-dong-cha-yu-ying-xiang>技术洞察与影响</h3><p>这个实现展示了几个有价值的技术模式：<ol><li><p><strong>利用 Rust 的所有权系统进行资源跟踪</strong>：通过将跟踪状态（<code>changed: bool</code>）放在一个具有 <code>Drop</code> 实现的结构体中，确保了状态管理与生命周期绑定，避免了资源泄漏或忘记发送事件的情况。</p><li><p><strong>非侵入式 API 设计</strong>：对于现有代码，主要的迁移成本是将 <code>let mut material = materials.get_mut(...)</code> 中的变量声明改为 <code>mut</code>。对于只读检查后可能不写的情况，代码可以保持原样并获得性能收益。这种设计平衡了兼容性和优化收益。</p><li><p><strong>性能影响</strong>：对于“检查后可能不修改”的模式，优化效果最明显。如果代码总是会修改资产，那么性能开销与之前类似（仍需标记和发送事件）。但许多实际场景（如条件更新、动画插值）都从这一优化中受益。</p><li><p><strong>对下游系统的影响</strong>：该 PR 修改了 Bevy 代码库中大量调用 <code>get_mut</code> 的示例和内部代码，展示了变化的广泛性。更新主要是添加 <code>mut</code> 关键字或使用新的 <code>into_inner()</code> 方法。例如，在反射系统中：</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span>asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>asset</span><span>| asset </span><span style=color:#ed9366>as &</span><span style=color:#fa6e32>mut</span><span> dyn Reflect)
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span>asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>asset</span><span>| asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>into_inner</span><span>() </span><span style=color:#ed9366>as &</span><span style=color:#fa6e32>mut</span><span> dyn Reflect)
</span></code></pre></ol><h3 id=zong-jie>总结</h3><p>PR #22460 通过引入 <code>AssetMut</code> 包装器，巧妙地解决了资产系统中不必要的修改事件导致的性能瓶颈。它将变化检测的粒度从“获取可变引用时”细化到“实际写入时”，这对于频繁条件更新资产的场景（如 UI、动画）带来了显著的性能提升。这是一个典型的“零成本抽象”案例：在不需要时避免了开销，同时在需要时保留了完整功能。实现利用了 Rust 的类型系统和所有权模型，提供了安全且高效的解决方案。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Assets::get_mut] --> B[返回 AssetMut 包装器]
</span><span>    B --> C[包含 AssetMutChangeNotifier]
</span><span>    C --> D{通过 Deref/DerefMut 访问资产}
</span><span>    D -->|Deref 只读| E[不标记更改]
</span><span>    D -->|DerefMut 写入| F[标记 changed = true]
</span><span>    E --> G[AssetMut 被丢弃]
</span><span>    F --> G
</span><span>    G --> H[AssetMutChangeNotifier::drop 执行]
</span><span>    H --> I{changed == true?}
</span><span>    I -->|是| J[发送 AssetEvent::Modified]
</span><span>    I -->|否| K[不发送事件]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-crates-bevy-asset-src-assets-rs-142-7>1. <code>crates/bevy_asset/src/assets.rs</code> (+142/-7)</h3><p>这是实现变化检测逻辑的核心文件。主要更改包括：<ul><li>引入了 <code>AssetMut</code> 和 <code>AssetMutChangeNotifier</code> 两个新结构体。<li>修改了 <code>get_mut</code> 和 <code>get_or_insert_mut</code> 方法的返回类型。<li>添加了相应的 <code>Deref</code>、<code>DerefMut</code> 和 <code>Drop</code> 实现。<li>新增了单元测试 <code>assets_mut_change_detection</code> 来验证行为。</ul><p><strong>关键代码片段：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 新的 get_mut 实现
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>id</span><span style=color:#61676ccc>:</span><span> impl </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTAssetId&LTA>>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTAssetMut<'</span><span style=color:#ed9366>_</span><span>, A>> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> id</span><span style=color:#61676ccc>: </span><span>AssetId&LTA> </span><span style=color:#ed9366>=</span><span> id</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> result </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> id {
</span><span>        AssetId</span><span style=color:#ed9366>::</span><span>Index { index</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>.. </span><span>} </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>dense_storage</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(index)</span><span style=color:#61676ccc>,
</span><span>        AssetId</span><span style=color:#ed9366>::</span><span>Uuid { uuid } </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>hash_map</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span>uuid)</span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(AssetMut {
</span><span>        asset</span><span style=color:#61676ccc>:</span><span> result</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>,
</span><span>        guard</span><span style=color:#61676ccc>:</span><span> AssetMutChangeNotifier {
</span><span>            changed</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>            asset_id</span><span style=color:#61676ccc>:</span><span> id</span><span style=color:#61676ccc>,
</span><span>            queued_events</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>queued_events</span><span style=color:#61676ccc>,
</span><span>        }</span><span style=color:#61676ccc>,
</span><span>    })
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// DerefMut 实现 - 触发更改标记的关键
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>, A</span><span style=color:#61676ccc>:</span><span> Asset> DerefMut </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>AssetMut</span><span><</span><span style=color:#fa6e32>'a</span><span>, A> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>Target {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>guard</span><span style=color:#ed9366>.</span><span>changed </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>asset
</span><span>    }
</span><span>}
</span></code></pre><h3 id=2-release-content-migration-guides-asset-mut-change-detection-md-34-0>2. <code>release-content/migration-guides/asset-mut-change-detection.md</code> (+34/-0)</h3><p>这是一个新增的迁移指南，解释了 API 变更以及如何利用新特性优化代码。<p><strong>关键内容：</strong><pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span style=color:#ed9366;background-color:#61676c10>`Assets::get_mut`</span><span> will now return </span><span style=color:#ed9366;background-color:#61676c10>`AssetMut&LTA: Asset>`</span><span> instead of </span><span style=color:#ed9366;background-color:#61676c10>`&mut Asset`</span><span>.
</span><span>Similar to </span><span style=color:#ed9366;background-color:#61676c10>`Mut`</span><span>/</span><span style=color:#ed9366;background-color:#61676c10>`ResMut`</span><span>, new implementation will trigger </span><span style=color:#ed9366;background-color:#61676c10>`AssetEvent::Modified`</span><span>
</span><span>event only when the asset is actually mutated.
</span><span>
</span><span>In some cases (like materials), triggering </span><span style=color:#ed9366;background-color:#61676c10>`AssetEvent::Modified`</span><span> event might lead to
</span><span>measurable performance costs. To avoid this, it is now possible to check if the </span><span style=color:#ed9366;background-color:#61676c10>`Asset`</span><span>
</span><span>will change before mutating it:
</span></code></pre><p>指南提供了示例代码，展示了如何通过条件检查来避免不必要的修改事件。<h3 id=3-crates-bevy-text-src-font-atlas-rs-7-6>3. <code>crates/bevy_text/src/font_atlas.rs</code> (+7/-6)</h3><p>这个文件展示了如何适配新的 API。主要变化是将链式调用拆开，以便正确处理 <code>AssetMut</code>。<p><strong>代码片段：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前（假设的，实际是链式调用）：
</span><span style=color:#fa6e32>let</span><span> atlas_layout </span><span style=color:#ed9366>=</span><span> atlas_layouts</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> atlas_texture </span><span style=color:#ed9366>=</span><span> textures</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>builder</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_texture</span><span>(atlas_layout</span><span style=color:#61676ccc>,</span><span> texture</span><span style=color:#61676ccc>,</span><span> atlas_texture)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>let mut</span><span> atlas_layout </span><span style=color:#ed9366>=</span><span> atlas_layouts</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let mut</span><span> atlas_texture </span><span style=color:#ed9366>=</span><span> textures</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>builder</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_texture</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> atlas_layout</span><span style=color:#61676ccc>,</span><span> texture</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> atlas_texture)
</span></code></pre><p>注意 <code>&mut atlas_layout</code> 和 <code>&mut atlas_texture</code> 的传递，这是因为 <code>get_mut</code> 现在返回的是 <code>AssetMut</code>，而方法需要 <code>&mut</code> 引用。<h3 id=4-examples-3d-solari-rs-5-5-he-examples-large-scenes-mipmap-generator-src-lib-rs-3-3>4. <code>examples/3d/solari.rs</code> (+5/-5) 和 <code>examples/large_scenes/mipmap_generator/src/lib.rs</code> (+3/-3)</h3><p>这些是众多被更新的示例文件中的两个，代表了整个代码库中需要的适配性更改。更改模式非常一致：在变量声明中添加 <code>mut</code> 关键字。<p><strong>典型模式：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>let</span><span> material </span><span style=color:#ed9366>=</span><span> materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(material_handle)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>let mut</span><span> material </span><span style=color:#ed9366>=</span><span> materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(material_handle)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// 或者，如果后续没有可变访问：
</span><span style=color:#fa6e32>let</span><span> material </span><span style=color:#ed9366>=</span><span> materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(material_handle)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p>这种广泛的更新表明，虽然 API 发生了变化，但迁移成本相对较低，主要是在编译器的帮助下添加 <code>mut</code> 关键字。<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy ECS Change Detection</strong>: 了解 <code>ResMut</code> 和 <code>Mut</code> 包装器如何实现类似的变化检测机制，可以帮助深入理解本 PR 的设计模式。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/programming/change-detection.html target=_blank>Bevy Cheatbook - Change Detection</a></ul><li><p><strong>Rust Deref and DerefMut Traits</strong>: 理解这些 trait 如何工作，是理解 <code>AssetMut</code> 透明访问机制的关键。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch15-02-deref.html target=_blank>Rust Book - The Deref Trait</a></ul><li><p><strong>零成本抽象（Zero-Cost Abstractions）</strong>: 本 PR 是一个很好的案例，展示了如何在 Rust 中通过类型系统提供高级抽象，而不带来运行时开销。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://blog.rust-lang.org/2015/05/11/traits.html target=_blank>Rust Blog - What are zero-cost abstractions?</a></ul><li><p><strong>Resource Management with Drop Guards</strong>: <code>AssetMutChangeNotifier</code> 是一个典型的“守卫”（Guard）模式，利用 <code>Drop</code> trait 进行资源清理。这是一种常见的 RAII（Resource Acquisition Is Initialization）模式。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/rust-by-example/scope/raii.html target=_blank>Rust RAII</a></ul></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22460.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>