<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23023 Batch meshes with morph targets.
        
    </title><meta content="#23023 Batch meshes with morph targets." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-28</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-23023-zh-cn-20260228>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Batch meshes with morph targets.<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Batch meshes with morph targets.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/23023<li><strong>Author</strong>: pcwalton<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review, M-Migration-Guide<li><strong>Created</strong>: 2026-02-17T22:32:42Z<li><strong>Merged</strong>: 2026-02-28T21:41:57Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Right now, Bevy can’t batch meshes with morph targets together, because the morph targets are packed into a morph texture, which is non-bindless. To fix this, this PR adds support for batching morph targets together on platforms with storage buffers. Morph displacements are allocated using the mesh allocator, just like vertex and index buffers are.<p>This PR also improves the API for supplying morph targets to a mesh. Today, the application must create a <code>MorphTargetImage</code> explicitly to store the morph targets, which is cumbersome. This patch changes the <code>Mesh</code> API to instead take morph targets as a flat vector. Internally, if the platform doesn’t support storage buffers, the morph targets are converted to a morph target image; if the platform does support storage buffers, however, the morph targets are packed in the mesh allocator.<p>This patch is a prerequisite for skin caching, because skin caching also applies to morph targets, and skin caching wants to skin many meshes at a time. Using a morph target image would either require batch breaking logic or bindless, neither of which are desirable for a feature that be simple and work on WebGPU, so I opted to make morph targets batchable instead.<p>On the <code>many_morph_targets</code> example, I went from 5.55 ms/frame to 2.80 ms/frame, a 1.98x speedup.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>Before this PR, Bevy’s rendering system had a significant performance limitation when dealing with meshes that used morph targets. Morph targets, which allow for vertex-level animations by blending between different mesh shapes, were stored in 3D textures called <code>MorphTargetImage</code>. Each mesh with morph targets required its own texture, and because these textures weren’t bindless, the rendering engine couldn’t batch multiple morphed meshes together in a single draw call. This forced the renderer to issue separate draw calls for each morphed mesh, creating substantial CPU overhead and reducing rendering performance.<p>The API for setting up morph targets was also cumbersome. Developers had to manually create a <code>MorphTargetImage</code> from their morph data and pass it to the mesh, adding unnecessary complexity to asset loading pipelines. This was particularly problematic for features like skin caching, which needed to process many meshes simultaneously and couldn’t afford the overhead of per-mesh texture bindings.<h3 id=the-solution-approach>The Solution Approach</h3><p>The core solution was to make morph target data batchable by storing it in storage buffers on platforms that support them, similar to how vertex and index data are already managed. The mesh allocator, which previously only handled vertex and index buffers, was extended to also allocate storage for morph target displacement data. On platforms without storage buffer support (where bindless textures aren’t available), the implementation falls back to the existing texture-based approach.<p>The API was simplified: instead of requiring developers to create a <code>MorphTargetImage</code>, they can now pass morph targets as a flat vector of <code>MorphAttributes</code> directly to the mesh. The system automatically handles the conversion to the appropriate storage format based on platform capabilities.<p>This approach provides several key benefits:<ol><li><strong>Batching</strong>: Meshes with morph targets can now be batched together when using storage buffers, significantly reducing draw calls<li><strong>Simplified API</strong>: Developers work with straightforward vector data instead of texture assets<li><strong>Platform compatibility</strong>: The system automatically chooses the optimal storage method for each platform<li><strong>Foundation for skin caching</strong>: The same batching mechanism enables efficient skin caching for morphed meshes</ol><h3 id=the-implementation>The Implementation</h3><p>The implementation required changes across multiple subsystems in Bevy’s rendering pipeline:<p><strong>Mesh Data Storage Changes</strong> The <code>Mesh</code> struct was modified to store morph targets as a <code>Vec&LTMorphAttributes></code> instead of a <code>Handle&LTImage></code>. The <code>MorphAttributes</code> struct was expanded with padding fields to ensure proper memory alignment for GPU storage:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Copy</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Reflect</span><span style=color:#61676ccc>,</span><span> ShaderType</span><span style=color:#61676ccc>,</span><span> Pod</span><span style=color:#61676ccc>,</span><span> Zeroable</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>repr</span><span>(C)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>MorphAttributes </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>position</span><span style=color:#61676ccc>:</span><span> Vec3,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>pad_a</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>normal</span><span style=color:#61676ccc>:</span><span> Vec3,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>pad_b</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>tangent</span><span style=color:#61676ccc>:</span><span> Vec3,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>pad_c</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>}
</span></code></pre><p><strong>Mesh Allocator Extension</strong> The mesh allocator was extended to handle morph target data as a new element class alongside vertices and indices. A new <code>MORPH_ATTRIBUTE_ELEMENT_LAYOUT</code> was added, and the allocator now tracks morph target slabs separately:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"morph"</span><span>)]
</span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>MORPH_ATTRIBUTE_ELEMENT_LAYOUT</span><span style=color:#61676ccc>:</span><span> ElementLayout </span><span style=color:#ed9366>=</span><span> ElementLayout {
</span><span>    class</span><span style=color:#61676ccc>: </span><span>ElementClass</span><span style=color:#ed9366>::</span><span>MorphTarget</span><span style=color:#61676ccc>,
</span><span>    size</span><span style=color:#61676ccc>: </span><span>size_of</span><span style=color:#ed9366>::</span><span>&LTMorphAttributes>() </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u64</span><span style=color:#61676ccc>,
</span><span>    elements_per_slot</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>The <code>MeshSlabs</code> struct was introduced to bundle all slab IDs associated with a mesh:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Clone</span><span style=color:#61676ccc>,</span><span> Default</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> PartialOrd</span><span style=color:#61676ccc>,</span><span> Ord</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> Debug)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>MeshSlabs </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>vertex_slab_id</span><span style=color:#61676ccc>:</span><span> SlabId,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>index_slab_id</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTSlabId>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>morph_target_slab_id</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTSlabId>,
</span><span>}
</span></code></pre><p><strong>Dual-Path Rendering Pipeline</strong> The rendering system now has two distinct paths for handling morph targets, selected based on platform capabilities:<ol><li><strong>Storage Buffer Path</strong> (for platforms with storage buffer support): Morph data is stored in buffers managed by the mesh allocator, allowing batching<li><strong>Texture Path</strong> (for platforms without storage buffer support): Morph data is packed into <code>MorphTargetImage</code> textures, maintaining compatibility but without batching</ol><p>The <code>RenderMorphTargetAllocator</code> resource manages this duality:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>RenderMorphTargetAllocator </span><span>{
</span><span>    Image {
</span><span>        mesh_id_to_image</span><span style=color:#61676ccc>: </span><span>HashMap&LTAssetId&LTMesh>, MorphTargetImage></span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    Storage</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p><strong>Shader Changes</strong> The shaders were updated to handle both storage buffer and texture-based morph targets. New functions like <code>morph_position</code>, <code>morph_normal</code>, and <code>morph_tangent</code> were added to abstract the data access method:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// For storage buffers:
</span><span>fn morph_position(vertex_index: u32, weight_index: u32, instance_index: u32) -> vec3&LTf32> {
</span><span>    return get_morph_target(vertex_index, weight_index, instance_index).position;
</span><span>}
</span><span>
</span><span>// For textures:
</span><span>fn morph_position(vertex_index: u32, weight_index: u32, instance_index: u32) -> vec3&LTf32> {
</span><span>    return morph(vertex_index, position_offset, weight_index);
</span><span>}
</span></code></pre><p><strong>Batch Key Updates</strong> Batch keys throughout the rendering pipeline were updated to use <code>MeshSlabs</code> instead of separate vertex and index slab fields. This consolidated approach ensures all mesh data (vertices, indices, and morph targets) are considered together during batching.<h3 id=technical-insights>Technical Insights</h3><p><strong>Memory Alignment Considerations</strong> The <code>MorphAttributes</code> struct includes explicit padding fields (<code>pad_a</code>, <code>pad_b</code>, <code>pad_c</code>) to ensure each <code>Vec3</code> starts on a 16-byte boundary. This is crucial for GPU performance and compatibility, as misaligned data can cause significant performance penalties or even runtime errors on some hardware.<p><strong>Dynamic Offset Management</strong> When using uniform buffers (the fallback path for platforms without storage buffers), the system manages dynamic offsets for both skinning and morph weight data. The <code>SetMeshBindGroup</code> render command was updated to handle these offsets correctly for both storage buffer and uniform buffer paths.<p><strong>Descriptor-Based GPU Data Management</strong> For the storage buffer path, the system introduces <code>GpuMorphDescriptor</code> structs that contain metadata about each mesh’s morph targets:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Clone</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Default</span><span style=color:#61676ccc>,</span><span> ShaderType</span><span style=color:#61676ccc>,</span><span> Pod</span><span style=color:#61676ccc>,</span><span> Zeroable)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>repr</span><span>(C)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>GpuMorphDescriptor </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>current_weights_offset</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>prev_weights_offset</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>targets_offset</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>vertex_count</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>weight_count</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span></code></pre><p>These descriptors are stored in a buffer and indexed by the <code>morph_descriptor_index</code> field in the <code>MeshUniform</code> struct, allowing the GPU to efficiently locate morph data for each mesh instance.<p><strong>Backwards Compatibility</strong> The PR maintains full backwards compatibility by automatically converting the new vector-based morph target data to the old texture format when running on platforms without storage buffer support. This ensures existing content continues to work while allowing new content to benefit from batching on capable hardware.<h3 id=the-impact>The Impact</h3><p>The performance impact is substantial: the <code>many_morph_targets</code> example shows a 1.98x speedup, dropping from 5.55 ms/frame to 2.80 ms/frame. This improvement comes primarily from the ability to batch multiple morphed meshes together, reducing CPU overhead and draw call counts.<p>The API simplification makes morph targets more accessible to developers, removing the need to understand texture packing for morph data. This aligns with Bevy’s goal of providing ergonomic APIs that don’t sacrifice performance.<p>The changes also lay the groundwork for future optimizations like skin caching, which can now leverage the same batching infrastructure for morphed meshes. This is particularly important for character rendering where both skinning and morph targets are commonly used together.<p>The implementation demonstrates a pattern for handling platform-specific optimizations in a clean, maintainable way, providing a template for future rendering optimizations that need to balance performance with broad hardware compatibility.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    subgraph "CPU Side"
</span><span>        A[Mesh with MorphAttributes vector] --> B{Mesh Allocator}
</span><span>        B -->|Storage buffers supported| C[Allocate in storage buffer]
</span><span>        B -->|No storage buffers| D[Create MorphTargetImage texture]
</span><span>        C --> E[GPU Storage Buffer]
</span><span>        D --> F[GPU Texture]
</span><span>    end
</span><span>
</span><span>    subgraph "GPU Side"
</span><span>        E --> G{Shader Path Selection}
</span><span>        F --> G
</span><span>        G -->|Storage Buffer Path| H[Access via storage buffer]
</span><span>        G -->|Texture Path| I[Access via texture sampling]
</span><span>        H --> J[Morphed Vertex]
</span><span>        I --> J
</span><span>    end
</span><span>
</span><span>    subgraph "Rendering Pipeline"
</span><span>        K[Batch Key with MeshSlabs] --> L{Batching System}
</span><span>        M[Mesh without morphs] --> L
</span><span>        N[Mesh with morphs (storage)] --> L
</span><span>        O[Mesh with morphs (texture)] --> L
</span><span>        L -->|Can batch together| P[Meshes with storage buffer morphs]
</span><span>        L -->|Cannot batch| Q[Separate draw calls for texture morphs]
</span><span>    end
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-pbr-src-render-mesh-rs-460-96><code>crates/bevy_pbr/src/render/mesh.rs</code> (+460/-96)</h3><p>This file contains the core changes to mesh rendering, including:<ul><li>Updated <code>MeshUniform</code> and <code>MeshInputUniform</code> to include <code>morph_descriptor_index</code><li>Modified <code>MeshPhaseBindGroups</code> to handle both uniform and storage buffer morph target bind groups<li>Added new enum <code>MeshMorphTargetBindGroups</code> to manage bind groups based on storage buffer support<li>Updated batching logic to consider morph target slab IDs</ul><p>Key changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Separate vertex and index slab fields
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Opaque3dBatchSetKey </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>vertex_slab</span><span style=color:#61676ccc>:</span><span> SlabId,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>index_slab</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTSlabId>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Consolidated MeshSlabs
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Opaque3dBatchSetKey </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>slabs</span><span style=color:#61676ccc>:</span><span> MeshSlabs,
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-render-morph-rs-322-34><code>crates/bevy_pbr/src/render/morph.rs</code> (+322/-34)</h3><p>This file handles morph target extraction and preparation:<ul><li>Replaced the simple <code>MorphIndices</code> struct with an enum that supports both uniform and storage buffer paths<li>Added <code>GpuMorphDescriptor</code> struct for GPU-side morph target metadata<li>Implemented <code>prepare_morph_descriptors</code> system for storage buffer path<li>Updated <code>extract_morphs</code> to handle both storage buffer and uniform buffer cases</ul><p>Key changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Simple hash maps for indices
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Default</span><span style=color:#61676ccc>,</span><span> Resource)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>MorphIndices </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>current</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap&LTMorphIndex>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>prev</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap&LTMorphIndex>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Enum with separate paths for uniform vs storage
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>MorphIndices </span><span>{
</span><span>    Uniform {
</span><span>        current</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap&LTMorphIndex></span><span style=color:#61676ccc>,
</span><span>        prev</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap&LTMorphIndex></span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    Storage {
</span><span>        morph_weights_info</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap&LTMorphWeightsInfo></span><span style=color:#61676ccc>,
</span><span>        gpu_descriptor_indices</span><span style=color:#61676ccc>: </span><span>MainEntityHashMap&LTMorphDescriptorIndex></span><span style=color:#61676ccc>,
</span><span>        gpu_descriptor_free_list</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTMorphDescriptorIndex></span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-render-mesh-bindings-rs-198-99><code>crates/bevy_pbr/src/render/mesh_bindings.rs</code> (+198/-99)</h3><p>This file contains bind group layout definitions:<ul><li>Updated bind group layouts to conditionally include storage buffer bindings<li>Modified <code>MeshLayouts</code> to handle both texture and storage buffer paths for morph targets<li>Added support for morph descriptor buffers in storage buffer path</ul><p>Key changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Updated layout creation to conditionally include storage buffer bindings
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>morphed_layout</span><span>(</span><span style=color:#ff8f40>render_device</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>RenderDevice) </span><span style=color:#61676ccc>-></span><span> BindGroupLayoutDescriptor {
</span><span>    </span><span style=color:#fa6e32>let</span><span> limits </span><span style=color:#ed9366>=</span><span> render_device</span><span style=color:#ed9366>.</span><span style=color:#f07171>limits</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> entries</span><span style=color:#61676ccc>: </span><span>ArrayVec&LTBindGroupLayoutEntry, 4> </span><span style=color:#ed9366>= </span><span>ArrayVec</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    entries</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>([
</span><span>        (</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span>layout_entry</span><span style=color:#ed9366>::</span><span>model(</span><span style=color:#ed9366>&</span><span>limits))</span><span style=color:#61676ccc>,
</span><span>        (</span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>, </span><span>layout_entry</span><span style=color:#ed9366>::</span><span>weights(</span><span style=color:#ed9366>&</span><span>limits))</span><span style=color:#61676ccc>,
</span><span>        (</span><span style=color:#ff8f40>3</span><span style=color:#61676ccc>, </span><span>layout_entry</span><span style=color:#ed9366>::</span><span>targets(</span><span style=color:#ed9366>&</span><span>limits))</span><span style=color:#61676ccc>,
</span><span>    ]</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|(</span><span style=color:#ff8f40>binding</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>entry</span><span>)| entry</span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>(</span><span style=color:#ed9366>*</span><span>binding</span><span style=color:#61676ccc>, </span><span>ShaderStages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>VERTEX</span><span>)))</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>skin</span><span style=color:#ed9366>::</span><span>skins_use_uniform_buffers(</span><span style=color:#ed9366>&</span><span>render_device</span><span style=color:#ed9366>.</span><span style=color:#f07171>limits</span><span>()) {
</span><span>        entries</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(layout_entry</span><span style=color:#ed9366>::</span><span>morph_descriptors()</span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>(</span><span style=color:#ff8f40>8</span><span style=color:#61676ccc>, </span><span>ShaderStages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>VERTEX</span><span>))</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    
</span><span>    BindGroupLayoutDescriptor</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#86b300>"morphed_mesh_layout"</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>entries)
</span><span>}
</span></code></pre><h3 id=crates-bevy-render-src-mesh-morph-rs-274-0><code>crates/bevy_render/src/mesh/morph.rs</code> (+274/-0)</h3><p>This is a new file that consolidates morph target rendering logic:<ul><li>Defines <code>MorphTargetImage</code> for texture-based morph targets<li>Implements <code>RenderMorphTargetAllocator</code> to manage morph target storage based on platform capabilities<li>Provides <code>MorphTargetsResource</code> enum to abstract texture vs buffer access</ul><p>Key code:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>RenderMorphTargetAllocator </span><span>{
</span><span>    Image {
</span><span>        mesh_id_to_image</span><span style=color:#61676ccc>: </span><span>HashMap&LTAssetId&LTMesh>, MorphTargetImage></span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    Storage</span><span style=color:#61676ccc>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>RenderMorphTargetAllocator </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>allocate</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>        </span><span style=color:#ff8f40>render_device</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>RenderDevice,
</span><span>        </span><span style=color:#ff8f40>render_queue</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>RenderQueue,
</span><span>        </span><span style=color:#ff8f40>mesh_id</span><span style=color:#61676ccc>: </span><span>AssetId&LTMesh>,
</span><span>        </span><span style=color:#ff8f40>targets</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[MorphAttributes],
</span><span>        </span><span style=color:#ff8f40>vertex_count</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>    ) {
</span><span>        </span><span style=color:#fa6e32>match </span><span style=color:#ed9366>*</span><span style=color:#55b4d4;font-style:italic>self </span><span>{
</span><span>            RenderMorphTargetAllocator</span><span style=color:#ed9366>::</span><span>Image { </span><span style=color:#fa6e32>ref mut</span><span> mesh_id_to_image } </span><span style=color:#ed9366>=> </span><span>{
</span><span>                </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(morph_target_image) </span><span style=color:#ed9366>=
</span><span>                    MorphTargetImage</span><span style=color:#ed9366>::</span><span>new(render_device</span><span style=color:#61676ccc>,</span><span> render_queue</span><span style=color:#61676ccc>,</span><span> targets</span><span style=color:#61676ccc>,</span><span> vertex_count)
</span><span>                {
</span><span>                    mesh_id_to_image</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(mesh_id</span><span style=color:#61676ccc>,</span><span> morph_target_image)</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            }
</span><span>            RenderMorphTargetAllocator</span><span style=color:#ed9366>::</span><span>Storage </span><span style=color:#ed9366>=> </span><span>{
</span><span>                </span><span style=color:#abb0b6;font-style:italic>// Do nothing. Morph target displacements are managed by the
</span><span>                </span><span style=color:#abb0b6;font-style:italic>// mesh allocator in this case.
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h3 id=examples-stress-tests-many-morph-targets-rs-200-53><code>examples/stress_tests/many_morph_targets.rs</code> (+200/-53)</h3><p>The example was updated to demonstrate the new API and test performance:<ul><li>Simplified morph target setup using the new vector-based API<li>Added various spawning patterns to test different batching scenarios<li>Improved animation variation to better stress test the system</ul><p>Key changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Manual MorphTargetImage creation
</span><span style=color:#fa6e32>let</span><span> morph_target_image </span><span style=color:#ed9366>= </span><span>MorphTargetImage</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>;
</span><span>mesh</span><span style=color:#ed9366>.</span><span style=color:#f07171>set_morph_targets</span><span>(handle)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Direct vector assignment
</span><span>mesh</span><span style=color:#ed9366>.</span><span style=color:#f07171>set_morph_targets</span><span>(
</span><span>    morph_target_reader
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>flat_map</span><span>(|</span><span style=color:#ff8f40>i</span><span>| PrimitiveMorphAttributesIter { </span><span style=color:#ed9366>... </span><span>})
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>WebGPU Storage Buffers</strong>: Understanding storage buffers is crucial for this PR. The <a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/#storage-buffer target=_blank>WebGPU specification</a> provides details on storage buffer usage and limitations.</p><li><p><strong>Morph Target Animation</strong>: For background on morph target animation techniques, the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Morph_target_animation target=_blank>Wikipedia article on morph target animation</a> provides a good overview.</p><li><p><strong>Bevy Mesh Allocator</strong>: The existing mesh allocator documentation in Bevy’s source code (<code>crates/bevy_render/src/mesh/allocator.rs</code>) provides context for how vertex and index data are managed.</p><li><p><strong>WGSL Shader Language</strong>: The <a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/WGSL/ target=_blank>WGSL specification</a> is useful for understanding the shader changes made in this PR, particularly around storage buffer access patterns.</p><li><p><strong>GPU-Driven Rendering</strong>: This PR moves Bevy further toward GPU-driven rendering architectures. Resources like <a rel="noopener nofollow noreferrer" href=https://advances.realtimerendering.com/s2021/index.html target=_blank>GPU-Driven Rendering</a> from Advances in Real-Time Rendering provide context for why batching is important.</p><li><p><strong>Bevy Rendering Architecture</strong>: The <a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/rendering/render-graph/ target=_blank>Bevy Render Graph documentation</a> helps understand how this PR fits into Bevy’s overall rendering pipeline.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23023.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>