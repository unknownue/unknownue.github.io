diff --git a/crates/bevy_image/src/image.rs b/crates/bevy_image/src/image.rs
index a74ef77a75920..bac725500afe7 100644
--- a/crates/bevy_image/src/image.rs
+++ b/crates/bevy_image/src/image.rs
@@ -1464,50 +1464,63 @@ impl Image {
 
     /// Compute the byte offset where the data of a specific pixel is stored
     ///
-    /// Returns None if the provided coordinates are out of bounds.
+    /// Returns an error if the provided coordinates are out of bounds.
     ///
     /// For 2D textures, Z is the layer number. For 1D textures, Y and Z are ignored.
     #[inline(always)]
-    pub fn pixel_data_offset(&self, coords: UVec3) -> Option<usize> {
+    pub fn pixel_data_offset(&self, coords: UVec3) -> Result<usize, TextureAccessError> {
         let width = self.texture_descriptor.size.width;
         let height = self.texture_descriptor.size.height;
         let depth = self.texture_descriptor.size.depth_or_array_layers;
 
-        let pixel_size = self.texture_descriptor.format.pixel_size().ok()?;
+        let pixel_size = self.texture_descriptor.format.pixel_size()?;
         let pixel_offset = match self.texture_descriptor.dimension {
             TextureDimension::D3 | TextureDimension::D2 => {
                 if coords.x >= width || coords.y >= height || coords.z >= depth {
-                    return None;
+                    return Err(TextureAccessError::OutOfBounds {
+                        x: coords.x,
+                        y: coords.y,
+                        z: coords.z,
+                    });
                 }
                 coords.z * height * width + coords.y * width + coords.x
             }
             TextureDimension::D1 => {
                 if coords.x >= width {
-                    return None;
+                    return Err(TextureAccessError::OutOfBounds {
+                        x: coords.x,
+                        y: coords.y,
+                        z: coords.z,
+                    });
                 }
                 coords.x
             }
         };
 
-        Some(pixel_offset as usize * pixel_size)
+        Ok(pixel_offset as usize * pixel_size)
     }
 
-    /// Get a reference to the data bytes where a specific pixel's value is stored
+    /// Get a reference to the data bytes where a specific pixel's value is stored.
     #[inline(always)]
-    pub fn pixel_bytes(&self, coords: UVec3) -> Option<&[u8]> {
-        let len = self.texture_descriptor.format.pixel_size().ok()?;
-        let data = self.data.as_ref()?;
-        self.pixel_data_offset(coords)
-            .map(|start| &data[start..(start + len)])
+    pub fn pixel_bytes(&self, coords: UVec3) -> Result<&[u8], TextureAccessError> {
+        let len = self.texture_descriptor.format.pixel_size()?;
+        let start = self.pixel_data_offset(coords)?;
+        let Some(data) = self.data.as_ref() else {
+            return Err(TextureAccessError::Uninitialized);
+        };
+        Ok(&data[start..(start + len)])
     }
 
-    /// Get a mutable reference to the data bytes where a specific pixel's value is stored
+    /// Get a mutable reference to the data bytes where a specific pixel's value is stored.
     #[inline(always)]
-    pub fn pixel_bytes_mut(&mut self, coords: UVec3) -> Option<&mut [u8]> {
-        let len = self.texture_descriptor.format.pixel_size().ok()?;
-        let offset = self.pixel_data_offset(coords);
-        let data = self.data.as_mut()?;
-        offset.map(|start| &mut data[start..(start + len)])
+    pub fn pixel_bytes_mut(&mut self, coords: UVec3) -> Result<&mut [u8], TextureAccessError> {
+        let len = self.texture_descriptor.format.pixel_size()?;
+        let offset = self.pixel_data_offset(coords)?;
+        let Some(data) = self.data.as_mut() else {
+            return Err(TextureAccessError::Uninitialized);
+        };
+
+        Ok(&mut data[offset..(offset + len)])
     }
 
     /// Clears the content of the image with the given pixel. The image needs to be initialized on
@@ -1659,13 +1672,7 @@ impl Image {
 
     #[inline(always)]
     fn get_color_at_internal(&self, coords: UVec3) -> Result<Color, TextureAccessError> {
-        let Some(bytes) = self.pixel_bytes(coords) else {
-            return Err(TextureAccessError::OutOfBounds {
-                x: coords.x,
-                y: coords.y,
-                z: coords.z,
-            });
-        };
+        let bytes = self.pixel_bytes(coords)?;
 
         // NOTE: GPUs are always Little Endian.
         // Make sure to respect that when we create color values from bytes.
@@ -1807,13 +1814,7 @@ impl Image {
     ) -> Result<(), TextureAccessError> {
         let format = self.texture_descriptor.format;
 
-        let Some(bytes) = self.pixel_bytes_mut(coords) else {
-            return Err(TextureAccessError::OutOfBounds {
-                x: coords.x,
-                y: coords.y,
-                z: coords.z,
-            });
-        };
+        let bytes = self.pixel_bytes_mut(coords)?;
 
         // NOTE: GPUs are always Little Endian.
         // Make sure to respect that when we convert color values to bytes.
@@ -2007,6 +2008,8 @@ pub enum TextureAccessError {
     OutOfBounds { x: u32, y: u32, z: u32 },
     #[error("unsupported texture format: {0:?}")]
     UnsupportedTextureFormat(TextureFormat),
+    #[error("image data is not initialized")]
+    Uninitialized,
     #[error("attempt to access texture with different dimension")]
     WrongDimension,
 }
@@ -2217,6 +2220,34 @@ mod test {
         ));
     }
 
+    #[test]
+    fn compressed_texture_format_is_reported_correctly() {
+        let mut image = Image::new_uninit(
+            Extent3d {
+                width: 4,
+                height: 4,
+                depth_or_array_layers: 1,
+            },
+            TextureDimension::D2,
+            TextureFormat::Bc1RgbaUnorm,
+            RenderAssetUsages::MAIN_WORLD,
+        );
+
+        assert!(matches!(
+            image.get_color_at(0, 0),
+            Err(TextureAccessError::UnsupportedTextureFormat(
+                TextureFormat::Bc1RgbaUnorm
+            ))
+        ));
+
+        assert!(matches!(
+            image.set_color_at(0, 0, Color::WHITE),
+            Err(TextureAccessError::UnsupportedTextureFormat(
+                TextureFormat::Bc1RgbaUnorm
+            ))
+        ));
+    }
+
     #[test]
     fn get_set_pixel_2d_with_layers() {
         let mut image = Image::new_fill(
diff --git a/release-content/migration-guides/image_pixel_bytes_result.md b/release-content/migration-guides/image_pixel_bytes_result.md
new file mode 100644
index 0000000000000..17839bbdc6fae
--- /dev/null
+++ b/release-content/migration-guides/image_pixel_bytes_result.md
@@ -0,0 +1,48 @@
+---
+title: "`Image::pixel_bytes` and `Image::pixel_data_offset` now return `Result`"
+pull_requests: [22908]
+---
+
+`Image::pixel_bytes`, `Image::pixel_bytes_mut`, and
+`Image::pixel_data_offset` now return `Result<..., TextureAccessError>`.
+
+Previously, these methods returned `Option` and would silently fail for
+both out-of-bounds access and unsupported texture formats (such as
+compressed textures). This caused error information to be lost, making it
+impossible for callers to distinguish between these different failure
+cases.
+
+Now, these methods properly propagate `TextureAccessError`:
+
+- `TextureAccessError::OutOfBounds` for coordinates outside the image
+  bounds
+- `TextureAccessError::UnsupportedTextureFormat` for compressed or
+  unsupported texture formats
+- `TextureAccessError::Uninitialized` if the image data is not initialized
+
+## Migration
+
+Update any code using these methods to handle the `Result` return type:
+
+```rust
+// Before
+if let Some(bytes) = image.pixel_bytes(coords) {
+    // use bytes
+}
+
+// After
+match image.pixel_bytes(coords) {
+    Ok(bytes) => {
+        // use bytes
+    }
+    Err(TextureAccessError::Uninitialized) => {
+        // handle missing image data
+    }
+    Err(TextureAccessError::OutOfBounds { .. }) => {
+        // handle out of bounds
+    }
+    Err(TextureAccessError::UnsupportedTextureFormat(format)) => {
+        // handle compressed/unsupported format
+    }
+}
+```
