<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #18536 Add `many_morph_targets` stress test
        
    </title><meta content="#18536 Add `many_morph_targets` stress test" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-17</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-18536-zh-cn-20260217>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Add <code>many_morph_targets</code> stress test<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add <code>many_morph_targets</code> stress test<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/18536<li><strong>Author</strong>: greeble-dev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, S-Ready-For-For-Review, A-Animation, D-Modest<li><strong>Created</strong>: 2025-03-25T11:57:57Z<li><strong>Merged</strong>: 2026-02-16T23:24:56Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>The original description is in English and is included exactly as-is below:<h3 id=objective>Objective</h3><p>I wanted to benchmark the morph target changes in #18465. I also wanted to test morph targets on multiple meshes, which is not covered by existing examples.<h3 id=solution>Solution</h3><p>Add a stress test for morph targets, similar to <code>many_cubes</code> and <code>many_foxes</code>. Spawns a ton of meshes (defaults to 1024) and animates their morph target weights.<p><img alt=425571366-b043c16c-6e6a-491e-a0bd-5ece630d7bf8 src=https://github.com/user-attachments/assets/86ef26a4-ad00-46fa-9e5a-0aa4238023e3><h3 id=testing>Testing</h3><pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> many_morph_targets
</span><span>
</span><span style=color:#abb0b6;font-style:italic># Test different mesh counts.
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> many_morph_targets</span><span style=color:#ed9366> --</span><span> --count 42
</span></code></pre><p>Tested on Win10/Vulkan/Nvidia, Wasm/WebGL/Chrome/Win10/Nvidia.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a specific gap in Bevy’s stress testing suite by introducing a dedicated benchmark for morph target performance. The developer needed to evaluate changes from PR #18465, which likely involved optimizations or modifications to morph target handling, and recognized that existing examples didn’t adequately test morph targets across multiple meshes simultaneously.<p>Morph targets (also known as blend shapes) are a technique for animating mesh deformations by interpolating between different vertex positions. They’re commonly used for facial animations, where different expressions are stored as target shapes. The performance characteristics of morph targets are important because they affect both vertex processing (interpolating between shapes) and potentially pixel shading (if normal maps are affected).<p>The solution follows the established pattern of Bevy’s stress tests like <code>many_cubes</code> and <code>many_foxes</code>. These tests serve dual purposes: they’re useful for performance benchmarking and regression testing, and they also demonstrate engine capabilities to users. The implementation creates a configurable stress test that can spawn many meshes with animated morph targets, providing a controlled environment for measuring rendering performance under heavy morph target usage.<p>The implementation is thoughtful about test configuration. The developer added command-line arguments to control:<ul><li>The number of meshes (<code>--count</code>)<li>How morph weights are set (<code>--weights</code> with options: animated, one, zero, tiny)<li>Camera distance (<code>--camera</code> with options: near, far)</ul><p>These options allow isolating different performance aspects. For example, setting weights to “zero” minimizes vertex shader cost while “tiny” keeps vertex shader work similar to “one” but reduces pixel shader impact. The camera distance control helps separate vertex processing costs (more visible when zoomed in) from pixel shading costs (more relevant when zoomed out).<p>The code structure is clean and follows Bevy conventions. It uses the <code>argh</code> crate for command-line parsing (consistent with other examples), sets up a 3D scene with appropriate lighting and camera positioning, and organizes the meshes in a grid pattern for predictable rendering. The animation system is well-implemented, loading three different animation clips from the glTF asset and applying them with randomized speeds to ensure stable morph target distribution across frames.<p>One technical insight from the implementation is the use of observer systems (<code>observe()</code> method) to trigger actions when scene instances become ready. This pattern is necessary because glTF assets load asynchronously - the animation players and morph weight components don’t exist immediately when entities are spawned. The <code>play_animation</code> and <code>set_weights</code> systems wait for the <code>SceneInstanceReady</code> event before manipulating the animation players and morph weights.<p>The impact of this PR is straightforward but valuable: it provides a dedicated tool for benchmarking morph target performance, which is particularly important for games and applications that rely heavily on character animations. By adding this to the official examples, it becomes part of Bevy’s continuous integration testing, helping catch performance regressions in morph target handling. The example also serves as educational material for developers wanting to understand how to work with morph targets in Bevy.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Args struct] --> B[main function]
</span><span>    B --> C[setup system]
</span><span>    C --> D[Spawn meshes in grid]
</span><span>    C --> E[Spawn camera & light]
</span><span>    D --> F[For each mesh]
</span><span>    F --> G[Create AnimationToPlay]
</span><span>    F --> H[Set transform]
</span><span>    F --> I[Add observers]
</span><span>    I --> J[play_animation system]
</span><span>    I --> K[set_weights system]
</span><span>    J --> L[AnimationPlayer control]
</span><span>    K --> M[MorphWeights modification]
</span><span>    
</span><span>    style A fill:#e1f5fe
</span><span>    style J fill:#f1f8e9
</span><span>    style K fill:#f1f8e9
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-examples-stress-tests-many-morph-targets-rs-245-0>1. <code>examples/stress_tests/many_morph_targets.rs</code> (+245/-0)</h3><p>This is the main implementation file, created from scratch. It contains the complete stress test example.<p><strong>Key code sections:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Command-line argument definitions
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(FromArgs</span><span style=color:#61676ccc>,</span><span> Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Args </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>argh</span><span>(option</span><span style=color:#61676ccc>,</span><span> default </span><span style=color:#ed9366>= </span><span style=color:#86b300>"1024"</span><span>)]
</span><span>    count</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>    
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>argh</span><span>(option</span><span style=color:#61676ccc>,</span><span> default </span><span style=color:#ed9366>= </span><span style=color:#86b300>"ArgWeights::Animated"</span><span>)]
</span><span>    weights</span><span style=color:#61676ccc>:</span><span> ArgWeights,
</span><span>    
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>argh</span><span>(option</span><span style=color:#61676ccc>,</span><span> default </span><span style=color:#ed9366>= </span><span style=color:#86b300>"ArgCamera::Near"</span><span>)]
</span><span>    camera</span><span style=color:#61676ccc>:</span><span> ArgCamera,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Main setup function - arranges meshes in a grid
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>setup</span><span>(</span><span style=color:#ff8f40>args</span><span style=color:#61676ccc>: </span><span>Res&LTArgs>, </span><span style=color:#ff8f40>asset_server</span><span style=color:#61676ccc>: </span><span>Res&LTAssetServer>, </span><span style=color:#abb0b6;font-style:italic>/* ... */</span><span>) {
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ASSET_PATH</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str </span><span style=color:#ed9366>= </span><span style=color:#86b300>"models/animated/MorphStressTest.gltf"</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> scene </span><span style=color:#ed9366>=</span><span> SceneRoot(asset_server</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(GltfAssetLabel</span><span style=color:#ed9366>::</span><span>Scene(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>from_asset</span><span>(</span><span style=color:#ff8f40>ASSET_PATH</span><span>)))</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Arrange meshes in a grid
</span><span>    </span><span style=color:#fa6e32>let</span><span> count </span><span style=color:#ed9366>=</span><span> args</span><span style=color:#ed9366>.</span><span>count</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> x_dim </span><span style=color:#ed9366>= </span><span>((count </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>sqrt</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>ceil</span><span>() </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> y_dim </span><span style=color:#ed9366>=</span><span> count</span><span style=color:#ed9366>.</span><span style=color:#f07171>div_ceil</span><span>(x_dim)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>for</span><span> mesh_index </span><span style=color:#ed9366>in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span>count {
</span><span>        </span><span style=color:#fa6e32>let</span><span> x </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>2.5 </span><span style=color:#ed9366>+ </span><span>(</span><span style=color:#ff8f40>5.0 </span><span style=color:#ed9366>* </span><span>((mesh_index</span><span style=color:#ed9366>.</span><span style=color:#f07171>rem_euclid</span><span>(x_dim) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#ed9366>- </span><span>((x_dim </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>0.5</span><span>)))</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> y </span><span style=color:#ed9366>= -</span><span style=color:#ff8f40>2.2 </span><span style=color:#ed9366>- </span><span>(</span><span style=color:#ff8f40>3.0 </span><span style=color:#ed9366>* </span><span>((mesh_index</span><span style=color:#ed9366>.</span><span style=color:#f07171>div_euclid</span><span>(x_dim) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#ed9366>- </span><span>((y_dim </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>0.5</span><span>)))</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((animation</span><span style=color:#ed9366>.</span><span style=color:#f07171>with_speed</span><span>(animation_speed)</span><span style=color:#61676ccc>,</span><span> scene</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>, </span><span>Transform</span><span style=color:#ed9366>::</span><span>from_xyz(x</span><span style=color:#61676ccc>,</span><span> y</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.0</span><span>)))
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>observe</span><span>(play_animation)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>observe</span><span>(set_weights)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// System to set morph weights when scene is ready
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>set_weights</span><span>(</span><span style=color:#ff8f40>trigger</span><span style=color:#61676ccc>: </span><span>On&LTSceneInstanceReady>, </span><span style=color:#ff8f40>args</span><span style=color:#61676ccc>: </span><span>Res&LTArgs>, </span><span style=color:#abb0b6;font-style:italic>/* ... */</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(weight_value) </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> args</span><span style=color:#ed9366>.</span><span>weights {
</span><span>        ArgWeights</span><span style=color:#ed9366>::</span><span>One </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ff8f40>1.0</span><span>)</span><span style=color:#61676ccc>,
</span><span>        ArgWeights</span><span style=color:#ed9366>::</span><span>Zero </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#61676ccc>,
</span><span>        ArgWeights</span><span style=color:#ed9366>::</span><span>Tiny </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ff8f40>0.00001</span><span>)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>_ => </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,
</span><span>    } {
</span><span>        </span><span style=color:#fa6e32>for</span><span> child </span><span style=color:#ed9366>in</span><span> children</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_descendants</span><span>(trigger</span><span style=color:#ed9366>.</span><span>entity) {
</span><span>            </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#fa6e32>mut</span><span> weight_component) </span><span style=color:#ed9366>=</span><span> weight_components</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(child) {
</span><span>                weight_component</span><span style=color:#ed9366>.</span><span style=color:#f07171>weights_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>fill</span><span>(weight_value)</span><span style=color:#61676ccc>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h3 id=2-cargo-toml-11-0>2. <code>Cargo.toml</code> (+11/-0)</h3><p>Added the new example to the examples list with appropriate metadata.<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[[</span><span style=color:#399ee6>example</span><span>]]
</span><span style=color:#399ee6>name </span><span>= </span><span style=color:#86b300>"many_morph_targets"
</span><span style=color:#399ee6>path </span><span>= </span><span style=color:#86b300>"examples/stress_tests/many_morph_targets.rs"
</span><span style=color:#399ee6>doc-scrape-examples </span><span>= </span><span style=color:#ff8f40>true
</span><span>
</span><span>[</span><span style=color:#399ee6>package</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>metadata</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>example</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>many_morph_targets</span><span>]
</span><span style=color:#399ee6>name </span><span>= </span><span style=color:#86b300>"Many Morph Targets"
</span><span style=color:#399ee6>description </span><span>= </span><span style=color:#86b300>"Simple benchmark to test rendering many meshes with animated morph targets."
</span><span style=color:#399ee6>category </span><span>= </span><span style=color:#86b300>"Stress Tests"
</span><span style=color:#399ee6>wasm </span><span>= </span><span style=color:#ff8f40>true
</span></code></pre><h3 id=3-examples-readme-md-1-0>3. <code>examples/README.md</code> (+1/-0)</h3><p>Added documentation for the new example in the stress tests section.<pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span>[Many Morph Targets](</span><span style=color:#4cbf99;font-style:italic;text-decoration:underline>../examples/stress_tests/many_morph_targets.rs</span><span>) | Simple benchmark to test rendering many meshes with animated morph targets.
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy Documentation on Morph Targets</strong>: The official Bevy documentation provides information on how morph targets work in the engine.<li><strong>glTF Morph Target Specification</strong>: The Khronos glTF specification details how morph targets are stored and animated in glTF files.<li><strong>Computer Graphics - Blend Shapes</strong>: Academic and technical resources on blend shape animation techniques.<li><strong>Bevy Animation System</strong>: Documentation on Bevy’s animation system, including animation graphs and players.<li><strong>Performance Profiling in Bevy</strong>: Resources on using Bevy’s diagnostic plugins and performance measurement tools.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_18536.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>