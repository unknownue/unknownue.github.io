diff --git a/crates/bevy_feathers/Cargo.toml b/crates/bevy_feathers/Cargo.toml
index 5d2ee7860aeda..0247e9690fc9e 100644
--- a/crates/bevy_feathers/Cargo.toml
+++ b/crates/bevy_feathers/Cargo.toml
@@ -40,6 +40,8 @@ accesskit = "0.23"
 [features]
 default = []
 custom_cursor = ["bevy_window/custom_cursor"]
+webgl = []
+webgpu = []
 
 [lints]
 workspace = true
diff --git a/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl b/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl
index 738c74937c29e..9a808be46b6ad 100644
--- a/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl
+++ b/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl
@@ -5,21 +5,28 @@
     hsl_to_linear_rgb,
 }
 
-@group(1) @binding(0) var<uniform> fixed_channel: f32;
+struct ColorPlaneUniform {
+  fixed_channel : f32,
+#ifdef SIXTEEN_BYTE_ALIGNMENT
+  _webgl2_padding_12b : vec3<f32>,
+#endif
+}
+
+@group(1) @binding(0) var<uniform> uniform_data : ColorPlaneUniform;
 
 @fragment
 fn fragment(in: UiVertexOutput) -> @location(0) vec4<f32> {
     let uv = in.uv;
 #ifdef PLANE_RG
-    return vec4(srgb_to_linear_rgb(vec3(uv.x, uv.y, fixed_channel)), 1.0);
+    return vec4(srgb_to_linear_rgb(vec3(uv.x, uv.y, uniform_data.fixed_channel)), 1.0);
 #else ifdef PLANE_RB
-    return vec4(srgb_to_linear_rgb(vec3(uv.x, fixed_channel, uv.y)), 1.0);
+    return vec4(srgb_to_linear_rgb(vec3(uv.x, uniform_data.fixed_channel, uv.y)), 1.0);
 #else ifdef PLANE_GB
-    return vec4(srgb_to_linear_rgb(vec3(fixed_channel, uv.x, uv.y)), 1.0);
+    return vec4(srgb_to_linear_rgb(vec3(uniform_data.fixed_channel, uv.x, uv.y)), 1.0);
 #else ifdef PLANE_HS
-    return vec4(hsl_to_linear_rgb(vec3(uv.x, 1.0 - uv.y, fixed_channel)), 1.0);
+    return vec4(hsl_to_linear_rgb(vec3(uv.x, 1.0 - uv.y, uniform_data.fixed_channel)), 1.0);
 #else ifdef PLANE_HL
-    return vec4(hsl_to_linear_rgb(vec3(uv.x, fixed_channel, 1.0 - uv.y)), 1.0);
+    return vec4(hsl_to_linear_rgb(vec3(uv.x, uniform_data.fixed_channel, 1.0 - uv.y)), 1.0);
 #else
     // Error color
     return vec4(1.0, 0.0, 1.0, 1.0);
diff --git a/crates/bevy_feathers/src/controls/color_plane.rs b/crates/bevy_feathers/src/controls/color_plane.rs
index c0398fe8b47cb..8051a74748124 100644
--- a/crates/bevy_feathers/src/controls/color_plane.rs
+++ b/crates/bevy_feathers/src/controls/color_plane.rs
@@ -84,6 +84,10 @@ struct ColorPlaneMaterial {
 
     #[uniform(0)]
     fixed_channel: f32,
+
+    #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
+    #[uniform(0)]
+    _webgl2_padding_12b: Vec3,
 }
 
 impl From<&ColorPlaneMaterial> for ColorPlaneMaterialKey {
@@ -207,6 +211,8 @@ fn update_plane_color(
             let material = r_materials.add(ColorPlaneMaterial {
                 plane: *plane,
                 fixed_channel: plane_value.0.z,
+                #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
+                _webgl2_padding_12b: Default::default(),
             });
             commands.entity(*inner_ent).insert(MaterialNode(material));
         }
diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index 25fe37c361b53..49271579c6c85 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -191,6 +191,7 @@ webgl = [
   "bevy_gizmos_render?/webgl",
   "bevy_sprite_render?/webgl",
   "bevy_dev_tools?/webgl",
+  "bevy_feathers?/webgl",
 ]
 
 webgpu = [
@@ -201,6 +202,7 @@ webgpu = [
   "bevy_gizmos_render?/webgpu",
   "bevy_sprite_render?/webgpu",
   "bevy_dev_tools?/webgpu",
+  "bevy_feathers?/webgpu",
 ]
 
 # Enable systems that allow for automated testing on CI
