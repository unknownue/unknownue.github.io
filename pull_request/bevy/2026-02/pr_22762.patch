diff --git a/crates/bevy_gizmos/src/aabb.rs b/crates/bevy_gizmos/src/aabb.rs
index 2f8c8e17f2a89..f0f469d0f35a3 100644
--- a/crates/bevy_gizmos/src/aabb.rs
+++ b/crates/bevy_gizmos/src/aabb.rs
@@ -2,7 +2,7 @@
 
 use bevy_app::{Plugin, PostUpdate};
 use bevy_camera::{primitives::Aabb, visibility::ViewVisibility};
-use bevy_color::{Color, Oklcha};
+use bevy_color::Color;
 use bevy_ecs::{
     component::Component,
     entity::Entity,
@@ -15,6 +15,7 @@ use bevy_reflect::{std_traits::ReflectDefault, Reflect};
 use bevy_transform::{components::GlobalTransform, TransformSystems};
 
 use crate::{
+    color_from_entity,
     config::{GizmoConfigGroup, GizmoConfigStore},
     gizmos::Gizmos,
     AppGizmoBuilder,
@@ -112,7 +113,3 @@ fn draw_all_aabbs(
 fn is_visible(view_visibility: Option<&ViewVisibility>) -> bool {
     view_visibility.is_some_and(|v| v.get())
 }
-
-fn color_from_entity(entity: Entity) -> Color {
-    Oklcha::sequential_dispersed(entity.index_u32()).into()
-}
diff --git a/crates/bevy_gizmos/src/frustum.rs b/crates/bevy_gizmos/src/frustum.rs
new file mode 100644
index 0000000000000..a0b8eb4ac3897
--- /dev/null
+++ b/crates/bevy_gizmos/src/frustum.rs
@@ -0,0 +1,149 @@
+//! Module for the drawing of [`Frustum`]s.
+//!
+//! Camera entities are spawned with a [`Frustum`] component,
+//! which describes a camera's field of vision. With this module,
+//! a camera's frustum can be drawn with gizmos. This is useful
+//! for debugging what a camera can see and what entities in the scene
+//! will be subject to the camera's frustum culling, especially when
+//! combined with drawing [`Aabb`](bevy_camera::primitives::Aabb)
+//! [`gizmos`](crate::aabb).
+//!
+//! There are two ways to enable gizmo drawing of a [`Frustum`]:
+//! 1) The [`ShowFrustumGizmo`] component can be added to individual camera
+//!    entities.
+//! ```rust
+//! # use bevy_gizmos::frustum::ShowFrustumGizmo;
+//! # use bevy_camera::Camera2d;
+//! # use bevy_ecs::system::Commands;
+//! fn setup(mut commands: Commands) {
+//!     commands.spawn((Camera2d, ShowFrustumGizmo::default()));
+//! }
+//! ```
+//! 2) Setting the [`FrustumGizmoConfigGroup`] configuration's `draw_all`
+//!    field to `true` will draw every frustum. Note that this will include
+//!    drawing `bevy_light` `SpotLight` [`Frustum`]s.
+//! ```rust
+//! # use bevy_ecs::prelude::*;
+//! # use bevy_gizmos::prelude::*;
+//! fn turn_on_frustum_gizmos(mut config: ResMut<GizmoConfigStore>) {
+//!    config.config_mut::<FrustumGizmoConfigGroup>().1.draw_all = true;
+//! }
+//! ```
+
+use bevy_app::{Plugin, PostUpdate};
+use bevy_camera::{primitives::Frustum, visibility::VisibilitySystems};
+use bevy_color::Color;
+use bevy_ecs::{
+    component::Component,
+    entity::Entity,
+    query::Without,
+    reflect::ReflectComponent,
+    schedule::{IntoScheduleConfigs, SystemSet},
+    system::{Query, Res},
+};
+use bevy_reflect::{std_traits::ReflectDefault, Reflect, ReflectFromReflect};
+
+use crate::{
+    color_from_entity,
+    config::{GizmoConfigGroup, GizmoConfigStore},
+    gizmos::Gizmos,
+    AppGizmoBuilder,
+};
+
+/// A [`Plugin`] that provides visualization of [`Frustum`]s for debugging.
+pub struct FrustumGizmoPlugin;
+
+/// Frustum Gizmo system set. This exists in [`PostUpdate`].
+#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]
+pub struct FrustumGizmoSystems;
+
+impl Plugin for FrustumGizmoPlugin {
+    fn build(&self, app: &mut bevy_app::App) {
+        app.init_gizmo_group::<FrustumGizmoConfigGroup>()
+            .add_systems(
+                PostUpdate,
+                (
+                    draw_frustum_gizmos,
+                    draw_all_frustum_gizmos.run_if(|config: Res<GizmoConfigStore>| {
+                        config.config::<FrustumGizmoConfigGroup>().1.draw_all
+                    }),
+                )
+                    .in_set(FrustumGizmoSystems)
+                    .after(VisibilitySystems::UpdateFrusta),
+            );
+    }
+}
+
+/// The [`GizmoConfigGroup`] used for debug visualizations of [`Frustum`] components on entities
+#[derive(Clone, Default, Reflect, GizmoConfigGroup)]
+#[reflect(Clone, Default)]
+pub struct FrustumGizmoConfigGroup {
+    /// Draws all frusta in the scene when set to `true`.
+    ///
+    /// To draw a specific entity's frustum, you can add the [`ShowFrustumGizmo`] component.
+    ///
+    /// Defaults to `false`.
+    pub draw_all: bool,
+    /// The default color for frustum gizmos.
+    ///
+    /// A random color is chosen per frustum if `None`.
+    ///
+    /// Defaults to `None`.
+    pub default_color: Option<Color>,
+}
+
+/// Add this [`Component`] to an entity to draw its [`Frustum`] component.
+#[derive(Component, Reflect, Default, Debug)]
+#[reflect(Component, FromReflect, Default)]
+pub struct ShowFrustumGizmo {
+    /// The color of the frustum.
+    ///
+    /// The default color from the [`FrustumGizmoConfigGroup`] resource is used if `None`,
+    pub color: Option<Color>,
+}
+
+fn draw_frustum_gizmos(
+    query: Query<(Entity, &Frustum, &ShowFrustumGizmo)>,
+    mut gizmos: Gizmos<FrustumGizmoConfigGroup>,
+) {
+    for (entity, &frustum, gizmo) in &query {
+        let color = gizmo
+            .color
+            .or(gizmos.config_ext.default_color)
+            .unwrap_or_else(|| color_from_entity(entity));
+
+        frustum_inner(&frustum, color, &mut gizmos);
+    }
+}
+
+fn draw_all_frustum_gizmos(
+    query: Query<(Entity, &Frustum), Without<ShowFrustumGizmo>>,
+    mut gizmos: Gizmos<FrustumGizmoConfigGroup>,
+) {
+    for (entity, &frustum) in &query {
+        let color = gizmos
+            .config_ext
+            .default_color
+            .unwrap_or_else(|| color_from_entity(entity));
+
+        frustum_inner(&frustum, color, &mut gizmos);
+    }
+}
+
+fn frustum_inner(frustum: &Frustum, color: Color, gizmos: &mut Gizmos<FrustumGizmoConfigGroup>) {
+    let Some([tln, trn, brn, bln, tlf, trf, brf, blf]) = frustum.corners() else {
+        return;
+    };
+
+    gizmos.linestrip(
+        [
+            tln, trn, brn, bln, // Near
+            tln, tlf, // Top Left Near to Far
+            trf, brf, blf, tlf, // Far
+        ],
+        color,
+    );
+    gizmos.line(trn, trf, color); // Top Right Near to Far
+    gizmos.line(brn, brf, color); // Bottom Right Near to Far
+    gizmos.line(bln, blf, color); // Bottom Left Near to Far
+}
diff --git a/crates/bevy_gizmos/src/lib.rs b/crates/bevy_gizmos/src/lib.rs
index 9cf6d38892b90..ab64e5457c0f5 100755
--- a/crates/bevy_gizmos/src/lib.rs
+++ b/crates/bevy_gizmos/src/lib.rs
@@ -29,6 +29,7 @@ pub mod circles;
 pub mod config;
 pub mod cross;
 pub mod curves;
+pub mod frustum;
 pub mod gizmos;
 mod global;
 pub mod grid;
@@ -45,6 +46,7 @@ pub mod skinned_mesh_bounds;
 pub mod prelude {
     #[doc(hidden)]
     pub use crate::aabb::{AabbGizmoConfigGroup, ShowAabbGizmo};
+    pub use crate::frustum::{FrustumGizmoConfigGroup, ShowFrustumGizmo};
 
     #[doc(hidden)]
     #[cfg(feature = "bevy_mesh")]
@@ -68,7 +70,9 @@ pub mod prelude {
 
 use bevy_app::{App, FixedFirst, FixedLast, Last, Plugin, RunFixedMainLoop};
 use bevy_asset::{Asset, AssetApp, Assets, Handle};
+use bevy_color::{Color, Oklcha};
 use bevy_ecs::{
+    prelude::Entity,
     resource::Resource,
     schedule::{IntoScheduleConfigs, SystemSet},
     system::{Res, ResMut},
@@ -97,7 +101,11 @@ impl Plugin for GizmoPlugin {
             // We insert the Resource GizmoConfigStore into the world implicitly here if it does not exist.
             .init_gizmo_group::<DefaultGizmoConfigGroup>();
 
-        app.add_plugins((aabb::AabbGizmoPlugin, global::GlobalGizmosPlugin));
+        app.add_plugins((
+            aabb::AabbGizmoPlugin,
+            frustum::FrustumGizmoPlugin,
+            global::GlobalGizmosPlugin,
+        ));
 
         #[cfg(feature = "bevy_mesh")]
         app.add_plugins(SkinnedMeshBoundsGizmoPlugin);
@@ -338,3 +346,8 @@ impl Default for GizmoAsset {
         GizmoAsset::new()
     }
 }
+
+/// Generates a random, well-dispersed color seeded by the provided `Entity`.
+pub fn color_from_entity(entity: Entity) -> Color {
+    Oklcha::sequential_dispersed(entity.index_u32()).into()
+}
diff --git a/crates/bevy_light/src/lib.rs b/crates/bevy_light/src/lib.rs
index f2619208106a3..ffeba78233444 100644
--- a/crates/bevy_light/src/lib.rs
+++ b/crates/bevy_light/src/lib.rs
@@ -14,6 +14,8 @@ use bevy_camera::{
     CameraUpdateSystems,
 };
 use bevy_ecs::{entity::EntityHashSet, prelude::*};
+#[cfg(feature = "bevy_gizmos")]
+use bevy_gizmos::frustum::FrustumGizmoSystems;
 use bevy_math::Vec3A;
 use bevy_mesh::Mesh3d;
 use bevy_reflect::prelude::*;
@@ -190,6 +192,13 @@ impl Plugin for LightPlugin {
                         .in_set(SimulationLightSystems::UpdateLightFrusta)
                         .after(TransformSystems::Propagate)
                         .after(SimulationLightSystems::AssignLightsToClusters),
+                    #[cfg(feature = "bevy_gizmos")]
+                    update_spot_light_frusta
+                        .in_set(SimulationLightSystems::UpdateLightFrusta)
+                        .before(FrustumGizmoSystems)
+                        .after(TransformSystems::Propagate)
+                        .after(SimulationLightSystems::AssignLightsToClusters),
+                    #[cfg(not(feature = "bevy_gizmos"))]
                     update_spot_light_frusta
                         .in_set(SimulationLightSystems::UpdateLightFrusta)
                         .after(TransformSystems::Propagate)
diff --git a/crates/bevy_math/src/primitives/half_space.rs b/crates/bevy_math/src/primitives/half_space.rs
index 3bf9a945ee053..d53e269bbfed3 100644
--- a/crates/bevy_math/src/primitives/half_space.rs
+++ b/crates/bevy_math/src/primitives/half_space.rs
@@ -1,4 +1,4 @@
-use crate::{Vec3A, Vec4, Vec4Swizzles};
+use crate::{ops, Vec3, Vec3A, Vec4, Vec4Swizzles};
 
 #[cfg(feature = "bevy_reflect")]
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
@@ -75,4 +75,79 @@ impl HalfSpace {
     pub fn normal_d(&self) -> Vec4 {
         self.normal_d
     }
+
+    /// Returns the intersection point if the three halfspaces all intersect at a single point.
+    #[inline]
+    pub fn intersection_point(a: HalfSpace, b: HalfSpace, c: HalfSpace) -> Option<Vec3> {
+        let an = a.normal();
+        let bn = b.normal();
+        let cn = c.normal();
+
+        let x = Vec3A::new(an.x, bn.x, cn.x);
+        let y = Vec3A::new(an.y, bn.y, cn.y);
+        let z = Vec3A::new(an.z, bn.z, cn.z);
+
+        let d = -Vec3A::new(a.d(), b.d(), c.d());
+
+        let u = y.cross(z);
+        let v = x.cross(d);
+
+        let denom = x.dot(u);
+
+        if ops::abs(denom) < f32::EPSILON {
+            return None;
+        }
+
+        Some(Vec3::new(d.dot(u), z.dot(v), -y.dot(v)) / denom)
+    }
+}
+
+#[cfg(test)]
+mod half_space_tests {
+    use core::f32;
+
+    use approx::assert_relative_eq;
+
+    use super::HalfSpace;
+    use crate::{Vec3, Vec4};
+
+    #[test]
+    fn intersection_point() {
+        // Intersection of shifted xy, xz, and yz planes
+        let xy_at_z_3 = HalfSpace {
+            normal_d: Vec4::new(0., 0., -1., 3.),
+        };
+        let xz_at_y_2 = HalfSpace {
+            normal_d: Vec4::new(0., 1., 0., -2.),
+        };
+        let yz_at_x_1 = HalfSpace {
+            normal_d: Vec4::new(1., 0., 0., -1.),
+        };
+        assert_relative_eq!(
+            HalfSpace::intersection_point(xy_at_z_3, xz_at_y_2, yz_at_x_1).unwrap(),
+            Vec3::new(1., 2., 3.),
+            epsilon = 2e-7
+        );
+
+        // Three planes that do not simultaneously intersect
+        let xz_at_y_3 = HalfSpace {
+            normal_d: Vec4::new(0., 1., 0., -3.),
+        };
+        assert!(HalfSpace::intersection_point(xy_at_z_3, xz_at_y_2, xz_at_y_3).is_none());
+
+        // Three planes that intersect at a line
+        let other_xz_at_y_2 = HalfSpace {
+            normal_d: Vec4::new(0., -1., 0., 3.),
+        };
+        assert!(HalfSpace::intersection_point(xy_at_z_3, xz_at_y_2, other_xz_at_y_2).is_none());
+
+        // Three identical planes
+        assert!(HalfSpace::intersection_point(xz_at_y_2, xz_at_y_2, other_xz_at_y_2).is_none());
+
+        // ill-defined halfspace
+        let ill_defined = HalfSpace {
+            normal_d: Vec4::new(0., 0., 0., f32::INFINITY),
+        };
+        assert!(HalfSpace::intersection_point(xy_at_z_3, xz_at_y_2, ill_defined).is_none());
+    }
 }
diff --git a/crates/bevy_math/src/primitives/view_frustum.rs b/crates/bevy_math/src/primitives/view_frustum.rs
index d0048c385e833..604aee6f155aa 100644
--- a/crates/bevy_math/src/primitives/view_frustum.rs
+++ b/crates/bevy_math/src/primitives/view_frustum.rs
@@ -61,6 +61,28 @@ impl ViewFrustum {
         frustum
     }
 
+    /// Calculates the corners of this frustum. Returns `None` if the frustum isn't properly defined.
+    ///
+    /// If `Some`, the corners are returned in the following order:
+    /// near top left, near top right, near bottom right, near bottom left,
+    /// far top left, far top right, far bottom right, far bottom left.
+    /// If the far plane is an inactive half space, the intersection points
+    /// that include the far plane will be `Vec3::NAN`.
+    #[inline]
+    pub fn corners(&self) -> Option<[Vec3; 8]> {
+        let [left, right, top, bottom, near, far] = self.half_spaces;
+        Some([
+            HalfSpace::intersection_point(top, left, near)?,
+            HalfSpace::intersection_point(top, right, near)?,
+            HalfSpace::intersection_point(bottom, right, near)?,
+            HalfSpace::intersection_point(bottom, left, near)?,
+            HalfSpace::intersection_point(top, left, far)?,
+            HalfSpace::intersection_point(top, right, far)?,
+            HalfSpace::intersection_point(bottom, right, far)?,
+            HalfSpace::intersection_point(bottom, left, far)?,
+        ])
+    }
+
     // NOTE: This approach of extracting the frustum half-space from the view
     // projection matrix is from Foundations of Game Engine Development 2
     // Rendering by Lengyel.
@@ -84,3 +106,146 @@ impl ViewFrustum {
         }
     }
 }
+
+#[cfg(test)]
+mod view_frustum_tests {
+    use core::f32::consts::FRAC_1_SQRT_2;
+
+    use approx::assert_relative_eq;
+
+    use super::ViewFrustum;
+    use crate::{primitives::HalfSpace, Vec3, Vec4};
+
+    #[test]
+    fn cuboid_frustum_corners() {
+        let cuboid_frustum = ViewFrustum {
+            // left: x = -5; right: x = 4
+            // near: y = 0; far: y = 6
+            // top: z = 3; bottom: z = -2
+            half_spaces: [
+                // left: yz plane at x = -5
+                HalfSpace::new(Vec4::new(1., 0., 0., 5.)),
+                // right: yz plane at x = 4
+                HalfSpace::new(Vec4::new(-1., 0., 0., 4.)),
+                // top: xy plane at z = 3
+                HalfSpace::new(Vec4::new(0., 0., -1., 3.)),
+                // bottom: xy plane at z = -2
+                HalfSpace::new(Vec4::new(0., 0., 1., 2.)),
+                // near: xz plane at origin (y = 0)
+                HalfSpace::new(Vec4::new(0., 1., 0., 0.)),
+                // far: xz plane at y = 6
+                HalfSpace::new(Vec4::new(0., -1., 0., 6.)),
+            ],
+        };
+        let corners = cuboid_frustum.corners().unwrap();
+        // near top left
+        assert_relative_eq!(corners[0], Vec3::new(-5., 0., 3.), epsilon = 2e-7);
+        // near top right
+        assert_relative_eq!(corners[1], Vec3::new(4., 0., 3.), epsilon = 2e-7);
+        // near bottom right
+        assert_relative_eq!(corners[2], Vec3::new(4., 0., -2.), epsilon = 2e-7);
+        // near bottom left
+        assert_relative_eq!(corners[3], Vec3::new(-5., 0., -2.), epsilon = 2e-7);
+        // far top left
+        assert_relative_eq!(corners[4], Vec3::new(-5., 6., 3.), epsilon = 2e-7);
+        // far top right
+        assert_relative_eq!(corners[5], Vec3::new(4., 6., 3.), epsilon = 2e-7);
+        // far bottom right
+        assert_relative_eq!(corners[6], Vec3::new(4., 6., -2.), epsilon = 2e-7);
+        // far bottom left
+        assert_relative_eq!(corners[7], Vec3::new(-5., 6., -2.), epsilon = 2e-7);
+    }
+
+    #[test]
+    fn pyramid_frustum_corners() {
+        // a frustum where the near plane intersects the left right top and bottom planes
+        // at a single point
+        let pyramid_frustum = ViewFrustum {
+            half_spaces: [
+                // left
+                HalfSpace::new(Vec4::new(FRAC_1_SQRT_2, FRAC_1_SQRT_2, 0., FRAC_1_SQRT_2)),
+                // right
+                HalfSpace::new(Vec4::new(-FRAC_1_SQRT_2, FRAC_1_SQRT_2, 0., FRAC_1_SQRT_2)),
+                // top
+                HalfSpace::new(Vec4::new(0., FRAC_1_SQRT_2, -FRAC_1_SQRT_2, FRAC_1_SQRT_2)),
+                // bottom
+                HalfSpace::new(Vec4::new(0., FRAC_1_SQRT_2, FRAC_1_SQRT_2, FRAC_1_SQRT_2)),
+                // near: xz plane at y = -1
+                HalfSpace::new(Vec4::new(0., 1., 0., 1.)),
+                // far: xz plane at y = 3
+                HalfSpace::new(Vec4::new(0., -1., 0., 3.)),
+            ],
+        };
+        let corners = pyramid_frustum.corners().unwrap();
+        // near top left
+        assert_relative_eq!(corners[0], Vec3::new(0., -1., 0.), epsilon = 2e-7);
+        // near top right
+        assert_relative_eq!(corners[1], Vec3::new(0., -1., 0.), epsilon = 2e-7);
+        // near bottom right
+        assert_relative_eq!(corners[2], Vec3::new(0., -1., 0.), epsilon = 2e-7);
+        // near bottom left
+        assert_relative_eq!(corners[3], Vec3::new(0., -1., 0.), epsilon = 2e-7);
+        // far top left
+        assert_relative_eq!(corners[4], Vec3::new(-4., 3., 4.), epsilon = 2e-7);
+        // far top right
+        assert_relative_eq!(corners[5], Vec3::new(4., 3., 4.), epsilon = 2e-7);
+        // far bottom right
+        assert_relative_eq!(corners[6], Vec3::new(4., 3., -4.), epsilon = 2e-7);
+        // far bottom left
+        assert_relative_eq!(corners[7], Vec3::new(-4., 3., -4.), epsilon = 2e-7);
+    }
+
+    #[test]
+    fn frustum_with_some_nan_corners() {
+        // frustum with no far plane has NAN far corners
+        let no_far = ViewFrustum {
+            half_spaces: [
+                // left: a yz plane rotated outwards
+                HalfSpace::new(Vec4::new(FRAC_1_SQRT_2, FRAC_1_SQRT_2, 0., FRAC_1_SQRT_2)),
+                // right: a yz plane rotated outwards
+                HalfSpace::new(Vec4::new(-FRAC_1_SQRT_2, FRAC_1_SQRT_2, 0., FRAC_1_SQRT_2)),
+                // top: an xz plane rotated outwards
+                HalfSpace::new(Vec4::new(0., FRAC_1_SQRT_2, -FRAC_1_SQRT_2, FRAC_1_SQRT_2)),
+                // bottom: xz plane rotated outwards
+                HalfSpace::new(Vec4::new(0., FRAC_1_SQRT_2, FRAC_1_SQRT_2, FRAC_1_SQRT_2)),
+                // near: xz plane at origin (y = 0)
+                HalfSpace::new(Vec4::new(0., 1., 0., 0.)),
+                // far
+                HalfSpace::new(ViewFrustum::INACTIVE_HALF_SPACE),
+            ],
+        };
+        let corners = no_far.corners().unwrap();
+        // near top left
+        assert_relative_eq!(corners[0], Vec3::new(-1., 0., 1.), epsilon = 2e-7);
+        // near top right
+        assert_relative_eq!(corners[1], Vec3::new(1., 0., 1.), epsilon = 2e-7);
+        // near bottom right
+        assert_relative_eq!(corners[2], Vec3::new(1., 0., -1.), epsilon = 2e-7);
+        // near bottom left
+        assert_relative_eq!(corners[3], Vec3::new(-1., 0., -1.), epsilon = 2e-7);
+        // far top left
+        assert!(corners[4].is_nan());
+        // far top right
+        assert!(corners[5].is_nan());
+        // far bottom right
+        assert!(corners[6].is_nan());
+        // far bottom left
+        assert!(corners[7].is_nan());
+    }
+
+    #[test]
+    fn invalid_frustum_corners() {
+        let invalid = ViewFrustum {
+            half_spaces: [
+                // the left and the top half spaces are the same, resulting in no intersection point
+                HalfSpace::new(Vec4::new(FRAC_1_SQRT_2, FRAC_1_SQRT_2, 0., FRAC_1_SQRT_2)),
+                HalfSpace::new(Vec4::new(-FRAC_1_SQRT_2, FRAC_1_SQRT_2, 0., -FRAC_1_SQRT_2)),
+                HalfSpace::new(Vec4::new(FRAC_1_SQRT_2, FRAC_1_SQRT_2, 0., FRAC_1_SQRT_2)),
+                HalfSpace::new(Vec4::new(0., FRAC_1_SQRT_2, FRAC_1_SQRT_2, FRAC_1_SQRT_2)),
+                HalfSpace::new(Vec4::new(0., 1., 0., 0.)),
+                HalfSpace::new(Vec4::new(0., -1., 0., 3.)),
+            ],
+        };
+        assert!(invalid.corners().is_none());
+    }
+}
diff --git a/examples/tools/scene_viewer/scene_viewer_plugin.rs b/examples/tools/scene_viewer/scene_viewer_plugin.rs
index 7f4de259d2a12..8b72bb4d183b1 100644
--- a/examples/tools/scene_viewer/scene_viewer_plugin.rs
+++ b/examples/tools/scene_viewer/scene_viewer_plugin.rs
@@ -37,6 +37,7 @@ const INSTRUCTIONS: &str = r#"
 Scene Controls:
     L           - animate light direction
     U           - toggle shadows
+    F           - toggle camera frusta
     C           - cycle through the camera controller and any cameras loaded from the scene
 
     compile with "--features animation" for animation controls.
@@ -48,6 +49,7 @@ Scene Controls:
     L           - animate light direction
     U           - toggle shadows
     B           - toggle bounding boxes
+    F           - toggle camera frusta
     J           - toggle skinned mesh joint bounding boxes
     C           - cycle through the camera controller and any cameras loaded from the scene
 
@@ -74,6 +76,7 @@ impl Plugin for SceneViewerPlugin {
                     camera_tracker,
                     (
                         toggle_bounding_boxes.run_if(input_just_pressed(KeyCode::KeyB)),
+                        toggle_camera_frusta.run_if(input_just_pressed(KeyCode::KeyF)),
                         toggle_skinned_mesh_bounds.run_if(input_just_pressed(KeyCode::KeyJ)),
                     )
                         .chain(),
@@ -86,6 +89,10 @@ fn toggle_bounding_boxes(mut config: ResMut<GizmoConfigStore>) {
     config.config_mut::<AabbGizmoConfigGroup>().1.draw_all ^= true;
 }
 
+fn toggle_camera_frusta(mut config: ResMut<GizmoConfigStore>) {
+    config.config_mut::<FrustumGizmoConfigGroup>().1.draw_all ^= true;
+}
+
 fn toggle_skinned_mesh_bounds(mut config: ResMut<GizmoConfigStore>) {
     config
         .config_mut::<SkinnedMeshBoundsGizmoConfigGroup>()
