diff --git a/assets/shaders/custom_clustered_decal.wgsl b/assets/shaders/custom_clustered_decal.wgsl
index 13f404cebb262..d94a52fbea1b2 100644
--- a/assets/shaders/custom_clustered_decal.wgsl
+++ b/assets/shaders/custom_clustered_decal.wgsl
@@ -29,7 +29,7 @@ fn fragment(
     let view_z = clustered::get_view_z(in.world_position.xyz);
     let is_orthographic = clustered::view_is_orthographic();
     let cluster_index =
-        clustered_forward::fragment_cluster_index(in.position.xy, view_z, is_orthographic);
+        clustered_forward::view_fragment_cluster_index(in.position.xy, view_z, is_orthographic);
     var clusterable_object_index_ranges =
         clustered_forward::unpack_clusterable_object_index_ranges(cluster_index);
     var decal_iterator = clustered::clustered_decal_iterator_new(
diff --git a/assets/shaders/irradiance_volume_voxel_visualization.wgsl b/assets/shaders/irradiance_volume_voxel_visualization.wgsl
index d510e75eb866f..6a0fc176b51b5 100644
--- a/assets/shaders/irradiance_volume_voxel_visualization.wgsl
+++ b/assets/shaders/irradiance_volume_voxel_visualization.wgsl
@@ -33,7 +33,7 @@ fn fragment(mesh: VertexOutput) -> @location(0) vec4<f32> {
         mesh_view_bindings::view.view_from_world[2].z,
         mesh_view_bindings::view.view_from_world[3].z
     ), mesh.world_position);
-    let cluster_index = clustered_forward::fragment_cluster_index(mesh.position.xy, view_z, false);
+    let cluster_index = clustered_forward::view_fragment_cluster_index(mesh.position.xy, view_z, false);
     var clusterable_object_index_ranges =
         clustered_forward::unpack_clusterable_object_index_ranges(cluster_index);
 
diff --git a/crates/bevy_light/src/cluster/assign.rs b/crates/bevy_light/src/cluster/assign.rs
index e33e804cdc2fc..7ddc9f32b218e 100644
--- a/crates/bevy_light/src/cluster/assign.rs
+++ b/crates/bevy_light/src/cluster/assign.rs
@@ -2,13 +2,13 @@
 
 use bevy_camera::{
     primitives::{Aabb, Frustum, Sphere},
-    visibility::RenderLayers,
+    visibility::{RenderLayers, ViewVisibility},
     Camera,
 };
 use bevy_ecs::{
     entity::Entity,
     query::{Has, With},
-    system::{Commands, Local, Query, Res},
+    system::{Local, Query, Res},
 };
 use bevy_math::{
     ops::{self, sin_cos},
@@ -16,14 +16,11 @@ use bevy_math::{
     Mat4, UVec3, Vec2, Vec3, Vec3A, Vec3Swizzles as _, Vec4, Vec4Swizzles as _,
 };
 use bevy_transform::components::GlobalTransform;
-use tracing::warn;
+use tracing::{error, warn};
 
-use super::{
-    ClusterConfig, ClusterFarZMode, ClusteredDecal, Clusters, GlobalClusterSettings,
-    VisibleClusterableObjects,
-};
+use super::{ClusterConfig, ClusterFarZMode, ClusteredDecal, Clusters, GlobalClusterSettings};
 use crate::{
-    cluster::ObjectsInCluster, EnvironmentMapLight, LightProbe, PointLight, SpotLight,
+    cluster::ClusterableObjects, EnvironmentMapLight, LightProbe, PointLight, SpotLight,
     VolumetricLight,
 };
 
@@ -134,20 +131,18 @@ impl ClusterableObjectType {
 ///
 /// NOTE: Run this before `update_point_light_frusta`!
 pub(crate) fn assign_objects_to_clusters(
-    mut commands: Commands,
     mut views: Query<(
-        Entity,
         &GlobalTransform,
         &Camera,
         &Frustum,
         Option<&ClusterConfig>,
         &mut Clusters,
         Option<&RenderLayers>,
-        Option<&mut VisibleClusterableObjects>,
     )>,
     point_lights_query: Query<(
         Entity,
         &GlobalTransform,
+        &ViewVisibility,
         &PointLight,
         Option<&RenderLayers>,
         Option<&VolumetricLight>,
@@ -155,15 +150,21 @@ pub(crate) fn assign_objects_to_clusters(
     spot_lights_query: Query<(
         Entity,
         &GlobalTransform,
+        &ViewVisibility,
         &SpotLight,
         Option<&RenderLayers>,
         Option<&VolumetricLight>,
     )>,
     light_probes_query: Query<
-        (Entity, &GlobalTransform, Has<EnvironmentMapLight>),
+        (
+            Entity,
+            &GlobalTransform,
+            &ViewVisibility,
+            Has<EnvironmentMapLight>,
+        ),
         With<LightProbe>,
     >,
-    decals_query: Query<(Entity, &GlobalTransform), With<ClusteredDecal>>,
+    decals_query: Query<(Entity, &GlobalTransform, &ViewVisibility), With<ClusteredDecal>>,
     mut clusterable_objects: Local<Vec<ClusterableObjectAssignmentData>>,
     mut cluster_aabb_spheres: Local<Vec<Option<Sphere>>>,
     mut max_clusterable_objects_warning_emitted: Local<bool>,
@@ -174,153 +175,136 @@ pub(crate) fn assign_objects_to_clusters(
     };
 
     clusterable_objects.clear();
-    // collect just the relevant query data into a persisted vec to avoid reallocating each frame
-    clusterable_objects.extend(point_lights_query.iter().map(
-        |(entity, transform, point_light, maybe_layers, volumetric)| {
-            ClusterableObjectAssignmentData {
-                entity,
-                transform: GlobalTransform::from_translation(transform.translation()),
-                range: point_light.range,
-                object_type: ClusterableObjectType::PointLight {
-                    shadow_maps_enabled: point_light.shadow_maps_enabled,
-                    volumetric: volumetric.is_some(),
-                },
-                render_layers: maybe_layers.unwrap_or_default().clone(),
-            }
-        },
-    ));
-    clusterable_objects.extend(spot_lights_query.iter().map(
-        |(entity, transform, spot_light, maybe_layers, volumetric)| {
-            ClusterableObjectAssignmentData {
-                entity,
-                transform: *transform,
-                range: spot_light.range,
-                object_type: ClusterableObjectType::SpotLight {
-                    outer_angle: spot_light.outer_angle,
-                    shadow_maps_enabled: spot_light.shadow_maps_enabled,
-                    volumetric: volumetric.is_some(),
-                },
-                render_layers: maybe_layers.unwrap_or_default().clone(),
-            }
-        },
-    ));
-
-    // Gather up light probes, but only if we're clustering them.
-    //
-    // UBOs aren't large enough to hold indices for light probes, so we can't
-    // cluster light probes on such platforms (mainly WebGL 2). Besides, those
-    // platforms typically lack bindless textures, so multiple light probes
-    // wouldn't be supported anyhow.
-    if global_cluster_settings.supports_storage_buffers {
-        clusterable_objects.extend(light_probes_query.iter().map(
-            |(entity, transform, is_reflection_probe)| ClusterableObjectAssignmentData {
-                entity,
-                transform: *transform,
-                range: transform.radius_vec3a(Vec3A::ONE),
-                object_type: if is_reflection_probe {
-                    ClusterableObjectType::ReflectionProbe
+
+    // Collect clusterable objects if GPU clustering is enabled.
+    if global_cluster_settings.gpu_clustering.is_none() {
+        // collect just the relevant query data into a persisted vec to avoid reallocating each frame
+        clusterable_objects.extend(point_lights_query.iter().filter_map(
+            |(entity, transform, view_visibility, point_light, maybe_layers, volumetric)| {
+                if view_visibility.get() {
+                    Some(ClusterableObjectAssignmentData {
+                        entity,
+                        transform: GlobalTransform::from_translation(transform.translation()),
+                        range: point_light.range,
+                        object_type: ClusterableObjectType::PointLight {
+                            shadow_maps_enabled: point_light.shadow_maps_enabled,
+                            volumetric: volumetric.is_some(),
+                        },
+                        render_layers: maybe_layers.unwrap_or_default().clone(),
+                    })
                 } else {
-                    ClusterableObjectType::IrradianceVolume
-                },
-                render_layers: RenderLayers::default(),
+                    None
+                }
             },
         ));
-    }
-
-    // Add decals if the current platform supports them.
-    if global_cluster_settings.clustered_decals_are_usable {
-        clusterable_objects.extend(decals_query.iter().map(|(entity, transform)| {
-            ClusterableObjectAssignmentData {
-                entity,
-                transform: *transform,
-                range: transform.scale().length(),
-                object_type: ClusterableObjectType::Decal,
-                render_layers: RenderLayers::default(),
-            }
-        }));
-    }
-
-    if clusterable_objects.len() > global_cluster_settings.max_uniform_buffer_clusterable_objects
-        && !global_cluster_settings.supports_storage_buffers
-    {
-        clusterable_objects.sort_by_cached_key(|clusterable_object| {
-            (
-                clusterable_object.object_type.ordering(),
-                clusterable_object.entity,
-            )
-        });
-
-        // check each clusterable object against each view's frustum, keep only
-        // those that affect at least one of our views
-        let frusta: Vec<_> = views
-            .iter()
-            .map(|(_, _, _, frustum, _, _, _, _)| *frustum)
-            .collect();
-        let mut clusterable_objects_in_view_count = 0;
-        clusterable_objects.retain(|clusterable_object| {
-            // take one extra clusterable object to check if we should emit the warning
-            if clusterable_objects_in_view_count
-                == global_cluster_settings.max_uniform_buffer_clusterable_objects + 1
-            {
-                false
-            } else {
-                let clusterable_object_sphere = clusterable_object.sphere();
-                let clusterable_object_in_view = frusta
-                    .iter()
-                    .any(|frustum| frustum.intersects_sphere(&clusterable_object_sphere, true));
-
-                if clusterable_object_in_view {
-                    clusterable_objects_in_view_count += 1;
+        clusterable_objects.extend(spot_lights_query.iter().filter_map(
+            |(entity, transform, view_visibility, spot_light, maybe_layers, volumetric)| {
+                if view_visibility.get() {
+                    Some(ClusterableObjectAssignmentData {
+                        entity,
+                        transform: *transform,
+                        range: spot_light.range,
+                        object_type: ClusterableObjectType::SpotLight {
+                            outer_angle: spot_light.outer_angle,
+                            shadow_maps_enabled: spot_light.shadow_maps_enabled,
+                            volumetric: volumetric.is_some(),
+                        },
+                        render_layers: maybe_layers.unwrap_or_default().clone(),
+                    })
+                } else {
+                    None
                 }
+            },
+        ));
 
-                clusterable_object_in_view
-            }
-        });
+        // Gather up light probes, but only if we're clustering them.
+        //
+        // UBOs aren't large enough to hold indices for light probes, so we can't
+        // cluster light probes on such platforms (mainly WebGL 2). Besides, those
+        // platforms typically lack bindless textures, so multiple light probes
+        // wouldn't be supported anyhow.
+        if global_cluster_settings.supports_storage_buffers {
+            clusterable_objects.extend(light_probes_query.iter().filter_map(
+                |(entity, transform, view_visibility, is_reflection_probe)| {
+                    if view_visibility.get() {
+                        Some(ClusterableObjectAssignmentData {
+                            entity,
+                            transform: *transform,
+                            range: transform.radius_vec3a(Vec3A::ONE),
+                            object_type: if is_reflection_probe {
+                                ClusterableObjectType::ReflectionProbe
+                            } else {
+                                ClusterableObjectType::IrradianceVolume
+                            },
+                            render_layers: RenderLayers::default(),
+                        })
+                    } else {
+                        None
+                    }
+                },
+            ));
+        }
+
+        // Add decals if the current platform supports them.
+        if global_cluster_settings.clustered_decals_are_usable {
+            clusterable_objects.extend(decals_query.iter().filter_map(
+                |(entity, transform, view_visibility)| {
+                    if view_visibility.get() {
+                        Some(ClusterableObjectAssignmentData {
+                            entity,
+                            transform: *transform,
+                            range: transform.scale().length(),
+                            object_type: ClusterableObjectType::Decal,
+                            render_layers: RenderLayers::default(),
+                        })
+                    } else {
+                        None
+                    }
+                },
+            ));
+        }
 
         if clusterable_objects.len()
             > global_cluster_settings.max_uniform_buffer_clusterable_objects
-            && !*max_clusterable_objects_warning_emitted
+            && !global_cluster_settings.supports_storage_buffers
         {
-            warn!(
-                "max_uniform_buffer_clusterable_objects ({}) exceeded",
-                global_cluster_settings.max_uniform_buffer_clusterable_objects
-            );
-            *max_clusterable_objects_warning_emitted = true;
-        }
+            clusterable_objects.sort_by_cached_key(|clusterable_object| {
+                (
+                    clusterable_object.object_type.ordering(),
+                    clusterable_object.entity,
+                )
+            });
 
-        clusterable_objects
-            .truncate(global_cluster_settings.max_uniform_buffer_clusterable_objects);
+            if clusterable_objects.len()
+                > global_cluster_settings.max_uniform_buffer_clusterable_objects
+                && !*max_clusterable_objects_warning_emitted
+            {
+                warn!(
+                    "max_uniform_buffer_clusterable_objects ({}) exceeded",
+                    global_cluster_settings.max_uniform_buffer_clusterable_objects
+                );
+                *max_clusterable_objects_warning_emitted = true;
+            }
+
+            clusterable_objects
+                .truncate(global_cluster_settings.max_uniform_buffer_clusterable_objects);
+        }
     }
 
-    for (
-        view_entity,
-        camera_transform,
-        camera,
-        frustum,
-        config,
-        clusters,
-        maybe_layers,
-        mut visible_clusterable_objects,
-    ) in &mut views
-    {
+    for (camera_transform, camera, frustum, config, clusters, maybe_layers) in &mut views {
         let view_layers = maybe_layers.unwrap_or_default();
         let clusters = clusters.into_inner();
         let config = config.copied().unwrap_or_default();
 
         if matches!(config, ClusterConfig::None) {
-            if visible_clusterable_objects.is_some() {
-                commands
-                    .entity(view_entity)
-                    .remove::<VisibleClusterableObjects>();
-            }
-            clusters.clear();
+            clusters.clear(&global_cluster_settings);
             continue;
         }
 
         let screen_size = match camera.physical_viewport_size() {
             Some(screen_size) if screen_size.x != 0 && screen_size.y != 0 => screen_size,
             _ => {
-                clusters.clear();
+                clusters.clear(&global_cluster_settings);
                 continue;
             }
         };
@@ -400,389 +384,383 @@ pub(crate) fn assign_objects_to_clusters(
 
         let view_from_clip = camera.clip_from_view().inverse();
 
-        for clusterable_objects in &mut clusters.clusterable_objects {
-            clusterable_objects.clear();
-        }
         let cluster_count =
             (clusters.dimensions.x * clusters.dimensions.y * clusters.dimensions.z) as usize;
-        clusters
-            .clusterable_objects
-            .resize_with(cluster_count, ObjectsInCluster::default);
-
-        // initialize empty cluster bounding spheres
-        cluster_aabb_spheres.clear();
-        cluster_aabb_spheres.extend(core::iter::repeat_n(None, cluster_count));
-
-        // Calculate the x/y/z cluster frustum planes in view space
-        let mut x_planes = Vec::with_capacity(clusters.dimensions.x as usize + 1);
-        let mut y_planes = Vec::with_capacity(clusters.dimensions.y as usize + 1);
-        let mut z_planes = Vec::with_capacity(clusters.dimensions.z as usize + 1);
-
-        if is_orthographic {
-            let x_slices = clusters.dimensions.x as f32;
-            for x in 0..=clusters.dimensions.x {
-                let x_proportion = x as f32 / x_slices;
-                let x_pos = x_proportion * 2.0 - 1.0;
-                let view_x = clip_to_view(view_from_clip, Vec4::new(x_pos, 0.0, 1.0, 1.0)).x;
-                let normal = Vec3::X;
-                let d = view_x * normal.x;
-                x_planes.push(HalfSpace::new(normal.extend(d)));
-            }
+        clusters.reset_for_new_frame(cluster_count, &global_cluster_settings);
 
-            let y_slices = clusters.dimensions.y as f32;
-            for y in 0..=clusters.dimensions.y {
-                let y_proportion = 1.0 - y as f32 / y_slices;
-                let y_pos = y_proportion * 2.0 - 1.0;
-                let view_y = clip_to_view(view_from_clip, Vec4::new(0.0, y_pos, 1.0, 1.0)).y;
-                let normal = Vec3::Y;
-                let d = view_y * normal.y;
-                y_planes.push(HalfSpace::new(normal.extend(d)));
-            }
-        } else {
-            let x_slices = clusters.dimensions.x as f32;
-            for x in 0..=clusters.dimensions.x {
-                let x_proportion = x as f32 / x_slices;
-                let x_pos = x_proportion * 2.0 - 1.0;
-                let nb = clip_to_view(view_from_clip, Vec4::new(x_pos, -1.0, 1.0, 1.0)).xyz();
-                let nt = clip_to_view(view_from_clip, Vec4::new(x_pos, 1.0, 1.0, 1.0)).xyz();
-                let normal = nb.cross(nt);
-                let d = nb.dot(normal);
-                x_planes.push(HalfSpace::new(normal.extend(d)));
-            }
+        let (mut total_cluster_index_count, mut farthest_z) = (0, 0.0f32);
+        let view_from_world_row_2 = view_from_world.row(2);
 
-            let y_slices = clusters.dimensions.y as f32;
-            for y in 0..=clusters.dimensions.y {
-                let y_proportion = 1.0 - y as f32 / y_slices;
-                let y_pos = y_proportion * 2.0 - 1.0;
-                let nl = clip_to_view(view_from_clip, Vec4::new(-1.0, y_pos, 1.0, 1.0)).xyz();
-                let nr = clip_to_view(view_from_clip, Vec4::new(1.0, y_pos, 1.0, 1.0)).xyz();
-                let normal = nr.cross(nl);
-                let d = nr.dot(normal);
-                y_planes.push(HalfSpace::new(normal.extend(d)));
+        if matches!(clusters.clusterable_objects, ClusterableObjects::Cpu(..)) {
+            // initialize empty cluster bounding spheres
+            cluster_aabb_spheres.clear();
+            cluster_aabb_spheres.extend(core::iter::repeat_n(None, cluster_count));
+
+            // Calculate the x/y/z cluster frustum planes in view space
+            let mut x_planes = Vec::with_capacity(clusters.dimensions.x as usize + 1);
+            let mut y_planes = Vec::with_capacity(clusters.dimensions.y as usize + 1);
+            let mut z_planes = Vec::with_capacity(clusters.dimensions.z as usize + 1);
+
+            if is_orthographic {
+                let x_slices = clusters.dimensions.x as f32;
+                for x in 0..=clusters.dimensions.x {
+                    let x_proportion = x as f32 / x_slices;
+                    let x_pos = x_proportion * 2.0 - 1.0;
+                    let view_x = clip_to_view(view_from_clip, Vec4::new(x_pos, 0.0, 1.0, 1.0)).x;
+                    let normal = Vec3::X;
+                    let d = view_x * normal.x;
+                    x_planes.push(HalfSpace::new(normal.extend(d)));
+                }
+
+                let y_slices = clusters.dimensions.y as f32;
+                for y in 0..=clusters.dimensions.y {
+                    let y_proportion = 1.0 - y as f32 / y_slices;
+                    let y_pos = y_proportion * 2.0 - 1.0;
+                    let view_y = clip_to_view(view_from_clip, Vec4::new(0.0, y_pos, 1.0, 1.0)).y;
+                    let normal = Vec3::Y;
+                    let d = view_y * normal.y;
+                    y_planes.push(HalfSpace::new(normal.extend(d)));
+                }
+            } else {
+                let x_slices = clusters.dimensions.x as f32;
+                for x in 0..=clusters.dimensions.x {
+                    let x_proportion = x as f32 / x_slices;
+                    let x_pos = x_proportion * 2.0 - 1.0;
+                    let nb = clip_to_view(view_from_clip, Vec4::new(x_pos, -1.0, 1.0, 1.0)).xyz();
+                    let nt = clip_to_view(view_from_clip, Vec4::new(x_pos, 1.0, 1.0, 1.0)).xyz();
+                    let normal = nb.cross(nt);
+                    let d = nb.dot(normal);
+                    x_planes.push(HalfSpace::new(normal.extend(d)));
+                }
+
+                let y_slices = clusters.dimensions.y as f32;
+                for y in 0..=clusters.dimensions.y {
+                    let y_proportion = 1.0 - y as f32 / y_slices;
+                    let y_pos = y_proportion * 2.0 - 1.0;
+                    let nl = clip_to_view(view_from_clip, Vec4::new(-1.0, y_pos, 1.0, 1.0)).xyz();
+                    let nr = clip_to_view(view_from_clip, Vec4::new(1.0, y_pos, 1.0, 1.0)).xyz();
+                    let normal = nr.cross(nl);
+                    let d = nr.dot(normal);
+                    y_planes.push(HalfSpace::new(normal.extend(d)));
+                }
             }
-        }
 
-        let z_slices = clusters.dimensions.z;
-        for z in 0..=z_slices {
-            let view_z = z_slice_to_view_z(first_slice_depth, far_z, z_slices, z, is_orthographic);
-            let normal = -Vec3::Z;
-            let d = view_z * normal.z;
-            z_planes.push(HalfSpace::new(normal.extend(d)));
-        }
+            let z_slices = clusters.dimensions.z;
+            for z in 0..=z_slices {
+                let view_z =
+                    z_slice_to_view_z(first_slice_depth, far_z, z_slices, z, is_orthographic);
+                let normal = -Vec3::Z;
+                let d = view_z * normal.z;
+                z_planes.push(HalfSpace::new(normal.extend(d)));
+            }
 
-        let (mut total_cluster_index_count, mut farthest_z) = (0, 0.0f32);
-        let view_from_world_row_2 = view_from_world.row(2);
+            for clusterable_object in &clusterable_objects {
+                // check if the clusterable light layers overlap the view layers
+                if !view_layers.intersects(&clusterable_object.render_layers) {
+                    continue;
+                }
 
-        let mut update_from_object_intersections =
-            |visible_clusterable_objects: &mut VisibleClusterableObjects| {
-                for clusterable_object in &clusterable_objects {
-                    // check if the clusterable light layers overlap the view layers
-                    if !view_layers.intersects(&clusterable_object.render_layers) {
-                        continue;
-                    }
+                let clusterable_object_sphere = clusterable_object.sphere();
 
-                    let clusterable_object_sphere = clusterable_object.sphere();
+                // Check if the clusterable object is within the view frustum
+                if !frustum.intersects_sphere(&clusterable_object_sphere, true) {
+                    continue;
+                }
 
-                    // Check if the clusterable object is within the view frustum
-                    if !frustum.intersects_sphere(&clusterable_object_sphere, true) {
-                        continue;
+                // note: caching seems to be slower than calling twice for this aabb calculation
+                let (
+                    clusterable_object_aabb_xy_ndc_z_view_min,
+                    clusterable_object_aabb_xy_ndc_z_view_max,
+                ) = cluster_space_clusterable_object_aabb(
+                    view_from_world,
+                    view_from_world_scale,
+                    camera.clip_from_view(),
+                    &clusterable_object_sphere,
+                );
+
+                let min_cluster = ndc_position_to_cluster(
+                    clusters.dimensions,
+                    cluster_factors,
+                    is_orthographic,
+                    clusterable_object_aabb_xy_ndc_z_view_min,
+                    clusterable_object_aabb_xy_ndc_z_view_min.z,
+                );
+                let max_cluster = ndc_position_to_cluster(
+                    clusters.dimensions,
+                    cluster_factors,
+                    is_orthographic,
+                    clusterable_object_aabb_xy_ndc_z_view_max,
+                    clusterable_object_aabb_xy_ndc_z_view_max.z,
+                );
+                let (min_cluster, max_cluster) =
+                    (min_cluster.min(max_cluster), min_cluster.max(max_cluster));
+
+                // If we're doing GPU clustering, then all we have to do is
+                // to push the Z range we computed. Otherwise, proceed to
+                // assign to individual clusters.
+                let clusterable_objects = match clusters.clusterable_objects {
+                    ClusterableObjects::Gpu => {
+                        error!(
+                            "We shouldn't be clustering objects on CPU if we're in GPU clustering \
+                             mode"
+                        );
+                        return;
                     }
-
-                    // NOTE: The clusterable object intersects the frustum so it
-                    // must be visible and part of the global set
-                    visible_clusterable_objects
-                        .add(clusterable_object.entity, &clusterable_object.object_type);
-
-                    let this_object_far_z = -view_from_world_row_2
-                        .dot(clusterable_object.transform.translation().extend(1.0))
-                        + clusterable_object.range * view_from_world_scale.z;
-                    farthest_z = farthest_z.max(this_object_far_z);
-
-                    // note: caching seems to be slower than calling twice for this aabb calculation
-                    let (
-                        clusterable_object_aabb_xy_ndc_z_view_min,
-                        clusterable_object_aabb_xy_ndc_z_view_max,
-                    ) = cluster_space_clusterable_object_aabb(
-                        view_from_world,
-                        view_from_world_scale,
-                        camera.clip_from_view(),
-                        &clusterable_object_sphere,
-                    );
-
-                    let min_cluster = ndc_position_to_cluster(
-                        clusters.dimensions,
-                        cluster_factors,
-                        is_orthographic,
-                        clusterable_object_aabb_xy_ndc_z_view_min,
-                        clusterable_object_aabb_xy_ndc_z_view_min.z,
-                    );
-                    let max_cluster = ndc_position_to_cluster(
-                        clusters.dimensions,
-                        cluster_factors,
-                        is_orthographic,
-                        clusterable_object_aabb_xy_ndc_z_view_max,
-                        clusterable_object_aabb_xy_ndc_z_view_max.z,
-                    );
-                    let (min_cluster, max_cluster) =
-                        (min_cluster.min(max_cluster), min_cluster.max(max_cluster));
-
-                    // What follows is the Iterative Sphere Refinement algorithm from Just Cause 3
-                    // Persson et al, Practical Clustered Shading
-                    // http://newq.net/dl/pub/s2015_practical.pdf
-                    // NOTE: A sphere under perspective projection is no longer a sphere. It gets
-                    // stretched and warped, which prevents simpler algorithms from being correct
-                    // as they often assume that the widest part of the sphere under projection is the
-                    // center point on the axis of interest plus the radius, and that is not true!
-                    let view_clusterable_object_sphere = Sphere {
-                        center: Vec3A::from_vec4(
-                            view_from_world * clusterable_object_sphere.center.extend(1.0),
-                        ),
-                        radius: clusterable_object_sphere.radius * view_from_world_scale_max,
-                    };
-                    let spot_light_dir_sin_cos = match clusterable_object.object_type {
-                        ClusterableObjectType::SpotLight { outer_angle, .. } => {
-                            let (angle_sin, angle_cos) = sin_cos(outer_angle);
-                            Some((
-                                (view_from_world * clusterable_object.transform.back().extend(0.0))
-                                    .truncate()
-                                    .normalize(),
-                                angle_sin,
-                                angle_cos,
-                            ))
-                        }
-                        ClusterableObjectType::Decal => {
-                            // TODO: cull via a frustum
-                            None
-                        }
-                        ClusterableObjectType::PointLight { .. }
-                        | ClusterableObjectType::ReflectionProbe
-                        | ClusterableObjectType::IrradianceVolume => None,
-                    };
-                    let clusterable_object_center_clip =
-                        camera.clip_from_view() * view_clusterable_object_sphere.center.extend(1.0);
-                    let object_center_ndc =
-                        clusterable_object_center_clip.xyz() / clusterable_object_center_clip.w;
-                    let cluster_coordinates = ndc_position_to_cluster(
-                        clusters.dimensions,
-                        cluster_factors,
-                        is_orthographic,
-                        object_center_ndc,
-                        view_clusterable_object_sphere.center.z,
-                    );
-                    let z_center = if object_center_ndc.z <= 1.0 {
-                        Some(cluster_coordinates.z)
-                    } else {
-                        None
-                    };
-                    let y_center = if object_center_ndc.y > 1.0 {
+                    ClusterableObjects::Cpu(ref mut clusterable_objects_cpu) => {
+                        clusterable_objects_cpu
+                    }
+                };
+
+                // What follows is the Iterative Sphere Refinement algorithm from Just Cause 3
+                // Persson et al, Practical Clustered Shading
+                // http://newq.net/dl/pub/s2015_practical.pdf
+                // NOTE: A sphere under perspective projection is no longer a sphere. It gets
+                // stretched and warped, which prevents simpler algorithms from being correct
+                // as they often assume that the widest part of the sphere under projection is the
+                // center point on the axis of interest plus the radius, and that is not true!
+                let view_clusterable_object_sphere = Sphere {
+                    center: Vec3A::from_vec4(
+                        view_from_world * clusterable_object_sphere.center.extend(1.0),
+                    ),
+                    radius: clusterable_object_sphere.radius * view_from_world_scale_max,
+                };
+
+                let this_object_far_z = -view_from_world_row_2
+                    .dot(clusterable_object.transform.translation().extend(1.0))
+                    + clusterable_object.range * view_from_world_scale.z;
+                farthest_z = farthest_z.max(this_object_far_z);
+
+                let spot_light_dir_sin_cos = match clusterable_object.object_type {
+                    ClusterableObjectType::SpotLight { outer_angle, .. } => {
+                        let (angle_sin, angle_cos) = sin_cos(outer_angle);
+                        Some((
+                            (view_from_world * clusterable_object.transform.back().extend(0.0))
+                                .truncate()
+                                .normalize(),
+                            angle_sin,
+                            angle_cos,
+                        ))
+                    }
+                    ClusterableObjectType::Decal => {
+                        // TODO: cull via a frustum
                         None
-                    } else if object_center_ndc.y < -1.0 {
-                        Some(clusters.dimensions.y + 1)
-                    } else {
-                        Some(cluster_coordinates.y)
-                    };
-                    for z in min_cluster.z..=max_cluster.z {
-                        let mut z_object = view_clusterable_object_sphere;
-                        if z_center.is_none() || z != z_center.unwrap() {
-                            // The z plane closer to the clusterable object has the
-                            // larger radius circle where the light sphere
-                            // intersects the z plane.
-                            let z_plane = if z_center.is_some() && z < z_center.unwrap() {
-                                z_planes[(z + 1) as usize]
+                    }
+                    ClusterableObjectType::PointLight { .. }
+                    | ClusterableObjectType::ReflectionProbe
+                    | ClusterableObjectType::IrradianceVolume => None,
+                };
+                let clusterable_object_center_clip =
+                    camera.clip_from_view() * view_clusterable_object_sphere.center.extend(1.0);
+                let object_center_ndc =
+                    clusterable_object_center_clip.xyz() / clusterable_object_center_clip.w;
+                let cluster_coordinates = ndc_position_to_cluster(
+                    clusters.dimensions,
+                    cluster_factors,
+                    is_orthographic,
+                    object_center_ndc,
+                    view_clusterable_object_sphere.center.z,
+                );
+                let z_center = if object_center_ndc.z <= 1.0 {
+                    Some(cluster_coordinates.z)
+                } else {
+                    None
+                };
+                let y_center = if object_center_ndc.y > 1.0 {
+                    None
+                } else if object_center_ndc.y < -1.0 {
+                    Some(clusters.dimensions.y + 1)
+                } else {
+                    Some(cluster_coordinates.y)
+                };
+                for z in min_cluster.z..=max_cluster.z {
+                    let mut z_object = view_clusterable_object_sphere;
+                    if z_center.is_none() || z != z_center.unwrap() {
+                        // The z plane closer to the clusterable object has the
+                        // larger radius circle where the light sphere
+                        // intersects the z plane.
+                        let z_plane = if z_center.is_some() && z < z_center.unwrap() {
+                            z_planes[(z + 1) as usize]
+                        } else {
+                            z_planes[z as usize]
+                        };
+                        // Project the sphere to this z plane and use its radius as the radius of a
+                        // new, refined sphere.
+                        if let Some(projected) = project_to_plane_z(z_object, z_plane) {
+                            z_object = projected;
+                        } else {
+                            continue;
+                        }
+                    }
+                    for y in min_cluster.y..=max_cluster.y {
+                        let mut y_object = z_object;
+                        if y_center.is_none() || y != y_center.unwrap() {
+                            // The y plane closer to the clusterable object has
+                            // the larger radius circle where the light sphere
+                            // intersects the y plane.
+                            let y_plane = if y_center.is_some() && y < y_center.unwrap() {
+                                y_planes[(y + 1) as usize]
                             } else {
-                                z_planes[z as usize]
+                                y_planes[y as usize]
                             };
-                            // Project the sphere to this z plane and use its radius as the radius of a
-                            // new, refined sphere.
-                            if let Some(projected) = project_to_plane_z(z_object, z_plane) {
-                                z_object = projected;
+                            // Project the refined sphere to this y plane and use its radius as the
+                            // radius of a new, even more refined sphere.
+                            if let Some(projected) =
+                                project_to_plane_y(y_object, y_plane, is_orthographic)
+                            {
+                                y_object = projected;
                             } else {
                                 continue;
                             }
                         }
-                        for y in min_cluster.y..=max_cluster.y {
-                            let mut y_object = z_object;
-                            if y_center.is_none() || y != y_center.unwrap() {
-                                // The y plane closer to the clusterable object has
-                                // the larger radius circle where the light sphere
-                                // intersects the y plane.
-                                let y_plane = if y_center.is_some() && y < y_center.unwrap() {
-                                    y_planes[(y + 1) as usize]
-                                } else {
-                                    y_planes[y as usize]
-                                };
-                                // Project the refined sphere to this y plane and use its radius as the
-                                // radius of a new, even more refined sphere.
-                                if let Some(projected) =
-                                    project_to_plane_y(y_object, y_plane, is_orthographic)
-                                {
-                                    y_object = projected;
-                                } else {
-                                    continue;
-                                }
+                        // Loop from the left to find the first affected cluster
+                        let mut min_x = min_cluster.x;
+                        loop {
+                            if min_x >= max_cluster.x
+                                || -get_distance_x(
+                                    x_planes[(min_x + 1) as usize],
+                                    y_object.center,
+                                    is_orthographic,
+                                ) + y_object.radius
+                                    > 0.0
+                            {
+                                break;
                             }
-                            // Loop from the left to find the first affected cluster
-                            let mut min_x = min_cluster.x;
-                            loop {
-                                if min_x >= max_cluster.x
-                                    || -get_distance_x(
-                                        x_planes[(min_x + 1) as usize],
-                                        y_object.center,
-                                        is_orthographic,
-                                    ) + y_object.radius
-                                        > 0.0
-                                {
-                                    break;
-                                }
-                                min_x += 1;
-                            }
-                            // Loop from the right to find the last affected cluster
-                            let mut max_x = max_cluster.x;
-                            loop {
-                                if max_x <= min_x
-                                    || get_distance_x(
-                                        x_planes[max_x as usize],
-                                        y_object.center,
-                                        is_orthographic,
-                                    ) + y_object.radius
-                                        > 0.0
-                                {
-                                    break;
-                                }
-                                max_x -= 1;
+                            min_x += 1;
+                        }
+                        // Loop from the right to find the last affected cluster
+                        let mut max_x = max_cluster.x;
+                        loop {
+                            if max_x <= min_x
+                                || get_distance_x(
+                                    x_planes[max_x as usize],
+                                    y_object.center,
+                                    is_orthographic,
+                                ) + y_object.radius
+                                    > 0.0
+                            {
+                                break;
                             }
-                            let mut cluster_index = ((y * clusters.dimensions.x + min_x)
-                                * clusters.dimensions.z
-                                + z) as usize;
-
-                            match clusterable_object.object_type {
-                                ClusterableObjectType::SpotLight { .. } => {
-                                    let (view_light_direction, angle_sin, angle_cos) =
-                                        spot_light_dir_sin_cos.unwrap();
-                                    for x in min_x..=max_x {
-                                        // further culling for spot lights
-                                        // get or initialize cluster bounding sphere
-                                        let cluster_aabb_sphere =
-                                            &mut cluster_aabb_spheres[cluster_index];
-                                        let cluster_aabb_sphere =
-                                            if let Some(sphere) = cluster_aabb_sphere {
-                                                &*sphere
-                                            } else {
-                                                let aabb = compute_aabb_for_cluster(
-                                                    first_slice_depth,
-                                                    far_z,
-                                                    clusters.tile_size.as_vec2(),
-                                                    screen_size.as_vec2(),
-                                                    view_from_clip,
-                                                    is_orthographic,
-                                                    clusters.dimensions,
-                                                    UVec3::new(x, y, z),
-                                                );
-                                                let sphere = Sphere {
-                                                    center: aabb.center,
-                                                    radius: aabb.half_extents.length(),
-                                                };
-                                                *cluster_aabb_sphere = Some(sphere);
-                                                cluster_aabb_sphere.as_ref().unwrap()
+                            max_x -= 1;
+                        }
+                        let mut cluster_index = ((y * clusters.dimensions.x + min_x)
+                            * clusters.dimensions.z
+                            + z) as usize;
+
+                        match clusterable_object.object_type {
+                            ClusterableObjectType::SpotLight { .. } => {
+                                let (view_light_direction, angle_sin, angle_cos) =
+                                    spot_light_dir_sin_cos.unwrap();
+                                for x in min_x..=max_x {
+                                    // further culling for spot lights
+                                    // get or initialize cluster bounding sphere
+                                    let cluster_aabb_sphere =
+                                        &mut cluster_aabb_spheres[cluster_index];
+                                    let cluster_aabb_sphere =
+                                        if let Some(sphere) = cluster_aabb_sphere {
+                                            &*sphere
+                                        } else {
+                                            let aabb = compute_aabb_for_cluster(
+                                                first_slice_depth,
+                                                far_z,
+                                                clusters.tile_size.as_vec2(),
+                                                screen_size.as_vec2(),
+                                                view_from_clip,
+                                                is_orthographic,
+                                                clusters.dimensions,
+                                                UVec3::new(x, y, z),
+                                            );
+                                            let sphere = Sphere {
+                                                center: aabb.center,
+                                                radius: aabb.half_extents.length(),
                                             };
-
-                                        // test -- based on https://bartwronski.com/2017/04/13/cull-that-cone/
-                                        let spot_light_offset = Vec3::from(
-                                            view_clusterable_object_sphere.center
-                                                - cluster_aabb_sphere.center,
-                                        );
-                                        let spot_light_dist_sq = spot_light_offset.length_squared();
-                                        let v1_len = spot_light_offset.dot(view_light_direction);
-
-                                        let distance_closest_point = (angle_cos
-                                            * (spot_light_dist_sq - v1_len * v1_len).sqrt())
-                                            - v1_len * angle_sin;
-                                        let angle_cull =
-                                            distance_closest_point > cluster_aabb_sphere.radius;
-
-                                        let front_cull = v1_len
-                                            > cluster_aabb_sphere.radius
-                                                + clusterable_object.range
-                                                    * view_from_world_scale_max;
-                                        let back_cull = v1_len < -cluster_aabb_sphere.radius;
-
-                                        if !angle_cull && !front_cull && !back_cull {
-                                            // this cluster is affected by the spot light
-                                            clusters.clusterable_objects[cluster_index]
-                                                .add_spot_light(clusterable_object.entity);
-                                            total_cluster_index_count += 1;
-                                        }
-                                        cluster_index += clusters.dimensions.z as usize;
+                                            *cluster_aabb_sphere = Some(sphere);
+                                            cluster_aabb_sphere.as_ref().unwrap()
+                                        };
+
+                                    // test -- based on https://bartwronski.com/2017/04/13/cull-that-cone/
+                                    let spot_light_offset = Vec3::from(
+                                        view_clusterable_object_sphere.center
+                                            - cluster_aabb_sphere.center,
+                                    );
+                                    let spot_light_dist_sq = spot_light_offset.length_squared();
+                                    let v1_len = spot_light_offset.dot(view_light_direction);
+
+                                    let distance_closest_point = (angle_cos
+                                        * (spot_light_dist_sq - v1_len * v1_len).sqrt())
+                                        - v1_len * angle_sin;
+                                    let angle_cull =
+                                        distance_closest_point > cluster_aabb_sphere.radius;
+
+                                    let front_cull = v1_len
+                                        > cluster_aabb_sphere.radius
+                                            + clusterable_object.range * view_from_world_scale_max;
+                                    let back_cull = v1_len < -cluster_aabb_sphere.radius;
+
+                                    if !angle_cull && !front_cull && !back_cull {
+                                        // this cluster is affected by the spot light
+                                        clusterable_objects[cluster_index]
+                                            .add_spot_light(clusterable_object.entity);
+                                        total_cluster_index_count += 1;
                                     }
+                                    cluster_index += clusters.dimensions.z as usize;
                                 }
+                            }
 
-                                ClusterableObjectType::PointLight { .. } => {
-                                    for _ in min_x..=max_x {
-                                        // all clusters within range are affected by point lights
-                                        clusters.clusterable_objects[cluster_index]
-                                            .add_point_light(clusterable_object.entity);
-                                        cluster_index += clusters.dimensions.z as usize;
-                                    }
-                                    total_cluster_index_count += (max_x - min_x + 1) as usize;
+                            ClusterableObjectType::PointLight { .. } => {
+                                for _ in min_x..=max_x {
+                                    // all clusters within range are affected by point lights
+                                    clusterable_objects[cluster_index]
+                                        .add_point_light(clusterable_object.entity);
+                                    cluster_index += clusters.dimensions.z as usize;
                                 }
+                                total_cluster_index_count += (max_x - min_x + 1) as usize;
+                            }
 
-                                ClusterableObjectType::ReflectionProbe => {
-                                    // Reflection probes currently affect all
-                                    // clusters in their bounding sphere.
-                                    //
-                                    // TODO: Cull more aggressively based on the
-                                    // probe's OBB.
-                                    for _ in min_x..=max_x {
-                                        clusters.clusterable_objects[cluster_index]
-                                            .add_reflection_probe(clusterable_object.entity);
-                                        cluster_index += clusters.dimensions.z as usize;
-                                    }
-                                    total_cluster_index_count += (max_x - min_x + 1) as usize;
+                            ClusterableObjectType::ReflectionProbe => {
+                                // Reflection probes currently affect all
+                                // clusters in their bounding sphere.
+                                //
+                                // TODO: Cull more aggressively based on the
+                                // probe's OBB.
+                                for _ in min_x..=max_x {
+                                    clusterable_objects[cluster_index]
+                                        .add_reflection_probe(clusterable_object.entity);
+                                    cluster_index += clusters.dimensions.z as usize;
                                 }
+                                total_cluster_index_count += (max_x - min_x + 1) as usize;
+                            }
 
-                                ClusterableObjectType::IrradianceVolume => {
-                                    // Irradiance volumes currently affect all
-                                    // clusters in their bounding sphere.
-                                    //
-                                    // TODO: Cull more aggressively based on the
-                                    // probe's OBB.
-                                    for _ in min_x..=max_x {
-                                        clusters.clusterable_objects[cluster_index]
-                                            .add_irradiance_volume(clusterable_object.entity);
-                                        cluster_index += clusters.dimensions.z as usize;
-                                    }
-                                    total_cluster_index_count += (max_x - min_x + 1) as usize;
+                            ClusterableObjectType::IrradianceVolume => {
+                                // Irradiance volumes currently affect all
+                                // clusters in their bounding sphere.
+                                //
+                                // TODO: Cull more aggressively based on the
+                                // probe's OBB.
+                                for _ in min_x..=max_x {
+                                    clusterable_objects[cluster_index]
+                                        .add_irradiance_volume(clusterable_object.entity);
+                                    cluster_index += clusters.dimensions.z as usize;
                                 }
+                                total_cluster_index_count += (max_x - min_x + 1) as usize;
+                            }
 
-                                ClusterableObjectType::Decal => {
-                                    // Decals currently affect all clusters in their
-                                    // bounding sphere.
-                                    //
-                                    // TODO: Cull more aggressively based on the
-                                    // decal's OBB.
-                                    for _ in min_x..=max_x {
-                                        clusters.clusterable_objects[cluster_index]
-                                            .add_decal(clusterable_object.entity);
-                                        cluster_index += clusters.dimensions.z as usize;
-                                    }
-                                    total_cluster_index_count += (max_x - min_x + 1) as usize;
+                            ClusterableObjectType::Decal => {
+                                // Decals currently affect all clusters in their
+                                // bounding sphere.
+                                //
+                                // TODO: Cull more aggressively based on the
+                                // decal's OBB.
+                                for _ in min_x..=max_x {
+                                    clusterable_objects[cluster_index]
+                                        .add_decal(clusterable_object.entity);
+                                    cluster_index += clusters.dimensions.z as usize;
                                 }
+                                total_cluster_index_count += (max_x - min_x + 1) as usize;
                             }
                         }
                     }
                 }
-            };
-
-        // reuse existing visible clusterable objects Vec, if it exists
-        if let Some(visible_clusterable_objects) = visible_clusterable_objects.as_mut() {
-            visible_clusterable_objects.clear();
-            update_from_object_intersections(visible_clusterable_objects);
-        } else {
-            let mut visible_clusterable_objects = VisibleClusterableObjects::new();
-            update_from_object_intersections(&mut visible_clusterable_objects);
-            commands
-                .entity(view_entity)
-                .insert(visible_clusterable_objects);
+            }
         }
 
         // Save statistics for this frame so that the `dynamic_resizing` and
diff --git a/crates/bevy_light/src/cluster/mod.rs b/crates/bevy_light/src/cluster/mod.rs
index 3007d7ed7d43b..4a3f02b6d28d5 100644
--- a/crates/bevy_light/src/cluster/mod.rs
+++ b/crates/bevy_light/src/cluster/mod.rs
@@ -1,7 +1,5 @@
 //! Spatial clustering of objects to accelerate rendering performance.
 
-use core::any::TypeId;
-
 use bevy_asset::Handle;
 use bevy_camera::{
     prelude::ViewVisibility,
@@ -20,12 +18,9 @@ use bevy_image::Image;
 use bevy_math::{AspectRatio, UVec2, UVec3, Vec3A, Vec3Swizzles as _};
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
 use bevy_transform::components::Transform;
-use bevy_utils::TypeIdMap;
 use tracing::warn;
 
-use crate::{
-    cluster::assign::ClusterableObjectType, EnvironmentMapLight, IrradianceVolume, LightProbe,
-};
+use crate::LightProbe;
 
 pub mod assign;
 
@@ -43,15 +38,45 @@ mod test;
 
 /// Cluster configuration depends on rendering capabilities, these are exposed here.
 /// They are automatically set by `bevy_pbr`, but a custom renderer may configure these too.
-#[derive(Resource)]
+#[derive(Clone, Resource, Debug)]
 #[expect(missing_docs, reason = "self explanatory")]
 pub struct GlobalClusterSettings {
     pub supports_storage_buffers: bool,
     pub clustered_decals_are_usable: bool,
+    /// Settings relating to GPU clustering, if GPU clustering is enabled.
+    ///
+    /// To disable GPU light clustering, set this to `None`.
+    pub gpu_clustering: Option<GlobalClusterGpuSettings>,
     pub max_uniform_buffer_clusterable_objects: usize,
     pub view_cluster_bindings_max_indices: usize,
 }
 
+/// Settings relating to GPU clustering.
+#[derive(Clone, Copy, Debug)]
+pub struct GlobalClusterGpuSettings {
+    /// The initial capacity of the list of Z slices.
+    ///
+    /// If there are too many clusterable objects on screen, this can overflow.
+    /// Bevy will detect this situation and resize it, but you might see a few
+    /// incorrect frames before Bevy resizes the list. To avoid this issue, you
+    /// can set this to a higher value.
+    ///
+    /// The default value is
+    /// `bevy::pbr::cluster::GPU_CLUSTERING_INITIAL_Z_SLICE_LIST_SIZE`.
+    pub initial_z_slice_list_capacity: usize,
+
+    /// The initial capacity of the list of clusterable objects.
+    ///
+    /// If there are too many clusterable objects on screen, this can overflow.
+    /// Bevy will detect this situation and resize it, but you might see a few
+    /// incorrect frames before Bevy resizes the list. To avoid this issue, you
+    /// can set this to a higher value.
+    ///
+    /// The default value is
+    /// `bevy::pbr::cluster::GPU_CLUSTERING_INITIAL_INDEX_LIST_CAPACITY`.
+    pub initial_index_list_capacity: usize,
+}
+
 /// Configure the far z-plane mode used for the furthest depth slice for clustered forward
 /// rendering
 #[derive(Debug, Copy, Clone, Reflect)]
@@ -114,7 +139,7 @@ pub enum ClusterConfig {
 }
 
 /// The cluster geometry generated by [`ClusterConfig`].
-#[derive(Component, Debug, Default)]
+#[derive(Component, Debug)]
 pub struct Clusters {
     /// The dimensions of the rectangle the cluster occupies in screen-space, rounded up to the nearest pixel.
     pub tile_size: UVec2,
@@ -137,7 +162,17 @@ pub struct Clusters {
     /// grows the number of clusters if clusters have likely become too large.
     pub last_frame_total_cluster_index_count: Option<usize>,
     /// All objects within the cluster.
-    pub clusterable_objects: Vec<ObjectsInCluster>,
+    pub clusterable_objects: ClusterableObjects,
+}
+
+/// The list of objects within a cluster, if known to the CPU.
+#[derive(Debug)]
+pub enum ClusterableObjects {
+    /// The list of objects in the cluster is known to the CPU.
+    Cpu(Vec<ObjectsInClusterCpu>),
+    /// The list of objects in the cluster is unknown to the CPU, because GPU
+    /// clustering is being used.
+    Gpu,
 }
 
 /// The [`VisibilityClass`] used for clusterables (decals, point lights, spot
@@ -146,20 +181,9 @@ pub struct Clusters {
 /// [`VisibilityClass`]: bevy_camera::visibility::VisibilityClass
 pub struct ClusterVisibilityClass;
 
-/// A component, present on each render-world view, that stores the light of all
-/// clusterable objects potentially visible in that view, separated by type.
-#[derive(Clone, Component, Debug, Default)]
-pub struct VisibleClusterableObjects {
-    /// A list of all point and spot lights that are potentially visible from
-    /// this view.
-    pub point_and_spot_lights: Vec<Entity>,
-    /// A list of all light probes that are potentially visible from this view.
-    pub light_probes: TypeIdMap<Vec<Entity>>,
-}
-
 /// All objects that potentially intersect a single cluster.
-#[derive(Default, Debug)]
-pub struct ObjectsInCluster {
+#[derive(Clone, Default, Debug)]
+pub struct ObjectsInClusterCpu {
     /// A list of all clusterable objects that are potentially visible from this
     /// view.
     clusterables: Vec<Entity>,
@@ -352,6 +376,22 @@ impl ClusterConfig {
     }
 }
 
+impl Default for Clusters {
+    fn default() -> Clusters {
+        Clusters {
+            tile_size: UVec2::ZERO,
+            dimensions: UVec3::ZERO,
+            near: 0.0,
+            far: 0.0,
+            last_frame_farthest_z: None,
+            last_frame_total_cluster_index_count: None,
+            // Although we start with CPU clustering, this will be switched to
+            // GPU clustering if that's enabled.
+            clusterable_objects: ClusterableObjects::Cpu(vec![]),
+        }
+    }
+}
+
 impl Clusters {
     fn update(&mut self, screen_size: UVec2, requested_dimensions: UVec3) {
         debug_assert!(
@@ -372,16 +412,61 @@ impl Clusters {
         // NOTE: Maximum 4096 clusters due to uniform buffer size constraints
         debug_assert!(self.dimensions.x * self.dimensions.y * self.dimensions.z <= 4096);
     }
-    fn clear(&mut self) {
+
+    fn clear(&mut self, global_cluster_settings: &GlobalClusterSettings) {
         self.tile_size = UVec2::ONE;
         self.dimensions = UVec3::ZERO;
         self.near = 0.0;
         self.far = 0.0;
-        self.clusterable_objects.clear();
+
+        match (
+            &mut self.clusterable_objects,
+            &global_cluster_settings.gpu_clustering,
+        ) {
+            (ClusterableObjects::Cpu(_), Some(_)) => {
+                self.clusterable_objects = ClusterableObjects::Gpu;
+            }
+            (ClusterableObjects::Cpu(objects_in_cluster_cpu), None) => {
+                objects_in_cluster_cpu.clear();
+            }
+            (ClusterableObjects::Gpu, Some(_)) => {
+                self.clusterable_objects = ClusterableObjects::Cpu(vec![]);
+            }
+            (ClusterableObjects::Gpu, None) => {}
+        }
+    }
+
+    fn reset_for_new_frame(
+        &mut self,
+        cluster_count: usize,
+        global_cluster_settings: &GlobalClusterSettings,
+    ) {
+        match (
+            &mut self.clusterable_objects,
+            &global_cluster_settings.gpu_clustering,
+        ) {
+            (ClusterableObjects::Cpu(_), Some(_)) => {
+                self.clusterable_objects = ClusterableObjects::Gpu;
+            }
+
+            (ClusterableObjects::Cpu(objects_in_cluster_cpu), None) => {
+                for clusterable_objects in objects_in_cluster_cpu.iter_mut() {
+                    clusterable_objects.clear();
+                }
+                objects_in_cluster_cpu.resize_with(cluster_count, ObjectsInClusterCpu::default);
+            }
+
+            (ClusterableObjects::Gpu, Some(_)) => {}
+
+            (ClusterableObjects::Gpu, None) => {
+                self.clusterable_objects =
+                    ClusterableObjects::Cpu(vec![ObjectsInClusterCpu::default(); cluster_count]);
+            }
+        }
     }
 }
 
-impl ObjectsInCluster {
+impl ObjectsInClusterCpu {
     /// Clears out all objects in this cluster in preparation for a new frame.
     pub fn clear(&mut self) {
         self.clusterables.clear();
@@ -424,42 +509,6 @@ impl ObjectsInCluster {
     }
 }
 
-impl VisibleClusterableObjects {
-    /// Creates a new [`VisibleClusterableObjects`] container.
-    pub fn new() -> Self {
-        Self::default()
-    }
-
-    /// Clears out all lists of visible clusterable objects in preparation for a
-    /// new frame.
-    pub fn clear(&mut self) {
-        self.point_and_spot_lights.clear();
-        self.light_probes.clear();
-    }
-
-    /// Adds a new object of the given type to the list.
-    pub fn add(&mut self, entity: Entity, object_type: &ClusterableObjectType) {
-        match *object_type {
-            ClusterableObjectType::PointLight { .. } | ClusterableObjectType::SpotLight { .. } => {
-                self.point_and_spot_lights.push(entity);
-            }
-            ClusterableObjectType::ReflectionProbe => {
-                self.light_probes
-                    .entry(TypeId::of::<EnvironmentMapLight>())
-                    .or_default()
-                    .push(entity);
-            }
-            ClusterableObjectType::IrradianceVolume => {
-                self.light_probes
-                    .entry(TypeId::of::<IrradianceVolume>())
-                    .or_default()
-                    .push(entity);
-            }
-            ClusterableObjectType::Decal => {}
-        }
-    }
-}
-
 /// A system that adds AABBs to light probes and decals so that the visibility
 /// determination works for them.
 pub fn add_light_probe_and_decal_aabbs(
diff --git a/crates/bevy_light/src/lib.rs b/crates/bevy_light/src/lib.rs
index 8393915ce91ef..c1fdcc89e8139 100644
--- a/crates/bevy_light/src/lib.rs
+++ b/crates/bevy_light/src/lib.rs
@@ -10,8 +10,8 @@ use bevy_camera::{
     primitives::{Aabb, CascadesFrusta, CubemapFrusta, Frustum, Sphere},
     visibility::{
         CascadesVisibleEntities, CubemapVisibleEntities, InheritedVisibility, NoFrustumCulling,
-        RenderLayers, ViewVisibility, VisibilityRange, VisibilitySystems, VisibleEntityRanges,
-        VisibleMeshEntities,
+        RenderLayers, ViewVisibility, VisibilityRange, VisibilitySystems, VisibleEntities,
+        VisibleEntityRanges, VisibleMeshEntities,
     },
     Camera3d, CameraUpdateSystems,
 };
@@ -23,11 +23,11 @@ use bevy_mesh::Mesh3d;
 use bevy_reflect::prelude::*;
 use bevy_transform::{components::GlobalTransform, TransformSystems};
 use bevy_utils::Parallel;
-use core::{mem, ops::DerefMut};
+use core::{any::TypeId, mem, ops::DerefMut};
 
 pub mod cluster;
+use cluster::assign::assign_objects_to_clusters;
 pub use cluster::ClusteredDecal;
-use cluster::{assign::assign_objects_to_clusters, VisibleClusterableObjects};
 mod ambient_light;
 pub use ambient_light::{AmbientLight, GlobalAmbientLight};
 use bevy_camera::visibility::SetViewVisibility;
@@ -80,7 +80,7 @@ pub mod prelude {
 
 use crate::{
     atmosphere::ScatteringMedium,
-    cluster::{add_light_probe_and_decal_aabbs, Clusters},
+    cluster::{add_light_probe_and_decal_aabbs, ClusterVisibilityClass, Clusters},
     directional_light::validate_shadow_map_size,
     point_light::update_point_light_bounding_spheres,
     spot_light::update_spot_light_bounding_spheres,
@@ -483,7 +483,7 @@ pub fn check_dir_light_mesh_visibility(
 /// Updates the visibility for [`PointLight`]s and [`SpotLight`]s so that
 /// shadow map rendering can work.
 pub fn check_point_light_mesh_visibility(
-    visible_point_lights: Query<&VisibleClusterableObjects>,
+    visible_point_lights: Query<&VisibleEntities>,
     mut point_lights: Query<(
         &PointLight,
         &GlobalTransform,
@@ -524,7 +524,7 @@ pub fn check_point_light_mesh_visibility(
 
     let visible_entity_ranges = visible_entity_ranges.as_deref();
     for visible_lights in &visible_point_lights {
-        for light_entity in visible_lights.point_and_spot_lights.iter().copied() {
+        for &light_entity in visible_lights.get(TypeId::of::<ClusterVisibilityClass>()) {
             if !checked_lights.insert(light_entity) {
                 continue;
             }
diff --git a/crates/bevy_pbr/src/cluster/cluster.wgsl b/crates/bevy_pbr/src/cluster/cluster.wgsl
new file mode 100644
index 0000000000000..0dc6f9e81c626
--- /dev/null
+++ b/crates/bevy_pbr/src/cluster/cluster.wgsl
@@ -0,0 +1,201 @@
+#define_import_path bevy_pbr::cluster
+#import bevy_pbr::clustered_forward::view_z_to_z_slice
+
+// Valid values for the `object_type` field.
+const CLUSTERABLE_OBJECT_TYPE_POINT_LIGHT: u32 = 0u;
+const CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT: u32 = 1u;
+const CLUSTERABLE_OBJECT_TYPE_REFLECTION_PROBE: u32 = 2u;
+const CLUSTERABLE_OBJECT_TYPE_IRRADIANCE_VOLUME: u32 = 3u;
+const CLUSTERABLE_OBJECT_TYPE_DECAL: u32 = 4u;
+
+const NDC_MIN: vec2<f32> = vec2<f32>(-1.0);
+const NDC_MAX: vec2<f32> = vec2<f32>(1.0);
+
+// Metadata stored on GPU that's global to all clusters for a view.
+//
+// See the comments in `bevy_pbr/src/cluster/gpu.rs` for information on the
+// fields.
+struct ClusterMetadata {
+    indirect_draw_params: ClusterRasterIndirectDrawParams,
+
+    clustered_light_count: u32,
+    reflection_probe_count: u32,
+    irradiance_volume_count: u32,
+    decal_count: u32,
+
+    z_slice_list_capacity: u32,
+    index_list_size: u32,
+
+    farthest_z: atomic<u32>,
+};
+
+// Indirect draw parameters in the format required by the WebGPU specification.
+struct ClusterRasterIndirectDrawParams {
+    index_count: u32,
+    instance_count: atomic<u32>,
+    first_index: u32,
+    base_vertex: u32,
+    first_instance: u32,
+}
+
+// The GPU representation of a single Z-slice of a clusterable object.
+//
+// See the comments in `bevy_pbr/src/cluster/gpu.rs` for information on the
+// fields.
+struct ClusterableObjectZSlice {
+    object_index: u32,
+    object_type: u32,
+    z_slice: u32,
+};
+
+// An axis-aligned bounding box.
+struct Aabb {
+    // The minimum extents of the box.
+    min: vec3<f32>,
+    // The maximum extents of the box.
+    max: vec3<f32>,
+};
+
+// An axis-aligned bounding box using unsigned integer coordinates.
+//
+// This is used for cluster bounds.
+struct AabbU {
+    // The minimum extents of the box.
+    min: vec3<u32>,
+    // The maximum extents of the box, plus one.
+    //
+    // We add 1 here so that 0-size AABBs can be expressed.
+    max: vec3<u32>,
+}
+
+// Returns the AABB of an object suitable for conversion into an AABB of
+// clusters.
+//
+// See `bevy_light::cluster::assign::cluster_space_clusterable_object_aabb`.
+fn cluster_space_object_aabb(
+    position: vec3<f32>,
+    radius: f32,
+    view_from_world: mat4x4<f32>,
+    clip_from_view: mat4x4<f32>,
+    view_from_world_scale: vec3<f32>
+) -> Aabb {
+    let position_view = (view_from_world * vec4(position, 1.0)).xyz;
+    let half_extents = radius * abs(view_from_world_scale);
+
+    var view_min = position_view - half_extents;
+    var view_max = position_view + half_extents;
+
+    // Constrain view z to be negative - i.e. in front of the camera
+    // When view z is >= 0.0 and we're using a perspective projection, bad
+    // things happen.  At view z == 0.0, ndc x,y are mathematically undefined.
+    // At view z > 0.0, i.e. behind the camera, the perspective projection flips
+    // the directions of the axes. This breaks assumptions about use of min/max
+    // operations as something that was to the left in view space is now
+    // returning a coordinate that for view z in front of the camera would be on
+    // the right, but at view z behind the camera is on the left. So, we just
+    // constrain view z to be < 0.0 and necessarily in front of the camera.
+    view_min.z = min(view_min.z, -0.00001);
+    view_max.z = min(view_max.z, -0.00001);
+
+    // Is there a cheaper way to do this? The problem is that because of
+    // perspective the point at max z but min xy may be less xy in screenspace,
+    // and similar. As such, projecting the min and max xy at both the closer
+    // and further z and taking the min and max of those projected points
+    // addresses this.
+    let view_xymin_near = view_min;
+    let view_xymin_far = vec3(view_min.xy, view_max.z);
+    let view_xymax_near = vec3(view_max.xy, view_min.z);
+    let view_xymax_far = view_max;
+
+    let clip_xymin_near = clip_from_view * vec4(view_xymin_near, 1.0);
+    let clip_xymin_far = clip_from_view * vec4(view_xymin_far, 1.0);
+    let clip_xymax_near = clip_from_view * vec4(view_xymax_near, 1.0);
+    let clip_xymax_far = clip_from_view * vec4(view_xymax_far, 1.0);
+
+    let ndc_xymin_near = clip_xymin_near.xyz / clip_xymin_near.w;
+    let ndc_xymin_far = clip_xymin_far.xyz / clip_xymin_far.w;
+    let ndc_xymax_near = clip_xymax_near.xyz / clip_xymax_near.w;
+    let ndc_xymax_far = clip_xymax_far.xyz / clip_xymax_far.w;
+
+    var ndc_min = min(min(ndc_xymin_near, ndc_xymin_far), min(ndc_xymax_near, ndc_xymax_far));
+    var ndc_max = max(max(ndc_xymin_near, ndc_xymin_far), max(ndc_xymax_near, ndc_xymax_far));
+
+    // clamp to ndc coords without depth
+    ndc_min = vec3(clamp(ndc_min.xy, NDC_MIN, NDC_MAX), ndc_min.z);
+    ndc_max = vec3(clamp(ndc_max.xy, NDC_MIN, NDC_MAX), ndc_max.z);
+
+    // pack unadjusted z depth into the vecs
+    return Aabb(vec3(ndc_min.xy, view_min.z), vec3(ndc_max.xy, view_max.z));
+}
+
+// Computes the scale of the camera from the view matrix.
+fn compute_view_from_world_scale(world_from_view: mat4x4<f32>) -> vec3<f32> {
+    let world_from_view_3x3 = mat3x3<f32>(
+        world_from_view[0].xyz,
+        world_from_view[1].xyz,
+        world_from_view[2].xyz
+    );
+    let det = determinant(world_from_view_3x3);
+    let scale = vec3<f32>(
+        length(world_from_view_3x3[0]) * sign(det),
+        length(world_from_view_3x3[1]),
+        length(world_from_view_3x3[2])
+    );
+    return vec3<f32>(1.0) / scale;
+}
+
+// Returns the cluster coordinates corresponding to a position in normalized
+// device coordinates.
+// See `bevy_light::cluster::assign::ndc_position_to_cluster`.
+fn ndc_position_to_cluster(
+    cluster_dimensions: vec3<u32>,
+    cluster_factors: vec2<f32>,
+    is_orthographic: bool,
+    ndc_p: vec3<f32>,
+    view_z: f32
+) -> vec3<u32> {
+    let frag_coord = clamp(ndc_p.xy * vec2(0.5, -0.5) + vec2(0.5), vec2(0.0), vec2(1.0));
+    let xy = vec2<u32>(floor(frag_coord * vec2<f32>(cluster_dimensions.xy)));
+    let z_slice = view_z_to_z_slice(cluster_factors, cluster_dimensions.z, view_z, is_orthographic);
+    return clamp(vec3<u32>(xy, z_slice), vec3(0u), cluster_dimensions - vec3(1u));
+}
+
+// Returns the AABB encompassing all clusters that intersect a sphere.
+fn calculate_sphere_cluster_bounds(
+    position: vec3<f32>,
+    radius: f32,
+    view_from_world: mat4x4<f32>,
+    clip_from_view: mat4x4<f32>,
+    view_from_world_scale: vec3<f32>,
+    cluster_dimensions: vec3<u32>,
+    cluster_factors: vec2<f32>,
+    is_orthographic: bool,
+) -> AabbU {
+    let aabb_ndc = cluster_space_object_aabb(
+        position,
+        radius,
+        view_from_world,
+        clip_from_view,
+        view_from_world_scale
+    );
+
+    let temp_min_cluster = ndc_position_to_cluster(
+        cluster_dimensions,
+        cluster_factors,
+        is_orthographic,
+        aabb_ndc.min,
+        aabb_ndc.min.z
+    );
+    let temp_max_cluster = ndc_position_to_cluster(
+        cluster_dimensions,
+        cluster_factors,
+        is_orthographic,
+        aabb_ndc.max,
+        aabb_ndc.max.z
+    );
+
+    let min_cluster = min(temp_min_cluster, temp_max_cluster);
+    let max_cluster = max(temp_min_cluster, temp_max_cluster);
+
+    return AabbU(min_cluster, max_cluster);
+}
diff --git a/crates/bevy_pbr/src/cluster/cluster_allocate.wgsl b/crates/bevy_pbr/src/cluster/cluster_allocate.wgsl
new file mode 100644
index 0000000000000..433e32ab91df0
--- /dev/null
+++ b/crates/bevy_pbr/src/cluster/cluster_allocate.wgsl
@@ -0,0 +1,127 @@
+#import bevy_pbr::cluster::ClusterMetadata
+#import bevy_pbr::mesh_view_types::{ClusterOffsetsAndCounts, Lights}
+
+// The shader that allocates the clustered object ID buffer.
+//
+// The clustered object ID buffer consists of many tightly-packed
+// variable-length arrays of clustered object IDs. The offset to the start of
+// each list is stored in `ClusterOffsetsAndCounts`. To allocate the lists in
+// the buffer, the number of objects of each type in each cluster must be known.
+//
+// Since the lists are tightly packed, determining the offsets in the global
+// buffer is a [prefix sum] problem. To deal with the fact that workgroup sizes
+// are limited to 256 in `wgpu`, and we will usually have more clusters than
+// that, we use a two-pass approach:
+//
+// 1. First, the *local* allocation pass runs on workgroups of 256 clusters
+// each. A [Hillis-Steele scan] is performed to allocate the position in the
+// buffer for each 256 clusters, relative to the first cluster in the workgroup.
+//
+// 2. Next, the *global* allocation pass runs a sequential loop over each 256
+// clusters to calculate the final offsets relative to the previous 256 cluster
+// chunk.
+//
+// At the end of this process, the clusters will have been assigned to their
+// final positions in the list.
+//
+// [prefix sum]: https://en.wikipedia.org/wiki/Prefix_sum
+//
+// [Hillis-Steele scan]: https://en.wikipedia.org/wiki/Prefix_sum#Algorithm_1:_Shorter_span,_more_parallel
+
+@group(0) @binding(0) var<storage, read_write> offsets_and_counts: ClusterOffsetsAndCounts;
+@group(0) @binding(1) var<uniform> lights: Lights;
+@group(0) @binding(2) var<storage, read_write> clustering_metadata: ClusterMetadata;
+@group(0) @binding(3) var<storage, read_write> scratchpad_offsets_and_counts:
+    ClusterOffsetsAndCounts;
+
+// The offset of the first clustered light within the buffer for each thread.
+var<workgroup> block_offsets: array<u32, 256>;
+
+// The local allocation pass that, for each chunk of 256 clusters, calculates
+// the offset for each cluster in the chunk.
+@compute @workgroup_size(256, 1, 1)
+fn allocate_local_main(
+    @builtin(local_invocation_id) local_id: vec3<u32>,
+    @builtin(workgroup_id) group_id: vec3<u32>,
+    @builtin(global_invocation_id) global_id: vec3<u32>
+) {
+    let cluster_count =
+        lights.cluster_dimensions.x *
+        lights.cluster_dimensions.y *
+        lights.cluster_dimensions.z;
+
+    let block_start = group_id.x * 256u;
+    let block_end = min(block_start + 256u, cluster_count);
+
+    // Initialize the block offsets.
+    block_offsets[local_id.x] = 0u;
+    workgroupBarrier();
+
+    // Compute our "block offset" relative to the cluster before us.
+    // After a prefix scan, the offsets will be correct.
+    if (global_id.x < block_end && local_id.x < 255u) {
+        block_offsets[local_id.x + 1] = cluster_object_count(global_id.x);
+    }
+    workgroupBarrier();
+
+    // Do the Hillis-Steele scan.
+    for (var offset = 1u; offset < 256u; offset *= 2u) {
+        var term = 0u;
+        if (local_id.x >= offset) {
+            term = block_offsets[local_id.x - offset];
+        }
+        workgroupBarrier();
+        block_offsets[local_id.x] += term;
+        workgroupBarrier();
+    }
+
+    if (global_id.x < block_end) {
+        // Now write in the local offset.
+        offsets_and_counts.data[global_id.x][0].x = block_offsets[local_id.x];
+
+        // Zero out the scratchpad counts in preparation for the populate phase
+        // of the rasterizer.
+        scratchpad_offsets_and_counts.data[global_id.x][0u] = vec4(0u);
+        scratchpad_offsets_and_counts.data[global_id.x][1u] = vec4(0u);
+    }
+}
+
+// The global allocation pass that propagates the offsets from each chunk of 256
+// clusters to later chunks sequentially.
+@compute @workgroup_size(256, 1, 1)
+fn allocate_global_main(@builtin(local_invocation_id) local_id: vec3<u32>) {
+    let cluster_count =
+        lights.cluster_dimensions.x *
+        lights.cluster_dimensions.y *
+        lights.cluster_dimensions.z;
+
+    // March along the chunks sequentially, accumulating as we go.
+    var current_offset = 0u;
+    for (var i = 0u; i < cluster_count; i += 256u) {
+        offsets_and_counts.data[i + local_id.x][0].x += current_offset;
+        storageBarrier();
+
+        if (i + 255u < cluster_count) {
+            current_offset = offsets_and_counts.data[i + 255u][0].x +
+                cluster_object_count(i + 255u);
+        }
+    }
+    storageBarrier();
+
+    // Write in the final size. This will be read back to the CPU so that the
+    // buffer can be resized if necessary.
+    if (local_id.x == 0u) {
+        clustering_metadata.index_list_size = offsets_and_counts.data[cluster_count - 1][0].x +
+            cluster_object_count(cluster_count - 1);
+    }
+}
+
+// Returns the total number of objects in the given cluster.
+fn cluster_object_count(cluster_index: u32) -> u32 {
+    return
+        offsets_and_counts.data[cluster_index][0].y +
+        offsets_and_counts.data[cluster_index][0].z +
+        offsets_and_counts.data[cluster_index][0].w +
+        offsets_and_counts.data[cluster_index][1].x +
+        offsets_and_counts.data[cluster_index][1].y;
+}
diff --git a/crates/bevy_pbr/src/cluster/cluster_raster.wgsl b/crates/bevy_pbr/src/cluster/cluster_raster.wgsl
new file mode 100644
index 0000000000000..54fd20d91aa82
--- /dev/null
+++ b/crates/bevy_pbr/src/cluster/cluster_raster.wgsl
@@ -0,0 +1,525 @@
+#import bevy_pbr::cluster::{
+    Aabb, CLUSTERABLE_OBJECT_TYPE_DECAL, CLUSTERABLE_OBJECT_TYPE_IRRADIANCE_VOLUME,
+    CLUSTERABLE_OBJECT_TYPE_POINT_LIGHT, CLUSTERABLE_OBJECT_TYPE_REFLECTION_PROBE,
+    CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT, ClusterableObjectZSlice,
+    calculate_sphere_cluster_bounds, compute_view_from_world_scale
+}
+#import bevy_pbr::clustered_forward
+#import bevy_pbr::light_probes::transpose_affine_matrix
+#import bevy_pbr::mesh_view_types::{
+    ClusterOffsetsAndCounts, ClusterableObjectIndexLists, ClusteredDecals, ClusteredLights,
+    LightProbes, Lights, POINT_LIGHT_FLAGS_SPOT_LIGHT_Y_NEGATIVE
+}
+#import bevy_render::view::View
+
+// The shader that performs the cluster-object intersection tests and assigns
+// objects to clusters as appropriate.
+//
+// Assuming the froxel grid has size WxHxD, this shader is expected to run on a
+// viewport of size WxH. It draws each *Z slice* as an axis aligned quad such
+// that each fragment shader invocation represents a single cluster-object pair
+// in the froxel grid. The fragment shader performs a finer test to see if the
+// object might intersects the cluster and, if it succeeds, records the result.
+// Because the result is written to storage buffers, color writes are disabled
+// for this shader invocation.
+//
+// This shader runs twice: once to accumulate the *count* of each object type in
+// each cluster, and once to *populate* the actual IDs. Both invocations of the
+// shader must compute the exact same visibility results.
+
+struct Vertex {
+    @builtin(instance_index) instance_id: u32,
+    @location(0) position: vec2<f32>,
+}
+
+// Data output from the vertex shader and input to the fragment shader.
+struct Varyings {
+    @builtin(position) position: vec4<f32>,
+    // The index of the Z slice we're rasterizing.
+    @location(0) @interpolate(flat) instance_id: u32,
+    // The view-space center of the bounding sphere of the object.
+    @location(1) @interpolate(flat) sphere_position: vec3<f32>,
+    // The view-space radius of the bounding sphere of the object.
+    @location(2) @interpolate(flat) sphere_radius: f32,
+}
+
+// The same as the `ClusterOffsetsAndCounts` structure, but with atomic fields
+// so that we can write to it.
+struct ClusterOffsetsAndCountsAtomic {
+    data: array<ClusterOffsetsAndCountsElementAtomic>,
+}
+
+// The same as the `ClusterOffsetsAndCountsElement` structure, but with atomic
+// fields so that we can write to it.
+struct ClusterOffsetsAndCountsElementAtomic {
+    offset: atomic<u32>,
+    point_lights: atomic<u32>,
+    spot_lights: atomic<u32>,
+    reflection_probes: atomic<u32>,
+    irradiance_volumes: atomic<u32>,
+    decals: atomic<u32>,
+    pad_a: u32,
+    pad_b: u32,
+}
+
+// The list of clusterable object Z slices that we read from to.
+@group(0) @binding(0) var<storage> z_slices: array<ClusterableObjectZSlice>;
+// The list of indices per cluster that we write to in the populate pass.
+@group(0) @binding(1) var<storage, read_write> index_lists: ClusterableObjectIndexLists;
+// Information about each light.
+@group(0) @binding(2) var<storage> clustered_lights: ClusteredLights;
+// Information about each light probe (reflection probe or irradiance volume).
+@group(0) @binding(3) var<uniform> light_probes: LightProbes;
+// Information about each clustered decal.
+@group(0) @binding(4) var<storage> clustered_decals: ClusteredDecals;
+// Information about the clusters as a whole, including the dimensions of the
+// cluster grid.
+@group(0) @binding(5) var<uniform> lights: Lights;
+// Information about the view.
+@group(0) @binding(6) var<uniform> view: View;
+#ifdef POPULATE_PASS
+// The number of objects in each cluster, and the offset of each list.
+@group(0) @binding(7) var<storage> offsets_and_counts: ClusterOffsetsAndCounts;
+// For each cluster, the counts of objects written *so far* to it.
+//
+// We use this during the populate phase in order to write the ID of each object
+// to the correct spot.
+@group(0) @binding(8) var<storage, read_write> scratchpad_offsets_and_counts:
+    ClusterOffsetsAndCountsAtomic;
+#else   // POPULATE_PASS
+// The number of objects in each cluster.
+//
+// During the count pass, we write to this.
+@group(0) @binding(7) var<storage, read_write> offsets_and_counts: ClusterOffsetsAndCountsAtomic;
+#endif  // POPULATE_PASS
+
+// The vertex entry point.
+@vertex
+fn vertex_main(vertex: Vertex) -> Varyings {
+    let instance_id = vertex.instance_id;
+    let object_index = z_slices[instance_id].object_index;
+    let object_type = z_slices[instance_id].object_type;
+
+    // Look up the world space bounding sphere of the object.
+    let bounding_sphere = get_object_bounding_sphere(object_index, object_type);
+    let position = bounding_sphere.xyz;
+    let radius = bounding_sphere.w;
+
+    let view_from_world_scale = compute_view_from_world_scale(view.world_from_view);
+    let max_view_from_world_scale = max(view_from_world_scale.x,
+        max(view_from_world_scale.y, view_from_world_scale.z));
+    let is_orthographic = view.clip_from_view[3].w == 1.0;
+
+    // Calculate an approximate AABB of the cluster by computing its bounding
+    // sphere and converting that to the AABB.
+    // It's possible to do better, as the CPU version of
+    // `assign_objects_to_clusters` does with its *iterative sphere refinement*
+    // algorithm. However, that's sequential. I believe that this simple
+    // approach is the standard way to do cluster assignment on GPU.
+    let cluster_bounds = calculate_sphere_cluster_bounds(
+        position,
+        radius,
+        view.view_from_world,
+        view.clip_from_view,
+        view_from_world_scale,
+        lights.cluster_dimensions.xyz,
+        lights.cluster_factors.zw,
+        is_orthographic
+    );
+    let cluster_bounds_xy = vec4<u32>(cluster_bounds.min.xy, cluster_bounds.max.xy + vec2<u32>(1u));
+
+    // Calculate the bounding sphere's center and radius in view space.
+    let view_position = (view.view_from_world * vec4(position, 1.0)).xyz;
+    let view_radius = max_view_from_world_scale * radius;
+
+    return Varyings(
+        calculate_vertex_position(vertex, cluster_bounds_xy),
+        instance_id,
+        view_position,
+        view_radius
+    );
+}
+
+// Returns the position of the quad vertex necessary to enclose all the
+// fragments that represent the cluster AABB.
+// The cluster bounds are supplied as `vec4(min X, min Y, max X, max Y)`.
+fn calculate_vertex_position(vertex: Vertex, cluster_bounds: vec4<u32>) -> vec4<f32> {
+    let framebuffer_position = vec2<u32>(
+        select(cluster_bounds.x, cluster_bounds.z, vertex.position.x == 1.0),
+        select(cluster_bounds.y, cluster_bounds.w, vertex.position.y == 1.0)
+    );
+    let vertex_position =
+        vec2<f32>(framebuffer_position) / vec2<f32>(lights.cluster_dimensions.xy);
+    return vec4(mix(vec2(-1.0, 1.0), vec2(1.0, -1.0), vertex_position), 0.0, 1.0);
+}
+
+// Performs a fine-grained test to ensure that the object intersects a single
+// froxel and records the result.
+@fragment
+fn fragment_main(varyings: Varyings) -> @location(0) vec4<f32> {
+    let instance_id = varyings.instance_id;
+    let object_index = z_slices[instance_id].object_index;
+    let object_type = z_slices[instance_id].object_type;
+    let z_slice = z_slices[instance_id].z_slice;
+
+    let is_orthographic = view.clip_from_view[3].w == 1.0;
+    let screen_size = view.viewport.zw;
+    let tile_size = screen_size / vec2<f32>(lights.cluster_dimensions.xy);
+
+    let z_near_far = compute_z_near_and_z_far(is_orthographic);
+    let z_near = z_near_far.x;
+    let z_far = z_near_far.y;
+
+    // Determine the AABB of the cluster this fragment represents.
+    let cluster_position = vec3<u32>(vec2<u32>(floor(varyings.position.xy)), z_slice);
+    let cluster_aabb = compute_aabb_for_cluster(
+        z_near,
+        z_far,
+        tile_size,
+        screen_size,
+        view.view_from_clip,
+        is_orthographic,
+        lights.cluster_dimensions.xyz,
+        cluster_position
+    );
+    let cluster_aabb_center = (cluster_aabb.max + cluster_aabb.min) * 0.5;
+    let cluster_aabb_half_size = (cluster_aabb.max - cluster_aabb.min) * 0.5;
+
+    // See if the object sphere intersects the AABB. If it doesn't, cull the
+    // object.
+    let object_intersects_cluster_aabb = sphere_intersects_aabb(
+        varyings.sphere_position,
+        varyings.sphere_radius,
+        cluster_aabb_center,
+        cluster_aabb_half_size
+    );
+    if (!object_intersects_cluster_aabb) {
+        return vec4<f32>(0.0);
+    }
+
+    // Do further, more precise culling for spot lights.
+    if (object_type == CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT && cull_spot_light(
+        object_index,
+        cluster_aabb_center,
+        length(cluster_aabb_half_size),
+        varyings.sphere_position,
+        varyings.sphere_radius
+    )) {
+        return vec4<f32>(0.0);
+    }
+
+    let cluster_index =
+        clustered_forward::fragment_cluster_index(cluster_position, lights.cluster_dimensions);
+
+    // If this is the populate pass, reserve a slot and write in the actual
+    // object index. Otherwise, if this is the count pass, just bump the
+    // appropriate counter.
+#ifdef POPULATE_PASS
+    let output_index = allocate_list_entry(cluster_index, object_type);
+    if (output_index < arrayLength(&index_lists.data)) {
+        index_lists.data[output_index] = object_index;
+    }
+#else   // POPULATE_PASS
+    increment_object_count(cluster_index, object_type);
+#endif  // POPULATE_PASS
+
+    return vec4<f32>(0.0);
+}
+
+// Returns true if the given sphere intersects the AABB with the given
+// boundaries.
+fn sphere_intersects_aabb(
+    sphere_center: vec3<f32>,
+    sphere_radius: f32,
+    aabb_center: vec3<f32>,
+    aabb_half_size: vec3<f32>
+) -> bool {
+    let delta = max(vec3(0.0), abs(aabb_center - sphere_center) - aabb_half_size);
+    let dist_sq = dot(delta, delta);
+    return dist_sq <= sphere_radius * sphere_radius;
+}
+
+// See `bevy_light::cluster::assign::compute_aabb_for_cluster`.
+fn compute_aabb_for_cluster(
+    z_near: f32,
+    z_far: f32,
+    tile_size: vec2<f32>,
+    screen_size: vec2<f32>,
+    view_from_clip: mat4x4<f32>,
+    is_orthographic: bool,
+    cluster_dimensions: vec3<u32>,
+    ijk_u: vec3<u32>
+) -> Aabb {
+    let ijk = vec3<f32>(ijk_u);
+
+    // Calculate the minimum and maximum points in screen space
+    let p_min = ijk.xy * tile_size;
+    let p_max = p_min + tile_size;
+
+    var cluster_min: vec3<f32>;
+    var cluster_max: vec3<f32>;
+    if (is_orthographic) {
+        // Use linear depth slicing for orthographic
+
+        // Convert to view space at the cluster near and far planes
+        // NOTE: 1.0 is the near plane due to using reverse z projections
+        var p_min = screen_to_view(screen_size, view_from_clip, p_min, 0.0).xyz;
+        var p_max = screen_to_view(screen_size, view_from_clip, p_max, 0.0).xyz;
+
+        // calculate cluster depth using z_near and z_far
+        p_min.z = -z_near + (z_near - z_far) * ijk.z / f32(cluster_dimensions.z);
+        p_max.z = -z_near + (z_near - z_far) * (ijk.z + 1.0) / f32(cluster_dimensions.z);
+
+        cluster_min = min(p_min, p_max);
+        cluster_max = max(p_min, p_max);
+    } else {
+        // Convert to view space at the near plane
+        // NOTE: 1.0 is the near plane due to using reverse z projections
+        let p_min = screen_to_view(screen_size, view_from_clip, p_min, 1.0);
+        let p_max = screen_to_view(screen_size, view_from_clip, p_max, 1.0);
+
+        let z_far_over_z_near = -z_far / -z_near;
+        var cluster_near = 0.0;
+        if (ijk.z != 0.0) {
+            cluster_near = -z_near *
+                pow(z_far_over_z_near, (ijk.z - 1.0) / f32(cluster_dimensions.z - 1u));
+        }
+        // NOTE: This could be simplified to:
+        // cluster_far = cluster_near * z_far_over_z_near;
+        var cluster_far: f32;
+        if (cluster_dimensions.z == 1u) {
+            cluster_far = -z_far;
+        } else {
+            cluster_far = -z_near * pow(z_far_over_z_near, ijk.z / f32(cluster_dimensions.z - 1u));
+        }
+
+        // Calculate the four intersection points of the min and max points with the cluster near and far planes
+        let p_min_near = line_intersection_to_z_plane(vec3(0.0), p_min.xyz, cluster_near);
+        let p_min_far = line_intersection_to_z_plane(vec3(0.0), p_min.xyz, cluster_far);
+        let p_max_near = line_intersection_to_z_plane(vec3(0.0), p_max.xyz, cluster_near);
+        let p_max_far = line_intersection_to_z_plane(vec3(0.0), p_max.xyz, cluster_far);
+
+        cluster_min = min(min(p_min_near, p_min_far), min(p_max_near, p_max_far));
+        cluster_max = max(max(p_min_near, p_min_far), max(p_max_near, p_max_far));
+    }
+
+    return Aabb(cluster_min, cluster_max);
+}
+
+// Converts a screen-space position to a view-space position.
+// See `bevy_light::cluster::assign::screen_to_view`.
+fn screen_to_view(
+    screen_size: vec2<f32>,
+    view_from_clip: mat4x4<f32>,
+    screen: vec2<f32>,
+    ndc_z: f32
+) -> vec4<f32> {
+    let tex_coord = screen / screen_size;
+    let clip = vec4(
+        tex_coord.x * 2.0 - 1.0,
+        (1.0 - tex_coord.y) * 2.0 - 1.0,
+        ndc_z,
+        1.0
+    );
+    return clip_to_view(view_from_clip, clip);
+}
+
+// Converts a clip-space position to a view-space position.
+// See `bevy_light::cluster::assign::clip_to_view`.
+fn clip_to_view(view_from_clip: mat4x4<f32>, clip: vec4<f32>) -> vec4<f32> {
+    let view = view_from_clip * clip;
+    return view / view.w;
+}
+
+// Calculate the intersection of a ray from the eye through the view space
+// position to a z plane
+// See `bevy_light::cluster::assign::line_intersection_to_z_plane`.
+fn line_intersection_to_z_plane(origin: vec3<f32>, p: vec3<f32>, z: f32) -> vec3<f32> {
+    let v = p - origin;
+    let t = (z - dot(vec3(0.0, 0.0, 1.0), origin)) / dot(vec3(0.0, 0.0, 1.0), v);
+    return origin + t * v;
+}
+
+// Computes the near and far extents of the cluster grid.
+fn compute_z_near_and_z_far(is_orthographic: bool) -> vec2<f32> {
+    let cluster_dimensions = vec3<f32>(lights.cluster_dimensions.xyz);
+    let cluster_factors = lights.cluster_factors;
+    var z_near: f32;
+    var z_far: f32;
+    if (is_orthographic) {
+        z_near = -cluster_factors.z;
+        z_far = -(cluster_dimensions.z + cluster_factors.w * cluster_factors.z) / cluster_factors.w;
+    } else {
+        z_near = exp(cluster_factors.w / cluster_factors.z);
+        z_far = exp((cluster_dimensions.z + cluster_factors.w - 1.0) / cluster_factors.z);
+    }
+    return vec2<f32>(z_near, z_far);
+}
+
+// Returns true if a spot light should be culled.
+// See `assign_objects_to_clusters` in `bevy_light/src/cluster/assign.rs`.
+fn cull_spot_light(
+    object_index: u32,
+    cluster_aabb_sphere_center: vec3<f32>,
+    cluster_aabb_sphere_radius: f32,
+    sphere_position: vec3<f32>,
+    sphere_radius: f32
+) -> bool {
+    let light_custom_data = clustered_lights.data[object_index].light_custom_data;
+    let light_flags = clustered_lights.data[object_index].flags;
+    let light_tan_angle = clustered_lights.data[object_index].spot_light_tan_angle;
+
+    // `spot_light_dir_sin_cos` in `assign_objects_to_clusters` uses
+    // `normalize(view_from_world *
+    // vec4(clusterable_object.transform.back(), 0.0).xyz)`.
+    // What we have is the XZ value of
+    // `clusterable_object.transform.forward()`. So we have to first
+    // calculate the missing Y value, then flip it to go from forward to
+    // back, then transform by the view-from-world matrix to get
+    // `view_light_direction`.
+    let world_light_direction_rev_xz = light_custom_data.xy;
+    let world_light_direction_rev_y_sign = select(
+        1.0,
+        -1.0,
+        (light_flags & POINT_LIGHT_FLAGS_SPOT_LIGHT_Y_NEGATIVE) != 0u
+    );
+    let world_light_direction_rev = vec3(
+        world_light_direction_rev_xz.x,
+        world_light_direction_rev_y_sign * sqrt(
+            1.0 -
+                world_light_direction_rev_xz.x * world_light_direction_rev_xz.x -
+                world_light_direction_rev_xz.y * world_light_direction_rev_xz.y
+        ),
+        world_light_direction_rev_xz.y
+    );
+    let world_light_direction = -world_light_direction_rev;
+    let view_light_direction = normalize((view.view_from_world *
+        vec4(world_light_direction, 0.0)).xyz);
+
+    let angle_cos = cos_atan(light_tan_angle);
+    let angle_sin = sin_atan(light_tan_angle);
+
+    // test -- based on https://bartwronski.com/2017/04/13/cull-that-cone/
+    let spot_light_offset = sphere_position - cluster_aabb_sphere_center;
+    let spot_light_dist_sq = dot(spot_light_offset, spot_light_offset);
+    let v1_len = dot(spot_light_offset, view_light_direction);
+
+    let distance_closest_point = angle_cos * sqrt(spot_light_dist_sq - v1_len * v1_len) -
+        v1_len * angle_sin;
+    let angle_cull = distance_closest_point > cluster_aabb_sphere_radius;
+
+    let front_cull = v1_len > cluster_aabb_sphere_radius + sphere_radius;
+    let back_cull = v1_len < -cluster_aabb_sphere_radius;
+
+    return angle_cull || front_cull || back_cull;
+}
+
+// Computes `cos(atan(x))` cheaply.
+// See https://en.wikipedia.org/wiki/List_of_trigonometric_identities
+fn cos_atan(tan_theta: f32) -> f32 {
+    return inverseSqrt(1.0 + tan_theta * tan_theta);
+}
+
+// Computes `sin(atan(x))` cheaply.
+// See https://en.wikipedia.org/wiki/List_of_trigonometric_identities
+fn sin_atan(tan_theta: f32) -> f32 {
+    return tan_theta * inverseSqrt(1.0 + tan_theta * tan_theta);
+}
+
+#ifdef POPULATE_PASS
+// Allocates space in the appropriate list and returns the global index that the
+// object index should be written to.
+fn allocate_list_entry(cluster_index: u32, object_type: u32) -> u32 {
+    switch (object_type) {
+        case CLUSTERABLE_OBJECT_TYPE_POINT_LIGHT: {
+            return offsets_and_counts.data[cluster_index][0u].x +
+                atomicAdd(&scratchpad_offsets_and_counts.data[cluster_index].point_lights, 1u);
+        }
+        case CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT: {
+            return offsets_and_counts.data[cluster_index][0u].x +
+                offsets_and_counts.data[cluster_index][0u].y +
+                atomicAdd(&scratchpad_offsets_and_counts.data[cluster_index].spot_lights, 1u);
+        }
+        case CLUSTERABLE_OBJECT_TYPE_REFLECTION_PROBE: {
+            return offsets_and_counts.data[cluster_index][0u].x +
+                offsets_and_counts.data[cluster_index][0u].y +
+                offsets_and_counts.data[cluster_index][0u].z +
+                atomicAdd(&scratchpad_offsets_and_counts.data[cluster_index].reflection_probes, 1u);
+        }
+        case CLUSTERABLE_OBJECT_TYPE_IRRADIANCE_VOLUME: {
+            return offsets_and_counts.data[cluster_index][0u].x +
+                offsets_and_counts.data[cluster_index][0u].y +
+                offsets_and_counts.data[cluster_index][0u].z +
+                offsets_and_counts.data[cluster_index][0u].w +
+                atomicAdd(
+                    &scratchpad_offsets_and_counts.data[cluster_index].irradiance_volumes,
+                    1u
+                );
+        }
+        case CLUSTERABLE_OBJECT_TYPE_DECAL: {
+            return offsets_and_counts.data[cluster_index][0u].x +
+                offsets_and_counts.data[cluster_index][0u].y +
+                offsets_and_counts.data[cluster_index][0u].z +
+                offsets_and_counts.data[cluster_index][0u].w +
+                offsets_and_counts.data[cluster_index][1u].x +
+                atomicAdd(&scratchpad_offsets_and_counts.data[cluster_index].decals, 1u);
+        }
+        default: {}
+    }
+    return 0xffffffffu;
+}
+#else   // POPULATE_PASS
+// Increments the count of objects of the given type for the given cluster.
+fn increment_object_count(cluster_index: u32, object_type: u32) {
+    switch (object_type) {
+        case CLUSTERABLE_OBJECT_TYPE_POINT_LIGHT: {
+            atomicAdd(&offsets_and_counts.data[cluster_index].point_lights, 1u);
+        }
+        case CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT: {
+            atomicAdd(&offsets_and_counts.data[cluster_index].spot_lights, 1u);
+        }
+        case CLUSTERABLE_OBJECT_TYPE_REFLECTION_PROBE: {
+            atomicAdd(&offsets_and_counts.data[cluster_index].reflection_probes, 1u);
+        }
+        case CLUSTERABLE_OBJECT_TYPE_IRRADIANCE_VOLUME: {
+            atomicAdd(&offsets_and_counts.data[cluster_index].irradiance_volumes, 1u);
+        }
+        case CLUSTERABLE_OBJECT_TYPE_DECAL: {
+            atomicAdd(&offsets_and_counts.data[cluster_index].decals, 1u);
+        }
+        default: {}
+    }
+}
+#endif  // POPULATE_PASS
+
+// Looks up and returns the world-space center and radius of the bounding sphere
+// for the object with the given index and type.
+// Returns a 4-vector with the fields `vec4(center X, center Y, center Z, radius)`.
+fn get_object_bounding_sphere(object_index: u32, object_type: u32) -> vec4<f32> {
+    var position = vec3<f32>(0.0);
+    var radius = 0.0;
+    switch (object_type) {
+        case CLUSTERABLE_OBJECT_TYPE_POINT_LIGHT: {
+            position = clustered_lights.data[object_index].position_radius.xyz;
+            radius = clustered_lights.data[object_index].range;
+        }
+        case CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT: {
+            position = clustered_lights.data[object_index].position_radius.xyz;
+            radius = clustered_lights.data[object_index].range;
+        }
+        case CLUSTERABLE_OBJECT_TYPE_REFLECTION_PROBE: {
+            position = light_probes.reflection_probes[object_index].world_position;
+            radius = light_probes.reflection_probes[object_index].bounding_sphere_radius;
+        }
+        case CLUSTERABLE_OBJECT_TYPE_IRRADIANCE_VOLUME: {
+            position = light_probes.irradiance_volumes[object_index].world_position;
+            radius = light_probes.irradiance_volumes[object_index].bounding_sphere_radius;
+        }
+        case CLUSTERABLE_OBJECT_TYPE_DECAL: {
+            position = clustered_decals.decals[object_index].world_position;
+            radius = clustered_decals.decals[object_index].bounding_sphere_radius;
+        }
+        default: {}
+    }
+    return vec4(position, radius);
+}
diff --git a/crates/bevy_pbr/src/cluster/cluster_z_slice.wgsl b/crates/bevy_pbr/src/cluster/cluster_z_slice.wgsl
new file mode 100644
index 0000000000000..a5d633d0387de
--- /dev/null
+++ b/crates/bevy_pbr/src/cluster/cluster_z_slice.wgsl
@@ -0,0 +1,203 @@
+#import bevy_pbr::cluster::{
+    CLUSTERABLE_OBJECT_TYPE_DECAL, CLUSTERABLE_OBJECT_TYPE_IRRADIANCE_VOLUME,
+    CLUSTERABLE_OBJECT_TYPE_POINT_LIGHT, CLUSTERABLE_OBJECT_TYPE_REFLECTION_PROBE,
+    CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT, ClusterMetadata, ClusterableObjectZSlice,
+    calculate_sphere_cluster_bounds, compute_view_from_world_scale
+}
+#import bevy_pbr::mesh_view_types::{
+    ClusteredDecals, ClusteredLights, LightProbes, Lights, POINT_LIGHT_FLAGS_SPOT_LIGHT_BIT
+}
+#import bevy_render::view::View
+
+// The shader that divides clusterable objects into Z slices.
+//
+// Treating the cluster froxel space as a grid of size WxHxD, for each
+// clusterable object, we seek to rasterize D overlapping quads into a viewport
+// of size WxH. Each quad represents a *Z slice* of the object. This shader
+// calculates the number of Z slices needed for each object in parallel and
+// prepares the `ClusterableObjectZSlice` data that the rasterization passes
+// will consume. It also updates the indirect draw parameters for the
+// rasterization pass and calculates statistics about the farthest Z value
+// encountered that the CPU can later read back for dynamic froxel range tuning.
+
+// Metadata, including the indirect draw parameters that we write to.
+@group(0) @binding(0) var<storage, read_write> cluster_metadata: ClusterMetadata;
+// The list of clusterable object Z slices that we write to.
+@group(0) @binding(1) var<storage, read_write> z_slices: array<ClusterableObjectZSlice>;
+// Information about each light.
+@group(0) @binding(2) var<storage> clustered_lights: ClusteredLights;
+// Information about each light probe (reflection probe or irradiance volume).
+@group(0) @binding(3) var<uniform> light_probes: LightProbes;
+// Information about each clustered decal.
+@group(0) @binding(4) var<storage> clustered_decals: ClusteredDecals;
+// Information about the clusters as a whole, including the dimensions of the
+// cluster grid.
+@group(0) @binding(5) var<uniform> lights: Lights;
+// Information about the view.
+@group(0) @binding(6) var<uniform> view: View;
+
+// A temporary workgroup-local buffer used to accelerate the "farthest depth of
+// any object" calculation.
+var<workgroup> shared_farthest_z: array<f32, 64>;
+
+// The shader entry point.
+//
+// We have one invocation per clusterable object.
+@compute @workgroup_size(64, 1, 1)
+fn z_slice_main(
+    @builtin(global_invocation_id) global_invocation_id: vec3<u32>,
+    @builtin(local_invocation_id) local_invocation_id: vec3<u32>
+) {
+    let id = global_invocation_id.x;
+    let local_id = local_invocation_id.x;
+
+    var object_index: u32 = 0u;
+    var object_type: u32 = 0xffffffffu;
+    var position: vec3<f32> = vec3<f32>(0.0);
+    var radius: f32 = 0.0;
+
+    // Figure out what the bounds are for each type of clusterable object, in
+    // preparation to determining which kind of object we're clustering.
+    // In thread order, the threads are assigned to cluster clusterable lights,
+    // reflection probes, irradiance volumes, and decals, in that order.
+    // It might look like we should have done prefix sum on
+    // `clustered_light_count`, `reflection_probe_count`, etc. to avoid all
+    // this ID math. But that would make life harder for plugins that want to
+    // add clustered objects in compute shaders, because they might have to
+    // update multiple fields (atomically!) when adding, for example, a light.
+    let last_clustered_light_id = cluster_metadata.clustered_light_count;
+    let last_reflection_probe_id = last_clustered_light_id +
+        cluster_metadata.reflection_probe_count;
+    let last_irradiance_volume_id = last_reflection_probe_id +
+        cluster_metadata.irradiance_volume_count;
+    let last_decal_id = last_irradiance_volume_id + cluster_metadata.decal_count;
+
+    // Figure out which type of object we are, and calculate our position and range.
+    // We use a sphere to conservatively construct our AABB.
+    if (id < last_clustered_light_id) {
+        // We're a light (either point light or spot light).
+        object_index = id;
+        let flags = clustered_lights.data[object_index].flags;
+        object_type = select(
+            CLUSTERABLE_OBJECT_TYPE_POINT_LIGHT,
+            CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT,
+            (flags & POINT_LIGHT_FLAGS_SPOT_LIGHT_BIT) != 0u
+        );
+        position = clustered_lights.data[object_index].position_radius.xyz;
+        radius = clustered_lights.data[object_index].range;
+    } else if (id < last_reflection_probe_id) {
+        // We're a reflection probe.
+        object_index = id - last_clustered_light_id;
+        object_type = CLUSTERABLE_OBJECT_TYPE_REFLECTION_PROBE;
+        position = light_probes.reflection_probes[object_index].world_position;
+        radius = light_probes.reflection_probes[object_index].bounding_sphere_radius;
+    } else if (id < last_irradiance_volume_id) {
+        // We're an irradiance volume.
+        object_index = id - last_reflection_probe_id;
+        object_type = CLUSTERABLE_OBJECT_TYPE_IRRADIANCE_VOLUME;
+        position = light_probes.irradiance_volumes[object_index].world_position;
+        radius = light_probes.irradiance_volumes[object_index].bounding_sphere_radius;
+    } else if (id < last_decal_id) {
+        // We're a clustered decal.
+        object_index = id - last_irradiance_volume_id;
+        object_type = CLUSTERABLE_OBJECT_TYPE_DECAL;
+        position = clustered_decals.decals[object_index].world_position;
+        radius = clustered_decals.decals[object_index].bounding_sphere_radius;
+    }
+
+    let view_from_world_scale = compute_view_from_world_scale(view.world_from_view);
+    let is_orthographic = view.clip_from_view[3].w == 1.0;
+
+    // Gather the farthest Z value among all clusters in this workgroup.
+    // We want to do this *before* bailing out below so that all threads hit the
+    // same workgroup barriers, which this function uses.
+    accumulate_farthest_z_value(local_id, position, radius, view_from_world_scale, is_orthographic);
+
+    // Bail out if we have no clusterable object to work on.
+    if (object_type == 0xffffffffu) {
+        return;
+    }
+
+    let cluster_bounds = calculate_sphere_cluster_bounds(
+        position,
+        radius,
+        view.view_from_world,
+        view.clip_from_view,
+        view_from_world_scale,
+        lights.cluster_dimensions.xyz,
+        lights.cluster_factors.zw,
+        is_orthographic
+    );
+
+    // Write out our Z slices.
+    for (var z_slice = cluster_bounds.min.z; z_slice <= cluster_bounds.max.z; z_slice += 1u) {
+        try_write_z_slice(object_index, object_type, z_slice);
+    }
+}
+
+// Writes a Z slice to the list.
+//
+// This silently fails if the list is too small, but it still updates the
+// instance count, which the CPU reads back. So, if the list is too small, the
+// CPU will end up being notified and can resize the buffer.
+fn try_write_z_slice(object_index: u32, object_type: u32, z_slice: u32) {
+    let z_slice_offset = atomicAdd(&cluster_metadata.indirect_draw_params.instance_count, 1u);
+    if (z_slice_offset >= cluster_metadata.z_slice_list_capacity) {
+        return;
+    }
+
+    z_slices[z_slice_offset].object_index = object_index;
+    z_slices[z_slice_offset].object_type = object_type;
+    z_slices[z_slice_offset].z_slice = z_slice;
+}
+
+// Records the farthest Z value for clusterable objects in this workgroup for
+// the CPU to read back.
+fn accumulate_farthest_z_value(
+    local_id: u32,
+    position: vec3<f32>,
+    radius: f32,
+    view_from_world_scale: vec3<f32>,
+    is_orthographic: bool
+) {
+    // Compute the maximum Z extent for our clusterable object.
+    let view_from_world_row_2 = transpose(view.view_from_world)[2];
+    let far_z = dot(-view_from_world_row_2, vec4(position, 1.0)) + radius * view_from_world_scale.z;
+    shared_farthest_z[local_id] = far_z;
+    workgroupBarrier();
+
+    // Reduce in local memory to quickly find the maximum Z extent of the
+    // objects in our workgroup.
+    for (var stride = 32u; stride > 0u; stride /= 2u) {
+        if (local_id < stride) {
+            shared_farthest_z[local_id] = max(
+                shared_farthest_z[local_id],
+                shared_farthest_z[local_id + stride]
+            );
+        }
+        workgroupBarrier();
+    }
+
+    // Only the first thread will continue.
+    if (local_id != 0u) {
+        return;
+    }
+
+    // Have the first thread update the global farthest-Z value.
+    // We don't have `atomicMax` for floats in WGSL, so we use CAS instead.
+    // Thankfully, we only have a few workgroups, so this shouldn't be terribly
+    // slow.
+    let this_farthest_z = shared_farthest_z[0u];
+    var that_farthest_z = bitcast<f32>(atomicLoad(&cluster_metadata.farthest_z));
+    while (this_farthest_z > that_farthest_z) {
+        let exchange_result = atomicCompareExchangeWeak(
+            &cluster_metadata.farthest_z,
+            bitcast<u32>(that_farthest_z),
+            bitcast<u32>(this_farthest_z)
+        );
+        if (exchange_result.exchanged) {
+            break;
+        }
+        that_farthest_z = bitcast<f32>(exchange_result.old_value);
+    }
+}
diff --git a/crates/bevy_pbr/src/cluster/gpu.rs b/crates/bevy_pbr/src/cluster/gpu.rs
new file mode 100644
index 0000000000000..9925399903070
--- /dev/null
+++ b/crates/bevy_pbr/src/cluster/gpu.rs
@@ -0,0 +1,1714 @@
+//! Clustering of lights and other clusterable objects on GPU.
+//!
+//! GPU light clustering uses the hardware rasterizer for compute purposes as a
+//! way to automatically distribute workloads within 2D axis-aligned bounding
+//! boxes without actually rendering any pixels. The algorithm is as follows,
+//! with each step corresponding to a raster or compute command
+//!
+//! 1. *Z slicing*: We have a 3D cluster froxel grid of size WHD and seek to
+//!    rasterize D axis-aligned quads, each of size WH, representing the range of
+//!    each clusterable object. In this compute phase, we generate D indirect
+//!    instances for each clusterable object for the subsequent indirect draws.
+//!
+//! 2. *Count rasterization*: We use instanced indirect drawing to rasterize
+//!    each quad generated in step 1 to a viewport of size WH, with color
+//!    writes disabled. Each rasterized fragment represents a cluster-object
+//!    pair. In the fragment shader, we check to see if the object
+//!    intersects the cluster, and, if it does, we atomically bump a counter
+//!    corresponding to the number of objects of the given type intersecting
+//!    the cluster in question. We don't record the ID of the object in this
+//!    phase; we simply count the number of objects.
+//!
+//! 3. *Local allocation*: Now that we know the number of objects of each
+//!    type in each cluster, we can proceed to allocate space in the
+//!    clustered object buffer for each clustered object list. To do this,
+//!    we need to perform a [*prefix sum*] operation so that each list is
+//!    tightly packed with the others. For example, if adjacent clusters
+//!    have 2, 5, and 3 objects, they'll be allocated at offsets 0, 2, and 7
+//!    respectively. This *local* step uses a [Hillis-Steele scan] in shared
+//!    memory to compute the prefix sum of each chunk of 256 clusters. We
+//!    can't go beyond 256 clusters in this local step because 256 is the
+//!    maximum workgroup size in `wgpu`.
+//!
+//! 4. *Global allocation*: To deal with the fact that we can't calculate
+//!    prefix sums beyond 256 clusters in step 3, we employ this second step
+//!    that does a sequential loop over every 256-cluster chunk, propagating
+//!    the prefix sum. At the end of this step, every list of clustered
+//!    objects is allocated.
+//!
+//! 5. *Populate rasterization*: Finally, we issue an instanced indirect
+//!    draw command using the same parameters as step (2). We test each
+//!    cluster-object pair for intersection, and, if the test passes, we
+//!    record the ID of each clustered object into the correct space in the
+//!    list, using an scratch pad buffer of atomics to store the position of
+//!    the next object in each list.
+//!
+//! [*prefix sum*]: https://en.wikipedia.org/wiki/Prefix_sum
+//!
+//! [Hillis-Steele scan]: https://en.wikipedia.org/wiki/Prefix_sum#Algorithm_1:_Shorter_span,_more_parallel
+
+use alloc::sync::Arc;
+use std::sync::Mutex;
+
+use bevy_app::{App, Plugin};
+use bevy_asset::{embedded_asset, load_embedded_asset, AssetServer, Handle};
+use bevy_camera::Camera;
+use bevy_color::Color;
+use bevy_core_pipeline::{prepass::node::early_prepass, Core3d, Core3dSystems};
+use bevy_derive::{Deref, DerefMut};
+use bevy_ecs::{
+    component::Component,
+    entity::Entity,
+    query::With,
+    resource::Resource,
+    schedule::IntoScheduleConfigs as _,
+    system::{Commands, Query, Res, ResMut},
+    world::{FromWorld, World},
+};
+use bevy_light::{
+    cluster::{Clusters, GlobalClusterGpuSettings, GlobalClusterSettings},
+    EnvironmentMapLight, IrradianceVolume,
+};
+use bevy_material::descriptor::{
+    BindGroupLayoutDescriptor, CachedComputePipelineId, CachedRenderPipelineId,
+    ComputePipelineDescriptor, FragmentState, RenderPipelineDescriptor, VertexState,
+};
+use bevy_math::{vec2, Vec2};
+use bevy_mesh::{VertexBufferLayout, VertexFormat};
+use bevy_render::{
+    diagnostic::RecordDiagnostics as _,
+    extract_resource::{ExtractResource, ExtractResourcePlugin},
+    render_resource::{
+        binding_types,
+        encase::internal::{CreateFrom as _, Reader},
+        BindGroup, BindGroupEntry, BindGroupLayoutEntries, Buffer, BufferBindingType,
+        BufferDescriptor, BufferInitDescriptor, BufferUsages, ColorTargetState, ColorWrites,
+        CommandEncoder, ComputePassDescriptor, ComputePipeline, Extent3d, IndexFormat, LoadOp,
+        MapMode, Operations, PipelineCache, RenderPassColorAttachment, RenderPassDescriptor,
+        RenderPipeline, ShaderStages, ShaderType, SpecializedComputePipeline,
+        SpecializedComputePipelines, SpecializedRenderPipeline, SpecializedRenderPipelines,
+        StorageBuffer, StoreOp, TextureDescriptor, TextureDimension, TextureFormat, TextureUsages,
+        UninitBufferVec, VertexAttribute, VertexStepMode,
+    },
+    renderer::{RenderContext, RenderDevice, RenderQueue, ViewQuery},
+    sync_world::{MainEntity, MainEntityHashMap, MainEntityHashSet, RenderEntity},
+    texture::{CachedTexture, TextureCache},
+    view::{ExtractedView, ViewUniform, ViewUniformOffset, ViewUniforms},
+    MainWorld, Render, RenderApp, RenderSystems,
+};
+use bevy_shader::{load_shader_library, Shader, ShaderDefVal};
+use bevy_utils::default;
+use bytemuck::{Pod, Zeroable};
+use tracing::{error, trace, warn};
+
+use crate::{
+    cluster::{
+        GpuClusterOffsetAndCounts, GpuClusterOffsetsAndCountsStorage,
+        GpuClusterableObjectIndexListsStorage, ViewClusterBuffers,
+    },
+    decal::clustered::{DecalsBuffer, RenderClusteredDecal, RenderClusteredDecals},
+    gpu_clustering_is_enabled, ExtractedClusterConfig, GlobalClusterableObjectMeta,
+    GpuClusteredLight, GpuLights, LightMeta, LightProbesBuffer, LightProbesUniform,
+    RenderViewLightProbes, ViewClusterBindings, ViewLightProbesUniformOffset,
+    ViewLightsUniformOffset,
+};
+
+/// The workgroup size of the `cluster_allocate.wgsl` shader.
+const ALLOCATION_WORKGROUP_SIZE: u32 = 256;
+/// The workgroup size of the `cluster_z_slice.wgsl` shader.
+const Z_SLICING_WORKGROUP_SIZE: u32 = 64;
+
+/// A plugin that enables GPU clustering of lights and other objects.
+pub struct GpuClusteringPlugin;
+
+impl Plugin for GpuClusteringPlugin {
+    fn build(&self, app: &mut App) {
+        load_shader_library!(app, "cluster.wgsl");
+        embedded_asset!(app, "cluster_z_slice.wgsl");
+        embedded_asset!(app, "cluster_raster.wgsl");
+        embedded_asset!(app, "cluster_allocate.wgsl");
+
+        app.add_plugins(ExtractResourcePlugin::<
+            GlobalClusterSettings,
+            GpuClusteringPlugin,
+        >::default());
+    }
+
+    fn finish(&self, app: &mut App) {
+        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {
+            return;
+        };
+
+        // Bail out if we have no storage buffers. This is the case when we have
+        // `WGPU_SETTINGS_PRIO="webgl2"`.
+        let render_device = render_app.world().resource::<RenderDevice>();
+        if render_device.limits().max_storage_buffers_per_shader_stage == 0 {
+            return;
+        }
+
+        render_app
+            .init_resource::<SpecializedRenderPipelines<ClusteringRasterPipeline>>()
+            .init_resource::<SpecializedComputePipelines<ClusteringZSlicingPipeline>>()
+            .init_resource::<SpecializedComputePipelines<ClusteringAllocationPipeline>>()
+            .init_resource::<RenderViewClusteringReadbackData>()
+            .init_resource::<GpuClusteringMeshBuffers>()
+            .init_resource::<ClusteringRasterPipeline>()
+            .init_resource::<ClusteringZSlicingPipeline>()
+            .init_resource::<ClusteringAllocationPipeline>()
+            .add_systems(
+                Render,
+                (prepare_clustering_pipelines, prepare_cluster_dummy_textures)
+                    .in_set(RenderSystems::Prepare)
+                    .run_if(gpu_clustering_is_enabled),
+            )
+            .add_systems(
+                Render,
+                (
+                    prepare_clusters_for_gpu_clustering,
+                    upload_view_gpu_clustering_buffers,
+                )
+                    .chain()
+                    .in_set(RenderSystems::PrepareResources)
+                    .run_if(gpu_clustering_is_enabled),
+            )
+            .add_systems(
+                Render,
+                prepare_clustering_bind_groups
+                    .in_set(RenderSystems::PrepareBindGroups)
+                    .run_if(gpu_clustering_is_enabled),
+            )
+            .add_systems(
+                Core3d,
+                cluster_on_gpu
+                    .before(early_prepass)
+                    .in_set(Core3dSystems::Prepass)
+                    .run_if(gpu_clustering_is_enabled),
+            );
+    }
+}
+
+/// The texture that we bind when performing the raster passes.
+///
+/// We don't actually write to this texture; it exists only so that we can set a
+/// viewport.
+#[derive(Component, Deref, DerefMut)]
+pub struct ViewClusteringDummyTexture(CachedTexture);
+
+/// The bind groups for each pass of GPU clustering.
+#[derive(Component)]
+pub struct ViewClusteringBindGroups {
+    /// The bind group for the Z-slicing compute pass.
+    clustering_bind_group_z_slicing_pass: BindGroup,
+    /// The bind group for the count rasterization pass.
+    clustering_bind_group_count_pass: BindGroup,
+    /// The bind group for both local and global allocation passes.
+    clustering_bind_group_allocate_pass: BindGroup,
+    /// The bind group for the populate rasterization pass.
+    clustering_bind_group_populate_pass: BindGroup,
+}
+
+/// The GPU representation of a single Z-slice of a clusterable object.
+///
+/// A Z-slice is an axis-aligned bounding box representing the potential
+/// bounding box of a clusterable object in a single Z slice of the froxel grid.
+#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, ShaderType, Pod, Zeroable)]
+#[repr(C)]
+pub struct ClusterableObjectZSlice {
+    /// The index of the object to be clustered.
+    pub object_index: u32,
+    /// The type of the object to be clustered.
+    ///
+    /// This is one of the `CLUSTERABLE_OBJECT_TYPE_` constants in
+    /// `cluster.wgsl`.
+    pub object_type: u32,
+    /// The Z coordinate of the froxels that this slice covers.
+    pub z_slice: u32,
+}
+
+/// Metadata stored on GPU that's global to all clusters for a view.
+#[derive(Clone, Copy, Default, ShaderType, Pod, Zeroable)]
+#[repr(C)]
+pub struct ClusterMetadata {
+    /// The indirect draw parameters for the raster passes.
+    indirect_draw_params: ClusterRasterIndirectDrawParams,
+
+    /// The total number of clustered lights, set by the CPU.
+    clustered_light_count: u32,
+    /// The total number of reflection probes, set by the CPU.
+    reflection_probe_count: u32,
+    /// The total number of irradiance volumes, set by the CPU.
+    irradiance_volume_count: u32,
+    /// The total number of clustered decals, set by the CPU.
+    decal_count: u32,
+
+    /// The current maximum size of the Z-slice list.
+    z_slice_list_capacity: u32,
+
+    /// The current size of the clustered object index list.
+    ///
+    /// This is set to 0 by the CPU, and the GPU updates it with the computed
+    /// value.
+    index_list_capacity: u32,
+
+    /// The farthest depth that any clustered object AABB has extended to this
+    /// frame.
+    ///
+    /// This is set to 0 by the CPU, and the GPU updates it with the computed
+    /// value.
+    farthest_z: f32,
+}
+
+/// Indirect draw parameters for the raster dispatch phase, built partially by
+/// the CPU and partially by the GPU.
+///
+/// These must conform to the format that `wgpu` demands, so this structure
+/// layout must not be modified.
+#[derive(Clone, Copy, Default, ShaderType, Pod, Zeroable)]
+#[repr(C)]
+pub struct ClusterRasterIndirectDrawParams {
+    index_count: u32,
+
+    /// Represents the total number of Z slices.
+    ///
+    /// This field is the one that the GPU modifies.
+    instance_count: u32,
+
+    first_index: u32,
+    base_vertex: u32,
+    first_instance: u32,
+}
+
+/// A component, stored on [`ExtractedView`], that stores buffers needed to
+/// perform GPU clustering for that view.
+#[derive(Component)]
+pub struct ViewGpuClusteringBuffers {
+    /// The buffer that holds the Z slices for each clusterable object.
+    ///
+    /// The `cluster_z_slice.wgsl` shader fills this buffer out, and the raster
+    /// passes read it.
+    pub z_slices_buffer: UninitBufferVec<ClusterableObjectZSlice>,
+    /// The buffer that holds the scratchpad offsets and counts for each
+    /// clusterable object.
+    ///
+    /// The populate pass uses this to coordinate where to write indices for
+    /// each clusterable object. The allocation pass zeroes it out.
+    scratchpad_offsets_and_counts_buffer: UninitBufferVec<GpuClusterOffsetAndCounts>,
+    /// The buffer that stores the [`ClusterMetadata`].
+    ///
+    /// Since this buffer is small, [`StorageBuffer`] is fine to use.
+    cluster_metadata_buffer: StorageBuffer<ClusterMetadata>,
+}
+
+impl ViewGpuClusteringBuffers {
+    /// Creates a new, empty set of [`ViewGpuClusteringBuffers`] for a single
+    /// view.
+    pub(crate) fn new() -> ViewGpuClusteringBuffers {
+        let mut cluster_metadata_buffer = StorageBuffer::from(ClusterMetadata::default());
+        cluster_metadata_buffer.add_usages(BufferUsages::COPY_SRC | BufferUsages::INDIRECT);
+        cluster_metadata_buffer.set_label(Some("clustering Z slicing metadata buffer"));
+
+        ViewGpuClusteringBuffers {
+            cluster_metadata_buffer,
+            z_slices_buffer: UninitBufferVec::new(BufferUsages::STORAGE | BufferUsages::COPY_DST),
+            scratchpad_offsets_and_counts_buffer: UninitBufferVec::new(
+                BufferUsages::STORAGE | BufferUsages::COPY_DST,
+            ),
+        }
+    }
+}
+
+/// Stores data associated with reading back clustering statistics from GPU to
+/// CPU for all views.
+#[derive(Resource, Default)]
+pub(crate) struct RenderViewClusteringReadbackData {
+    /// The data for each view.
+    ///
+    /// This is locked behind a mutex so that the buffer readback callbacks,
+    /// which execute concurrently, can access it alongside the render world.
+    views: MainEntityHashMap<Arc<Mutex<ViewClusteringReadbackData>>>,
+}
+
+/// Data associated with reading back clustering statistics for a single view.
+struct ViewClusteringReadbackData {
+    /// The current capacity of the Z slice list.
+    ///
+    /// This starts out at the default size as specified by the allocation and
+    /// can grow based on the results of GPU readback.
+    z_slice_list_capacity: usize,
+    /// The current capacity of the clustered object index list.
+    ///
+    /// This starts out at the default size as specified by the allocation and
+    /// can grow based on the results of GPU readback.
+    max_index_list_capacity: usize,
+    /// Buffers corresponding to GPU readback operations in progress.
+    metadata_staging_pending_buffers: Vec<Buffer>,
+    /// Buffers corresponding to GPU readback operations that are finished.
+    ///
+    /// These buffers are ready for reuse.
+    metadata_staging_free_buffers: Vec<Buffer>,
+    /// Statistics about GPU clustering that the GPU calculated last frame.
+    last_frame_statistics: Option<ViewClusteringLastFrameStatistics>,
+}
+
+/// Statistics about GPU clustering that the GPU calculated last frame.
+struct ViewClusteringLastFrameStatistics {
+    /// The actual used size of the index list.
+    ///
+    /// If this is greater than the capacity of the index list, the CPU will
+    /// resize the index list buffer.
+    index_list_size: u32,
+    /// The maximum depth of all axis-aligned bounding boxes corresponding to
+    /// clusterable objects in view.
+    farthest_z: f32,
+}
+
+impl ViewClusteringReadbackData {
+    /// Creates a new [`ViewClusteringReadbackData`] for a view.
+    ///
+    /// The [`Self::z_slice_list_capacity`] and
+    /// [`Self::max_index_list_capacity`] are calculated based on the initial
+    /// capacities that the application set in the [`GlobalClusterGpuSettings`].
+    fn new(settings: &GlobalClusterGpuSettings) -> ViewClusteringReadbackData {
+        ViewClusteringReadbackData {
+            z_slice_list_capacity: settings.initial_z_slice_list_capacity,
+            max_index_list_capacity: settings.initial_index_list_capacity,
+            metadata_staging_pending_buffers: vec![],
+            metadata_staging_free_buffers: vec![],
+            last_frame_statistics: None,
+        }
+    }
+
+    fn get_or_create_staging_buffer(&mut self, render_device: &RenderDevice) -> Buffer {
+        let staging_buffer = self.metadata_staging_free_buffers.pop().unwrap_or_else(|| {
+            render_device.create_buffer(&BufferDescriptor {
+                label: Some("clustering metadata staging buffer"),
+                size: ClusterMetadata::min_size().into(),
+                usage: BufferUsages::COPY_DST | BufferUsages::MAP_READ,
+                mapped_at_creation: false,
+            })
+        });
+        self.metadata_staging_pending_buffers
+            .push(staging_buffer.clone());
+        staging_buffer
+    }
+
+    /// Updates this [`ViewClusteringReadbackData`] with new information from
+    /// the given metadata read back from the GPU.
+    fn update_from_metadata(&mut self, gpu_clustering_metadata: &ClusterMetadata) {
+        // Schedule a resize of the Z slice list if the GPU overflowed.
+        if self.z_slice_list_capacity
+            < gpu_clustering_metadata.indirect_draw_params.instance_count as usize
+        {
+            let new_capacity = gpu_clustering_metadata
+                .indirect_draw_params
+                .instance_count
+                .next_power_of_two();
+            warn!(
+                "Resizing the view clustering Z slice list from a capacity of {0} elements to \
+                a capacity of {1} elements. The scene lighting may have been corrupted for a \
+                few frames. To avoid this, set the `gpu_clustering.z_slice_list_capacity` field \
+                on the `GlobalClusterSettings` resource to at least {1}.",
+                self.z_slice_list_capacity, new_capacity
+            );
+            self.z_slice_list_capacity = new_capacity as usize;
+        }
+
+        // Schedule a resize of the index slice list if the GPU overflowed.
+        if self.max_index_list_capacity < gpu_clustering_metadata.index_list_capacity as usize {
+            let new_capacity = gpu_clustering_metadata
+                .index_list_capacity
+                .next_power_of_two();
+            warn!(
+                "Resizing the view clustering index list from a capacity of {0} elements to a \
+                capacity of {1} elements. The scene lighting may have been corrupted for a \
+                few frames. To avoid this, set the `gpu_clustering.index_list_capacity` field on \
+                the `GlobalClusterSettings` resource to at least {1}.",
+                self.max_index_list_capacity, new_capacity
+            );
+            self.max_index_list_capacity = new_capacity as usize;
+        }
+
+        // Record the statistics we just received.
+        self.last_frame_statistics = Some(ViewClusteringLastFrameStatistics {
+            index_list_size: gpu_clustering_metadata.index_list_capacity,
+            farthest_z: gpu_clustering_metadata.farthest_z,
+        });
+    }
+}
+
+/// Global data relating to the `cluster_raster.wgsl` shader.
+#[derive(Resource)]
+pub struct ClusteringRasterPipeline {
+    /// The bind group layout for group 0 for the count (first) pass.
+    pub bind_group_layout_count_pass: BindGroupLayoutDescriptor,
+    /// The bind group layout for group 0 for the populate (second) pass.
+    pub bind_group_layout_populate_pass: BindGroupLayoutDescriptor,
+    /// A handle to the shader itself.
+    pub shader: Handle<Shader>,
+}
+
+/// Global data relating to the `cluster_z_slice.wgsl` shader.
+#[derive(Resource)]
+pub struct ClusteringZSlicingPipeline {
+    /// The bind group layout for group 0.
+    pub bind_group_layout: BindGroupLayoutDescriptor,
+    /// A handle to the shader itself.
+    pub shader: Handle<Shader>,
+}
+
+/// Global data relating to the `cluster_allocate.wgsl` shader.
+#[derive(Resource)]
+pub struct ClusteringAllocationPipeline {
+    /// The bind group layout of group 0 for both shader invocations.
+    pub bind_group_layout: BindGroupLayoutDescriptor,
+    /// A handle to the `cluster_allocate.wgsl` shader itself.
+    pub shader: Handle<Shader>,
+}
+
+/// The pipeline key that identifies specializations of the
+/// `cluster_raster.wgsl` shader.
+#[derive(Clone, Copy, PartialEq, Eq, Hash)]
+pub struct ClusteringRasterPipelineKey {
+    /// True if this is the populate (second) pass; false if it's the count
+    /// (first) one.
+    populate_pass: bool,
+}
+
+/// The pipeline key that identifies specializations of the
+/// `cluster_allocate.wgsl` shader.
+#[derive(Clone, Copy, PartialEq, Eq, Hash)]
+pub struct ClusteringAllocationPipelineKey {
+    /// True if this is the global (second) pass; false if it's the local
+    /// (first) one.
+    global_pass: bool,
+}
+
+impl FromWorld for ClusteringRasterPipeline {
+    fn from_world(world: &mut World) -> Self {
+        let asset_server = world.resource::<AssetServer>();
+
+        let mut bind_group_layout_entries_count_pass = vec![
+            // @group(0) @binding(0) var<storage> z_slices:
+            // array<ClusterableObjectZSlice>;
+            binding_types::storage_buffer_read_only::<ClusterableObjectZSlice>(false)
+                .build(0, ShaderStages::VERTEX_FRAGMENT),
+            // @group(0) @binding(1) var<storage, read_write> index_lists:
+            // ClusterableObjectIndexLists;
+            binding_types::storage_buffer::<GpuClusterableObjectIndexListsStorage>(false)
+                .build(1, ShaderStages::VERTEX_FRAGMENT),
+            // @group(0) @binding(2) var<storage> clustered_lights:
+            // ClusteredLights;
+            binding_types::storage_buffer_read_only::<GpuClusteredLight>(false)
+                .build(2, ShaderStages::VERTEX_FRAGMENT),
+            // @group(0) @binding(3) var<uniform> light_probes: LightProbes;
+            binding_types::uniform_buffer::<LightProbesUniform>(true)
+                .build(3, ShaderStages::VERTEX_FRAGMENT),
+            // @group(0) @binding(4) var<storage> clustered_decals:
+            // ClusteredDecals;
+            binding_types::storage_buffer_read_only::<RenderClusteredDecal>(false)
+                .build(4, ShaderStages::VERTEX_FRAGMENT),
+            // @group(0) @binding(5) var<uniform> lights: Lights;
+            binding_types::uniform_buffer::<GpuLights>(true)
+                .build(5, ShaderStages::VERTEX_FRAGMENT),
+            // @group(0) @binding(6) var<uniform> view: View;
+            binding_types::uniform_buffer::<ViewUniform>(true)
+                .build(6, ShaderStages::VERTEX_FRAGMENT),
+        ];
+
+        let mut bind_group_layout_entries_populate_pass =
+            bind_group_layout_entries_count_pass.clone();
+
+        // @group(0) @binding(7) var<storage, read_write> offsets_and_counts:
+        // ClusterOffsetsAndCountsAtomic;
+        bind_group_layout_entries_count_pass.push(
+            binding_types::storage_buffer::<GpuClusterOffsetsAndCountsStorage>(false)
+                .build(7, ShaderStages::VERTEX_FRAGMENT),
+        );
+
+        // @group(0) @binding(7) var<storage> offsets_and_counts:
+        // ClusterOffsetsAndCounts;
+        bind_group_layout_entries_populate_pass.push(
+            binding_types::storage_buffer_read_only::<GpuClusterOffsetsAndCountsStorage>(false)
+                .build(7, ShaderStages::VERTEX_FRAGMENT),
+        );
+        // @group(0) @binding(8) var<storage, read_write>
+        // scratchpad_offsets_and_counts: ClusterOffsetsAndCountsAtomic;
+        bind_group_layout_entries_populate_pass.push(
+            binding_types::storage_buffer::<GpuClusterOffsetsAndCountsStorage>(false)
+                .build(8, ShaderStages::VERTEX_FRAGMENT),
+        );
+
+        let bind_group_layout_count_pass = BindGroupLayoutDescriptor::new(
+            "clustering count pass bind group layout",
+            &bind_group_layout_entries_count_pass,
+        );
+        let bind_group_layout_populate_pass = BindGroupLayoutDescriptor::new(
+            "clustering populate pass bind group layout",
+            &bind_group_layout_entries_populate_pass,
+        );
+
+        let shader = load_embedded_asset!(asset_server, "cluster_raster.wgsl");
+
+        ClusteringRasterPipeline {
+            bind_group_layout_count_pass,
+            bind_group_layout_populate_pass,
+            shader,
+        }
+    }
+}
+
+impl SpecializedRenderPipeline for ClusteringRasterPipeline {
+    type Key = ClusteringRasterPipelineKey;
+
+    fn specialize(&self, key: Self::Key) -> RenderPipelineDescriptor {
+        let mut shader_defs = vec![];
+        if key.populate_pass {
+            shader_defs.push(ShaderDefVal::from("POPULATE_PASS"));
+        } else {
+            shader_defs.push(ShaderDefVal::from("COUNT_PASS"));
+        }
+
+        RenderPipelineDescriptor {
+            label: if key.populate_pass {
+                Some("clustering populate pipeline".into())
+            } else {
+                Some("clustering count pipeline".into())
+            },
+            layout: vec![if key.populate_pass {
+                self.bind_group_layout_populate_pass.clone()
+            } else {
+                self.bind_group_layout_count_pass.clone()
+            }],
+            immediate_size: 0,
+            vertex: VertexState {
+                shader: self.shader.clone(),
+                shader_defs: shader_defs.clone(),
+                entry_point: Some("vertex_main".into()),
+                buffers: vec![VertexBufferLayout {
+                    array_stride: size_of::<Vec2>() as u64,
+                    step_mode: VertexStepMode::Vertex,
+                    attributes: vec![VertexAttribute {
+                        format: VertexFormat::Float32x2,
+                        offset: 0,
+                        shader_location: 0,
+                    }],
+                }],
+            },
+            fragment: Some(FragmentState {
+                shader: self.shader.clone(),
+                shader_defs: shader_defs.clone(),
+                entry_point: Some("fragment_main".into()),
+                targets: vec![Some(ColorTargetState {
+                    format: TextureFormat::R8Unorm,
+                    blend: None,
+                    // Disable writing.
+                    write_mask: ColorWrites::empty(),
+                })],
+            }),
+            ..default()
+        }
+    }
+}
+
+impl FromWorld for ClusteringZSlicingPipeline {
+    fn from_world(world: &mut World) -> Self {
+        let asset_server = world.resource::<AssetServer>();
+
+        let bind_group_layout = BindGroupLayoutDescriptor::new(
+            "clustering Z slicing pass bind group layout",
+            &BindGroupLayoutEntries::sequential(
+                ShaderStages::COMPUTE,
+                (
+                    // @group(0) @binding(0) var<storage, read_write>
+                    // cluster_metadata: ClusterMetadata;
+                    binding_types::storage_buffer::<ClusterMetadata>(false),
+                    // @group(0) @binding(1) var<storage, read_write> z_slices:
+                    // array<ClusterableObjectZSlice>;
+                    binding_types::storage_buffer::<ClusterableObjectZSlice>(false),
+                    // @group(0) @binding(2) var<storage> clustered_lights:
+                    // ClusteredLights;
+                    binding_types::storage_buffer_read_only::<GpuClusteredLight>(false),
+                    // @group(0) @binding(3) var<uniform> light_probes:
+                    // LightProbes;
+                    binding_types::uniform_buffer::<LightProbesUniform>(true),
+                    // @group(0) @binding(4) var<storage> clustered_decals:
+                    // ClusteredDecals;
+                    binding_types::storage_buffer_read_only::<RenderClusteredDecal>(false),
+                    // @group(0) @binding(5) var<uniform> lights: Lights;
+                    binding_types::uniform_buffer::<GpuLights>(true),
+                    // @group(0) @binding(6) var<uniform> view: View;
+                    binding_types::uniform_buffer::<ViewUniform>(true),
+                ),
+            ),
+        );
+
+        let shader = load_embedded_asset!(asset_server, "cluster_z_slice.wgsl");
+
+        ClusteringZSlicingPipeline {
+            bind_group_layout,
+            shader,
+        }
+    }
+}
+
+impl SpecializedComputePipeline for ClusteringZSlicingPipeline {
+    type Key = ();
+
+    fn specialize(&self, _: Self::Key) -> ComputePipelineDescriptor {
+        ComputePipelineDescriptor {
+            label: Some("clustering Z slicing pipeline".into()),
+            layout: vec![self.bind_group_layout.clone()],
+            shader: self.shader.clone(),
+            shader_defs: vec![],
+            entry_point: Some("z_slice_main".into()),
+            zero_initialize_workgroup_memory: true,
+            ..default()
+        }
+    }
+}
+
+impl FromWorld for ClusteringAllocationPipeline {
+    fn from_world(world: &mut World) -> Self {
+        let asset_server = world.resource::<AssetServer>();
+
+        let bind_group_layout = BindGroupLayoutDescriptor::new(
+            "clustering allocation pass bind group layout",
+            &BindGroupLayoutEntries::sequential(
+                ShaderStages::COMPUTE,
+                (
+                    // @group(0) @binding(0) var<storage, read_write>
+                    // offsets_and_counts: ClusterOffsetsAndCounts;
+                    binding_types::storage_buffer::<GpuClusterOffsetsAndCountsStorage>(false),
+                    // @group(0) @binding(1) var<uniform> lights: Lights;
+                    binding_types::uniform_buffer::<GpuLights>(true),
+                    // @group(0) @binding(2) var<storage, read_write>
+                    // clustering_metadata: ClusterMetadata;
+                    binding_types::storage_buffer::<ClusterMetadata>(false),
+                    // @group(0) @binding(3) var<storage, read_write>
+                    // scratchpad_offsets_and_counts: ClusterOffsetsAndCounts;
+                    binding_types::storage_buffer::<GpuClusterOffsetsAndCountsStorage>(false),
+                ),
+            ),
+        );
+
+        let shader = load_embedded_asset!(asset_server, "cluster_allocate.wgsl");
+
+        ClusteringAllocationPipeline {
+            bind_group_layout,
+            shader,
+        }
+    }
+}
+
+impl SpecializedComputePipeline for ClusteringAllocationPipeline {
+    type Key = ClusteringAllocationPipelineKey;
+
+    fn specialize(&self, key: Self::Key) -> ComputePipelineDescriptor {
+        ComputePipelineDescriptor {
+            label: if key.global_pass {
+                Some("clustering allocation global pass pipeline".into())
+            } else {
+                Some("clustering allocation local pass pipeline".into())
+            },
+            layout: vec![self.bind_group_layout.clone()],
+            shader: self.shader.clone(),
+            shader_defs: vec![],
+            entry_point: if key.global_pass {
+                Some("allocate_global_main".into())
+            } else {
+                Some("allocate_local_main".into())
+            },
+            zero_initialize_workgroup_memory: true,
+            ..default()
+        }
+    }
+}
+
+/// The vertices of the quad that we rasterize to represent a clusterable object
+/// Z slice.
+static GPU_CLUSTERING_VERTICES: [Vec2; 4] = [
+    vec2(0.0, 0.0),
+    vec2(1.0, 0.0),
+    vec2(0.0, 1.0),
+    vec2(1.0, 1.0),
+];
+
+/// The indices of the quad that we rasterize to represent a clusterable object
+/// Z slice.
+static GPU_CLUSTERING_INDICES: [u32; 6] = [0, 1, 2, 1, 3, 2];
+
+/// The buffers that store the vertices and indices for the quad that we
+/// rasterize to represent each clusterable object Z slice.
+#[derive(Resource)]
+struct GpuClusteringMeshBuffers {
+    /// The vertex buffer containing the 4 vertices of a quad.
+    vertex_buffer: Buffer,
+    /// The index buffer containing the 6 indices of a quad.
+    index_buffer: Buffer,
+}
+
+impl FromWorld for GpuClusteringMeshBuffers {
+    fn from_world(world: &mut World) -> Self {
+        let render_device = world.resource::<RenderDevice>();
+        GpuClusteringMeshBuffers {
+            vertex_buffer: render_device.create_buffer_with_data(&BufferInitDescriptor {
+                label: Some("GPU clustering vertex buffer"),
+                contents: bytemuck::bytes_of(&GPU_CLUSTERING_VERTICES),
+                usage: BufferUsages::COPY_DST | BufferUsages::VERTEX,
+            }),
+            index_buffer: render_device.create_buffer_with_data(&BufferInitDescriptor {
+                label: Some("GPU clustering index buffer"),
+                contents: bytemuck::bytes_of(&GPU_CLUSTERING_INDICES),
+                usage: BufferUsages::COPY_DST | BufferUsages::INDEX,
+            }),
+        }
+    }
+}
+
+/// The IDs of each pipeline used for GPU clustering for a single view.
+#[derive(Component)]
+pub struct ViewGpuClusteringPipelineIds {
+    /// The compute pipeline for the Z slicing compute pass (pass 1).
+    clustering_z_slicing_pipeline_id: CachedComputePipelineId,
+    /// The compute pipeline for the count raster pass (pass 2).
+    clustering_count_pipeline_id: CachedRenderPipelineId,
+    /// The compute pipeline for the local allocation compute pass (pass 3).
+    clustering_allocation_local_pipeline_id: CachedComputePipelineId,
+    /// The compute pipeline for the global allocation compute pass (pass 4).
+    clustering_allocation_global_pipeline_id: CachedComputePipelineId,
+    /// The compute pipeline for the populate raster pass (pass 5).
+    clustering_populate_pipeline_id: CachedRenderPipelineId,
+}
+
+/// The render command building system that performs GPU clustering on each
+/// view.
+fn cluster_on_gpu(
+    view_query: ViewQuery<(
+        &MainEntity,
+        Option<&ViewGpuClusteringBuffers>,
+        Option<&ViewGpuClusteringPipelineIds>,
+        Option<&ViewClusteringDummyTexture>,
+        Option<&ViewClusteringBindGroups>,
+        Option<&ViewLightProbesUniformOffset>,
+        Option<&ViewLightsUniformOffset>,
+        Option<&ViewUniformOffset>,
+        Option<&ExtractedClusterConfig>,
+    )>,
+    pipeline_cache: Res<PipelineCache>,
+    clustering_mesh_buffers: Res<GpuClusteringMeshBuffers>,
+    render_view_clustering_readback_data: Res<RenderViewClusteringReadbackData>,
+    mut render_context: RenderContext,
+) {
+    let (
+        view_main_entity,
+        Some(view_gpu_clustering_buffers),
+        Some(view_gpu_clustering_pipeline_ids),
+        Some(view_clustering_dummy_texture),
+        Some(view_clustering_bind_groups),
+        Some(view_light_probes_uniform_offset),
+        Some(view_lights_uniform_offset),
+        Some(view_uniform_offset),
+        Some(extracted_cluster_config),
+    ) = view_query.into_inner()
+    else {
+        trace!("Failed to match view query; not clustering");
+        return;
+    };
+
+    let Some(view_clustering_readback_data) = render_view_clustering_readback_data
+        .views
+        .get(view_main_entity)
+    else {
+        return;
+    };
+
+    let (
+        Some(clustering_z_slicing_compute_pipeline),
+        Some(clustering_count_render_pipeline),
+        Some(clustering_allocate_local_compute_pipeline),
+        Some(clustering_allocate_global_compute_pipeline),
+        Some(clustering_populate_render_pipeline),
+    ) = (
+        pipeline_cache.get_compute_pipeline(
+            view_gpu_clustering_pipeline_ids.clustering_z_slicing_pipeline_id,
+        ),
+        pipeline_cache
+            .get_render_pipeline(view_gpu_clustering_pipeline_ids.clustering_count_pipeline_id),
+        pipeline_cache.get_compute_pipeline(
+            view_gpu_clustering_pipeline_ids.clustering_allocation_local_pipeline_id,
+        ),
+        pipeline_cache.get_compute_pipeline(
+            view_gpu_clustering_pipeline_ids.clustering_allocation_global_pipeline_id,
+        ),
+        pipeline_cache
+            .get_render_pipeline(view_gpu_clustering_pipeline_ids.clustering_populate_pipeline_id),
+    )
+    else {
+        trace!("One or more clustering pipelines not found; not clustering");
+        return;
+    };
+
+    let diagnostics = render_context.diagnostic_recorder();
+    let diagnostics = diagnostics.as_deref();
+    let time_span = diagnostics.time_span(render_context.command_encoder(), "clustering");
+
+    // Fetch a staging buffer for us to perform readback with.
+    let staging_buffer = view_clustering_readback_data
+        .lock()
+        .unwrap()
+        .get_or_create_staging_buffer(render_context.render_device());
+
+    let command_encoder = render_context.command_encoder();
+    command_encoder.push_debug_group("clustering");
+
+    // Pass 1: Z slicing.
+    run_clustering_z_slicing_pass(
+        command_encoder,
+        clustering_z_slicing_compute_pipeline,
+        &view_clustering_bind_groups.clustering_bind_group_z_slicing_pass,
+        &view_gpu_clustering_buffers.cluster_metadata_buffer,
+        view_light_probes_uniform_offset,
+        view_lights_uniform_offset,
+        view_uniform_offset,
+    );
+
+    // Pass 2: Count raster.
+    run_clustering_rasterization_pass(
+        command_encoder,
+        clustering_count_render_pipeline,
+        &view_clustering_bind_groups.clustering_bind_group_count_pass,
+        view_gpu_clustering_buffers,
+        view_light_probes_uniform_offset,
+        view_lights_uniform_offset,
+        view_uniform_offset,
+        view_clustering_dummy_texture,
+        extracted_cluster_config,
+        &clustering_mesh_buffers,
+        false,
+    );
+
+    // Pass 3: local allocation.
+    run_clustering_allocation_pass(
+        command_encoder,
+        clustering_allocate_local_compute_pipeline,
+        view_clustering_bind_groups,
+        view_lights_uniform_offset,
+        extracted_cluster_config,
+        false,
+    );
+
+    // Pass 4: global allocation.
+    run_clustering_allocation_pass(
+        command_encoder,
+        clustering_allocate_global_compute_pipeline,
+        view_clustering_bind_groups,
+        view_lights_uniform_offset,
+        extracted_cluster_config,
+        true,
+    );
+
+    // Pass 5: populate raster.
+    run_clustering_rasterization_pass(
+        command_encoder,
+        clustering_populate_render_pipeline,
+        &view_clustering_bind_groups.clustering_bind_group_populate_pass,
+        view_gpu_clustering_buffers,
+        view_light_probes_uniform_offset,
+        view_lights_uniform_offset,
+        view_uniform_offset,
+        view_clustering_dummy_texture,
+        extracted_cluster_config,
+        &clustering_mesh_buffers,
+        true,
+    );
+
+    // Schedule a readback of the readback data.
+    schedule_readback_staging(
+        command_encoder,
+        view_gpu_clustering_buffers,
+        &staging_buffer,
+    );
+    schedule_readback_buffer_map(
+        command_encoder,
+        view_clustering_readback_data.clone(),
+        &staging_buffer,
+    );
+
+    command_encoder.pop_debug_group();
+    time_span.end(render_context.command_encoder());
+
+    /// Runs the Z slicing pass (step 1).
+    fn run_clustering_z_slicing_pass(
+        command_encoder: &mut CommandEncoder,
+        clustering_z_slicing_pipeline: &ComputePipeline,
+        clustering_z_slicing_bind_group: &BindGroup,
+        clustering_cluster_metadata_buffer: &StorageBuffer<ClusterMetadata>,
+        view_light_probes_uniform_offset: &ViewLightProbesUniformOffset,
+        view_lights_uniform_offset: &ViewLightsUniformOffset,
+        view_uniform_offset: &ViewUniformOffset,
+    ) {
+        let mut compute_pass = command_encoder.begin_compute_pass(&ComputePassDescriptor {
+            label: Some("clustering Z slicing pass"),
+            ..default()
+        });
+        compute_pass.set_pipeline(clustering_z_slicing_pipeline);
+        compute_pass.set_bind_group(
+            0,
+            Some(&**clustering_z_slicing_bind_group),
+            &[
+                **view_light_probes_uniform_offset,
+                view_lights_uniform_offset.offset,
+                view_uniform_offset.offset,
+            ],
+        );
+
+        let clustering_cluster_metadata = clustering_cluster_metadata_buffer.get();
+        let clusterable_object_count = clustering_cluster_metadata.clustered_light_count
+            + clustering_cluster_metadata.reflection_probe_count
+            + clustering_cluster_metadata.irradiance_volume_count
+            + clustering_cluster_metadata.decal_count;
+
+        let workgroup_count = clusterable_object_count.div_ceil(Z_SLICING_WORKGROUP_SIZE);
+        compute_pass.dispatch_workgroups(workgroup_count, 1, 1);
+    }
+
+    /// Runs either the count or populate rasterization pass (steps 2 and 5
+    /// respectively) for a single view.
+    ///
+    /// The `populate_pass` parameter specifies whether this is a count pass
+    /// (false) or a populate pass (true).
+    fn run_clustering_rasterization_pass(
+        command_encoder: &mut CommandEncoder,
+        clustering_render_pipeline: &RenderPipeline,
+        clustering_bind_group: &BindGroup,
+        view_gpu_clustering_buffers: &ViewGpuClusteringBuffers,
+        view_light_probes_uniform_offset: &ViewLightProbesUniformOffset,
+        view_lights_uniform_offset: &ViewLightsUniformOffset,
+        view_uniform_offset: &ViewUniformOffset,
+        view_clustering_dummy_texture: &ViewClusteringDummyTexture,
+        extracted_cluster_config: &ExtractedClusterConfig,
+        clustering_mesh_buffers: &GpuClusteringMeshBuffers,
+        populate_pass: bool,
+    ) {
+        let Some(cluster_metadata_buffer) =
+            view_gpu_clustering_buffers.cluster_metadata_buffer.buffer()
+        else {
+            error!("Z slicing metadata buffer was never uploaded");
+            return;
+        };
+
+        let mut render_pass = command_encoder.begin_render_pass(&RenderPassDescriptor {
+            label: if populate_pass {
+                Some("clustering populate pass")
+            } else {
+                Some("clustering count pass")
+            },
+            color_attachments: &[Some(RenderPassColorAttachment {
+                view: &view_clustering_dummy_texture.default_view,
+                depth_slice: None,
+                resolve_target: None,
+                ops: Operations {
+                    // Do nothing to the color buffer. We only care about using
+                    // the rasterizer for fragment scheduling; we're not going
+                    // to actually paint any pixels.
+                    load: LoadOp::Clear(Color::BLACK.to_linear().into()),
+                    store: StoreOp::Discard,
+                },
+            })],
+            depth_stencil_attachment: None,
+            ..default()
+        });
+        render_pass.set_pipeline(clustering_render_pipeline);
+        render_pass.set_bind_group(
+            0,
+            Some(&**clustering_bind_group),
+            &[
+                **view_light_probes_uniform_offset,
+                view_lights_uniform_offset.offset,
+                view_uniform_offset.offset,
+            ],
+        );
+
+        // Since we rounded up the dummy texture size to prevent thrashing, we
+        // need to use an explicit viewport here so that we only render to the
+        // correct portion.
+        render_pass.set_viewport(
+            0.0,
+            0.0,
+            extracted_cluster_config.dimensions.x as f32,
+            extracted_cluster_config.dimensions.y as f32,
+            0.0,
+            1.0,
+        );
+
+        render_pass.set_vertex_buffer(0, *clustering_mesh_buffers.vertex_buffer.slice(..));
+        render_pass.set_index_buffer(
+            *clustering_mesh_buffers.index_buffer.slice(..),
+            IndexFormat::Uint32,
+        );
+        render_pass.draw_indexed_indirect(cluster_metadata_buffer, 0);
+    }
+
+    /// Runs either the local or global allocation pass (steps 3 and 4
+    /// respectively) for GPU clustering for a single view.
+    ///
+    /// The `global_pass` parameter specifies whether this is the local pass
+    /// (false) or the global pass (true).
+    fn run_clustering_allocation_pass(
+        command_encoder: &mut CommandEncoder,
+        clustering_allocation_pipeline: &ComputePipeline,
+        view_clustering_bind_groups: &ViewClusteringBindGroups,
+        view_lights_uniform_offset: &ViewLightsUniformOffset,
+        extracted_cluster_config: &ExtractedClusterConfig,
+        global_pass: bool,
+    ) {
+        let mut compute_pass = command_encoder.begin_compute_pass(&ComputePassDescriptor {
+            label: if global_pass {
+                Some("clustering allocation global pass")
+            } else {
+                Some("clustering allocation local pass")
+            },
+            ..default()
+        });
+        compute_pass.set_pipeline(clustering_allocation_pipeline);
+        compute_pass.set_bind_group(
+            0,
+            Some(&*view_clustering_bind_groups.clustering_bind_group_allocate_pass),
+            &[view_lights_uniform_offset.offset],
+        );
+
+        // The global pass has only one workgroup because it runs sequentially
+        // over chunks, while the local pass has a number of workgroups equal to
+        // the number of chunks because it runs in parallel over them.
+        let workgroup_count = if global_pass {
+            1
+        } else {
+            extracted_cluster_config
+                .dimensions
+                .element_product()
+                .div_ceil(ALLOCATION_WORKGROUP_SIZE)
+        };
+        compute_pass.dispatch_workgroups(workgroup_count, 1, 1);
+    }
+
+    /// Schedules the staging part of readback of the data from GPU.
+    fn schedule_readback_staging(
+        command_encoder: &mut CommandEncoder,
+        view_gpu_clustering_buffers: &ViewGpuClusteringBuffers,
+        staging_buffer: &Buffer,
+    ) {
+        match view_gpu_clustering_buffers.cluster_metadata_buffer.buffer() {
+            None => {
+                // This should never happen. It shouldn't have been possible to
+                // create the necessary bind groups without this buffer's being
+                // present.
+                error!("No clustering Z slicing metadata buffer found");
+            }
+            Some(metadata_buffer) => {
+                // Copy the metadata buffer to the staging buffer so we can read
+                // it back.
+                command_encoder.copy_buffer_to_buffer(
+                    metadata_buffer,
+                    0,
+                    staging_buffer,
+                    0,
+                    Some(u64::from(ClusterMetadata::min_size())),
+                );
+            }
+        }
+    }
+
+    /// Schedules the buffer map operation part of the readback of the data from
+    /// GPU.
+    fn schedule_readback_buffer_map(
+        command_encoder: &mut CommandEncoder,
+        view_clustering_readback_data: Arc<Mutex<ViewClusteringReadbackData>>,
+        staging_buffer: &Buffer,
+    ) {
+        let captured_staging_buffer = staging_buffer.clone();
+        command_encoder.map_buffer_on_submit(staging_buffer, MapMode::Read, .., move |result| {
+            if result.is_err() {
+                return;
+            };
+
+            let mut view_clustering_readback_data = view_clustering_readback_data.lock().unwrap();
+
+            {
+                // Use `encase` to populate a `ClusterMetadata`.
+                let buffer_view = captured_staging_buffer.slice(..).get_mapped_range();
+                let Ok(mut buffer_reader) =
+                    Reader::new::<ClusterMetadata>(buffer_view[..].to_vec(), 0)
+                else {
+                    return;
+                };
+                let gpu_clustering_metadata = ClusterMetadata::create_from(&mut buffer_reader);
+
+                // Update readback data.
+                view_clustering_readback_data.update_from_metadata(&gpu_clustering_metadata);
+            }
+
+            // `wgpu` will error if we didn't drop the buffer view at this
+            // point, which is why we use a separate block above.
+            captured_staging_buffer.unmap();
+
+            // Recycle the staging buffer.
+            view_clustering_readback_data
+                .metadata_staging_free_buffers
+                .push(captured_staging_buffer);
+        });
+    }
+}
+
+/// Prepares bind groups for each of the shaders involved in GPU clustering.
+fn prepare_clustering_bind_groups(
+    mut commands: Commands,
+    views_query: Query<
+        (Entity, &ViewGpuClusteringBuffers, &ViewClusterBindings),
+        With<ExtractedView>,
+    >,
+    render_device: Res<RenderDevice>,
+    clustering_z_slicing_pipeline: Res<ClusteringZSlicingPipeline>,
+    clustering_raster_pipeline: Res<ClusteringRasterPipeline>,
+    clustering_allocation_pipeline: Res<ClusteringAllocationPipeline>,
+    global_clusterable_object_meta: Res<GlobalClusterableObjectMeta>,
+    pipeline_cache: Res<PipelineCache>,
+    light_probes_buffer: Res<LightProbesBuffer>,
+    decals_buffer: Res<DecalsBuffer>,
+    light_meta: Res<LightMeta>,
+    view_uniforms: Res<ViewUniforms>,
+) {
+    let (
+        Some(gpu_clustered_lights_binding),
+        Some(light_probes_binding),
+        Some(decals_buffer),
+        Some(lights_binding),
+        Some(view_binding),
+    ) = (
+        global_clusterable_object_meta
+            .gpu_clustered_lights
+            .binding(),
+        light_probes_buffer.binding(),
+        decals_buffer.buffer(),
+        light_meta.view_gpu_lights.binding(),
+        view_uniforms.uniforms.binding(),
+    )
+    else {
+        return;
+    };
+
+    // Create separate bind groups for each view.
+    for (view_entity, view_gpu_clustering_buffers, view_cluster_bindings) in &views_query {
+        let ViewClusterBuffers::Storage {
+            clusterable_object_index_lists: ref maybe_clusterable_object_index_lists,
+            cluster_offsets_and_counts: ref maybe_cluster_offsets_and_counts,
+        } = view_cluster_bindings.buffers
+        else {
+            continue;
+        };
+
+        let (
+            Some(z_slices_buffer),
+            Some(cluster_metadata_buffer),
+            Some(scratchpad_offsets_and_counts_buffer),
+            Some(clusterable_object_index_lists),
+            Some(cluster_offsets_and_counts),
+        ) = (
+            view_gpu_clustering_buffers.z_slices_buffer.buffer(),
+            view_gpu_clustering_buffers.cluster_metadata_buffer.buffer(),
+            view_gpu_clustering_buffers
+                .scratchpad_offsets_and_counts_buffer
+                .buffer(),
+            maybe_clusterable_object_index_lists.buffer(),
+            maybe_cluster_offsets_and_counts.buffer(),
+        )
+        else {
+            continue;
+        };
+
+        let clustering_bind_group_entries_z_slicing_pass = [
+            // @group(0) @binding(0) var<storage, read_write>
+            // cluster_metadata: ClusterMetadata;
+            BindGroupEntry {
+                binding: 0,
+                resource: cluster_metadata_buffer.as_entire_binding(),
+            },
+            // @group(0) @binding(1) var<storage, read_write> z_slices:
+            // array<ClusterableObjectZSlice>;
+            BindGroupEntry {
+                binding: 1,
+                resource: z_slices_buffer.as_entire_binding(),
+            },
+            // @group(0) @binding(2) var<storage> clustered_lights:
+            // ClusteredLights;
+            BindGroupEntry {
+                binding: 2,
+                resource: gpu_clustered_lights_binding.clone(),
+            },
+            // @group(0) @binding(3) var<uniform> light_probes: LightProbes;
+            BindGroupEntry {
+                binding: 3,
+                resource: light_probes_binding.clone(),
+            },
+            // @group(0) @binding(4) var<storage> clustered_decals:
+            // ClusteredDecals;
+            BindGroupEntry {
+                binding: 4,
+                resource: decals_buffer.as_entire_binding(),
+            },
+            // @group(0) @binding(5) var<uniform> lights: Lights;
+            BindGroupEntry {
+                binding: 5,
+                resource: lights_binding.clone(),
+            },
+            // @group(0) @binding(6) var<uniform> view: View;
+            BindGroupEntry {
+                binding: 6,
+                resource: view_binding.clone(),
+            },
+        ];
+
+        let mut clustering_bind_group_entries_count_pass: Vec<BindGroupEntry> = vec![
+            // @group(0) @binding(0) var<storage> z_slices:
+            // array<ClusterableObjectZSlice>;
+            BindGroupEntry {
+                binding: 0,
+                resource: z_slices_buffer.as_entire_binding(),
+            },
+            // @group(0) @binding(1) var<storage, read_write> index_lists:
+            // ClusterableObjectIndexLists;
+            BindGroupEntry {
+                binding: 1,
+                resource: clusterable_object_index_lists.as_entire_binding(),
+            },
+            // @group(0) @binding(2) var<storage> clustered_lights:
+            // ClusteredLights;
+            BindGroupEntry {
+                binding: 2,
+                resource: gpu_clustered_lights_binding.clone(),
+            },
+            // @group(0) @binding(3) var<uniform> light_probes: LightProbes;
+            BindGroupEntry {
+                binding: 3,
+                resource: light_probes_binding.clone(),
+            },
+            // @group(0) @binding(4) var<storage> clustered_decals:
+            // ClusteredDecals;
+            BindGroupEntry {
+                binding: 4,
+                resource: decals_buffer.as_entire_binding(),
+            },
+            // @group(0) @binding(5) var<uniform> lights: Lights;
+            BindGroupEntry {
+                binding: 5,
+                resource: lights_binding.clone(),
+            },
+            // @group(0) @binding(6) var<uniform> view: View;
+            BindGroupEntry {
+                binding: 6,
+                resource: view_binding.clone(),
+            },
+        ];
+
+        let mut clustering_bind_group_entries_populate_pass =
+            clustering_bind_group_entries_count_pass.clone();
+
+        clustering_bind_group_entries_count_pass.push(
+            // @group(0) @binding(7) var<storage, read_write>
+            // offsets_and_counts: ClusterOffsetsAndCounts;
+            BindGroupEntry {
+                binding: 7,
+                resource: cluster_offsets_and_counts.as_entire_binding(),
+            },
+        );
+
+        clustering_bind_group_entries_populate_pass.push(
+            // @group(0) @binding(7) var<storage>
+            // offsets_and_counts: ClusterOffsetsAndCounts;
+            BindGroupEntry {
+                binding: 7,
+                resource: cluster_offsets_and_counts.as_entire_binding(),
+            },
+        );
+        clustering_bind_group_entries_populate_pass.push(
+            // @group(0) @binding(8) var<storage, read_write>
+            // scratchpad_offsets_and_counts: ClusterOffsetsAndCountsAtomic;
+            BindGroupEntry {
+                binding: 8,
+                resource: scratchpad_offsets_and_counts_buffer.as_entire_binding(),
+            },
+        );
+
+        let clustering_bind_group_entries_allocation_pass: [BindGroupEntry; _] = [
+            // @group(0) @binding(0) var<storage, read_write>
+            // offsets_and_counts: ClusterOffsetsAndCounts;
+            BindGroupEntry {
+                binding: 0,
+                resource: cluster_offsets_and_counts.as_entire_binding(),
+            },
+            // @group(0) @binding(1) var<uniform> lights: Lights;
+            BindGroupEntry {
+                binding: 1,
+                resource: lights_binding.clone(),
+            },
+            // @group(0) @binding(2) var<storage, read_write>
+            // clustering_metadata: ClusterMetadata;
+            BindGroupEntry {
+                binding: 2,
+                resource: cluster_metadata_buffer.as_entire_binding(),
+            },
+            // @group(0) @binding(3) var<storage, read_write>
+            // scratchpad_offsets_and_counts: ClusterOffsetsAndCounts;
+            BindGroupEntry {
+                binding: 3,
+                resource: scratchpad_offsets_and_counts_buffer.as_entire_binding(),
+            },
+        ];
+
+        let clustering_bind_group_z_slicing_pass = render_device.create_bind_group(
+            "clustering Z slicing pass bind group",
+            &pipeline_cache.get_bind_group_layout(&clustering_z_slicing_pipeline.bind_group_layout),
+            &clustering_bind_group_entries_z_slicing_pass,
+        );
+        let clustering_bind_group_count_pass = render_device.create_bind_group(
+            "clustering count pass bind group",
+            &pipeline_cache
+                .get_bind_group_layout(&clustering_raster_pipeline.bind_group_layout_count_pass),
+            &clustering_bind_group_entries_count_pass,
+        );
+        let clustering_bind_group_allocate_pass = render_device.create_bind_group(
+            "clustering allocate pass bind group",
+            &pipeline_cache
+                .get_bind_group_layout(&clustering_allocation_pipeline.bind_group_layout),
+            &clustering_bind_group_entries_allocation_pass,
+        );
+        let clustering_bind_group_populate_pass = render_device.create_bind_group(
+            "clustering populate pass bind group",
+            &pipeline_cache
+                .get_bind_group_layout(&clustering_raster_pipeline.bind_group_layout_populate_pass),
+            &clustering_bind_group_entries_populate_pass,
+        );
+
+        commands
+            .entity(view_entity)
+            .insert(ViewClusteringBindGroups {
+                clustering_bind_group_z_slicing_pass,
+                clustering_bind_group_count_pass,
+                clustering_bind_group_allocate_pass,
+                clustering_bind_group_populate_pass,
+            });
+    }
+}
+
+/// Creates the dummy textures that we use to establish a viewport for the
+/// rasterization phases of GPU clustering.
+///
+/// We don't actually write to these textures, but they need to exist so that a
+/// viewport of the appropriate size can be set.
+fn prepare_cluster_dummy_textures(
+    mut commands: Commands,
+    views_query: Query<(Entity, &ExtractedClusterConfig), With<ExtractedView>>,
+    render_device: Res<RenderDevice>,
+    mut texture_cache: ResMut<TextureCache>,
+) {
+    for (view_entity, view_cluster_config) in &views_query {
+        let dummy_texture = texture_cache.get(
+            &render_device,
+            TextureDescriptor {
+                label: Some("clustering dummy texture"),
+                // We round these up to the nearest multiple of 32 to guard
+                // against the risk of thrashing between different sizes,
+                // especially if the auto-resize feature is on.
+                size: Extent3d {
+                    width: round_up(view_cluster_config.dimensions.x),
+                    height: round_up(view_cluster_config.dimensions.y),
+                    depth_or_array_layers: 1,
+                },
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::R8Unorm,
+                usage: TextureUsages::RENDER_ATTACHMENT | TextureUsages::COPY_DST,
+                view_formats: &[],
+            },
+        );
+        commands
+            .entity(view_entity)
+            .insert(ViewClusteringDummyTexture(dummy_texture));
+    }
+
+    /// Rounds the given value up to the nearest multiple of 32.
+    fn round_up(length: u32) -> u32 {
+        (length + 31) & !31
+    }
+}
+
+/// Prepares the compute and raster pipelines for the various shader invocations
+/// in GPU clustering for each view.
+fn prepare_clustering_pipelines(
+    mut commands: Commands,
+    views_query: Query<Entity, With<ExtractedView>>,
+    pipeline_cache: Res<PipelineCache>,
+    mut clustering_z_slicing_pipelines: ResMut<
+        SpecializedComputePipelines<ClusteringZSlicingPipeline>,
+    >,
+    mut clustering_raster_pipelines: ResMut<SpecializedRenderPipelines<ClusteringRasterPipeline>>,
+    mut clustering_allocation_pipelines: ResMut<
+        SpecializedComputePipelines<ClusteringAllocationPipeline>,
+    >,
+    clustering_z_slicing_pipeline: Res<ClusteringZSlicingPipeline>,
+    clustering_raster_pipeline: Res<ClusteringRasterPipeline>,
+    clustering_allocation_pipeline: Res<ClusteringAllocationPipeline>,
+) {
+    for view_entity in &views_query {
+        let clustering_z_slicing_pipeline_id = clustering_z_slicing_pipelines.specialize(
+            &pipeline_cache,
+            &clustering_z_slicing_pipeline,
+            (),
+        );
+        let clustering_count_pipeline_id = clustering_raster_pipelines.specialize(
+            &pipeline_cache,
+            &clustering_raster_pipeline,
+            ClusteringRasterPipelineKey {
+                populate_pass: false,
+            },
+        );
+        let clustering_local_allocation_pipeline_id = clustering_allocation_pipelines.specialize(
+            &pipeline_cache,
+            &clustering_allocation_pipeline,
+            ClusteringAllocationPipelineKey { global_pass: false },
+        );
+        let clustering_global_allocation_pipeline_id = clustering_allocation_pipelines.specialize(
+            &pipeline_cache,
+            &clustering_allocation_pipeline,
+            ClusteringAllocationPipelineKey { global_pass: true },
+        );
+        let clustering_populate_pipeline_id = clustering_raster_pipelines.specialize(
+            &pipeline_cache,
+            &clustering_raster_pipeline,
+            ClusteringRasterPipelineKey {
+                populate_pass: true,
+            },
+        );
+
+        commands
+            .entity(view_entity)
+            .insert(ViewGpuClusteringPipelineIds {
+                clustering_z_slicing_pipeline_id,
+                clustering_count_pipeline_id,
+                clustering_allocation_local_pipeline_id: clustering_local_allocation_pipeline_id,
+                clustering_allocation_global_pipeline_id: clustering_global_allocation_pipeline_id,
+                clustering_populate_pipeline_id,
+            });
+    }
+}
+
+/// Uploads the buffers needed to perform GPU clustering to the GPU.
+fn upload_view_gpu_clustering_buffers(
+    mut views_query: Query<&mut ViewGpuClusteringBuffers>,
+    render_device: Res<RenderDevice>,
+    render_queue: Res<RenderQueue>,
+) {
+    for mut view_gpu_clustering_buffers in &mut views_query {
+        view_gpu_clustering_buffers
+            .z_slices_buffer
+            .write_buffer(&render_device);
+
+        view_gpu_clustering_buffers
+            .cluster_metadata_buffer
+            .write_buffer(&render_device, &render_queue);
+
+        // Make sure the scratchpad buffer is nonempty, and upload it.
+        if view_gpu_clustering_buffers
+            .scratchpad_offsets_and_counts_buffer
+            .is_empty()
+        {
+            view_gpu_clustering_buffers
+                .scratchpad_offsets_and_counts_buffer
+                .add();
+        }
+        view_gpu_clustering_buffers
+            .scratchpad_offsets_and_counts_buffer
+            .write_buffer(&render_device);
+    }
+}
+
+/// Extracts information needed for GPU clustering from each view in the render
+/// world, and synchronizes statistics back from the render world to the main
+/// world if needed.
+pub fn extract_clusters_for_gpu_clustering(
+    mut commands: Commands,
+    mut main_world: ResMut<MainWorld>,
+    render_view_clustering_index_list_sizes: Res<RenderViewClusteringReadbackData>,
+) {
+    let mut views = main_world.query::<(Entity, RenderEntity, &mut Clusters, &Camera)>();
+
+    for (main_view_entity, render_view_entity, mut clusters, camera) in
+        views.iter_mut(&mut main_world)
+    {
+        let mut entity_commands = commands
+            .get_entity(render_view_entity)
+            .expect("Clusters entity wasn't synced.");
+        if !camera.is_active {
+            entity_commands.remove::<ExtractedClusterConfig>();
+            continue;
+        }
+
+        entity_commands.insert(ExtractedClusterConfig::from(&*clusters));
+
+        // Read back statistics from the render world to the main world if we
+        // have some.
+        // The clustering systems in the main world will pick them up and adjust
+        // cluster settings if necessary.
+        if let Some(view_clustering_buffer_size_data) = render_view_clustering_index_list_sizes
+            .views
+            .get(&MainEntity::from(main_view_entity))
+        {
+            let view_clustering_buffer_size_data = view_clustering_buffer_size_data.lock().unwrap();
+            if let Some(last_frame_statistics) =
+                &view_clustering_buffer_size_data.last_frame_statistics
+            {
+                clusters.last_frame_farthest_z = Some(last_frame_statistics.farthest_z);
+                clusters.last_frame_total_cluster_index_count =
+                    Some(last_frame_statistics.index_list_size as usize);
+            }
+        }
+    }
+
+    let global_cluster_settings = main_world.resource::<GlobalClusterSettings>();
+    commands.insert_resource(global_cluster_settings.clone());
+}
+
+/// Creates associated buffers necessary to perform GPU clustering for all
+/// views.
+pub(crate) fn prepare_clusters_for_gpu_clustering(
+    mut commands: Commands,
+    views_query: Query<(
+        Entity,
+        &MainEntity,
+        &ExtractedClusterConfig,
+        Option<&RenderViewLightProbes<EnvironmentMapLight>>,
+        Option<&RenderViewLightProbes<IrradianceVolume>>,
+    )>,
+    render_clustered_decals: Res<RenderClusteredDecals>,
+    render_device: Res<RenderDevice>,
+    render_queue: Res<RenderQueue>,
+    global_clusterable_object_meta: Res<GlobalClusterableObjectMeta>,
+    global_cluster_settings: Res<GlobalClusterSettings>,
+    mut render_view_clustering_index_list_sizes: ResMut<RenderViewClusteringReadbackData>,
+) {
+    let render_device = render_device.into_inner();
+
+    let Some(ref global_cluster_settings_gpu) = global_cluster_settings.gpu_clustering else {
+        error!("`prepare_clusters_for_gpu_clustering() called when not GPU clustering");
+        return;
+    };
+
+    let gpu_clustered_lights_storage = &global_clusterable_object_meta.gpu_clustered_lights;
+
+    let mut all_view_main_entities = MainEntityHashSet::default();
+
+    for (
+        view_entity,
+        view_main_entity,
+        extracted_cluster_config,
+        maybe_environment_maps,
+        maybe_irradiance_volumes,
+    ) in &views_query
+    {
+        // Allocate the cluster array.
+        let mut view_clusters_bindings =
+            ViewClusterBindings::new(BufferBindingType::Storage { read_only: false });
+        view_clusters_bindings.clear();
+        let cluster_count = extracted_cluster_config.dimensions.x as usize
+            * extracted_cluster_config.dimensions.y as usize
+            * extracted_cluster_config.dimensions.z as usize;
+        view_clusters_bindings.reserve_clusters(cluster_count);
+
+        all_view_main_entities.insert(*view_main_entity);
+
+        // Create the readback data.
+        let view_clustering_buffer_size_data = render_view_clustering_index_list_sizes
+            .views
+            .entry(*view_main_entity)
+            .or_insert_with(|| {
+                Arc::new(Mutex::new(ViewClusteringReadbackData::new(
+                    global_cluster_settings_gpu,
+                )))
+            })
+            .lock()
+            .unwrap();
+
+        let mut view_gpu_clustering_buffers = ViewGpuClusteringBuffers::new();
+
+        // Count the number of each type of clusterable object that we have.
+        let clustered_light_count = gpu_clustered_lights_storage.data.len() as u32;
+        let reflection_probe_count = match maybe_environment_maps {
+            Some(view_reflection_probes) => view_reflection_probes.len() as u32,
+            None => 0,
+        };
+        let irradiance_volume_count = match maybe_irradiance_volumes {
+            Some(view_irradiance_volumes) => view_irradiance_volumes.len() as u32,
+            None => 0,
+        };
+        let decal_count = render_clustered_decals.len() as u32;
+
+        // Initialize the metadata.
+        *view_gpu_clustering_buffers
+            .cluster_metadata_buffer
+            .get_mut() = ClusterMetadata {
+            indirect_draw_params: ClusterRasterIndirectDrawParams {
+                index_count: 6,
+                // This will be filled in by the GPU.
+                instance_count: 0,
+                first_index: 0,
+                base_vertex: 0,
+                first_instance: 0,
+            },
+            clustered_light_count,
+            reflection_probe_count,
+            irradiance_volume_count,
+            decal_count,
+            index_list_capacity: view_clustering_buffer_size_data.max_index_list_capacity as u32,
+            z_slice_list_capacity: view_clustering_buffer_size_data.z_slice_list_capacity as u32,
+            farthest_z: 0.0,
+        };
+
+        // Allocate Z slices.
+        if view_gpu_clustering_buffers.z_slices_buffer.len()
+            < view_clustering_buffer_size_data.z_slice_list_capacity
+        {
+            view_gpu_clustering_buffers.z_slices_buffer.add_multiple(
+                view_clustering_buffer_size_data.z_slice_list_capacity
+                    - view_gpu_clustering_buffers.z_slices_buffer.len(),
+            );
+        }
+
+        // Make room for the appropriate number of indices.
+        view_clusters_bindings
+            .reserve_indices(view_clustering_buffer_size_data.max_index_list_capacity);
+        view_clusters_bindings.write_buffers(render_device, &render_queue);
+
+        // Allocate scratchpad offsets and counts.
+        view_gpu_clustering_buffers
+            .scratchpad_offsets_and_counts_buffer
+            .add_multiple(cluster_count);
+
+        commands
+            .entity(view_entity)
+            .insert((view_clusters_bindings, view_gpu_clustering_buffers));
+    }
+
+    // Clear out clustering allocations corresponding to views that don't exist
+    // any longer.
+    render_view_clustering_index_list_sizes
+        .views
+        .retain(|view_main_entity, _| all_view_main_entities.contains(view_main_entity));
+}
+
+impl ExtractResource<GpuClusteringPlugin> for GlobalClusterSettings {
+    type Source = GlobalClusterSettings;
+
+    fn extract_resource(source: &Self::Source) -> Self {
+        source.clone()
+    }
+}
diff --git a/crates/bevy_pbr/src/cluster.rs b/crates/bevy_pbr/src/cluster/mod.rs
similarity index 79%
rename from crates/bevy_pbr/src/cluster.rs
rename to crates/bevy_pbr/src/cluster/mod.rs
index 9b42282b322f1..ced014b1f1b38 100644
--- a/crates/bevy_pbr/src/cluster.rs
+++ b/crates/bevy_pbr/src/cluster/mod.rs
@@ -1,26 +1,31 @@
-use core::num::NonZero;
+use core::{iter, num::NonZero};
 
 use bevy_camera::Camera;
 use bevy_ecs::{entity::EntityHashMap, prelude::*};
 use bevy_light::{
-    cluster::{ClusterableObjectCounts, Clusters, GlobalClusterSettings},
+    cluster::{
+        ClusterableObjectCounts, ClusterableObjects, Clusters, GlobalClusterGpuSettings,
+        GlobalClusterSettings,
+    },
     ClusteredDecal, EnvironmentMapLight, IrradianceVolume, PointLight, SpotLight,
 };
 use bevy_math::{uvec4, UVec3, UVec4, Vec4};
 use bevy_render::{
     render_resource::{
-        BindingResource, BufferBindingType, BufferUsages, RawBufferVec, ShaderSize, ShaderType,
-        StorageBuffer, UniformBuffer,
+        BindingResource, BufferBindingType, BufferUsages, DownlevelFlags, RawBufferVec, ShaderSize,
+        ShaderType, StorageBuffer, UniformBuffer, UninitBufferVec,
     },
     renderer::{RenderAdapter, RenderDevice, RenderQueue},
     sync_world::{MainEntity, RenderEntity},
     Extract,
 };
 use bytemuck::{Pod, Zeroable};
-use tracing::{error, trace, warn};
+use tracing::{error, info, trace, warn};
 
 use crate::{MeshPipeline, RenderViewLightProbes};
 
+pub(crate) mod gpu;
+
 // NOTE: this must be kept in sync with the same constants in
 // `mesh_view_types.wgsl`.
 pub const MAX_UNIFORM_BUFFER_CLUSTERABLE_OBJECTS: usize = 204;
@@ -40,6 +45,19 @@ const CLUSTER_COUNT_SIZE: u32 = 9;
 const CLUSTER_OFFSET_MASK: u32 = (1 << (32 - (CLUSTER_COUNT_SIZE * 2))) - 1;
 const CLUSTER_COUNT_MASK: u32 = (1 << CLUSTER_COUNT_SIZE) - 1;
 
+/// The initial capacity of the Z slice list.
+///
+/// The application can override this by setting
+/// [`GlobalClusterGpuSettings::initial_z_slice_list_capacity`].
+pub const GPU_CLUSTERING_INITIAL_Z_SLICE_LIST_CAPACITY: usize = 1024;
+
+/// The initial capacity of the clustered object index list.
+///
+/// The application can override this by setting
+/// [`GlobalClusterGpuSettings::initial_index_list_capacity`].
+pub const GPU_CLUSTERING_INITIAL_INDEX_LIST_CAPACITY: usize = 65536;
+
+/// Creates the default [`GlobalClusterSettings`] resource.
 pub(crate) fn make_global_cluster_settings(world: &World) -> GlobalClusterSettings {
     let device = world.resource::<RenderDevice>();
     let adapter = world.resource::<RenderAdapter>();
@@ -49,9 +67,31 @@ pub(crate) fn make_global_cluster_settings(world: &World) -> GlobalClusterSettin
         device.get_supported_read_only_binding_type(CLUSTERED_FORWARD_STORAGE_BUFFER_COUNT),
         BufferBindingType::Storage { .. }
     );
+
+    // We need to support compute shaders to use GPU clustering. To deal with
+    // the `WGPU_SETTINGS_PRIO="webgl2"` environment setting, we check the
+    // `RenderDevice` limits in addition to the `RenderAdapter`.
+    let gpu_clustering_supported = adapter
+        .get_downlevel_capabilities()
+        .flags
+        .contains(DownlevelFlags::COMPUTE_SHADERS)
+        && device.limits().max_storage_buffers_per_shader_stage > 0;
+
+    let gpu_clustering = if gpu_clustering_supported {
+        info!("GPU clustering is supported on this device.");
+        Some(GlobalClusterGpuSettings {
+            initial_z_slice_list_capacity: GPU_CLUSTERING_INITIAL_Z_SLICE_LIST_CAPACITY,
+            initial_index_list_capacity: GPU_CLUSTERING_INITIAL_INDEX_LIST_CAPACITY,
+        })
+    } else {
+        info!("GPU clustering isn't supported on this device; falling back to CPU clustering.");
+        None
+    };
+
     GlobalClusterSettings {
         supports_storage_buffers,
         clustered_decals_are_usable,
+        gpu_clustering,
         max_uniform_buffer_clusterable_objects: MAX_UNIFORM_BUFFER_CLUSTERABLE_OBJECTS,
         view_cluster_bindings_max_indices: ViewClusterBindings::MAX_INDICES,
     }
@@ -80,7 +120,8 @@ pub struct GpuClusteredLight {
     /// Note that this is separate from clustered decals. Clustered decals have
     /// their own structures and don't use [`GpuClusteredLight`].
     pub(crate) decal_index: u32,
-    pub(crate) pad: f32,
+    /// The radius of the range that the light affects, used for clustering.
+    pub(crate) range: f32,
 }
 
 /// Contains information about clusterable objects in the scene that's global:
@@ -122,7 +163,18 @@ pub struct ExtractedClusterConfig {
     pub(crate) dimensions: UVec3,
 }
 
-/// A single command in the stream that [`extract_clusters`] produces.
+impl<'a> From<&'a Clusters> for ExtractedClusterConfig {
+    fn from(clusters: &'a Clusters) -> Self {
+        Self {
+            near: clusters.near,
+            far: clusters.far,
+            dimensions: clusters.dimensions,
+        }
+    }
+}
+
+/// A single command in the stream that [`extract_clusters_for_cpu_clustering`]
+/// produces.
 enum ExtractedClusterableObjectElement {
     /// Marks the beginning of a new cluster.
     ClusterHeader(ClusterableObjectCounts),
@@ -168,9 +220,12 @@ struct GpuClusterOffsetsAndCountsStorage {
     /// lights, reflection probes, and irradiance volumes in each cluster, in
     /// that order. The remaining fields are filled with zeroes.
     #[shader(size(runtime))]
-    data: Vec<[UVec4; 2]>,
+    data: Vec<GpuClusterOffsetAndCounts>,
 }
 
+/// The type we use for the offset and counts for each cluster.
+type GpuClusterOffsetAndCounts = [UVec4; 2];
+
 enum ViewClusterBuffers {
     Uniform {
         // NOTE: UVec4 is because all arrays in Std140 layout have 16-byte alignment
@@ -179,7 +234,7 @@ enum ViewClusterBuffers {
         cluster_offsets_and_counts: UniformBuffer<GpuClusterOffsetsAndCountsUniform>,
     },
     Storage {
-        clusterable_object_index_lists: StorageBuffer<GpuClusterableObjectIndexListsStorage>,
+        clusterable_object_index_lists: UninitBufferVec<u32>,
         cluster_offsets_and_counts: StorageBuffer<GpuClusterOffsetsAndCountsStorage>,
     },
 }
@@ -287,29 +342,50 @@ impl GpuClusteredLights {
     }
 }
 
-/// Extracts clusters from the main world from the render world.
-pub fn extract_clusters(
+/// A shortcut for testing the type of a clusterable object.
+type ClusterExtractionMapperQueryFlags = (
+    Has<PointLight>,
+    Has<SpotLight>,
+    Has<EnvironmentMapLight>,
+    Has<IrradianceVolume>,
+    Has<ClusteredDecal>,
+);
+/// A shortcut for testing whether an entity is any type of clusterable object.
+type ClusterExtractionMapperQueryFilter = Or<(
+    With<PointLight>,
+    With<SpotLight>,
+    With<EnvironmentMapLight>,
+    With<IrradianceVolume>,
+    With<ClusteredDecal>,
+)>;
+
+/// A run condition that tests whether GPU clustering is enabled.
+///
+/// This is the version for use in extraction systems.
+pub fn gpu_clustering_is_enabled_during_extraction(
+    global_cluster_settings: Extract<Res<GlobalClusterSettings>>,
+) -> bool {
+    global_cluster_settings.gpu_clustering.is_some()
+}
+
+/// A run condition that tests whether GPU clustering is enabled.
+///
+/// This is the version for use in non-extraction systems.
+pub fn gpu_clustering_is_enabled(global_cluster_settings: Res<GlobalClusterSettings>) -> bool {
+    global_cluster_settings.gpu_clustering.is_some()
+}
+
+/// Extracts the clusters that the CPU produced into the render world.
+pub fn extract_clusters_for_cpu_clustering(
     mut commands: Commands,
     views: Extract<Query<(RenderEntity, &Clusters, &Camera)>>,
     mapper: Extract<
         Query<
-            (
-                Option<&RenderEntity>,
-                Has<PointLight>,
-                Has<SpotLight>,
-                Has<EnvironmentMapLight>,
-                Has<IrradianceVolume>,
-                Has<ClusteredDecal>,
-            ),
-            Or<(
-                With<PointLight>,
-                With<SpotLight>,
-                With<EnvironmentMapLight>,
-                With<IrradianceVolume>,
-                With<ClusteredDecal>,
-            )>,
+            (Option<&RenderEntity>, ClusterExtractionMapperQueryFlags),
+            ClusterExtractionMapperQueryFilter,
         >,
     >,
+    global_cluster_settings: Extract<Res<GlobalClusterSettings>>,
 ) {
     for (entity, clusters, camera) in &views {
         let mut entity_commands = commands
@@ -320,19 +396,29 @@ pub fn extract_clusters(
             continue;
         }
 
+        let clusterable_objects = match clusters.clusterable_objects {
+            ClusterableObjects::Cpu(ref cpu_clusterable_objects) => cpu_clusterable_objects,
+            ClusterableObjects::Gpu => {
+                error!("Clusterable objects must have been in CPU mode if doing CPU clustering");
+                continue;
+            }
+        };
+
         let mut data = vec![];
-        for cluster_objects in &clusters.clusterable_objects {
+        for cluster_objects in clusterable_objects {
             data.push(ExtractedClusterableObjectElement::ClusterHeader(
                 cluster_objects.counts,
             ));
             for clusterable_entity in cluster_objects.iter() {
                 let Ok((
                     maybe_render_entity,
-                    is_point_light,
-                    is_spot_light,
-                    is_reflection_probe,
-                    is_irradiance_volume,
-                    is_clustered_decal,
+                    (
+                        is_point_light,
+                        is_spot_light,
+                        is_reflection_probe,
+                        is_irradiance_volume,
+                        is_clustered_decal,
+                    ),
                 )) = mapper.get(*clusterable_entity)
                 else {
                     error!(
@@ -364,16 +450,16 @@ pub fn extract_clusters(
 
         entity_commands.insert((
             ExtractedClusterableObjects { data },
-            ExtractedClusterConfig {
-                near: clusters.near,
-                far: clusters.far,
-                dimensions: clusters.dimensions,
-            },
+            ExtractedClusterConfig::from(clusters),
         ));
     }
+
+    commands.insert_resource(global_cluster_settings.clone());
 }
 
-pub fn prepare_clusters(
+/// Creates and populates the GPU buffers that store clusters when CPU
+/// clustering is being used.
+pub fn prepare_clusters_for_cpu_clustering(
     mut commands: Commands,
     render_device: Res<RenderDevice>,
     render_queue: Res<RenderQueue>,
@@ -505,7 +591,7 @@ impl ViewClusterBindings {
                 cluster_offsets_and_counts,
                 ..
             } => {
-                clusterable_object_index_lists.get_mut().data.clear();
+                clusterable_object_index_lists.clear();
                 cluster_offsets_and_counts.get_mut().data.clear();
             }
         }
@@ -566,11 +652,11 @@ impl ViewClusterBindings {
                 clusterable_object_index_lists.get_mut().data[array_index][component] |=
                     index << (8 * sub_index);
             }
-            ViewClusterBuffers::Storage {
-                clusterable_object_index_lists,
-                ..
-            } => {
-                clusterable_object_index_lists.get_mut().data.push(index);
+            ViewClusterBuffers::Storage { .. } => {
+                error!(
+                    "Shouldn't be pushing a clusterable object index from CPU when GPU clustering \
+                     is in use"
+                );
             }
         }
 
@@ -590,6 +676,45 @@ impl ViewClusterBindings {
         self.push_raw_index(!0);
     }
 
+    /// Reserves space in the cluster offsets-and-counts list for `clusters`
+    /// clusters.
+    pub fn reserve_clusters(&mut self, clusters: usize) {
+        match &mut self.buffers {
+            ViewClusterBuffers::Uniform { .. } => {
+                error!("`reserve_clusters` should only be called in GPU clustering, which requires a storage buffer");
+            }
+            ViewClusterBuffers::Storage {
+                cluster_offsets_and_counts,
+                ..
+            } => {
+                cluster_offsets_and_counts
+                    .get_mut()
+                    .data
+                    .extend(iter::repeat_n(
+                        GpuClusterOffsetAndCounts::default(),
+                        clusters,
+                    ));
+                self.n_offsets += clusters;
+            }
+        }
+    }
+
+    /// Reserves space in the index lists for `elements` indices.
+    pub fn reserve_indices(&mut self, elements: usize) {
+        match &mut self.buffers {
+            ViewClusterBuffers::Uniform { .. } => {
+                error!("`reserve_indices` should only be called in GPU clustering, which requires a storage buffer");
+            }
+            ViewClusterBuffers::Storage {
+                clusterable_object_index_lists,
+                ..
+            } => {
+                clusterable_object_index_lists.add_multiple(elements);
+                self.n_indices += elements;
+            }
+        }
+    }
+
     pub fn write_buffers(&mut self, render_device: &RenderDevice, render_queue: &RenderQueue) {
         match &mut self.buffers {
             ViewClusterBuffers::Uniform {
@@ -603,7 +728,7 @@ impl ViewClusterBindings {
                 clusterable_object_index_lists,
                 cluster_offsets_and_counts,
             } => {
-                clusterable_object_index_lists.write_buffer(render_device, render_queue);
+                clusterable_object_index_lists.write_buffer(render_device);
                 cluster_offsets_and_counts.write_buffer(render_device, render_queue);
             }
         }
@@ -671,7 +796,9 @@ impl ViewClusterBuffers {
 
     fn storage() -> Self {
         ViewClusterBuffers::Storage {
-            clusterable_object_index_lists: StorageBuffer::default(),
+            clusterable_object_index_lists: UninitBufferVec::new(
+                BufferUsages::STORAGE | BufferUsages::COPY_DST,
+            ),
             cluster_offsets_and_counts: StorageBuffer::default(),
         }
     }
diff --git a/crates/bevy_pbr/src/decal/clustered.rs b/crates/bevy_pbr/src/decal/clustered.rs
index 21c8daec4a407..712051157df10 100644
--- a/crates/bevy_pbr/src/decal/clustered.rs
+++ b/crates/bevy_pbr/src/decal/clustered.rs
@@ -33,7 +33,7 @@ use bevy_ecs::{
 };
 use bevy_image::Image;
 use bevy_light::{ClusteredDecal, DirectionalLightTexture, PointLightTexture, SpotLightTexture};
-use bevy_math::Mat4;
+use bevy_math::{Mat4, Vec3};
 use bevy_platform::collections::HashMap;
 use bevy_render::{
     render_asset::RenderAssets,
@@ -96,6 +96,8 @@ impl RenderClusteredDecals {
         entity: Entity,
         images: [Option<AssetId<Image>>; IMAGES_PER_DECAL],
         local_from_world: Mat4,
+        world_position: Vec3,
+        bounding_sphere_radius: f32,
         tag: u32,
     ) {
         let image_indices = images.map(|maybe_image_id| match maybe_image_id {
@@ -106,6 +108,8 @@ impl RenderClusteredDecals {
         self.decals.push(RenderClusteredDecal {
             local_from_world,
             image_indices,
+            world_position,
+            bounding_sphere_radius,
             tag,
             pad_a: 0,
             pad_b: 0,
@@ -117,6 +121,16 @@ impl RenderClusteredDecals {
     pub fn get(&self, entity: Entity) -> Option<usize> {
         self.entity_to_decal_index.get(&entity).copied()
     }
+
+    /// Returns the number of clustered decals in the scene.
+    pub fn len(&self) -> usize {
+        self.decals.len()
+    }
+
+    /// Returns true if there are no clustered decals in the scene.
+    pub fn is_empty(&self) -> bool {
+        self.decals.is_empty()
+    }
 }
 
 /// The per-view bind group entries pertaining to decals.
@@ -207,6 +221,8 @@ pub struct RenderClusteredDecal {
     /// If the decal doesn't have a texture assigned to a slot, the index at
     /// that slot will be -1.
     image_indices: [i32; 4],
+    world_position: Vec3,
+    bounding_sphere_radius: f32,
     /// A custom tag available for application-defined purposes.
     tag: u32,
     /// Padding.
@@ -253,7 +269,7 @@ pub fn extract_decals(
     >,
     mut render_decals: ResMut<RenderClusteredDecals>,
 ) {
-    // Clear out the `RenderDecals` in preparation for a new frame.
+    // Clear out the `RenderClusteredDecals` in preparation for a new frame.
     render_decals.clear();
 
     extract_clustered_decals(&decals, &mut render_decals);
@@ -296,6 +312,8 @@ fn extract_clustered_decals(
                 clustered_decal.emissive_texture.as_ref().map(Handle::id),
             ],
             global_transform.affine().inverse().into(),
+            global_transform.translation(),
+            (global_transform.scale() * Vec3::ONE).length(),
             clustered_decal.tag,
         );
     }
@@ -324,6 +342,8 @@ fn extract_spot_light_textures(
             decal_entity,
             [Some(texture.image.id()), None, None, None],
             global_transform.affine().inverse().into(),
+            global_transform.translation(),
+            (global_transform.scale() * Vec3::ONE).length(),
             0,
         );
     }
@@ -352,6 +372,8 @@ fn extract_point_light_textures(
             decal_entity,
             [Some(texture.image.id()), None, None, None],
             global_transform.affine().inverse().into(),
+            global_transform.translation(),
+            (global_transform.scale() * Vec3::ONE).length(),
             texture.cubemap_layout as u32,
         );
     }
@@ -380,6 +402,8 @@ fn extract_directional_light_textures(
             decal_entity,
             [Some(texture.image.id()), None, None, None],
             global_transform.affine().inverse().into(),
+            global_transform.translation(),
+            (global_transform.scale() * Vec3::ONE).length(),
             if texture.tiled { 1 } else { 0 },
         );
     }
diff --git a/crates/bevy_pbr/src/decal/clustered.wgsl b/crates/bevy_pbr/src/decal/clustered.wgsl
index a6404ecde0c67..a2102a80dc384 100644
--- a/crates/bevy_pbr/src/decal/clustered.wgsl
+++ b/crates/bevy_pbr/src/decal/clustered.wgsl
@@ -10,7 +10,7 @@
 //      let is_orthographic = view_is_orthographic();
 //
 //      let cluster_index =
-//          clustered_forward::fragment_cluster_index(frag_coord, view_z, is_orthographic);
+//          clustered_forward::view_fragment_cluster_index(frag_coord, view_z, is_orthographic);
 //      var clusterable_object_index_ranges =
 //          clustered_forward::unpack_clusterable_object_index_ranges(cluster_index);
 //
@@ -80,7 +80,7 @@ struct ClusteredDecalIterator {
 //      let is_orthographic = view_is_orthographic();
 //
 //      let cluster_index =
-//          clustered_forward::fragment_cluster_index(frag_coord, view_z, is_orthographic);
+//          clustered_forward::view_fragment_cluster_index(frag_coord, view_z, is_orthographic);
 //      var clusterable_object_index_ranges =
 //          clustered_forward::unpack_clusterable_object_index_ranges(cluster_index);
 fn clustered_decal_iterator_new(
@@ -185,7 +185,7 @@ fn apply_decals(pbr_input: ptr<function, PbrInput>) {
     let is_orthographic = view_is_orthographic();
 
     let cluster_index =
-        clustered_forward::fragment_cluster_index(frag_coord, view_z, is_orthographic);
+        clustered_forward::view_fragment_cluster_index(frag_coord, view_z, is_orthographic);
     var clusterable_object_index_ranges =
         clustered_forward::unpack_clusterable_object_index_ranges(cluster_index);
 
diff --git a/crates/bevy_pbr/src/lib.rs b/crates/bevy_pbr/src/lib.rs
index c86188eacd9b7..8a6ac08df3b6a 100644
--- a/crates/bevy_pbr/src/lib.rs
+++ b/crates/bevy_pbr/src/lib.rs
@@ -96,7 +96,8 @@ pub mod prelude {
     };
 }
 
-use crate::deferred::DeferredPbrLightingPlugin;
+use crate::gpu::GpuClusteringPlugin;
+use crate::{deferred::DeferredPbrLightingPlugin, gpu::extract_clusters_for_gpu_clustering};
 use bevy_app::prelude::*;
 use bevy_asset::{AssetApp, AssetPath, Assets, Handle, RenderAssetUsages};
 use bevy_core_pipeline::mip_generation::experimental::depth::early_downsample_depth;
@@ -223,7 +224,11 @@ impl Plugin for PbrPlugin {
                 SyncComponentPlugin::<SpotLight, Self>::default(),
                 SyncComponentPlugin::<AmbientLight, Self>::default(),
             ))
-            .add_plugins((ScatteringMediumPlugin, AtmospherePlugin));
+            .add_plugins((
+                ScatteringMediumPlugin,
+                AtmospherePlugin,
+                GpuClusteringPlugin,
+            ));
 
         #[cfg(feature = "bevy_gltf")]
         if self.gltf_enable_standard_materials {
@@ -293,7 +298,15 @@ impl Plugin for PbrPlugin {
             .add_systems(
                 ExtractSchedule,
                 (
-                    extract_clusters,
+                    extract_clusters_for_cpu_clustering
+                        .run_if(not(gpu_clustering_is_enabled_during_extraction)),
+                    extract_clusters_for_gpu_clustering
+                        .run_if(gpu_clustering_is_enabled_during_extraction),
+                ),
+            )
+            .add_systems(
+                ExtractSchedule,
+                (
                     extract_lights,
                     extract_ambient_light_resource,
                     extract_ambient_light,
@@ -307,7 +320,7 @@ impl Plugin for PbrPlugin {
                     prepare_lights
                         .in_set(RenderSystems::CreateViews)
                         .after(sort_cameras),
-                    prepare_clusters.in_set(RenderSystems::PrepareResources),
+                    prepare_clusters_for_cpu_clustering.in_set(RenderSystems::PrepareResources),
                 ),
             )
             .init_resource::<LightMeta>()
diff --git a/crates/bevy_pbr/src/light_probe/mod.rs b/crates/bevy_pbr/src/light_probe/mod.rs
index 424ac386f1812..2853b1eefcf12 100644
--- a/crates/bevy_pbr/src/light_probe/mod.rs
+++ b/crates/bevy_pbr/src/light_probe/mod.rs
@@ -2,7 +2,7 @@
 
 use bevy_app::{App, Plugin};
 use bevy_asset::AssetId;
-use bevy_camera::Camera3d;
+use bevy_camera::{visibility::VisibleEntities, Camera3d};
 use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::{
     component::Component,
@@ -14,7 +14,7 @@ use bevy_ecs::{
 };
 use bevy_image::Image;
 use bevy_light::{
-    cluster::VisibleClusterableObjects, EnvironmentMapLight, IrradianceVolume, LightProbe,
+    cluster::ClusterVisibilityClass, EnvironmentMapLight, IrradianceVolume, LightProbe,
 };
 use bevy_math::{Affine3A, FloatOrd, Mat4, Vec3, Vec4};
 use bevy_platform::collections::HashMap;
@@ -37,8 +37,8 @@ use tracing::error;
 use core::{any::TypeId, hash::Hash, ops::Deref};
 
 use crate::{
-    extract_clusters, generate::EnvironmentMapGenerationPlugin,
-    light_probe::environment_map::EnvironmentMapIds,
+    extract_clusters_for_cpu_clustering, generate::EnvironmentMapGenerationPlugin,
+    gpu::extract_clusters_for_gpu_clustering, light_probe::environment_map::EnvironmentMapIds,
 };
 
 pub mod environment_map;
@@ -75,6 +75,13 @@ struct RenderLightProbe {
     /// See the comments in [`LightProbe`] for more details.
     falloff: Vec3,
 
+    /// The radius of the bounding sphere that encompasses this light probe.
+    ///
+    /// This could be computed from [`Self::light_from_world_transposed`], but
+    /// that requires inverting a matrix, which we don't want to do in the GPU
+    /// light clustering kernel.
+    bounding_sphere_radius: f32,
+
     /// The boundaries of the simulated space used for parallax correction,
     /// specified as *half* extents in light probe space.
     ///
@@ -85,6 +92,18 @@ struct RenderLightProbe {
     /// details.
     parallax_correction_bounds: Vec3,
 
+    /// Scale factor applied to the light generated by this light probe.
+    ///
+    /// See the comment in [`EnvironmentMapLight`] for details.
+    intensity: f32,
+
+    /// The world-space position of this light probe.
+    ///
+    /// This could be computed from [`Self::light_from_world_transposed`], but
+    /// that requires inverting a matrix, which we don't want to do in the GPU
+    /// light clustering kernel.
+    world_position: Vec3,
+
     /// The index of the texture or textures in the appropriate binding array or
     /// arrays.
     ///
@@ -92,11 +111,6 @@ struct RenderLightProbe {
     /// the diffuse and specular texture arrays.
     texture_index: i32,
 
-    /// Scale factor applied to the light generated by this light probe.
-    ///
-    /// See the comment in [`EnvironmentMapLight`] for details.
-    intensity: f32,
-
     /// Various flags associated with the light probe: the bit value of
     /// [`RenderLightProbeFlags`].
     flags: u32,
@@ -171,6 +185,13 @@ where
     // The transform from light probe space to world space.
     world_from_light: Affine3A,
 
+    /// The radius of the bounding sphere that encompasses this light probe.
+    ///
+    /// This could be computed from [`Self::light_from_world`], but that
+    /// requires inverting a matrix, which we don't want to do in the GPU light
+    /// clustering kernel.
+    bounding_sphere_radius: f32,
+
     // The falloff region, specified as a fraction of the light probe's
     // bounding box.
     //
@@ -392,11 +413,15 @@ impl Plugin for LightProbePlugin {
             .add_systems(ExtractSchedule, gather_environment_map_uniform)
             .add_systems(
                 ExtractSchedule,
-                gather_light_probes::<EnvironmentMapLight>.before(extract_clusters),
+                gather_light_probes::<EnvironmentMapLight>
+                    .before(extract_clusters_for_cpu_clustering)
+                    .before(extract_clusters_for_gpu_clustering),
             )
             .add_systems(
                 ExtractSchedule,
-                gather_light_probes::<IrradianceVolume>.before(extract_clusters),
+                gather_light_probes::<IrradianceVolume>
+                    .before(extract_clusters_for_cpu_clustering)
+                    .before(extract_clusters_for_gpu_clustering),
             )
             .add_systems(
                 Render,
@@ -437,15 +462,7 @@ fn gather_light_probes<C>(
     image_assets: Res<RenderAssets<GpuImage>>,
     light_probe_query: Extract<Query<(Entity, &GlobalTransform, &LightProbe, &C, C::QueryData)>>,
     view_query: Extract<
-        Query<
-            (
-                RenderEntity,
-                &GlobalTransform,
-                &VisibleClusterableObjects,
-                Option<&C>,
-            ),
-            With<Camera3d>,
-        >,
+        Query<(RenderEntity, &GlobalTransform, &VisibleEntities, Option<&C>), With<Camera3d>>,
     >,
     mut view_light_probe_info: Local<Vec<LightProbeInfo<C>>>,
     mut commands: Commands,
@@ -453,34 +470,21 @@ fn gather_light_probes<C>(
     C: LightProbeComponent,
 {
     // Build up the light probes uniform and the key table.
-    for (view_entity, view_transform, visible_clusterable_objects, view_component) in
-        view_query.iter()
-    {
+    for (view_entity, view_transform, visible_entities, view_component) in view_query.iter() {
         view_light_probe_info.clear();
-        view_light_probe_info.reserve(visible_clusterable_objects.light_probes.len());
-        if let Some(visible_light_probes) = visible_clusterable_objects
-            .light_probes
-            .get(&TypeId::of::<C>())
-        {
-            for &main_entity in visible_light_probes {
-                let Ok(query_row) = light_probe_query.get(main_entity) else {
-                    // This should never happen. `assign_objects_to_clusters`
-                    // should use a light probe query that matches exactly the
-                    // same set of entities as our `light_probe_query`.
-                    error!(
-                        "Clustering shouldn't have clustered light probe {:?}",
-                        main_entity
-                    );
-                    continue;
-                };
-                // If we don't successfully create `LightProbeInfo`, that means
-                // the light probe hasn't loaded yet. We don't add such light
-                // probes to `view_light_probe_info` so that they don't waste
-                // space in the GPU light probe buffer, which has a limited
-                // size.
-                if let Some(light_probe_info) = LightProbeInfo::new(query_row, &image_assets) {
-                    view_light_probe_info.push(light_probe_info);
-                }
+        let visible_light_probes = visible_entities.get(TypeId::of::<ClusterVisibilityClass>());
+        for &main_entity in visible_light_probes {
+            let Ok(query_row) = light_probe_query.get(main_entity) else {
+                // This might not be a light probe. If so, ignore it.
+                continue;
+            };
+            // If we don't successfully create `LightProbeInfo`, that means
+            // the light probe hasn't loaded yet. We don't add such light
+            // probes to `view_light_probe_info` so that they don't waste
+            // space in the GPU light probe buffer, which has a limited
+            // size.
+            if let Some(light_probe_info) = LightProbeInfo::new(query_row, &image_assets) {
+                view_light_probe_info.push(light_probe_info);
             }
         }
 
@@ -671,6 +675,7 @@ where
         let world_from_light =
             environment_map.get_world_from_light_matrix(&light_probe_transform.affine());
         let light_from_world_transposed = Mat4::from(world_from_light.inverse()).transpose();
+        let bounding_sphere_radius = (world_from_light.matrix3 * Vec3::ONE).length();
         environment_map.id(image_assets).map(|id| LightProbeInfo {
             main_entity: main_entity.into(),
             world_from_light,
@@ -679,6 +684,7 @@ where
                 light_from_world_transposed.y_axis,
                 light_from_world_transposed.z_axis,
             ],
+            bounding_sphere_radius,
             falloff: light_probe.falloff,
             parallax_correction_bounds: environment_map
                 .parallax_correction_bounds(&query_components),
@@ -766,6 +772,8 @@ where
                 light_from_world_transposed: light_probe.light_from_world,
                 falloff: light_probe.falloff,
                 parallax_correction_bounds: light_probe.parallax_correction_bounds,
+                world_position: light_probe.world_from_light.translation.into(),
+                bounding_sphere_radius: light_probe.bounding_sphere_radius,
                 texture_index: cubemap_index as i32,
                 intensity: light_probe.intensity,
                 flags: light_probe.flags.bits() as u32,
@@ -785,6 +793,7 @@ where
             world_from_light: self.world_from_light,
             falloff: self.falloff,
             parallax_correction_bounds: self.parallax_correction_bounds,
+            bounding_sphere_radius: self.bounding_sphere_radius,
             intensity: self.intensity,
             flags: self.flags,
             asset_id: self.asset_id.clone(),
diff --git a/crates/bevy_pbr/src/render/clustered_forward.wgsl b/crates/bevy_pbr/src/render/clustered_forward.wgsl
index 30af387c2d059..4bdf29494f85a 100644
--- a/crates/bevy_pbr/src/render/clustered_forward.wgsl
+++ b/crates/bevy_pbr/src/render/clustered_forward.wgsl
@@ -34,28 +34,43 @@ struct ClusterableObjectIndexRanges {
 }
 
 // NOTE: Keep in sync with bevy_pbr/src/light.rs
-fn view_z_to_z_slice(view_z: f32, is_orthographic: bool) -> u32 {
+fn view_z_to_z_slice(
+    cluster_factors: vec2<f32>,
+    z_slices: u32,
+    view_z: f32,
+    is_orthographic: bool
+) -> u32 {
     var z_slice: u32 = 0u;
     if is_orthographic {
         // NOTE: view_z is correct in the orthographic case
-        z_slice = u32(floor((view_z - bindings::lights.cluster_factors.z) * bindings::lights.cluster_factors.w));
+        z_slice = u32(floor((view_z - cluster_factors.x) * cluster_factors.y));
     } else {
         // NOTE: had to use -view_z to make it positive else log(negative) is nan
-        z_slice = u32(log(-view_z) * bindings::lights.cluster_factors.z - bindings::lights.cluster_factors.w + 1.0);
+        z_slice = u32(log(-view_z) * cluster_factors.x - cluster_factors.y + 1.0);
     }
     // NOTE: We use min as we may limit the far z plane used for clustering to be closer than
     // the furthest thing being drawn. This means that we need to limit to the maximum cluster.
-    return min(z_slice, bindings::lights.cluster_dimensions.z - 1u);
+    return min(z_slice, z_slices - 1u);
 }
 
-fn fragment_cluster_index(frag_coord: vec2<f32>, view_z: f32, is_orthographic: bool) -> u32 {
+fn view_fragment_cluster_index(frag_coord: vec2<f32>, view_z: f32, is_orthographic: bool) -> u32 {
     let xy = vec2<u32>(floor((frag_coord - bindings::view.viewport.xy) * bindings::lights.cluster_factors.xy));
-    let z_slice = view_z_to_z_slice(view_z, is_orthographic);
+    let z_slice = view_z_to_z_slice(
+        bindings::lights.cluster_factors.zw,
+        bindings::lights.cluster_dimensions.z,
+        view_z,
+        is_orthographic
+    );
+    return fragment_cluster_index(vec3(xy, z_slice), bindings::lights.cluster_dimensions);
+}
+
+// Given a cluster XYZ position, returns its index in the cluster list.
+fn fragment_cluster_index(p: vec3<u32>, cluster_dimensions: vec4<u32>) -> u32 {
     // NOTE: Restricting cluster index to avoid undefined behavior when accessing uniform buffer
     // arrays based on the cluster index.
     return min(
-        (xy.y * bindings::lights.cluster_dimensions.x + xy.x) * bindings::lights.cluster_dimensions.z + z_slice,
-        bindings::lights.cluster_dimensions.w - 1u
+        (p.y * cluster_dimensions.x + p.x) * cluster_dimensions.z + p.z,
+        cluster_dimensions.w - 1u
     );
 }
 
@@ -148,7 +163,12 @@ fn cluster_debug_visualization(
 #ifdef CLUSTERED_FORWARD_DEBUG_Z_SLICES
     // NOTE: This debug mode visualizes the z-slices
     let cluster_overlay_alpha = 0.1;
-    var z_slice: u32 = view_z_to_z_slice(view_z, is_orthographic);
+    var z_slice: u32 = view_z_to_z_slice(
+        bindings::lights.cluster_factors.zw,
+        bindings::lights.cluster_dimensions.z,
+        view_z,
+        is_orthographic
+    );
     // A hack to make the colors alternate a bit more
     if (z_slice & 1u) == 1u {
         z_slice = z_slice + bindings::lights.cluster_dimensions.z / 2u;
diff --git a/crates/bevy_pbr/src/render/light.rs b/crates/bevy_pbr/src/render/light.rs
index d4ff8ae771cc4..8f26b266a15cb 100644
--- a/crates/bevy_pbr/src/render/light.rs
+++ b/crates/bevy_pbr/src/render/light.rs
@@ -125,6 +125,7 @@ bitflags::bitflags! {
         const VOLUMETRIC                        = 1 << 2;
         const AFFECTS_LIGHTMAPPED_MESH_DIFFUSE  = 1 << 3;
         const CONTACT_SHADOWS_ENABLED           = 1 << 4;
+        const SPOT_LIGHT                        = 1 << 5;
         const NONE                              = 0;
         const UNINITIALIZED                     = 0xFFFF;
     }
@@ -1040,6 +1041,8 @@ pub fn prepare_lights(
 
         let (light_custom_data, spot_light_tan_angle) = match light.spot_light_angles {
             Some((inner, outer)) => {
+                flags |= PointLightFlags::SPOT_LIGHT;
+
                 let light_direction = light.transform.forward();
                 if light_direction.y.is_sign_negative() {
                     flags |= PointLightFlags::SPOT_LIGHT_Y_NEGATIVE;
@@ -1091,7 +1094,7 @@ pub fn prepare_lights(
                     .and_then(|decals| decals.get(entity))
                     .and_then(|index| index.try_into().ok())
                     .unwrap_or(u32::MAX),
-                pad: 0.0,
+                range: light.range,
                 soft_shadow_size: if light.soft_shadows_enabled {
                     light.radius
                 } else {
diff --git a/crates/bevy_pbr/src/render/mesh_view_types.wgsl b/crates/bevy_pbr/src/render/mesh_view_types.wgsl
index f4ca5d6e45cd5..bacde26fb99f8 100644
--- a/crates/bevy_pbr/src/render/mesh_view_types.wgsl
+++ b/crates/bevy_pbr/src/render/mesh_view_types.wgsl
@@ -14,7 +14,7 @@ struct ClusteredLight {
     soft_shadow_size: f32,
     shadow_map_near_z: f32,
     decal_index: u32,
-    pad: f32,
+    range: f32,
 };
 
 const POINT_LIGHT_FLAGS_SHADOWS_ENABLED_BIT: u32                    = 1u << 0u;
@@ -22,6 +22,7 @@ const POINT_LIGHT_FLAGS_SPOT_LIGHT_Y_NEGATIVE: u32                  = 1u << 1u;
 const POINT_LIGHT_FLAGS_VOLUMETRIC_BIT: u32                         = 1u << 2u;
 const POINT_LIGHT_FLAGS_AFFECTS_LIGHTMAPPED_MESH_DIFFUSE_BIT: u32   = 1u << 3u;
 const POINT_LIGHT_FLAGS_CONTACT_SHADOWS_ENABLED_BIT: u32            = 1u << 4u;
+const POINT_LIGHT_FLAGS_SPOT_LIGHT_BIT: u32                         = 1u << 5u;
 
 struct DirectionalCascade {
     clip_from_world: mat4x4<f32>,
@@ -60,8 +61,8 @@ struct Lights {
     // xy are vec2<f32>(cluster_dimensions.xy) / vec2<f32>(view.width, view.height)
     //
     // For perspective projections:
-    // z is cluster_dimensions.z / log(far / near)
-    // w is cluster_dimensions.z * log(near) / log(far / near)
+    // z is (cluster_dimensions.z - 1) / log(far / near)
+    // w is (cluster_dimensions.z - 1) * log(near) / log(far / near)
     //
     // For orthographic projections:
     // NOTE: near and far are +ve but -z is infront of the camera
@@ -135,11 +136,13 @@ struct LightProbe {
     // The falloff region, specified as a fraction of the light probe's
     // bounding box.
     falloff: vec3<f32>,
+    bounding_sphere_radius: f32,
     // The boundaries of the simulated space used for parallax correction,
     // specified as *half* extents in light probe space.
     parallax_correction_bounds: vec3<f32>,
-    cubemap_index: i32,
     intensity: f32,
+    world_position: vec3<f32>,
+    cubemap_index: i32,
     // Various flags that apply to this light probe.
     flags: u32,
 };
@@ -215,6 +218,8 @@ struct ClusteredDecal {
     normal_map_texture_index: i32,
     metallic_roughness_texture_index: i32,
     emissive_texture_index: i32,
+    world_position: vec3<f32>,
+    bounding_sphere_radius: f32,
     tag: u32,
     pad_a: u32,
     pad_b: u32,
diff --git a/crates/bevy_pbr/src/render/pbr_functions.wgsl b/crates/bevy_pbr/src/render/pbr_functions.wgsl
index f125e044b0d92..7ab8449b32155 100644
--- a/crates/bevy_pbr/src/render/pbr_functions.wgsl
+++ b/crates/bevy_pbr/src/render/pbr_functions.wgsl
@@ -438,7 +438,7 @@ fn apply_pbr_lighting(
         view_bindings::view.view_from_world[2].z,
         view_bindings::view.view_from_world[3].z
     ), in.world_position);
-    let cluster_index = clustering::fragment_cluster_index(in.frag_coord.xy, view_z, in.is_orthographic);
+    let cluster_index = clustering::view_fragment_cluster_index(in.frag_coord.xy, view_z, in.is_orthographic);
     var clusterable_object_index_ranges =
         clustering::unpack_clusterable_object_index_ranges(cluster_index);
 
diff --git a/crates/bevy_pbr/src/ssr/ssr.wgsl b/crates/bevy_pbr/src/ssr/ssr.wgsl
index e64928ff0a89a..7c1d77560c61b 100644
--- a/crates/bevy_pbr/src/ssr/ssr.wgsl
+++ b/crates/bevy_pbr/src/ssr/ssr.wgsl
@@ -292,7 +292,7 @@ fn fragment(in: FullscreenVertexOutput) -> @location(0) vec4<f32> {
 
     // Determine which cluster we're in. We'll need this to find the right
     // reflection probe.
-    let cluster_index = clustered_forward::fragment_cluster_index(
+    let cluster_index = clustered_forward::view_fragment_cluster_index(
         frag_coord.xy, frag_coord.z, false);
     var clusterable_object_index_ranges =
         clustered_forward::unpack_clusterable_object_index_ranges(cluster_index);
diff --git a/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl b/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl
index 8ab06fd03da02..b63ac25c95926 100644
--- a/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl
+++ b/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl
@@ -337,7 +337,7 @@ fn fragment(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
     // Point lights and Spot lights
     let view_z = view_start_pos.z;
     let is_orthographic = view.clip_from_view[3].w == 1.0;
-    let cluster_index = clustering::fragment_cluster_index(frag_coord.xy, view_z, is_orthographic);
+    let cluster_index = clustering::view_fragment_cluster_index(frag_coord.xy, view_z, is_orthographic);
     var clusterable_object_index_ranges =
         clustering::unpack_clusterable_object_index_ranges(cluster_index);
     for (var i: u32 = clusterable_object_index_ranges.first_point_light_index_offset;
