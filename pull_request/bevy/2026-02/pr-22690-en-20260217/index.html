<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22690 fix: improve semantic clarity for run condition combinators
        
    </title><meta content="#22690 fix: improve semantic clarity for run condition combinators" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-17</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22690-zh-cn-20260217>中文</a></div></div><div class=pr-content><h1 id=fix-improve-semantic-clarity-for-run-condition-combinators>fix: improve semantic clarity for run condition combinators</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: fix: improve semantic clarity for run condition combinators<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22690<li><strong>Author</strong>: joseph-gio<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Usability, S-Ready-For-Final-Review, M-Migration-Guide, X-Blessed<li><strong>Created</strong>: 2026-01-25T02:10:39Z<li><strong>Merged</strong>: 2026-02-17T00:40:13Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>We include several run condition combinators, such as <code>and</code>, <code>or</code>, etc., which short-circuit depending on the output of the first condition in the combinator.<p>This is incredibly error-prone due to the subtle way that short-circuiting interacts with change detection – rather than reacting to changes frame-by-frame, the second condition in short-circuiting combinator will react to <em>the last time that the first condition did not short circuit</em>. This can easily lead to confusing bugs if the user does not expect this, and I suspect that most users will not expect this. For this reason, when combining multiple run conditions added via <code>.run_if()</code>, all run conditions are intentionally eagerly evaluated.<h2 id=solution>Solution</h2><p>Add new run condition combinators <code>and_then</code>, <code>and_eager</code>, <code>or_else</code>, <code>or_eager</code>, etc., for clarity, and deprecate the previous methods, pointing users to the new ones.<p>After the previous combinators have been removed for a few release cycles, we should consider renaming combinators such as <code>and_eager</code> to simply <code>and</code>.<h1 id=migration-guide>Migration Guide</h1><p>Bevy supports run condition combinators (<code>and</code>, <code>or</code>, <code>nan</code>, <code>nor</code>), which have historically short-circuited. While familiar, short-circuiting interacts with Bevy’s change detection in a subtle way: when the left-hand condition short-circuits, the right-hand condition is not evaluated and therefore does not observe changes on that frame. Instead, it reacts based on the last frame it ran, which can lead to confusing and non-local bugs.<p>By contrast, Bevy’s scheduler combines multiple .run_if(…) conditions using eager evaluation, which avoids this known pitfall.<p>To make intent explicit and reduce footguns, short-circuiting combinators have been renamed and eagerly-evaluated variants have been added.<h2 id=examples>Examples</h2><p>Most users should use eager evaluation, which ensures all conditions participate in change detection every frame:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (deprecated)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>and</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>or</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>nand</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>nor</span><span>(cond_b)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After (recommended default)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>and_eager</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>or_eager</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>nand_eager</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>nor_eager</span><span>(cond_b)
</span></code></pre><p>If you <em>intentionally rely on short-circuiting</em> for correctness, use the explicit short-circuiting variants:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Explicit short-circuiting
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>and_then</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>or_else</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>nand_then</span><span>(cond_b)
</span><span>cond_a</span><span style=color:#ed9366>.</span><span style=color:#f07171>nor_else</span><span>(cond_b)
</span></code></pre><p><code>xor</code> and <code>xnor</code> are unchanged, as they cannot short-circuit by nature.<h2 id=future-naming-note>Future naming note</h2><p>The <code>_eager</code> suffix exists to ease migration without changing the behavior of existing code that relied on short-circuiting. After the deprecated combinators have been removed for a few release cycles, we expect to revisit naming and likely remove the _eager suffix, keeping <code>and_then</code> / <code>or_else</code> as the explicit short-circuiting forms.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a subtle but significant issue in Bevy’s run condition combinators. The problem stems from the interaction between short-circuit evaluation and Bevy’s change detection system. When developers use combinators like <code>.and()</code> or <code>.or()</code>, they might expect both conditions to be evaluated every frame, but in reality, these combinators use short-circuit logic similar to Rust’s <code>&&</code> and <code>||</code> operators.<p>The core issue is that when the first condition in a short-circuiting combinator returns a value that causes the second condition to be skipped (like <code>false</code> in an <code>and</code> chain or <code>true</code> in an <code>or</code> chain), the second condition doesn’t get to observe world changes on that frame. Instead, it only sees changes from the last time it was actually executed. This can lead to non-obvious bugs where systems don’t run when expected, or conditions appear to lag behind the actual world state.<p>The developer recognized this as a fundamental design problem that needed addressing. The solution wasn’t to fix a bug in the implementation, but rather to change the API to make the evaluation semantics explicit. This approach follows the principle that APIs should guide users toward correct usage and make potential pitfalls visible.<p>The implementation approach was pragmatic: instead of changing the behavior of existing methods (which would break existing code), the PR introduces new method names with clearer semantics. The short-circuiting variants get names like <code>and_then</code> and <code>or_else</code> that hint at their conditional evaluation nature, while new eager variants get names like <code>and_eager</code> and <code>or_eager</code> that explicitly state they evaluate both conditions. The old methods are deprecated with clear migration guidance.<p>This change required updating the type definitions and implementing the new eager combinators. Each combinator now has two variants: one that short-circuits (using <code>&&</code> and <code>||</code> logic) and one that doesn’t (using <code>&</code> and <code>|</code> bitwise operators for eager evaluation). The naming convention helps developers understand what they’re getting: <code>_then</code> and <code>_else</code> suffixes for short-circuiting, and <code>_eager</code> for non-short-circuiting.<p>From a technical perspective, the implementation adds new marker types like <code>AndEagerMarker</code> and <code>OrEagerMarker</code> that implement the <code>Combine</code> trait to perform eager evaluation. The key difference is in the <code>combine</code> method implementation - while short-circuiting variants use <code>&&</code> and <code>||</code>, eager variants use <code>&</code> and <code>|</code> which always evaluate both operands.<p>The changes also required updating documentation extensively to explain the rationale and provide clear examples. The documentation now explicitly warns about the change detection implications of short-circuiting and recommends eager evaluation as the default choice.<p>This PR has significant impact on code clarity and correctness. It transforms what was a hidden footgun into an explicit design choice that developers must consciously make. The migration guide provides a clear path forward, and the deprecation strategy gives existing code time to adapt. The long-term plan to eventually rename <code>and_eager</code> to simply <code>and</code> after a few release cycles shows good API evolution planning - it moves toward making the safer, more intuitive behavior the default.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[SystemCondition Trait] --> B[Short-circuiting Combinators]
</span><span>    A --> C[Eager Combinators]
</span><span>    
</span><span>    B --> D[and_then]
</span><span>    B --> E[or_else]
</span><span>    B --> F[nand_then]
</span><span>    B --> G[nor_else]
</span><span>    
</span><span>    C --> H[and_eager]
</span><span>    C --> I[or_eager]
</span><span>    C --> J[nand_eager]
</span><span>    C --> K[nor_eager]
</span><span>    
</span><span>    L[Deprecated Methods] --> M[and]
</span><span>    L --> N[or]
</span><span>    L --> O[nand]
</span><span>    L --> P[nor]
</span><span>    
</span><span>    M -.-> D
</span><span>    N -.-> E
</span><span>    O -.-> F
</span><span>    P -.-> G
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-schedule-condition-rs-469-102><code>crates/bevy_ecs/src/schedule/condition.rs</code> (+469/-102)</h3><p>This is the main file where the run condition combinators are defined. The changes include:<ol><li>Renaming existing combinators to have <code>_then</code> and <code>_else</code> suffixes for short-circuiting variants<li>Adding new <code>_eager</code> variants that evaluate both conditions<li>Deprecating the old <code>and</code>, <code>or</code>, <code>nand</code>, <code>nor</code> methods<li>Updating documentation with clear warnings about change detection implications</ol><p>Key code changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>and</span><span>&LTM, C</span><span style=color:#61676ccc>: </span><span>SystemCondition&LTM, In>>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>and</span><span style=color:#61676ccc>:</span><span> C) </span><span style=color:#61676ccc>-> </span><span>And<</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>System, </span><span style=color:#fa6e32>C</span><span style=color:#ed9366>::</span><span>System> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> a </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(</span><span style=color:#55b4d4;font-style:italic>self</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> b </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(and)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> name </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300> && </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> a</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>())</span><span style=color:#61676ccc>;
</span><span>    CombinatorSystem</span><span style=color:#ed9366>::</span><span>new(a</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#61676ccc>, </span><span>DebugName</span><span style=color:#ed9366>::</span><span>owned(name))
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After (multiple methods):
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>and_then</span><span>&LTM, C</span><span style=color:#61676ccc>: </span><span>SystemCondition&LTM, In>>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>then_run</span><span style=color:#61676ccc>:</span><span> C) </span><span style=color:#61676ccc>-> </span><span>AndThen<</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>System, </span><span style=color:#fa6e32>C</span><span style=color:#ed9366>::</span><span>System> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> a </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(</span><span style=color:#55b4d4;font-style:italic>self</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> b </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(then_run)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> name </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300> && </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> a</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>())</span><span style=color:#61676ccc>;
</span><span>    CombinatorSystem</span><span style=color:#ed9366>::</span><span>new(a</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#61676ccc>, </span><span>DebugName</span><span style=color:#ed9366>::</span><span>owned(name))
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>and_eager</span><span>&LTM, C</span><span style=color:#61676ccc>: </span><span>SystemCondition&LTM, In>>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>other</span><span style=color:#61676ccc>:</span><span> C) </span><span style=color:#61676ccc>-> </span><span>AndEager<</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>System, </span><span style=color:#fa6e32>C</span><span style=color:#ed9366>::</span><span>System> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> a </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(</span><span style=color:#55b4d4;font-style:italic>self</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> b </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(other)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> name </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300> & </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> a</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>())</span><span style=color:#61676ccc>;
</span><span>    CombinatorSystem</span><span style=color:#ed9366>::</span><span>new(a</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#61676ccc>, </span><span>DebugName</span><span style=color:#ed9366>::</span><span>owned(name))
</span><span>}
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>deprecated</span><span>(since </span><span style=color:#ed9366>= </span><span style=color:#86b300>"0.19.0"</span><span style=color:#61676ccc>,</span><span> note </span><span style=color:#ed9366>= </span><span style=color:#86b300>"use `.and_then(...)` instead, or `.and_eager(...)` to evaluate the conditions eagerly"</span><span>)]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>and</span><span>&LTM, C</span><span style=color:#61676ccc>: </span><span>SystemCondition&LTM, In>>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>then_run</span><span style=color:#61676ccc>:</span><span> C) </span><span style=color:#61676ccc>-> </span><span>AndThen<</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>System, </span><span style=color:#fa6e32>C</span><span style=color:#ed9366>::</span><span>System> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> a </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(</span><span style=color:#55b4d4;font-style:italic>self</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> b </span><span style=color:#ed9366>= </span><span>IntoSystem</span><span style=color:#ed9366>::</span><span>into_system(then_run)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> name </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300> && </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> a</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>())</span><span style=color:#61676ccc>;
</span><span>    CombinatorSystem</span><span style=color:#ed9366>::</span><span>new(a</span><span style=color:#61676ccc>,</span><span> b</span><span style=color:#61676ccc>, </span><span>DebugName</span><span style=color:#ed9366>::</span><span>owned(name))
</span><span>}
</span></code></pre><p>The type definitions were also updated:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub type </span><span style=color:#399ee6>And</span><span style=color:#ed9366><</span><span>A</span><span style=color:#61676ccc>,</span><span> B</span><span style=color:#ed9366>> = </span><span>CombinatorSystem&LTAndMarker, A, B></span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub type </span><span style=color:#399ee6>AndThen</span><span style=color:#ed9366><</span><span>A</span><span style=color:#61676ccc>,</span><span> B</span><span style=color:#ed9366>> = </span><span>CombinatorSystem&LTAndThenMarker, A, B></span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>pub type </span><span style=color:#399ee6>AndEager</span><span style=color:#ed9366><</span><span>A</span><span style=color:#61676ccc>,</span><span> B</span><span style=color:#ed9366>> = </span><span>CombinatorSystem&LTAndEagerMarker, A, B></span><span style=color:#61676ccc>;
</span></code></pre><h3 id=examples-ecs-run-conditions-rs-4-4><code>examples/ecs/run_conditions.rs</code> (+4/-4)</h3><p>Updated examples to use the new method names, demonstrating the migration from old short-circuiting combinators to the new explicit ones:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(resource_exists</span><span style=color:#ed9366>::</span><span>&LTUnused></span><span style=color:#ed9366>.</span><span style=color:#f07171>or</span><span>(
</span><span>    has_user_input</span><span style=color:#61676ccc>,
</span><span>))
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(resource_exists</span><span style=color:#ed9366>::</span><span>&LTUnused></span><span style=color:#ed9366>.</span><span style=color:#f07171>or_else</span><span>(
</span><span>    has_user_input</span><span style=color:#61676ccc>,
</span><span>))
</span></code></pre><h3 id=examples-math-render-primitives-rs-3-2><code>examples/math/render_primitives.rs</code> (+3/-2)</h3><p>Updated to use <code>or_eager</code> instead of <code>or</code> for combining state change conditions:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>update_primitive_meshes
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(state_changed</span><span style=color:#ed9366>::</span><span>&LTPrimitiveSelected></span><span style=color:#ed9366>.</span><span style=color:#f07171>or</span><span>(state_changed</span><span style=color:#ed9366>::</span><span>&LTCameraActive>))</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>update_primitive_meshes</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(
</span><span>    state_changed</span><span style=color:#ed9366>::</span><span>&LTPrimitiveSelected></span><span style=color:#ed9366>.</span><span style=color:#f07171>or_eager</span><span>(state_changed</span><span style=color:#ed9366>::</span><span>&LTCameraActive>)</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>,
</span></code></pre><h3 id=crates-bevy-ecs-src-system-combinator-rs-2-2><code>crates/bevy_ecs/src/system/combinator.rs</code> (+2/-2)</h3><p>Updated a test to use the new <code>OrElseMarker</code> instead of <code>OrMarker</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> system </span><span style=color:#ed9366>= </span><span>CombinatorSystem</span><span style=color:#ed9366>::</span><span>&LTOrMarker, </span><span style=color:#ed9366>_</span><span>, </span><span style=color:#ed9366>_</span><span>></span><span style=color:#ed9366>::</span><span>new(
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> system </span><span style=color:#ed9366>= </span><span>CombinatorSystem</span><span style=color:#ed9366>::</span><span>&LTOrElseMarker, </span><span style=color:#ed9366>_</span><span>, </span><span style=color:#ed9366>_</span><span>></span><span style=color:#ed9366>::</span><span>new(
</span></code></pre><h3 id=crates-bevy-ecs-src-system-mod-rs-1-1><code>crates/bevy_ecs/src/system/mod.rs</code> (+1/-1)</h3><p>Updated a test to use <code>or_eager</code> instead of <code>or</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>distributive_run_if</span><span>(resource_exists</span><span style=color:#ed9366>::</span><span>&LTA></span><span style=color:#ed9366>.</span><span style=color:#f07171>or</span><span>(resource_exists</span><span style=color:#ed9366>::</span><span>&LTB>))</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>distributive_run_if</span><span>(resource_exists</span><span style=color:#ed9366>::</span><span>&LTA></span><span style=color:#ed9366>.</span><span style=color:#f07171>or_eager</span><span>(resource_exists</span><span style=color:#ed9366>::</span><span>&LTB>))</span><span style=color:#61676ccc>,
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy’s Change Detection System</strong>: Understanding how Bevy tracks changes to components and resources is crucial for understanding why short-circuiting combinators cause issues. The official Bevy documentation on change detection provides detailed information.</p><li><p><strong>Short-circuit Evaluation in Programming Languages</strong>: The behavior of <code>&&</code> and <code>||</code> operators in languages like Rust, C, and JavaScript follows short-circuit evaluation. Understanding this pattern helps recognize why the original combinators behaved as they did.</p><li><p><strong>API Design Principles</strong>: This PR demonstrates good API design practices, particularly the principle of making implicit behavior explicit and providing migration paths for breaking changes.</p><li><p><strong>Rust’s Operator Overloading</strong>: The use of <code>&</code> and <code>|</code> for eager boolean evaluation (as opposed to <code>&&</code> and <code>||</code> for short-circuiting) follows Rust’s convention where bitwise operators evaluate both sides.</p><li><p><strong>Bevy’s System Combinators Documentation</strong>: For more details on how to combine systems and conditions in Bevy, refer to the official documentation on system combinators and run conditions.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22690.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>