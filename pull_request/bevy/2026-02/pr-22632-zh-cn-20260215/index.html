<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22632 Don't require image/buffer to have COPY_DST to reuse if no data
        
    </title><meta content="#22632 Don't require image/buffer to have COPY_DST to reuse if no data" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-15</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-22632-en-20260215>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title-don-t-require-image-buffer-to-have-copy-dst-to-reuse-if-no-data>Title: Don’t require image/buffer to have COPY_DST to reuse if no data</h1><h2 id=ji-ben-zi-xun>基本資訊</h2><ul><li><strong>標題</strong>: Don’t require image/buffer to have COPY_DST to reuse if no data<li><strong>PR 連結</strong>: https://github.com/bevyengine/bevy/pull/22632<li><strong>作者</strong>: beicause<li><strong>狀態</strong>: MERGED<li><strong>標籤</strong>: A-Rendering, C-Usability, D-Straightforward, S-Needs-Review<li><strong>創建時間</strong>: 2026-01-21T19:56:10Z<li><strong>合併時間</strong>: 2026-02-15T14:31:43Z<li><strong>合併者</strong>: mockersf</ul><h2 id=miao-shu-fan-yi>描述翻譯</h2><h1 id=mu-biao>目標</h1><p>如果圖像或緩衝區沒有數據，我們就不會呼叫 <code>write_texture</code>/<code>write_buffer</code>，因此即使它們沒有 <code>COPY_DST</code> 使用標誌，我們也可以重複使用它們。<h2 id=jie-jue-fang-an>解決方案</h2><p><code>(!had_data || usage contains COPY_DST)</code><h2 id=ce-shi>測試</h2><p>手動測試。<h2 id=zhe-ge-pull-request-de-gu-shi>這個 Pull Request 的故事</h2><p>這個 PR 解決了一個 GPU 資源管理和重複使用（reuse）邏輯中的邊際情況優化問題。在 Bevy 的渲染架構中，<code>GpuImage</code> 和 <code>GpuShaderBuffer</code> 這類 GPU 資源在幀之間更新時，系統會嘗試復用（reuse）現有的 GPU 物件（例如 <code>wgpu::Texture</code> 或 <code>wgpu::Buffer</code>），而不是每次都創建新的。這是一種重要的效能優化，可以避免不必要的記憶體分配和銷毀開銷。<p>然而，原有的重複使用邏輯存在一個可以改進的限制。對於一個 <code>GpuImage</code> 或 <code>GpuShaderBuffer</code>，如果它的描述符（descriptor）——包括大小、格式、使用標誌等——與上一幀的資源完全匹配，並且<strong>其使用標誌包含了 <code>TextureUsages::COPY_DST</code> 或 <code>BufferUsages::COPY_DST</code></strong>，那麼系統就會嘗試復用現有的 GPU 物件，並通過 <code>write_texture</code> 或 <code>write_buffer</code> 將新的數據上傳上去。<p>問題就在於這個 <code>COPY_DST</code> 的檢查是無條件的。<code>COPY_DST</code> 使用標誌表示該資源可以被用作複製操作（copy operation）的目標，這是執行 <code>write_texture</code>/<code>write_buffer</code> 的必要條件。邏輯很直觀：如果你想寫入數據，你必須確保資源允許寫入。<p>但是，考慮這樣一種情況：一個資源在創建時沒有數據（例如，它可能是一個用於存儲計算結果的渲染目標，或者一個後續通過其他方式填充的緩衝區）。在後續的更新中，如果這個資源的描述符沒有改變，並且仍然<strong>沒有新的數據需要上傳</strong>（<code>image.data.is_none()</code> 或 <code>source_asset.data.is_none()</code>），那麼系統實際上並不會呼叫 <code>write_texture</code> 或 <code>write_buffer</code>。在這種「沒有數據需要寫入」的情況下，資源是否具有 <code>COPY_DST</code> 標誌就變得無關緊要了。現有的邏輯卻因為缺少 <code>COPY_DST</code> 標誌而錯誤地阻止了資源的重複使用，導致系統創建一個新的、同樣沒有 <code>COPY_DST</code> 標誌的資源來替代它。這造成了不必要的資源創建開銷。<p>這個 PR 的解決方案非常精確和簡潔。它沒有移除 <code>COPY_DST</code> 的檢查，而是修改了檢查的條件。新的邏輯是：只有當資源<strong>有數據需要寫入</strong>（<code>had_data</code> 為 <code>true</code>）時，才需要檢查其是否包含 <code>COPY_DST</code> 使用標誌。如果沒有數據需要寫入（<code>had_data</code> 為 <code>false</code>），則跳過 <code>COPY_DST</code> 的檢查，允許資源在描述符匹配的情況下被重複使用。<p>具體的實現體現在兩段幾乎相同的條件判斷邏輯中。以 <code>GpuImage</code> 為例，修改前的程式碼是：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>&&</span><span> prev</span><span style=color:#ed9366>.</span><span>texture_descriptor</span><span style=color:#ed9366>.</span><span>usage</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(TextureUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COPY_DST</span><span>)
</span></code></pre><p>修改後變成了：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>&& </span><span>(</span><span style=color:#ed9366>!</span><span>had_data </span><span style=color:#ed9366>||</span><span> prev</span><span style=color:#ed9366>.</span><span>texture_descriptor</span><span style=color:#ed9366>.</span><span>usage</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(TextureUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COPY_DST</span><span>))
</span></code></pre><p>這是一個典型的「修正過度限制條件」的優化。它放寬了重複使用的條件，使其與實際的資源使用模式（是否需要寫入數據）保持一致，從而避免了不必要的資源重新建立。這種修改體現了良好的 API 設計思維：約束應該與功能需求精確對應，避免施加不必要的限制。<p>從工程模式的角度來看，這也是一個清晰的例子，展示了如何通過布林邏輯（<code>!had_data || ...</code>）來組合條件，以更精確地表達意圖。它將「是否需要寫入能力」與「是否具有寫入能力」這兩個概念分開處理，只有在前者為真時才驗證後者。<p>這個改動的影響是積極的：它提升了渲染效率，特別是在頻繁更新但數據時有時無的動態資源場景下。它不會破壞現有功能，因為對於任何有數據需要上傳的資源，<code>COPY_DST</code> 的檢查依然有效，確保了寫入操作的安全性。這是一個低風險、高回報的改進。<h2 id=shi-jue-hua-cheng-xian>視覺化呈現</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    subgraph “PR #22632 優化的邏輯”
</span><span>        A[資源更新流程] --> B{描述符是否匹配？};
</span><span>        B -- 是 --> C{是否有數據需寫入？};
</span><span>        C -- 否 --> D[允許重複使用資源];
</span><span>        C -- 是 --> E{資源是否包含 COPY_DST 標誌？};
</span><span>        E -- 是 --> F[允許重複使用並寫入數據];
</span><span>        E -- 否 --> G[創建新資源];
</span><span>        B -- 否 --> G;
</span><span>    end
</span></code></pre><h2 id=guan-jian-dang-an-bian-geng>關鍵檔案變更</h2><ol><li><p><strong><code>crates/bevy_render/src/texture/gpu_image.rs</code></strong> (+5/-4)</p> <ul><li><strong>變更原因</strong>：優化 <code>GpuImage</code> 資源的重複使用邏輯，允許沒有數據的圖像在缺少 <code>COPY_DST</code> 標誌時也能被重複使用。<li><strong>關鍵修改</strong>：修改了 <code>RenderAsset</code> trait 為 <code>GpuImage</code> 實現中的 <code>prepare_asset</code> 方法內的條件判斷。</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_render/src/texture/gpu_image.rs
</span><span style=color:#abb0b6;font-style:italic>// 修改前:
</span><span style=color:#ed9366>&&</span><span> prev</span><span style=color:#ed9366>.</span><span>texture_descriptor</span><span style=color:#ed9366>.</span><span>usage</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(TextureUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COPY_DST</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改後:
</span><span style=color:#ed9366>&& </span><span>(</span><span style=color:#ed9366>!</span><span>had_data
</span><span>    </span><span style=color:#ed9366>||</span><span> prev</span><span style=color:#ed9366>.</span><span>texture_descriptor</span><span style=color:#ed9366>.</span><span>usage</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(TextureUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COPY_DST</span><span>))
</span></code></pre> <ul><li><strong>與 PR 目標的關係</strong>：這是實現本 PR 核心目標的兩處修改之一，針對紋理（Texture）資源。</ul><li><p><strong><code>crates/bevy_render/src/storage.rs</code></strong> (+5/-4)</p> <ul><li><strong>變更原因</strong>：優化 <code>GpuShaderBuffer</code> 資源的重複使用邏輯，允許沒有數據的緩衝區在缺少 <code>COPY_DST</code> 標誌時也能被重複使用。<li><strong>關鍵修改</strong>：修改了 <code>RenderAsset</code> trait 為 <code>GpuShaderBuffer</code> 實現中的 <code>prepare_asset</code> 方法內的條件判斷。</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_render/src/storage.rs
</span><span style=color:#abb0b6;font-style:italic>// 修改前:
</span><span style=color:#ed9366>&&</span><span> source_asset</span><span style=color:#ed9366>.</span><span>buffer_description</span><span style=color:#ed9366>.</span><span>usage</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(BufferUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COPY_DST</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改後:
</span><span style=color:#ed9366>&& </span><span>(</span><span style=color:#ed9366>!</span><span>had_data
</span><span>    </span><span style=color:#ed9366>||</span><span> source_asset</span><span style=color:#ed9366>.</span><span>buffer_description</span><span style=color:#ed9366>.</span><span>usage</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(BufferUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COPY_DST</span><span>))
</span></code></pre> <ul><li><strong>與 PR 目標的關係</strong>：這是實現本 PR 核心目標的兩處修改之一，針對緩衝區（Buffer）資源。邏輯與 <code>gpu_image.rs</code> 中的修改完全對稱。</ul></ol><h2 id=yan-shen-yue-du>延伸閱讀</h2><ul><li><strong>Bevy RenderAsset Trait 文件</strong>: 瞭解 <code>RenderAsset</code> trait 如何作為渲染資源準備的核心抽象。<li><strong>wgpu BufferUsages 和 TextureUsages</strong>: 理解 <code>COPY_DST</code> 及其他使用標誌（如 <code>STORAGE</code>, <code>RENDER_ATTACHMENT</code>）的具體含義和用途。<li><strong>資源重用（Resource Reuse）模式</strong>: 在實時圖形和遊戲引擎中，高效管理 GPU 資源是關鍵效能優化點，避免每幀分配/釋放資源是常見模式。</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22632.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>