<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22767 Add per-entity NoCpuCulling
        
    </title><meta content="#22767 Add per-entity NoCpuCulling" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-04</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22767-zh-cn-20260204>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Add per-entity NoCpuCulling<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add per-entity NoCpuCulling<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22767<li><strong>Author</strong>: Lampan-git<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, D-Straightforward<li><strong>Created</strong>: 2026-02-01T17:12:34Z<li><strong>Merged</strong>: 2026-02-04T17:02:11Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>I use a compute shader to update the transforms and write them to MeshInput directly for some entities and doesn’t readback to the CPU. This has the unfortunate side-effect of making the main world transform positions always being (0,0) and then being frustum culled on the CPU side. There is no way to disable CPU culling per entity, hence this PR.</ul><h2 id=solution>Solution</h2><ul><li>Use the same <code>Has&LTNoCpuCulling></code> for visible_aabb_query as view_query</ul><h2 id=testing>Testing</h2><p>I checked in RenderDoc for VkDrawIndexedIndirectCommand’s instanceCount, which results in the same number as without NoCpuCulling, and lower number than with NoFrustumCulling. It also works when looking away from the center.<p>Note that this is my first real contribution and I have no real rendering experience.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The developer faced a specific rendering challenge where they were using compute shaders to update entity transforms on the GPU side. They were writing transforms directly to <code>MeshInput</code> without reading back to the CPU, which created a disconnect: the GPU had accurate transform data for rendering, but the CPU-side world transform positions remained at (0,0,0). This stale CPU data caused the frustum culling system to incorrectly cull these entities, even when they should have been visible.<p>The existing <code>NoCpuCulling</code> component was designed to address similar issues, but it had a limitation - it could only be applied at the camera level. When attached to a camera, it would disable CPU-side culling for all entities rendered by that camera. This was too broad for the developer’s use case, where only specific entities (those with GPU-updated transforms) needed CPU culling disabled.<p>The solution implemented in this PR is straightforward but effective: extend the <code>NoCpuCulling</code> component to work on a per-entity basis, not just per-camera. The implementation modifies the <code>check_visibility</code> system to check for <code>NoCpuCulling</code> on both cameras and individual entities.<p>Here’s how the logic works in practice: when the system processes entities for visibility determination, it now checks three conditions before performing CPU-side frustum culling:<ol><li>Whether the entity has <code>NoFrustumCulling</code> (disables all frustum culling)<li>Whether the camera has <code>NoCpuCulling</code> (existing behavior)<li>Whether the entity has <code>NoCpuCulling</code> (new behavior)</ol><p>The key change is in the condition check within <code>check_visibility</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>no_frustum_culling </span><span style=color:#ed9366>&& !</span><span>no_cpu_culling </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(model_aabb) </span><span style=color:#ed9366>=</span><span> maybe_model_aabb
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>no_frustum_culling </span><span style=color:#ed9366>&& !</span><span>no_cpu_culling_camera </span><span style=color:#ed9366>&& !</span><span>no_cpu_culling_entity </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(model_aabb) </span><span style=color:#ed9366>=</span><span> maybe_model_aabb
</span></code></pre><p>This change allows for more granular control over the culling behavior. Entities with GPU-updated transforms can now be marked with <code>NoCpuCulling</code> to prevent incorrect culling based on stale CPU-side transform data, while other entities in the same scene continue to benefit from CPU-side culling optimizations.<p>The PR also improves the documentation for <code>NoCpuCulling</code> to clarify its dual usage:<ul><li>Disabling CPU culling completely for a camera (using only GPU culling)<li>Handling cases where transforms are overwritten on the GPU side (like the author’s compute shader scenario)</ul><p>This implementation maintains backward compatibility - existing code using <code>NoCpuCulling</code> on cameras continues to work unchanged. The addition of per-entity support doesn’t break the existing API while providing the necessary flexibility for advanced rendering techniques.<p>From a technical perspective, this change highlights the importance of considering both CPU and GPU data consistency in rendering pipelines. When transforms are managed exclusively on the GPU (through compute shaders or other GPU-driven rendering techniques), the CPU-side systems need mechanisms to opt-out of operations that depend on accurate CPU-side transform data.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Camera] --> B{check_visibility system}
</span><span>    C[Entity 1] --> B
</span><span>    D[Entity 2] --> B
</span><span>    E[Entity 3] --> B
</span><span>    
</span><span>    F[NoCpuCulling on Camera] --> B
</span><span>    G[NoCpuCulling on Entity 3] --> B
</span><span>    
</span><span>    B --> H[CPU Frustum Culling]
</span><span>    
</span><span>    F -.->|Skips CPU culling for all entities| H
</span><span>    G -.->|Skips CPU culling for Entity 3 only| H
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-camera-src-visibility-mod-rs-12-2><code>crates/bevy_camera/src/visibility/mod.rs</code> (+12/-2)</h3><p>This file contains the core visibility and culling logic for Bevy’s camera system. The changes are minimal but significant:<ol><li><strong>Documentation enhancement</strong>: Added comprehensive documentation to the <code>NoCpuCulling</code> component struct, explaining its dual usage for both cameras and individual entities.</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Added documentation explaining the component's purpose:
</span><span style=color:#abb0b6;font-style:italic>/// Use this component to opt-out of the built-in CPU frustum culling, see
</span><span style=color:#abb0b6;font-style:italic>/// [`Frustum`]. This can be attached to a [`Camera`] or to individual entities.
</span><span style=color:#abb0b6;font-style:italic>///
</span><span style=color:#abb0b6;font-style:italic>/// It can be used for example:
</span><span style=color:#abb0b6;font-style:italic>/// - disabling CPU culling completely for a [`Camera`], using only GPU culling.
</span><span style=color:#abb0b6;font-style:italic>/// - when overwriting a [`Mesh`]'s transform on the GPU side (e.g. overwriting `MeshInputUniform`'s
</span><span style=color:#abb0b6;font-style:italic>///   `world_from_local`), resulting in stale CPU-side positions.
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>NoCpuCulling</span><span style=color:#61676ccc>;
</span></code></pre><ol start=2><li><strong>Query modification</strong>: Added <code>Has&LTNoCpuCulling></code> to the <code>visible_aabb_query</code> to enable per-entity checking.</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// In the check_visibility function's parameter declaration:
</span><span>visible_aabb_query</span><span style=color:#61676ccc>: </span><span>Query<
</span><span>    (
</span><span>        Entity,
</span><span>        </span><span style=color:#ed9366>&</span><span>ViewVisibility,
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> ComputedVisibility,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>Aabb>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>RenderLayers>,
</span><span>        </span><span style=color:#ed9366>&</span><span>GlobalTransform,
</span><span>        Has&LTNoFrustumCulling>,
</span><span>        Has&LTVisibilityRange>,
</span><span>        Has&LTNoCpuCulling>,  // Added this component check for entities
</span><span>    ),
</span><span>    Without&LTNoCpuCulling>,
</span><span>></span><span style=color:#61676ccc>,
</span></code></pre><ol start=3><li><strong>Logic update</strong>: Modified the frustum culling condition to check for <code>NoCpuCulling</code> on both the camera and the entity.</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before the change:
</span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>no_frustum_culling </span><span style=color:#ed9366>&& !</span><span>no_cpu_culling </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(model_aabb) </span><span style=color:#ed9366>=</span><span> maybe_model_aabb
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After the change:
</span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>no_frustum_culling
</span><span>    </span><span style=color:#ed9366>&& !</span><span>no_cpu_culling_camera
</span><span>    </span><span style=color:#ed9366>&& !</span><span>no_cpu_culling_entity
</span><span>    </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(model_aabb) </span><span style=color:#ed9366>=</span><span> maybe_model_aabb
</span></code></pre><p>The changes are minimal and focused, adding only what’s necessary to support the new per-entity functionality without overcomplicating the implementation.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy Visibility System</strong>: The official Bevy documentation on visibility and culling systems provides context for how these components interact.<li><strong>GPU-Driven Rendering</strong>: For understanding the use case that motivated this change, resources on GPU-driven rendering pipelines and compute shader transform updates would be helpful.<li><strong>Frustum Culling Algorithms</strong>: Background on different frustum culling techniques (both CPU and GPU-based) can help understand the trade-offs between performance and accuracy.<li><strong>Entity Component System Patterns</strong>: This PR demonstrates a common ECS pattern where components can be attached to different entity types (cameras and regular entities) with consistent querying logic.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22767.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>