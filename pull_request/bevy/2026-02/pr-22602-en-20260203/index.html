<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22602 Observer run conditions
        
    </title><meta content="#22602 Observer run conditions" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-03</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22602-zh-cn-20260203>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Observer run conditions<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22602<li><strong>Author</strong>: jonas-meyer<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-ECS, S-Ready-For-Final-Review, M-Release-Note, D-Modest, D-Unsafe<li><strong>Created</strong>: 2026-01-19T21:58:49Z<li><strong>Merged</strong>: 2026-02-03T16:12:26Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Allow observers to use run conditions, enabling conditional execution based on world state - the same pattern that systems use with .run_if().<p>Fixes #14195 Fixes #21442<h2 id=solution>Solution</h2><p>Add a run_if() method to observer systems via the ObserverSystemExt trait. Conditions are stored in Observer and checked before execution in the runner.<p>Key implementation details:<ul><li>ObserverWithCondition&LTE,B,M,S> wrapper preserves event type info for compile-time EntityEvent enforcement on entity observers<li>Conditions are ReadOnlySystem (enforced by SystemCondition trait), matching system run conditions<li>Multiple conditions chain with AND semantics, short-circuiting on first false</ul><p>It’s a bit more involved than mentioned <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/21442#issuecomment-3765694484 target=_blank>here</a> since we need the full system‑style API: chained run_ifs, entity observers with compile‑time EntityEvent checks, and use with add_observer/observe.<p>That forces a typed wrapper + marker types + IntoObserver/IntoEntityObserver, and conditions must be initialized at spawn time (so the hook has to take/init/restore). The runner also needs a safety‑documented precheck before running the observer.<h2 id=testing>Testing</h2><ul><li>Added 7 new tests covering: <ul><li>Condition preventing/allowing execution<li>Multiple conditions (all true / one false)<li>Entity observers with conditions<li>Resource-based conditions<li>Builder pattern on Observer::new()</ul><li>All existing tests pass (cargo test -p bevy_ecs)<li>Updated observers.rs example with Space key toggle</ul><hr><h2 id=showcase>Showcase</h2><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>GameActive</span><span>(</span><span style=color:#fa6e32>bool</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// Global observer - only runs when game is active
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(
</span><span>    on_damage</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(|</span><span style=color:#ff8f40>state</span><span style=color:#61676ccc>: </span><span>Res&LTGameActive>| state</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// Chained conditions (AND semantics)
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(
</span><span>    on_damage
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(|</span><span style=color:#ff8f40>state</span><span style=color:#61676ccc>: </span><span>Res&LTGameActive>| state</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(|</span><span style=color:#ff8f40>player</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span>Health, With&LTPlayer>>| player</span><span style=color:#ed9366>.</span><span style=color:#f07171>single</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_ok</span><span>())
</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// Entity observer
</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(Enemy)</span><span style=color:#ed9366>.</span><span style=color:#f07171>observe</span><span>(
</span><span>    on_hit</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(|</span><span style=color:#ff8f40>game</span><span style=color:#61676ccc>: </span><span>Res&LTGameActive>| game</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// Builder pattern
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(
</span><span>    Observer</span><span style=color:#ed9366>::</span><span>new(on_event)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_entity</span><span>(target)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(some_condition)
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><details><summary>Example from observers.rs</summary> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>ExplosionsEnabled</span><span>(</span><span style=color:#fa6e32>bool</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>toggle_explosions</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>enabled</span><span style=color:#61676ccc>: </span><span>ResMut&LTExplosionsEnabled>, </span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span>Res&LTButtonInput&LTKeyCode>>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> input</span><span style=color:#ed9366>.</span><span style=color:#f07171>just_pressed</span><span>(KeyCode</span><span style=color:#ed9366>::</span><span>Space) {
</span><span>        enabled</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>= !</span><span>enabled</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#f07171>info!</span><span>(</span><span style=color:#86b300>"Explosions {}"</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>if</span><span> enabled</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span>{ </span><span style=color:#86b300>"enabled" </span><span>} </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#86b300>"disabled" </span><span>})</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>setup</span><span>(</span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>    app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(
</span><span>        explode_mine</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(|</span><span style=color:#ff8f40>enabled</span><span style=color:#61676ccc>: </span><span>Res&LTExplosionsEnabled>| enabled</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre></details><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>Observers in Bevy provide a powerful way to react to events, but they lacked a critical feature: conditional execution. This limitation became apparent when developers needed observers to run only under specific game states or conditions, requiring workarounds like checking conditions inside the observer function itself or using multiple observers. This PR addresses that gap by bringing <code>.run_if()</code> functionality to observers, matching the capabilities already available to regular systems.<p>The implementation began with the core requirement: conditions needed to work seamlessly across all observer use cases. This included global observers added via <code>add_observer()</code>, entity observers created with <code>.observe()</code>, and the builder pattern using <code>Observer::new()</code>. The challenge was maintaining type safety while supporting chained conditions and preserving compile-time validation for entity events.<p>The solution centers around three key components. First, the <code>ObserverSystemExt</code> trait provides the <code>.run_if()</code> method that returns an <code>ObserverWithCondition</code> wrapper. This wrapper preserves the event type information needed for compile-time enforcement of <code>EntityEvent</code> on entity observers. Second, the <code>Observer</code> struct now stores a vector of <code>ObserverCondition</code> objects that hold the actual condition systems. Third, the observer runner checks all conditions before executing the observer’s main logic.<p>A significant implementation detail is the initialization sequence. Conditions must be initialized after the observer is added to the world but before any events can trigger it. This required modifying the <code>hook_on_add</code> function to temporarily take ownership of the conditions vector, initialize each condition, and then restore it to the observer. The runner performs safety-documented checks before evaluating conditions, ensuring proper world access.<p>The design follows Bevy’s existing patterns for system conditions. Conditions are <code>ReadOnlySystem</code>s (enforced by the <code>SystemCondition</code> trait), matching how system run conditions work. Multiple conditions chain with AND semantics and short-circuit on the first false condition. The implementation also handles error cases where conditions might return <code>Result&LTbool></code>.<p>Testing was comprehensive, covering both global and entity observers with various condition types. The example in <code>observers.rs</code> was updated to demonstrate the feature with a Space key toggle, providing immediate visual feedback of the functionality. All existing tests continue to pass, confirming backward compatibility.<p>This change enhances Bevy’s observer system by providing the same conditional execution capabilities that systems enjoy, reducing boilerplate and enabling more declarative observer patterns. Developers can now write observers that cleanly separate condition checking from reaction logic, improving code organization and maintainability.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[ObserverSystemExt trait] -->|provides| B[.run_if() method]
</span><span>    B -->|returns| C[ObserverWithCondition wrapper]
</span><span>    C -->|preserves type info| D[EntityEvent validation]
</span><span>    E[Observer struct] -->|stores| F[Vec&LTObserverCondition>]
</span><span>    F -->|initialized by| G[hook_on_add function]
</span><span>    H[Observer runner] -->|checks| F
</span><span>    F -->|all true| I[Execute observer]
</span><span>    F -->|any false| J[Skip observer]
</span><span>    K[IntoObserver trait] -->|enables| L[add_observer() API]
</span><span>    M[IntoEntityObserver trait] -->|enables| N[entity.observe() API]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-observer-mod-rs-215-6><code>crates/bevy_ecs/src/observer/mod.rs</code> (+215/-6)</h3><p>This is the main entry point for observer functionality. The changes add support for run conditions throughout the observer API.<p>Key modifications:<ol><li><p><strong><code>World::add_observer()</code></strong> now uses the <code>IntoObserver</code> trait instead of <code>IntoObserverSystem</code>, enabling it to accept observers with conditions.</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>add_observer</span><span>&LTE</span><span style=color:#61676ccc>:</span><span> Event, B</span><span style=color:#61676ccc>:</span><span> Bundle, M>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>system</span><span style=color:#61676ccc>:</span><span> impl IntoObserverSystem&LTE, B, M>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>EntityWorldMut<'</span><span style=color:#ed9366>_</span><span>> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(Observer</span><span style=color:#ed9366>::</span><span>new(system))
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>add_observer</span><span>&LTM>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>observer</span><span style=color:#61676ccc>:</span><span> impl IntoObserver&LTM>) </span><span style=color:#61676ccc>-> </span><span>EntityWorldMut<'</span><span style=color:#ed9366>_</span><span>> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(observer</span><span style=color:#ed9366>.</span><span style=color:#f07171>into_observer</span><span>())
</span><span>}
</span></code></pre><li><p><strong>New tests</strong> were added to verify run condition functionality, covering:</p> <ul><li>Basic true/false conditions<li>Chained conditions with AND semantics<li>Entity observers with conditions<li>Conditions returning <code>Result&LTbool></code><li>Change detection in conditions<li>Builder pattern with <code>Observer::new().run_if()</code></ul></ol><h3 id=crates-bevy-ecs-src-observer-distributed-storage-rs-138-12><code>crates/bevy_ecs/src/observer/distributed_storage.rs</code> (+138/-12)</h3><p>This file contains the core <code>Observer</code> struct definition and related traits.<p>Key modifications:<ol><li><p><strong><code>Observer</code> struct</strong> now includes a <code>conditions</code> field:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Observer </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing fields ...
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) conditions</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTObserverCondition>,
</span><span>}
</span></code></pre><li><p><strong>New methods</strong> for adding conditions:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Adds a run condition to this observer.
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>run_if</span><span>&LTM>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>condition</span><span style=color:#61676ccc>:</span><span> impl SystemCondition&LTM>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>conditions</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(ObserverCondition</span><span style=color:#ed9366>::</span><span>new(condition))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self
</span><span>}
</span></code></pre><li><p><strong><code>IntoObserver</code> and <code>IntoEntityObserver</code> traits</strong> enable polymorphic acceptance of observers with or without conditions:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>IntoObserver</span><span>&LTMarker>: Send + 'static {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>into_observer</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Observer</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>IntoEntityObserver</span><span>&LTMarker>: Send + 'static {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>into_observer_for_entity</span><span>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>entity</span><span style=color:#61676ccc>:</span><span> Entity) </span><span style=color:#61676ccc>-></span><span> Observer</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><li><p><strong><code>hook_on_add</code> function</strong> was updated to initialize conditions during observer registration:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let mut</span><span> conditions </span><span style=color:#ed9366>= </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... get observer and take conditions ...
</span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>for</span><span> condition </span><span style=color:#ed9366>in &</span><span style=color:#fa6e32>mut</span><span> conditions {
</span><span>    condition</span><span style=color:#ed9366>.</span><span style=color:#f07171>initialize</span><span>(world)</span><span style=color:#61676ccc>;
</span><span>}
</span><span style=color:#abb0b6;font-style:italic>// ... restore conditions to observer ...
</span></code></pre></ol><h3 id=crates-bevy-ecs-src-observer-condition-rs-108-0><code>crates/bevy_ecs/src/observer/condition.rs</code> (+108/-0)</h3><p>This is a new file that defines the types and structures for observer conditions.<p>Key components:<ol><li><p><strong><code>ObserverCondition</code> struct</strong> wraps a boxed condition system:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>ObserverCondition </span><span>{
</span><span>    condition</span><span style=color:#61676ccc>:</span><span> BoxedCondition,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>ObserverCondition </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>check</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>:</span><span> UnsafeWorldCell) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>        </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>condition</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_unsafe</span><span>(()</span><span style=color:#61676ccc>,</span><span> world) }</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>false</span><span>)
</span><span>    }
</span><span>}
</span></code></pre><li><p><strong><code>ObserverWithCondition</code> struct</strong> is the typed wrapper returned by <code>.run_if()</code>:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ObserverWithCondition</span><span>&LTE</span><span style=color:#61676ccc>:</span><span> Event, B</span><span style=color:#61676ccc>:</span><span> Bundle, M, S</span><span style=color:#61676ccc>: </span><span>IntoObserverSystem&LTE, B, M>> {
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) system</span><span style=color:#61676ccc>:</span><span> S,
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) conditions</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTBoxedCondition>,
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) _marker</span><span style=color:#61676ccc>: </span><span>PhantomData<</span><span style=color:#fa6e32>fn</span><span>() </span><span style=color:#61676ccc>-> </span><span>(E, B, M)>,
</span><span>}
</span></code></pre><li><p><strong><code>ObserverSystemExt</code> trait</strong> provides the <code>.run_if()</code> method:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>ObserverSystemExt</span><span>&LTE: Event, B: Bundle, M>: IntoObserverSystem&LTE, B, M> + Sized {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>run_if</span><span>&LTC, CM>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>condition</span><span style=color:#61676ccc>:</span><span> C) </span><span style=color:#61676ccc>-> </span><span>ObserverWithCondition&LTE, B, M, </span><span style=color:#fa6e32>Self</span><span>>
</span><span>    </span><span style=color:#fa6e32>where
</span><span>        C</span><span style=color:#61676ccc>: </span><span>SystemCondition&LTCM>,
</span><span>}
</span></code></pre></ol><h3 id=crates-bevy-ecs-src-observer-runner-rs-15-0><code>crates/bevy_ecs/src/observer/runner.rs</code> (+15/-0)</h3><p>The observer runner was updated to check conditions before executing the observer.<p>Key modification:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Check all conditions before running the observer
</span><span style=color:#fa6e32>let mut</span><span> should_run </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>for</span><span> condition </span><span style=color:#ed9366>in</span><span> state</span><span style=color:#ed9366>.</span><span>conditions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>    should_run </span><span style=color:#ed9366>&= </span><span style=color:#fa6e32>unsafe </span><span>{ condition</span><span style=color:#ed9366>.</span><span style=color:#f07171>check</span><span>(world) }</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>should_run {
</span><span>    </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=examples-ecs-observers-rs-32-7><code>examples/ecs/observers.rs</code> (+32/-7)</h3><p>The example was updated to demonstrate observer run conditions with a Space key toggle.<p>Key changes:<ol><li><strong>Added <code>ExplosionsEnabled</code> resource</strong> to control whether explosions should occur.<li><strong>Added <code>toggle_explosions</code> system</strong> that toggles the resource when Space is pressed.<li><strong>Modified observer</strong> to use <code>.run_if()</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(
</span><span>    (|</span><span style=color:#ff8f40>explode_mines</span><span style=color:#61676ccc>: </span><span>On&LTExplodeMines></span><span style=color:#61676ccc>,</span><span> /* ... */| {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Observer logic
</span><span>    })
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(|</span><span style=color:#ff8f40>enabled</span><span style=color:#61676ccc>: </span><span>Res&LTExplosionsEnabled>| enabled</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>,
</span><span>)
</span></code></pre></ol><h3 id=other-files>Other files</h3><ul><li><strong><code>crates/bevy_app/src/app.rs</code></strong>: Updated <code>App::add_observer()</code> to use <code>IntoObserver</code> trait.<li><strong><code>crates/bevy_ecs/src/system/commands/mod.rs</code></strong>: Updated command APIs to use <code>IntoObserver</code> and <code>IntoEntityObserver</code> traits.<li><strong><code>crates/bevy_ecs/src/world/entity_access/world_mut.rs</code></strong>: Updated <code>EntityWorldMut::observe()</code> to use <code>IntoEntityObserver</code>.<li><strong><code>release-content/release-notes/observer_run_conditions.md</code></strong>: Added release notes documenting the new feature.</ul><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy Observer Documentation</strong>: The <a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/observer/index.html target=_blank>official Bevy observer documentation</a> provides comprehensive information about observers.<li><strong>System Conditions</strong>: Understanding <a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/schedule/trait.SystemCondition.html target=_blank>Bevy’s system conditions</a> helps in writing effective observer conditions.<li><strong>Entity Events</strong>: The <a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/event/trait.EntityEvent.html target=_blank><code>EntityEvent</code> trait documentation</a> explains how entity-specific events work.<li><strong>Original Issues</strong>: Issues <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/14195 target=_blank>#14195</a> and <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/21442 target=_blank>#21442</a> provide context about the need for observer run conditions.<li><strong>Bevy ECS Architecture</strong>: The <a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/programming/ecs-intro.html target=_blank>Bevy ECS architecture guide</a> offers a broader understanding of how observers fit into Bevy’s ECS model.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22602.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>