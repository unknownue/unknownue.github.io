diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index 7f4a70321c5b3..de65c0cc44153 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -74,7 +74,9 @@ pub mod prelude {
         event::{EntityEvent, Event},
         hierarchy::{ChildOf, ChildSpawner, ChildSpawnerCommands, Children},
         lifecycle::{Add, Despawn, Insert, Remove, RemovedComponents, Replace},
-        message::{Message, MessageMutator, MessageReader, MessageWriter, Messages},
+        message::{
+            Message, MessageMutator, MessageReader, MessageWriter, Messages, PopulatedMessageReader,
+        },
         name::{Name, NameOrEntity},
         observer::{Observer, On},
         query::{Added, Allow, AnyOf, Changed, Has, Or, QueryBuilder, QueryState, With, Without},
diff --git a/crates/bevy_ecs/src/message/message_reader.rs b/crates/bevy_ecs/src/message/message_reader.rs
index e42b4131385fd..c53e044fcb000 100644
--- a/crates/bevy_ecs/src/message/message_reader.rs
+++ b/crates/bevy_ecs/src/message/message_reader.rs
@@ -2,11 +2,13 @@
 use crate::message::MessageParIter;
 use crate::{
     message::{Message, MessageCursor, MessageIterator, MessageIteratorWithId, Messages},
-    system::{Local, Res, SystemParam},
+    system::{Local, Res, SystemParam, SystemParamValidationError},
 };
 
 /// Reads [`Message`]s of type `T` in order and tracks which messages have already been read.
 ///
+/// Use [`PopulatedMessageReader<T>`] to skip the system if there are no messages.
+///
 /// # Concurrency
 ///
 /// Unlike [`MessageWriter<T>`], systems with `MessageReader<T>` param can be executed concurrently
@@ -113,3 +115,124 @@ impl<'w, 's, M: Message> MessageReader<'w, 's, M> {
         self.reader.clear(&self.messages);
     }
 }
+
+/// Reads [`Message`]s of type `T` in order and tracks which messages have already been read.
+/// Skips the system if there no messages.
+///
+/// Use [`MessageReader<T>`] to run the system even if there are no messages.
+///
+/// Use the [`on_message`](crate::prelude::on_message) run condition to skip the system based on messages that it doesn't read.
+#[derive(Debug)]
+pub struct PopulatedMessageReader<'w, 's, M: Message>(MessageReader<'w, 's, M>);
+
+impl<'w, 's, M: Message> core::ops::Deref for PopulatedMessageReader<'w, 's, M> {
+    type Target = MessageReader<'w, 's, M>;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
+    }
+}
+
+impl<'w, 's, M: Message> core::ops::DerefMut for PopulatedMessageReader<'w, 's, M> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.0
+    }
+}
+
+// SAFETY: relies on MessageReader to uphold soundness requirements
+unsafe impl<'w, 's, M: Message> SystemParam for PopulatedMessageReader<'w, 's, M> {
+    type State = <MessageReader<'w, 's, M> as SystemParam>::State;
+    type Item<'world, 'state> = PopulatedMessageReader<'world, 'state, M>;
+
+    fn init_state(world: &mut crate::prelude::World) -> Self::State {
+        MessageReader::<M>::init_state(world)
+    }
+
+    fn init_access(
+        state: &Self::State,
+        system_meta: &mut crate::system::SystemMeta,
+        component_access_set: &mut crate::query::FilteredAccessSet,
+        world: &mut crate::prelude::World,
+    ) {
+        MessageReader::<M>::init_access(state, system_meta, component_access_set, world);
+    }
+
+    unsafe fn get_param<'world, 'state>(
+        state: &'state mut Self::State,
+        system_meta: &crate::system::SystemMeta,
+        world: crate::world::unsafe_world_cell::UnsafeWorldCell<'world>,
+        change_tick: crate::change_detection::Tick,
+    ) -> Self::Item<'world, 'state> {
+        // SAFETY: requirements are upheld by MessageReader's implementation
+        unsafe {
+            PopulatedMessageReader(MessageReader::get_param(
+                state,
+                system_meta,
+                world,
+                change_tick,
+            ))
+        }
+    }
+
+    unsafe fn validate_param(
+        state: &mut Self::State,
+        system_meta: &crate::system::SystemMeta,
+        world: crate::world::unsafe_world_cell::UnsafeWorldCell,
+    ) -> Result<(), SystemParamValidationError> {
+        // SAFETY: requirements are upheld by MessageReader's implementation
+        unsafe { MessageReader::<M>::validate_param(state, system_meta, world) }?;
+
+        // SAFETY: requirements are upheld by MessageReader's implementation
+        let reader =
+            unsafe { MessageReader::get_param(state, system_meta, world, world.change_tick()) };
+        if reader.is_empty() {
+            Err(SystemParamValidationError::skipped::<Self>(
+                "message queue is empty",
+            ))
+        } else {
+            Ok(())
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use core::sync::atomic::{AtomicBool, Ordering};
+
+    use super::*;
+    use crate::message::MessageRegistry;
+    use crate::prelude::*;
+    use bevy_platform::sync::Arc;
+
+    #[test]
+    fn test_populated_message_reader() {
+        let system_ran = Arc::new(AtomicBool::new(false));
+
+        let mut world = World::new();
+        MessageRegistry::register_message::<TheMessage>(&mut world);
+
+        let mut schedule = Schedule::default();
+        schedule.add_systems({
+            let system_ran = system_ran.clone();
+            move |mut _reader: PopulatedMessageReader<TheMessage>| {
+                system_ran.store(true, Ordering::SeqCst);
+            }
+        });
+
+        schedule.run(&mut world);
+        assert!(
+            !system_ran.load(Ordering::SeqCst),
+            "system with PopulatedMessageReader should have been skipped"
+        );
+
+        world.write_message(TheMessage);
+        schedule.run(&mut world);
+        assert!(
+            system_ran.load(Ordering::SeqCst),
+            "system with PopulatedMessageReader should NOT have been skipped"
+        );
+
+        #[derive(Message)]
+        struct TheMessage;
+    }
+}
diff --git a/crates/bevy_ecs/src/schedule/condition.rs b/crates/bevy_ecs/src/schedule/condition.rs
index 4d42a6a307737..1bb39c529f944 100644
--- a/crates/bevy_ecs/src/schedule/condition.rs
+++ b/crates/bevy_ecs/src/schedule/condition.rs
@@ -828,6 +828,8 @@ pub mod common_conditions {
     /// A [`SystemCondition`]-satisfying system that returns `true`
     /// if there are any new messages of the given type since it was last called.
     ///
+    /// To skip a system based on messages that it reads, use [`PopulatedMessageReader`](crate::prelude::PopulatedMessageReader) instead.
+    ///
     /// # Example
     ///
     /// ```
