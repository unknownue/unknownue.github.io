<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22972 `FontSmoothing::None` pixel alignment fix
        
    </title><meta content="#22972 `FontSmoothing::None` pixel alignment fix" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-17</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-22972-en-20260217>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: <code>FontSmoothing::None</code> pixel alignment fix<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22972<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, S-Ready-For-Final-Review, P-Regression, A-Text, D-Straightforward, M-Deliberate-Rendering-Change<li><strong>Created</strong>: 2026-02-16T00:48:05Z<li><strong>Merged</strong>: 2026-02-17T01:47:20Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h3 id=mu-de>目的</h3><p>当使用 <code>FontSmoothing::None</code> 时，<code>update_text_layout_info</code> 会对每个字形（glyph）最终的对象中心（object-centered）位置进行四舍五入（round）。如果字形的大小为奇数，这会破坏像素对齐（pixel alignment）。<p>修复问题 #22975<h3 id=jie-jue-fang-an>解决方案</h3><p>在我们将坐标转换为对象中心坐标之前，首先对从 Parley 布局得到的基于角落（corner-based）的字形位置进行向下取整（floor）。<h4 id=ju-ti-shi-li>具体示例</h4><ol><li>Parley 返回一个基于左上角的字形矩形： <code>left = 100, top = 50, width = 15, height = 18</code><li>UI 渲染器期望字形坐标是对象中心的，因此我们加上一半的尺寸来得到字形的对象中心位置。所以字形的水平中心将在： <code>x = left + width / 2 = 100 + 7.5 = 107.5</code><li>这是像素对齐的，因为如果我们再减去一半的尺寸，就可以得到 <code>left</code> 边缘的位置。<li>但是，如果我们对对象中心位置向下取整 <code>x' = floor(x) = 107</code>。这将字形精灵（sprite）的左边缘移动到了一个亚像素（subpixel）位置： <code>left' = x' - width / 2 = 107 - 7.5 = 99.5</code><li>在 y 轴上没有亚像素问题，因为高度可以被 2 整除。</ol><h3 id=ce-shi>测试</h3><p>如果仔细比较 <code>test_bed_ui</code> 中 <code>text</code> 场景的输出，改进是相当明显的：<h4 id=main-zhu-fen-zhi>main（主分支）</h4><img alt=smooth-broke src=https://github.com/user-attachments/assets/f3d352ab-db9d-4db1-9f4e-2cad06e0563f width=548><h4 id=ben-pr>本 PR</h4><img alt=smooth-fix src=https://github.com/user-attachments/assets/ef5700eb-fef3-4af5-ba21-19ed85335e19 width=528><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这是一个关于渲染管线中一个微妙但重要bug的修复故事，涉及坐标空间转换和取整操作的顺序问题。<p>问题始于一个回归（regression），当开发者将文本的 <code>FontSmoothing</code> 设置为 <code>None</code> 时，期望得到清晰、像素对齐的文本，但实际渲染结果却出现了模糊或错位的字形。标签 <code>P-Regression</code> 和 <code>C-Bug</code> 明确指出了这一点。问题的核心在于 <code>bevy_text</code> 管线中处理字形定位的逻辑存在缺陷。<p>具体来说，文本布局引擎 Parley 输出的字形位置是基于其边界矩形的左上角（top-left corner）的。然而，Bevy 的 UI 渲染器内部使用的是对象中心（object-centered）坐标系，即位置代表精灵的中心点。因此，代码需要进行一次坐标转换：将角落坐标加上字形尺寸的一半，以得到中心坐标。<p>当 <code>FontSmoothing</code> 为 <code>None</code> 时，为了实现像素级锐利渲染，代码需要对最终位置进行取整（round），以确保其落在整数像素上。这里的 bug 在于<strong>取整操作的时机错了</strong>。原始代码在完成从“角落坐标”到“中心坐标”的转换<em>之后</em>，才对中心坐标进行 <code>round</code>。这导致了一个问题：对于一个宽度为奇数的字形，其中心坐标可能是一个像 <code>107.5</code> 这样的半像素值。<code>round(107.5)</code> 得到 <code>108.0</code>。当渲染器用这个中心坐标 <code>108.0</code> 减去半宽（例如 <code>7.5</code>）来重新计算用于实际绘制的左上角时，得到的是 <code>100.5</code>。这个亚像素（subpixel）位置就是导致渲染模糊的根本原因。<p>解决方案在概念上很清晰：为了确保最终的渲染位置是像素对齐的，必须在进行可能导致非整数结果的运算<em>之前</em>，就将基础坐标固定到整数像素网格上。开发者将取整操作从坐标转换链的末端移到了前端。<p>具体实现是，不再单独计算 <code>x</code> 和 <code>y</code> 然后对它们取整，而是直接构建一个 <code>glyph_pos</code> 向量（<code>Vec2::new(glyph.x, glyph.y)</code>）。然后，在将其与半尺寸和偏移量相加之前，先根据 <code>font_smoothing</code> 的设置进行条件处理：如果是 <code>FontSmoothing::None</code>，则使用 <code>glyph_pos.floor()</code>；否则使用原始的 <code>glyph_pos</code>。这个 <code>floor</code> 操作（对比之前的 <code>round</code>）确保了字形的基础定位点被牢牢锁定在像素网格上，后续的任何加法运算（包括加上半尺寸）都会从这个稳固的整数基础开始，从而保证最终渲染的左上角坐标也是整数。<p>从工程角度看，这个修复是精准且最小化的。它没有改变管线的基本流程或数据结构，只是修正了计算顺序和取整函数的选用（<code>floor</code> 确保了向下对齐，对于从左上角开始的坐标系是合适的）。修改集中在一处，<code>+11/-11</code> 的代码行变化也体现了这一点。附带的测试截图直观地证明了修复的有效性：文本的锐利度和整体渲染质量得到了显著提升。这个案例很好地说明了在图形渲染中，数学精度和操作顺序的极端重要性，一个看似简单的取整操作放错了地方，就会直接损害视觉保真度。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Parley 布局引擎] -->|输出 corner-based&LTbr/>glyph rect| B[`update_text_layout_info`]
</span><span>    B --> C{`FontSmoothing::None`?}
</span><span>    C -->|是| D[对 glyph_pos 进行 floor 操作]
</span><span>    C -->|否| E[使用原始 glyph_pos]
</span><span>    D --> F[加上 glyph_size/2 和 offset&LTbr/>转换为 object-centered 坐标]
</span><span>    E --> F
</span><span>    F --> G[生成 PositionedGlyph&LTbr/>传递给渲染器]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><p><strong>crates/bevy_text/src/pipeline.rs</strong> (+11/-11)<p>这个文件包含了文本渲染管线的核心逻辑。修改发生在 <code>update_text_layout_info</code> 函数中，该函数负责将 Parley 布局引擎的输出转换为 Bevy 渲染器所需的 <code>PositionedGlyph</code> 数据。<p><strong>关键修改：</strong> 修改的核心是重组了计算 <code>PositionedGlyph.position</code> 的数学公式，将像素对齐的取整操作从计算链的末端移到了起始端。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前（存在bug的逻辑）：
</span><span style=color:#fa6e32>let</span><span> glyph_size </span><span style=color:#ed9366>= </span><span>UVec2</span><span style=color:#ed9366>::</span><span>new(glyph_rect</span><span style=color:#ed9366>.</span><span style=color:#f07171>width</span><span>()</span><span style=color:#61676ccc>,</span><span> glyph_rect</span><span style=color:#ed9366>.</span><span style=color:#f07171>height</span><span>())</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let mut</span><span> x </span><span style=color:#ed9366>=</span><span> glyph_size</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32 </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0 </span><span style=color:#ed9366>+</span><span> glyph</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>+</span><span> location</span><span style=color:#ed9366>.</span><span>offset</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let mut</span><span> y </span><span style=color:#ed9366>=</span><span> glyph_size</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32 </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0 </span><span style=color:#ed9366>+</span><span> glyph</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>-</span><span> location</span><span style=color:#ed9366>.</span><span>offset</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>if</span><span> font_smoothing </span><span style=color:#ed9366>== </span><span>FontSmoothing</span><span style=color:#ed9366>::</span><span>None {
</span><span>    x </span><span style=color:#ed9366>=</span><span> x</span><span style=color:#ed9366>.</span><span style=color:#f07171>round</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 在中心坐标上取整，为bug来源
</span><span>    y </span><span style=color:#ed9366>=</span><span> y</span><span style=color:#ed9366>.</span><span style=color:#f07171>round</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span><span>layout_info</span><span style=color:#ed9366>.</span><span>glyphs</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(PositionedGlyph {
</span><span>    position</span><span style=color:#61676ccc>: </span><span>Vec2</span><span style=color:#ed9366>::</span><span>new(x</span><span style=color:#61676ccc>,</span><span> y)</span><span style=color:#61676ccc>,
</span><span>    size</span><span style=color:#61676ccc>:</span><span> glyph_size</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_vec2</span><span>()</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后（修复后的逻辑）：
</span><span style=color:#fa6e32>let</span><span> glyph_size </span><span style=color:#ed9366>= </span><span>UVec2</span><span style=color:#ed9366>::</span><span>new(glyph_rect</span><span style=color:#ed9366>.</span><span style=color:#f07171>width</span><span>()</span><span style=color:#61676ccc>,</span><span> glyph_rect</span><span style=color:#ed9366>.</span><span style=color:#f07171>height</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_vec2</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> glyph_pos </span><span style=color:#ed9366>= </span><span>Vec2</span><span style=color:#ed9366>::</span><span>new(glyph</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>,</span><span> glyph</span><span style=color:#ed9366>.</span><span>y)</span><span style=color:#61676ccc>;
</span><span>layout_info</span><span style=color:#ed9366>.</span><span>glyphs</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(PositionedGlyph {
</span><span>    position</span><span style=color:#61676ccc>:</span><span> glyph_size </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.
</span><span>        </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>if</span><span> font_smoothing </span><span style=color:#ed9366>== </span><span>FontSmoothing</span><span style=color:#ed9366>::</span><span>None {
</span><span>            glyph_pos</span><span style=color:#ed9366>.</span><span style=color:#f07171>floor</span><span>() </span><span style=color:#abb0b6;font-style:italic>// 先在原始角落坐标上取整
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            glyph_pos
</span><span>        }
</span><span>        </span><span style=color:#ed9366>+</span><span> location</span><span style=color:#ed9366>.</span><span>offset</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_vec2</span><span>() </span><span style=color:#ed9366>* </span><span>Vec2</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>1.</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1.</span><span>)</span><span style=color:#61676ccc>,
</span><span>    size</span><span style=color:#61676ccc>:</span><span> glyph_size</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>关系说明：</strong> 这项修改直接解决了 PR 描述中概述的像素对齐问题。通过先对从布局引擎得到的原始 <code>glyph_pos</code>（角落坐标）进行 <code>floor</code> 操作，确保了后续所有计算都基于一个像素对齐的起点，从而最终渲染出的字形边界也能精确落在像素网格上。这是修复 <code>FontSmoothing::None</code> 模式下文本渲染模糊问题的根本所在。<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy 官方文档 - 文本（Text）</strong>：了解 Bevy 中文本渲染的基本组件和用法。<li><strong>像素对齐（Pixel Alignment）</strong> 在计算机图形学中的重要性，特别是在 2D UI 和字体渲染中，这是保证清晰度的关键技术。<li><strong>坐标空间变换</strong> 的概念，理解如何在不同的坐标系（如世界坐标、局部坐标、屏幕坐标、纹理坐标）之间进行转换是图形编程的基础。<li><strong>关于“亚像素渲染（Subpixel Rendering）”</strong> 的讨论，这与本 PR 的 <code>FontSmoothing::None</code>（即关闭亚像素平滑）形成对比，有助于理解不同字体平滑技术的取舍。</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22972.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>