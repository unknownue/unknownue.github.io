<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23036 Implement GPU clustering for lights, light probes, and decals
        
    </title><meta content="#23036 Implement GPU clustering for lights, light probes, and decals" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-28</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-23036-zh-cn-20260228>中文</a></div></div><div class=pr-content><h1 id=title-implement-gpu-clustering-for-lights-light-probes-and-decals>Title: Implement GPU clustering for lights, light probes, and decals</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Implement GPU clustering for lights, light probes, and decals.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/23036<li><strong>Author</strong>: pcwalton<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review, M-Release-Note<li><strong>Created</strong>: 2026-02-18T06:30:21Z<li><strong>Merged</strong>: 2026-02-28T17:36:54Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Currently, Bevy clusters lights on the CPU. This is generally not considered a best practice any longer, and it can be a bottleneck in workloads like <code>many_lights</code>. Moreover, it prevents GPU systems like <a rel="noopener nofollow noreferrer" href=https://github.com/djeedai/bevy_hanabi target=_blank>Hanabi</a> from creating clusterable objects such as lights and decals without a round trip to the CPU.<p>This PR introduces GPU light clustering when supported by the hardware. The algorithm is the same as the existing GPU light clustering, but parallelized over all clusters, and the resulting on-GPU format for clusters is unchanged. GPU light clustering uses the hardware rasterizer for compute purposes as a way to automatically distribute workloads within 2D axis-aligned bounding boxes without actually rendering any pixels, a first for Bevy. The algorithm is as follows, with each step corresponding to a raster or compute command:<ol><li><p><em>Z slicing</em>: We have a 3D cluster froxel grid of size WxHxD and seek to rasterize D axis-aligned quads, each of size WxH, representing the range of each clusterable object. In this compute phase, we generate D indirect instances for each clusterable object for the subsequent indirect draws.</p><li><p><em>Count rasterization</em>: We use instanced indirect drawing to rasterize each quad generated in step 1 to a viewport of size WxH, with color writes disabled. Each rasterized fragment represents a cluster-object pair. In the fragment shader, we check to see if the object intersects the cluster, and, if it does, we atomically bump a counter corresponding to the number of objects of the given type intersecting the cluster in question. We don’t record the ID of the object in this phase; we simply count the number of objects.</p><li><p><em>Local allocation</em>: Now that we know the number of objects of each type in each cluster, we can proceed to allocate space in the clustered object buffer for each clustered object list. To do this, we need to perform a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Prefix_sum target=_blank><em>prefix sum</em></a> operation so that each list is tightly packed with the others. For example, if adjacent clusters have 2, 5, and 3 objects, they’ll be allocated at offsets 0, 2, and 7 respectively. This <em>local</em> step uses a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Prefix_sum#Algorithm_1:_Shorter_span,_more_parallel target=_blank>Hillis-Steele scan</a> in shared memory to compute the prefix sum of each chunk of 256 clusters. We can’t go beyond 256 clusters in this local step because 256 is the maximum workgroup size in <code>wgpu</code>.</p><li><p><em>Global allocation</em>: To deal with the fact that we can’t calculate prefix sums beyond 256 clusters in step 3, we employ this second step that does a sequential loop over every 256-cluster chunk, propagating the prefix sum. At the end of this step, every list of clustered objects is allocated.</p><li><p><em>Populate rasterization</em>: Finally, we issue an instanced indirect draw command using the same parameters as step (2). We test each cluster-object pair for intersection, and, if the test passes, we record the ID of each clustered object into the correct space in the list, using a scratch pad buffer of atomics to store the position of the next object in each list.</p></ol><p>The buffer of clustered objects has a fixed size and can overflow. We detect this condition via asynchronous CPU readback and automatically grow the buffer for subsequent frames. In this case, we also log a warning so that the developer can choose a larger initial buffer size and avoid any incorrect frames. Additionally, like #22874, the automatic clustering heuristics are dynamically adjusted from frame to frame, by recording statistics on the GPU and using CPU readback to download them back to the CPU for processing.<p>As part of this PR, I refactored clustered visibility so that clustered objects go through the same <code>ViewVisibility</code> system as other objects, instead of using <code>VisibleClusterableObjects</code>. This was a nice simplification.<p>On the <code>many_lights</code> benchmark, with about 8,000 lights visible out of 100,000, this process takes approximately 0.099 ms on my NVIDIA GeForce RTX 4070 Laptop GPU. The AMD Ryzen 9 8945HS CPU, however, takes 2.12 ms to do the same task. The GPU version is therefore a 21x speedup.<p><code>main</code> <code>assign_objects_to_clusters</code> time, 2.12 ms: <img alt="CPU clustering time" src=https://github.com/user-attachments/assets/66341ad2-96f2-4e4a-87ee-fe3462bc05de><p>GPU clustering GPU time, 0.099 ms: <img alt="GPU clustering time" src=https://github.com/user-attachments/assets/18e2e0ae-a946-4b80-b38a-0543e76ebc02><p><code>main</code>, 5.71 ms median frame time, 175 FPS: <img alt="CPU clustering frame time" src=https://github.com/user-attachments/assets/111c8e22-414f-4ee1-95fa-d7cfe422c2ab><p>GPU clustering, 4.88 ms median frame time, 205 FPS: <img alt="GPU clustering frame time" src=https://github.com/user-attachments/assets/0a662e88-a1b9-49c8-8bab-cc12b46cd079><h2 id=alice-s-pm-note-from-kfc35>Alice’s PM Note from @kfc35</h2><p>Fixes https://github.com/bevyengine/bevy/issues/22957 and also fixes https://github.com/bevyengine/bevy/issues/22904.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>Bevy’s rendering engine uses clustered forward rendering to efficiently determine which lights, light probes, and decals affect each region (cluster) of the screen. Before this PR, Bevy performed this clustering entirely on the CPU. While functional, this approach had several significant limitations:<ol><li><strong>Performance bottleneck</strong>: CPU-based clustering was a measurable performance cost, particularly in scenes with many lights (like the <code>many_lights</code> benchmark).<li><strong>Architectural constraint</strong>: Systems that run entirely on the GPU (like particle effects from the Hanabi library) couldn’t create lights or decals that participate in clustering without expensive CPU round trips.<li><strong>Algorithmic complexity</strong>: The CPU algorithm used iterative sphere refinement, which is complex and inherently sequential, making it difficult to parallelize effectively.</ol><p>The CPU clustering implementation was also architecturally complex, using a separate <code>VisibleClusterableObjects</code> component to track which clusterable objects were visible to each view.<h3 id=the-solution-approach>The Solution Approach</h3><p>The developer implemented GPU-based clustering using a five-step algorithm that leverages the hardware rasterizer as a compute mechanism. This approach is novel for Bevy - using the rasterizer not to draw pixels, but to efficiently schedule compute work across 2D axis-aligned bounding boxes.<p>The solution includes several key engineering decisions:<ol><li><strong>Hardware compatibility</strong>: The system automatically detects whether GPU clustering is supported (requires storage buffers and compute shaders) and falls back to CPU clustering when necessary.<li><strong>Buffer management</strong>: Dynamic buffer resizing with asynchronous CPU readback handles overflow conditions gracefully.<li><strong>Architecture simplification</strong>: The PR refactors the clustered visibility system to use the existing <code>ViewVisibility</code> system instead of the custom <code>VisibleClusterableObjects</code> component.<li><strong>Algorithm design</strong>: The five-step algorithm (Z slicing, count rasterization, local allocation, global allocation, populate rasterization) balances parallelism with workgroup size limitations.</ol><h3 id=the-implementation>The Implementation</h3><p>The implementation adds approximately 2,600 lines of new code across 19 files, with the core logic in:<ol><li><strong><code>gpu.rs</code></strong>: Contains the main GPU clustering implementation with the five-step algorithm.<li><strong>Three new WGSL shaders</strong>: Handle Z slicing, rasterization, and allocation.<li><strong>Modified CPU clustering</strong>: Now conditionally runs only when GPU clustering is disabled.</ol><p>The GPU clustering system integrates with Bevy’s existing rendering architecture by:<ol><li><strong>Extraction phase</strong>: When GPU clustering is enabled, the system extracts cluster configurations but doesn’t run CPU clustering.<li><strong>Preparation phase</strong>: Creates and uploads necessary buffers (Z slices, metadata, scratchpad).<li><strong>Rendering phase</strong>: Executes the five-step algorithm via compute and raster passes.<li><strong>Readback phase</strong>: Asynchronously reads statistics back to CPU for dynamic adjustment.</ol><p>A key insight is how the rasterizer is used for compute: by setting up a viewport matching the cluster grid dimensions (W×H) and drawing axis-aligned quads for each Z slice, each fragment shader invocation naturally corresponds to a specific cluster-object pair. Color writes are disabled since we’re only using the rasterizer for fragment scheduling.<h3 id=technical-insights>Technical Insights</h3><p><strong>Prefix Sum Implementation</strong>: The allocation phase requires a prefix sum to pack cluster lists contiguously. Due to wgpu’s 256 workgroup size limit, this uses a two-pass approach:<ul><li>Local pass: Hillis-Steele scan over 256-cluster chunks<li>Global pass: Sequential propagation across chunks</ul><p><strong>Buffer Overflow Handling</strong>: The system detects when buffers are too small via GPU→CPU readback and automatically resizes them, logging warnings to guide developers in choosing appropriate initial sizes.<p><strong>Simplified Visibility</strong>: By using <code>ViewVisibility</code> instead of <code>VisibleClusterableObjects</code>, clusterable objects now participate in Bevy’s standard visibility system. This removes custom code paths and makes the system more consistent.<p><strong>Performance Characteristics</strong>: The implementation achieves a 21× speedup (0.099 ms vs 2.12 ms) on the <code>many_lights</code> benchmark. This improvement comes from both algorithmic changes (parallel vs sequential) and hardware utilization (GPU compute units vs CPU cores).<h3 id=the-impact>The Impact</h3><p><strong>Performance</strong>: Significant reduction in clustering time (21× faster) translates to measurable frame time improvements (5.71 ms → 4.88 ms median frame time in the benchmark).<p><strong>Architectural improvements</strong>:<ul><li>Removed the <code>VisibleClusterableObjects</code> component and associated complexity<li>Unified clusterable object visibility with the standard <code>ViewVisibility</code> system<li>Enabled GPU systems to create clusterable objects without CPU intervention</ul><p><strong>Feature enablement</strong>: GPU systems like Hanabi can now create lights and decals that participate in clustering directly on the GPU.<p><strong>Developer experience</strong>: Automatic buffer resizing with clear warning messages helps developers understand when to adjust buffer capacities.<p>The implementation maintains backward compatibility by automatically detecting hardware support and falling back to CPU clustering when GPU clustering isn’t available. This ensures the feature works across Bevy’s supported platforms while providing optimal performance on capable hardware.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Clusterable Objects&LTbr/>(Lights, Probes, Decals)] --> B[Z Slicing Compute Pass]
</span><span>    B --> C[Count Rasterization Pass]
</span><span>    C --> D[Local Allocation Compute Pass]
</span><span>    D --> E[Global Allocation Compute Pass]
</span><span>    E --> F[Populate Rasterization Pass]
</span><span>    F --> G[Clustered Index Lists]
</span><span>    
</span><span>    H[View Configuration] --> I[Cluster Grid Setup]
</span><span>    I --> C
</span><span>    I --> F
</span><span>    
</span><span>    J[Statistics Readback] --> K[Dynamic Buffer Resizing]
</span><span>    K --> B
</span><span>    K --> D
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-pbr-src-cluster-gpu-rs-1714-0><code>crates/bevy_pbr/src/cluster/gpu.rs</code> (+1714/-0)</h3><p><strong>Purpose</strong>: Implements the core GPU clustering algorithm and plugin.<p><strong>Key changes</strong>:<ul><li>New <code>GpuClusteringPlugin</code> that conditionally enables GPU clustering<li>Five-step algorithm implementation (z_slice_main, allocate_local_main, allocate_global_main, vertex_main, fragment_main)<li>Buffer management with automatic resizing via CPU readback<li>Integration with Bevy’s rendering systems</ul><p><strong>Code snippet showing the main clustering function</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// The render command building system that performs GPU clustering on each
</span><span style=color:#abb0b6;font-style:italic>/// view.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>cluster_on_gpu</span><span>(
</span><span>    </span><span style=color:#ff8f40>view_query</span><span style=color:#61676ccc>: </span><span>ViewQuery<(
</span><span>        </span><span style=color:#ed9366>&</span><span>MainEntity,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ViewGpuClusteringBuffers>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ViewGpuClusteringPipelineIds>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ViewClusteringDummyTexture>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ViewClusteringBindGroups>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ViewLightProbesUniformOffset>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ViewLightsUniformOffset>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ViewUniformOffset>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ExtractedClusterConfig>,
</span><span>    )>,
</span><span>    </span><span style=color:#ff8f40>pipeline_cache</span><span style=color:#61676ccc>: </span><span>Res&LTPipelineCache>,
</span><span>    </span><span style=color:#ff8f40>clustering_mesh_buffers</span><span style=color:#61676ccc>: </span><span>Res&LTGpuClusteringMeshBuffers>,
</span><span>    </span><span style=color:#ff8f40>render_view_clustering_readback_data</span><span style=color:#61676ccc>: </span><span>Res&LTRenderViewClusteringReadbackData>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>render_context</span><span style=color:#61676ccc>:</span><span> RenderContext,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... setup and validation
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 1: Z slicing.
</span><span>    </span><span style=color:#f07171>run_clustering_z_slicing_pass</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 2: Count raster.
</span><span>    </span><span style=color:#f07171>run_clustering_rasterization_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 3: local allocation.
</span><span>    </span><span style=color:#f07171>run_clustering_allocation_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 4: global allocation.
</span><span>    </span><span style=color:#f07171>run_clustering_allocation_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 5: populate raster.
</span><span>    </span><span style=color:#f07171>run_clustering_rasterization_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Schedule readback for statistics
</span><span>    </span><span style=color:#f07171>schedule_readback_staging</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>schedule_readback_buffer_map</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-light-src-cluster-assign-rs-463-485><code>crates/bevy_light/src/cluster/assign.rs</code> (+463/-485)</h3><p><strong>Purpose</strong>: Modified CPU clustering to conditionally run only when GPU clustering is disabled.<p><strong>Key changes</strong>:<ul><li>Added check for <code>global_cluster_settings.gpu_clustering.is_none()</code> before running CPU clustering<li>Removed <code>VisibleClusterableObjects</code> usage in favor of <code>ViewVisibility</code><li>Simplified query structures to use <code>ViewVisibility</code> component</ul><p><strong>Code snippet showing the conditional logic</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Collect clusterable objects if GPU clustering is enabled.
</span><span style=color:#fa6e32>if</span><span> global_cluster_settings</span><span style=color:#ed9366>.</span><span>gpu_clustering</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... CPU clustering logic
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-cluster-cluster-raster-wgsl-525-0><code>crates/bevy_pbr/src/cluster/cluster_raster.wgsl</code> (+525/-0)</h3><p><strong>Purpose</strong>: Shader for count and populate rasterization passes.<p><strong>Key changes</strong>:<ul><li>Fragment shader tests sphere-AABB intersection for cluster-object pairs<li>Two versions: count pass (atomic increments) and populate pass (writes indices)<li>Includes spot light cone culling logic</ul><p><strong>Code snippet showing intersection test</strong>:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// See if the object sphere intersects the AABB. If it doesn't, cull the
</span><span>// object.
</span><span>let object_intersects_cluster_aabb = sphere_intersects_aabb(
</span><span>    varyings.sphere_position,
</span><span>    varyings.sphere_radius,
</span><span>    cluster_aabb_center,
</span><span>    cluster_aabb_half_size
</span><span>);
</span><span>if (!object_intersects_cluster_aabb) {
</span><span>    return vec4&LTf32>(0.0);
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-cluster-mod-rs-173-46><code>crates/bevy_pbr/src/cluster/mod.rs</code> (+173/-46)</h3><p><strong>Purpose</strong>: Updated cluster module to support both CPU and GPU clustering.<p><strong>Key changes</strong>:<ul><li>Added <code>ClusterableObjects</code> enum to track whether clustering is CPU or GPU<li>Modified <code>Clusters</code> struct to use <code>ClusterableObjects</code> instead of direct <code>Vec</code><li>Added GPU clustering constants and helper functions</ul><p><strong>Code snippet showing the new enum</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// The list of objects within a cluster, if known to the CPU.
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>ClusterableObjects </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// The list of objects in the cluster is known to the CPU.
</span><span>    Cpu(</span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTObjectsInClusterCpu>)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// The list of objects in the cluster is unknown to the CPU, because GPU
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// clustering is being used.
</span><span>    Gpu</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-cluster-cluster-z-slice-wgsl-203-0><code>crates/bevy_pbr/src/cluster/cluster_z_slice.wgsl</code> (+203/-0)</h3><p><strong>Purpose</strong>: Compute shader for Z slicing pass (step 1).<p><strong>Key changes</strong>:<ul><li>Computes Z slice range for each clusterable object<li>Writes Z slice data to buffer for rasterization passes<li>Calculates farthest Z value for dynamic cluster range adjustment</ul><p><strong>Code snippet showing Z slice calculation</strong>:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Write out our Z slices.
</span><span>for (var z_slice = cluster_bounds.min.z; z_slice <= cluster_bounds.max.z; z_slice += 1u) {
</span><span>    try_write_z_slice(object_index, object_type, z_slice);
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Clustered Shading Algorithms</strong>:</p> <ul><li><a rel="noopener nofollow noreferrer" href=http://newq.net/dl/pub/s2015_practical.pdf target=_blank>Practical Clustered Shading</a> - The original paper on clustered shading<li><a rel="noopener nofollow noreferrer" href=https://software.intel.com/content/www/us/en/develop/articles/forward-clustered-shading.html target=_blank>Clustered Deferred and Forward Shading</a> - Intel’s implementation details</ul><li><p><strong>Parallel Algorithms</strong>:</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Prefix_sum target=_blank>Prefix Sum (Scan) Algorithms</a> - Foundation for the allocation phase<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Prefix_sum#Algorithm_1:_Shorter_span,_more_parallel target=_blank>Hillis-Steele Scan</a> - Parallel prefix sum algorithm used</ul><li><p><strong>Bevy Documentation</strong>:</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/rendering/ target=_blank>Bevy’s Rendering Architecture</a> - Understanding Bevy’s render graph<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/rendering/shaders/ target=_blank>WGSL Shader Language</a> - Bevy’s shading language</ul><li><p><strong>GPU Compute Patterns</strong>:</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-32-taking-plunge-gpu target=_blank>GPU-Based Compute Using Rasterization</a> - Using rasterizers for general-purpose compute<li><a rel="noopener nofollow noreferrer" href=https://www.khronos.org/opengl/wiki/Memory_Model#Atomic_operations target=_blank>Atomic Operations in GPU Shaders</a> - Understanding atomic operations used in the counting phase</ul></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23036.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>