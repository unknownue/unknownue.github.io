<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21831 Implement per-pixel linked list for OIT
        
    </title><meta content="#21831 Implement per-pixel linked list for OIT" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-05</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-21831-en-20260205>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Implement per-pixel linked list for OIT<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21831<li><strong>Author</strong>: beicause<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review, D-Shaders, C-Refinement<li><strong>Created</strong>: 2025-11-14T02:22:56Z<li><strong>Merged</strong>: 2026-02-05T21:40:10Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=mu-biao>目标</h1><p>目前的OIT为每个层存储视口大小的片段。它使用的内存比实际需要的多得多。<h2 id=jie-jue-fang-an>解决方案</h2><p>实现了每像素链表用于OIT，这节省了内存并能处理更多层。实现参考了 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/oit_linked_lists<h2 id=ce-shi>测试</h2><p>使用 <code>order_independent_transparency</code> 示例进行了测试。我还在其中添加了一个新场景。<details><img alt=屏幕截图_20251114_100337 height=1098 src=https://github.com/user-attachments/assets/cd76a6be-69db-4700-88a8-34a2ab140c16 width=1763></details><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=wen-ti-he-bei-jing>问题和背景</h3><p>在实时渲染中，顺序无关透明度（Order Independent Transparency, OIT）是一种能够正确渲染半透明对象的技术，无论这些对象在场景中的绘制顺序如何。Bevy引擎原有的OIT实现采用了一种分层方法：它分配一个视口大小的缓冲区，为每个像素存储固定数量的层（fragment）。每个层包含颜色和深度信息。这种方法有一个明显的缺点：内存使用与层数乘以屏幕像素数成正比。即使一个像素实际上只有很少的半透明片段，系统也必须为每个像素分配完整的层数。这不仅浪费内存，还限制了可处理的半透明片段数量，因为层数设置是固定的，超过该数量的片段将被丢弃。<p>开发者面临的核心问题是内存效率低下和可扩展性限制。原实现在处理复杂半透明场景时，要么需要设置很高的层数（导致内存浪费），要么会因层数不足而丢失片段。因此，需要一个更高效的数据结构来存储每个像素的半透明片段。<h3 id=jie-jue-fang-an-fang-fa>解决方案方法</h3><p>开发者选择了<strong>每像素链表（per-pixel linked list）</strong> 作为新的OIT实现方案。这种方案的基本思想是：为每个像素维护一个链表，链表节点存储在全局的节点缓冲区中。每个节点包含当前片段的颜色、深度和指向下一个节点的索引。此外，还有一个头指针缓冲区，存储每个像素链表的第一个节点索引。这种方案的内存使用与实际的半透明片段数量成正比，而不是屏幕像素数乘以固定层数。它能更灵活地处理动态数量的片段，并且内存利用率更高。<p>该实现参考了Khronos Group的Vulkan示例中的OIT链表实现。这种方案在图形学界是已知的，但将其集成到Bevy的渲染管线中需要进行一系列的架构调整。<h3 id=shi-xian-xi-jie>实现细节</h3><p>新的实现涉及多个组件的修改。首先，数据结构从固定大小的分层缓冲区转变为动态的链表缓冲区。在Rust代码中，<code>OitBuffers</code>结构体被重构：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Fixed-size per-layer buffers
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>OitBuffers </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>layers</span><span style=color:#61676ccc>: </span><span>BufferVec&LTUVec2>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>layer_ids</span><span style=color:#61676ccc>: </span><span>BufferVec<</span><span style=color:#fa6e32>i32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>settings</span><span style=color:#61676ccc>: </span><span>DynamicUniformBuffer&LTOrderIndependentTransparencySettings>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Linked list buffers
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>OitBuffers </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>settings</span><span style=color:#61676ccc>: </span><span>DynamicUniformBuffer&LTOrderIndependentTransparencySettings>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>nodes_capacity</span><span style=color:#61676ccc>: </span><span>UniformBuffer<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>nodes</span><span style=color:#61676ccc>: </span><span>UninitBufferVec&LTOitFragmentNode>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>heads</span><span style=color:#61676ccc>: </span><span>UninitBufferVec<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>atomic_counter</span><span style=color:#61676ccc>: </span><span>UninitBufferVec<</span><span style=color:#fa6e32>u32</span><span>>,
</span><span>}
</span></code></pre><p><code>OitFragmentNode</code>是一个新的结构体，在WGSL和Rust中都有定义，包含颜色（压缩为rgb9e5格式）、深度和alpha（打包为32位）以及下一个节点的索引。<p>在渲染过程中，透明通道（<code>main_transparent_pass_3d</code>）现在会检查OIT是否启用，并确保OIT解析管道（<code>OitResolvePipelineId</code>）已准备就绪，以防止在没有重置链表的情况下写入缓冲区，导致链表损坏（如循环引用）。<p>在着色器方面，<code>oit_draw.wgsl</code>中的<code>oit_draw</code>函数被重写，不再使用原子操作向固定层数组添加片段，而是使用原子操作分配新的节点，并更新头指针：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before: Write to fixed layer array
</span><span>var layer_id = atomicAdd(&oit_layer_ids[screen_index], 1);
</span><span>if layer_id >= oit_settings.layers_count {
</span><span>    atomicStore(&oit_layer_ids[screen_index], oit_settings.layers_count);
</span><span>    return;
</span><span>}
</span><span>let layer_index = screen_index + layer_id * buffer_size;
</span><span>oit_layers[layer_index] = vec2(rgb9e5_color, depth_alpha);
</span><span>
</span><span>// After: Linked list insertion
</span><span>var new_node_index = atomicAdd(&oit_atomic_counter, 1u);
</span><span>if new_node_index >= oit_nodes_capacity {
</span><span>    return;
</span><span>}
</span><span>var node: OitFragmentNode;
</span><span>node.next = atomicExchange(&oit_heads[screen_index], new_node_index + 1u) - 1u;
</span><span>node.color = bevy_pbr::rgb9e5::vec3_to_rgb9e5_(color.rgb);
</span><span>node.depth_alpha = pack_24bit_depth_8bit_alpha(position.z, color.a);
</span><span>oit_nodes[new_node_index] = node;
</span></code></pre><p>注意，头指针缓冲区使用从1开始的索引，0作为结束哨兵（sentinel），这样可以避免从CPU写入<code>u32::MAX</code>，因为wgpu保证缓冲区初始化为零。<p>在解析通道（<code>oit_resolve.wgsl</code>）中，算法也进行了重写。原实现使用固定大小的数组进行冒泡排序，新实现则遍历链表，使用一个固定大小的排序数组（大小由<code>sorted_fragment_max_count</code>控制）来存储最前面的几个片段。如果链表中的片段数超过排序数组容量，则会进行近似混合：将最近（深度最小）的片段混合到最终颜色中，然后将其从排序数组中移除，为更远的片段腾出空间。这种方法在片段数超过排序容量时提供了合理的近似，同时保持了性能。<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// New resolve algorithm: build sorted array from linked list
</span><span>var fragment_list: array&LTOitFragment, SORTED_FRAGMENT_MAX_COUNT>;
</span><span>var sorted_frag_count = 0u;
</span><span>while current_node != LINKED_LIST_END_SENTINEL {
</span><span>    let fragment_node = nodes[current_node];
</span><span>    current_node = fragment_node.next;
</span><span>    // ... depth test and insertion sort into fragment_list ...
</span><span>}
</span></code></pre><p>此外，为了支持深度预通道（depth prepass），着色器增加了条件编译。当启用深度预通道时，解析着色器可以直接跳过被不透明物体遮挡的片段，而无需采样深度纹理。这通过添加<code>DEPTH_PREPASS</code> shader定义和相应的条件代码实现。<h3 id=ji-shu-dong-cha>技术洞察</h3><p>这个PR展示了几个重要的技术决策：<ol><li><p><strong>原子操作和链表构建</strong>：在GPU上构建每像素链表需要原子操作来分配节点和更新头指针。这依赖于GPU的原子操作支持。Bevy的渲染设备需要支持存储缓冲区的原子操作（<code>WgpuFeatures::STORAGE_BUFFER_ATOMIC</code>）。原子计数器用于分配新节点，而头指针的交换（<code>atomicExchange</code>）确保了链表的正确构建。</p><li><p><strong>内存管理</strong>：链表节点的缓冲区大小不再与屏幕分辨率和固定层数绑定，而是基于预期的平均每像素片段数（<code>fragments_per_pixel_average</code>）动态计算。这允许开发者根据场景复杂度调整内存分配，而不是为最坏情况分配内存。当没有摄像机启用OIT时，缓冲区大小会被缩减到最小（1），以释放内存。</p><li><p><strong>深度和alpha的打包</strong>：深度和alpha被打包到一个32位整数中，但打包方式发生了改变。原代码将深度放在低24位，alpha放在高8位。新代码将深度放在高24位，alpha放在低8位。这样做的原因是：由于深度值在整数表示中占高位，比较打包后的整数值就相当于比较深度值（忽略alpha），这可以在排序时简化比较操作。</p><li><p><strong>与深度预通道的集成</strong>：深度预通道（Depth Prepass）是一种常用的优化技术，它先渲染不透明物体的深度，然后在透明通道中利用这些深度信息进行早期深度测试。OIT的新实现与深度预通道协同工作：如果启用了深度预通道，那么在绘制半透明片段时就可以提前拒绝被遮挡的片段（在<code>oit_draw.wgsl</code>中），并且在解析时也不需要采样深度纹理。</p><li><p><strong>管道和绑定组的调整</strong>：由于数据结构的变化，渲染管道的绑定组布局也需要调整。现在需要绑定节点缓冲区、头指针缓冲区和原子计数器缓冲区。此外，根据是否启用深度预通道，解析管道的布局也会不同（可能不需要深度纹理绑定）。</p></ol><h3 id=ying-xiang>影响</h3><p>这些改变带来了几个具体的改进：<ol><li><p><strong>内存效率提升</strong>：内存使用现在与实际的半透明片段数量更接近，而不是固定的屏幕像素乘以层数。对于典型场景，这可以显著减少内存占用，尤其是当半透明对象只覆盖屏幕一部分时。</p><li><p><strong>可扩展性增强</strong>：链表结构理论上可以处理任意数量的片段，只受节点缓冲区大小的限制。节点缓冲区的大小可以基于预期片段数设置，而不是固定的层数。这意味着更复杂的半透明场景可以被正确渲染，而不会因为层数不足而丢失片段。</p><li><p><strong>性能考虑</strong>：链表构建需要原子操作，这可能在某些硬件上带来性能开销。但是，由于避免了固定大小数组的冗余存储和排序，整体性能可能得到提升，特别是在片段分布不均匀的场景中。新的解析算法使用插入排序和近似混合，对于超过排序容量的片段进行了优化处理。</p><li><p><strong>代码维护性</strong>：新的实现更加模块化，与深度预通道的集成也更清晰。然而，由于增加了链表管理的复杂性，代码的理解和调试难度也可能增加。</p></ol><p>这个PR为Bevy的OIT实现带来了现代图形技术，使其能够更好地处理复杂的半透明效果，同时为未来的优化（如更好的排序算法、尾混合等）奠定了基础。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[OrderIndependentTransparencySettings] --> B[OitBuffers]
</span><span>    B --> C[nodes buffer]
</span><span>    B --> D[heads buffer]
</span><span>    B --> E[atomic counter]
</span><span>    F[main_transparent_pass_3d] --> G[oit_draw.wgsl]
</span><span>    G --> H[Build linked list]
</span><span>    H --> C
</span><span>    H --> D
</span><span>    H --> E
</span><span>    I[oit_resolve node] --> J[oit_resolve.wgsl]
</span><span>    J --> K[Traverse linked list]
</span><span>    K --> L[Sort and blend]
</span><span>    L --> M[Output color]
</span><span>    N[DepthPrepass] --> G
</span><span>    N --> J
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><p><strong><code>crates/bevy_core_pipeline/src/oit/mod.rs</code> (+129/-118)</strong></p> <ul><li>这是OIT模块的主要文件，进行了大规模重构。<li>主要变化：将原来的固定层缓冲区（<code>layers</code>和<code>layer_ids</code>）替换为链表缓冲区（<code>nodes</code>、<code>heads</code>、<code>atomic_counter</code>）。<li>引入了新的结构体<code>OitFragmentNode</code>。<li>修改了<code>OrderIndependentTransparencySettings</code>，将<code>layer_count</code>替换为<code>sorted_fragment_max_count</code>和<code>fragments_per_pixel_average</code>。<li>更新了缓冲区准备逻辑，根据摄像机设置动态计算缓冲区大小。<li>移除了原来的<code>configure_depth_texture_usages</code>系统，改为更简单的<code>configure_camera_depth_usages</code>。</ul><li><p><strong><code>crates/bevy_core_pipeline/src/oit/resolve/oit_resolve.wgsl</code> (+95/-63)</strong></p> <ul><li>这是OIT解析的着色器文件，完全重写。<li>新实现了链表遍历、排序和混合算法。<li>支持深度预通道条件编译。<li>使用固定大小的排序数组，对超出容量的片段进行近似混合。</ul><li><p><strong><code>examples/3d/order_independent_transparency.rs</code> (+110/-4)</strong></p> <ul><li>更新了OIT示例，添加了新的测试场景。<li>新增了四边形场景和自动实例化测试场景。<li>展示了如何与深度预通道（<code>DepthPrepass</code>）一起使用。</ul><li><p><strong><code>crates/bevy_core_pipeline/src/oit/resolve/mod.rs</code> (+45/-21)</strong></p> <ul><li>OIT解析模块的Rust代码。<li>更新了管道特化逻辑，包含深度预通道支持。<li>修改了绑定组准备，以包含新的缓冲区。</ul><li><p><strong><code>crates/bevy_pbr/src/render/mesh_view_bindings.rs</code> (+33/-21)</strong></p> <ul><li>更新了网格视图绑定，以反映新的OIT缓冲区布局。<li>绑定索引从27-29调整为27-31，增加了节点容量、节点、头指针和原子计数器的绑定。</ul></ol><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Vulkan Samples: Order Independent Transparency with Linked Lists</strong> - 这是本PR参考的实现，提供了详细的解释和代码：https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/oit_linked_lists</p><li><p><strong>GPU Pro 2: Order-Independent Transparency Using Per-Pixel Linked Lists</strong> - 一篇经典论文，详细介绍了每像素链表技术。</p><li><p><strong>Bevy文档：Order Independent Transparency</strong> - Bevy官方文档中关于OIT的部分，可以帮助理解如何在实际项目中使用此功能。</p><li><p><strong>WGSL原子操作</strong> - WebGPU Shading Language中原子操作的规范，对于理解链表构建至关重要：https://www.w3.org/TR/WGSL/#atomic-operations</p><li><p><strong>Bevy深度预通道</strong> - 了解深度预通道如何工作，以及如何与OIT配合：https://bevyengine.org/learn/advanced-topics/depth-prepass/</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_21831.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>