diff --git a/examples/stress_tests/many_cubes.rs b/examples/stress_tests/many_cubes.rs
index 671f6d7ead72c..5f5a96afc6c40 100644
--- a/examples/stress_tests/many_cubes.rs
+++ b/examples/stress_tests/many_cubes.rs
@@ -16,7 +16,10 @@ use bevy::{
     camera::visibility::{NoCpuCulling, NoFrustumCulling},
     diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin},
     light::NotShadowCaster,
-    math::{ops::cbrt, DVec2, DVec3},
+    math::{
+        ops::{cbrt, sqrt},
+        DVec2, DVec3,
+    },
     prelude::*,
     render::{
         batching::NoAutomaticBatching,
@@ -52,6 +55,10 @@ struct Args {
     #[argh(option, default = "1")]
     mesh_count: usize,
 
+    /// the number of cubes
+    #[argh(option, default = "1600000")]
+    instance_count: usize,
+
     /// whether to disable all frustum culling. Stresses queuing and batching as all mesh material entities in the scene are always drawn.
     #[argh(switch)]
     no_frustum_culling: bool,
@@ -172,13 +179,13 @@ fn setup(
         Layout::Sphere => {
             // NOTE: This pattern is good for testing performance of culling as it provides roughly
             // the same number of visible meshes regardless of the viewing angle.
-            const N_POINTS: usize = WIDTH * HEIGHT * 4;
+            let n_points: usize = args.instance_count;
             // NOTE: f64 is used to avoid precision issues that produce visual artifacts in the distribution
             let radius = WIDTH as f64 * 2.5;
             let golden_ratio = 0.5f64 * (1.0f64 + 5.0f64.sqrt());
-            for i in 0..N_POINTS {
+            for i in 0..n_points {
                 let spherical_polar_theta_phi =
-                    fibonacci_spiral_on_sphere(golden_ratio, i, N_POINTS);
+                    fibonacci_spiral_on_sphere(golden_ratio, i, n_points);
                 let unit_sphere_p = spherical_polar_to_cartesian(spherical_polar_theta_phi);
                 let (mesh, transform) = meshes.choose(&mut material_rng).unwrap();
                 commands
@@ -214,8 +221,24 @@ fn setup(
             // NOTE: This pattern is good for demonstrating that frustum culling is working correctly
             // as the number of visible meshes rises and falls depending on the viewing angle.
             let scale = 2.5;
-            for x in 0..WIDTH {
-                for y in 0..HEIGHT {
+
+            // Scale the width and height by the same factor so that we have the
+            // right number of instances.
+            // Because of the moiré pattern check and the fact that we're
+            // spawning 4 instances per trip around the inner loop below, we're
+            // solving the following equation for the factor variable:
+            //
+            //      4 * (9/10 * factor * width * 9/10 * factor * height) = count
+            //
+            // The solution is the value below.
+            let factor = (5.0 / 9.0) * sqrt(args.instance_count as f32)
+                / (sqrt(HEIGHT as f32) * sqrt(WIDTH as f32));
+            let dimensions = (vec2(WIDTH as f32, HEIGHT as f32) * factor)
+                .ceil()
+                .as_uvec2();
+
+            for x in 0..dimensions.x {
+                for y in 0..dimensions.y {
                     // introduce spaces to break any kind of moiré pattern
                     if x % 10 == 0 || y % 10 == 0 {
                         continue;
@@ -231,7 +254,7 @@ fn setup(
                         MeshMaterial3d(materials.choose(&mut material_rng).unwrap().clone()),
                         Transform::from_xyz(
                             (x as f32) * scale,
-                            HEIGHT as f32 * scale,
+                            dimensions.y as f32 * scale,
                             (y as f32) * scale,
                         ),
                     ));
@@ -248,7 +271,13 @@ fn setup(
                 }
             }
             // camera
-            let center = 0.5 * scale * Vec3::new(WIDTH as f32, HEIGHT as f32, WIDTH as f32);
+            let center = 0.5
+                * scale
+                * Vec3::new(
+                    dimensions.x as f32,
+                    dimensions.y as f32,
+                    dimensions.x as f32,
+                );
             commands.spawn((Camera3d::default(), Transform::from_translation(center)));
             // Inside-out box around the meshes onto which shadows are cast (though you cannot see them...)
             commands.spawn((
@@ -261,7 +290,7 @@ fn setup(
         Layout::Dense => {
             // NOTE: This pattern is good for demonstrating a dense configuration of cubes
             // overlapping each other, all within the camera frustum.
-            let count = WIDTH * HEIGHT * 2;
+            let count = args.instance_count;
             let size = cbrt(count as f32).round();
             let gap = 1.25;
 
@@ -330,11 +359,7 @@ fn init_materials(
     assets: &mut Assets<StandardMaterial>,
 ) -> Vec<Handle<StandardMaterial>> {
     let capacity = if args.vary_material_data_per_instance {
-        match args.layout {
-            Layout::Cube => (WIDTH - WIDTH / 10) * (HEIGHT - HEIGHT / 10),
-            Layout::Sphere => WIDTH * HEIGHT * 4,
-            Layout::Dense => WIDTH * HEIGHT * 2,
-        }
+        args.instance_count
     } else {
         args.material_texture_count
     }
