<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22785 Fix off-by-one in alloc_many unintentionally allocating fresh indices
        
    </title><meta content="#22785 Fix off-by-one in alloc_many unintentionally allocating fresh indices" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-04</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22785-zh-cn-20260204>中文</a></div></div><div class=pr-content><h1 id=fix-off-by-one-in-alloc-many-unintentionally-allocating-fresh-indices>Fix off-by-one in alloc_many unintentionally allocating fresh indices</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix off-by-one in alloc_many unintentionally allocating fresh indices<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22785<li><strong>Author</strong>: nickbabcock<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-ECS, S-Ready-For-Final-Review, P-Regression<li><strong>Created</strong>: 2026-02-03T00:10:34Z<li><strong>Merged</strong>: 2026-02-04T00:21:34Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>The PR description remains in English as per the instructions:<h1 id=objective>Objective</h1><p>Currently there is an off-by-one bug in <code>alloc_many</code>. <code>spawn_batch</code> would allocate fresh indices instead of reusing freed ones when current_len == free.len().<p>I don’t believe this bug exists on <code>main</code>, hence why this PR is targeting 0.18.1. Please let me know if there is a better way to land this change.<h2 id=testing>Testing</h2><ul><li>The unit test covers the bug (ie: reverting the change will cause the test to fail).</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a subtle but important bug in Bevy’s Entity Component System (ECS) that affected entity index reuse. The issue occurred in the <code>EntityAllocator</code> implementation, specifically in the <code>alloc_many</code> method used for batch entity allocation. When systems like <code>spawn_batch</code> needed to allocate multiple entities at once, there was a boundary condition where freed entity indices wouldn’t be properly reused, causing unnecessary allocation of fresh indices instead.<p>The core problem was an off-by-one error in a conditional check. When the number of entities requested for allocation (<code>count</code>) exactly matched the number of available free indices (<code>free.len()</code>), the system would incorrectly default to allocating fresh indices rather than reusing the available ones. This happened because the comparison operator in the conditional was strict (<code><</code>) rather than inclusive (<code><=</code>).<p>From an engineering perspective, this bug had several implications. First, it could lead to inefficient memory usage by not reusing available entity slots. Second, it could cause unexpected performance characteristics in systems that frequently allocated and freed entities in batches. Third, for long-running applications, this could potentially lead to faster exhaustion of the entity index space than necessary.<p>The fix itself is minimal but important. The <code>alloc_many</code> method uses atomic operations to manage concurrent access to the free list. When allocating multiple entities, it first decrements the <code>free_len</code> counter atomically to reserve slots, then checks whether there are enough free slots available. The bug was in this boundary check:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> current_len </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if</span><span> current_len </span><span style=color:#ed9366>< </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>free</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>    current_len
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#ff8f40>0
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>The issue occurs when <code>current_len == self.free.len()</code>. In this case, the condition <code>current_len < self.free.len()</code> evaluates to <code>false</code>, causing the code to fall through to the else branch and set <code>current_len</code> to 0. This tells the system that there are no free indices available, when in fact there are exactly enough to satisfy the request.<p>The corrected version uses <code><=</code> instead:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> current_len </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if</span><span> current_len </span><span style=color:#ed9366><= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>free</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>    current_len
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#ff8f40>0
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>This ensures that when <code>current_len</code> equals <code>self.free.len()</code>, the system correctly recognizes that free indices are available and should be used.<p>The implementation includes a comprehensive unit test that clearly demonstrates the issue and verifies the fix. The test follows a clean pattern:<ol><li>Allocate a batch of entities<li>Free all those entities<li>Allocate the same number of entities again<li>Verify that all indices are reused</ol><p>The test uses <code>index_u32()</code> to compare entity indices directly, which is appropriate since entity reuse should manifest as index reuse. The assertion checks that the intersection between the first batch’s indices and the second batch’s indices equals the batch size (5), confirming complete reuse.<p>What’s interesting about this bug is its regression nature. The author notes that this bug doesn’t exist on <code>main</code>, suggesting it was introduced during development for the 0.18.1 release. This highlights the importance of thorough testing for boundary conditions, especially in concurrent data structures like entity allocators that use atomic operations.<p>The fix is targeted specifically at the 0.18.1 release branch, which is a responsible approach to bug fixing in a versioned release system. This ensures that the stable release gets the fix without introducing potential instability from <code>main</code> branch changes.<p>From an architectural perspective, this fix maintains the existing design pattern of the entity allocator. The <code>alloc_many</code> method returns an iterator (<code>AllocEntitiesIterator</code>) that handles the actual allocation logic, and this fix ensures that the iterator receives the correct information about available free slots.<p>The simplicity of the fix belies its importance. Off-by-one errors are classic bugs that can have significant consequences in systems programming, especially in resource management components like entity allocators. The fact that this was caught and fixed with a targeted unit test demonstrates good software engineering practices: identify the bug, write a test that reproduces it, fix the bug, and verify the test passes.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[spawn_batch requests entities] --> B[EntityAllocator.alloc_many]
</span><span>    B --> C{Check free slots}
</span><span>    C -->|current_len <= free.len()| D[Use free indices]
</span><span>    C -->|current_len > free.len()| E[Allocate fresh indices]
</span><span>    D --> F[AllocEntitiesIterator processes indices]
</span><span>    E --> F
</span><span>    F --> G[Entities returned to spawn_batch]
</span><span>    
</span><span>    H[Original Bug: current_len == free.len()] --> I[Falls through to fresh allocation]
</span><span>    J[Fixed: current_len == free.len()] --> D[Correctly uses free indices]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-entity-mod-rs-31-1><code>crates/bevy_ecs/src/entity/mod.rs</code> (+31/-1)</h3><p>This file contains the <code>EntityAllocator</code> implementation and the bug fix. The change is minimal but crucial for correct entity index reuse.<p><strong>Key changes:</strong><ol><li><strong>Bug fix in <code>alloc_many</code> method:</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> current_len </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if</span><span> current_len </span><span style=color:#ed9366>< </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>free</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>    current_len
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#ff8f40>0
</span><span>}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> current_len </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if</span><span> current_len </span><span style=color:#ed9366><= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>free</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>    current_len
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#ff8f40>0
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><ol start=2><li><strong>Unit test added to verify the fix:</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>alloc_many_reuses_freed_entities</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> allocator </span><span style=color:#ed9366>= </span><span>EntityAllocator</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Allocate 5 entities
</span><span>    </span><span style=color:#fa6e32>let</span><span> first_batch</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#ed9366>_</span><span>> </span><span style=color:#ed9366>=</span><span> allocator</span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc_many</span><span>(</span><span style=color:#ff8f40>5</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(first_batch</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>5</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Record the indices
</span><span>    </span><span style=color:#fa6e32>let</span><span> first_indices</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#ed9366>_</span><span>> </span><span style=color:#ed9366>=</span><span> first_batch</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>e</span><span>| e</span><span style=color:#ed9366>.</span><span style=color:#f07171>index_u32</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Free all entities
</span><span>    </span><span style=color:#fa6e32>for</span><span> e </span><span style=color:#ed9366>in &</span><span>first_batch {
</span><span>        allocator</span><span style=color:#ed9366>.</span><span style=color:#f07171>free</span><span>(</span><span style=color:#ed9366>*</span><span>e)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Allocate 5 entities again - this should reuse all freed indices
</span><span>    </span><span style=color:#fa6e32>let</span><span> second_batch</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#ed9366>_</span><span>> </span><span style=color:#ed9366>=</span><span> allocator</span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc_many</span><span>(</span><span style=color:#ff8f40>5</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(second_batch</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>5</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Compute intersection between the two batches
</span><span>    </span><span style=color:#fa6e32>let</span><span> intersection </span><span style=color:#ed9366>=</span><span> first_indices
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter</span><span>(|</span><span style=color:#ff8f40>idx</span><span>| second_batch</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>any</span><span>(|</span><span style=color:#ff8f40>e</span><span>| e</span><span style=color:#ed9366>.</span><span style=color:#f07171>index_u32</span><span>() </span><span style=color:#ed9366>== **</span><span>idx))
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>count</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// All 5 indices should be reused
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(intersection</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>5</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The test follows a clear pattern: allocate, record indices, free, reallocate, and verify reuse. This is an effective test because it directly tests the bug scenario and provides clear failure conditions.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Rust Atomic Operations</strong>: Understanding <code>Ordering::Relaxed</code> and other memory orderings used in concurrent Rust code<li><strong>Entity Component System Architecture</strong>: How ECS systems manage entity lifecycles and resource allocation<li><strong>Off-by-One Errors</strong>: Common programming mistakes and strategies for avoiding them<li><strong>Boundary Condition Testing</strong>: Techniques for testing edge cases in software systems<li><strong>Regression Testing</strong>: Strategies for preventing reintroduction of fixed bugs in versioned software</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22785.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>