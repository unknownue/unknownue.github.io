<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22966 Use change lists instead of ticks for detecting when meshes need to be re-specialized and/or re-queued.
        
    </title><meta content="#22966 Use change lists instead of ticks for detecting when meshes need to be re-specialized and/or re-queued." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-20</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22966-zh-cn-20260220>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Use change lists instead of ticks for detecting when meshes need to be re-specialized and/or re-queued.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22966<li><strong>Author</strong>: pcwalton<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review, M-Migration-Guide<li><strong>Created</strong>: 2026-02-15T06:01:08Z<li><strong>Merged</strong>: 2026-02-20T01:19:16Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Right now, every frame, all specialization and queuing systems iterate over all entities visible from a view and check to see whether they need to be updated by consulting a set of change ticks and comparing them to the current change ticks. To handle cases in which a mesh needs to be removed from the bins, a separate final <em>sweep</em> pass then finds entities that no longer exist and removes them manually from the bins. This process is complex, error-prone, and slow, as it involves visiting all visible entities multiple times every frame.<p>This PR changes the setup so that, instead of examining change ticks, the visibility logic pushes the set of added and removed entities to each view explicitly. The visibility system determines which meshes need to be added and removed by first sorting the list of visible entities, then performing an O(n) diff process on the last frame’s visible entities and this frame’s visible entity list. The end result is that the specialization and queuing systems only process the entities that they need to every frame. If a mesh was visible last frame, remained visible this frame, and didn’t change its mesh or material, then it’s generally not examined at all. Not only is this significantly faster for virtually all realistic scenes, but it’s also much simpler.<p>In order to achieve the benefits of not examining every visible mesh every frame, I made sorted render passes retained via an <code>IndexMap</code>. This allows entities to be removed and added via random access while still allowing the list to be sorted by distance. Note that I had to remove the radix sort because <code>IndexMap</code> doesn’t currently support that; I believe the enormous speed benefits of this patch outweigh any minor sorting regressions from this.<p>I tested this PR by running <code>scene_viewer</code> on a test scene with many meshes and materials and implementing a material shuffler that randomly switches the materials around. I tested the following cases:<ul><li><p>Moving the camera so that meshes become visible and invisible.</p><li><p>Switching opaque materials on meshes.</p><li><p>Moving meshes from opaque to alpha masked and vice versa.</p><li><p>Moving meshes from binned render passes to sorted render passes (i.e. transparent).</p><li><p>All of the above while the meshes were off screen, then moving them on screen to ensure that the changes took effect.</p></ul><p>This PR brings the <code>specialize_shadows</code> time on the <code>bevy_city</code> demo from 12.87 ms per frame to 0.1261 ms per frame, a 102x speedup. It brings the <code>queue_shadows</code> time on the same demo from 12.34 ms per frame to 0.1102 ms, a 111x speedup. Mean frame time goes from 50.16 ms to 23.26 ms, a 2.16x speedup.<p><code>specialize_shadows</code> in <code>bevy_city</code> before and after: <img alt="Screenshot 2026-02-14 180313" height=1800 src=https://github.com/user-attachments/assets/dbc3c68b-e0ec-424f-8085-87c0f5f41d3f width=2756><p><code>queue_shadows</code> in <code>bevy_city</code> before and after: <img alt="Screenshot 2026-02-14 180500" height=1800 src=https://github.com/user-attachments/assets/08f8e1bb-6ab4-47da-ae68-a80156d59caa width=2756><p>Frame graph of <code>bevy_city</code> before: <img alt="Screenshot 2026-02-12 203324" height=1800 src=https://github.com/user-attachments/assets/d0807cee-23a2-4e14-be1a-7466b795ebfa width=2756><p>Frame graph of <code>bevy_city</code> after: <img alt="Screenshot 2026-02-14 180506" height=1800 src=https://github.com/user-attachments/assets/b22acf0f-a6f9-432b-93d7-f8057c815b05 width=2756><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>Before this PR, Bevy’s rendering system used a change tick-based approach to detect when meshes needed their pipelines re-specialized or re-queued. Every frame, for each view, the specialization and queuing systems would iterate over all visible entities and check their change ticks against stored ticks. This required examining every visible entity each frame, even if nothing had changed. Additionally, a separate sweep pass was needed to remove entities that were no longer visible or had been despawned. This design had several drawbacks:<ol><li><p><strong>Performance overhead</strong>: The system processed every visible entity every frame, leading to O(n) complexity where n is the number of visible entities, regardless of how many actually changed.</p><li><p><strong>Complexity</strong>: The tick comparison logic was intricate, requiring careful handling of edge cases like material type changes. The sweep pass added additional complexity and was error-prone.</p><li><p><strong>Inefficiency</strong>: Even when an entity remained unchanged and visible, it would still be processed each frame, wasting CPU cycles.</p></ol><p>The performance impact was particularly noticeable in scenes with many meshes, as shown in the <code>bevy_city</code> demo where shadow specialization and queuing took over 12 ms per frame.<h3 id=the-solution-approach>The Solution Approach</h3><p>The core idea of this PR is to replace the tick-based change detection with explicit change lists. Instead of checking ticks for each entity, the visibility system now computes the difference between the previous frame’s visible entities and the current frame’s visible entities. This produces two lists: entities that were added (became visible) and entities that were removed (became invisible). These lists are then used by specialization and queuing systems to process only the entities that actually changed.<p>The implementation required several architectural changes:<ol><li><p><strong>Change list generation</strong>: The visibility system now sorts visible entity lists and performs an O(n) diff to compute added and removed entities.</p><li><p><strong>Retained data structures</strong>: Sorted render phases now use <code>IndexMap</code> instead of <code>Vec</code> to allow efficient removal of entities by key without rebuilding the entire list each frame.</p><li><p><strong>Centralized change tracking</strong>: New resources (<code>DirtySpecializations</code>, <code>PendingQueues</code>) were introduced to track which entities need processing and handle cases where assets aren’t yet loaded.</p><li><p><strong>Simplified removal logic</strong>: Entities can now be removed directly from bins and sorted phases using the change lists, eliminating the need for the complex sweep pass.</p></ol><h3 id=the-implementation>The Implementation</h3><p>The implementation touches many parts of the rendering system, but the key changes can be grouped into several categories:<p><strong>1. Visibility System Changes</strong><p>The visibility system was modified to compute change lists. In <code>crates/bevy_camera/src/visibility/mod.rs</code>, visible entity lists are now sorted after collection:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// The list must be sorted in order for the O(n) diffing algorithm that
</span><span style=color:#abb0b6;font-style:italic>// visibility determination uses to work, so do that now.
</span><span style=color:#fa6e32>for</span><span> visible_entities </span><span style=color:#ed9366>in</span><span> visible_entities</span><span style=color:#ed9366>.</span><span>entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>values_mut</span><span>() {
</span><span>    visible_entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>sort_unstable</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The <code>RenderVisibleMeshEntities</code> struct was enhanced to store not just the current visible entities, but also the added and removed entities:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>RenderVisibleMeshEntities </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// A sorted list of all entities that are visible from this view.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>entities</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, MainEntity)>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// A sorted list of all entities that were invisible last frame and became visible this frame.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>added_entities</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, MainEntity)>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// A sorted list of all entities that were visible last frame and became invisible this frame.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>removed_entities</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, MainEntity)>,
</span><span>}
</span></code></pre><p>The <code>update_from</code> method performs the diff between the old and new visible entity lists:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>update_from</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>mapper</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Extract&LTQuery&LTRenderEntity>>,
</span><span>    </span><span style=color:#ff8f40>visible_mesh_entities</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[Entity],
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> old_entities </span><span style=color:#ed9366>= </span><span>mem</span><span style=color:#ed9366>::</span><span>take(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>entities)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>added_entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>removed_entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// March over the old and new visible entity lists in lockstep, diffing
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// as we go to determine the added and removed entities.
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> old_entity_iter </span><span style=color:#ed9366>=</span><span> old_entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>peekable</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for </span><span style=color:#ed9366>&</span><span>visible_main_entity </span><span style=color:#ed9366>in</span><span> visible_mesh_entities {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... diff logic ...
</span><span>    }
</span><span>}
</span></code></pre><p><strong>2. Change Tracking Resources</strong><p>New resources were added to track which entities need processing:<ul><li><code>DirtySpecializations</code>: Tracks renderable objects and views that need re-specialization.<li><code>PendingQueues</code>: Handles entities that can’t be processed immediately due to unloaded assets.</ul><p>These resources are used by specialization and queuing systems to determine which entities to process. For example, in <code>specialize_material_meshes</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Remove cached pipeline IDs corresponding to entities that either
</span><span style=color:#abb0b6;font-style:italic>// have been removed or need to be re-specialized.
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#fa6e32>ref mut</span><span> specialized_material_pipeline_cache) </span><span style=color:#ed9366>=
</span><span>    maybe_specialized_material_pipeline_cache
</span><span>{
</span><span>    </span><span style=color:#fa6e32>if</span><span> dirty_specializations
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>must_wipe_specializations_for_view</span><span>(view</span><span style=color:#ed9366>.</span><span>retained_view_entity)
</span><span>    {
</span><span>        specialized_material_pipeline_cache</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>for </span><span style=color:#ed9366>&</span><span>renderable_entity </span><span style=color:#ed9366>in</span><span> dirty_specializations</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_to_despecialize</span><span>() {
</span><span>            specialized_material_pipeline_cache</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ed9366>&</span><span>renderable_entity)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p><strong>3. Render Phase Modifications</strong><p>Both binned and sorted render phases were updated to support incremental updates:<ul><li><strong>Binned phases</strong>: Now support direct removal of entities using <code>remove()</code> method.<li><strong>Sorted phases</strong>: Now use <code>IndexMap</code> to store items, allowing efficient removal by key.</ul><p>The <code>SortedRenderPhase</code> struct was changed:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>SortedRenderPhase</span><span>&LTI>
</span><span>where
</span><span>    I: SortedPhaseItem,
</span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>items</span><span style=color:#61676ccc>: </span><span>IndexMap<(Entity, MainEntity), I, EntityHash>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>transient_items</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, MainEntity)>,
</span><span>}
</span></code></pre><p>This change required updating the <code>SortedPhaseItem</code> trait to work with <code>IndexMap</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>sort</span><span>(</span><span style=color:#ff8f40>items</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>IndexMap<(Entity, MainEntity), </span><span style=color:#fa6e32>Self</span><span>, EntityHash>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>recalculate_sort_keys</span><span>(
</span><span>    </span><span style=color:#ff8f40>items</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>IndexMap<(Entity, MainEntity), </span><span style=color:#fa6e32>Self</span><span>, EntityHash>,
</span><span>    </span><span style=color:#ff8f40>view</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ExtractedView,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>4. Specialization and Queuing Systems</strong><p>Specialization and queuing systems were rewritten to use the change lists. Instead of iterating over all visible entities and checking ticks, they now iterate only over entities in the change lists:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Now process all meshes that need to be specialized.
</span><span style=color:#fa6e32>for </span><span>(render_entity</span><span style=color:#61676ccc>,</span><span> visible_entity) </span><span style=color:#ed9366>in</span><span> dirty_specializations</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_to_specialize</span><span>(
</span><span>    view</span><span style=color:#ed9366>.</span><span>retained_view_entity</span><span style=color:#61676ccc>,
</span><span>    render_visible_mesh_entities</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>&</span><span>view_pending_mesh_material_queues</span><span style=color:#ed9366>.</span><span>prev_frame</span><span style=color:#61676ccc>,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Only process entities that actually need specialization
</span><span>}
</span></code></pre><p><strong>5. Removal of Old Tick-Based Systems</strong><p>The old tick-based systems and resources were removed:<ul><li><code>EntitySpecializationTicks</code><li><code>ViewSpecializationTicks</code><li><code>LightSpecializationTicks</code><li><code>WireframeEntitySpecializationTicks</code><li>The <code>sweep_old_entities</code> system</ul><h3 id=technical-insights>Technical Insights</h3><p><strong>Performance Characteristics</strong><p>The new approach changes the performance characteristics from O(n) to O(m + d), where n is the total number of visible entities, m is the number of changed entities, and d is the cost of diffing (which is O(n) but much cheaper than the previous per-entity tick checks). In typical scenes where only a small fraction of entities change each frame, this provides massive speedups.<p><strong>Data Structure Trade-offs</strong><p>The switch from <code>Vec</code> to <code>IndexMap</code> in sorted render phases introduces a trade-off:<ul><li><strong>Benefit</strong>: Allows O(1) removal of entities by key, enabling incremental updates.<li><strong>Cost</strong>: Slightly slower iteration and sorting compared to <code>Vec</code>. The PR also had to abandon radix sort because <code>IndexMap</code> doesn’t support it.</ul><p>The performance data shows that the benefits far outweigh the costs, especially given that the number of transparent objects is typically smaller than opaque objects.<p><strong>Handling Unloaded Assets</strong><p>The <code>PendingQueues</code> system addresses a subtle issue: entities might not be processable immediately if their materials or meshes haven’t loaded yet. Instead of failing or skipping them entirely, they’re added to a pending queue and retried on subsequent frames. This ensures correctness without compromising performance.<p><strong>System Ordering</strong><p>The PR introduces new system sets (<code>DirtySpecializationSystems</code>) to ensure proper ordering:<ol><li><code>Clear</code>: Clears change lists at the start of the frame.<li><code>CheckForChanges</code>: Identifies entities that need re-specialization.<li><code>CheckForRemovals</code>: Identifies entities that need to be removed from render phases.</ol><p>This ordering is critical to handle cases where an entity changes material type in the same frame it’s removed.<h3 id=the-impact>The Impact</h3><p><strong>Performance Improvements</strong><p>The performance improvements are dramatic:<ul><li><code>specialize_shadows</code>: 102x faster (12.87 ms → 0.1261 ms)<li><code>queue_shadows</code>: 111x faster (12.34 ms → 0.1102 ms)<li>Overall frame time: 2.16x faster (50.16 ms → 23.26 ms)</ul><p>These improvements scale with scene complexity. In scenes with many static objects, the overhead per frame becomes nearly constant rather than linear in the number of visible entities.<p><strong>Code Simplification</strong><p>Despite touching many files, the PR simplifies the overall codebase:<ul><li>Removes complex tick comparison logic<li>Eliminates the error-prone sweep pass<li>Reduces per-frame work for unchanged entities<li>Centralizes change tracking in a few resources</ul><p><strong>Migration Requirements</strong><p>Custom render phases need to be updated to use the new change list system. The migration guide provides examples of how to adapt specialization and queuing systems. The changes are mostly mechanical: instead of iterating over all visible entities, iterate over the change lists provided by <code>DirtySpecializations</code>.<p><strong>Future Implications</strong><p>This change lays the groundwork for further optimizations:<ul><li>More efficient culling systems<li>Better handling of dynamic scenes<li>Potential for multi-threading improvements in visibility determination</ul><p>The architecture is now better positioned to handle the increasing complexity of modern rendering pipelines.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    subgraph "Before PR"
</span><span>        A[Visibility System] --> B[Collect All Visible Entities]
</span><span>        B --> C[For Each Entity Check Change Ticks]
</span><span>        C --> D[Process Entity if Tick Changed]
</span><span>        D --> E[Separate Sweep Pass for Removals]
</span><span>    end
</span><span>
</span><span>    subgraph "After PR"
</span><span>        F[Visibility System] --> G[Collect & Sort Visible Entities]
</span><span>        G --> H[Diff with Previous Frame]
</span><span>        H --> I[Generate Change Lists]
</span><span>        I --> J[Specialization Systems Process Only Changed Entities]
</span><span>        I --> K[Queuing Systems Process Only Changed Entities]
</span><span>        J --> L[Direct Removal from Phases]
</span><span>        K --> L
</span><span>    end
</span><span>
</span><span>    style F fill:#90EE90
</span><span>    style G fill:#90EE90
</span><span>    style H fill:#90EE90
</span><span>    style I fill:#90EE90
</span><span>    style J fill:#90EE90
</span><span>    style K fill:#90EE90
</span><span>    style L fill:#90EE90
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-render-src-camera-rs-364-24><code>crates/bevy_render/src/camera.rs</code> (+364/-24)</h3><p>This file gained the core change tracking infrastructure.<p><strong>Key additions:</strong><ul><li><code>DirtySpecializations</code>: The main resource tracking which entities and views need processing.<li><code>PendingQueues</code> and <code>ViewPendingQueues</code>: Handle entities with unloaded dependencies.<li>System sets for ordering change list processing.</ul><p><strong>Code snippet showing the new resource:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Clone</span><span style=color:#61676ccc>,</span><span> Resource</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>DirtySpecializations </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// All renderable objects that must be re-specialized this frame.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>changed_renderables</span><span style=color:#61676ccc>:</span><span> MainEntityHashSet,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// All renderable objects that need their specializations removed this frame.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>removed_renderables</span><span style=color:#61676ccc>:</span><span> MainEntityHashSet,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Views that must be respecialized this frame.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>views</span><span style=color:#61676ccc>: </span><span>HashSet&LTRetainedViewEntity>,
</span><span>}
</span></code></pre><p><strong>How it relates to the PR:</strong> This is the central coordination point for change tracking. All specialization and queuing systems now query this resource to determine what work needs to be done.<h3 id=crates-bevy-render-src-render-phase-mod-rs-96-254><code>crates/bevy_render/src/render_phase/mod.rs</code> (+96/-254)</h3><p>This file contains the render phase infrastructure changes.<p><strong>Key changes:</strong><ul><li><code>SortedRenderPhase</code> now uses <code>IndexMap</code> instead of <code>Vec</code>.<li>Added <code>remove()</code> methods for direct entity removal.<li>Removed the <code>sweep_old_entities</code> system and related tick validation logic.</ul><p><strong>Code snippet showing the new SortedRenderPhase structure:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>SortedRenderPhase</span><span>&LTI>
</span><span>where
</span><span>    I: SortedPhaseItem,
</span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>items</span><span style=color:#61676ccc>: </span><span>IndexMap<(Entity, MainEntity), I, EntityHash>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>transient_items</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, MainEntity)>,
</span><span>}
</span></code></pre><p><strong>How it relates to the PR:</strong> These changes enable efficient incremental updates to render phases, which is essential for the change list approach to work well.<h3 id=crates-bevy-pbr-src-material-rs-205-235><code>crates/bevy_pbr/src/material.rs</code> (+205/-235)</h3><p>This file contains the 3D material specialization and queuing logic.<p><strong>Key changes:</strong><ul><li>Replaced tick-based change detection with change list processing.<li>Added <code>PendingMeshMaterialQueues</code> for handling unloaded materials.<li>Simplified the specialization logic to only process changed entities.</ul><p><strong>Code snippet showing the new specialization loop:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Now process all meshes that need to be specialized.
</span><span style=color:#fa6e32>for </span><span>(render_entity</span><span style=color:#61676ccc>,</span><span> visible_entity) </span><span style=color:#ed9366>in</span><span> dirty_specializations</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_to_specialize</span><span>(
</span><span>    view</span><span style=color:#ed9366>.</span><span>retained_view_entity</span><span style=color:#61676ccc>,
</span><span>    render_visible_mesh_entities</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>&</span><span>view_pending_mesh_material_queues</span><span style=color:#ed9366>.</span><span>prev_frame</span><span style=color:#61676ccc>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> maybe_specialized_material_pipeline_cache
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some_and</span><span>(|</span><span style=color:#ff8f40>specialized_material_pipeline_cache</span><span>| {
</span><span>            specialized_material_pipeline_cache</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains_key</span><span>(visible_entity)
</span><span>        })
</span><span>    {
</span><span>        </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... specialization logic ...
</span><span>}
</span></code></pre><p><strong>How it relates to the PR:</strong> This is where the performance gains are realized for 3D materials. Instead of processing all visible entities, only changed entities are examined.<h3 id=crates-bevy-pbr-src-render-light-rs-198-129><code>crates/bevy_pbr/src/render/light.rs</code> (+198/-129)</h3><p>This file handles shadow specialization and queuing.<p><strong>Key changes:</strong><ul><li>Updated shadow processing to use change lists.<li>Added <code>PendingShadowQueues</code> for handling unloaded assets.<li>Simplified the queuing logic.</ul><p><strong>Code snippet showing the new queuing approach:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Now iterate through all newly-visible entities and those needing respecialization.
</span><span style=color:#fa6e32>for </span><span>(render_entity</span><span style=color:#61676ccc>,</span><span> main_entity) </span><span style=color:#ed9366>in</span><span> dirty_specializations</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_to_queue</span><span>(
</span><span>    extracted_view_light</span><span style=color:#ed9366>.</span><span>retained_view_entity</span><span style=color:#61676ccc>,
</span><span>    visible_entities</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>&</span><span>view_pending_shadow_queues</span><span style=color:#ed9366>.</span><span>prev_frame</span><span style=color:#61676ccc>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ed9366>&</span><span>(pipeline_id</span><span style=color:#61676ccc>,</span><span> draw_function)) </span><span style=color:#ed9366>=
</span><span>        view_specialized_material_pipeline_cache</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(main_entity)
</span><span>    </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... queuing logic ...
</span><span>}
</span></code></pre><p><strong>How it relates to the PR:</strong> Shadow rendering saw some of the largest performance improvements (100x+). This file shows how the change list approach was applied to the shadow pipeline.<h3 id=crates-bevy-sprite-render-src-mesh2d-material-rs-185-83><code>crates/bevy_sprite_render/src/mesh2d/material.rs</code> (+185/-83)</h3><p>This file contains the 2D material specialization and queuing logic.<p><strong>Key changes:</strong><ul><li>Updated 2D material processing to use change lists.<li>Added <code>PendingMeshMaterial2dQueues</code> for handling unloaded assets.<li>Simplified the tick-based logic.</ul><p><strong>Code snippet showing the new 2D specialization:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Now process all 2D meshes that need to be re-specialized.
</span><span style=color:#fa6e32>for </span><span>(render_entity</span><span style=color:#61676ccc>,</span><span> visible_entity) </span><span style=color:#ed9366>in</span><span> dirty_specializations</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_to_specialize</span><span>(
</span><span>    view</span><span style=color:#ed9366>.</span><span>retained_view_entity</span><span style=color:#61676ccc>,
</span><span>    visible_entities</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>&</span><span>view_pending_mesh_material2d_queues</span><span style=color:#ed9366>.</span><span>prev_frame</span><span style=color:#61676ccc>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> view_specialized_material_pipeline_cache</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains_key</span><span>(visible_entity) {
</span><span>        </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... specialization logic ...
</span><span>}
</span></code></pre><p><strong>How it relates to the PR:</strong> Demonstrates that the change list approach works consistently across both 2D and 3D rendering pipelines.<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy Render Graph Documentation</strong>: Understanding Bevy’s render graph architecture helps contextualize these changes.</p> <ul><li>https://bevyengine.org/learn/quick-start/getting-started/systems/</ul><li><p><strong>Entity Component System (ECS) Patterns</strong>: The change list approach is a classic ECS optimization pattern for reducing work.</p> <ul><li>https://en.wikipedia.org/wiki/Entity_component_system</ul><li><p><strong>Difference Algorithms</strong>: The O(n) diff algorithm used for computing change lists is similar to those used in text diffing tools.</p> <ul><li>https://en.wikipedia.org/wiki/Diff_algorithm</ul><li><p><strong>IndexMap Data Structure</strong>: Understanding the trade-offs of <code>IndexMap</code> vs <code>Vec</code> for sorted data.</p> <ul><li>https://docs.rs/indexmap/latest/indexmap/</ul><li><p><strong>Rendering Pipeline Optimization</strong>: General techniques for optimizing rendering pipelines.</p> <ul><li>Real-Time Rendering, 4th Edition, by Tomas Akenine-Möller et al.</ul></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22966.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>