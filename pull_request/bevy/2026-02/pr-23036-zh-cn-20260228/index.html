<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #23036 Implement GPU clustering for lights, light probes, and decals.
        
    </title><meta content="#23036 Implement GPU clustering for lights, light probes, and decals." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-28</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-02/pr-23036-en-20260228>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=shi-xian-gpu-ju-lei-bevy-xuan-ran-xing-neng-de-fei-yue>实现 GPU 聚类：Bevy 渲染性能的飞跃</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Implement GPU clustering for lights, light probes, and decals.<li><strong>PR 链接</strong>: https://github.com/bevyengine/bevy/pull/23036<li><strong>作者</strong>: pcwalton<li><strong>状态</strong>: MERGED<li><strong>标签</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review, M-Release-Note<li><strong>创建时间</strong>: 2026-02-18T06:30:21Z<li><strong>合并时间</strong>: 2026-02-28T17:36:54Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><p>目前，Bevy 在 CPU 上进行光照聚类。这通常不再被认为是最佳实践，并且在诸如 <code>many_lights</code> 这样的工作负载中可能成为瓶颈。此外，它阻止了像 <a rel="noopener nofollow noreferrer" href=https://github.com/djeedai/bevy_hanabi target=_blank>Hanabi</a> 这样的 GPU 系统创建可聚类的对象（如灯光和贴花），而无需往返 CPU。<p>此 PR 在硬件支持时引入了 GPU 光照聚类。该算法与现有的 GPU 光照聚类相同，但在所有集群上并行化，并且生成的集群的 GPU 格式保持不变。GPU 光照聚类使用硬件光栅化器进行计算目的，作为一种在 2D 轴对齐边界框内自动分配工作负载的方式，而无需实际渲染任何像素，这在 Bevy 中是首次。算法如下，每个步骤对应一个光栅化或计算命令：<ol><li><p><em>Z 切片</em>：我们有一个大小为 WxHxD 的 3D 集群 froxel 网格，并寻求光栅化 D 个轴对齐的四边形，每个大小为 WxH，表示每个可聚类对象的范围。在这个计算阶段，我们为每个可聚类对象生成 D 个间接实例，用于后续的间接绘制。</p><li><p><em>计数光栅化</em>：我们使用实例化间接绘制来光栅化步骤 1 中生成的每个四边形到大小为 WxH 的视口，颜色写入被禁用。每个光栅化的片段代表一个集群-对象对。在片段着色器中，我们检查对象是否与集群相交，如果相交，我们原子地增加一个计数器，该计数器对应于给定类型的对象与所讨论集群相交的数量。在这个阶段我们不记录对象的 ID；我们只是计算对象的数量。</p><li><p><em>本地分配</em>：现在我们知道每个集群中每种类型对象的数量，我们可以继续在聚类对象缓冲区中为每个聚类对象列表分配空间。为此，我们需要执行 <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Prefix_sum target=_blank><em>前缀和</em></a> 操作，以便每个列表与其他列表紧密打包。例如，如果相邻的集群有 2、5 和 3 个对象，它们将分别被分配到偏移量 0、2 和 7。这个<em>本地</em>步骤使用共享内存中的 <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Prefix_sum#Algorithm_1:_Shorter_span,_more_parallel target=_blank>Hillis-Steele 扫描</a> 来计算每个 256 个集群块的前缀和。在这个本地步骤中，我们不能超过 256 个集群，因为 256 是 <code>wgpu</code> 中的最大工作组大小。</p><li><p><em>全局分配</em>：为了处理步骤 3 中无法计算超过 256 个集群的前缀和的问题，我们采用第二步，对每个 256 集群块进行顺序循环，传播前缀和。在此步骤结束时，每个聚类对象列表都被分配。</p><li><p><em>填充光栅化</em>：最后，我们使用与步骤 (2) 相同的参数发出一个实例化间接绘制命令。我们测试每个集群-对象对是否相交，如果测试通过，我们将每个聚类对象的 ID 记录到列表中的正确空间，使用原子暂存缓冲区来存储每个列表中下一个对象的位置。</p></ol><p>聚类对象缓冲区具有固定大小并且可能溢出。我们通过异步 CPU 读回检测这种情况，并自动为后续帧增长缓冲区。在这种情况下，我们还会记录一条消息，以便开发人员可以选择更大的初始缓冲区大小并避免任何错误的帧。此外，与 #22874 类似，自动聚类启发式方法会从帧到帧动态调整，通过在 GPU 上记录统计数据并使用 CPU 读回将它们下载回 CPU 进行处理。<p>作为此 PR 的一部分，我重构了聚类可见性，以便聚类对象与其他对象一样通过相同的 <code>ViewVisibility</code> 系统，而不是使用 <code>VisibleClusterableObjects</code>。这是一个很好的简化。<p>在 <code>many_lights</code> 基准测试中，大约有 100,000 个灯光中的 8,000 个可见，此过程在我的 NVIDIA GeForce RTX 4070 Laptop GPU 上大约需要 0.099 毫秒。然而，AMD Ryzen 9 8945HS CPU 执行相同任务需要 2.12 毫秒。因此，GPU 版本速度提升了 21 倍。<p><code>main</code> <code>assign_objects_to_clusters</code> 时间，2.12 毫秒： <img alt="Screenshot 2026-02-17 222757" height=1800 src=https://github.com/user-attachments/assets/66341ad2-96f2-4e4a-87ee-fe3462bc05de width=2756><p>GPU 聚类 GPU 时间，0.099 毫秒： <img alt="Screenshot 2026-02-17 222458" height=1800 src=https://github.com/user-attachments/assets/18e2e0ae-a946-4b80-b38a-0543e76ebc02 width=2756><p><code>main</code>，5.71 毫秒中值帧时间，175 FPS： <img alt="Screenshot 2026-02-17 222243" height=1800 src=https://github.com/user-attachments/assets/111c8e22-414f-4ee1-95fa-d7cfe422c2ab width=2756><p>GPU 聚类，4.88 毫秒中值帧时间，205 FPS： <img alt="Screenshot 2026-02-17 222256" height=1800 src=https://github.com/user-attachments/assets/0a662e88-a1b9-49c8-8bab-cc12b46cd079 width=2756><h2 id=alice-de-pm-zhu-shi-lai-zi-kfc35>Alice 的 PM 注释来自 @kfc35</h2><p>修复了 https://github.com/bevyengine/bevy/issues/22957 和 https://github.com/bevyengine/bevy/issues/22904。<h2 id=zhe-ge-pull-request-de-gu-shi>这个 Pull Request 的故事</h2><h3 id=wen-ti-yu-bei-jing>问题与背景</h3><p>在图形渲染中，光照聚类（Light Clustering）是一种将光源分配到空间网格（称为 froxel 或 cluster）的技术，用于加速每像素光照计算。在 PR #23036 之前，Bevy 完全在 CPU 上执行这一过程。这种方法存在两个主要问题：<ol><li><strong>性能瓶颈</strong>：CPU 聚类算法（如迭代球体细化）是计算密集型的，在包含大量光源的场景（如 <code>many_lights</code> 基准测试）中成为显著的性能瓶颈。<li><strong>架构限制</strong>：CPU 聚类阻止了纯 GPU 系统（如粒子效果库 Hanabi）动态创建光源或贴花（decals）并让它们参与聚类，因为这将需要昂贵的 CPU-GPU 往返。</ol><p>此外，现有的聚类可见性系统使用了专门的 <code>VisibleClusterableObjects</code> 组件，这与 Bevy 中其他实体使用的 <code>ViewVisibility</code> 系统不一致，增加了代码复杂性。<h3 id=jie-jue-fang-an>解决方案</h3><p>这个 PR 引入了一个可选的 GPU 聚类系统，当硬件支持时自动启用。GPU 聚类使用硬件光栅化器和计算着色器并行执行聚类操作，算法分为五个步骤：<ol><li><strong>Z 切片</strong>：为每个可聚类对象（光源、光探针、贴花）计算其在 Z 轴上的切片范围，生成间接绘制实例。<li><strong>计数光栅化</strong>：利用光栅化器，为每个对象-切片对生成片段，在片段着色器中原子增加每个集群的对象计数。<li><strong>本地分配</strong>：使用 Hillis-Steele 扫描算法在共享内存中计算每个 256 集群块的前缀和，确定每个集群在全局缓冲区中的偏移量。<li><strong>全局分配</strong>：跨多个 256 集群块传播前缀和，完成全局分配。<li><strong>填充光栅化</strong>：再次光栅化，将对象索引写入到分配好的缓冲区位置。</ol><p>这种方法巧妙地利用了光栅化器来并行处理大量对象-集群相交测试，避免了在 CPU 上进行复杂的几何计算。<h3 id=shi-xian-xi-jie>实现细节</h3><p>PR 对代码库进行了广泛修改，涉及 19 个文件。核心变化包括：<p><strong>新模块 <code>crates/bevy_pbr/src/cluster/gpu.rs</code></strong> 这个新文件包含了 GPU 聚落的完整实现，包括：<ul><li>五个阶段的管线设置（Z 切片计算、计数光栅化、本地/全局分配、填充光栅化）<li>缓冲区管理（Z 切片列表、集群元数据、暂存缓冲区）<li>异步 CPU 读回机制，用于动态调整缓冲区大小和收集统计信息<li>与现有渲染架构的集成点</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 示例：GPU 聚类的主要调度函数
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>cluster_on_gpu</span><span>(
</span><span>    </span><span style=color:#ff8f40>view_query</span><span style=color:#61676ccc>: </span><span>ViewQuery<(...)>,
</span><span>    </span><span style=color:#ff8f40>pipeline_cache</span><span style=color:#61676ccc>: </span><span>Res&LTPipelineCache>,
</span><span>    </span><span style=color:#ff8f40>clustering_mesh_buffers</span><span style=color:#61676ccc>: </span><span>Res&LTGpuClusteringMeshBuffers>,
</span><span>    </span><span style=color:#ff8f40>render_view_clustering_readback_data</span><span style=color:#61676ccc>: </span><span>Res&LTRenderViewClusteringReadbackData>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>render_context</span><span style=color:#61676ccc>:</span><span> RenderContext,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 依次执行五个阶段
</span><span>}
</span></code></pre><p><strong>修改 <code>crates/bevy_light/src/cluster/assign.rs</code></strong> CPU 聚类逻辑被重构为可选路径。当 GPU 聚类启用时，<code>assign_objects_to_clusters</code> 系统仅收集可见对象而不执行实际聚类。此外，系统现在使用标准的 <code>ViewVisibility</code> 组件而不是专用的 <code>VisibleClusterableObjects</code>。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前：总是执行 CPU 聚类
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>assign_objects_to_clusters</span><span>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>views</span><span style=color:#61676ccc>: </span><span>Query<(Entity, ...)>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 多个查询
</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后：根据设置选择路径
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>assign_objects_to_clusters</span><span>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>views</span><span style=color:#61676ccc>: </span><span>Query<(...)>, </span><span style=color:#abb0b6;font-style:italic>// 移除了 commands 参数
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 查询现在包含 ViewVisibility
</span><span>    </span><span style=color:#ff8f40>global_cluster_settings</span><span style=color:#61676ccc>: </span><span>Res&LTGlobalClusterSettings>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> global_cluster_settings</span><span style=color:#ed9366>.</span><span>gpu_clustering</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 仅当 GPU 聚类禁用时才执行 CPU 聚类
</span><span>    }
</span><span>}
</span></code></pre><p><strong>新的 WGSL 着色器</strong><ul><li><code>cluster_z_slice.wgsl</code>：计算每个对象的 Z 切片范围<li><code>cluster_raster.wgsl</code>：执行计数和填充光栅化<li><code>cluster_allocate.wgsl</code>：执行前缀和分配<li><code>cluster.wgsl</code>：包含共享的实用函数和结构定义</ul><p>这些着色器实现了算法描述中的数学运算，包括视图空间转换、球体-AABB 相交测试和前缀和计算。<p><strong>架构调整</strong><ul><li>移除了 <code>VisibleClusterableObjects</code> 组件，使用 <code>ViewVisibility</code> 统一处理<li>修改了 <code>Clusters</code> 组件以支持 CPU 和 GPU 两种存储模式<li>扩展了 <code>GlobalClusterSettings</code> 以包含 GPU 聚类配置选项<li>更新了光照和贴花系统以与新的可见性系统配合工作</ul><h3 id=ji-shu-dong-cha>技术洞察</h3><ol><li><p><strong>硬件光栅化器作为计算单元</strong>：这个实现的一个关键创新是使用光栅化器来并行执行对象-集群相交测试。通过禁用颜色写入，光栅化阶段仅用于生成片段着色器调用，每个调用对应一个需要测试的潜在相交对。这比在计算着色器中手动调度工作更高效。</p><li><p><strong>两阶段前缀和</strong>：由于 WebGPU 限制工作组大小为 256，分配阶段采用了经典的两级前缀和方法。首先在每个 256 集群块内并行计算局部前缀和，然后通过顺序循环传播块之间的累积值。这种模式在并行算法设计中很常见。</p><li><p><strong>动态缓冲区管理</strong>：GPU 聚类缓冲区具有固定大小，但通过异步读回机制可以检测溢出并自动调整大小。系统记录溢出警告，允许开发人员调整初始分配以避免临时性能下降。</p><li><p><strong>向后兼容性</strong>：实现通过 <code>GlobalClusterSettings</code> 中的 <code>gpu_clustering</code> 选项保持向后兼容性。当 GPU 聚类不可用（如 WebGL2）或显式禁用时，系统回退到 CPU 聚类。</p></ol><h3 id=ying-xiang>影响</h3><ol><li><p><strong>性能显著提升</strong>：在作者的测试中，GPU 聚类比 CPU 聚类快 21 倍（0.099 ms vs 2.12 ms）。这直接转化为帧时间减少和 FPS 增加，在 <code>many_lights</code> 基准测试中从 175 FPS 提升到 205 FPS。</p><li><p><strong>架构简化</strong>：通过移除 <code>VisibleClusterableObjects</code> 和使用统一的 <code>ViewVisibility</code> 系统，代码库变得更一致且更易于维护。</p><li><p><strong>为 GPU 驱动效果铺平道路</strong>：现在像 Hanabi 这样的系统可以在 GPU 上创建光源和贴花，而无需 CPU 干预，开启了新的渲染可能性。</p><li><p><strong>自适应启发式改进</strong>：与 #22874 类似，这个 PR 扩展了动态聚类调整机制，使用 GPU 计算的统计信息（如最远 Z 值）来优化后续帧的聚类参数。</p></ol><h2 id=shi-jue-biao-shi>视觉表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[ViewVisibility System] --> B{GPU Clustering Enabled?}
</span><span>    B -->|Yes| C[GPU Clustering Pipeline]
</span><span>    B -->|No| D[CPU Clustering Path]
</span><span>    
</span><span>    subgraph C [GPU Clustering - 5 Stages]
</span><span>        C1[Z-Slicing Compute] --> C2[Count Rasterization]
</span><span>        C2 --> C3[Local Allocation]
</span><span>        C3 --> C4[Global Allocation]
</span><span>        C4 --> C5[Populate Rasterization]
</span><span>    end
</span><span>    
</span><span>    C --> E[Cluster Buffer]
</span><span>    D --> E
</span><span>    
</span><span>    E --> F[Forward/Deferred Rendering]
</span><span>    
</span><span>    G[Async Readback] --> H[Dynamic Buffer Resizing]
</span><span>    G --> I[Cluster Statistics]
</span><span>    I --> J[Heuristic Adjustment]
</span><span>    
</span><span>    C -.-> G
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><h3 id=crates-bevy-pbr-src-cluster-gpu-rs-1714-0><code>crates/bevy_pbr/src/cluster/gpu.rs</code> (+1714/-0)</h3><p>这是全新的 GPU 聚类实现模块。它包含了：<ol><li>五个聚类阶段的管线定义和绑定组布局<li>缓冲区管理结构（<code>ViewGpuClusteringBuffers</code>、<code>RenderViewClusteringReadbackData</code>）<li>主要的调度函数 <code>cluster_on_gpu</code><li>与 Bevy 渲染架构的集成点</ol><p>关键代码片段：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// GPU 聚类的主循环，依次执行五个阶段
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>cluster_on_gpu</span><span>(
</span><span>    </span><span style=color:#ff8f40>view_query</span><span style=color:#61676ccc>: </span><span>ViewQuery<(...)>,
</span><span>    </span><span style=color:#ff8f40>pipeline_cache</span><span style=color:#61676ccc>: </span><span>Res&LTPipelineCache>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 1: Z slicing
</span><span>    </span><span style=color:#f07171>run_clustering_z_slicing_pass</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 2: Count raster
</span><span>    </span><span style=color:#f07171>run_clustering_rasterization_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 3: local allocation
</span><span>    </span><span style=color:#f07171>run_clustering_allocation_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 4: global allocation
</span><span>    </span><span style=color:#f07171>run_clustering_allocation_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Pass 5: populate raster
</span><span>    </span><span style=color:#f07171>run_clustering_rasterization_pass</span><span>(</span><span style=color:#ed9366>...</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Schedule readback for dynamic resizing
</span><span>    </span><span style=color:#f07171>schedule_readback_staging</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-light-src-cluster-assign-rs-463-485><code>crates/bevy_light/src/cluster/assign.rs</code> (+463/-485)</h3><p>CPU 聚类逻辑被大幅修改以支持可选路径。主要变化包括：<ol><li>移除对 <code>VisibleClusterableObjects</code> 的依赖，改用 <code>ViewVisibility</code><li>添加 GPU 聚类启用检查，跳过 CPU 聚类计算<li>重构查询以包含 <code>ViewVisibility</code> 组件</ol><p>关键代码片段：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改后的函数签名，移除了 Commands 参数
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>assign_objects_to_clusters</span><span>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>views</span><span style=color:#61676ccc>: </span><span>Query<(
</span><span>        </span><span style=color:#ed9366>&</span><span>GlobalTransform,
</span><span>        </span><span style=color:#ed9366>&</span><span>Camera,
</span><span>        </span><span style=color:#ed9366>&</span><span>Frustum,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>ClusterConfig>,
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Clusters,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>RenderLayers>,
</span><span>    )>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 所有查询现在都包含 &ViewVisibility
</span><span>    </span><span style=color:#ff8f40>point_lights_query</span><span style=color:#61676ccc>: </span><span>Query<(
</span><span>        Entity,
</span><span>        </span><span style=color:#ed9366>&</span><span>GlobalTransform,
</span><span>        </span><span style=color:#ed9366>&</span><span>ViewVisibility,  // 新增
</span><span>        </span><span style=color:#ed9366>&</span><span>PointLight,
</span><span>        // ...
</span><span>    )>,
</span><span>    </span><span style=color:#ff8f40>global_cluster_settings</span><span style=color:#61676ccc>: </span><span>Res&LTGlobalClusterSettings>,  </span><span style=color:#abb0b6;font-style:italic>// 新增
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 仅在 GPU 聚类禁用时执行 CPU 聚类
</span><span>    </span><span style=color:#fa6e32>if</span><span> global_cluster_settings</span><span style=color:#ed9366>.</span><span>gpu_clustering</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 收集和聚类对象的逻辑
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-cluster-cluster-raster-wgsl-525-0><code>crates/bevy_pbr/src/cluster/cluster_raster.wgsl</code> (+525/-0)</h3><p>这是计数和填充光栅化阶段使用的着色器。它包含了：<ol><li>对象-集群相交测试的逻辑<li>球体与 AABB 相交的数学计算<li>原子计数器操作用于计数和索引分配</ol><p>关键代码片段：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 片段着色器：测试对象是否与集群相交并记录结果
</span><span>@fragment
</span><span>fn fragment_main(varyings: Varyings) -> @location(0) vec4&LTf32> {
</span><span>    // 计算集群的 AABB
</span><span>    let cluster_aabb = compute_aabb_for_cluster(...);
</span><span>    
</span><span>    // 测试球体与 AABB 相交
</span><span>    let object_intersects_cluster_aabb = sphere_intersects_aabb(...);
</span><span>    
</span><span>    if (!object_intersects_cluster_aabb) {
</span><span>        return vec4&LTf32>(0.0);
</span><span>    }
</span><span>    
</span><span>    // 聚光灯的额外剔除
</span><span>    if (object_type == CLUSTERABLE_OBJECT_TYPE_SPOT_LIGHT && cull_spot_light(...)) {
</span><span>        return vec4&LTf32>(0.0);
</span><span>    }
</span><span>    
</span><span>    // 在计数阶段增加计数器，或在填充阶段分配索引
</span><span>    #ifdef POPULATE_PASS
</span><span>    let output_index = allocate_list_entry(cluster_index, object_type);
</span><span>    index_lists.data[output_index] = object_index;
</span><span>    #else
</span><span>    increment_object_count(cluster_index, object_type);
</span><span>    #endif
</span><span>    
</span><span>    return vec4&LTf32>(0.0);
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-cluster-mod-rs-173-46><code>crates/bevy_pbr/src/cluster/mod.rs</code> (+173/-46)</h3><p>集群系统的主要模块，进行了以下修改：<ol><li>扩展 <code>GlobalClusterSettings</code> 以包含 GPU 聚类配置<li>修改 <code>Clusters</code> 组件以支持 <code>ClusterableObjects</code> 枚举（CPU 或 GPU 模式）<li>添加 GPU 聚落的运行条件和提取函数</ol><p>关键代码片段：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 新的 GlobalClusterSettings 结构，包含 GPU 聚类选项
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Clone</span><span style=color:#61676ccc>,</span><span> Resource</span><span style=color:#61676ccc>,</span><span> Debug)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>GlobalClusterSettings </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>supports_storage_buffers</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>clustered_decals_are_usable</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>gpu_clustering</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTGlobalClusterGpuSettings>,  </span><span style=color:#abb0b6;font-style:italic>// 新增
</span><span>    </span><span style=color:#fa6e32>pub </span><span>max_uniform_buffer_clusterable_objects</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>view_cluster_bindings_max_indices</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后的 Clusters 组件，现在使用枚举区分存储模式
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Debug)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Clusters </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 现有字段
</span><span>    </span><span style=color:#fa6e32>pub </span><span>clusterable_objects</span><span style=color:#61676ccc>:</span><span> ClusterableObjects,  </span><span style=color:#abb0b6;font-style:italic>// 从 Vec&LTObjectsInCluster> 修改
</span><span>}
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>ClusterableObjects </span><span>{
</span><span>    Cpu(</span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTObjectsInClusterCpu>)</span><span style=color:#61676ccc>,
</span><span>    Gpu</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-cluster-cluster-z-slice-wgsl-203-0><code>crates/bevy_pbr/src/cluster/cluster_z_slice.wgsl</code> (+203/-0)</h3><p>Z 切片计算着色器，为每个可聚类对象计算其在集群网格中的 Z 范围。<p>关键代码片段：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 计算每个对象的 Z 切片范围
</span><span>@compute @workgroup_size(64, 1, 1)
</span><span>fn z_slice_main(...) {
</span><span>    // 根据对象类型获取位置和半径
</span><span>    let cluster_bounds = calculate_sphere_cluster_bounds(
</span><span>        position,
</span><span>        radius,
</span><span>        view.view_from_world,
</span><span>        view.clip_from_view,
</span><span>        view_from_world_scale,
</span><span>        lights.cluster_dimensions.xyz,
</span><span>        lights.cluster_factors.zw,
</span><span>        is_orthographic
</span><span>    );
</span><span>    
</span><span>    // 为每个 Z 切片写入一个实例
</span><span>    for (var z_slice = cluster_bounds.min.z; z_slice <= cluster_bounds.max.z; z_slice += 1u) {
</span><span>        try_write_z_slice(object_index, object_type, z_slice);
</span><span>    }
</span><span>}
</span></code></pre><h2 id=jin-yi-bu-yue-du>进一步阅读</h2><ol><li><p><strong>Practical Clustered Shading</strong> - 聚类着色的原始论文，介绍了 CPU 端使用的迭代球体细化算法： http://newq.net/dl/pub/s2015_practical.pdf</p><li><p><strong>前缀和算法</strong> - GPU 并行计算中的基础算法，用于分配阶段： https://en.wikipedia.org/wiki/Prefix_sum</p><li><p><strong>Hillis-Steele 扫描</strong> - 一种并行前缀和算法： https://en.wikipedia.org/wiki/Prefix_sum#Algorithm_1:_Shorter_span,_more_parallel</p><li><p><strong>WebGPU 规范</strong> - 了解工作组大小限制和存储缓冲区约束： https://www.w3.org/TR/webgpu/</p><li><p><strong>Bevy 渲染架构</strong> - 了解 Bevy 的 ECS 渲染系统如何工作： https://bevyengine.org/learn/quick-start/introduction/</p><li><p><strong>Hanabi 粒子系统</strong> - 一个受益于 GPU 聚落的 Bevy 粒子效果库： https://github.com/djeedai/bevy_hanabi</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_23036.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>