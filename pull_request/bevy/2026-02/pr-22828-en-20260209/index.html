<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22828 Make the old and new archetype available in lifecycle observers
        
    </title><meta content="#22828 Make the old and new archetype available in lifecycle observers" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-02/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-02-09</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-02/pr-22828-zh-cn-20260209>中文</a></div></div><div class=pr-content><h1 id=make-the-old-and-new-archetype-available-in-lifecycle-observers>Make the old and new archetype available in lifecycle observers</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Make the old and new archetype available in lifecycle observers<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22828<li><strong>Author</strong>: chescock<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Usability, S-Ready-For-Final-Review, M-Migration-Guide<li><strong>Created</strong>: 2026-02-06T14:36:44Z<li><strong>Merged</strong>: 2026-02-09T22:36:29Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description>Description</h2><p><strong>Objective</strong><p>Simplify observers that need to detect when multiple components are added or removed.<p>In particular, if a module needs to keep track of entities with some component <code>C</code> that are not <code>Disabled</code>, it will normally start tracking an entity on <code>Add, C</code> and <code>Remove, Disabled</code> and stop tracking it on <code>Remove, C</code> and <code>Add, Disabled</code>. But it should <em>not</em> start tracking the entity when <code>C</code> and <code>Disabled</code> are removed together, such as when an entity with both is despawned, and this is difficult to detect today.<p>Fixes #22700, although with the idea from https://github.com/bevyengine/bevy/issues/22700#issuecomment-3797391974 rather than the solution in the issue description.<p><strong>Solution</strong><p>Make the old and new archetypes available in lifecycle observers. Wrap them in <code>Option</code> so that the old archetype during spawn and the new archetype during despawn can be <code>None</code>.<p><strong>Showcase</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_remove_disable</span><span>(
</span><span>    </span><span style=color:#ff8f40>on</span><span style=color:#61676ccc>: </span><span>On&LTRemove, Disabled>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>cache</span><span style=color:#61676ccc>: </span><span>ResMut&LTEntitiesWithA>,
</span><span>    </span><span style=color:#ff8f40>a_component</span><span style=color:#61676ccc>: </span><span>ComponentIdFor&LTA>,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// The `A` component may have been removed at the same time as `Disabled`,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// either due to a remove or despawn. Only try to add this entity to our
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// cache if the `A` component is still in the new archetype.
</span><span>    </span><span style=color:#fa6e32>if</span><span> on</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>()</span><span style=color:#ed9366>.</span><span>new_archetype</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some_and</span><span>(|</span><span style=color:#ff8f40>a</span><span>| a</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(</span><span style=color:#ed9366>*</span><span>a_component)) {
</span><span>        cache</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>insert</span><span>(on</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p><strong>Alternatives</strong><p>Adding support for <code>Remove</code> observers that run <em>after</em> the change and <code>Add</code> observers that run <em>before</em> would solve this issue with a simpler user experience, as they would be able to check the <em>current</em> archetype of the entity using ordinary <code>Query</code> infrastructure. That would avoid the need for tricks like <code>ComponentIdFor</code> and <code>E: for<'a> Event&LTTrigger<'a> = EntityComponentsTrigger<'a>></code>.<p>But I believe there are concerns about the performance impact of adding more observer types, so I expect a change like that to be controversial.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a subtle but important problem in Bevy’s ECS system: observers couldn’t accurately determine the complete state of an entity when multiple components were added or removed simultaneously. The issue was particularly evident when tracking entities that needed to have certain components while lacking others, like tracking entities with component <code>A</code> that aren’t disabled.<p>The core problem stems from how lifecycle observers receive information. When an observer triggers on a specific component change, it only receives information about that particular component - not about other components that might be changing at the same time. Consider a scenario where we want to track entities with component <code>A</code> but without component <code>Disabled</code>. If both <code>A</code> and <code>Disabled</code> are removed simultaneously (like when an entity is despawned), the observer for <code>Remove, Disabled</code> would fire, but it wouldn’t know that <code>A</code> was also removed. This could lead to incorrect tracking logic where the system tries to track an entity that no longer has the required component.<p>The solution approach is straightforward: provide observers with the complete archetype information before and after the change. An archetype in Bevy’s ECS represents a specific combination of components that entities can have. By exposing both the old and new archetypes, observers can check for the presence of any component in either state.<p>The implementation required modifying the <code>EntityComponentsTrigger</code> struct in <code>crates/bevy_ecs/src/event/trigger.rs</code> to include two new optional fields:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>EntityComponentsTrigger</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    </span><span style=color:#fa6e32>pub </span><span>components</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> [ComponentId],
</span><span>    </span><span style=color:#fa6e32>pub </span><span>old_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> Archetype>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>new_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> Archetype>,
</span><span>}
</span></code></pre><p>The fields are <code>Option<&Archetype></code> because during entity spawning, there is no old archetype (it’s <code>None</code>), and during despawning, there is no new archetype (also <code>None</code>). This design maintains consistency with the ECS lifecycle model where spawning is equivalent to starting with an empty entity and adding components, and despawning is equivalent to removing all components and then removing the entity.<p>Throughout the codebase, every place where <code>EntityComponentsTrigger</code> is constructed needed to be updated to provide the appropriate archetype information. This included modifications to:<ul><li>Bundle insertion and removal logic<li>Entity spawning<li>Single-component operations in deferred world<li>Entity despawning</ul><p>The changes ensure that all lifecycle events (Add, Remove, Insert, Replace, Despawn) properly propagate archetype information. For example, in <code>crates/bevy_ecs/src/bundle/insert.rs</code>, when components are added via a bundle, the code now captures both the old archetype (before insertion) and the new archetype (after insertion):<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> EntityComponentsTrigger {
</span><span>    components</span><span style=color:#61676ccc>:</span><span> archetype_after_insert</span><span style=color:#ed9366>.</span><span style=color:#f07171>added</span><span>()</span><span style=color:#61676ccc>,
</span><span>    old_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(old_archetype)</span><span style=color:#61676ccc>,
</span><span>    new_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(new_archetype)</span><span style=color:#61676ccc>,
</span><span>}</span><span style=color:#61676ccc>,
</span></code></pre><p>A key technical consideration is that this change is breaking. Since all fields of <code>EntityComponentsTrigger</code> are public, adding new fields constitutes a breaking change that requires users to update their code. The migration guide provides clear instructions: pattern matches need to include <code>..</code> to ignore the new fields, and manual constructions need to specify values for <code>old_archetype</code> and <code>new_archetype</code>.<p>The testing strategy includes a comprehensive test that validates archetype information flows correctly through different lifecycle events. The test spawns entities, removes components, inserts components, and despawns entities, then verifies that the correct old and new archetypes are reported for each event type.<p>From a performance perspective, the impact is minimal. The archetype references are already available when the events are triggered, so we’re just passing additional references. There’s no new allocation or computation required.<p>Looking forward, this solution works well for the immediate problem but points to a potential future improvement. As mentioned in the alternatives section, a more elegant solution might involve adding new observer types that run at different points in the lifecycle (like Remove observers that run after the change). This would allow observers to use regular query infrastructure instead of needing to check archetypes directly. However, such a change would require careful consideration of performance implications and API design.<p>The implementation demonstrates good software engineering practices: it solves a concrete problem with minimal API surface changes, maintains backward compatibility where possible, includes comprehensive documentation and examples, and provides thorough testing to ensure correctness.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Lifecycle Event Occurs] --> B[Determine Old Archetype]
</span><span>    A --> C[Determine Changed Components]
</span><span>    A --> D[Determine New Archetype]
</span><span>    
</span><span>    B --> E[Construct EntityComponentsTrigger]
</span><span>    C --> E
</span><span>    D --> E
</span><span>    
</span><span>    E --> F[Pass to Observer]
</span><span>    F --> G[Observer Logic]
</span><span>    
</span><span>    G --> H{Check Component Presence}
</span><span>    H --> I[In Old Archetype?]
</span><span>    H --> J[In New Archetype?]
</span><span>    
</span><span>    I --> K[Take Action Based on State Transition]
</span><span>    J --> K
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><strong>crates/bevy_ecs/src/event/trigger.rs</strong> (+79/-0) <ul><li>Added <code>old_archetype</code> and <code>new_archetype</code> fields to <code>EntityComponentsTrigger</code><li>Included comprehensive documentation with examples showing how to use the new fields<li>The fields are optional to handle spawn (no old archetype) and despawn (no new archetype) cases</ul></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Key addition to EntityComponentsTrigger struct
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>EntityComponentsTrigger</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    </span><span style=color:#fa6e32>pub </span><span>components</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> [ComponentId],
</span><span>    </span><span style=color:#fa6e32>pub </span><span>old_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> Archetype>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>new_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> Archetype>,
</span><span>}
</span></code></pre><ol start=2><li><strong>crates/bevy_ecs/src/observer/mod.rs</strong> (+71/-2) <ul><li>Updated existing tests to include the new fields in <code>EntityComponentsTrigger</code> constructions<li>Added a new test <code>observer_new_old_archetypes</code> that verifies archetype information flows correctly through different lifecycle events</ul></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Updated test to include new fields
</span><span>EntityComponentsTrigger {
</span><span>    components</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[component_a]</span><span style=color:#61676ccc>,
</span><span>    old_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,
</span><span>    new_archetype</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><ol start=3><li><p><strong>release-content/migration-guides/observer_old_new_archetype.md</strong> (+37/-0)</p> <ul><li>Created migration guide explaining the breaking change<li>Shows how to update pattern matches and manual constructions<li>Provides before/after examples for common use cases</ul><li><p><strong>crates/bevy_ecs/src/bundle/insert.rs</strong> (+17/-0)</p> <ul><li>Updated bundle insertion to pass old and new archetypes to Add, Insert, and Replace events<li>Ensures proper archetype tracking during complex bundle operations</ul><li><p><strong>crates/bevy_ecs/src/bundle/remove.rs</strong> (+6/-0)</p> <ul><li>Updated bundle removal to pass old and new archetypes to Replace and Remove events<li>Maintains consistent archetype information during component removal</ul></ol><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/ecs/ target=_blank>Bevy ECS Documentation</a> - Official Bevy ECS documentation<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Entity_component_system#Archetype-based target=_blank>Archetype-Based ECS Pattern</a> - Wikipedia article on archetype-based ECS<li><a rel="noopener nofollow noreferrer" href=https://gameprogrammingpatterns.com/observer.html target=_blank>Observer Pattern in Game Development</a> - Game Programming Patterns chapter on observers<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/rfcs/pull/53 target=_blank>Bevy Observers RFC</a> - RFC detailing the observer system design</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-02/pr_22828.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>