diff --git a/Cargo.toml b/Cargo.toml
index 036057fa254cf..432eec735d96c 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -760,6 +760,7 @@ anyhow = "1"
 accesskit = "0.24"
 nonmax = "0.5"
 gltf = "1.4"
+indexmap = "2"
 
 [target.'cfg(not(target_family = "wasm"))'.dev-dependencies]
 ureq = { version = "3.0.8", features = ["json"] }
diff --git a/crates/bevy_camera/src/visibility/mod.rs b/crates/bevy_camera/src/visibility/mod.rs
index 8f9352dc4b8a2..ce8d5c5131278 100644
--- a/crates/bevy_camera/src/visibility/mod.rs
+++ b/crates/bevy_camera/src/visibility/mod.rs
@@ -347,13 +347,33 @@ impl VisibleEntities {
 ///
 /// This component contains all mesh entities visible from the current light view.
 /// The collection is updated automatically by `bevy_pbr::SimulationLightSystems`.
-#[derive(Component, Clone, Debug, Default, Reflect, Deref, DerefMut)]
+#[derive(Component, Clone, Debug, Default, Reflect)]
 #[reflect(Component, Debug, Default, Clone)]
 pub struct VisibleMeshEntities {
     #[reflect(ignore, clone)]
     pub entities: Vec<Entity>,
 }
 
+impl VisibleMeshEntities {
+    /// Resizes the entity vector so that its capacity isn't too much higher
+    /// than its size.
+    pub fn shrink(&mut self) {
+        // Check that visible entities capacity() is no more than two times greater than len()
+        let capacity = self.entities.capacity();
+        let reserved = capacity
+            .checked_div(self.entities.len())
+            .map_or(0, |reserve| {
+                if reserve > 2 {
+                    capacity / (reserve / 2)
+                } else {
+                    capacity
+                }
+            });
+
+        self.entities.shrink_to(reserved);
+    }
+}
+
 #[derive(Component, Clone, Debug, Default, Reflect)]
 #[reflect(Component, Debug, Default, Clone)]
 pub struct CubemapVisibleEntities {
@@ -760,6 +780,12 @@ pub fn check_visibility(
                 visible_entities.get_mut(*class).append(entities);
             }
         }
+
+        // The list must be sorted in order for the O(n) diffing algorithm that
+        // visibility determination uses to work, so do that now.
+        for visible_entities in visible_entities.entities.values_mut() {
+            visible_entities.sort_unstable();
+        }
     }
 }
 
diff --git a/crates/bevy_core_pipeline/Cargo.toml b/crates/bevy_core_pipeline/Cargo.toml
index d48710c2ea090..85159496e1252 100644
--- a/crates/bevy_core_pipeline/Cargo.toml
+++ b/crates/bevy_core_pipeline/Cargo.toml
@@ -39,8 +39,8 @@ bevy_platform = { path = "../bevy_platform", version = "0.19.0-dev", default-fea
 ] }
 
 bitflags = "2.3"
-radsort = "0.1"
 nonmax = "0.5"
+indexmap = "2"
 
 [lints]
 workspace = true
diff --git a/crates/bevy_core_pipeline/src/core_2d/mod.rs b/crates/bevy_core_pipeline/src/core_2d/mod.rs
index e159b9615caf8..1bc693fac863d 100644
--- a/crates/bevy_core_pipeline/src/core_2d/mod.rs
+++ b/crates/bevy_core_pipeline/src/core_2d/mod.rs
@@ -5,6 +5,7 @@ use core::ops::Range;
 
 use bevy_asset::UntypedAssetId;
 use bevy_camera::{Camera, Camera2d};
+use bevy_ecs::entity::EntityHash;
 use bevy_image::ToExtents;
 use bevy_platform::collections::{HashMap, HashSet};
 use bevy_render::{
@@ -13,6 +14,7 @@ use bevy_render::{
     render_phase::PhaseItemBatchSetKey,
     view::{ExtractedView, RetainedViewEntity},
 };
+use indexmap::IndexMap;
 pub use main_opaque_pass_2d_node::*;
 pub use main_transparent_pass_2d_node::*;
 
@@ -365,9 +367,15 @@ impl SortedPhaseItem for Transparent2d {
     }
 
     #[inline]
-    fn sort(items: &mut [Self]) {
-        // radsort is a stable radix sort that performed better than `slice::sort_by_key` or `slice::sort_unstable_by_key`.
-        radsort::sort_by_key(items, |item| item.sort_key().0);
+    fn sort(items: &mut IndexMap<(Entity, MainEntity), Transparent2d, EntityHash>) {
+        items.sort_by_key(|_, item| item.sort_key());
+    }
+
+    fn recalculate_sort_keys(
+        _: &mut IndexMap<(Entity, MainEntity), Self, EntityHash>,
+        _: &ExtractedView,
+    ) {
+        // Sort keys are precalculated for 2D phase items.
     }
 
     fn indexed(&self) -> bool {
@@ -399,7 +407,7 @@ pub fn extract_core_2d_camera_phases(
         // This is the main 2D camera, so we use the first subview index (0).
         let retained_view_entity = RetainedViewEntity::new(main_entity.into(), None, 0);
 
-        transparent_2d_phases.insert_or_clear(retained_view_entity);
+        transparent_2d_phases.prepare_for_new_frame(retained_view_entity);
         opaque_2d_phases.prepare_for_new_frame(retained_view_entity, GpuPreprocessingMode::None);
         alpha_mask_2d_phases
             .prepare_for_new_frame(retained_view_entity, GpuPreprocessingMode::None);
diff --git a/crates/bevy_core_pipeline/src/core_3d/mod.rs b/crates/bevy_core_pipeline/src/core_3d/mod.rs
index a75f6a51126bf..42af8ed981880 100644
--- a/crates/bevy_core_pipeline/src/core_3d/mod.rs
+++ b/crates/bevy_core_pipeline/src/core_3d/mod.rs
@@ -24,7 +24,7 @@ pub const DEPTH_TEXTURE_SAMPLING_SUPPORTED: bool = false;
 #[cfg(any(feature = "webgpu", not(target_arch = "wasm32")))]
 pub const DEPTH_TEXTURE_SAMPLING_SUPPORTED: bool = true;
 
-use core::ops::Range;
+use core::{f32, ops::Range};
 
 use bevy_camera::{Camera, Camera3d, Camera3dDepthLoadOp};
 use bevy_diagnostic::FrameCount;
@@ -33,20 +33,21 @@ use bevy_render::{
     camera::CameraRenderGraph,
     mesh::allocator::SlabId,
     occlusion_culling::OcclusionCulling,
-    render_phase::PhaseItemBatchSetKey,
+    render_phase::{PhaseItemBatchSetKey, ViewRangefinder3d},
     texture::CachedTexture,
     view::{prepare_view_targets, NoIndirectDrawing, RetainedViewEntity},
 };
+use indexmap::IndexMap;
 pub use main_opaque_pass_3d_node::*;
 pub use main_transparent_pass_3d_node::*;
 
 use bevy_app::{App, Plugin, PostUpdate};
 use bevy_asset::UntypedAssetId;
 use bevy_color::LinearRgba;
-use bevy_ecs::prelude::*;
+use bevy_ecs::{entity::EntityHash, prelude::*};
 use bevy_image::ToExtents;
 use bevy_log::warn;
-use bevy_math::FloatOrd;
+use bevy_math::{FloatOrd, Vec3};
 use bevy_platform::collections::{HashMap, HashSet};
 use bevy_render::{
     camera::ExtractedCamera,
@@ -371,6 +372,7 @@ impl CachedRenderPipelinePhaseItem for AlphaMask3d {
 }
 
 pub struct Transparent3d {
+    pub sorting_info: TransparentSortingInfo3d,
     pub distance: f32,
     pub pipeline: CachedRenderPipelineId,
     pub entity: (Entity, MainEntity),
@@ -428,8 +430,19 @@ impl SortedPhaseItem for Transparent3d {
     }
 
     #[inline]
-    fn sort(items: &mut [Self]) {
-        radsort::sort_by_key(items, |item| item.distance);
+    fn sort(items: &mut IndexMap<(Entity, MainEntity), Transparent3d, EntityHash>) {
+        items.sort_by_key(|_, item| item.sort_key());
+    }
+
+    fn recalculate_sort_keys(
+        items: &mut IndexMap<(Entity, MainEntity), Self, EntityHash>,
+        view: &ExtractedView,
+    ) {
+        // Determine the distance to the view for each phase item.
+        let rangefinder = view.rangefinder3d();
+        for item in items.values_mut() {
+            item.distance = item.sorting_info.sort_distance(&rangefinder);
+        }
     }
 
     #[inline]
@@ -445,6 +458,38 @@ impl CachedRenderPipelinePhaseItem for Transparent3d {
     }
 }
 
+/// Information needed to perform a depth sort.
+#[derive(Clone, Copy)]
+pub enum TransparentSortingInfo3d {
+    /// No information is needed because this object should always appear on top
+    /// of other objects.
+    AlwaysOnTop,
+    /// Information needed to sort the object based on distance to the view.
+    Sorted {
+        /// The center of the mesh.
+        ///
+        /// This is the point that is used to sort.
+        mesh_center: Vec3,
+        /// An additional value that's artificially added to the distance before
+        /// sorting.
+        depth_bias: f32,
+    },
+}
+
+impl TransparentSortingInfo3d {
+    /// Calculates the value used for distance sorting for an item.
+    /// For [`Self::AlwaysOnTop`], this is [`f32::NEG_INFINITY`].
+    pub fn sort_distance(&self, rangefinder: &ViewRangefinder3d) -> f32 {
+        match *self {
+            TransparentSortingInfo3d::AlwaysOnTop => f32::NEG_INFINITY,
+            TransparentSortingInfo3d::Sorted {
+                mesh_center,
+                depth_bias,
+            } => rangefinder.distance(&mesh_center) + depth_bias,
+        }
+    }
+}
+
 pub fn extract_core_3d_camera_phases(
     mut opaque_3d_phases: ResMut<ViewBinnedRenderPhases<Opaque3d>>,
     mut alpha_mask_3d_phases: ResMut<ViewBinnedRenderPhases<AlphaMask3d>>,
@@ -473,7 +518,7 @@ pub fn extract_core_3d_camera_phases(
 
         opaque_3d_phases.prepare_for_new_frame(retained_view_entity, gpu_preprocessing_mode);
         alpha_mask_3d_phases.prepare_for_new_frame(retained_view_entity, gpu_preprocessing_mode);
-        transparent_3d_phases.insert_or_clear(retained_view_entity);
+        transparent_3d_phases.prepare_for_new_frame(retained_view_entity);
 
         live_entities.insert(retained_view_entity);
     }
diff --git a/crates/bevy_gizmos_render/Cargo.toml b/crates/bevy_gizmos_render/Cargo.toml
index a9bbea1ebca3b..07d03b3b3c172 100644
--- a/crates/bevy_gizmos_render/Cargo.toml
+++ b/crates/bevy_gizmos_render/Cargo.toml
@@ -29,6 +29,7 @@ bevy_render = { path = "../bevy_render", version = "0.19.0-dev" }
 bevy_utils = { path = "../bevy_utils", version = "0.19.0-dev" }
 bevy_core_pipeline = { path = "../bevy_core_pipeline", version = "0.19.0-dev" }
 bevy_transform = { path = "../bevy_transform", version = "0.19.0-dev" }
+bevy_reflect = { path = "../bevy_reflect", version = "0.19.0-dev" }
 
 # other
 bytemuck = "1.0"
diff --git a/crates/bevy_gizmos_render/src/lib.rs b/crates/bevy_gizmos_render/src/lib.rs
index d7a735e83c674..6b5fececa4864 100755
--- a/crates/bevy_gizmos_render/src/lib.rs
+++ b/crates/bevy_gizmos_render/src/lib.rs
@@ -26,11 +26,14 @@ mod pipeline_3d;
 
 use bevy_app::{App, Plugin};
 use bevy_ecs::{
+    name::Name,
     resource::Resource,
     schedule::{IntoScheduleConfigs, SystemSet},
     system::Res,
+    world::{FromWorld, World},
 };
 use bevy_math::Affine3Ext;
+use bevy_reflect::Reflect;
 
 use {bevy_gizmos::config::GizmoMeshConfig, bevy_mesh::VertexBufferLayout};
 
@@ -40,6 +43,7 @@ use {
     bevy_ecs::{
         component::Component,
         entity::Entity,
+        prelude::ReflectResource,
         query::ROQueryItem,
         system::{
             lifetimeless::{Read, SRes},
@@ -62,8 +66,9 @@ use {
     bytemuck::cast_slice,
 };
 
-use bevy_render::render_resource::{
-    BindGroupLayoutDescriptor, PipelineCache, VertexAttribute, VertexStepMode,
+use bevy_render::{
+    extract_resource::{ExtractResource, ExtractResourcePlugin},
+    render_resource::{BindGroupLayoutDescriptor, PipelineCache, VertexAttribute, VertexStepMode},
 };
 
 use bevy_gizmos::{
@@ -86,7 +91,9 @@ impl Plugin for GizmoRenderPlugin {
         }
 
         app.add_plugins(UniformComponentPlugin::<LineGizmoUniform>::default())
-            .add_plugins(RenderAssetPlugin::<GpuLineGizmo>::default());
+            .add_plugins(RenderAssetPlugin::<GpuLineGizmo>::default())
+            .add_plugins(ExtractResourcePlugin::<LineGizmoEntities>::default())
+            .init_resource::<LineGizmoEntities>();
 
         if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
             render_app.add_systems(RenderStartup, init_line_gizmo_uniform_bind_group_layout);
@@ -602,3 +609,34 @@ fn line_joint_gizmo_vertex_buffer_layouts() -> Vec<VertexBufferLayout> {
         color_layout.clone(),
     ]
 }
+
+/// Holds entities that the gizmo render phase items are associated with.
+///
+/// Sorted render phases require each phase item to be associated with an entity
+/// in the main world. Immediate mode gizmos don't have entities normally, so we
+/// need to create entities for them. There are three potential phase items that
+/// can be added and therefore three potential entities.
+#[derive(Clone, Reflect, Resource, ExtractResource)]
+#[reflect(Clone, Resource)]
+pub struct LineGizmoEntities {
+    /// An entity that regular line phase items are associated with.
+    pub line_gizmo_renderer: MainEntity,
+    /// An entity that line strip phase items are associated with.
+    pub line_strip_gizmo_renderer: MainEntity,
+    /// An entity that line joint phase items are associated with.
+    pub line_joint_gizmo_renderer: MainEntity,
+}
+
+impl FromWorld for LineGizmoEntities {
+    fn from_world(world: &mut World) -> LineGizmoEntities {
+        // Create the entities for line gizmo phase items to be associated with.
+        let line_gizmo_renderer = world.spawn(Name::new("LineGizmoRenderer")).id();
+        let line_strip_gizmo_renderer = world.spawn(Name::new("LineStripGizmoRenderer")).id();
+        let line_joint_gizmo_renderer = world.spawn(Name::new("LineJointGizmoRenderer")).id();
+        LineGizmoEntities {
+            line_gizmo_renderer: MainEntity::from(line_gizmo_renderer),
+            line_strip_gizmo_renderer: MainEntity::from(line_strip_gizmo_renderer),
+            line_joint_gizmo_renderer: MainEntity::from(line_joint_gizmo_renderer),
+        }
+    }
+}
diff --git a/crates/bevy_gizmos_render/src/pipeline_2d.rs b/crates/bevy_gizmos_render/src/pipeline_2d.rs
index 2a29d18de24cf..b58aee360d011 100644
--- a/crates/bevy_gizmos_render/src/pipeline_2d.rs
+++ b/crates/bevy_gizmos_render/src/pipeline_2d.rs
@@ -1,7 +1,7 @@
 use crate::{
     init_line_gizmo_uniform_bind_group_layout, line_gizmo_vertex_buffer_layouts,
     line_joint_gizmo_vertex_buffer_layouts, DrawLineGizmo, DrawLineJointGizmo, GizmoRenderSystems,
-    GpuLineGizmo, LineGizmoUniformBindgroupLayout, SetLineGizmoBindGroup,
+    GpuLineGizmo, LineGizmoEntities, LineGizmoUniformBindgroupLayout, SetLineGizmoBindGroup,
 };
 use bevy_app::{App, Plugin};
 use bevy_asset::{load_embedded_asset, AssetServer, Handle};
@@ -17,6 +17,7 @@ use bevy_ecs::{
 };
 use bevy_image::BevyDefault as _;
 use bevy_math::FloatOrd;
+use bevy_render::RenderStartup;
 use bevy_render::{
     render_asset::{prepare_assets, RenderAssets},
     render_phase::{
@@ -27,7 +28,6 @@ use bevy_render::{
     view::{ExtractedView, Msaa, ViewTarget},
     Render, RenderApp, RenderSystems,
 };
-use bevy_render::{sync_world::MainEntity, RenderStartup};
 use bevy_shader::Shader;
 use bevy_sprite_render::{
     init_mesh_2d_pipeline, Mesh2dPipeline, Mesh2dPipelineKey, SetMesh2dViewBindGroup,
@@ -294,8 +294,9 @@ fn queue_line_and_joint_gizmos_2d(
     mut line_gizmo_pipelines: ResMut<SpecializedRenderPipelines<LineGizmoPipeline>>,
     mut line_joint_gizmo_pipelines: ResMut<SpecializedRenderPipelines<LineJointGizmoPipeline>>,
     pipeline_cache: Res<PipelineCache>,
-    line_gizmos: Query<(Entity, &MainEntity, &GizmoMeshConfig)>,
+    line_gizmos: Query<(Entity, &GizmoMeshConfig)>,
     line_gizmo_assets: Res<RenderAssets<GpuLineGizmo>>,
+    line_gizmo_entities: Res<LineGizmoEntities>,
     mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent2d>>,
     mut views: Query<(&ExtractedView, &Msaa, Option<&RenderLayers>)>,
 ) {
@@ -319,7 +320,7 @@ fn queue_line_and_joint_gizmos_2d(
             | Mesh2dPipelineKey::from_hdr(view.hdr);
 
         let render_layers = render_layers.unwrap_or_default();
-        for (entity, main_entity, config) in &line_gizmos {
+        for (entity, config) in &line_gizmos {
             if !config.render_layers.intersects(render_layers) {
                 continue;
             }
@@ -339,8 +340,8 @@ fn queue_line_and_joint_gizmos_2d(
                         line_style: config.line_style,
                     },
                 );
-                transparent_phase.add(Transparent2d {
-                    entity: (entity, *main_entity),
+                transparent_phase.add_transient(Transparent2d {
+                    entity: (entity, line_gizmo_entities.line_gizmo_renderer),
                     draw_function,
                     pipeline,
                     sort_key: FloatOrd(f32::INFINITY),
@@ -361,8 +362,8 @@ fn queue_line_and_joint_gizmos_2d(
                         line_style: config.line_style,
                     },
                 );
-                transparent_phase.add(Transparent2d {
-                    entity: (entity, *main_entity),
+                transparent_phase.add_transient(Transparent2d {
+                    entity: (entity, line_gizmo_entities.line_strip_gizmo_renderer),
                     draw_function: draw_line_function_strip,
                     pipeline,
                     sort_key: FloatOrd(f32::INFINITY),
@@ -386,8 +387,8 @@ fn queue_line_and_joint_gizmos_2d(
                     joints: config.line_joints,
                 },
             );
-            transparent_phase.add(Transparent2d {
-                entity: (entity, *main_entity),
+            transparent_phase.add_transient(Transparent2d {
+                entity: (entity, line_gizmo_entities.line_joint_gizmo_renderer),
                 draw_function: draw_line_joint_function,
                 pipeline,
                 sort_key: FloatOrd(f32::INFINITY),
diff --git a/crates/bevy_gizmos_render/src/pipeline_3d.rs b/crates/bevy_gizmos_render/src/pipeline_3d.rs
index 176d73940effc..3db5999f41aa2 100644
--- a/crates/bevy_gizmos_render/src/pipeline_3d.rs
+++ b/crates/bevy_gizmos_render/src/pipeline_3d.rs
@@ -1,12 +1,12 @@
 use crate::{
     init_line_gizmo_uniform_bind_group_layout, line_gizmo_vertex_buffer_layouts,
     line_joint_gizmo_vertex_buffer_layouts, DrawLineGizmo, DrawLineJointGizmo, GizmoRenderSystems,
-    GpuLineGizmo, LineGizmoUniformBindgroupLayout, SetLineGizmoBindGroup,
+    GpuLineGizmo, LineGizmoEntities, LineGizmoUniformBindgroupLayout, SetLineGizmoBindGroup,
 };
 use bevy_app::{App, Plugin};
 use bevy_asset::{load_embedded_asset, AssetServer, Handle};
 use bevy_camera::visibility::RenderLayers;
-use bevy_core_pipeline::core_3d::{Transparent3d, CORE_3D_DEPTH_FORMAT};
+use bevy_core_pipeline::core_3d::{Transparent3d, TransparentSortingInfo3d, CORE_3D_DEPTH_FORMAT};
 use bevy_gizmos::config::{GizmoLineJoint, GizmoLineStyle, GizmoMeshConfig};
 
 use bevy_ecs::{
@@ -287,11 +287,12 @@ fn queue_line_gizmos_3d(
     draw_functions: Res<DrawFunctions<Transparent3d>>,
     mut pipeline: ResMut<LineGizmoPipeline>,
     pipeline_cache: Res<PipelineCache>,
-    line_gizmos: Query<(Entity, &MainEntity, &GizmoMeshConfig)>,
+    line_gizmos: Query<(Entity, &GizmoMeshConfig)>,
     line_gizmo_assets: Res<RenderAssets<GpuLineGizmo>>,
     mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent3d>>,
     views: Query<(&ExtractedView, Option<&RenderLayers>)>,
     view_key_cache: Res<ViewKeyCache>,
+    line_gizmo_entities: Res<LineGizmoEntities>,
 ) -> Result<(), BevyError> {
     let draw_function = draw_functions.read().get_id::<DrawLineGizmo3d>().unwrap();
     let draw_function_strip = draw_functions
@@ -311,7 +312,7 @@ fn queue_line_gizmos_3d(
             continue;
         };
 
-        for (entity, main_entity, config) in &line_gizmos {
+        for (entity, config) in &line_gizmos {
             if !config.render_layers.intersects(render_layers) {
                 continue;
             }
@@ -330,8 +331,9 @@ fn queue_line_gizmos_3d(
                         line_style: config.line_style,
                     },
                 )?;
-                transparent_phase.add(Transparent3d {
-                    entity: (entity, *main_entity),
+                transparent_phase.add_transient(Transparent3d {
+                    sorting_info: TransparentSortingInfo3d::AlwaysOnTop,
+                    entity: (entity, line_gizmo_entities.line_gizmo_renderer),
                     draw_function,
                     pipeline,
                     distance: 0.,
@@ -351,8 +353,9 @@ fn queue_line_gizmos_3d(
                         line_style: config.line_style,
                     },
                 )?;
-                transparent_phase.add(Transparent3d {
-                    entity: (entity, *main_entity),
+                transparent_phase.add_transient(Transparent3d {
+                    sorting_info: TransparentSortingInfo3d::AlwaysOnTop,
+                    entity: (entity, line_gizmo_entities.line_strip_gizmo_renderer),
                     draw_function: draw_function_strip,
                     pipeline,
                     distance: 0.,
@@ -377,6 +380,7 @@ fn queue_line_joint_gizmos_3d(
     mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent3d>>,
     views: Query<(&ExtractedView, Option<&RenderLayers>)>,
     view_key_cache: Res<ViewKeyCache>,
+    line_gizmo_entities: Res<LineGizmoEntities>,
 ) {
     let draw_function = draw_functions
         .read()
@@ -395,7 +399,7 @@ fn queue_line_joint_gizmos_3d(
             continue;
         };
 
-        for (entity, main_entity, config) in &line_gizmos {
+        for (entity, _, config) in &line_gizmos {
             if !config.render_layers.intersects(render_layers) {
                 continue;
             }
@@ -418,8 +422,9 @@ fn queue_line_joint_gizmos_3d(
                 },
             );
 
-            transparent_phase.add(Transparent3d {
-                entity: (entity, *main_entity),
+            transparent_phase.add_transient(Transparent3d {
+                sorting_info: TransparentSortingInfo3d::AlwaysOnTop,
+                entity: (entity, line_gizmo_entities.line_joint_gizmo_renderer),
                 draw_function,
                 pipeline,
                 distance: 0.,
diff --git a/crates/bevy_light/src/lib.rs b/crates/bevy_light/src/lib.rs
index f9acc99f4c3d0..8393915ce91ef 100644
--- a/crates/bevy_light/src/lib.rs
+++ b/crates/bevy_light/src/lib.rs
@@ -23,7 +23,7 @@ use bevy_mesh::Mesh3d;
 use bevy_reflect::prelude::*;
 use bevy_transform::{components::GlobalTransform, TransformSystems};
 use bevy_utils::Parallel;
-use core::ops::DerefMut;
+use core::{mem, ops::DerefMut};
 
 pub mod cluster;
 pub use cluster::ClusteredDecal;
@@ -317,22 +317,6 @@ pub enum SimulationLightSystems {
     CheckLightVisibility,
 }
 
-fn shrink_entities(visible_entities: &mut Vec<Entity>) {
-    // Check that visible entities capacity() is no more than two times greater than len()
-    let capacity = visible_entities.capacity();
-    let reserved = capacity
-        .checked_div(visible_entities.len())
-        .map_or(0, |reserve| {
-            if reserve > 2 {
-                capacity / (reserve / 2)
-            } else {
-                capacity
-            }
-        });
-
-    visible_entities.shrink_to(reserved);
-}
-
 /// Updates the visibility for [`DirectionalLight`]s so that shadow map rendering can work.
 pub fn check_dir_light_mesh_visibility(
     mut commands: Commands,
@@ -376,7 +360,6 @@ pub fn check_dir_light_mesh_visibility(
             match frusta.frusta.get(view) {
                 Some(view_frusta) => {
                     cascade_view_entities.resize(view_frusta.len(), Default::default());
-                    cascade_view_entities.iter_mut().for_each(|x| x.clear());
                 }
                 None => views_to_remove.push(*view),
             };
@@ -394,6 +377,7 @@ pub fn check_dir_light_mesh_visibility(
 
         // NOTE: If shadow mapping is disabled for the light then it must have no visible entities
         if !directional_light.shadow_maps_enabled || !light_view_visibility.get() {
+            visible_entities.entities.clear();
             continue;
         }
 
@@ -463,30 +447,28 @@ pub fn check_dir_light_mesh_visibility(
                 },
             );
             // collect entities from parallel queue
-            for entities in view_visible_entities_queue.iter_mut() {
-                visible_entities
-                    .entities
-                    .get_mut(view)
-                    .unwrap()
-                    .iter_mut()
-                    .zip(entities.iter_mut())
-                    .for_each(|(dst, source)| {
-                        dst.append(source);
-                    });
-            }
-        }
-
-        for (_, cascade_view_entities) in &mut visible_entities.entities {
-            cascade_view_entities
+            for (view_dest_index, view_dest) in visible_entities
+                .entities
+                .get_mut(view)
+                .unwrap()
                 .iter_mut()
-                .map(DerefMut::deref_mut)
-                .for_each(shrink_entities);
+                .enumerate()
+            {
+                view_dest.entities.clear();
+                for thread_entity_queue in view_visible_entities_queue.iter_mut() {
+                    view_dest
+                        .entities
+                        .append(&mut thread_entity_queue[view_dest_index]);
+                }
+                view_dest.shrink();
+                view_dest.entities.sort_unstable();
+            }
         }
     }
 
     // Defer marking view visibility so this system can run in parallel with check_point_light_mesh_visibility
     // TODO: use resource to avoid unnecessary memory alloc
-    let mut defer_queue = core::mem::take(defer_visible_entities_queue.deref_mut());
+    let mut defer_queue = mem::take(defer_visible_entities_queue.deref_mut());
     commands.queue(move |world: &mut World| {
         let mut query = world.query::<&mut ViewVisibility>();
         for entities in defer_queue.iter_mut() {
@@ -556,15 +538,6 @@ pub fn check_point_light_mesh_visibility(
                 maybe_view_mask,
             )) = point_lights.get_mut(light_entity)
             {
-                if cubemap_visible_entities
-                    .iter()
-                    .any(|visible_entities| !visible_entities.is_empty())
-                {
-                    for visible_entities in cubemap_visible_entities.iter_mut() {
-                        visible_entities.entities.clear();
-                    }
-                }
-
                 // NOTE: If shadow mapping is disabled for the light then it must have no visible entities
                 if !point_light.shadow_maps_enabled {
                     continue;
@@ -635,16 +608,17 @@ pub fn check_point_light_mesh_visibility(
                     },
                 );
 
-                for entities in cubemap_visible_entities_queue.iter_mut() {
-                    for (dst, source) in
-                        cubemap_visible_entities.iter_mut().zip(entities.iter_mut())
-                    {
-                        dst.entities.append(source);
+                // Collect the entities from each parallel queue.
+                for (view_dest_index, view_dest) in cubemap_visible_entities.iter_mut().enumerate()
+                {
+                    view_dest.entities.clear();
+                    for thread_entity_queue in cubemap_visible_entities_queue.iter_mut() {
+                        view_dest
+                            .entities
+                            .append(&mut thread_entity_queue[view_dest_index]);
                     }
-                }
-
-                for visible_entities in cubemap_visible_entities.iter_mut() {
-                    shrink_entities(visible_entities);
+                    view_dest.shrink();
+                    view_dest.entities.sort_unstable();
                 }
             }
 
@@ -652,8 +626,6 @@ pub fn check_point_light_mesh_visibility(
             if let Ok((point_light, transform, frustum, mut visible_entities, maybe_view_mask)) =
                 spot_lights.get_mut(light_entity)
             {
-                visible_entities.clear();
-
                 // NOTE: If shadow mapping is disabled for the light then it must have no visible entities
                 if !point_light.shadow_maps_enabled {
                     continue;
@@ -717,11 +689,12 @@ pub fn check_point_light_mesh_visibility(
                     },
                 );
 
-                for entities in spot_visible_entities_queue.iter_mut() {
-                    visible_entities.append(entities);
+                visible_entities.entities.clear();
+                for thread_entity_queue in spot_visible_entities_queue.iter_mut() {
+                    visible_entities.entities.append(thread_entity_queue);
                 }
-
-                shrink_entities(visible_entities.deref_mut());
+                visible_entities.shrink();
+                visible_entities.entities.sort_unstable();
             }
         }
     }
diff --git a/crates/bevy_pbr/Cargo.toml b/crates/bevy_pbr/Cargo.toml
index b37eebfb9cfa2..69e91a513ee4a 100644
--- a/crates/bevy_pbr/Cargo.toml
+++ b/crates/bevy_pbr/Cargo.toml
@@ -82,12 +82,12 @@ itertools = { version = "0.14", optional = true }
 bitvec = { version = "1", optional = true }
 # direct dependency required for derive macro
 bytemuck = { version = "1", features = ["derive", "must_cast"] }
-radsort = "0.1"
 smallvec = { version = "1", default-features = false }
 nonmax = "0.5"
 static_assertions = "1"
 tracing = { version = "0.1", default-features = false, features = ["std"] }
 offset-allocator = "0.2"
+indexmap = { version = "2" }
 
 [lints]
 workspace = true
diff --git a/crates/bevy_pbr/src/components.rs b/crates/bevy_pbr/src/components.rs
index bdb5a36d010d4..d675b0beb3823 100644
--- a/crates/bevy_pbr/src/components.rs
+++ b/crates/bevy_pbr/src/components.rs
@@ -1,16 +1,8 @@
-use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::component::Component;
-use bevy_ecs::entity::{Entity, EntityHashMap};
+use bevy_ecs::entity::EntityHashMap;
 use bevy_ecs::reflect::ReflectComponent;
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
-use bevy_render::sync_world::MainEntity;
-
-#[derive(Component, Clone, Debug, Default, Reflect, Deref, DerefMut)]
-#[reflect(Component, Debug, Default, Clone)]
-pub struct RenderVisibleMeshEntities {
-    #[reflect(ignore, clone)]
-    pub entities: Vec<(Entity, MainEntity)>,
-}
+use bevy_render::view::RenderVisibleMeshEntities;
 
 #[derive(Component, Clone, Debug, Default, Reflect)]
 #[reflect(Component, Debug, Default, Clone)]
diff --git a/crates/bevy_pbr/src/material.rs b/crates/bevy_pbr/src/material.rs
index 220bd8fb7c264..b947c7076df24 100644
--- a/crates/bevy_pbr/src/material.rs
+++ b/crates/bevy_pbr/src/material.rs
@@ -6,6 +6,7 @@ use alloc::sync::Arc;
 use bevy_asset::prelude::AssetChanged;
 use bevy_asset::{Asset, AssetEventSystems, AssetId, AssetServer, UntypedAssetId};
 use bevy_camera::visibility::ViewVisibility;
+use bevy_core_pipeline::core_3d::TransparentSortingInfo3d;
 use bevy_core_pipeline::deferred::{AlphaMask3dDeferred, Opaque3dDeferred};
 use bevy_core_pipeline::prepass::{AlphaMask3dPrepass, Opaque3dPrepass};
 use bevy_core_pipeline::{
@@ -15,7 +16,7 @@ use bevy_core_pipeline::{
 };
 use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::change_detection::Tick;
-use bevy_ecs::system::{SystemChangeTick, SystemParam};
+use bevy_ecs::system::SystemParam;
 use bevy_ecs::{
     prelude::*,
     system::{
@@ -36,7 +37,7 @@ use bevy_platform::collections::{HashMap, HashSet};
 use bevy_platform::hash::FixedHasher;
 use bevy_reflect::std_traits::ReflectDefault;
 use bevy_reflect::Reflect;
-use bevy_render::camera::extract_cameras;
+use bevy_render::camera::{DirtySpecializationSystems, DirtySpecializations, PendingQueues};
 use bevy_render::erased_render_asset::{
     ErasedRenderAsset, ErasedRenderAssetPlugin, ErasedRenderAssets, PrepareAssetError,
 };
@@ -287,17 +288,19 @@ impl Plugin for MaterialsPlugin {
         app.add_plugins((PrepassPipelinePlugin, PrepassPlugin::new(self.debug_flags)));
         if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
             render_app
-                .init_resource::<EntitySpecializationTicks>()
                 .init_resource::<SpecializedMaterialPipelineCache>()
                 .init_resource::<SpecializedMeshPipelines<MaterialPipelineSpecializer>>()
                 .init_resource::<LightKeyCache>()
-                .init_resource::<LightSpecializationTicks>()
                 .init_resource::<SpecializedShadowMaterialPipelineCache>()
                 .init_resource::<DrawFunctions<Shadow>>()
                 .init_resource::<RenderMaterialInstances>()
                 .allow_ambiguous_resource::<RenderMaterialInstances>()
                 .init_resource::<MaterialBindGroupAllocators>()
                 .allow_ambiguous_resource::<MaterialBindGroupAllocators>()
+                .init_resource::<PendingMeshMaterialQueues>()
+                .allow_ambiguous_resource::<PendingMeshMaterialQueues>()
+                .init_resource::<PendingShadowQueues>()
+                .allow_ambiguous_resource::<PendingShadowQueues>()
                 .add_render_command::<Shadow, DrawPrepass>()
                 .add_render_command::<Shadow, DrawDepthOnlyPrepass>()
                 .add_render_command::<Transparent3d, DrawMaterial>()
@@ -375,14 +378,6 @@ where
                     .after(mark_3d_meshes_as_changed_if_their_assets_changed),
             );
 
-        if M::enable_shadows() {
-            app.add_systems(
-                PostUpdate,
-                check_light_entities_needing_specialization::<M>
-                    .after(check_entities_needing_specialization::<M>),
-            );
-        }
-
         if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
             render_app
                 .add_systems(RenderStartup, add_material_bind_group_allocator::<M>)
@@ -393,19 +388,10 @@ where
                         early_sweep_material_instances::<M>
                             .after(MaterialExtractionSystems)
                             .before(late_sweep_material_instances),
-                        // See the comments in
-                        // `sweep_entities_needing_specialization` for an
-                        // explanation of why the systems are ordered this way.
                         extract_entities_needs_specialization::<M>
-                            .in_set(MaterialExtractEntitiesNeedingSpecializationSystems)
-                            .ambiguous_with(MaterialExtractEntitiesNeedingSpecializationSystems),
-                        sweep_entities_needing_specialization::<M>
-                            .in_set(MaterialSweepEntitiesNeedingSpecializationSystems)
-                            .ambiguous_with(MaterialSweepEntitiesNeedingSpecializationSystems)
-                            .after(MaterialExtractEntitiesNeedingSpecializationSystems)
-                            .after(MaterialExtractionSystems)
-                            .after(extract_cameras)
-                            .before(late_sweep_material_instances),
+                            .in_set(DirtySpecializationSystems::CheckForChanges),
+                        extract_entities_that_need_specializations_removed::<M>
+                            .in_set(DirtySpecializationSystems::CheckForRemovals),
                     ),
                 );
         }
@@ -615,16 +601,6 @@ pub struct RenderMaterialInstance {
 #[derive(SystemSet, Clone, PartialEq, Eq, Debug, Hash)]
 pub struct MaterialExtractionSystems;
 
-/// A [`SystemSet`] that contains all `extract_entities_needs_specialization`
-/// systems.
-#[derive(SystemSet, Clone, PartialEq, Eq, Debug, Hash)]
-pub struct MaterialExtractEntitiesNeedingSpecializationSystems;
-
-/// A [`SystemSet`] that contains all `sweep_entities_needing_specialization`
-/// systems.
-#[derive(SystemSet, Clone, PartialEq, Eq, Debug, Hash)]
-pub struct MaterialSweepEntitiesNeedingSpecializationSystems;
-
 pub const fn alpha_mode_pipeline_key(alpha_mode: AlphaMode, msaa: &Msaa) -> MeshPipelineKey {
     match alpha_mode {
         // Premultiplied and Add share the same pipeline key
@@ -775,170 +751,59 @@ pub fn late_sweep_material_instances(
 
 pub fn extract_entities_needs_specialization<M>(
     entities_needing_specialization: Extract<Res<EntitiesNeedingSpecialization<M>>>,
-    mut entity_specialization_ticks: ResMut<EntitySpecializationTicks>,
-    render_material_instances: Res<RenderMaterialInstances>,
-    ticks: SystemChangeTick,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
 ) where
     M: Material,
 {
-    for entity in entities_needing_specialization.iter() {
-        // Update the entity's specialization tick with this run's tick
-        entity_specialization_ticks.insert(
-            (*entity).into(),
-            EntitySpecializationTickPair {
-                system_tick: ticks.this_run(),
-                material_instances_tick: render_material_instances.current_change_tick,
-            },
-        );
+    // Drain the list of entities needing specialization from the main world
+    // into the render-world `DirtySpecializations` table.
+    for entity in entities_needing_specialization.changed.iter() {
+        dirty_specializations
+            .changed_renderables
+            .insert(MainEntity::from(*entity));
     }
 }
 
-/// A system that runs after all instances of
-/// [`extract_entities_needs_specialization`] in order to delete specialization
-/// ticks for entities that are no longer renderable.
-///
-/// We delete entities from the [`EntitySpecializationTicks`] table *after*
-/// updating it with newly-discovered renderable entities in order to handle the
-/// case in which a single entity changes material types. If we na√Øvely removed
-/// entities from that table when their [`MeshMaterial3d<M>`] components were
-/// removed, and an entity changed material types, we might end up adding a new
-/// set of [`EntitySpecializationTickPair`] for the new material and then
-/// deleting it upon detecting the removed component for the old material.
-/// Deferring [`sweep_entities_needing_specialization`] to the end allows us to
-/// detect the case in which another material type updated the entity
-/// specialization ticks this frame and avoid deleting it if so.
-pub fn sweep_entities_needing_specialization<M>(
-    mut entity_specialization_ticks: ResMut<EntitySpecializationTicks>,
-    mut removed_mesh_material_components: Extract<RemovedComponents<MeshMaterial3d<M>>>,
-    mut specialized_material_pipeline_cache: ResMut<SpecializedMaterialPipelineCache>,
-    mut specialized_prepass_material_pipeline_cache: Option<
-        ResMut<SpecializedPrepassMaterialPipelineCache>,
-    >,
-    mut specialized_shadow_material_pipeline_cache: Option<
-        ResMut<SpecializedShadowMaterialPipelineCache>,
-    >,
-    render_material_instances: Res<RenderMaterialInstances>,
-    views: Query<&ExtractedView>,
+/// A system that adds entities that were judged to need their specializations
+/// removed to the appropriate table in [`DirtySpecializations`].
+pub fn extract_entities_that_need_specializations_removed<M>(
+    entities_needing_specialization: Extract<Res<EntitiesNeedingSpecialization<M>>>,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
 ) where
     M: Material,
 {
-    // Clean up any despawned entities, we do this first in case the removed material was re-added
-    // the same frame, thus will appear both in the removed components list and have been added to
-    // the `EntitiesNeedingSpecialization` collection by triggering the `Changed` filter
-    //
-    // Additionally, we need to make sure that we are careful about materials
-    // that could have changed type, e.g. from a `StandardMaterial` to a
-    // `CustomMaterial`, as this will also appear in the removed components
-    // list. As such, we make sure that this system runs after
-    // `extract_entities_needs_specialization` so that the entity specialization
-    // tick bookkeeping has already been done, and we can check if the entity's
-    // tick was updated this frame.
-    for entity in removed_mesh_material_components.read() {
-        // If the entity's specialization tick was updated this frame, that
-        // means that that entity changed materials this frame. Don't remove the
-        // entity from the table in that case.
-        if entity_specialization_ticks
-            .get(&MainEntity::from(entity))
-            .is_some_and(|ticks| {
-                ticks.material_instances_tick == render_material_instances.current_change_tick
-            })
-        {
-            continue;
-        }
-
-        entity_specialization_ticks.remove(&MainEntity::from(entity));
-        for view in views {
-            if let Some(cache) =
-                specialized_material_pipeline_cache.get_mut(&view.retained_view_entity)
-            {
-                cache.remove(&MainEntity::from(entity));
-            }
-            if let Some(cache) = specialized_prepass_material_pipeline_cache
-                .as_mut()
-                .and_then(|c| c.get_mut(&view.retained_view_entity))
-            {
-                cache.remove(&MainEntity::from(entity));
-            }
-            if let Some(cache) = specialized_shadow_material_pipeline_cache
-                .as_mut()
-                .and_then(|c| c.get_mut(&view.retained_view_entity))
-            {
-                cache.remove(&MainEntity::from(entity));
-            }
-        }
+    for entity in entities_needing_specialization.removed.iter() {
+        dirty_specializations
+            .removed_renderables
+            .insert(MainEntity::from(*entity));
     }
 }
 
-#[derive(Resource, Deref, DerefMut, Clone, Debug)]
+/// Temporarily stores entities that were determined to either need their
+/// specialized pipelines updated or to have their specialized pipelines
+/// removed.
+#[derive(Resource, Clone, Debug)]
 pub struct EntitiesNeedingSpecialization<M> {
-    #[deref]
-    pub entities: Vec<Entity>,
+    /// Entities that need to have their pipelines updated.
+    pub changed: Vec<Entity>,
+    /// Entities that need to have their pipelines removed, *unless* they also
+    /// appear in [`Self::changed`].
+    ///
+    /// We can't determine which entities truly need to have their pipelines removed until all
+    pub removed: Vec<Entity>,
     _marker: PhantomData<M>,
 }
 
 impl<M> Default for EntitiesNeedingSpecialization<M> {
     fn default() -> Self {
         Self {
-            entities: Default::default(),
+            changed: Default::default(),
+            removed: Default::default(),
             _marker: Default::default(),
         }
     }
 }
 
-/// Stores ticks specifying the last time Bevy specialized the pipelines of each
-/// entity.
-///
-/// Every entity that has a mesh and material must be present in this table,
-/// even if that mesh isn't visible.
-#[derive(Resource, Deref, DerefMut, Default, Clone, Debug)]
-pub struct EntitySpecializationTicks {
-    /// A mapping from each main entity to ticks that specify the last time this
-    /// entity's pipeline was specialized.
-    ///
-    /// Every entity that has a mesh and material must be present in this table,
-    /// even if that mesh isn't visible.
-    #[deref]
-    pub entities: MainEntityHashMap<EntitySpecializationTickPair>,
-}
-
-/// Ticks that specify the last time an entity's pipeline was specialized.
-///
-/// We need two different types of ticks here for a subtle reason. First, we
-/// need the [`Self::system_tick`], which maps to Bevy's [`SystemChangeTick`],
-/// because that's what we use in `specialize_material_meshes` to check
-/// whether pipelines need specialization. But we also need
-/// [`Self::material_instances_tick`], which maps to the
-/// [`RenderMaterialInstances::current_change_tick`]. That's because the latter
-/// only changes once per frame, which is a guarantee we need to handle the
-/// following case:
-///
-/// 1. The app removes material A from a mesh and replaces it with material B.
-///    Both A and B are of different [`Material`] types entirely.
-///
-/// 2. [`extract_entities_needs_specialization`] runs for material B and marks
-///    the mesh as up to date by recording the current tick.
-///
-/// 3. [`sweep_entities_needing_specialization`] runs for material A and checks
-///    to ensure it's safe to remove the [`EntitySpecializationTickPair`] for the mesh
-///    from the [`EntitySpecializationTicks`]. To do this, it needs to know
-///    whether [`extract_entities_needs_specialization`] for some *different*
-///    material (in this case, material B) ran earlier in the frame and updated the
-///    change tick, and to skip removing the [`EntitySpecializationTickPair`] if so.
-///    It can't reliably use the [`Self::system_tick`] to determine this because
-///    the [`SystemChangeTick`] can be updated multiple times in the same frame.
-///    Instead, it needs a type of tick that's updated only once per frame, after
-///    all materials' versions of [`sweep_entities_needing_specialization`] have
-///    run. The [`RenderMaterialInstances`] tick satisfies this criterion, and so
-///    that's what [`sweep_entities_needing_specialization`] uses.
-#[derive(Clone, Copy, Debug)]
-pub struct EntitySpecializationTickPair {
-    /// The standard Bevy system tick.
-    pub system_tick: Tick,
-    /// The tick in [`RenderMaterialInstances`], which is updated in
-    /// `late_sweep_material_instances`.
-    pub material_instances_tick: Tick,
-}
-
 /// Stores the [`SpecializedMaterialViewPipelineCache`] for each view.
 #[derive(Resource, Deref, DerefMut, Default)]
 pub struct SpecializedMaterialPipelineCache {
@@ -953,9 +818,11 @@ pub struct SpecializedMaterialPipelineCache {
 pub struct SpecializedMaterialViewPipelineCache {
     // material entity -> (tick, pipeline_id)
     #[deref]
-    map: MainEntityHashMap<(Tick, CachedRenderPipelineId)>,
+    map: MainEntityHashMap<CachedRenderPipelineId>,
 }
 
+/// Finds 3D entities that have changed in such a way as to potentially require
+/// specialization and adds them to the [`EntitiesNeedingSpecialization`] list.
 pub fn check_entities_needing_specialization<M>(
     needs_specialization: Query<
         Entity,
@@ -971,16 +838,34 @@ pub fn check_entities_needing_specialization<M>(
     >,
     mut par_local: Local<Parallel<Vec<Entity>>>,
     mut entities_needing_specialization: ResMut<EntitiesNeedingSpecialization<M>>,
+    mut removed_mesh_3d_components: RemovedComponents<Mesh3d>,
+    mut removed_mesh_material_3d_components: RemovedComponents<MeshMaterial3d<M>>,
 ) where
     M: Material,
 {
-    entities_needing_specialization.clear();
+    entities_needing_specialization.changed.clear();
+    entities_needing_specialization.removed.clear();
 
+    // Gather all entities that need their specializations regenerated.
     needs_specialization
         .par_iter()
         .for_each(|entity| par_local.borrow_local_mut().push(entity));
+    par_local.drain_into(&mut entities_needing_specialization.changed);
 
-    par_local.drain_into(&mut entities_needing_specialization);
+    // All entities that removed their `Mesh3d` or `MeshMaterial3d` components
+    // need to have their specializations removed as well.
+    //
+    // It's possible that `Mesh3d` was removed and re-added in the same frame,
+    // but we don't have to handle that situation specially here, because
+    // `specialize_material_meshes` processes specialization removals before
+    // additions. So, if the pipeline specialization gets spuriously removed,
+    // it'll just be immediately re-added again, which is harmless.
+    for entity in removed_mesh_3d_components
+        .read()
+        .chain(removed_mesh_material_3d_components.read())
+    {
+        entities_needing_specialization.removed.push(entity);
+    }
 }
 
 pub(crate) struct SpecializationWorkItem {
@@ -992,6 +877,13 @@ pub(crate) struct SpecializationWorkItem {
     material_type_id: TypeId,
 }
 
+/// Holds all entities with mesh materials that couldn't be specialized and/or
+/// queued because their materials hadn't loaded yet.
+///
+/// See the [`PendingQueues`] documentation for more information.
+#[derive(Default, Deref, DerefMut, Resource)]
+pub struct PendingMeshMaterialQueues(pub PendingQueues);
+
 #[derive(SystemParam)]
 pub(crate) struct SpecializeMaterialMeshesSystemParam<'w, 's> {
     render_meshes: Res<'w, RenderAssets<RenderMesh>>,
@@ -1006,10 +898,9 @@ pub(crate) struct SpecializeMaterialMeshesSystemParam<'w, 's> {
     transparent_render_phases: Res<'w, ViewSortedRenderPhases<Transparent3d>>,
     views: Query<'w, 's, (&'static ExtractedView, &'static RenderVisibleEntities)>,
     view_key_cache: Res<'w, ViewKeyCache>,
-    entity_specialization_ticks: Res<'w, EntitySpecializationTicks>,
-    view_specialization_ticks: Res<'w, ViewSpecializationTicks>,
-    specialized_material_pipeline_cache: Res<'w, SpecializedMaterialPipelineCache>,
-    this_run: SystemChangeTick,
+    specialized_material_pipeline_cache: ResMut<'w, SpecializedMaterialPipelineCache>,
+    pending_mesh_material_queues: ResMut<'w, PendingMeshMaterialQueues>,
+    dirty_specializations: Res<'w, DirtySpecializations>,
 }
 
 pub(crate) fn specialize_material_meshes(
@@ -1021,8 +912,6 @@ pub(crate) fn specialize_material_meshes(
     work_items.clear();
     all_views.clear();
 
-    let this_run;
-
     {
         let SpecializeMaterialMeshesSystemParam {
             render_meshes,
@@ -1037,13 +926,10 @@ pub(crate) fn specialize_material_meshes(
             transparent_render_phases,
             views,
             view_key_cache,
-            entity_specialization_ticks,
-            view_specialization_ticks,
-            specialized_material_pipeline_cache,
-            this_run: system_change_tick,
-        } = state.get(world);
-
-        this_run = system_change_tick.this_run();
+            mut specialized_material_pipeline_cache,
+            mut pending_mesh_material_queues,
+            dirty_specializations,
+        } = state.get_mut(world);
 
         for (view, visible_entities) in &views {
             all_views.insert(view.retained_view_entity);
@@ -1060,41 +946,80 @@ pub(crate) fn specialize_material_meshes(
                 continue;
             };
 
-            let view_tick = view_specialization_ticks
-                .get(&view.retained_view_entity)
-                .unwrap();
-            let view_specialized_material_pipeline_cache =
-                specialized_material_pipeline_cache.get(&view.retained_view_entity);
+            let Some(render_visible_mesh_entities) = visible_entities.get::<Mesh3d>() else {
+                continue;
+            };
+
+            let mut maybe_specialized_material_pipeline_cache =
+                specialized_material_pipeline_cache.get_mut(&view.retained_view_entity);
+
+            // Remove cached pipeline IDs corresponding to entities that either
+            // have been removed or need to be re-specialized.
+            if let Some(ref mut specialized_material_pipeline_cache) =
+                maybe_specialized_material_pipeline_cache
+            {
+                if dirty_specializations
+                    .must_wipe_specializations_for_view(view.retained_view_entity)
+                {
+                    specialized_material_pipeline_cache.clear();
+                } else {
+                    for &renderable_entity in dirty_specializations.iter_to_despecialize() {
+                        specialized_material_pipeline_cache.remove(&renderable_entity);
+                    }
+                }
+            }
+
+            // Initialize the pending queues.
+            let view_pending_mesh_material_queues =
+                pending_mesh_material_queues.prepare_for_new_frame(view.retained_view_entity);
+
+            // Now process all meshes that need to be specialized.
+            for (render_entity, visible_entity) in dirty_specializations.iter_to_specialize(
+                view.retained_view_entity,
+                render_visible_mesh_entities,
+                &view_pending_mesh_material_queues.prev_frame,
+            ) {
+                if maybe_specialized_material_pipeline_cache
+                    .as_ref()
+                    .is_some_and(|specialized_material_pipeline_cache| {
+                        specialized_material_pipeline_cache.contains_key(visible_entity)
+                    })
+                {
+                    continue;
+                }
 
-            for (_, visible_entity) in visible_entities.iter::<Mesh3d>() {
                 let Some(material_instance) =
                     render_material_instances.instances.get(visible_entity)
                 else {
+                    // We couldn't fetch the material instance, probably because
+                    // the material hasn't been loaded yet. Add the entity to
+                    // the list of pending mesh materials and bail.
+                    view_pending_mesh_material_queues
+                        .current_frame
+                        .insert((*render_entity, *visible_entity));
                     continue;
                 };
                 let Some(mesh_instance) =
                     render_mesh_instances.render_mesh_queue_data(*visible_entity)
                 else {
+                    // We couldn't fetch the mesh, probably because it hasn't
+                    // been loaded yet. Add the entity to the list of pending
+                    // mesh materials and bail.
+                    view_pending_mesh_material_queues
+                        .current_frame
+                        .insert((*render_entity, *visible_entity));
                     continue;
                 };
-                let entity_tick = entity_specialization_ticks
-                    .get(visible_entity)
-                    .unwrap()
-                    .system_tick;
-                let last_specialized_tick = view_specialized_material_pipeline_cache
-                    .and_then(|cache| cache.get(visible_entity))
-                    .map(|(tick, _)| *tick);
-                let needs_specialization = last_specialized_tick.is_none_or(|tick| {
-                    view_tick.is_newer_than(tick, this_run)
-                        || entity_tick.is_newer_than(tick, this_run)
-                });
-                if !needs_specialization {
-                    continue;
-                }
                 let Some(mesh) = render_meshes.get(mesh_instance.mesh_asset_id) else {
                     continue;
                 };
                 let Some(material) = render_materials.get(material_instance.asset_id) else {
+                    // We couldn't fetch the material, probably because the
+                    // material hasn't been loaded yet. Add the entity to the
+                    // list of pending mesh materials and bail.
+                    view_pending_mesh_material_queues
+                        .current_frame
+                        .insert((*render_entity, *visible_entity));
                     continue;
                 };
 
@@ -1147,6 +1072,8 @@ pub(crate) fn specialize_material_meshes(
                 });
             }
         }
+
+        pending_mesh_material_queues.expire_stale_views(&all_views);
     }
 
     for item in work_items.drain(..) {
@@ -1165,7 +1092,7 @@ pub(crate) fn specialize_material_meshes(
                     .resource_mut::<SpecializedMaterialPipelineCache>()
                     .entry(item.retained_view_entity)
                     .or_default()
-                    .insert(item.visible_entity, (this_run, pipeline_id));
+                    .insert(item.visible_entity, pipeline_id);
             }
             Err(err) => error!("{}", err),
         }
@@ -1188,8 +1115,10 @@ pub fn queue_material_meshes(
     mut alpha_mask_render_phases: ResMut<ViewBinnedRenderPhases<AlphaMask3d>>,
     mut transmissive_render_phases: ResMut<ViewSortedRenderPhases<Transmissive3d>>,
     mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent3d>>,
+    mut pending_mesh_material_queues: ResMut<PendingMeshMaterialQueues>,
     views: Query<(&ExtractedView, &RenderVisibleEntities)>,
     specialized_material_pipeline_cache: ResMut<SpecializedMaterialPipelineCache>,
+    dirty_specializations: Res<DirtySpecializations>,
 ) {
     for (view, visible_entities) in &views {
         let (
@@ -1213,31 +1142,68 @@ pub fn queue_material_meshes(
             continue;
         };
 
-        let rangefinder = view.rangefinder3d();
-        for (render_entity, visible_entity) in visible_entities.iter::<Mesh3d>() {
-            let Some((current_change_tick, pipeline_id)) = view_specialized_material_pipeline_cache
+        let Some(render_visible_mesh_entities) = visible_entities.get::<Mesh3d>() else {
+            continue;
+        };
+
+        // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+        for &main_entity in dirty_specializations
+            .iter_to_dequeue(view.retained_view_entity, render_visible_mesh_entities)
+        {
+            opaque_phase.remove(main_entity);
+            alpha_mask_phase.remove(main_entity);
+            transmissive_phase.remove(Entity::PLACEHOLDER, main_entity);
+            transparent_phase.remove(Entity::PLACEHOLDER, main_entity);
+        }
+
+        // Fetch the pending mesh material queues for this view.
+        let view_pending_mesh_material_queues = pending_mesh_material_queues
+            .get_mut(&view.retained_view_entity)
+            .expect(
+                "View pending mesh material queues should have been created in \
+                 `specialize_material_meshes`",
+            );
+
+        // Now iterate through all newly-visible entities and those needing respecialization.
+        for (render_entity, visible_entity) in dirty_specializations.iter_to_queue(
+            view.retained_view_entity,
+            render_visible_mesh_entities,
+            &view_pending_mesh_material_queues.prev_frame,
+        ) {
+            let Some(pipeline_id) = view_specialized_material_pipeline_cache
                 .get(visible_entity)
-                .map(|(current_change_tick, pipeline_id)| (*current_change_tick, *pipeline_id))
+                .copied()
             else {
                 continue;
             };
 
-            // Skip the entity if it's cached in a bin and up to date.
-            if opaque_phase.validate_cached_entity(*visible_entity, current_change_tick)
-                || alpha_mask_phase.validate_cached_entity(*visible_entity, current_change_tick)
-            {
-                continue;
-            }
-
             let Some(material_instance) = render_material_instances.instances.get(visible_entity)
             else {
+                // We couldn't fetch the material, probably because the material
+                // hasn't been loaded yet. Add the entity to the list of pending
+                // mesh materials and bail.
+                view_pending_mesh_material_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*visible_entity)
             else {
+                // We couldn't fetch the mesh, probably because it hasn't been
+                // loaded yet. Add the entity to the list of pending mesh
+                // materials and bail.
+                view_pending_mesh_material_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(material) = render_materials.get(material_instance.asset_id) else {
+                // We couldn't fetch the material, probably because the material
+                // hasn't been loaded yet. Add the entity to the list of pending
+                // mesh materials and bail.
+                view_pending_mesh_material_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
 
@@ -1246,8 +1212,6 @@ pub fn queue_material_meshes(
 
             match material.properties.render_phase_type {
                 RenderPhaseType::Transmissive => {
-                    let distance = rangefinder.distance(&mesh_instance.center)
-                        + material.properties.depth_bias;
                     let Some(draw_function) = material
                         .properties
                         .get_draw_function(MainPassTransmissiveDrawFunction)
@@ -1255,13 +1219,18 @@ pub fn queue_material_meshes(
                         continue;
                     };
                     transmissive_phase.add(Transmissive3d {
-                        entity: (*render_entity, *visible_entity),
+                        sorting_info: TransparentSortingInfo3d::Sorted {
+                            mesh_center: mesh_instance.center,
+                            depth_bias: material.properties.depth_bias,
+                        },
+                        entity: (Entity::PLACEHOLDER, *visible_entity),
                         draw_function,
                         pipeline: pipeline_id,
-                        distance,
                         batch_range: 0..1,
                         extra_index: PhaseItemExtraIndex::None,
                         indexed: index_slab.is_some(),
+                        // Filled in later.
+                        distance: 0.0,
                     });
                 }
                 RenderPhaseType::Opaque => {
@@ -1270,7 +1239,7 @@ pub fn queue_material_meshes(
                         // a bin, we still want to update its cache entry. That
                         // way, we know we don't need to re-examine it in future
                         // frames.
-                        opaque_phase.update_cache(*visible_entity, None, current_change_tick);
+                        opaque_phase.update_cache(*visible_entity, None);
                         continue;
                     }
                     let Some(draw_function) = material
@@ -1293,13 +1262,12 @@ pub fn queue_material_meshes(
                     opaque_phase.add(
                         batch_set_key,
                         bin_key,
-                        (*render_entity, *visible_entity),
+                        (Entity::PLACEHOLDER, *visible_entity),
                         mesh_instance.current_uniform_index,
                         BinnedRenderPhaseType::mesh(
                             mesh_instance.should_batch(),
                             &gpu_preprocessing_support,
                         ),
-                        current_change_tick,
                     );
                 }
                 // Alpha mask
@@ -1323,18 +1291,15 @@ pub fn queue_material_meshes(
                     alpha_mask_phase.add(
                         batch_set_key,
                         bin_key,
-                        (*render_entity, *visible_entity),
+                        (Entity::PLACEHOLDER, *visible_entity),
                         mesh_instance.current_uniform_index,
                         BinnedRenderPhaseType::mesh(
                             mesh_instance.should_batch(),
                             &gpu_preprocessing_support,
                         ),
-                        current_change_tick,
                     );
                 }
                 RenderPhaseType::Transparent => {
-                    let distance = rangefinder.distance(&mesh_instance.center)
-                        + material.properties.depth_bias;
                     let Some(draw_function) = material
                         .properties
                         .get_draw_function(MainPassTransparentDrawFunction)
@@ -1342,13 +1307,18 @@ pub fn queue_material_meshes(
                         continue;
                     };
                     transparent_phase.add(Transparent3d {
-                        entity: (*render_entity, *visible_entity),
+                        sorting_info: TransparentSortingInfo3d::Sorted {
+                            mesh_center: mesh_instance.center,
+                            depth_bias: material.properties.depth_bias,
+                        },
+                        entity: (Entity::PLACEHOLDER, *visible_entity),
                         draw_function,
                         pipeline: pipeline_id,
-                        distance,
                         batch_range: 0..1,
                         extra_index: PhaseItemExtraIndex::None,
                         indexed: index_slab.is_some(),
+                        // Filled in later.
+                        distance: 0.0,
                     });
                 }
             }
diff --git a/crates/bevy_pbr/src/prepass/mod.rs b/crates/bevy_pbr/src/prepass/mod.rs
index 2fcb482cb26b4..581fb02878648 100644
--- a/crates/bevy_pbr/src/prepass/mod.rs
+++ b/crates/bevy_pbr/src/prepass/mod.rs
@@ -4,12 +4,11 @@ use crate::{
     alpha_mode_pipeline_key, binding_arrays_are_usable, buffer_layout,
     collect_meshes_for_gpu_building, init_material_pipeline, set_mesh_motion_vector_flags,
     setup_morph_and_skinning_defs, skin, DeferredAlphaMaskDrawFunction, DeferredFragmentShader,
-    DeferredOpaqueDrawFunction, DeferredVertexShader, DrawMesh, EntitySpecializationTicks,
-    MaterialPipeline, MeshLayouts, MeshPipeline, MeshPipelineKey, PreparedMaterial,
-    PrepassAlphaMaskDrawFunction, PrepassFragmentShader, PrepassOpaqueDepthOnlyDrawFunction,
-    PrepassOpaqueDrawFunction, PrepassVertexShader, RenderLightmaps, RenderMaterialInstances,
-    RenderMeshInstanceFlags, RenderMeshInstances, SetMaterialBindGroup, SetMeshBindGroup,
-    ShadowView,
+    DeferredOpaqueDrawFunction, DeferredVertexShader, DrawMesh, MaterialPipeline, MeshLayouts,
+    MeshPipeline, MeshPipelineKey, PreparedMaterial, PrepassAlphaMaskDrawFunction,
+    PrepassFragmentShader, PrepassOpaqueDepthOnlyDrawFunction, PrepassOpaqueDrawFunction,
+    PrepassVertexShader, RenderLightmaps, RenderMaterialInstances, RenderMeshInstanceFlags,
+    RenderMeshInstances, SetMaterialBindGroup, SetMeshBindGroup, ShadowView,
 };
 use bevy_app::{App, Plugin, PreUpdate};
 use bevy_asset::{embedded_asset, load_embedded_asset, AssetServer, Handle};
@@ -30,6 +29,7 @@ use bevy_math::{Affine3A, Mat4, Vec4};
 use bevy_mesh::{Mesh, Mesh3d, MeshVertexBufferLayoutRef};
 use bevy_render::{
     batching::gpu_preprocessing::GpuPreprocessingSupport,
+    camera::{DirtySpecializations, PendingQueues},
     globals::{GlobalsBuffer, GlobalsUniform},
     mesh::{allocator::MeshAllocator, RenderMesh},
     render_asset::{prepare_assets, RenderAssets},
@@ -157,9 +157,9 @@ impl Plugin for PrepassPlugin {
         }
 
         render_app
-            .init_resource::<ViewPrepassSpecializationTicks>()
             .init_resource::<ViewKeyPrepassCache>()
             .init_resource::<SpecializedPrepassMaterialPipelineCache>()
+            .init_resource::<PendingPrepassMeshMaterialQueues>()
             .add_render_command::<Opaque3dPrepass, DrawPrepass>()
             .add_render_command::<Opaque3dPrepass, DrawDepthOnlyPrepass>()
             .add_render_command::<AlphaMask3dPrepass, DrawPrepass>()
@@ -790,12 +790,9 @@ pub struct SpecializedPrepassMaterialViewPipelineCache {
 #[derive(Resource, Deref, DerefMut, Default, Clone)]
 pub struct ViewKeyPrepassCache(HashMap<RetainedViewEntity, MeshPipelineKey>);
 
-#[derive(Resource, Deref, DerefMut, Default, Clone)]
-pub struct ViewPrepassSpecializationTicks(HashMap<RetainedViewEntity, Tick>);
-
 pub fn check_prepass_views_need_specialization(
     mut view_key_cache: ResMut<ViewKeyPrepassCache>,
-    mut view_specialization_ticks: ResMut<ViewPrepassSpecializationTicks>,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
     mut views: Query<(
         &ExtractedView,
         &Msaa,
@@ -803,7 +800,6 @@ pub fn check_prepass_views_need_specialization(
         Option<&NormalPrepass>,
         Option<&MotionVectorPrepass>,
     )>,
-    ticks: SystemChangeTick,
 ) {
     for (view, msaa, depth_prepass, normal_prepass, motion_vector_prepass) in views.iter_mut() {
         let mut view_key = MeshPipelineKey::from_msaa_samples(msaa.samples());
@@ -820,11 +816,15 @@ pub fn check_prepass_views_need_specialization(
         if let Some(current_key) = view_key_cache.get_mut(&view.retained_view_entity) {
             if *current_key != view_key {
                 view_key_cache.insert(view.retained_view_entity, view_key);
-                view_specialization_ticks.insert(view.retained_view_entity, ticks.this_run());
+                dirty_specializations
+                    .views
+                    .insert(view.retained_view_entity);
             }
         } else {
             view_key_cache.insert(view.retained_view_entity, view_key);
-            view_specialization_ticks.insert(view.retained_view_entity, ticks.this_run());
+            dirty_specializations
+                .views
+                .insert(view.retained_view_entity);
         }
     }
 }
@@ -838,6 +838,13 @@ pub(crate) struct PrepassSpecializationWorkItem {
     material_type_id: TypeId,
 }
 
+/// Holds all entities with mesh materials for which the prepass couldn't be
+/// specialized and/or queued because their materials hadn't loaded yet.
+///
+/// See the [`PendingQueues`] documentation for more information.
+#[derive(Default, Deref, DerefMut, Resource)]
+pub struct PendingPrepassMeshMaterialQueues(pub PendingQueues);
+
 #[derive(SystemParam)]
 pub(crate) struct SpecializePrepassSystemParam<'w, 's> {
     render_meshes: Res<'w, RenderAssets<RenderMesh>>,
@@ -862,9 +869,10 @@ pub(crate) struct SpecializePrepassSystemParam<'w, 's> {
     alpha_mask_prepass_render_phases: Res<'w, ViewBinnedRenderPhases<AlphaMask3dPrepass>>,
     opaque_deferred_render_phases: Res<'w, ViewBinnedRenderPhases<Opaque3dDeferred>>,
     alpha_mask_deferred_render_phases: Res<'w, ViewBinnedRenderPhases<AlphaMask3dDeferred>>,
-    specialized_material_pipeline_cache: Res<'w, SpecializedPrepassMaterialPipelineCache>,
-    view_specialization_ticks: Res<'w, ViewPrepassSpecializationTicks>,
-    entity_specialization_ticks: Res<'w, EntitySpecializationTicks>,
+    specialized_prepass_material_pipeline_cache:
+        ResMut<'w, SpecializedPrepassMaterialPipelineCache>,
+    pending_prepass_mesh_material_queues: ResMut<'w, PendingPrepassMeshMaterialQueues>,
+    dirty_specializations: Res<'w, DirtySpecializations>,
     this_run: SystemChangeTick,
 }
 
@@ -895,11 +903,11 @@ pub(crate) fn specialize_prepass_material_meshes(
             alpha_mask_prepass_render_phases,
             opaque_deferred_render_phases,
             alpha_mask_deferred_render_phases,
-            specialized_material_pipeline_cache,
-            view_specialization_ticks,
-            entity_specialization_ticks,
+            mut specialized_prepass_material_pipeline_cache,
+            mut pending_prepass_mesh_material_queues,
+            dirty_specializations,
             this_run: system_change_tick,
-        } = state.get(world);
+        } = state.get_mut(world);
 
         this_run = system_change_tick.this_run();
 
@@ -922,38 +930,79 @@ pub(crate) fn specialize_prepass_material_meshes(
 
             all_views.insert(extracted_view.retained_view_entity);
 
-            let view_tick = view_specialization_ticks
-                .get(&extracted_view.retained_view_entity)
-                .unwrap();
-            let view_specialized_material_pipeline_cache =
-                specialized_material_pipeline_cache.get(&extracted_view.retained_view_entity);
+            let Some(render_visible_mesh_entities) = visible_entities.get::<Mesh3d>() else {
+                continue;
+            };
+
+            // Fetch the pending mesh material queues for this view.
+            let view_pending_prepass_mesh_material_queues = pending_prepass_mesh_material_queues
+                .prepare_for_new_frame(extracted_view.retained_view_entity);
+
+            // Initialize the pending queues.
+            let mut maybe_specialized_prepass_material_pipeline_cache =
+                specialized_prepass_material_pipeline_cache
+                    .get_mut(&extracted_view.retained_view_entity);
+
+            // Remove cached pipeline IDs corresponding to entities that
+            // either have been removed or need to be respecialized.
+            if let Some(ref mut specialized_prepass_material_pipeline_cache) =
+                maybe_specialized_prepass_material_pipeline_cache
+            {
+                if dirty_specializations
+                    .must_wipe_specializations_for_view(extracted_view.retained_view_entity)
+                {
+                    specialized_prepass_material_pipeline_cache.clear();
+                } else {
+                    for &renderable_entity in dirty_specializations.iter_to_despecialize() {
+                        specialized_prepass_material_pipeline_cache.remove(&renderable_entity);
+                    }
+                }
+            }
+
+            // Now process all meshes that need to be specialized.
+            for (render_entity, visible_entity) in dirty_specializations.iter_to_specialize(
+                extracted_view.retained_view_entity,
+                render_visible_mesh_entities,
+                &view_pending_prepass_mesh_material_queues.prev_frame,
+            ) {
+                if maybe_specialized_prepass_material_pipeline_cache
+                    .as_ref()
+                    .is_some_and(|specialized_prepass_material_pipeline_cache| {
+                        specialized_prepass_material_pipeline_cache.contains_key(visible_entity)
+                    })
+                {
+                    continue;
+                }
 
-            for (_, visible_entity) in visible_entities.iter::<Mesh3d>() {
                 let Some(material_instance) =
                     render_material_instances.instances.get(visible_entity)
                 else {
+                    // We couldn't fetch the material instance, probably because
+                    // the material hasn't been loaded yet. Add the entity to
+                    // the list of pending prepass mesh materials and bail.
+                    view_pending_prepass_mesh_material_queues
+                        .current_frame
+                        .insert((*render_entity, *visible_entity));
                     continue;
                 };
                 let Some(mesh_instance) =
                     render_mesh_instances.render_mesh_queue_data(*visible_entity)
                 else {
+                    // We couldn't fetch the mesh, probably because it hasn't
+                    // loaded yet. Add the entity to the list of pending prepass
+                    // mesh materials and bail.
+                    view_pending_prepass_mesh_material_queues
+                        .current_frame
+                        .insert((*render_entity, *visible_entity));
                     continue;
                 };
-                let entity_tick = entity_specialization_ticks
-                    .get(visible_entity)
-                    .unwrap()
-                    .system_tick;
-                let last_specialized_tick = view_specialized_material_pipeline_cache
-                    .and_then(|cache| cache.get(visible_entity))
-                    .map(|(tick, _, _)| *tick);
-                let needs_specialization = last_specialized_tick.is_none_or(|tick| {
-                    view_tick.is_newer_than(tick, this_run)
-                        || entity_tick.is_newer_than(tick, this_run)
-                });
-                if !needs_specialization {
-                    continue;
-                }
                 let Some(material) = render_materials.get(material_instance.asset_id) else {
+                    // We couldn't fetch the material instance, probably because
+                    // the material hasn't been loaded yet. Add the entity to
+                    // the list of pending prepass mesh materials and bail.
+                    view_pending_prepass_mesh_material_queues
+                        .current_frame
+                        .insert((*render_entity, *visible_entity));
                     continue;
                 };
                 if !material.properties.prepass_enabled {
@@ -1048,6 +1097,8 @@ pub(crate) fn specialize_prepass_material_meshes(
                 });
             }
         }
+
+        pending_prepass_mesh_material_queues.expire_stale_views(&all_views);
     }
 
     let depth_clip_control_supported = world
@@ -1136,6 +1187,8 @@ pub fn queue_prepass_material_meshes(
     mut alpha_mask_deferred_render_phases: ResMut<ViewBinnedRenderPhases<AlphaMask3dDeferred>>,
     views: Query<(&ExtractedView, &RenderVisibleEntities)>,
     specialized_material_pipeline_cache: Res<SpecializedPrepassMaterialPipelineCache>,
+    mut pending_prepass_mesh_material_queues: ResMut<PendingPrepassMeshMaterialQueues>,
+    dirty_specializations: Res<DirtySpecializations>,
 ) {
     for (extracted_view, visible_entities) in &views {
         let (
@@ -1165,35 +1218,76 @@ pub fn queue_prepass_material_meshes(
             continue;
         }
 
-        for (render_entity, visible_entity) in visible_entities.iter::<Mesh3d>() {
-            let Some(&(current_change_tick, pipeline_id, draw_function)) =
+        let Some(render_visible_mesh_entities) = visible_entities.get::<Mesh3d>() else {
+            continue;
+        };
+
+        // Fetch the pending mesh material queues for this view.
+        let view_pending_prepass_mesh_material_queues = pending_prepass_mesh_material_queues
+            .get_mut(&extracted_view.retained_view_entity)
+            .expect(
+                "View pending prepass mesh material queues should have been created in \
+                 `specialize_prepass_material_meshes`",
+            );
+
+        // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+        for &main_entity in dirty_specializations.iter_to_dequeue(
+            extracted_view.retained_view_entity,
+            render_visible_mesh_entities,
+        ) {
+            if let Some(ref mut opaque_phase) = opaque_phase {
+                opaque_phase.remove(main_entity);
+            }
+            if let Some(ref mut alpha_mask_phase) = alpha_mask_phase {
+                alpha_mask_phase.remove(main_entity);
+            }
+            if let Some(ref mut opaque_deferred_phase) = opaque_deferred_phase {
+                opaque_deferred_phase.remove(main_entity);
+            }
+            if let Some(ref mut alpha_mask_deferred_phase) = alpha_mask_deferred_phase {
+                alpha_mask_deferred_phase.remove(main_entity);
+            }
+        }
+
+        // Now iterate through all newly-visible entities and those needing respecialization.
+        for (render_entity, visible_entity) in dirty_specializations.iter_to_queue(
+            extracted_view.retained_view_entity,
+            render_visible_mesh_entities,
+            &view_pending_prepass_mesh_material_queues.prev_frame,
+        ) {
+            let Some(&(_, pipeline_id, draw_function)) =
                 view_specialized_material_pipeline_cache.get(visible_entity)
             else {
                 continue;
             };
 
-            // Skip the entity if it's cached in a bin and up to date.
-            if opaque_phase.as_mut().is_some_and(|phase| {
-                phase.validate_cached_entity(*visible_entity, current_change_tick)
-            }) || alpha_mask_phase.as_mut().is_some_and(|phase| {
-                phase.validate_cached_entity(*visible_entity, current_change_tick)
-            }) || opaque_deferred_phase.as_mut().is_some_and(|phase| {
-                phase.validate_cached_entity(*visible_entity, current_change_tick)
-            }) || alpha_mask_deferred_phase.as_mut().is_some_and(|phase| {
-                phase.validate_cached_entity(*visible_entity, current_change_tick)
-            }) {
-                continue;
-            }
-
             let Some(material_instance) = render_material_instances.instances.get(visible_entity)
             else {
+                // We couldn't fetch the material, probably because the material
+                // hasn't been loaded yet. Add the entity to the list of pending
+                // prepass mesh materials and bail.
+                view_pending_prepass_mesh_material_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*visible_entity)
             else {
+                // We couldn't fetch the mesh, probably because it hasn't been
+                // loaded yet. Add the entity to the list of pending prepass
+                // mesh materials and bail.
+                view_pending_prepass_mesh_material_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(material) = render_materials.get(material_instance.asset_id) else {
+                // We couldn't fetch the material, probably because the material
+                // hasn't been loaded yet. Add the entity to the list of pending
+                // prepass mesh materials and bail.
+                view_pending_prepass_mesh_material_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let (vertex_slab, index_slab) = mesh_allocator.mesh_slabs(&mesh_instance.mesh_asset_id);
@@ -1224,7 +1318,6 @@ pub fn queue_prepass_material_meshes(
                                 mesh_instance.should_batch(),
                                 &gpu_preprocessing_support,
                             ),
-                            current_change_tick,
                         );
                     } else if let Some(opaque_phase) = opaque_phase.as_mut() {
                         let depth_only_draw_function = material
@@ -1253,7 +1346,6 @@ pub fn queue_prepass_material_meshes(
                                 mesh_instance.should_batch(),
                                 &gpu_preprocessing_support,
                             ),
-                            current_change_tick,
                         );
                     }
                 }
@@ -1276,7 +1368,6 @@ pub fn queue_prepass_material_meshes(
                                 mesh_instance.should_batch(),
                                 &gpu_preprocessing_support,
                             ),
-                            current_change_tick,
                         );
                     } else if let Some(alpha_mask_phase) = alpha_mask_phase.as_mut() {
                         alpha_mask_phase.add(
@@ -1296,7 +1387,6 @@ pub fn queue_prepass_material_meshes(
                                 mesh_instance.should_batch(),
                                 &gpu_preprocessing_support,
                             ),
-                            current_change_tick,
                         );
                     }
                 }
diff --git a/crates/bevy_pbr/src/render/light.rs b/crates/bevy_pbr/src/render/light.rs
index 49ce2087cef0d..65bd3f8ba0c11 100644
--- a/crates/bevy_pbr/src/render/light.rs
+++ b/crates/bevy_pbr/src/render/light.rs
@@ -12,8 +12,6 @@ use bevy_camera::Camera3d;
 use bevy_color::ColorToComponents;
 use bevy_core_pipeline::core_3d::CORE_3D_DEPTH_FORMAT;
 use bevy_derive::{Deref, DerefMut};
-use bevy_ecs::change_detection::Tick;
-use bevy_ecs::system::SystemChangeTick;
 use bevy_ecs::{
     entity::{EntityHashMap, EntityHashSet},
     prelude::*,
@@ -24,8 +22,8 @@ use bevy_light::cluster::assign::{calculate_cluster_factors, ClusterableObjectTy
 use bevy_light::SunDisk;
 use bevy_light::{
     spot_light_clip_from_view, spot_light_world_from_view, AmbientLight, CascadeShadowConfig,
-    Cascades, DirectionalLight, DirectionalLightShadowMap, GlobalAmbientLight, NotShadowCaster,
-    PointLight, PointLightShadowMap, ShadowFilteringMethod, SpotLight, VolumetricLight,
+    Cascades, DirectionalLight, DirectionalLightShadowMap, GlobalAmbientLight, PointLight,
+    PointLightShadowMap, ShadowFilteringMethod, SpotLight, VolumetricLight,
 };
 use bevy_material::{
     key::{ErasedMaterialPipelineKey, ErasedMeshPipelineKey},
@@ -39,11 +37,13 @@ use bevy_math::{
 use bevy_mesh::MeshVertexBufferLayoutRef;
 use bevy_platform::collections::{HashMap, HashSet};
 use bevy_platform::hash::FixedHasher;
+use bevy_render::camera::{DirtySpecializations, PendingQueues};
 use bevy_render::erased_render_asset::ErasedRenderAssets;
 use bevy_render::occlusion_culling::{
     OcclusionCulling, OcclusionCullingSubview, OcclusionCullingSubviewEntities,
 };
 use bevy_render::sync_world::{MainEntityHashMap, MainEntityHashSet};
+use bevy_render::view::RenderVisibleMeshEntities;
 use bevy_render::{
     batching::gpu_preprocessing::{GpuPreprocessingMode, GpuPreprocessingSupport},
     camera::SortedCameras,
@@ -66,8 +66,7 @@ use bevy_render::{
 };
 use bevy_transform::{components::GlobalTransform, prelude::Transform};
 use bevy_utils::default;
-use core::any::TypeId;
-use core::{hash::Hash, ops::Range};
+use core::{any::TypeId, array, hash::Hash, mem, ops::Range};
 use decal::clustered::RenderClusteredDecals;
 #[cfg(feature = "trace")]
 use tracing::info_span;
@@ -372,6 +371,9 @@ pub fn extract_lights(
         >,
     >,
     mapper: Extract<Query<RenderEntity>>,
+    mut existing_render_cascades_visible_entities: Query<&mut RenderCascadesVisibleEntities>,
+    mut existing_render_cubemap_visible_entities: Query<&mut RenderCubemapVisibleEntities>,
+    mut existing_render_visible_mesh_entities: Query<&mut RenderVisibleMeshEntities>,
     (mut removed_point_lights, mut removed_spot_lights, mut removed_directional_lights): (
         Extract<RemovedComponents<PointLight>>,
         Extract<RemovedComponents<SpotLight>>,
@@ -424,14 +426,24 @@ pub fn extract_lights(
             continue;
         }
 
-        let render_cubemap_visible_entities = RenderCubemapVisibleEntities {
-            data: cubemap_visible_entities
-                .iter()
-                .map(|v| create_render_visible_mesh_entities(&mapper, v))
-                .collect::<Vec<_>>()
-                .try_into()
-                .unwrap(),
-        };
+        // Initialize the visible entities for each cubemap face.
+        let mut render_cubemap_visible_entities =
+            match existing_render_cubemap_visible_entities.get_mut(render_entity) {
+                Ok(ref mut existing_cubemap_visible_entities) => {
+                    mem::take(&mut **existing_cubemap_visible_entities)
+                }
+                Err(_) => RenderCubemapVisibleEntities {
+                    data: array::repeat(RenderVisibleMeshEntities::default()),
+                },
+            };
+
+        // Calculate the added and removed entities for each face.
+        for (render_visible_mesh_entities, visible_mesh_entities) in render_cubemap_visible_entities
+            .iter_mut()
+            .zip(cubemap_visible_entities.iter())
+        {
+            render_visible_mesh_entities.update_from(&mapper, &visible_mesh_entities.entities);
+        }
 
         let extracted_point_light = ExtractedPointLight {
             color: point_light.color.into(),
@@ -491,8 +503,14 @@ pub fn extract_lights(
             continue;
         }
 
-        let render_visible_entities =
-            create_render_visible_mesh_entities(&mapper, visible_entities);
+        let mut render_visible_entities =
+            match existing_render_visible_mesh_entities.get_mut(render_entity) {
+                Ok(ref mut existing_render_visible_entities) => {
+                    mem::take(&mut **existing_render_visible_entities)
+                }
+                Err(_) => RenderVisibleMeshEntities::default(),
+            };
+        render_visible_entities.update_from(&mapper, &visible_entities.entities);
 
         let texel_size =
             2.0 * ops::tan(spot_light.outer_angle) / directional_light_shadow_map.size as f32;
@@ -565,7 +583,16 @@ pub fn extract_lights(
         // TODO: update in place instead of reinserting.
         let mut extracted_cascades = EntityHashMap::default();
         let mut extracted_frusta = EntityHashMap::default();
-        let mut cascade_visible_entities = EntityHashMap::default();
+        // Initialize the visible entities set for each cascade.
+        let mut cascade_visible_entities =
+            match existing_render_cascades_visible_entities.get_mut(entity) {
+                Ok(ref mut existing_cascade_visible_entities) => {
+                    mem::take(&mut **existing_cascade_visible_entities)
+                }
+                Err(_) => RenderCascadesVisibleEntities {
+                    entities: EntityHashMap::default(),
+                },
+            };
         for (e, v) in cascades.cascades.iter() {
             if let Ok(entity) = mapper.get(*e) {
                 extracted_cascades.insert(entity, v.clone());
@@ -580,19 +607,37 @@ pub fn extract_lights(
                 break;
             }
         }
-        for (e, v) in visible_entities.entities.iter() {
-            if let Ok(entity) = mapper.get(*e) {
-                cascade_visible_entities.insert(
-                    entity,
-                    v.iter()
-                        .map(|v| create_render_visible_mesh_entities(&mapper, v))
-                        .collect(),
-                );
-            } else {
+        // Calculate the added and removed entities for each cascade.
+        let mut all_cascades_seen = EntityHashSet::default();
+        for (entity, visible_mesh_entities_list) in visible_entities.entities.iter() {
+            let Ok(entity) = mapper.get(*entity) else {
                 break;
+            };
+            all_cascades_seen.insert(entity);
+            let render_visible_mesh_entities_list: &mut Vec<RenderVisibleMeshEntities> =
+                cascade_visible_entities
+                    .entities
+                    .entry(entity)
+                    .or_insert_with(default);
+            render_visible_mesh_entities_list.resize_with(
+                visible_mesh_entities_list.len(),
+                RenderVisibleMeshEntities::default,
+            );
+            for (render_visible_mesh_entities, visible_mesh_entities) in
+                render_visible_mesh_entities_list
+                    .iter_mut()
+                    .zip(visible_mesh_entities_list.iter())
+            {
+                render_visible_mesh_entities.update_from(&mapper, &visible_mesh_entities.entities);
             }
         }
 
+        // Clear out visible entity lists corresponding to cascades that no
+        // longer exist.
+        cascade_visible_entities
+            .entities
+            .retain(|cascade_entity, _| all_cascades_seen.contains(cascade_entity));
+
         commands
             .get_entity(entity)
             .expect("Light entity wasn't synced.")
@@ -622,9 +667,7 @@ pub fn extract_lights(
                     sun_disk_angular_size: sun_disk.unwrap_or_default().angular_size,
                     sun_disk_intensity: sun_disk.unwrap_or_default().intensity,
                 },
-                RenderCascadesVisibleEntities {
-                    entities: cascade_visible_entities,
-                },
+                cascade_visible_entities,
                 MainEntity::from(main_entity),
             ));
     }
@@ -682,21 +725,6 @@ pub fn extract_lights(
     }
 }
 
-fn create_render_visible_mesh_entities(
-    mapper: &Extract<Query<RenderEntity>>,
-    visible_entities: &VisibleMeshEntities,
-) -> RenderVisibleMeshEntities {
-    RenderVisibleMeshEntities {
-        entities: visible_entities
-            .iter()
-            .map(|e| {
-                let render_entity = mapper.get(*e).unwrap_or(Entity::PLACEHOLDER);
-                (render_entity, MainEntity::from(*e))
-            })
-            .collect(),
-    }
-}
-
 #[derive(Component, Default, Deref, DerefMut)]
 /// Component automatically attached to a light entity to track light-view entities
 /// for each view.
@@ -1360,13 +1388,6 @@ pub fn prepare_lights(
                 continue;
             };
 
-            if !light.shadow_maps_enabled {
-                if let Some(entities) = light_view_entities.remove(&entity) {
-                    despawn_entities(&mut commands, entities);
-                }
-                continue;
-            }
-
             let light_index = *global_clusterable_object_meta
                 .entity_to_index
                 .get(&light_entity)
@@ -1629,7 +1650,7 @@ pub fn prepare_lights(
                     .collect()
             });
             if light_view_entities.len() != iter.len() {
-                let entities = core::mem::take(light_view_entities);
+                let entities = mem::take(light_view_entities);
                 despawn_entities(&mut commands, entities);
                 light_view_entities.extend((0..iter.len()).map(|_| commands.spawn_empty().id()));
             }
@@ -1785,32 +1806,9 @@ fn despawn_entities(commands: &mut Commands, entities: Vec<Entity>) {
     });
 }
 
-// These will be extracted in the material extraction, which will also clear the needs_specialization
-// collection.
-pub fn check_light_entities_needing_specialization<M: Material>(
-    needs_specialization: Query<Entity, (With<MeshMaterial3d<M>>, Changed<NotShadowCaster>)>,
-    mesh_materials: Query<Entity, With<MeshMaterial3d<M>>>,
-    mut entities_needing_specialization: ResMut<EntitiesNeedingSpecialization<M>>,
-    mut removed_components: RemovedComponents<NotShadowCaster>,
-) {
-    for entity in &needs_specialization {
-        entities_needing_specialization.push(entity);
-    }
-
-    for removed in removed_components.read() {
-        // Only require specialization if the entity still exists.
-        if mesh_materials.contains(removed) {
-            entities_needing_specialization.entities.push(removed);
-        }
-    }
-}
-
 #[derive(Resource, Deref, DerefMut, Default, Debug, Clone)]
 pub struct LightKeyCache(HashMap<RetainedViewEntity, MeshPipelineKey>);
 
-#[derive(Resource, Deref, DerefMut, Default, Debug, Clone)]
-pub struct LightSpecializationTicks(HashMap<RetainedViewEntity, Tick>);
-
 #[derive(Resource, Deref, DerefMut, Default)]
 pub struct SpecializedShadowMaterialPipelineCache {
     // view light entity -> view pipeline cache
@@ -1821,7 +1819,7 @@ pub struct SpecializedShadowMaterialPipelineCache {
 #[derive(Deref, DerefMut, Default)]
 pub struct SpecializedShadowMaterialViewPipelineCache {
     #[deref]
-    map: MainEntityHashMap<(Tick, CachedRenderPipelineId, DrawFunctionId)>,
+    map: MainEntityHashMap<(CachedRenderPipelineId, DrawFunctionId)>,
 }
 
 pub fn check_views_lights_need_specialization(
@@ -1829,8 +1827,7 @@ pub fn check_views_lights_need_specialization(
     view_light_entities: Query<(&LightEntity, &ExtractedView)>,
     shadow_render_phases: Res<ViewBinnedRenderPhases<Shadow>>,
     mut light_key_cache: ResMut<LightKeyCache>,
-    mut light_specialization_ticks: ResMut<LightSpecializationTicks>,
-    ticks: SystemChangeTick,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
 ) {
     for view_lights in &view_lights {
         for view_light_entity in view_lights.lights.iter().copied() {
@@ -1859,13 +1856,15 @@ pub fn check_views_lights_need_specialization(
             {
                 if *current_key != light_key {
                     light_key_cache.insert(extracted_view_light.retained_view_entity, light_key);
-                    light_specialization_ticks
-                        .insert(extracted_view_light.retained_view_entity, ticks.this_run());
+                    dirty_specializations
+                        .views
+                        .insert(extracted_view_light.retained_view_entity);
                 }
             } else {
                 light_key_cache.insert(extracted_view_light.retained_view_entity, light_key);
-                light_specialization_ticks
-                    .insert(extracted_view_light.retained_view_entity, ticks.this_run());
+                dirty_specializations
+                    .views
+                    .insert(extracted_view_light.retained_view_entity);
             }
         }
     }
@@ -1880,6 +1879,13 @@ pub(crate) struct ShadowSpecializationWorkItem {
     material_type_id: TypeId,
 }
 
+/// Holds all entities with mesh materials for which the shadow pass couldn't be
+/// specialized and/or queued because their materials hadn't loaded yet.
+///
+/// See the [`PendingQueues`] documentation for more information.
+#[derive(Default, Deref, DerefMut, Resource)]
+pub struct PendingShadowQueues(pub PendingQueues);
+
 #[derive(SystemParam)]
 pub(crate) struct SpecializeShadowsSystemParam<'w, 's> {
     render_meshes: Res<'w, RenderAssets<RenderMesh>>,
@@ -1897,10 +1903,9 @@ pub(crate) struct SpecializeShadowsSystemParam<'w, 's> {
     spot_light_entities:
         Query<'w, 's, &'static RenderVisibleMeshEntities, With<ExtractedPointLight>>,
     light_key_cache: Res<'w, LightKeyCache>,
-    specialized_material_pipeline_cache: Res<'w, SpecializedShadowMaterialPipelineCache>,
-    light_specialization_ticks: Res<'w, LightSpecializationTicks>,
-    entity_specialization_ticks: Res<'w, EntitySpecializationTicks>,
-    this_run: SystemChangeTick,
+    specialized_shadow_material_pipeline_cache: ResMut<'w, SpecializedShadowMaterialPipelineCache>,
+    pending_shadow_queues: ResMut<'w, PendingShadowQueues>,
+    dirty_specializations: Res<'w, DirtySpecializations>,
 }
 
 pub(crate) fn specialize_shadows(
@@ -1912,8 +1917,6 @@ pub(crate) fn specialize_shadows(
     work_items.clear();
     all_shadow_views.clear();
 
-    let this_run;
-
     {
         let SpecializeShadowsSystemParam {
             render_meshes,
@@ -1928,13 +1931,10 @@ pub(crate) fn specialize_shadows(
             directional_light_entities,
             spot_light_entities,
             light_key_cache,
-            specialized_material_pipeline_cache,
-            light_specialization_ticks,
-            entity_specialization_ticks,
-            this_run: system_change_tick,
-        } = state.get(world);
-
-        this_run = system_change_tick.this_run();
+            mut specialized_shadow_material_pipeline_cache,
+            mut pending_shadow_queues,
+            dirty_specializations,
+        } = state.get_mut(world);
 
         for (entity, view_lights) in &view_lights {
             for view_light_entity in view_lights.lights.iter().copied() {
@@ -1979,39 +1979,78 @@ pub(crate) fn specialize_shadows(
                         .expect("Failed to get spot light visible entities"),
                 };
 
+                let mut maybe_specialized_shadow_material_pipeline_cache =
+                    specialized_shadow_material_pipeline_cache
+                        .get_mut(&extracted_view_light.retained_view_entity);
+
+                // Remove cached pipeline IDs corresponding to entities that
+                // either have been removed or need to be respecialized.
+                if let Some(ref mut specialized_shadow_material_pipeline_cache) =
+                    maybe_specialized_shadow_material_pipeline_cache
+                {
+                    if dirty_specializations.must_wipe_specializations_for_view(
+                        extracted_view_light.retained_view_entity,
+                    ) {
+                        specialized_shadow_material_pipeline_cache.clear();
+                    } else {
+                        for &renderable_entity in dirty_specializations.iter_to_despecialize() {
+                            specialized_shadow_material_pipeline_cache.remove(&renderable_entity);
+                        }
+                    }
+                }
+
+                // Initialize the pending queues.
+                let view_pending_shadow_queues = pending_shadow_queues
+                    .prepare_for_new_frame(extracted_view_light.retained_view_entity);
+
                 // NOTE: Lights with shadow mapping disabled will have no visible entities
                 // so no meshes will be queued
 
-                let view_tick = light_specialization_ticks
-                    .get(&extracted_view_light.retained_view_entity)
-                    .unwrap();
-                let view_specialized_material_pipeline_cache = specialized_material_pipeline_cache
-                    .get(&extracted_view_light.retained_view_entity);
+                // Now process all shadow meshes that need to be re-specialized.
+                for (render_entity, visible_entity) in dirty_specializations.iter_to_specialize(
+                    extracted_view_light.retained_view_entity,
+                    visible_entities,
+                    &view_pending_shadow_queues.prev_frame,
+                ) {
+                    if maybe_specialized_shadow_material_pipeline_cache
+                        .as_ref()
+                        .is_some_and(|specialized_shadow_material_pipeline_cache| {
+                            specialized_shadow_material_pipeline_cache.contains_key(visible_entity)
+                        })
+                    {
+                        continue;
+                    }
 
-                for (_, visible_entity) in visible_entities.iter().copied() {
                     let Some(material_instance) =
-                        render_material_instances.instances.get(&visible_entity)
+                        render_material_instances.instances.get(visible_entity)
                     else {
+                        // We couldn't fetch the material, probably because the
+                        // material hasn't been loaded yet. Add the entity to
+                        // the list of pending shadows and bail.
+                        view_pending_shadow_queues
+                            .current_frame
+                            .insert((*render_entity, *visible_entity));
                         continue;
                     };
 
                     let Some(mesh_instance) =
-                        render_mesh_instances.render_mesh_queue_data(visible_entity)
+                        render_mesh_instances.render_mesh_queue_data(*visible_entity)
                     else {
+                        // We couldn't fetch the mesh, probably because it
+                        // hasn't loaded yet. Add the entity to the list of
+                        // pending shadows and bail.
+                        view_pending_shadow_queues
+                            .current_frame
+                            .insert((*render_entity, *visible_entity));
                         continue;
                     };
-                    let entity_tick = entity_specialization_ticks.get(&visible_entity).unwrap();
-                    let last_specialized_tick = view_specialized_material_pipeline_cache
-                        .and_then(|cache| cache.get(&visible_entity))
-                        .map(|(tick, _, _)| *tick);
-                    let needs_specialization = last_specialized_tick.is_none_or(|tick| {
-                        view_tick.is_newer_than(tick, this_run)
-                            || entity_tick.system_tick.is_newer_than(tick, this_run)
-                    });
-                    if !needs_specialization {
-                        continue;
-                    }
                     let Some(material) = render_materials.get(material_instance.asset_id) else {
+                        // We couldn't fetch the material, probably because the
+                        // material hasn't been loaded yet. Add the entity to
+                        // the list of pending shadows and bail.
+                        view_pending_shadow_queues
+                            .current_frame
+                            .insert((*render_entity, *visible_entity));
                         continue;
                     };
                     if !material.properties.shadows_enabled {
@@ -2038,7 +2077,7 @@ pub(crate) fn specialize_shadows(
                     // present.
                     if render_lightmaps
                         .render_lightmaps
-                        .contains_key(&visible_entity)
+                        .contains_key(visible_entity)
                     {
                         mesh_key |= MeshPipelineKey::LIGHTMAPPED;
                     }
@@ -2053,7 +2092,7 @@ pub(crate) fn specialize_shadows(
                     };
 
                     work_items.push(ShadowSpecializationWorkItem {
-                        visible_entity,
+                        visible_entity: *visible_entity,
                         retained_view_entity: extracted_view_light.retained_view_entity,
                         mesh_key,
                         layout: mesh.layout.clone(),
@@ -2063,6 +2102,8 @@ pub(crate) fn specialize_shadows(
                 }
             }
         }
+
+        pending_shadow_queues.expire_stale_views(&all_shadow_views);
     }
 
     let depth_clip_control_supported = world
@@ -2105,7 +2146,7 @@ pub(crate) fn specialize_shadows(
                     .resource_mut::<SpecializedShadowMaterialPipelineCache>()
                     .entry(item.retained_view_entity)
                     .or_default()
-                    .insert(item.visible_entity, (this_run, pipeline_id, draw_function));
+                    .insert(item.visible_entity, (pipeline_id, draw_function));
             }
             Err(err) => error!("{}", err),
         }
@@ -2136,6 +2177,8 @@ pub fn queue_shadows(
     >,
     spot_light_entities: Query<&RenderVisibleMeshEntities, With<ExtractedPointLight>>,
     specialized_material_pipeline_cache: Res<SpecializedShadowMaterialPipelineCache>,
+    mut pending_shadow_queues: ResMut<PendingShadowQueues>,
+    dirty_specializations: Res<DirtySpecializations>,
 ) {
     for (entity, view_lights, camera_layers) in &view_lights {
         for view_light_entity in view_lights.lights.iter().copied() {
@@ -2156,6 +2199,13 @@ pub fn queue_shadows(
                 continue;
             };
 
+            // Fetch the pending mesh material queues for this view.
+            let view_pending_shadow_queues = pending_shadow_queues
+                .get_mut(&extracted_view_light.retained_view_entity)
+                .expect(
+                    "View pending shadow queues should have been created in `specialize_shadows`",
+                );
+
             let visible_entities = match light_entity {
                 LightEntity::Directional {
                     light_entity,
@@ -2180,15 +2230,34 @@ pub fn queue_shadows(
                     .expect("Failed to get spot light visible entities"),
             };
 
-            for (entity, main_entity) in visible_entities.iter().copied() {
-                let Some(&(current_change_tick, pipeline_id, draw_function)) =
-                    view_specialized_material_pipeline_cache.get(&main_entity)
+            // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+            for &main_entity in dirty_specializations
+                .iter_to_dequeue(extracted_view_light.retained_view_entity, visible_entities)
+            {
+                shadow_phase.remove(main_entity);
+            }
+
+            // Now iterate through all newly-visible entities and those needing respecialization.
+            for (render_entity, main_entity) in dirty_specializations.iter_to_queue(
+                extracted_view_light.retained_view_entity,
+                visible_entities,
+                &view_pending_shadow_queues.prev_frame,
+            ) {
+                let Some(&(pipeline_id, draw_function)) =
+                    view_specialized_material_pipeline_cache.get(main_entity)
                 else {
                     continue;
                 };
 
-                let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(main_entity)
+                let Some(mesh_instance) =
+                    render_mesh_instances.render_mesh_queue_data(*main_entity)
                 else {
+                    // We couldn't fetch the mesh, probably because it hasn't
+                    // loaded yet. Add the entity to the list of pending shadows
+                    // and bail.
+                    view_pending_shadow_queues
+                        .current_frame
+                        .insert((*render_entity, *main_entity));
                     continue;
                 };
                 if !mesh_instance
@@ -2210,16 +2279,17 @@ pub fn queue_shadows(
                     continue;
                 }
 
-                // Skip the entity if it's cached in a bin and up to date.
-                if shadow_phase.validate_cached_entity(main_entity, current_change_tick) {
-                    continue;
-                }
-
-                let Some(material_instance) = render_material_instances.instances.get(&main_entity)
+                let Some(material_instance) = render_material_instances.instances.get(main_entity)
                 else {
                     continue;
                 };
                 let Some(material) = render_materials.get(material_instance.asset_id) else {
+                    // We couldn't fetch the material, probably because the
+                    // material hasn't been loaded yet. Add the entity to the
+                    // list of pending shadows and bail.
+                    view_pending_shadow_queues
+                        .current_frame
+                        .insert((*render_entity, *main_entity));
                     continue;
                 };
 
@@ -2248,13 +2318,12 @@ pub fn queue_shadows(
                     ShadowBinKey {
                         asset_id: mesh_instance.mesh_asset_id.into(),
                     },
-                    (entity, main_entity),
+                    (*render_entity, *main_entity),
                     mesh_instance.current_uniform_index,
                     BinnedRenderPhaseType::mesh(
                         mesh_instance.should_batch(),
                         &gpu_preprocessing_support,
                     ),
-                    current_change_tick,
                 );
             }
         }
diff --git a/crates/bevy_pbr/src/render/mesh.rs b/crates/bevy_pbr/src/render/mesh.rs
index afc5020f9da85..fe157e1db7de5 100644
--- a/crates/bevy_pbr/src/render/mesh.rs
+++ b/crates/bevy_pbr/src/render/mesh.rs
@@ -83,9 +83,7 @@ use crate::{
 use bevy_core_pipeline::oit::OrderIndependentTransparencySettings;
 use bevy_core_pipeline::prepass::{DeferredPrepass, DepthPrepass, NormalPrepass};
 use bevy_core_pipeline::tonemapping::{DebandDither, Tonemapping};
-use bevy_ecs::change_detection::Tick;
-use bevy_ecs::system::SystemChangeTick;
-use bevy_render::camera::TemporalJitter;
+use bevy_render::camera::{DirtySpecializations, TemporalJitter};
 use bevy_render::prelude::Msaa;
 use bevy_render::sync_world::{MainEntity, MainEntityHashMap};
 use bevy_render::view::ExtractedView;
@@ -218,7 +216,6 @@ impl Plugin for MeshRenderPlugin {
         if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
             render_app
                 .init_resource::<ViewKeyCache>()
-                .init_resource::<ViewSpecializationTicks>()
                 .init_resource::<GpuPreprocessingSupport>()
                 .add_systems(RenderStartup, skin_uniforms_from_world)
                 .add_systems(
@@ -311,12 +308,9 @@ impl Plugin for MeshRenderPlugin {
 #[derive(Resource, Deref, DerefMut, Default, Debug, Clone)]
 pub struct ViewKeyCache(HashMap<RetainedViewEntity, MeshPipelineKey>);
 
-#[derive(Resource, Deref, DerefMut, Default, Debug, Clone)]
-pub struct ViewSpecializationTicks(HashMap<RetainedViewEntity, Tick>);
-
 pub fn check_views_need_specialization(
     mut view_key_cache: ResMut<ViewKeyCache>,
-    mut view_specialization_ticks: ResMut<ViewSpecializationTicks>,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
     mut views: Query<(
         &ExtractedView,
         &Msaa,
@@ -342,7 +336,6 @@ pub fn check_views_need_specialization(
         Has<ExtractedAtmosphere>,
         Has<ScreenSpaceReflectionsUniform>,
     )>,
-    ticks: SystemChangeTick,
 ) {
     for (
         view,
@@ -452,7 +445,9 @@ pub fn check_views_need_specialization(
             .is_some_and(|current_key| *current_key == view_key)
         {
             view_key_cache.insert(view.retained_view_entity, view_key);
-            view_specialization_ticks.insert(view.retained_view_entity, ticks.this_run());
+            dirty_specializations
+                .views
+                .insert(view.retained_view_entity);
         }
     }
 }
diff --git a/crates/bevy_pbr/src/transmission/phase.rs b/crates/bevy_pbr/src/transmission/phase.rs
index 1a2c0899dee6e..69bcb62c82be9 100644
--- a/crates/bevy_pbr/src/transmission/phase.rs
+++ b/crates/bevy_pbr/src/transmission/phase.rs
@@ -1,8 +1,9 @@
 use core::ops::Range;
 
 use bevy_camera::{Camera, Camera3d};
+use bevy_core_pipeline::core_3d::TransparentSortingInfo3d;
 use bevy_ecs::{
-    entity::Entity,
+    entity::{Entity, EntityHash},
     query::With,
     system::{Local, Query, ResMut},
 };
@@ -15,11 +16,13 @@ use bevy_render::{
         ViewSortedRenderPhases,
     },
     sync_world::MainEntity,
-    view::RetainedViewEntity,
+    view::{ExtractedView, RetainedViewEntity},
     Extract,
 };
+use indexmap::IndexMap;
 
 pub struct Transmissive3d {
+    pub sorting_info: TransparentSortingInfo3d,
     pub distance: f32,
     pub pipeline: CachedRenderPipelineId,
     pub entity: (Entity, MainEntity),
@@ -89,8 +92,19 @@ impl SortedPhaseItem for Transmissive3d {
     }
 
     #[inline]
-    fn sort(items: &mut [Self]) {
-        radsort::sort_by_key(items, |item| item.distance);
+    fn sort(items: &mut IndexMap<(Entity, MainEntity), Transmissive3d, EntityHash>) {
+        items.sort_by_key(|_, item| item.sort_key());
+    }
+
+    fn recalculate_sort_keys(
+        items: &mut IndexMap<(Entity, MainEntity), Self, EntityHash>,
+        view: &ExtractedView,
+    ) {
+        // Determine the distance to the view for each phase item.
+        let rangefinder = view.rangefinder3d();
+        for item in items.values_mut() {
+            item.distance = item.sorting_info.sort_distance(&rangefinder);
+        }
     }
 
     #[inline]
@@ -121,7 +135,7 @@ pub fn extract_transmissive_camera_phases(
         // This is the main camera, so use the first subview index (0).
         let retained_view_entity = RetainedViewEntity::new(main_entity.into(), None, 0);
 
-        transmissive_3d_phases.insert_or_clear(retained_view_entity);
+        transmissive_3d_phases.prepare_for_new_frame(retained_view_entity);
         live_entities.insert(retained_view_entity);
     }
 
diff --git a/crates/bevy_pbr/src/wireframe.rs b/crates/bevy_pbr/src/wireframe.rs
index 64b9dc86eab22..6796cc56be17a 100644
--- a/crates/bevy_pbr/src/wireframe.rs
+++ b/crates/bevy_pbr/src/wireframe.rs
@@ -2,7 +2,7 @@ use crate::{
     render::{PreprocessBindGroups, PreprocessPipelines},
     DrawMesh, MeshPipeline, MeshPipelineKey, RenderLightmaps, RenderMeshInstanceFlags,
     RenderMeshInstances, SetMeshBindGroup, SetMeshViewBindGroup, SetMeshViewBindingArrayBindGroup,
-    ViewKeyCache, ViewSpecializationTicks,
+    ViewKeyCache,
 };
 use bevy_app::{App, Plugin, PostUpdate, Startup, Update};
 use bevy_asset::{
@@ -14,10 +14,9 @@ use bevy_color::{Color, ColorToComponents};
 use bevy_core_pipeline::schedule::{Core3d, Core3dSystems};
 use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::{
-    change_detection::Tick,
     prelude::*,
     query::ROQueryItem,
-    system::{lifetimeless::SRes, SystemChangeTick, SystemParamItem},
+    system::{lifetimeless::SRes, SystemParamItem},
 };
 use bevy_mesh::{Mesh, Mesh3d, MeshVertexBufferLayoutRef};
 use bevy_platform::{
@@ -30,7 +29,9 @@ use bevy_render::{
         GpuPreprocessingMode, GpuPreprocessingSupport, IndirectBatchSet, IndirectParametersBuffers,
         IndirectParametersNonIndexed,
     },
-    camera::{extract_cameras, ExtractedCamera},
+    camera::{
+        DirtySpecializationSystems, DirtyWireframeSpecializations, ExtractedCamera, PendingQueues,
+    },
     extract_resource::ExtractResource,
     mesh::{
         allocator::{MeshAllocator, SlabId},
@@ -91,6 +92,7 @@ impl Plugin for WireframePlugin {
             RenderAssetPlugin::<RenderWireframeMaterial>::default(),
         ))
         .init_asset::<WireframeMaterial>()
+        .init_resource::<WireframeEntitiesNeedingSpecialization>()
         .init_resource::<SpecializedMeshPipelines<Wireframe3dPipeline>>()
         .init_resource::<WireframeConfig>()
         .init_resource::<WireframeEntitiesNeedingSpecialization>()
@@ -139,7 +141,6 @@ impl Plugin for WireframePlugin {
             .extra_buffer_usages |= BufferUsages::STORAGE;
 
         render_app
-            .init_resource::<WireframeEntitySpecializationTicks>()
             .init_resource::<SpecializedWireframePipelineCache>()
             .init_resource::<DrawFunctions<Wireframe3d>>()
             .add_render_command::<Wireframe3d, DrawWireframe3dThin>()
@@ -147,6 +148,7 @@ impl Plugin for WireframePlugin {
             .init_resource::<RenderWireframeInstances>()
             .init_resource::<WireframeWideBindGroups>()
             .init_resource::<SpecializedMeshPipelines<Wireframe3dPipeline>>()
+            .init_resource::<PendingWireframeQueues>()
             .add_systems(RenderStartup, init_wireframe_3d_pipeline)
             .add_systems(
                 Core3d,
@@ -158,7 +160,10 @@ impl Plugin for WireframePlugin {
                 ExtractSchedule,
                 (
                     extract_wireframe_3d_camera,
-                    extract_wireframe_entities_needing_specialization.after(extract_cameras),
+                    extract_wireframe_entities_needing_specialization
+                        .in_set(DirtySpecializationSystems::CheckForChanges),
+                    extract_wireframe_entities_that_need_specializations_removed
+                        .in_set(DirtySpecializationSystems::CheckForRemovals),
                     extract_wireframe_materials,
                 ),
             )
@@ -952,15 +957,15 @@ impl RenderAsset for RenderWireframeMaterial {
 #[derive(Resource, Deref, DerefMut, Default)]
 pub struct RenderWireframeInstances(MainEntityHashMap<AssetId<WireframeMaterial>>);
 
-#[derive(Clone, Resource, Deref, DerefMut, Debug, Default)]
+/// Temporarily stores entities that were determined to either need their
+/// specialized pipelines for wireframes updated or to have their specialized
+/// pipelines for wireframes removed.
+#[derive(Clone, Resource, Debug, Default)]
 pub struct WireframeEntitiesNeedingSpecialization {
-    #[deref]
-    pub entities: Vec<Entity>,
-}
-
-#[derive(Resource, Deref, DerefMut, Clone, Debug, Default)]
-pub struct WireframeEntitySpecializationTicks {
-    pub entities: MainEntityHashMap<Tick>,
+    /// Entities that need to have their pipelines updated.
+    pub changed: Vec<Entity>,
+    /// Entities that need to have their pipelines removed.
+    pub removed: Vec<Entity>,
 }
 
 #[derive(Resource, Default)]
@@ -973,7 +978,7 @@ pub struct SpecializedWireframePipelineCache {
 pub struct SpecializedWireframeViewPipelineCache {
     // material entity -> (tick, pipeline_id)
     #[deref]
-    map: MainEntityHashMap<(Tick, CachedRenderPipelineId)>,
+    map: MainEntityHashMap<CachedRenderPipelineId>,
 }
 
 #[derive(Resource)]
@@ -1265,29 +1270,34 @@ fn extract_wireframe_3d_camera(
 
 pub fn extract_wireframe_entities_needing_specialization(
     entities_needing_specialization: Extract<Res<WireframeEntitiesNeedingSpecialization>>,
-    mut entity_specialization_ticks: ResMut<WireframeEntitySpecializationTicks>,
-    views: Query<&ExtractedView>,
-    mut specialized_wireframe_pipeline_cache: ResMut<SpecializedWireframePipelineCache>,
-    mut removed_meshes_query: Extract<RemovedComponents<Mesh3d>>,
-    ticks: SystemChangeTick,
+    mut dirty_wireframe_specializations: ResMut<DirtyWireframeSpecializations>,
 ) {
-    for entity in entities_needing_specialization.iter() {
-        // Update the entity's specialization tick with this run's tick
-        entity_specialization_ticks.insert((*entity).into(), ticks.this_run());
+    // Drain the list of entities needing specialization from the main world
+    // into the render-world `DirtySpecializations` table.
+    for entity in entities_needing_specialization.changed.iter() {
+        dirty_wireframe_specializations
+            .changed_renderables
+            .insert(MainEntity::from(*entity));
     }
+}
 
-    for entity in removed_meshes_query.read() {
-        for view in &views {
-            if let Some(view_cache) = specialized_wireframe_pipeline_cache
-                .views
-                .get_mut(&view.retained_view_entity)
-            {
-                view_cache.remove(&MainEntity::from(entity));
-            }
-        }
+/// A system that adds entities that were judged to need their wireframe
+/// specializations removed to the appropriate table in
+/// [`DirtyWireframeSpecializations`].
+pub fn extract_wireframe_entities_that_need_specializations_removed(
+    entities_needing_specialization: Extract<Res<WireframeEntitiesNeedingSpecialization>>,
+    mut dirty_wireframe_specializations: ResMut<DirtyWireframeSpecializations>,
+) {
+    for entity in entities_needing_specialization.removed.iter() {
+        dirty_wireframe_specializations
+            .removed_renderables
+            .insert(MainEntity::from(*entity));
     }
 }
 
+/// Finds 3D wireframe entities that have changed in such a way as to
+/// potentially require specialization and adds them to the
+/// [`WireframeEntitiesNeedingSpecialization`] list.
 pub fn check_wireframe_entities_needing_specialization(
     needs_specialization: Query<
         Entity,
@@ -1301,13 +1311,36 @@ pub fn check_wireframe_entities_needing_specialization(
         )>,
     >,
     mut entities_needing_specialization: ResMut<WireframeEntitiesNeedingSpecialization>,
+    mut removed_mesh_3d_components: RemovedComponents<Mesh3d>,
+    mut removed_mesh_3d_wireframe_components: RemovedComponents<Mesh3dWireframe>,
 ) {
-    entities_needing_specialization.clear();
+    entities_needing_specialization.changed.clear();
+    entities_needing_specialization.removed.clear();
+
+    // Gather all entities that need their specializations regenerated.
     for entity in &needs_specialization {
-        entities_needing_specialization.push(entity);
+        entities_needing_specialization.changed.push(entity);
+    }
+
+    // All entities that removed their `Mesh3d` or `Mesh3dWireframe` components
+    // need to have their specializations removed as well.
+    //
+    // It's possible that `Mesh3d` was removed and re-added in the same frame,
+    // but we don't have to handle that situation specially here, because
+    // `specialize_wireframes` processes specialization removals before
+    // additions. So, if the pipeline specialization gets spuriously removed,
+    // it'll just be immediately re-added again, which is harmless.
+    for entity in removed_mesh_3d_components
+        .read()
+        .chain(removed_mesh_3d_wireframe_components.read())
+    {
+        entities_needing_specialization.removed.push(entity);
     }
 }
 
+#[derive(Default, Deref, DerefMut, Resource)]
+pub struct PendingWireframeQueues(pub PendingQueues);
+
 pub fn specialize_wireframes(
     render_meshes: Res<RenderAssets<RenderMesh>>,
     render_mesh_instances: Res<RenderMeshInstances>,
@@ -1317,14 +1350,13 @@ pub fn specialize_wireframes(
     wireframe_phases: Res<ViewBinnedRenderPhases<Wireframe3d>>,
     views: Query<(&ExtractedView, &RenderVisibleEntities)>,
     view_key_cache: Res<ViewKeyCache>,
-    entity_specialization_ticks: Res<WireframeEntitySpecializationTicks>,
-    view_specialization_ticks: Res<ViewSpecializationTicks>,
+    dirty_wireframe_specializations: Res<DirtyWireframeSpecializations>,
     mut specialized_material_pipeline_cache: ResMut<SpecializedWireframePipelineCache>,
     mut pipelines: ResMut<SpecializedMeshPipelines<Wireframe3dPipeline>>,
+    mut pending_wireframe_queues: ResMut<PendingWireframeQueues>,
     pipeline: Res<Wireframe3dPipeline>,
     pipeline_cache: Res<PipelineCache>,
     render_lightmaps: Res<RenderLightmaps>,
-    ticks: SystemChangeTick,
 ) {
     let mut all_views: HashSet<RetainedViewEntity, FixedHasher> = HashSet::default();
 
@@ -1344,32 +1376,53 @@ pub fn specialize_wireframes(
             continue;
         };
 
-        let view_tick = view_specialization_ticks
-            .get(&view.retained_view_entity)
-            .unwrap();
         let view_specialized_material_pipeline_cache = views_pipeline_cache
             .entry(view.retained_view_entity)
             .or_default();
 
-        for (_, visible_entity) in visible_entities.iter::<Mesh3d>() {
+        let Some(render_visible_mesh_entities) = visible_entities.get::<Mesh3d>() else {
+            continue;
+        };
+
+        // Initialize the pending queues.
+        let view_pending_wireframe_queues =
+            pending_wireframe_queues.prepare_for_new_frame(view.retained_view_entity);
+
+        // Remove cached pipeline IDs corresponding to entities that
+        // either have been removed or need to be respecialized.
+        if dirty_wireframe_specializations
+            .must_wipe_specializations_for_view(view.retained_view_entity)
+        {
+            view_specialized_material_pipeline_cache.clear();
+        } else {
+            for &renderable_entity in dirty_wireframe_specializations.iter_to_despecialize() {
+                view_specialized_material_pipeline_cache.remove(&renderable_entity);
+            }
+        }
+
+        // Now process all wireframe meshes that need to be re-specialized.
+        for (render_entity, visible_entity) in dirty_wireframe_specializations.iter_to_specialize(
+            view.retained_view_entity,
+            render_visible_mesh_entities,
+            &view_pending_wireframe_queues.prev_frame,
+        ) {
+            if view_specialized_material_pipeline_cache.contains_key(visible_entity) {
+                continue;
+            }
+
             if !render_wireframe_instances.contains_key(visible_entity) {
                 continue;
             };
             let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*visible_entity)
             else {
+                // We couldn't fetch the mesh, probably because it hasn't loaded
+                // yet. Add the entity to the list of pending wireframes and
+                // bail.
+                view_pending_wireframe_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
-            let entity_tick = entity_specialization_ticks.get(visible_entity).unwrap();
-            let last_specialized_tick = view_specialized_material_pipeline_cache
-                .get(visible_entity)
-                .map(|(tick, _)| *tick);
-            let needs_specialization = last_specialized_tick.is_none_or(|tick| {
-                view_tick.is_newer_than(tick, ticks.this_run())
-                    || entity_tick.is_newer_than(tick, ticks.this_run())
-            });
-            if !needs_specialization {
-                continue;
-            }
             let Some(mesh) = render_meshes.get(mesh_instance.mesh_asset_id) else {
                 continue;
             };
@@ -1453,15 +1506,13 @@ pub fn specialize_wireframes(
                 }
             };
 
-            if pipeline_id == CachedRenderPipelineId::INVALID {
-                continue;
-            }
-
-            view_specialized_material_pipeline_cache
-                .insert(*visible_entity, (ticks.this_run(), pipeline_id));
+            view_specialized_material_pipeline_cache.insert(*visible_entity, pipeline_id);
         }
     }
 
+    pending_wireframe_queues.expire_stale_views(&all_views);
+
+    // Delete specialized pipelines belonging to views that have expired.
     views_pipeline_cache.retain(|retained_view_entity, _| all_views.contains(retained_view_entity));
 }
 
@@ -1472,8 +1523,10 @@ fn queue_wireframes(
     mesh_allocator: Res<MeshAllocator>,
     specialized_wireframe_pipeline_cache: Res<SpecializedWireframePipelineCache>,
     render_wireframe_instances: Res<RenderWireframeInstances>,
+    dirty_wireframe_specializations: Res<DirtyWireframeSpecializations>,
     render_wireframe_assets: Res<RenderAssets<RenderWireframeMaterial>>,
     mut wireframe_3d_phases: ResMut<ViewBinnedRenderPhases<Wireframe3d>>,
+    mut pending_wireframe_queues: ResMut<PendingWireframeQueues>,
     mut views: Query<(&ExtractedView, &RenderVisibleEntities)>,
 ) {
     for (view, visible_entities) in &mut views {
@@ -1491,23 +1544,47 @@ fn queue_wireframes(
             continue;
         };
 
-        for (render_entity, visible_entity) in visible_entities.iter::<Mesh3d>() {
+        let Some(render_mesh_visible_entities) = visible_entities.get::<Mesh3d>() else {
+            continue;
+        };
+
+        let view_pending_wireframe_queues = pending_wireframe_queues
+            .get_mut(&view.retained_view_entity)
+            .expect(
+                "View pending wireframe queues should have been created in `specialize_wireframes`",
+            );
+
+        // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+        for &main_entity in dirty_wireframe_specializations
+            .iter_to_dequeue(view.retained_view_entity, render_mesh_visible_entities)
+        {
+            wireframe_phase.remove(main_entity);
+        }
+
+        // Now iterate through all newly-visible entities and those needing respecialization.
+        for (render_entity, visible_entity) in dirty_wireframe_specializations.iter_to_queue(
+            view.retained_view_entity,
+            render_mesh_visible_entities,
+            &view_pending_wireframe_queues.prev_frame,
+        ) {
             let Some(wireframe_instance) = render_wireframe_instances.get(visible_entity) else {
                 continue;
             };
-            let Some((current_change_tick, pipeline_id)) = view_specialized_material_pipeline_cache
+            let Some(pipeline_id) = view_specialized_material_pipeline_cache
                 .get(visible_entity)
-                .map(|(current_change_tick, pipeline_id)| (*current_change_tick, *pipeline_id))
+                .copied()
             else {
                 continue;
             };
 
-            // Skip the entity if it's cached in a bin and up to date.
-            if wireframe_phase.validate_cached_entity(*visible_entity, current_change_tick) {
-                continue;
-            }
             let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*visible_entity)
             else {
+                // We couldn't fetch the mesh, probably because it hasn't loaded
+                // yet. Add the entity to the list of pending wireframes and
+                // bail.
+                view_pending_wireframe_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
 
@@ -1545,7 +1622,6 @@ fn queue_wireframes(
                     mesh_instance.should_batch(),
                     &gpu_preprocessing_support,
                 ),
-                current_change_tick,
             );
         }
     }
diff --git a/crates/bevy_render/Cargo.toml b/crates/bevy_render/Cargo.toml
index 7c48be19d0b0c..aa8201ff842a7 100644
--- a/crates/bevy_render/Cargo.toml
+++ b/crates/bevy_render/Cargo.toml
@@ -122,15 +122,12 @@ offset-allocator = "0.2"
 variadics_please = "1.1"
 tracy-client = { version = "0.18.3", optional = true }
 indexmap = { version = "2" }
-fixedbitset = { version = "0.5" }
 bitflags = "2"
+itertools = "0.14"
 
 [target.'cfg(all(target_arch = "wasm32", target_feature = "atomics"))'.dependencies]
 send_wrapper = { version = "0.6.0" }
 
-[dev-dependencies]
-proptest = "1"
-
 [target.'cfg(target_arch = "wasm32")'.dependencies]
 js-sys = "0.3.83"
 web-sys = { version = "0.3.67", features = [
diff --git a/crates/bevy_render/src/batching/mod.rs b/crates/bevy_render/src/batching/mod.rs
index 1d585864c6024..07630d43dfaa8 100644
--- a/crates/bevy_render/src/batching/mod.rs
+++ b/crates/bevy_render/src/batching/mod.rs
@@ -208,7 +208,7 @@ fn batch_and_prepare_sorted_render_phase<I, GBD>(
     I: CachedRenderPipelinePhaseItem + SortedPhaseItem,
     GBD: GetBatchData,
 {
-    let items = phase.items.iter_mut().map(|item| {
+    let items = phase.items.values_mut().map(|item| {
         let batch_data = match process_item(item) {
             Some(compare_data) if I::AUTOMATIC_BATCHING => Some(BatchMeta::new(item, compare_data)),
             _ => None,
diff --git a/crates/bevy_render/src/camera.rs b/crates/bevy_render/src/camera.rs
index 5361e891d3e24..3d55e16a3b4c5 100644
--- a/crates/bevy_render/src/camera.rs
+++ b/crates/bevy_render/src/camera.rs
@@ -1,3 +1,5 @@
+use core::mem;
+
 use crate::{
     batching::gpu_preprocessing::{GpuPreprocessingMode, GpuPreprocessingSupport},
     extract_component::{ExtractComponent, ExtractComponentPlugin},
@@ -5,11 +7,11 @@ use crate::{
     render_asset::RenderAssets,
     render_resource::TextureView,
     sync_component::SyncComponent,
-    sync_world::{RenderEntity, SyncToRenderWorld},
+    sync_world::{MainEntity, MainEntityHashSet, RenderEntity, SyncToRenderWorld},
     texture::{GpuImage, ManualTextureViews},
     view::{
         ColorGrading, ExtractedView, ExtractedWindows, Msaa, NoIndirectDrawing,
-        RenderVisibleEntities, RetainedViewEntity, ViewUniformOffset,
+        RenderVisibleEntities, RenderVisibleMeshEntities, RetainedViewEntity, ViewUniformOffset,
     },
     Extract, ExtractSchedule, Render, RenderApp, RenderSystems,
 };
@@ -35,7 +37,7 @@ use bevy_ecs::{
     query::{Has, QueryItem},
     reflect::ReflectComponent,
     resource::Resource,
-    schedule::{InternedScheduleLabel, IntoScheduleConfigs, ScheduleLabel},
+    schedule::{InternedScheduleLabel, IntoScheduleConfigs, ScheduleLabel, SystemSet},
     system::{Commands, Query, Res, ResMut},
     world::DeferredWorld,
 };
@@ -47,6 +49,7 @@ use bevy_platform::collections::{HashMap, HashSet};
 use bevy_reflect::prelude::*;
 use bevy_transform::components::GlobalTransform;
 use bevy_window::{PrimaryWindow, Window, WindowCreated, WindowResized, WindowScaleFactorChanged};
+use itertools::Either;
 use wgpu::TextureFormat;
 
 #[derive(Default)]
@@ -77,7 +80,30 @@ impl Plugin for CameraPlugin {
         if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
             render_app
                 .init_resource::<SortedCameras>()
-                .add_systems(ExtractSchedule, extract_cameras)
+                .init_resource::<DirtySpecializations>()
+                .init_resource::<DirtyWireframeSpecializations>()
+                .allow_ambiguous_resource::<DirtySpecializations>()
+                .allow_ambiguous_resource::<DirtyWireframeSpecializations>()
+                .configure_sets(
+                    ExtractSchedule,
+                    (
+                        DirtySpecializationSystems::Clear
+                            .before(DirtySpecializationSystems::CheckForChanges),
+                        DirtySpecializationSystems::CheckForChanges
+                            .before(DirtySpecializationSystems::CheckForRemovals),
+                    ),
+                )
+                .add_systems(
+                    ExtractSchedule,
+                    (
+                        extract_cameras,
+                        clear_dirty_specializations.in_set(DirtySpecializationSystems::Clear),
+                        clear_dirty_wireframe_specializations
+                            .in_set(DirtySpecializationSystems::Clear),
+                        expire_specializations_for_views.in_set(RenderSystems::Cleanup),
+                        expire_wireframe_specializations_for_views.in_set(RenderSystems::Cleanup),
+                    ),
+                )
                 .add_systems(Render, sort_cameras.in_set(RenderSystems::CreateViews));
         }
     }
@@ -451,8 +477,9 @@ pub fn extract_cameras(
         )>,
     >,
     primary_window: Extract<Query<Entity, With<PrimaryWindow>>>,
+    mut existing_render_visible_entities: Query<&mut RenderVisibleEntities>,
     gpu_preprocessing_support: Res<GpuPreprocessingSupport>,
-    mapper: Extract<Query<&RenderEntity>>,
+    mapper: Extract<Query<RenderEntity>>,
 ) {
     let primary_window = primary_window.iter().next();
     type ExtractedCameraComponents = (
@@ -515,26 +542,26 @@ pub fn extract_cameras(
                 continue;
             }
 
-            let render_visible_entities = RenderVisibleEntities {
-                entities: visible_entities
+            let mut render_visible_entities =
+                match existing_render_visible_entities.get_mut(render_entity) {
+                    Ok(ref mut existing_render_visible_entities) => {
+                        mem::take(&mut **existing_render_visible_entities)
+                    }
+                    Err(_) => RenderVisibleEntities::default(),
+                };
+
+            for (visibility_class, visible_mesh_entities) in visible_entities.entities.iter() {
+                render_visible_entities
                     .entities
-                    .iter()
-                    .map(|(type_id, entities)| {
-                        let entities = entities
-                            .iter()
-                            .map(|entity| {
-                                let render_entity = mapper
-                                    .get(*entity)
-                                    .cloned()
-                                    .map(|entity| entity.id())
-                                    .unwrap_or(Entity::PLACEHOLDER);
-                                (render_entity, (*entity).into())
-                            })
-                            .collect();
-                        (*type_id, entities)
-                    })
-                    .collect(),
-            };
+                    .entry(*visibility_class)
+                    .or_default()
+                    .update_from(&mapper, visible_mesh_entities);
+            }
+
+            // Don't delete "unused" visibility classes from
+            // `RenderVisibleEntities`. Even if a visibility class seems empty
+            // *now*, phases need to be able to find the entities that were just
+            // removed from it.
 
             let mut commands = commands.entity(render_entity);
             commands.insert((
@@ -710,3 +737,316 @@ impl Default for MipBias {
         Self(-1.0)
     }
 }
+
+/// Stores information about all entities that have changed in such a way as to
+/// potentially require their pipelines to be re-specialized.
+///
+/// This is conservative; there's no harm, other than performance, in having an
+/// entity in this list that doesn't actually need to be re-specialized. Note
+/// that the presence of an entity in this list doesn't mean that a new shader
+/// will necessarily be compiled; the pipeline cache is checked first.
+///
+/// This handles 2D meshes, 3D meshes, and sprites. For 2D and 3D wireframes,
+/// see [`DirtyWireframeSpecializations`]. The reason for having two separate
+/// lists is that a single entity can have both a mesh and a wireframe.
+#[derive(Clone, Resource, Default)]
+pub struct DirtySpecializations {
+    /// All renderable objects that must be re-specialized this frame.
+    pub changed_renderables: MainEntityHashSet,
+
+    /// All renderable objects that need their specializations removed this
+    /// frame.
+    ///
+    /// Note that this may include entities in [`Self::changed_renderables`].
+    /// This is fine, as old specializations are removed before new ones are
+    /// added.
+    pub removed_renderables: MainEntityHashSet,
+
+    /// Views that must be respecialized this frame.
+    ///
+    /// The presence of a view in this list causes all entities that it renders
+    /// to be re-specialized.
+    pub views: HashSet<RetainedViewEntity>,
+}
+
+impl DirtySpecializations {
+    /// Returns true if the view has changed in such a way that all specialized
+    /// pipelines for entities visible from it must be regenerated.
+    pub fn must_wipe_specializations_for_view(&self, view: RetainedViewEntity) -> bool {
+        self.views.contains(&view)
+    }
+
+    /// Iterates over all entities that need their specializations cleared in
+    /// this frame.
+    pub fn iter_to_despecialize<'a>(&'a self) -> impl Iterator<Item = &'a MainEntity> {
+        // Entities that changed or were removed must be
+        // de-specialized.
+        self.changed_renderables
+            .iter()
+            .chain(self.removed_renderables.iter())
+    }
+
+    /// Iterates over all entities that need to have their pipelines
+    /// re-specialized this frame.
+    ///
+    /// `last_frame_view_pending_queues` should be the contents of the
+    /// [`ViewPendingQueues::prev_frame`] list.
+    pub fn iter_to_specialize<'a>(
+        &'a self,
+        view: RetainedViewEntity,
+        render_visible_mesh_entities: &'a RenderVisibleMeshEntities,
+        last_frame_view_pending_queues: &'a HashSet<(Entity, MainEntity)>,
+    ) -> impl Iterator<Item = &'a (Entity, MainEntity)> {
+        (if self.must_wipe_specializations_for_view(view) {
+            Either::Left(render_visible_mesh_entities.entities.iter())
+        } else {
+            Either::Right(render_visible_mesh_entities.added_entities.iter().chain(
+                self.changed_renderables.iter().filter_map(|main_entity| {
+                    render_visible_mesh_entities
+                        .entities
+                        .binary_search_by_key(main_entity, |(_, main_entity)| *main_entity)
+                        .ok()
+                        .map(|index| &render_visible_mesh_entities.entities[index])
+                }),
+            ))
+        })
+        .chain(last_frame_view_pending_queues.iter().filter(|entity_pair| {
+            render_visible_mesh_entities
+                .entities
+                .binary_search(entity_pair)
+                .is_ok()
+        }))
+    }
+
+    /// Iterates over all renderables that should be removed from the phase.
+    ///
+    /// This includes renderables that became invisible this frame, renderables
+    /// that are in [`DirtySpecializations::changed_renderables`], and
+    /// renderables that are in [`DirtySpecializations::removed_renderables`].
+    /// If this view must itself be re-specialized, this will iterate over all
+    /// visible entities in addition to those that became invisible.
+    pub fn iter_to_dequeue<'a>(
+        &'a self,
+        view: RetainedViewEntity,
+        render_visible_mesh_entities: &'a RenderVisibleMeshEntities,
+    ) -> impl Iterator<Item = &'a MainEntity> {
+        render_visible_mesh_entities
+            .removed_entities
+            .iter()
+            .map(|(_, main_entity)| main_entity)
+            .chain(if self.must_wipe_specializations_for_view(view) {
+                // All visible entities must be removed.
+                // Note that this includes potentially-invisible entities, but
+                // that's OK as they shouldn't be in the caller's bins in the
+                // first place.
+                Either::Left(
+                    render_visible_mesh_entities
+                        .entities
+                        .iter()
+                        .map(|(_, main_entity)| main_entity),
+                )
+            } else {
+                // Only entities that changed must be removed.
+                Either::Right(
+                    self.changed_renderables
+                        .iter()
+                        .chain(self.removed_renderables.iter()),
+                )
+            })
+    }
+
+    /// Iterates over all renderables that potentially need to be re-queued.
+    ///
+    /// This includes both renderables that became visible and those that are in
+    /// [`DirtySpecializations::changed_renderables`]. If this view must itself
+    /// be re-specialized, this will iterate over all visible renderables.
+    ///
+    /// `last_frame_view_pending_queues` should be the contents of the
+    /// [`ViewPendingQueues::prev_frame`] list.
+    pub fn iter_to_queue<'a>(
+        &'a self,
+        view: RetainedViewEntity,
+        render_visible_mesh_entities: &'a RenderVisibleMeshEntities,
+        last_frame_view_pending_queues: &'a HashSet<(Entity, MainEntity)>,
+    ) -> impl Iterator<Item = &'a (Entity, MainEntity)> {
+        (if self.must_wipe_specializations_for_view(view) {
+            Either::Left(render_visible_mesh_entities.entities.iter())
+        } else {
+            Either::Right(render_visible_mesh_entities.added_entities.iter().chain(
+                self.changed_renderables.iter().filter_map(|main_entity| {
+                    // Only include entities that need respecialization, are
+                    // visible, and *didn't* become visible this frame. The
+                    // third criterion exists because we already yielded
+                    // such entities just prior to this and don't want to
+                    // yield the same entity twice.
+                    // Note that binary searching works because all lists in
+                    // [`RenderVisibleMeshEntities`] are guaranteed to be
+                    // sorted.
+                    if render_visible_mesh_entities
+                        .added_entities
+                        .binary_search_by_key(main_entity, |(_, main_entity)| *main_entity)
+                        .is_err()
+                    {
+                        render_visible_mesh_entities
+                            .entities
+                            .binary_search_by_key(main_entity, |(_, main_entity)| *main_entity)
+                            .ok()
+                            .map(|index| &render_visible_mesh_entities.entities[index])
+                    } else {
+                        None
+                    }
+                }),
+            ))
+        })
+        .chain(last_frame_view_pending_queues.iter().filter(|entity_pair| {
+            render_visible_mesh_entities
+                .entities
+                .binary_search(entity_pair)
+                .is_ok()
+        }))
+    }
+}
+
+/// Stores information about all entities that have changed in such a way as to
+/// potentially require their wireframe pipelines to be re-specialized.
+///
+/// This is separate from [`DirtySpecializations`] because a single entity can
+/// have both a mesh and a wireframe on it, and the pipelines are treated
+/// separately.
+///
+/// See [`DirtySpecializations`] for more information.
+#[derive(Clone, Resource, Default, Deref, DerefMut)]
+pub struct DirtyWireframeSpecializations(pub DirtySpecializations);
+
+/// Clears out the [`DirtySpecializations`] resource in preparation for a new
+/// frame.
+pub fn clear_dirty_specializations(mut dirty_specializations: ResMut<DirtySpecializations>) {
+    dirty_specializations.changed_renderables.clear();
+    dirty_specializations.removed_renderables.clear();
+    dirty_specializations.views.clear();
+}
+
+/// Clears out the [`DirtyWireframeSpecializations`] resource in preparation for
+/// a new frame.
+pub fn clear_dirty_wireframe_specializations(
+    mut dirty_wireframe_specializations: ResMut<DirtyWireframeSpecializations>,
+) {
+    dirty_wireframe_specializations.changed_renderables.clear();
+    dirty_wireframe_specializations.removed_renderables.clear();
+    dirty_wireframe_specializations.views.clear();
+}
+
+/// A system that removes views that don't exist any longer from
+/// [`DirtySpecializations`].
+pub fn expire_specializations_for_views(
+    views: Query<&ExtractedView>,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
+) {
+    let all_live_retained_view_entities: HashSet<_> =
+        views.iter().map(|view| view.retained_view_entity).collect();
+    dirty_specializations.views.retain(|retained_view_entity| {
+        all_live_retained_view_entities.contains(retained_view_entity)
+    });
+}
+
+/// A system that removes views that don't exist any longer from
+/// [`DirtyWireframeSpecializations`].
+pub fn expire_wireframe_specializations_for_views(
+    views: Query<&ExtractedView>,
+    mut dirty_wireframe_specializations: ResMut<DirtyWireframeSpecializations>,
+) {
+    let all_live_retained_view_entities: HashSet<_> =
+        views.iter().map(|view| view.retained_view_entity).collect();
+    dirty_wireframe_specializations
+        .views
+        .retain(|retained_view_entity| {
+            all_live_retained_view_entities.contains(retained_view_entity)
+        });
+}
+
+/// A [`SystemSet`] that contains all systems that mutate the
+/// [`DirtySpecializations`] resource and other resources that wrap that type.
+///
+/// These systems must run in order.
+#[derive(SystemSet, Clone, PartialEq, Eq, Debug, Hash)]
+pub enum DirtySpecializationSystems {
+    /// Systems that clear out [`DirtySpecializations`] types in preparation for
+    /// a new frame.
+    Clear,
+
+    /// Systems that add entities that need to be re-specialized to
+    /// [`DirtySpecializations`].
+    CheckForChanges,
+
+    /// Systems that determine which entities need to be removed from render
+    /// phases and write the results to [`DirtySpecializations`].
+    ///
+    /// The set of entities that need to be removed from the render phases can
+    /// only be determined after all systems in
+    /// [`DirtySpecializationSystems::CheckForChanges`] have run. That's because
+    /// these systems check `RemovedComponents` resources, and they have to be
+    /// able to distinguish between the case in which an entity was truly made
+    /// unrenderable and the case in which an entity appeared in a
+    /// `RemovedComponents` table simply because its material *type* changed.
+    CheckForRemovals,
+}
+
+/// Holds all entities that couldn't be specialized and/or queued because their
+/// materials or other dependent resources hadn't loaded yet.
+///
+/// We might not be able to specialize and/or enqueue a renderable entity if a
+/// dependent resource like a material isn't available. In that case, we add the
+/// entity to the appropriate list so that we attempt to re-specialize and
+/// re-queue it on subsequent frames.
+///
+/// This type is expected to be placed in a newtype wrapper and stored as a
+/// resource: e.g. `PendingMeshMaterialQueues`.
+#[derive(Default, Deref, DerefMut)]
+pub struct PendingQueues(pub HashMap<RetainedViewEntity, ViewPendingQueues>);
+
+/// Holds all entities that couldn't be specialized and/or queued because their
+/// materials and/or other dependent resources hadn't loaded yet for a single
+/// view.
+///
+/// See the documentation of [`PendingQueues`] for more information.
+#[derive(Default)]
+pub struct ViewPendingQueues {
+    /// The entities that couldn't be specialized and/or queued this frame.
+    ///
+    /// We add to this list during pipeline specialization and queuing.
+    pub current_frame: HashSet<(Entity, MainEntity)>,
+
+    /// The entities that we need to re-examine in this frame.
+    ///
+    /// We attempt to specialize and queue entities in this list every frame, as
+    /// long as those entities are still visible.
+    pub prev_frame: HashSet<(Entity, MainEntity)>,
+}
+
+impl PendingQueues {
+    /// Initializes the pending queues for a new frame.
+    ///
+    /// This method is called during specialization. It creates the queues for
+    /// the view if necessary and initializes them.
+    pub fn prepare_for_new_frame(
+        &mut self,
+        retained_view_entity: RetainedViewEntity,
+    ) -> &mut ViewPendingQueues {
+        let view_pending_queues = self.entry(retained_view_entity).or_default();
+        mem::swap(
+            &mut view_pending_queues.current_frame,
+            &mut view_pending_queues.prev_frame,
+        );
+        view_pending_queues.current_frame.clear();
+        view_pending_queues
+    }
+
+    /// Removes any pending queues that belong to views not in the supplied
+    /// `all_views` table.
+    ///
+    /// Specialization systems for phases should call this before returning in
+    /// order to clean up resources relating to views that no longer exist.
+    pub fn expire_stale_views(&mut self, all_views: &HashSet<RetainedViewEntity>) {
+        self.retain(|retained_view_entity, _| all_views.contains(retained_view_entity));
+    }
+}
diff --git a/crates/bevy_render/src/render_phase/mod.rs b/crates/bevy_render/src/render_phase/mod.rs
index d1a2f167976da..adf29a17d4074 100644
--- a/crates/bevy_render/src/render_phase/mod.rs
+++ b/crates/bevy_render/src/render_phase/mod.rs
@@ -30,14 +30,12 @@ mod rangefinder;
 
 use bevy_app::{App, Plugin};
 use bevy_derive::{Deref, DerefMut};
-use bevy_ecs::change_detection::Tick;
 use bevy_ecs::entity::EntityHash;
 use bevy_platform::collections::{hash_map::Entry, HashMap};
 use bevy_utils::default;
 pub use draw::*;
 pub use draw_state::*;
 use encase::{internal::WriteInto, ShaderSize};
-use fixedbitset::{Block, FixedBitSet};
 use indexmap::IndexMap;
 use nonmax::NonMaxU32;
 pub use rangefinder::*;
@@ -49,7 +47,7 @@ use crate::batching::gpu_preprocessing::{
 };
 use crate::renderer::RenderDevice;
 use crate::sync_world::{MainEntity, MainEntityHashMap};
-use crate::view::RetainedViewEntity;
+use crate::view::{ExtractedView, RetainedViewEntity};
 use crate::RenderDebugFlags;
 use bevy_material::descriptor::CachedRenderPipelineId;
 
@@ -72,7 +70,13 @@ pub use bevy_material::labels::DrawFunctionId;
 pub use bevy_material_macros::DrawFunctionLabel;
 pub use bevy_material_macros::ShaderLabel;
 use bevy_render::renderer::RenderAdapterInfo;
-use core::{fmt::Debug, hash::Hash, iter, marker::PhantomData, ops::Range, slice::SliceIndex};
+use core::{
+    fmt::Debug,
+    hash::Hash,
+    iter,
+    marker::PhantomData,
+    ops::{Range, RangeBounds},
+};
 use smallvec::SmallVec;
 
 /// Stores the rendering instructions for a single phase that uses bins in all
@@ -152,26 +156,11 @@ where
 
     /// The batch and bin key for each entity.
     ///
-    /// We retain these so that, when the entity changes,
-    /// [`Self::sweep_old_entities`] can quickly find the bin it was located in
-    /// and remove it.
-    cached_entity_bin_keys: IndexMap<MainEntity, CachedBinnedEntity<BPI>, EntityHash>,
-
-    /// The set of indices in [`Self::cached_entity_bin_keys`] that are
-    /// confirmed to be up to date.
-    ///
-    /// Note that each bit in this bit set refers to an *index* in the
-    /// [`IndexMap`] (i.e. a bucket in the hash table). They aren't entity IDs.
-    valid_cached_entity_bin_keys: FixedBitSet,
+    /// We retain these so that, when the entity changes, the methods that
+    /// remove items from bins can quickly find the bin each entity was located
+    /// in in order to remove it.
+    cached_entity_bin_keys: MainEntityHashMap<CachedBinnedEntity<BPI>>,
 
-    /// The set of entities that changed bins this frame.
-    ///
-    /// An entity will only be present in this list if it was in one bin on the
-    /// previous frame and is in a new bin on this frame. Each list entry
-    /// specifies the bin the entity used to be in. We use this in order to
-    /// remove the entity from the old bin during
-    /// [`BinnedRenderPhase::sweep_old_entities`].
-    entities_that_changed_bins: Vec<EntityThatChangedBins<BPI>>,
     /// The gpu preprocessing mode configured for the view this phase is associated
     /// with.
     gpu_preprocessing_mode: GpuPreprocessingMode,
@@ -186,18 +175,6 @@ pub struct RenderBin {
     entities: IndexMap<MainEntity, InputUniformIndex, EntityHash>,
 }
 
-/// Information that we track about an entity that was in one bin on the
-/// previous frame and is in a different bin this frame.
-struct EntityThatChangedBins<BPI>
-where
-    BPI: BinnedPhaseItem,
-{
-    /// The entity.
-    main_entity: MainEntity,
-    /// The key that identifies the bin that this entity used to be in.
-    old_cached_binned_entity: CachedBinnedEntity<BPI>,
-}
-
 /// Information that we keep about an entity currently within a bin.
 pub struct CachedBinnedEntity<BPI>
 where
@@ -205,10 +182,6 @@ where
 {
     /// Information that we use to identify a cached entity in a bin.
     pub cached_bin_key: Option<CachedBinKey<BPI>>,
-    /// The last modified tick of the entity.
-    ///
-    /// We use this to detect when the entity needs to be invalidated.
-    pub change_tick: Tick,
 }
 
 /// Information that we use to identify a cached entity in a bin.
@@ -232,7 +205,6 @@ where
     fn clone(&self) -> Self {
         CachedBinnedEntity {
             cached_bin_key: self.cached_bin_key.clone(),
-            change_tick: self.change_tick,
         }
     }
 }
@@ -477,7 +449,6 @@ where
         (entity, main_entity): (Entity, MainEntity),
         input_uniform_index: InputUniformIndex,
         mut phase_type: BinnedRenderPhaseType,
-        change_tick: Tick,
     ) {
         // If the user has overridden indirect drawing for this view, we need to
         // force the phase type to be batchable instead.
@@ -567,7 +538,6 @@ where
                 bin_key,
                 phase_type,
             }),
-            change_tick,
         );
     }
 
@@ -576,30 +546,10 @@ where
         &mut self,
         main_entity: MainEntity,
         cached_bin_key: Option<CachedBinKey<BPI>>,
-        change_tick: Tick,
     ) {
-        let new_cached_binned_entity = CachedBinnedEntity {
-            cached_bin_key,
-            change_tick,
-        };
-
-        let (index, old_cached_binned_entity) = self
-            .cached_entity_bin_keys
-            .insert_full(main_entity, new_cached_binned_entity.clone());
-
-        // If the entity changed bins, record its old bin so that we can remove
-        // the entity from it.
-        if let Some(old_cached_binned_entity) = old_cached_binned_entity
-            && old_cached_binned_entity.cached_bin_key != new_cached_binned_entity.cached_bin_key
-        {
-            self.entities_that_changed_bins.push(EntityThatChangedBins {
-                main_entity,
-                old_cached_binned_entity,
-            });
-        }
-
-        // Mark the entity as valid.
-        self.valid_cached_entity_bin_keys.grow_and_insert(index);
+        let new_cached_binned_entity = CachedBinnedEntity { cached_bin_key };
+        self.cached_entity_bin_keys
+            .insert(main_entity, new_cached_binned_entity);
     }
 
     /// Encodes the GPU commands needed to render all entities in this phase.
@@ -856,80 +806,23 @@ where
     pub fn prepare_for_new_frame(&mut self) {
         self.batch_sets.clear();
 
-        self.valid_cached_entity_bin_keys.clear();
-        self.valid_cached_entity_bin_keys
-            .grow(self.cached_entity_bin_keys.len());
-        self.valid_cached_entity_bin_keys
-            .set_range(self.cached_entity_bin_keys.len().., true);
-
-        self.entities_that_changed_bins.clear();
-
         for unbatchable_bin in self.unbatchable_meshes.values_mut() {
             unbatchable_bin.buffer_indices.clear();
         }
     }
 
-    /// Checks to see whether the entity is in a bin and returns true if it's
-    /// both in a bin and up to date.
-    ///
-    /// If this function returns true, we also add the entry to the
-    /// `valid_cached_entity_bin_keys` list.
-    pub fn validate_cached_entity(
-        &mut self,
-        visible_entity: MainEntity,
-        current_change_tick: Tick,
-    ) -> bool {
-        if let indexmap::map::Entry::Occupied(entry) =
-            self.cached_entity_bin_keys.entry(visible_entity)
-            && entry.get().change_tick == current_change_tick
-        {
-            self.valid_cached_entity_bin_keys.insert(entry.index());
-            return true;
-        }
-
-        false
-    }
-
-    /// Removes all entities not marked as clean from the bins.
+    /// Removes a single entity from its bin.
     ///
-    /// During `queue_material_meshes`, we process all visible entities and mark
-    /// each as clean as we come to it. Then, in [`sweep_old_entities`], we call
-    /// this method, which removes entities that aren't marked as clean from the
-    /// bins.
-    pub fn sweep_old_entities(&mut self) {
-        // Search for entities not marked as valid. We have to do this in
-        // reverse order because `swap_remove_index` will potentially invalidate
-        // all indices after the one we remove.
-        for index in ReverseFixedBitSetZeroesIterator::new(&self.valid_cached_entity_bin_keys) {
-            let Some((entity, cached_binned_entity)) =
-                self.cached_entity_bin_keys.swap_remove_index(index)
-            else {
-                continue;
-            };
-
-            if let Some(ref cached_bin_key) = cached_binned_entity.cached_bin_key {
-                remove_entity_from_bin(
-                    entity,
-                    cached_bin_key,
-                    &mut self.multidrawable_meshes,
-                    &mut self.batchable_meshes,
-                    &mut self.unbatchable_meshes,
-                    &mut self.non_mesh_items,
-                );
-            }
-        }
+    /// If doing so makes the bin empty, this method removes the bin as well.
+    pub fn remove(&mut self, main_entity: MainEntity) {
+        let Some(cached_binned_entity) = self.cached_entity_bin_keys.remove(&main_entity) else {
+            return;
+        };
 
-        // If an entity changed bins, we need to remove it from its old bin.
-        for entity_that_changed_bins in self.entities_that_changed_bins.drain(..) {
-            let Some(ref old_cached_bin_key) = entity_that_changed_bins
-                .old_cached_binned_entity
-                .cached_bin_key
-            else {
-                continue;
-            };
+        if let Some(ref cached_bin_key) = cached_binned_entity.cached_bin_key {
             remove_entity_from_bin(
-                entity_that_changed_bins.main_entity,
-                old_cached_bin_key,
+                main_entity,
+                cached_bin_key,
                 &mut self.multidrawable_meshes,
                 &mut self.batchable_meshes,
                 &mut self.unbatchable_meshes,
@@ -1044,9 +937,7 @@ where
                 }
                 GpuPreprocessingMode::None => BinnedRenderPhaseBatchSets::DynamicUniforms(vec![]),
             },
-            cached_entity_bin_keys: IndexMap::default(),
-            valid_cached_entity_bin_keys: FixedBitSet::new(),
-            entities_that_changed_bins: vec![],
+            cached_entity_bin_keys: MainEntityHashMap::default(),
             gpu_preprocessing_mode: gpu_preprocessing,
         }
     }
@@ -1155,7 +1046,6 @@ where
                             ),
                     )
                         .in_set(RenderSystems::PrepareResourcesBatchPhases),
-                    sweep_old_entities::<BPI>.in_set(RenderSystems::QueueSweep),
                     gpu_preprocessing::collect_buffers_for_phase::<BPI, GFBD>
                         .run_if(
                             resource_exists::<
@@ -1191,9 +1081,18 @@ impl<SPI> ViewSortedRenderPhases<SPI>
 where
     SPI: SortedPhaseItem,
 {
-    pub fn insert_or_clear(&mut self, retained_view_entity: RetainedViewEntity) {
+    /// Ensures that a set of phases are present for the given
+    /// [`RetainedViewEntity`].
+    pub fn prepare_for_new_frame(&mut self, retained_view_entity: RetainedViewEntity) {
         match self.entry(retained_view_entity) {
-            Entry::Occupied(mut entry) => entry.get_mut().clear(),
+            Entry::Occupied(mut entry) => {
+                let render_phase = entry.get_mut();
+                for (render_entity, main_entity) in render_phase.transient_items.drain(..) {
+                    render_phase
+                        .items
+                        .swap_remove(&(render_entity, main_entity));
+                }
+            }
             Entry::Vacant(entry) => {
                 entry.insert(default());
             }
@@ -1388,7 +1287,10 @@ where
     I: SortedPhaseItem,
 {
     /// The items within this [`SortedRenderPhase`].
-    pub items: Vec<I>,
+    pub items: IndexMap<(Entity, MainEntity), I, EntityHash>,
+    /// Items within this render phase that will be automatically removed after
+    /// this frame.
+    pub transient_items: Vec<(Entity, MainEntity)>,
 }
 
 impl<I> Default for SortedRenderPhase<I>
@@ -1396,7 +1298,10 @@ where
     I: SortedPhaseItem,
 {
     fn default() -> Self {
-        Self { items: Vec::new() }
+        Self {
+            items: IndexMap::default(),
+            transient_items: vec![],
+        }
     }
 }
 
@@ -1407,7 +1312,23 @@ where
     /// Adds a [`PhaseItem`] to this render phase.
     #[inline]
     pub fn add(&mut self, item: I) {
-        self.items.push(item);
+        self.items.insert((item.entity(), item.main_entity()), item);
+    }
+
+    /// Adds a [`PhaseItem`] which will be automatically removed after this
+    /// frame to this phase.
+    #[inline]
+    pub fn add_transient(&mut self, item: I) {
+        let key = (item.entity(), item.main_entity());
+        self.items.insert(key, item);
+        self.transient_items.push(key);
+    }
+
+    /// Removes the [`PhaseItem`] corresponding to the given main-world entity
+    /// from this render phase.
+    #[inline]
+    pub fn remove(&mut self, render_entity: Entity, main_entity: MainEntity) {
+        self.items.swap_remove(&(render_entity, main_entity));
     }
 
     /// Removes all [`PhaseItem`]s from this render phase.
@@ -1416,6 +1337,15 @@ where
         self.items.clear();
     }
 
+    /// Populates whatever internal fields are necessary in order to perform the
+    /// sort.
+    ///
+    /// For example, for transparent 3D phases, this calculates the distance
+    /// from each object to the view.
+    pub fn recalculate_sort_keys(&mut self, view: &ExtractedView) {
+        I::recalculate_sort_keys(&mut self.items, view);
+    }
+
     /// Sorts all of its [`PhaseItem`]s.
     pub fn sort(&mut self) {
         I::sort(&mut self.items);
@@ -1424,7 +1354,7 @@ where
     /// An [`Iterator`] through the associated [`Entity`] for each [`PhaseItem`] in order.
     #[inline]
     pub fn iter_entities(&'_ self) -> impl Iterator<Item = Entity> + '_ {
-        self.items.iter().map(PhaseItem::entity)
+        self.items.values().map(PhaseItem::entity)
     }
 
     /// Renders all of its [`PhaseItem`]s using their corresponding draw functions.
@@ -1443,11 +1373,11 @@ where
         render_pass: &mut TrackedRenderPass<'w>,
         world: &'w World,
         view: Entity,
-        range: impl SliceIndex<[I], Output = [I]>,
+        range: impl RangeBounds<usize>,
     ) -> Result<(), DrawError> {
         let items = self
             .items
-            .get(range)
+            .get_range(range)
             .expect("`Range` provided to `render_range()` is out of bounds");
 
         let draw_functions = world.resource::<DrawFunctions<I>>();
@@ -1675,10 +1605,22 @@ pub trait SortedPhaseItem: PhaseItem {
     ///
     /// It's advised to always profile for performance changes when changing this implementation.
     #[inline]
-    fn sort(items: &mut [Self]) {
-        items.sort_unstable_by_key(Self::sort_key);
+    fn sort(items: &mut IndexMap<(Entity, MainEntity), Self, EntityHash>) {
+        items.sort_unstable_by_key(|_, value| Self::sort_key(value));
     }
 
+    /// Populates whatever internal fields are necessary in order to perform the
+    /// sort.
+    ///
+    /// The renderer calls this method right before calling [`Self::sort`]. For
+    /// 3D transparent phases that need to be depth sorted, it populates the
+    /// `distance` field with the actual distance from the view. For other
+    /// phases, this method is generally a no-op.
+    fn recalculate_sort_keys(
+        items: &mut IndexMap<(Entity, MainEntity), Self, EntityHash>,
+        view: &ExtractedView,
+    );
+
     /// Whether this phase item targets indexed meshes (those with both vertex
     /// and index buffers as opposed to just vertex buffers).
     ///
@@ -1730,27 +1672,21 @@ impl<P: CachedRenderPipelinePhaseItem> RenderCommand<P> for SetItemPipeline {
 
 /// This system sorts the [`PhaseItem`]s of all [`SortedRenderPhase`]s of this
 /// type.
-pub fn sort_phase_system<I>(mut render_phases: ResMut<ViewSortedRenderPhases<I>>)
-where
+pub fn sort_phase_system<I>(
+    views: Query<&ExtractedView>,
+    mut render_phases: ResMut<ViewSortedRenderPhases<I>>,
+) where
     I: SortedPhaseItem,
 {
-    for phase in render_phases.values_mut() {
+    for view in &views {
+        let Some(phase) = render_phases.get_mut(&view.retained_view_entity) else {
+            continue;
+        };
+        phase.recalculate_sort_keys(view);
         phase.sort();
     }
 }
 
-/// Removes entities that became invisible or changed phases from the bins.
-///
-/// This must run after queuing.
-pub fn sweep_old_entities<BPI>(mut render_phases: ResMut<ViewBinnedRenderPhases<BPI>>)
-where
-    BPI: BinnedPhaseItem,
-{
-    for phase in render_phases.0.values_mut() {
-        phase.sweep_old_entities();
-    }
-}
-
 impl BinnedRenderPhaseType {
     pub fn mesh(
         batchable: bool,
@@ -1794,97 +1730,3 @@ impl RenderBin {
         &self.entities
     }
 }
-
-/// An iterator that efficiently finds the indices of all zero bits in a
-/// [`FixedBitSet`] and returns them in reverse order.
-///
-/// [`FixedBitSet`] doesn't natively offer this functionality, so we have to
-/// implement it ourselves.
-#[derive(Debug)]
-struct ReverseFixedBitSetZeroesIterator<'a> {
-    /// The bit set.
-    bitset: &'a FixedBitSet,
-    /// The next bit index we're going to scan when [`Iterator::next`] is
-    /// called.
-    bit_index: isize,
-}
-
-impl<'a> ReverseFixedBitSetZeroesIterator<'a> {
-    fn new(bitset: &'a FixedBitSet) -> ReverseFixedBitSetZeroesIterator<'a> {
-        ReverseFixedBitSetZeroesIterator {
-            bitset,
-            bit_index: (bitset.len() as isize) - 1,
-        }
-    }
-}
-
-impl<'a> Iterator for ReverseFixedBitSetZeroesIterator<'a> {
-    type Item = usize;
-
-    fn next(&mut self) -> Option<usize> {
-        while self.bit_index >= 0 {
-            // Unpack the bit index into block and bit.
-            let block_index = self.bit_index / (Block::BITS as isize);
-            let bit_pos = self.bit_index % (Block::BITS as isize);
-
-            // Grab the block. Mask off all bits above the one we're scanning
-            // from by setting them all to 1.
-            let mut block = self.bitset.as_slice()[block_index as usize];
-            if bit_pos + 1 < (Block::BITS as isize) {
-                block |= (!0) << (bit_pos + 1);
-            }
-
-            // Search for the next unset bit. Note that the `leading_ones`
-            // function counts from the MSB to the LSB, so we need to flip it to
-            // get the bit number.
-            let pos = (Block::BITS as isize) - (block.leading_ones() as isize) - 1;
-
-            // If we found an unset bit, return it.
-            if pos != -1 {
-                let result = block_index * (Block::BITS as isize) + pos;
-                self.bit_index = result - 1;
-                return Some(result as usize);
-            }
-
-            // Otherwise, go to the previous block.
-            self.bit_index = block_index * (Block::BITS as isize) - 1;
-        }
-
-        None
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::ReverseFixedBitSetZeroesIterator;
-    use fixedbitset::FixedBitSet;
-    use proptest::{collection::vec, prop_assert_eq, proptest};
-
-    proptest! {
-        #[test]
-        fn reverse_fixed_bit_set_zeroes_iterator(
-            bits in vec(0usize..1024usize, 0usize..1024usize),
-            size in 0usize..1024usize,
-        ) {
-            // Build a random bit set.
-            let mut bitset = FixedBitSet::new();
-            bitset.grow(size);
-            for bit in bits {
-                if bit < size {
-                    bitset.set(bit, true);
-                }
-            }
-
-            // Iterate over the bit set backwards in a naive way, and check that
-            // that iteration sequence corresponds to the optimized one.
-            let mut iter = ReverseFixedBitSetZeroesIterator::new(&bitset);
-            for bit_index in (0..size).rev() {
-                if !bitset.contains(bit_index) {
-                    prop_assert_eq!(iter.next(), Some(bit_index));
-                }
-            }
-
-            prop_assert_eq!(iter.next(), None);
-        }
-    }
-}
diff --git a/crates/bevy_render/src/view/visibility/mod.rs b/crates/bevy_render/src/view/visibility/mod.rs
index 3994827f7538a..962c4c545fecb 100644
--- a/crates/bevy_render/src/view/visibility/mod.rs
+++ b/crates/bevy_render/src/view/visibility/mod.rs
@@ -1,10 +1,13 @@
-use core::any::TypeId;
+use core::{any::TypeId, mem};
 
-use bevy_ecs::{component::Component, entity::Entity, prelude::ReflectComponent};
+use bevy_ecs::{component::Component, entity::Entity, prelude::ReflectComponent, system::Query};
 use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_utils::TypeIdMap;
 
-use crate::sync_world::MainEntity;
+use crate::{
+    sync_world::{MainEntity, RenderEntity},
+    Extract,
+};
 
 mod range;
 use bevy_camera::visibility::*;
@@ -17,38 +20,89 @@ pub use range::*;
 #[reflect(Component, Default, Debug, Clone)]
 pub struct RenderVisibleEntities {
     #[reflect(ignore, clone)]
-    pub entities: TypeIdMap<Vec<(Entity, MainEntity)>>,
+    pub entities: TypeIdMap<RenderVisibleMeshEntities>,
+}
+
+/// Stores a list of all entities that are visible from this view, as well as
+/// the change lists.
+///
+/// Note that all lists in this component are guaranteed to be sorted. Thus you
+/// can test for the presence of an entity in these lists via binary search.
+///
+/// Note also that, for 3D meshes, the render-world [`Entity`] values will
+/// always be [`Entity::PLACEHOLDER`]. The render-world entities are kept for
+/// legacy passes that still need to process visibility of render-world
+/// entities.
+#[derive(Component, Clone, Debug, Default, Reflect)]
+#[reflect(Component, Debug, Default, Clone)]
+pub struct RenderVisibleMeshEntities {
+    /// A sorted list of all entities that are visible from this view.
+    #[reflect(ignore, clone)]
+    pub entities: Vec<(Entity, MainEntity)>,
+    /// A sorted list of all entities that were invisible last frame (including
+    /// ones that didn't exist at all last frame) and became visible this frame.
+    pub added_entities: Vec<(Entity, MainEntity)>,
+    /// A sorted list of all entities that were visible last frame and became
+    /// invisible this frame, including those that were despawned this frame.
+    pub removed_entities: Vec<(Entity, MainEntity)>,
 }
 
 impl RenderVisibleEntities {
-    pub fn get<QF>(&self) -> &[(Entity, MainEntity)]
+    pub fn get<QF>(&self) -> Option<&RenderVisibleMeshEntities>
     where
         QF: 'static,
     {
-        match self.entities.get(&TypeId::of::<QF>()) {
-            Some(entities) => &entities[..],
-            None => &[],
-        }
+        self.entities.get(&TypeId::of::<QF>())
     }
+}
 
-    pub fn iter<QF>(&self) -> impl DoubleEndedIterator<Item = &(Entity, MainEntity)>
-    where
-        QF: 'static,
-    {
-        self.get::<QF>().iter()
-    }
+impl RenderVisibleMeshEntities {
+    /// Processes a list of visible entities for a new frame, computing the set
+    /// of newly-added and newly-removed entities as it goes.
+    pub fn update_from(
+        &mut self,
+        mapper: &Extract<Query<RenderEntity>>,
+        visible_mesh_entities: &[Entity],
+    ) {
+        let old_entities = mem::take(&mut self.entities);
+        self.added_entities.clear();
+        self.removed_entities.clear();
 
-    pub fn len<QF>(&self) -> usize
-    where
-        QF: 'static,
-    {
-        self.get::<QF>().len()
-    }
+        // March over the old and new visible entity lists in lockstep, diffing
+        // as we go to determine the added and removed entities. The lists must
+        // be sorted.
+        let mut old_entity_iter = old_entities.iter().peekable();
+        for &visible_main_entity in visible_mesh_entities {
+            let visible_main_entity = MainEntity::from(visible_main_entity);
 
-    pub fn is_empty<QF>(&self) -> bool
-    where
-        QF: 'static,
-    {
-        self.get::<QF>().is_empty()
+            // Mark entities as removed until we see the one we're looking at.
+            while old_entity_iter
+                .peek()
+                .is_some_and(|(_, main_entity)| *main_entity < visible_main_entity)
+            {
+                self.removed_entities.push(*old_entity_iter.next().unwrap());
+            }
+
+            // Add the visible entity to the list.
+            let render_entity = mapper
+                .get(*visible_main_entity)
+                .unwrap_or(Entity::PLACEHOLDER);
+            self.entities.push((render_entity, visible_main_entity));
+
+            // If the next entity in the old list isn't equal to the entity we
+            // just marked visible, then our entity is newly visible this frame.
+            if old_entity_iter
+                .peek()
+                .is_some_and(|&&(_, main_entity)| main_entity == visible_main_entity)
+            {
+                old_entity_iter.next();
+            } else {
+                self.added_entities
+                    .push((render_entity, visible_main_entity));
+            }
+        }
+
+        // Any entities we didn't see yet are removed, so drain them.
+        self.removed_entities.extend(old_entity_iter.copied());
     }
 }
diff --git a/crates/bevy_sprite_render/src/mesh2d/material.rs b/crates/bevy_sprite_render/src/mesh2d/material.rs
index f96e93e475277..8dbce0f207b0d 100644
--- a/crates/bevy_sprite_render/src/mesh2d/material.rs
+++ b/crates/bevy_sprite_render/src/mesh2d/material.rs
@@ -1,7 +1,6 @@
 use crate::{
     init_mesh_2d_pipeline, DrawMesh2d, Mesh2d, Mesh2dPipeline, Mesh2dPipelineKey,
     RenderMesh2dInstances, SetMesh2dBindGroup, SetMesh2dViewBindGroup, ViewKeyCache,
-    ViewSpecializationTicks,
 };
 use bevy_app::{App, Plugin, PostUpdate};
 use bevy_asset::prelude::AssetChanged;
@@ -14,19 +13,19 @@ use bevy_core_pipeline::{
     tonemapping::Tonemapping,
 };
 use bevy_derive::{Deref, DerefMut};
-use bevy_ecs::change_detection::Tick;
-use bevy_ecs::system::SystemChangeTick;
 use bevy_ecs::{
     prelude::*,
     system::{lifetimeless::SRes, SystemParamItem},
 };
 use bevy_math::FloatOrd;
 use bevy_mesh::MeshVertexBufferLayoutRef;
-use bevy_platform::collections::HashMap;
+use bevy_platform::collections::{HashMap, HashSet};
+use bevy_platform::hash::FixedHasher;
 use bevy_reflect::{prelude::ReflectDefault, Reflect};
+use bevy_render::camera::{DirtySpecializationSystems, DirtySpecializations, PendingQueues};
 use bevy_render::render_resource::BindGroupLayoutDescriptor;
+use bevy_render::view::RetainedViewEntity;
 use bevy_render::{
-    camera::extract_cameras,
     mesh::RenderMesh,
     render_asset::{
         prepare_assets, PrepareAssetError, RenderAsset, RenderAssetPlugin, RenderAssets,
@@ -284,13 +283,14 @@ where
 
         if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
             render_app
-                .init_resource::<EntitySpecializationTickPair<M>>()
                 .init_resource::<SpecializedMaterial2dPipelineCache<M>>()
                 .add_render_command::<Opaque2d, DrawMaterial2d<M>>()
                 .add_render_command::<AlphaMask2d, DrawMaterial2d<M>>()
                 .add_render_command::<Transparent2d, DrawMaterial2d<M>>()
                 .init_resource::<RenderMaterial2dInstances<M>>()
                 .init_resource::<SpecializedMeshPipelines<Material2dPipeline<M>>>()
+                .init_resource::<PendingMeshMaterial2dQueues>()
+                .allow_ambiguous_resource::<PendingMeshMaterial2dQueues>()
                 .add_systems(
                     RenderStartup,
                     init_material_2d_pipeline::<M>.after(init_mesh_2d_pipeline),
@@ -298,7 +298,10 @@ where
                 .add_systems(
                     ExtractSchedule,
                     (
-                        extract_entities_needs_specialization::<M>.after(extract_cameras),
+                        extract_entities_needs_specialization::<M>
+                            .in_set(DirtySpecializationSystems::CheckForChanges),
+                        extract_entities_that_need_specializations_removed::<M>
+                            .in_set(DirtySpecializationSystems::CheckForRemovals),
                         extract_mesh_materials_2d::<M>,
                     ),
                 )
@@ -567,58 +570,51 @@ pub const fn tonemapping_pipeline_key(tonemapping: Tonemapping) -> Mesh2dPipelin
 
 pub fn extract_entities_needs_specialization<M>(
     entities_needing_specialization: Extract<Res<EntitiesNeedingSpecialization<M>>>,
-    mut entity_specialization_ticks: ResMut<EntitySpecializationTickPair<M>>,
-    mut removed_mesh_material_components: Extract<RemovedComponents<MeshMaterial2d<M>>>,
-    mut specialized_material2d_pipeline_cache: ResMut<SpecializedMaterial2dPipelineCache<M>>,
-    views: Query<&MainEntity, With<ExtractedView>>,
-    ticks: SystemChangeTick,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
 ) where
     M: Material2d,
 {
-    // Clean up any despawned entities, we do this first in case the removed material was re-added
-    // the same frame, thus will appear both in the removed components list and have been added to
-    // the `EntitiesNeedingSpecialization` collection by triggering the `Changed` filter
-    for entity in removed_mesh_material_components.read() {
-        entity_specialization_ticks.remove(&MainEntity::from(entity));
-        for view in views {
-            if let Some(cache) = specialized_material2d_pipeline_cache.get_mut(view) {
-                cache.remove(&MainEntity::from(entity));
-            }
-        }
+    // Drain the list of entities needing specialization from the main world
+    // into the render-world `DirtySpecializations` table.
+    for entity in entities_needing_specialization.changed.iter() {
+        dirty_specializations
+            .changed_renderables
+            .insert(MainEntity::from(*entity));
     }
-    for entity in entities_needing_specialization.iter() {
-        // Update the entity's specialization tick with this run's tick
-        entity_specialization_ticks.insert((*entity).into(), ticks.this_run());
-    }
-}
-
-#[derive(Clone, Resource, Deref, DerefMut, Debug)]
-pub struct EntitiesNeedingSpecialization<M> {
-    #[deref]
-    pub entities: Vec<Entity>,
-    _marker: PhantomData<M>,
 }
 
-impl<M> Default for EntitiesNeedingSpecialization<M> {
-    fn default() -> Self {
-        Self {
-            entities: Default::default(),
-            _marker: Default::default(),
-        }
+/// A system that adds entities that were judged to need their specializations
+/// removed to the appropriate table in [`DirtySpecializations`].
+pub fn extract_entities_that_need_specializations_removed<M>(
+    entities_needing_specialization: Extract<Res<EntitiesNeedingSpecialization<M>>>,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
+) where
+    M: Material2d,
+{
+    for entity in entities_needing_specialization.removed.iter() {
+        dirty_specializations
+            .removed_renderables
+            .insert(MainEntity::from(*entity));
     }
 }
 
-#[derive(Clone, Resource, Deref, DerefMut, Debug)]
-pub struct EntitySpecializationTickPair<M> {
-    #[deref]
-    pub entities: MainEntityHashMap<Tick>,
+/// Temporarily stores entities that were determined to either need their
+/// specialized pipelines updated or to have their specialized pipelines
+/// removed.
+#[derive(Clone, Resource, Debug)]
+pub struct EntitiesNeedingSpecialization<M> {
+    /// Entities that need to have their pipelines updated.
+    pub changed: Vec<Entity>,
+    /// Entities that need to have their pipelines removed.
+    pub removed: Vec<Entity>,
     _marker: PhantomData<M>,
 }
 
-impl<M> Default for EntitySpecializationTickPair<M> {
+impl<M> Default for EntitiesNeedingSpecialization<M> {
     fn default() -> Self {
         Self {
-            entities: MainEntityHashMap::default(),
+            changed: Default::default(),
+            removed: Default::default(),
             _marker: Default::default(),
         }
     }
@@ -639,7 +635,7 @@ pub struct SpecializedMaterial2dPipelineCache<M> {
 pub struct SpecializedMaterial2dViewPipelineCache<M> {
     // material entity -> (tick, pipeline_id)
     #[deref]
-    map: MainEntityHashMap<(Tick, CachedRenderPipelineId)>,
+    map: MainEntityHashMap<CachedRenderPipelineId>,
     marker: PhantomData<M>,
 }
 
@@ -661,6 +657,8 @@ impl<M> Default for SpecializedMaterial2dViewPipelineCache<M> {
     }
 }
 
+/// Finds 2D entities that have changed in such a way as to potentially require
+/// specialization and adds them to the [`EntitiesNeedingSpecialization`] list.
 pub fn check_entities_needing_specialization<M>(
     needs_specialization: Query<
         Entity,
@@ -676,18 +674,43 @@ pub fn check_entities_needing_specialization<M>(
     >,
     mut par_local: Local<Parallel<Vec<Entity>>>,
     mut entities_needing_specialization: ResMut<EntitiesNeedingSpecialization<M>>,
+    mut removed_mesh_2d_components: RemovedComponents<Mesh2d>,
+    mut removed_mesh_material_2d_components: RemovedComponents<MeshMaterial2d<M>>,
 ) where
     M: Material2d,
 {
-    entities_needing_specialization.clear();
+    entities_needing_specialization.changed.clear();
+    entities_needing_specialization.removed.clear();
 
+    // Gather all entities that need their specializations regenerated.
     needs_specialization
         .par_iter()
         .for_each(|entity| par_local.borrow_local_mut().push(entity));
-
-    par_local.drain_into(&mut entities_needing_specialization);
+    par_local.drain_into(&mut entities_needing_specialization.changed);
+
+    // All entities that removed their `Mesh2d` or `MeshMaterial2d` components
+    // need to have their specializations removed as well.
+    //
+    // It's possible that `Mesh2d` was removed and re-added in the same frame,
+    // but we don't have to handle that situation specially here, because
+    // `specialize_material2d_meshes` processes specialization removals before
+    // additions. So, if the pipeline specialization gets spuriously removed,
+    // it'll just be immediately re-added again, which is harmless.
+    for entity in removed_mesh_2d_components
+        .read()
+        .chain(removed_mesh_material_2d_components.read())
+    {
+        entities_needing_specialization.removed.push(entity);
+    }
 }
 
+/// Holds all entities with 2D mesh materials that couldn't be specialized
+/// and/or queued because their materials hadn't loaded yet.
+///
+/// See the [`PendingQueues`] documentation for more information.
+#[derive(Default, Deref, DerefMut, Resource)]
+pub struct PendingMeshMaterial2dQueues(pub PendingQueues);
+
 pub fn specialize_material2d_meshes<M: Material2d>(
     material2d_pipeline: Res<Material2dPipeline<M>>,
     mut pipelines: ResMut<SpecializedMeshPipelines<Material2dPipeline<M>>>,
@@ -703,9 +726,8 @@ pub fn specialize_material2d_meshes<M: Material2d>(
     alpha_mask_render_phases: Res<ViewBinnedRenderPhases<AlphaMask2d>>,
     views: Query<(&MainEntity, &ExtractedView, &RenderVisibleEntities)>,
     view_key_cache: Res<ViewKeyCache>,
-    entity_specialization_ticks: Res<EntitySpecializationTickPair<M>>,
-    view_specialization_ticks: Res<ViewSpecializationTicks>,
-    ticks: SystemChangeTick,
+    dirty_specializations: Res<DirtySpecializations>,
+    mut pending_mesh_material2d_queues: ResMut<PendingMeshMaterial2dQueues>,
     mut specialized_material_pipeline_cache: ResMut<SpecializedMaterial2dPipelineCache<M>>,
 ) where
     M::Data: PartialEq + Eq + Hash + Clone,
@@ -714,7 +736,13 @@ pub fn specialize_material2d_meshes<M: Material2d>(
         return;
     }
 
+    // Record the retained IDs of all views so that we can expire old pending
+    // queues.
+    let mut all_views: HashSet<RetainedViewEntity, FixedHasher> = HashSet::default();
+
     for (view_entity, view, visible_entities) in &views {
+        all_views.insert(view.retained_view_entity);
+
         if !transparent_render_phases.contains_key(&view.retained_view_entity)
             && !opaque_render_phases.contains_key(&view.retained_view_entity)
             && !alpha_mask_render_phases.contains_key(&view.retained_view_entity)
@@ -726,33 +754,57 @@ pub fn specialize_material2d_meshes<M: Material2d>(
             continue;
         };
 
-        let view_tick = view_specialization_ticks.get(view_entity).unwrap();
         let view_specialized_material_pipeline_cache = specialized_material_pipeline_cache
             .entry(*view_entity)
             .or_default();
 
-        for (_, visible_entity) in visible_entities.iter::<Mesh2d>() {
+        let Some(visible_entities) = visible_entities.get::<Mesh2d>() else {
+            continue;
+        };
+
+        // Remove cached pipeline IDs corresponding to entities that either
+        // have been removed or need to be re-specialized.
+        if dirty_specializations.must_wipe_specializations_for_view(view.retained_view_entity) {
+            view_specialized_material_pipeline_cache.clear();
+        } else {
+            for &renderable_entity in dirty_specializations.iter_to_despecialize() {
+                view_specialized_material_pipeline_cache.remove(&renderable_entity);
+            }
+        }
+
+        // Initialize the pending queues.
+        let view_pending_mesh_material2d_queues =
+            pending_mesh_material2d_queues.prepare_for_new_frame(view.retained_view_entity);
+
+        // Now process all 2D meshes that need to be re-specialized.
+        for (render_entity, visible_entity) in dirty_specializations.iter_to_specialize(
+            view.retained_view_entity,
+            visible_entities,
+            &view_pending_mesh_material2d_queues.prev_frame,
+        ) {
+            if view_specialized_material_pipeline_cache.contains_key(visible_entity) {
+                continue;
+            }
+
             let Some(material_asset_id) = render_material_instances.get(visible_entity) else {
+                // We couldn't fetch the material instance, probably because the
+                // material hasn't been loaded yet. Add the entity to the list
+                // of pending mesh materials and bail.
+                view_pending_mesh_material2d_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(mesh_instance) = render_mesh_instances.get_mut(visible_entity) else {
                 continue;
             };
-            let Some(entity_tick) = entity_specialization_ticks.get(visible_entity) else {
-                error!("{visible_entity:?} is missing specialization tick. Spawning Meshes in PostUpdate or later is currently not fully supported.");
-                continue;
-            };
-            let last_specialized_tick = view_specialized_material_pipeline_cache
-                .get(visible_entity)
-                .map(|(tick, _)| *tick);
-            let needs_specialization = last_specialized_tick.is_none_or(|tick| {
-                view_tick.is_newer_than(tick, ticks.this_run())
-                    || entity_tick.is_newer_than(tick, ticks.this_run())
-            });
-            if !needs_specialization {
-                continue;
-            }
             let Some(material_2d) = render_materials.get(*material_asset_id) else {
+                // We couldn't fetch the material instance, probably because the
+                // material hasn't been loaded yet. Add the entity to the list
+                // of pending mesh materials and bail.
+                view_pending_mesh_material2d_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(mesh) = render_meshes.get(mesh_instance.mesh_asset_id) else {
@@ -780,10 +832,11 @@ pub fn specialize_material2d_meshes<M: Material2d>(
                 }
             };
 
-            view_specialized_material_pipeline_cache
-                .insert(*visible_entity, (ticks.this_run(), pipeline_id));
+            view_specialized_material_pipeline_cache.insert(*visible_entity, pipeline_id);
         }
     }
+
+    pending_mesh_material2d_queues.expire_stale_views(&all_views);
 }
 
 pub fn queue_material2d_meshes<M: Material2d>(
@@ -797,6 +850,8 @@ pub fn queue_material2d_meshes<M: Material2d>(
     mut opaque_render_phases: ResMut<ViewBinnedRenderPhases<Opaque2d>>,
     mut alpha_mask_render_phases: ResMut<ViewBinnedRenderPhases<AlphaMask2d>>,
     views: Query<(&MainEntity, &ExtractedView, &RenderVisibleEntities)>,
+    dirty_specializations: Res<DirtySpecializations>,
+    mut pending_mesh_material2d_queues: ResMut<PendingMeshMaterial2dQueues>,
     specialized_material_pipeline_cache: ResMut<SpecializedMaterial2dPipelineCache<M>>,
 ) where
     M::Data: PartialEq + Eq + Hash + Clone,
@@ -824,28 +879,63 @@ pub fn queue_material2d_meshes<M: Material2d>(
             continue;
         };
 
-        for (render_entity, visible_entity) in visible_entities.iter::<Mesh2d>() {
-            let Some((current_change_tick, pipeline_id)) = view_specialized_material_pipeline_cache
+        let Some(visible_entities) = visible_entities.get::<Mesh2d>() else {
+            continue;
+        };
+
+        let view_pending_mesh_material2d_queues = pending_mesh_material2d_queues
+            .get_mut(&view.retained_view_entity)
+            .expect(
+                "View pending mesh material 2D queues should have been created in \
+                 `specialize_material2d_meshes`",
+            );
+
+        // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+        for &main_entity in
+            dirty_specializations.iter_to_dequeue(view.retained_view_entity, visible_entities)
+        {
+            // Note that this requires that all entities assigned to the
+            // transparent phase have `Entity::PLACEHOLDER` as their render
+            // entity.
+            transparent_phase.remove(Entity::PLACEHOLDER, main_entity);
+
+            opaque_phase.remove(main_entity);
+            alpha_mask_phase.remove(main_entity);
+        }
+
+        // Now iterate over all newly-visible entities and those that need
+        // specialization.
+        for (render_entity, visible_entity) in dirty_specializations.iter_to_queue(
+            view.retained_view_entity,
+            visible_entities,
+            &view_pending_mesh_material2d_queues.prev_frame,
+        ) {
+            let Some(pipeline_id) = view_specialized_material_pipeline_cache
                 .get(visible_entity)
-                .map(|(current_change_tick, pipeline_id)| (*current_change_tick, *pipeline_id))
+                .copied()
             else {
                 continue;
             };
 
-            // Skip the entity if it's cached in a bin and up to date.
-            if opaque_phase.validate_cached_entity(*visible_entity, current_change_tick)
-                || alpha_mask_phase.validate_cached_entity(*visible_entity, current_change_tick)
-            {
-                continue;
-            }
-
             let Some(material_asset_id) = render_material_instances.get(visible_entity) else {
+                // We couldn't fetch the material instance, probably because the
+                // material hasn't been loaded yet. Add the entity to the list
+                // of pending mesh materials and bail.
+                view_pending_mesh_material2d_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(mesh_instance) = render_mesh_instances.get_mut(visible_entity) else {
                 continue;
             };
             let Some(material_2d) = render_materials.get(*material_asset_id) else {
+                // We couldn't fetch the material instance, probably because the
+                // material hasn't been loaded yet. Add the entity to the list
+                // of pending mesh materials and bail.
+                view_pending_mesh_material2d_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(mesh) = render_meshes.get(mesh_instance.mesh_asset_id) else {
@@ -882,7 +972,6 @@ pub fn queue_material2d_meshes<M: Material2d>(
                         (*render_entity, *visible_entity),
                         InputUniformIndex::default(),
                         binned_render_phase_type,
-                        current_change_tick,
                     );
                 }
                 AlphaMode2d::Mask(_) => {
@@ -900,12 +989,25 @@ pub fn queue_material2d_meshes<M: Material2d>(
                         (*render_entity, *visible_entity),
                         InputUniformIndex::default(),
                         binned_render_phase_type,
-                        current_change_tick,
                     );
                 }
                 AlphaMode2d::Blend => {
+                    // We have to use `Entity::PLACEHOLDER` as the render entity
+                    // so that we can dequeue the items later with
+                    // `iter_to_dequeue` above.
+                    // Items can be removed from binned phases by knowing their
+                    // main entity alone, but items can only be removed from
+                    // sorted phases if both the render entity and main world
+                    // entity are known. So we have to use a fixed value,
+                    // `Entity::PLACEHOLDER`, here, because
+                    // `DirtySpecializations` only tracks main world entities,
+                    // not render world ones.
+                    // Really, in the future we should get rid of the render
+                    // entity field here entirely, but we currently can't do so
+                    // because UI creates multiple render entities for each main
+                    // entity in its sorted phases.
                     transparent_phase.add(Transparent2d {
-                        entity: (*render_entity, *visible_entity),
+                        entity: (Entity::PLACEHOLDER, *visible_entity),
                         draw_function: material_2d.properties.draw_function_id,
                         pipeline: pipeline_id,
                         // NOTE: Back-to-front ordering for transparent with ascending sort means far should have the
diff --git a/crates/bevy_sprite_render/src/mesh2d/mesh.rs b/crates/bevy_sprite_render/src/mesh2d/mesh.rs
index d1f861dc87bf0..7019913350f38 100644
--- a/crates/bevy_sprite_render/src/mesh2d/mesh.rs
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh.rs
@@ -1,7 +1,7 @@
 use bevy_app::Plugin;
 use bevy_asset::{embedded_asset, load_embedded_asset, AssetId, AssetServer, Handle};
 use bevy_camera::{visibility::ViewVisibility, Camera2d};
-use bevy_render::RenderStartup;
+use bevy_render::{camera::DirtySpecializations, RenderStartup};
 use bevy_shader::{load_shader_library, Shader, ShaderDefVal, ShaderSettings};
 
 use crate::{tonemapping_pipeline_key, Material2dBindGroupId};
@@ -13,8 +13,6 @@ use bevy_core_pipeline::{
     },
 };
 use bevy_derive::{Deref, DerefMut};
-use bevy_ecs::change_detection::Tick;
-use bevy_ecs::system::SystemChangeTick;
 use bevy_ecs::{
     prelude::*,
     query::ROQueryItem,
@@ -38,8 +36,7 @@ use bevy_render::{
     mesh::{allocator::MeshAllocator, RenderMesh, RenderMeshBufferInfo},
     render_asset::RenderAssets,
     render_phase::{
-        sweep_old_entities, PhaseItem, PhaseItemExtraIndex, RenderCommand, RenderCommandResult,
-        TrackedRenderPass,
+        PhaseItem, PhaseItemExtraIndex, RenderCommand, RenderCommandResult, TrackedRenderPass,
     },
     render_resource::{binding_types::uniform_buffer, *},
     renderer::RenderDevice,
@@ -76,7 +73,6 @@ impl Plugin for Mesh2dRenderPlugin {
                 .init_resource::<RenderMesh2dInstances>()
                 .allow_ambiguous_resource::<RenderMesh2dInstances>()
                 .init_resource::<SpecializedMeshPipelines<Mesh2dPipeline>>()
-                .init_resource::<ViewSpecializationTicks>()
                 .add_systems(
                     RenderStartup,
                     (
@@ -91,11 +87,6 @@ impl Plugin for Mesh2dRenderPlugin {
                     Render,
                     (
                         check_views_need_specialization.in_set(PrepareAssets),
-                        (
-                            sweep_old_entities::<Opaque2d>,
-                            sweep_old_entities::<AlphaMask2d>,
-                        )
-                            .in_set(RenderSystems::QueueSweep),
                         batch_and_prepare_binned_render_phase::<Opaque2d, Mesh2dPipeline>
                             .in_set(RenderSystems::PrepareResources),
                         batch_and_prepare_binned_render_phase::<AlphaMask2d, Mesh2dPipeline>
@@ -118,12 +109,9 @@ impl Plugin for Mesh2dRenderPlugin {
 #[derive(Resource, Deref, DerefMut, Default, Debug, Clone)]
 pub struct ViewKeyCache(MainEntityHashMap<Mesh2dPipelineKey>);
 
-#[derive(Resource, Deref, DerefMut, Default, Debug, Clone)]
-pub struct ViewSpecializationTicks(MainEntityHashMap<Tick>);
-
 pub fn check_views_need_specialization(
     mut view_key_cache: ResMut<ViewKeyCache>,
-    mut view_specialization_ticks: ResMut<ViewSpecializationTicks>,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
     views: Query<(
         &MainEntity,
         &ExtractedView,
@@ -131,7 +119,6 @@ pub fn check_views_need_specialization(
         Option<&Tonemapping>,
         Option<&DebandDither>,
     )>,
-    ticks: SystemChangeTick,
 ) {
     for (view_entity, view, msaa, tonemapping, dither) in &views {
         let mut view_key = Mesh2dPipelineKey::from_msaa_samples(msaa.samples())
@@ -152,7 +139,9 @@ pub fn check_views_need_specialization(
             .is_some_and(|current_key| *current_key == view_key)
         {
             view_key_cache.insert(*view_entity, view_key);
-            view_specialization_ticks.insert(*view_entity, ticks.this_run());
+            dirty_specializations
+                .views
+                .insert(view.retained_view_entity);
         }
     }
 }
diff --git a/crates/bevy_sprite_render/src/mesh2d/wireframe2d.rs b/crates/bevy_sprite_render/src/mesh2d/wireframe2d.rs
index a73b99621cb4c..6878ff8a47c71 100644
--- a/crates/bevy_sprite_render/src/mesh2d/wireframe2d.rs
+++ b/crates/bevy_sprite_render/src/mesh2d/wireframe2d.rs
@@ -1,6 +1,6 @@
 use crate::{
     init_mesh_2d_pipeline, DrawMesh2d, Mesh2dPipeline, Mesh2dPipelineKey, RenderMesh2dInstances,
-    SetMesh2dBindGroup, SetMesh2dViewBindGroup, ViewKeyCache, ViewSpecializationTicks,
+    SetMesh2dBindGroup, SetMesh2dViewBindGroup, ViewKeyCache,
 };
 use bevy_app::{App, Plugin, PostUpdate, Startup, Update};
 use bevy_asset::{
@@ -24,7 +24,10 @@ use bevy_platform::{
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
 use bevy_render::{
     batching::gpu_preprocessing::GpuPreprocessingMode,
-    camera::ExtractedCamera,
+    camera::{
+        extract_cameras, DirtySpecializationSystems, DirtyWireframeSpecializations,
+        ExtractedCamera, PendingQueues,
+    },
     extract_resource::ExtractResource,
     mesh::{
         allocator::{MeshAllocator, SlabId},
@@ -109,12 +112,12 @@ impl Plugin for Wireframe2dPlugin {
         };
 
         render_app
-            .init_resource::<WireframeEntitySpecializationTicks>()
             .init_resource::<SpecializedWireframePipelineCache>()
             .init_resource::<DrawFunctions<Wireframe2dPhaseItem>>()
             .add_render_command::<Wireframe2dPhaseItem, DrawWireframe2d>()
             .init_resource::<RenderWireframeInstances>()
             .init_resource::<SpecializedMeshPipelines<Wireframe2dPipeline>>()
+            .init_resource::<PendingWireframe2dQueues>()
             .add_systems(
                 Core2d,
                 wireframe_2d
@@ -129,8 +132,13 @@ impl Plugin for Wireframe2dPlugin {
                 ExtractSchedule,
                 (
                     extract_wireframe_2d_camera,
-                    extract_wireframe_entities_needing_specialization,
                     extract_wireframe_materials,
+                    extract_wireframe_2d_entities_needing_specialization
+                        .after(extract_cameras)
+                        .in_set(DirtySpecializationSystems::CheckForChanges),
+                    extract_wireframe_2d_entities_that_need_specializations_removed
+                        .after(extract_cameras)
+                        .in_set(DirtySpecializationSystems::CheckForRemovals),
                 ),
             )
             .add_systems(
@@ -461,15 +469,15 @@ impl RenderAsset for RenderWireframeMaterial {
 #[derive(Resource, Deref, DerefMut, Default)]
 pub struct RenderWireframeInstances(MainEntityHashMap<AssetId<Wireframe2dMaterial>>);
 
-#[derive(Clone, Resource, Deref, DerefMut, Debug, Default)]
+/// Temporarily stores entities that were determined to either need their
+/// specialized pipelines for wireframes updated or to have their specialized
+/// pipelines for wireframes removed.
+#[derive(Clone, Resource, Debug, Default)]
 pub struct WireframeEntitiesNeedingSpecialization {
-    #[deref]
-    pub entities: Vec<Entity>,
-}
-
-#[derive(Resource, Deref, DerefMut, Clone, Debug, Default)]
-pub struct WireframeEntitySpecializationTicks {
-    pub entities: MainEntityHashMap<Tick>,
+    /// Entities that need to have their pipelines updated.
+    pub changed: Vec<Entity>,
+    /// Entities that need to have their pipelines removed.
+    pub removed: Vec<Entity>,
 }
 
 /// Stores the [`SpecializedWireframeViewPipelineCache`] for each view.
@@ -658,30 +666,33 @@ fn extract_wireframe_2d_camera(
     wireframe_2d_phases.retain(|camera_entity, _| live_entities.contains(camera_entity));
 }
 
-pub fn extract_wireframe_entities_needing_specialization(
+pub fn extract_wireframe_2d_entities_needing_specialization(
     entities_needing_specialization: Extract<Res<WireframeEntitiesNeedingSpecialization>>,
-    mut entity_specialization_ticks: ResMut<WireframeEntitySpecializationTicks>,
-    views: Query<&ExtractedView>,
-    mut specialized_wireframe_pipeline_cache: ResMut<SpecializedWireframePipelineCache>,
-    mut removed_meshes_query: Extract<RemovedComponents<Mesh2d>>,
-    ticks: SystemChangeTick,
+    mut dirty_specializations: ResMut<DirtyWireframeSpecializations>,
 ) {
-    for entity in entities_needing_specialization.iter() {
-        // Update the entity's specialization tick with this run's tick
-        entity_specialization_ticks.insert((*entity).into(), ticks.this_run());
+    for entity in entities_needing_specialization.changed.iter() {
+        dirty_specializations
+            .changed_renderables
+            .insert(MainEntity::from(*entity));
     }
+}
 
-    for entity in removed_meshes_query.read() {
-        for view in &views {
-            if let Some(specialized_wireframe_pipeline_cache) =
-                specialized_wireframe_pipeline_cache.get_mut(&view.retained_view_entity)
-            {
-                specialized_wireframe_pipeline_cache.remove(&MainEntity::from(entity));
-            }
-        }
+/// A system that adds entities that were judged to need their specializations
+/// removed to the appropriate table in [`DirtyWireframeSpecializations`].
+pub fn extract_wireframe_2d_entities_that_need_specializations_removed(
+    entities_needing_specialization: Extract<Res<WireframeEntitiesNeedingSpecialization>>,
+    mut dirty_specializations: ResMut<DirtyWireframeSpecializations>,
+) {
+    for entity in entities_needing_specialization.removed.iter() {
+        dirty_specializations
+            .removed_renderables
+            .insert(MainEntity::from(*entity));
     }
 }
 
+/// Finds 2D wireframe entities that have changed in such a way as to
+/// potentially require specialization and adds them to the
+/// [`WireframeEntitiesNeedingSpecialization`] list.
 pub fn check_wireframe_entities_needing_specialization(
     needs_specialization: Query<
         Entity,
@@ -693,13 +704,33 @@ pub fn check_wireframe_entities_needing_specialization(
         )>,
     >,
     mut entities_needing_specialization: ResMut<WireframeEntitiesNeedingSpecialization>,
+    mut removed_mesh_2d_components: RemovedComponents<Mesh2d>,
+    mut removed_mesh_2d_wireframe_components: RemovedComponents<Mesh2dWireframe>,
 ) {
-    entities_needing_specialization.clear();
+    // Gather all entities that need their specializations regenerated.
     for entity in &needs_specialization {
-        entities_needing_specialization.push(entity);
+        entities_needing_specialization.changed.push(entity);
+    }
+
+    // All entities that removed their `Mesh2d` or `Mesh2dWireframe` components
+    // need to have their specializations removed as well.
+    //
+    // It's possible that `Mesh2d` was removed and re-added in the same frame,
+    // but we don't have to handle that situation specially here, because
+    // `specialize_wireframes` processes specialization removals before
+    // additions. So, if the pipeline specialization gets spuriously removed,
+    // it'll just be immediately re-added again, which is harmless.
+    for entity in removed_mesh_2d_components
+        .read()
+        .chain(removed_mesh_2d_wireframe_components.read())
+    {
+        entities_needing_specialization.removed.push(entity);
     }
 }
 
+#[derive(Default, Deref, DerefMut, Resource)]
+pub struct PendingWireframe2dQueues(pub PendingQueues);
+
 pub fn specialize_wireframes(
     render_meshes: Res<RenderAssets<RenderMesh>>,
     render_mesh_instances: Res<RenderMesh2dInstances>,
@@ -707,9 +738,9 @@ pub fn specialize_wireframes(
     wireframe_phases: Res<ViewBinnedRenderPhases<Wireframe2dPhaseItem>>,
     views: Query<(&ExtractedView, &RenderVisibleEntities)>,
     view_key_cache: Res<ViewKeyCache>,
-    entity_specialization_ticks: Res<WireframeEntitySpecializationTicks>,
-    view_specialization_ticks: Res<ViewSpecializationTicks>,
+    dirty_wireframe_specializations: Res<DirtyWireframeSpecializations>,
     mut specialized_material_pipeline_cache: ResMut<SpecializedWireframePipelineCache>,
+    mut pending_wireframe2d_queues: ResMut<PendingWireframe2dQueues>,
     mut pipelines: ResMut<SpecializedMeshPipelines<Wireframe2dPipeline>>,
     pipeline: Res<Wireframe2dPipeline>,
     pipeline_cache: Res<PipelineCache>,
@@ -730,31 +761,46 @@ pub fn specialize_wireframes(
             continue;
         };
 
-        let view_tick = view_specialization_ticks
-            .get(&view.retained_view_entity.main_entity)
-            .unwrap();
         let view_specialized_material_pipeline_cache = specialized_material_pipeline_cache
             .entry(view.retained_view_entity)
             .or_default();
 
-        for (_, visible_entity) in visible_entities.iter::<Mesh2d>() {
+        let Some(visible_entities) = visible_entities.get::<Mesh2d>() else {
+            continue;
+        };
+
+        // Initialize the pending queues.
+        let view_pending_wireframe2d_queues =
+            pending_wireframe2d_queues.prepare_for_new_frame(view.retained_view_entity);
+
+        // Remove cached pipeline IDs corresponding to entities that
+        // either have been removed or need to be respecialized.
+        if dirty_wireframe_specializations
+            .must_wipe_specializations_for_view(view.retained_view_entity)
+        {
+            view_specialized_material_pipeline_cache.clear();
+        } else {
+            for &renderable_entity in dirty_wireframe_specializations.iter_to_despecialize() {
+                view_specialized_material_pipeline_cache.remove(&renderable_entity);
+            }
+        }
+
+        // Now iterate over all 2D wireframes that need specialization.
+        for (_, visible_entity) in dirty_wireframe_specializations.iter_to_specialize(
+            view.retained_view_entity,
+            visible_entities,
+            &view_pending_wireframe2d_queues.prev_frame,
+        ) {
+            if view_specialized_material_pipeline_cache.contains_key(visible_entity) {
+                continue;
+            }
+
             if !render_wireframe_instances.contains_key(visible_entity) {
                 continue;
             };
             let Some(mesh_instance) = render_mesh_instances.get(visible_entity) else {
                 continue;
             };
-            let entity_tick = entity_specialization_ticks.get(visible_entity).unwrap();
-            let last_specialized_tick = view_specialized_material_pipeline_cache
-                .get(visible_entity)
-                .map(|(tick, _)| *tick);
-            let needs_specialization = last_specialized_tick.is_none_or(|tick| {
-                view_tick.is_newer_than(tick, ticks.this_run())
-                    || entity_tick.is_newer_than(tick, ticks.this_run())
-            });
-            if !needs_specialization {
-                continue;
-            }
             let Some(mesh) = render_meshes.get(mesh_instance.mesh_asset_id) else {
                 continue;
             };
@@ -777,6 +823,8 @@ pub fn specialize_wireframes(
         }
     }
 
+    pending_wireframe2d_queues.expire_stale_views(&all_views);
+
     // Delete specialized pipelines belonging to views that have expired.
     specialized_material_pipeline_cache
         .retain(|retained_view_entity, _| all_views.contains(retained_view_entity));
@@ -788,7 +836,9 @@ fn queue_wireframes(
     mesh_allocator: Res<MeshAllocator>,
     specialized_wireframe_pipeline_cache: Res<SpecializedWireframePipelineCache>,
     render_wireframe_instances: Res<RenderWireframeInstances>,
+    dirty_wireframe_specializations: Res<DirtyWireframeSpecializations>,
     mut wireframe_2d_phases: ResMut<ViewBinnedRenderPhases<Wireframe2dPhaseItem>>,
+    mut pending_wireframe2d_queues: ResMut<PendingWireframe2dQueues>,
     mut views: Query<(&ExtractedView, &RenderVisibleEntities)>,
 ) {
     for (view, visible_entities) in &mut views {
@@ -803,21 +853,47 @@ fn queue_wireframes(
             continue;
         };
 
-        for (render_entity, visible_entity) in visible_entities.iter::<Mesh2d>() {
+        let Some(visible_entities) = visible_entities.get::<Mesh2d>() else {
+            continue;
+        };
+
+        // Fetch the pending queues.
+        let view_pending_wireframe2d_queues = pending_wireframe2d_queues
+            .get_mut(&view.retained_view_entity)
+            .expect(
+                "View pending 2D wireframe queues should have been created in \
+                 `specialize_wireframes`",
+            );
+
+        // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+        for &main_entity in dirty_wireframe_specializations
+            .iter_to_dequeue(view.retained_view_entity, visible_entities)
+        {
+            wireframe_phase.remove(main_entity);
+        }
+
+        // Now iterate through all newly-visible entities and those needing respecialization.
+        for (render_entity, visible_entity) in dirty_wireframe_specializations.iter_to_queue(
+            view.retained_view_entity,
+            visible_entities,
+            &view_pending_wireframe2d_queues.prev_frame,
+        ) {
             let Some(wireframe_instance) = render_wireframe_instances.get(visible_entity) else {
                 continue;
             };
-            let Some((current_change_tick, pipeline_id)) = view_specialized_material_pipeline_cache
+            let Some(pipeline_id) = view_specialized_material_pipeline_cache
                 .get(visible_entity)
-                .map(|(current_change_tick, pipeline_id)| (*current_change_tick, *pipeline_id))
+                .map(|(_, pipeline_id)| *pipeline_id)
             else {
+                // We couldn't fetch the material, probably because the material
+                // hasn't been loaded yet. Add the entity to the list of pending
+                // mesh materials and bail.
+                view_pending_wireframe2d_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
 
-            // Skip the entity if it's cached in a bin and up to date.
-            if wireframe_phase.validate_cached_entity(*visible_entity, current_change_tick) {
-                continue;
-            }
             let Some(mesh_instance) = render_mesh_instances.get(visible_entity) else {
                 continue;
             };
@@ -842,7 +918,6 @@ fn queue_wireframes(
                 } else {
                     BinnedRenderPhaseType::UnbatchableMesh
                 },
-                current_change_tick,
             );
         }
     }
diff --git a/crates/bevy_sprite_render/src/render/mod.rs b/crates/bevy_sprite_render/src/render/mod.rs
index 8bcbba16048e9..4e488fe5ef822 100644
--- a/crates/bevy_sprite_render/src/render/mod.rs
+++ b/crates/bevy_sprite_render/src/render/mod.rs
@@ -521,11 +521,14 @@ pub fn queue_sprites(
         let pipeline = pipelines.specialize(&pipeline_cache, &sprite_pipeline, view_key);
 
         view_entities.clear();
-        view_entities.extend(
-            visible_entities
-                .iter::<Sprite>()
-                .map(|(_, e)| e.index_u32() as usize),
-        );
+        if let Some(visible_entities) = visible_entities.get::<Sprite>() {
+            view_entities.extend(
+                visible_entities
+                    .entities
+                    .iter()
+                    .map(|(_, e)| e.index_u32() as usize),
+            );
+        }
 
         transparent_phase
             .items
@@ -542,7 +545,7 @@ pub fn queue_sprites(
             let sort_key = FloatOrd(extracted_sprite.transform.translation().z);
 
             // Add the item to the render phase
-            transparent_phase.add(Transparent2d {
+            transparent_phase.add_transient(Transparent2d {
                 draw_function: draw_sprite_function,
                 pipeline,
                 entity: (
diff --git a/crates/bevy_ui_render/Cargo.toml b/crates/bevy_ui_render/Cargo.toml
index 44e4946270b26..06fd028648204 100644
--- a/crates/bevy_ui_render/Cargo.toml
+++ b/crates/bevy_ui_render/Cargo.toml
@@ -39,6 +39,7 @@ bevy_text = { path = "../bevy_text", version = "0.19.0-dev" }
 bytemuck = { version = "1.5", features = ["derive"] }
 derive_more = { version = "2", default-features = false, features = ["from"] }
 tracing = { version = "0.1", default-features = false, features = ["std"] }
+indexmap = { version = "2" }
 
 [features]
 default = ["bevy_ui_debug"]
diff --git a/crates/bevy_ui_render/src/box_shadow.rs b/crates/bevy_ui_render/src/box_shadow.rs
index f859c096485a1..2b0c4a410daaa 100644
--- a/crates/bevy_ui_render/src/box_shadow.rs
+++ b/crates/bevy_ui_render/src/box_shadow.rs
@@ -338,7 +338,7 @@ pub fn queue_shadows(
             },
         );
 
-        transparent_phase.add(TransparentUi {
+        transparent_phase.add_transient(TransparentUi {
             draw_function,
             pipeline,
             entity: (entity, extracted_shadow.main_entity),
diff --git a/crates/bevy_ui_render/src/gradient.rs b/crates/bevy_ui_render/src/gradient.rs
index 67c9133c9a3e0..03dc8784ab965 100644
--- a/crates/bevy_ui_render/src/gradient.rs
+++ b/crates/bevy_ui_render/src/gradient.rs
@@ -616,7 +616,7 @@ pub fn queue_gradient(
             },
         );
 
-        transparent_phase.add(TransparentUi {
+        transparent_phase.add_transient(TransparentUi {
             draw_function,
             pipeline,
             entity: (gradient.render_entity, gradient.main_entity),
diff --git a/crates/bevy_ui_render/src/lib.rs b/crates/bevy_ui_render/src/lib.rs
index fee505ee9ac04..78a856474f57c 100644
--- a/crates/bevy_ui_render/src/lib.rs
+++ b/crates/bevy_ui_render/src/lib.rs
@@ -768,7 +768,7 @@ pub fn extract_ui_camera_view(
             if let Some(shadow_samples) = shadow_samples {
                 entity_commands.insert(*shadow_samples);
             }
-            transparent_render_phases.insert_or_clear(retained_view_entity);
+            transparent_render_phases.prepare_for_new_frame(retained_view_entity);
 
             live_entities.insert(retained_view_entity);
         }
@@ -1351,7 +1351,7 @@ pub fn queue_uinodes(
             },
         );
 
-        transparent_phase.add(TransparentUi {
+        transparent_phase.add_transient(TransparentUi {
             draw_function,
             pipeline,
             entity: (extracted_uinode.render_entity, extracted_uinode.main_entity),
diff --git a/crates/bevy_ui_render/src/render_pass.rs b/crates/bevy_ui_render/src/render_pass.rs
index 53182abae2ba9..116c68c171405 100644
--- a/crates/bevy_ui_render/src/render_pass.rs
+++ b/crates/bevy_ui_render/src/render_pass.rs
@@ -4,6 +4,7 @@ use super::{ImageNodeBindGroups, UiBatch, UiMeta, UiViewTarget};
 
 use crate::UiCameraView;
 use bevy_ecs::{
+    entity::EntityHash,
     prelude::*,
     system::{lifetimeless::*, SystemParamItem},
 };
@@ -17,6 +18,7 @@ use bevy_render::{
     sync_world::MainEntity,
     view::*,
 };
+use indexmap::IndexMap;
 use tracing::error;
 
 pub fn ui_pass(
@@ -128,8 +130,15 @@ impl SortedPhaseItem for TransparentUi {
     }
 
     #[inline]
-    fn sort(items: &mut [Self]) {
-        items.sort_by_key(SortedPhaseItem::sort_key);
+    fn sort(items: &mut IndexMap<(Entity, MainEntity), TransparentUi, EntityHash>) {
+        items.sort_by_key(|_, value| value.sort_key());
+    }
+
+    fn recalculate_sort_keys(
+        _: &mut IndexMap<(Entity, MainEntity), Self, EntityHash>,
+        _: &ExtractedView,
+    ) {
+        // Sort keys are precalculated for UI phase items.
     }
 
     #[inline]
diff --git a/crates/bevy_ui_render/src/ui_material_pipeline.rs b/crates/bevy_ui_render/src/ui_material_pipeline.rs
index 7937a4246ccca..ad1e1ab6cbfd4 100644
--- a/crates/bevy_ui_render/src/ui_material_pipeline.rs
+++ b/crates/bevy_ui_render/src/ui_material_pipeline.rs
@@ -634,7 +634,7 @@ pub fn queue_ui_material_nodes<M: UiMaterial>(
                 extracted_uinodes.uinodes.len() - transparent_phase.items.capacity(),
             );
         }
-        transparent_phase.add(TransparentUi {
+        transparent_phase.add_transient(TransparentUi {
             draw_function,
             pipeline,
             entity: (extracted_uinode.render_entity, extracted_uinode.main_entity),
diff --git a/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs b/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs
index ecd7f2512ce49..47ca41b77df1e 100644
--- a/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs
+++ b/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs
@@ -339,7 +339,7 @@ pub fn queue_ui_slices(
             UiTextureSlicePipelineKey { hdr: view.hdr },
         );
 
-        transparent_phase.add(TransparentUi {
+        transparent_phase.add_transient(TransparentUi {
             draw_function,
             pipeline,
             entity: (extracted_slicer.render_entity, extracted_slicer.main_entity),
diff --git a/examples/2d/mesh2d_manual.rs b/examples/2d/mesh2d_manual.rs
index 484e67cbad518..ea21b2643e7d6 100644
--- a/examples/2d/mesh2d_manual.rs
+++ b/examples/2d/mesh2d_manual.rs
@@ -404,7 +404,10 @@ pub fn queue_colored_mesh2d(
             | Mesh2dPipelineKey::from_hdr(view.hdr);
 
         // Queue all entities visible to that view
-        for (render_entity, visible_entity) in visible_entities.iter::<Mesh2d>() {
+        let Some(visible_entities) = visible_entities.get::<Mesh2d>() else {
+            continue;
+        };
+        for (render_entity, visible_entity) in visible_entities.entities.iter() {
             if let Some(mesh_instance) = render_mesh_instances.get(visible_entity) {
                 let mesh2d_handle = mesh_instance.mesh_asset_id;
                 let mesh2d_transforms = &mesh_instance.transforms;
diff --git a/examples/shader_advanced/custom_phase_item.rs b/examples/shader_advanced/custom_phase_item.rs
index 32ad10146dd18..01cba00e1e000 100644
--- a/examples/shader_advanced/custom_phase_item.rs
+++ b/examples/shader_advanced/custom_phase_item.rs
@@ -14,13 +14,13 @@ use bevy::{
     },
     core_pipeline::core_3d::{Opaque3d, Opaque3dBatchSetKey, Opaque3dBinKey, CORE_3D_DEPTH_FORMAT},
     ecs::{
-        change_detection::Tick,
         query::ROQueryItem,
         system::{lifetimeless::SRes, SystemParamItem},
     },
     mesh::VertexBufferLayout,
     prelude::*,
     render::{
+        camera::{DirtySpecializations, PendingQueues},
         extract_component::{ExtractComponent, ExtractComponentPlugin},
         render_phase::{
             AddRenderCommand, BinnedRenderPhaseType, DrawFunctions, InputUniformIndex, PhaseItem,
@@ -169,6 +169,7 @@ fn main() {
     // We make sure to add these to the render app, not the main app.
     app.sub_app_mut(RenderApp)
         .init_resource::<CustomPhasePipeline>()
+        .init_resource::<PendingCustomPhaseItemQueues>()
         .add_render_command::<Opaque3d, DrawCustomPhaseItemCommands>()
         .add_systems(
             Render,
@@ -209,6 +210,17 @@ fn prepare_custom_phase_item_buffers(mut commands: Commands) {
     commands.init_resource::<CustomPhaseItemBuffers>();
 }
 
+/// A resource that holds entities that couldn't be specialized and/or queued
+/// yet because their dependent assets haven't loaded yet.
+///
+/// In this particular example, entities with custom rendering can always be
+/// specialized, so this resource goes unused in practice. However, we still
+/// need it, because [`DirtySpecializations`] requires such a resource.
+///
+/// See the documentation of [`PendingQueues`] for more information.
+#[derive(Default, Deref, DerefMut, Resource)]
+pub struct PendingCustomPhaseItemQueues(pub PendingQueues);
+
 /// A render-world system that enqueues the entity with custom rendering into
 /// the opaque render phases of each view.
 fn queue_custom_phase_item(
@@ -217,7 +229,8 @@ fn queue_custom_phase_item(
     mut opaque_render_phases: ResMut<ViewBinnedRenderPhases<Opaque3d>>,
     opaque_draw_functions: Res<DrawFunctions<Opaque3d>>,
     views: Query<(&ExtractedView, &RenderVisibleEntities, &Msaa)>,
-    mut next_tick: Local<Tick>,
+    dirty_specializations: Res<DirtySpecializations>,
+    mut pending_custom_phase_item_queues: ResMut<PendingCustomPhaseItemQueues>,
 ) {
     let draw_custom_phase_item = opaque_draw_functions
         .read()
@@ -231,9 +244,33 @@ fn queue_custom_phase_item(
             continue;
         };
 
+        // Fetch the list of visible entities in the `CustomRenderedEntity`
+        // class. If there are no such entities, then we have no entities to
+        // render, and we're done.
+        let Some(render_visible_mesh_entities) =
+            view_visible_entities.get::<CustomRenderedEntity>()
+        else {
+            continue;
+        };
+
+        let view_pending_custom_phase_item_queues =
+            pending_custom_phase_item_queues.prepare_for_new_frame(view.retained_view_entity);
+
+        // First, remove meshes that need to be respecialized, and those that
+        // were removed, from the bins.
+        for &main_entity in dirty_specializations
+            .iter_to_dequeue(view.retained_view_entity, render_visible_mesh_entities)
+        {
+            opaque_phase.remove(main_entity);
+        }
+
         // Find all the custom rendered entities that are visible from this
         // view.
-        for &entity in view_visible_entities.get::<CustomRenderedEntity>().iter() {
+        for entity_pair in dirty_specializations.iter_to_queue(
+            view.retained_view_entity,
+            render_visible_mesh_entities,
+            &view_pending_custom_phase_item_queues.prev_frame,
+        ) {
             // Ordinarily, the [`SpecializedRenderPipeline::Key`] would contain
             // some per-view settings, such as whether the view is HDR, but for
             // simplicity's sake we simply hard-code the view's characteristics,
@@ -245,10 +282,6 @@ fn queue_custom_phase_item(
                 continue;
             };
 
-            // Bump the change tick in order to force Bevy to rebuild the bin.
-            let this_tick = next_tick.get() + 1;
-            next_tick.set(this_tick);
-
             // Add the custom render item. We use the
             // [`BinnedRenderPhaseType::NonMesh`] type to skip the special
             // handling that Bevy has for meshes (preprocessing, indirect
@@ -269,10 +302,9 @@ fn queue_custom_phase_item(
                 Opaque3dBinKey {
                     asset_id: AssetId::<Mesh>::invalid().untyped(),
                 },
-                entity,
+                *entity_pair,
                 InputUniformIndex::default(),
                 BinnedRenderPhaseType::NonMesh,
-                *next_tick,
             );
         }
     }
diff --git a/examples/shader_advanced/custom_render_phase.rs b/examples/shader_advanced/custom_render_phase.rs
index 23c8cd0e15cc0..009a961723202 100644
--- a/examples/shader_advanced/custom_render_phase.rs
+++ b/examples/shader_advanced/custom_render_phase.rs
@@ -13,12 +13,16 @@
 use std::ops::Range;
 
 use bevy::camera::Viewport;
+use bevy::core_pipeline::core_3d::TransparentSortingInfo3d;
 use bevy::math::Affine3Ext;
 use bevy::pbr::{SetMeshViewEmptyBindGroup, ViewKeyCache};
 use bevy::{
     camera::MainPassResolutionOverride,
     core_pipeline::{core_3d::main_opaque_pass_3d, schedule::Core3d, Core3dSystems},
-    ecs::system::{lifetimeless::SRes, SystemParamItem},
+    ecs::{
+        entity::EntityHash,
+        system::{lifetimeless::SRes, SystemParamItem},
+    },
     math::FloatOrd,
     mesh::MeshVertexBufferLayoutRef,
     pbr::{
@@ -35,7 +39,7 @@ use bevy::{
             },
             GetBatchData, GetFullBatchData,
         },
-        camera::ExtractedCamera,
+        camera::{DirtySpecializations, ExtractedCamera, PendingQueues},
         extract_component::{ExtractComponent, ExtractComponentPlugin},
         mesh::{allocator::MeshAllocator, RenderMesh},
         render_asset::RenderAssets,
@@ -56,6 +60,7 @@ use bevy::{
         Extract, Render, RenderApp, RenderDebugFlags, RenderStartup, RenderSystems,
     },
 };
+use indexmap::IndexMap;
 use nonmax::NonMaxU32;
 
 const SHADER_ASSET_PATH: &str = "shaders/custom_stencil.wgsl";
@@ -125,6 +130,7 @@ impl Plugin for MeshStencilPhasePlugin {
             .init_resource::<DrawFunctions<Stencil3d>>()
             .add_render_command::<Stencil3d, DrawMesh3dStencil>()
             .init_resource::<ViewSortedRenderPhases<Stencil3d>>()
+            .init_resource::<PendingCustomMeshQueues>()
             .add_systems(RenderStartup, init_stencil_pipeline)
             .add_systems(ExtractSchedule, extract_camera_phases)
             .add_systems(
@@ -248,7 +254,10 @@ type DrawMesh3dStencil = (
 // If you want to see how a batched phase implementation looks, you should look at the Opaque2d
 // phase.
 struct Stencil3d {
-    pub sort_key: FloatOrd,
+    /// Information needed to sort the objects in the phase by distance to the
+    /// view.
+    pub sorting_info: TransparentSortingInfo3d,
+    pub distance: FloatOrd,
     pub entity: (Entity, MainEntity),
     pub pipeline: CachedRenderPipelineId,
     pub draw_function: DrawFunctionId,
@@ -302,15 +311,23 @@ impl SortedPhaseItem for Stencil3d {
 
     #[inline]
     fn sort_key(&self) -> Self::SortKey {
-        self.sort_key
+        self.distance
     }
 
     #[inline]
-    fn sort(items: &mut [Self]) {
-        // bevy normally uses radsort instead of the std slice::sort_by_key
-        // radsort is a stable radix sort that performed better than `slice::sort_by_key` or `slice::sort_unstable_by_key`.
-        // Since it is not re-exported by bevy, we just use the std sort for the purpose of the example
-        items.sort_by_key(SortedPhaseItem::sort_key);
+    fn sort(items: &mut IndexMap<(Entity, MainEntity), Stencil3d, EntityHash>) {
+        items.sort_by_key(|_, phase_item: &Stencil3d| phase_item.distance);
+    }
+
+    fn recalculate_sort_keys(
+        items: &mut IndexMap<(Entity, MainEntity), Self, EntityHash>,
+        view: &ExtractedView,
+    ) {
+        // Determine the distance to the view for each phase item.
+        let rangefinder = view.rangefinder3d();
+        for item in items.values_mut() {
+            item.distance = FloatOrd(item.sorting_info.sort_distance(&rangefinder));
+        }
     }
 
     #[inline]
@@ -478,7 +495,7 @@ fn extract_camera_phases(
         // This is the main camera, so we use the first subview index (0)
         let retained_view_entity = RetainedViewEntity::new(main_entity.into(), None, 0);
 
-        stencil_phases.insert_or_clear(retained_view_entity);
+        stencil_phases.prepare_for_new_frame(retained_view_entity);
         live_entities.insert(retained_view_entity);
     }
 
@@ -486,6 +503,13 @@ fn extract_camera_phases(
     stencil_phases.retain(|camera_entity, _| live_entities.contains(camera_entity));
 }
 
+/// A resource that stores meshes that couldn't be specialized yet because their
+/// materials hadn't loaded.
+///
+/// See the documentation for [`PendingQueues`] for more information.
+#[derive(Default, Deref, DerefMut, Resource)]
+struct PendingCustomMeshQueues(pub PendingQueues);
+
 // This is a very important step when writing a custom phase.
 //
 // This system determines which meshes will be added to the phase.
@@ -499,6 +523,8 @@ fn queue_custom_meshes(
     mut custom_render_phases: ResMut<ViewSortedRenderPhases<Stencil3d>>,
     mut views: Query<(&ExtractedView, &RenderVisibleEntities)>,
     view_key_cache: Res<ViewKeyCache>,
+    dirty_specializations: Res<DirtySpecializations>,
+    mut pending_custom_mesh_queues: ResMut<PendingCustomMeshQueues>,
     has_marker: Query<(), With<DrawStencil>>,
 ) {
     for (view, visible_entities) in &mut views {
@@ -511,15 +537,38 @@ fn queue_custom_meshes(
             continue;
         };
 
-        let rangefinder = view.rangefinder3d();
         // Since our phase can work on any 3d mesh we can reuse the default mesh 3d filter
-        for (render_entity, visible_entity) in visible_entities.iter::<Mesh3d>() {
+        let Some(render_visible_mesh_entities) = visible_entities.get::<Mesh3d>() else {
+            continue;
+        };
+
+        let view_pending_custom_mesh_queues =
+            pending_custom_mesh_queues.prepare_for_new_frame(view.retained_view_entity);
+
+        // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+        for &main_entity in dirty_specializations
+            .iter_to_dequeue(view.retained_view_entity, render_visible_mesh_entities)
+        {
+            custom_phase.remove(Entity::PLACEHOLDER, main_entity);
+        }
+
+        for (render_entity, visible_entity) in dirty_specializations.iter_to_queue(
+            view.retained_view_entity,
+            render_visible_mesh_entities,
+            &view_pending_custom_mesh_queues.prev_frame,
+        ) {
             // We only want meshes with the marker component to be queued to our phase.
             if has_marker.get(*render_entity).is_err() {
                 continue;
             }
             let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*visible_entity)
             else {
+                // We couldn't fetch the mesh, probably because it hasn't been
+                // loaded yet. Add the entity to the list of pending custom mesh
+                // queues and bail.
+                view_pending_custom_mesh_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
             let Some(mesh) = render_meshes.get(mesh_instance.mesh_asset_id) else {
@@ -545,13 +594,15 @@ fn queue_custom_meshes(
                     continue;
                 }
             };
-            let distance = rangefinder.distance(&mesh_instance.center);
             // At this point we have all the data we need to create a phase item and add it to our
             // phase
             custom_phase.add(Stencil3d {
-                // Sort the data based on the distance to the view
-                sort_key: FloatOrd(distance),
-                entity: (*render_entity, *visible_entity),
+                sorting_info: TransparentSortingInfo3d::Sorted {
+                    mesh_center: mesh_instance.center,
+                    depth_bias: 0.0,
+                },
+                distance: FloatOrd(0.0),
+                entity: (Entity::PLACEHOLDER, *visible_entity),
                 pipeline: pipeline_id,
                 draw_function: draw_custom,
                 // Sorted phase items aren't batched
diff --git a/examples/shader_advanced/custom_shader_instancing.rs b/examples/shader_advanced/custom_shader_instancing.rs
index cee6947bfc034..9313806325283 100644
--- a/examples/shader_advanced/custom_shader_instancing.rs
+++ b/examples/shader_advanced/custom_shader_instancing.rs
@@ -7,6 +7,7 @@
 //! implementation using bevy's low level rendering api.
 //! It's generally recommended to try the built-in instancing before going with this approach.
 
+use bevy::core_pipeline::core_3d::TransparentSortingInfo3d;
 use bevy::pbr::{SetMeshViewBindingArrayBindGroup, ViewKeyCache};
 use bevy::{
     camera::visibility::NoFrustumCulling,
@@ -149,7 +150,6 @@ fn queue_custom(
             continue;
         };
 
-        let rangefinder = view.rangefinder3d();
         for (entity, main_entity) in &material_meshes {
             let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*main_entity)
             else {
@@ -164,10 +164,14 @@ fn queue_custom(
                 .specialize(&pipeline_cache, &custom_pipeline, key, &mesh.layout)
                 .unwrap();
             transparent_phase.add(Transparent3d {
+                sorting_info: TransparentSortingInfo3d::Sorted {
+                    mesh_center: mesh_instance.center,
+                    depth_bias: 0.0,
+                },
                 entity: (entity, *main_entity),
                 pipeline,
                 draw_function: draw_custom,
-                distance: rangefinder.distance(&mesh_instance.center),
+                distance: 0.0,
                 batch_range: 0..1,
                 extra_index: PhaseItemExtraIndex::None,
                 indexed: true,
diff --git a/examples/shader_advanced/manual_material.rs b/examples/shader_advanced/manual_material.rs
index a25c6ee39fa91..a4261944e161e 100644
--- a/examples/shader_advanced/manual_material.rs
+++ b/examples/shader_advanced/manual_material.rs
@@ -5,20 +5,19 @@ use bevy::{
     core_pipeline::core_3d::Opaque3d,
     ecs::system::{
         lifetimeless::{SRes, SResMut},
-        SystemChangeTick, SystemParamItem,
+        SystemParamItem,
     },
     material::{key::ErasedMeshPipelineKey, MaterialProperties},
     pbr::{
-        base_specialize, late_sweep_material_instances, DrawMaterial,
-        EntitiesNeedingSpecialization, EntitySpecializationTickPair, EntitySpecializationTicks,
-        MainPassOpaqueDrawFunction, MaterialBindGroupAllocator, MaterialBindGroupAllocators,
-        MaterialExtractEntitiesNeedingSpecializationSystems, MaterialExtractionSystems,
-        MaterialFragmentShader, MeshPipelineKey, PreparedMaterial, RenderMaterialBindings,
-        RenderMaterialInstance, RenderMaterialInstances, SpecializedMaterialPipelineCache,
+        base_specialize, DrawMaterial, EntitiesNeedingSpecialization, MainPassOpaqueDrawFunction,
+        MaterialBindGroupAllocator, MaterialBindGroupAllocators, MaterialFragmentShader,
+        MeshPipelineKey, PreparedMaterial, RenderMaterialBindings, RenderMaterialInstance,
+        RenderMaterialInstances,
     },
     platform::collections::hash_map::Entry,
     prelude::*,
     render::{
+        camera::{DirtySpecializationSystems, DirtySpecializations},
         erased_render_asset::{ErasedRenderAsset, ErasedRenderAssetPlugin, PrepareAssetError},
         render_asset::RenderAssets,
         render_phase::DrawFunctions,
@@ -31,7 +30,6 @@ use bevy::{
         renderer::RenderDevice,
         sync_world::MainEntity,
         texture::GpuImage,
-        view::ExtractedView,
         Extract, RenderApp, RenderStartup,
     },
     utils::Parallel,
@@ -70,11 +68,9 @@ impl Plugin for ImageMaterialPlugin {
                 (
                     extract_image_materials,
                     extract_image_materials_needing_specialization
-                        .in_set(MaterialExtractEntitiesNeedingSpecializationSystems),
-                    sweep_image_materials_needing_specialization
-                        .after(MaterialExtractEntitiesNeedingSpecializationSystems)
-                        .after(MaterialExtractionSystems)
-                        .before(late_sweep_material_instances),
+                        .in_set(DirtySpecializationSystems::CheckForChanges),
+                    extract_image_materials_that_need_specializations_removed
+                        .in_set(DirtySpecializationSystems::CheckForRemovals),
                 ),
             );
     }
@@ -286,79 +282,50 @@ fn check_entities_needing_specialization(
     >,
     mut par_local: Local<Parallel<Vec<Entity>>>,
     mut entities_needing_specialization: ResMut<EntitiesNeedingSpecialization<ImageMaterial>>,
+    mut removed_mesh_3d_components: RemovedComponents<Mesh3d>,
+    mut removed_mesh_material_3d_components: RemovedComponents<ImageMaterial3d>,
 ) {
-    entities_needing_specialization.clear();
+    entities_needing_specialization.changed.clear();
+    entities_needing_specialization.removed.clear();
 
+    // Gather all entities that need their specializations regenerated.
     needs_specialization
         .par_iter()
         .for_each(|entity| par_local.borrow_local_mut().push(entity));
+    par_local.drain_into(&mut entities_needing_specialization.changed);
 
-    par_local.drain_into(&mut entities_needing_specialization);
+    // All entities that removed their `Mesh3d` or `ImageMaterial3d` components
+    // need to have their specializations removed as well.
+    for entity in removed_mesh_3d_components
+        .read()
+        .chain(removed_mesh_material_3d_components.read())
+    {
+        entities_needing_specialization.removed.push(entity);
+    }
 }
 
 fn extract_image_materials_needing_specialization(
     entities_needing_specialization: Extract<Res<EntitiesNeedingSpecialization<ImageMaterial>>>,
-    mut entity_specialization_ticks: ResMut<EntitySpecializationTicks>,
-    mut removed_mesh_material_components: Extract<RemovedComponents<ImageMaterial3d>>,
-    mut specialized_material_pipeline_cache: ResMut<SpecializedMaterialPipelineCache>,
-    render_material_instances: Res<RenderMaterialInstances>,
-    views: Query<&ExtractedView>,
-    ticks: SystemChangeTick,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
 ) {
-    // Clean up any despawned entities, we do this first in case the removed material was re-added
-    // the same frame, thus will appear both in the removed components list and have been added to
-    // the `EntitiesNeedingSpecialization` collection by triggering the `Changed` filter
-    for entity in removed_mesh_material_components.read() {
-        entity_specialization_ticks.remove(&MainEntity::from(entity));
-        for view in views {
-            if let Some(cache) =
-                specialized_material_pipeline_cache.get_mut(&view.retained_view_entity)
-            {
-                cache.remove(&MainEntity::from(entity));
-            }
-        }
-    }
-
-    for entity in entities_needing_specialization.iter() {
-        // Update the entity's specialization tick with this run's tick
-        entity_specialization_ticks.insert(
-            (*entity).into(),
-            EntitySpecializationTickPair {
-                system_tick: ticks.this_run(),
-                material_instances_tick: render_material_instances.current_change_tick,
-            },
-        );
+    // Drain the list of entities needing specialization from the main world
+    // into the render-world `DirtySpecializations` table.
+    for entity in entities_needing_specialization.changed.iter() {
+        dirty_specializations
+            .changed_renderables
+            .insert(MainEntity::from(*entity));
     }
 }
 
-fn sweep_image_materials_needing_specialization(
-    mut entity_specialization_ticks: ResMut<EntitySpecializationTicks>,
-    mut removed_mesh_material_components: Extract<RemovedComponents<ImageMaterial3d>>,
-    mut specialized_material_pipeline_cache: ResMut<SpecializedMaterialPipelineCache>,
-    render_material_instances: Res<RenderMaterialInstances>,
-    views: Query<&ExtractedView>,
+/// A system that adds entities that were judged to need their specializations
+/// removed to the appropriate table in [`DirtySpecializations`].
+fn extract_image_materials_that_need_specializations_removed(
+    entities_needing_specialization: Extract<Res<EntitiesNeedingSpecialization<ImageMaterial>>>,
+    mut dirty_specializations: ResMut<DirtySpecializations>,
 ) {
-    // Clean up any despawned entities, we do this first in case the removed material was re-added
-    // the same frame, thus will appear both in the removed components list and have been added to
-    // the `EntitiesNeedingSpecialization` collection by triggering the `Changed` filter
-    for entity in removed_mesh_material_components.read() {
-        if entity_specialization_ticks
-            .get(&MainEntity::from(entity))
-            .is_some_and(|ticks| {
-                ticks.material_instances_tick == render_material_instances.current_change_tick
-            })
-        {
-            continue;
-        }
-
-        entity_specialization_ticks.remove(&MainEntity::from(entity));
-
-        for view in views {
-            if let Some(cache) =
-                specialized_material_pipeline_cache.get_mut(&view.retained_view_entity)
-            {
-                cache.remove(&MainEntity::from(entity));
-            }
-        }
+    for entity in entities_needing_specialization.removed.iter() {
+        dirty_specializations
+            .removed_renderables
+            .insert(MainEntity::from(*entity));
     }
 }
diff --git a/examples/shader_advanced/specialized_mesh_pipeline.rs b/examples/shader_advanced/specialized_mesh_pipeline.rs
index 63fc7b3863481..f7b9b808f28ef 100644
--- a/examples/shader_advanced/specialized_mesh_pipeline.rs
+++ b/examples/shader_advanced/specialized_mesh_pipeline.rs
@@ -20,6 +20,7 @@ use bevy::{
     prelude::*,
     render::{
         batching::gpu_preprocessing::GpuPreprocessingSupport,
+        camera::{DirtySpecializations, PendingQueues},
         extract_component::{ExtractComponent, ExtractComponentPlugin},
         mesh::{allocator::MeshAllocator, RenderMesh},
         render_asset::RenderAssets,
@@ -111,6 +112,7 @@ impl Plugin for CustomRenderedMeshPipelinePlugin {
         render_app
             // This is needed to tell bevy about your custom pipeline
             .init_resource::<SpecializedMeshPipelines<CustomMeshPipeline>>()
+            .init_resource::<PendingCustomMeshQueues>()
             // We need to use a custom draw command so we need to register it
             .add_render_command::<Opaque3d, DrawSpecializedPipelineCommands>()
             .add_systems(RenderStartup, init_custom_mesh_pipeline)
@@ -262,6 +264,13 @@ impl SpecializedMeshPipeline for CustomMeshPipeline {
     }
 }
 
+/// A resource that stores meshes that couldn't be specialized yet because their
+/// materials hadn't loaded.
+///
+/// See the documentation for [`PendingQueues`] for more information.
+#[derive(Default, Deref, DerefMut, Resource)]
+struct PendingCustomMeshQueues(pub PendingQueues);
+
 /// A render-world system that enqueues the entity with custom rendering into
 /// the opaque render phases of each view.
 fn queue_custom_mesh_pipeline(
@@ -281,6 +290,8 @@ fn queue_custom_mesh_pipeline(
     mut change_tick: Local<Tick>,
     mesh_allocator: Res<MeshAllocator>,
     gpu_preprocessing_support: Res<GpuPreprocessingSupport>,
+    dirty_specializations: Res<DirtySpecializations>,
+    mut pending_custom_mesh_queues: ResMut<PendingCustomMeshQueues>,
 ) {
     // Get the id for our custom draw function
     let draw_function = opaque_draw_functions
@@ -299,14 +310,39 @@ fn queue_custom_mesh_pipeline(
             continue;
         };
 
+        let Some(render_visible_mesh_entities) =
+            view_visible_entities.get::<CustomRenderedEntity>()
+        else {
+            continue;
+        };
+
+        // Initialize the pending queues.
+        let view_pending_custom_mesh_queues =
+            pending_custom_mesh_queues.prepare_for_new_frame(view.retained_view_entity);
+
+        // First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+        for &main_entity in dirty_specializations
+            .iter_to_dequeue(view.retained_view_entity, render_visible_mesh_entities)
+        {
+            opaque_phase.remove(main_entity);
+        }
+
         // Find all the custom rendered entities that are visible from this
         // view.
-        for &(render_entity, visible_entity) in
-            view_visible_entities.get::<CustomRenderedEntity>().iter()
-        {
+        for (render_entity, visible_entity) in dirty_specializations.iter_to_queue(
+            view.retained_view_entity,
+            render_visible_mesh_entities,
+            &view_pending_custom_mesh_queues.prev_frame,
+        ) {
             // Get the mesh instance
-            let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(visible_entity)
+            let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*visible_entity)
             else {
+                // We couldn't fetch the mesh, probably because it hasn't been
+                // loaded yet. Add the entity to the list of pending custom
+                // meshes and bail.
+                view_pending_custom_mesh_queues
+                    .current_frame
+                    .insert((*render_entity, *visible_entity));
                 continue;
             };
 
@@ -354,7 +390,7 @@ fn queue_custom_mesh_pipeline(
                 Opaque3dBinKey {
                     asset_id: mesh_instance.mesh_asset_id.into(),
                 },
-                (render_entity, visible_entity),
+                (*render_entity, *visible_entity),
                 mesh_instance.current_uniform_index,
                 // This example supports batching and multi draw indirect,
                 // but if your pipeline doesn't support it you can use
@@ -363,7 +399,6 @@ fn queue_custom_mesh_pipeline(
                     mesh_instance.should_batch(),
                     &gpu_preprocessing_support,
                 ),
-                *change_tick,
             );
         }
     }
diff --git a/release-content/migration-guides/change_lists.md b/release-content/migration-guides/change_lists.md
new file mode 100644
index 0000000000000..0f75969fb2170
--- /dev/null
+++ b/release-content/migration-guides/change_lists.md
@@ -0,0 +1,53 @@
+---
+title: "Change lists"
+pull_requests: [22966]
+---
+
+Previously, Bevy required rendering phases to iterate over all visible entities to determine which objects changed via ticks. This became a bottleneck, so Bevy now uses *change lists* instead. This change affects custom render phases; if you aren't creating your own render phases, you shouldn't have to update any code.
+
+In the render world, the list of changed items can now be accessed in the new `DirtySpecializations` resource. In *specialize* systems, use code like the following:
+
+```rust
+// First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+for &main_entity in dirty_specializations
+    .iter_to_dequeue(view.retained_view_entity, render_visible_mesh_entities)
+{
+    opaque_phase.remove(main_entity);
+}
+
+// Specialize new meshes.
+for (render_entity, visible_entity) in dirty_specializations.iter_to_queue(
+    view.retained_view_entity,
+    render_visible_mesh_entities,
+    &view_pending_mesh_queues.prev_frame,
+) {
+    ...
+}
+
+```
+
+In *queue* systems, use code like this:
+
+```rust
+// First, remove meshes that need to be respecialized, and those that were removed, from the bins.
+for &main_entity in dirty_specializations
+    .iter_to_dequeue(view.retained_view_entity, render_visible_mesh_entities)
+{
+    my_phase.remove(Entity::PLACEHOLDER, main_entity);
+}
+
+// Now bin new items.
+for (render_entity, visible_entity) in dirty_specializations.iter_to_queue(
+    view.retained_view_entity,
+    render_visible_mesh_entities,
+    &view_pending_mesh_queues.prev_frame,
+) {
+    ...
+}
+```
+
+If you need to handle the case in which a mesh might not be able to be specialized and/or queued right away because its dependencies (e.g. materials) haven't loaded yet, there's a new type `PendingQueues` that can help with this.
+
+Additionally, sorted render phases now use an `IndexMap` instead of a `Vec`, so that entities can be added and removed incrementally instead of having to reconstruct the list every frame. This is incompatible with some exotic sorting algorithms that were commonly in use before (e.g. radix sort), so you may need to switch to the built-in `sort_unstable` method on `IndexMap`.
+
+See `examples/shader_advanced/specialized_mesh_pipeline.rs` for a comprehensive example.
