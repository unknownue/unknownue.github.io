<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #18531 Have the mesh allocator handle modified meshes
        
    </title><meta content="#18531 Have the mesh allocator handle modified meshes" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-03/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-03-27</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-03/pr-18531-zh-cn-20250327>中文</a></div></div><div class=pr-content><h1 id=18531-have-the-mesh-allocator-handle-modified-meshes>#18531 Have the mesh allocator handle modified meshes</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Have the mesh allocator handle modified meshes<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/18531<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: <code>C-Bug</code>, <code>A-Rendering</code>, <code>S-Ready-For-Final-Review</code><li><strong>Created</strong>: 2025-03-25T05:18:58Z<li><strong>Merged</strong>: Not merged<li><strong>Merged By</strong>: N/A</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Fixes https://github.com/bevyengine/bevy/issues/16586.<h2 id=solution>Solution</h2><ul><li>Free meshes before allocating new ones (so hopefully the existing allocation is used, but it’s not guaranteed since it might end up getting used by a smaller mesh first).<li>Keep track of modified render assets, and have the mesh allocator free their allocations.<li>Cleaned up some render asset code to make it more understandable, since it took me several minutes to reverse engineer/remember how it was supposed to work.</ul><p>Long term we’ll probably want to explicitly reusing allocations for modified meshes that haven’t grown in size, or do delta uploads using a compute shader or something, but this is an easy fix for the near term.<h2 id=testing>Testing</h2><p>Ran the example provided in the issue. No crash after a few minutes, and memory usage remains steady.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The core problem stemmed from how Bevy’s mesh allocator handled modified meshes. When meshes were updated at runtime, the renderer would accumulate GPU memory allocations without properly freeing previous ones. This led to memory exhaustion crashes, particularly evident in dynamic mesh modification scenarios.<p>The root cause lay in two areas:<ol><li>The asset preparation system wasn’t processing modified meshes through the deallocation path<li>The mesh allocator’s slab management didn’t account for updated mesh versions</ol><p>The solution required modifying both asset handling and allocation logic. In <code>render_asset.rs</code>, the <code>prepare_assets</code> system was updated to process both added <em>and</em> modified assets:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Updated asset processing logic
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>prepare_assets</span><span>&LTR</span><span style=color:#61676ccc>:</span><span> RenderAsset>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>extracted_assets</span><span style=color:#61676ccc>: </span><span>ResMut&LTExtractedAssets&LTR>>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Now handles both added and modified assets
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>events</span><span style=color:#61676ccc>: </span><span>EventReader&LTAssetEvent<</span><span style=color:#fa6e32>R</span><span style=color:#ed9366>::</span><span>SourceAsset>>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> changed_assets </span><span style=color:#ed9366>= </span><span>HashSet</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for</span><span> event </span><span style=color:#ed9366>in</span><span> events</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>() {
</span><span>        </span><span style=color:#fa6e32>if let </span><span>AssetEvent</span><span style=color:#ed9366>::</span><span>Added { id } </span><span style=color:#ed9366>| </span><span>AssetEvent</span><span style=color:#ed9366>::</span><span>Modified { id } </span><span style=color:#ed9366>=</span><span> event {
</span><span>            changed_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(</span><span style=color:#ed9366>*</span><span>id)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    extracted_assets</span><span style=color:#ed9366>.</span><span>assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(changed_assets)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This change ensured modified meshes would trigger the deallocation/reallocation process. The mesh allocator in <code>allocator.rs</code> was then enhanced with explicit cleanup for modified assets:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Modified free logic in MeshAllocator
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>free</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>id</span><span style=color:#61676ccc>: </span><span>AssetId&LTMesh>, </span><span style=color:#ff8f40>modified</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(slab_id) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>mesh_id_to_vertex_slab</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ed9366>&</span><span>id) {
</span><span>        </span><span style=color:#fa6e32>if</span><span> modified {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>slabs</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ed9366>&</span><span>slab_id)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Similar logic for index buffers...
</span><span>}
</span></code></pre><p>Key implementation details:<ol><li><strong>Dual Tracking</strong>: Maintain separate mappings for vertex and index buffer slabs<li><strong>Slab Lifecycle</strong>: Remove entire slabs when their contained mesh is modified<li><strong>Early Free</strong>: Clear old allocations before creating new ones to maximize reuse potential</ol><p>The technical trade-off here prioritizes memory safety over allocation optimization. While this approach guarantees no memory leaks, it may temporarily increase allocation churn for frequently modified meshes. The solution explicitly leaves room for future optimizations like:<ul><li>Slab reuse for same-size updates<li>Delta uploads via compute shaders<li>Better slab growth heuristics</ul><p>Testing showed memory stabilization in stress scenarios, with the example from the original issue maintaining steady memory usage. This fix addresses immediate stability concerns while preserving the existing allocation architecture.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Mesh Modification] --> B[AssetEvent::Modified]
</span><span>    B --> C[ExtractedAssets]
</span><span>    C --> D[prepare_assets System]
</span><span>    D --> E[MeshAllocator.free]
</span><span>    E --> F[Slab Removal]
</span><span>    F --> G[New Allocation]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-render-src-render-asset-rs-24-8><code>crates/bevy_render/src/render_asset.rs</code> (+24/-8)</h3><p><strong>Purpose</strong>: Update asset processing to handle modified meshes<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Key change in event handling
</span><span style=color:#fa6e32>for</span><span> event </span><span style=color:#ed9366>in</span><span> events</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>() {
</span><span>    </span><span style=color:#fa6e32>if let </span><span>AssetEvent</span><span style=color:#ed9366>::</span><span>Added { id } </span><span style=color:#ed9366>| </span><span>AssetEvent</span><span style=color:#ed9366>::</span><span>Modified { id } </span><span style=color:#ed9366>=</span><span> event {
</span><span>        changed_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(</span><span style=color:#ed9366>*</span><span>id)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>This modification ensures both new and updated meshes go through the allocation cleanup path.<h3 id=crates-bevy-render-src-mesh-allocator-rs-13-5><code>crates/bevy_render/src/mesh/allocator.rs</code> (+13/-5)</h3><p><strong>Purpose</strong>: Implement modified mesh cleanup<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Modified free logic
</span><span style=color:#fa6e32>if</span><span> modified {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>slabs</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ed9366>&</span><span>slab_id)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This conditional slab removal prevents stale allocations from persisting after mesh updates.<h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://github.com/GameTechDev/OffsetAllocator target=_blank>Offset Allocator Algorithm</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/implementation/rendering/ target=_blank>Bevy Render Architecture Overview</a><li><a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/#buffer-usage target=_blank>WebGPU Buffer Management Best Practices</a></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-03/pr_18531.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>