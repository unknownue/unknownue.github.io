<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20071 Refactor `3d_viewport_to_world` example with let chains
        
    </title><meta content="#20071 Refactor `3d_viewport_to_world` example with let chains" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-10</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-20071-zh-cn-20250710>中文</a></div></div><div class=pr-content><h1 id=refactor-3d-viewport-to-world-example-with-let-chains>Refactor <code>3d_viewport_to_world</code> example with let chains</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Refactor <code>3d_viewport_to_world</code> example with let chains<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20071<li><strong>Author</strong>: tim-blackbird<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, C-Examples, C-Code-Quality, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-07-09T23:25:32Z<li><strong>Merged</strong>: 2025-07-10T02:57:09Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Make use of let chains to reduce LoC where we previously used let else to cut down on indentation. Best of both worlds.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The <code>3d_viewport_to_world</code> example needed optimization to improve readability and maintainability. The original implementation used multiple <code>let else</code> statements for early returns when required data wasn’t available. This approach created several nested conditional blocks that increased indentation levels and made the control flow harder to follow at a glance.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Original approach with multiple early returns
</span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(windows) </span><span style=color:#ed9366>=</span><span> windows</span><span style=color:#ed9366>.</span><span style=color:#f07171>single</span><span>() </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>return </span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(cursor_position) </span><span style=color:#ed9366>=</span><span> windows</span><span style=color:#ed9366>.</span><span style=color:#f07171>cursor_position</span><span>() </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>return </span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(ray) </span><span style=color:#ed9366>=</span><span> camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>viewport_to_world</span><span>(</span><span style=color:#ed9366>...</span><span>) </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>return </span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(distance) </span><span style=color:#ed9366>= ... </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>return </span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>The developer recognized that Rust’s let chains feature could consolidate these sequential checks into a single logical block. Let chains allow combining multiple pattern matches in a single <code>if let</code> expression using the <code>&&</code> operator. This approach maintains the same failure semantics but reduces visual clutter.<p>The solution modifies the <code>draw_cursor</code> system to use a single <code>if let</code> chain that combines four separate conditions:<ol><li>Checking for a valid window cursor position<li>Calculating the viewport-to-world ray<li>Checking for ray-plane intersection<li>Calculating the intersection point</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(cursor_position) </span><span style=color:#ed9366>=</span><span> window</span><span style=color:#ed9366>.</span><span style=color:#f07171>cursor_position</span><span>()
</span><span>    </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(ray) </span><span style=color:#ed9366>=</span><span> camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>viewport_to_world</span><span>(</span><span style=color:#ed9366>...</span><span>)
</span><span>    </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(distance) </span><span style=color:#ed9366>= ...
</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// All conditions met - proceed with drawing
</span><span>}
</span></code></pre><p>This refactoring achieves several improvements:<ol><li>Reduces total lines of code from 41 to 30<li>Eliminates multiple early return points<li>Groups related condition checks together<li>Makes the success path more visually distinct from failure cases<li>Maintains identical functionality and error handling</ol><p>An additional optimization changes the window query from <code>Query<&Window></code> to <code>Single<&Window></code>. Since the example only needs the primary window, using <code>Single</code> is more efficient and semantically clearer. This change also eliminates the need for separate error handling on the window query.<p>The changes demonstrate effective use of Rust’s let chains feature to simplify control flow in systems with multiple fallible operations. The result is more concise code with improved readability while maintaining the same functionality and error handling behavior.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Window Query] --> B[Cursor Position]
</span><span>    B --> C[Viewport Ray Calculation]
</span><span>    C --> D[Ray-Plane Intersection]
</span><span>    D --> E[Point Calculation]
</span><span>    E --> F[Draw Gizmo]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=examples-3d-3d-viewport-to-world-rs><code>examples/3d/3d_viewport_to_world.rs</code></h3><p><strong>What changed</strong>: Refactored the <code>draw_cursor</code> system to use let chains and simplified window handling.<p><strong>Why changed</strong>: To reduce code complexity and improve readability while maintaining identical functionality.<p><strong>Code diff</strong>:<pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span> fn draw_cursor(
</span><span>     camera_query: Single<(&Camera, &GlobalTransform)>,
</span><span>     ground: Single<&GlobalTransform, With&LTGround>>,
</span><span style=color:#f07171>-    windows: Query<&Window>,
</span><span style=color:#86b300>+    window: Single<&Window>,
</span><span>     mut gizmos: Gizmos,
</span><span> ) {
</span><span style=color:#f07171>-    let Ok(windows) = windows.single() else {
</span><span style=color:#f07171>-        return;
</span><span style=color:#f07171>-    };
</span><span style=color:#f07171>-
</span><span>     let (camera, camera_transform) = *camera_query;
</span><span> 
</span><span style=color:#f07171>-    let Some(cursor_position) = windows.cursor_position() else {
</span><span style=color:#f07171>-        return;
</span><span style=color:#f07171>-    };
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    // Calculate a ray pointing from the camera into the world based on the cursor's position.
</span><span style=color:#f07171>-    let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position) else {
</span><span style=color:#f07171>-        return;
</span><span style=color:#f07171>-    };
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    // Calculate if and where the ray is hitting the ground plane.
</span><span style=color:#f07171>-    let Some(distance) =
</span><span style=color:#f07171>-        ray.intersect_plane(ground.translation(), InfinitePlane3d::new(ground.up()))
</span><span style=color:#f07171>-    else {
</span><span style=color:#f07171>-        return;
</span><span style=color:#f07171>-    };
</span><span style=color:#f07171>-    let point = ray.get_point(distance);
</span><span style=color:#86b300>+    if let Some(cursor_position) = window.cursor_position()
</span><span style=color:#86b300>+        // Calculate a ray pointing from the camera into the world based on the cursor's position.
</span><span style=color:#86b300>+        && let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position)
</span><span style=color:#86b300>+        // Calculate if and at what distance the ray is hitting the ground plane.
</span><span style=color:#86b300>+        && let Some(distance) =
</span><span style=color:#86b300>+            ray.intersect_plane(ground.translation(), InfinitePlane3d::new(ground.up()))
</span><span style=color:#86b300>+    {
</span><span style=color:#86b300>+        let point = ray.get_point(distance);
</span><span> 
</span><span style=color:#f07171>-    // Draw a circle just above the ground plane at that position.
</span><span style=color:#f07171>-    gizmos.circle(
</span><span style=color:#f07171>-        Isometry3d::new(
</span><span style=color:#f07171>-            point + ground.up() * 0.01,
</span><span style=color:#f07171>-            Quat::from_rotation_arc(Vec3::Z, ground.up().as_vec3()),
</span><span style=color:#f07171>-        ),
</span><span style=color:#f07171>-        0.2,
</span><span style=color:#f07171>-        Color::WHITE,
</span><span style=color:#f07171>-    );
</span><span style=color:#86b300>+        // Draw a circle just above the ground plane at that position.
</span><span style=color:#86b300>+        gizmos.circle(
</span><span style=color:#86b300>+            Isometry3d::new(
</span><span style=color:#86b300>+                point + ground.up() * 0.01,
</span><span style=color:#86b300>+                Quat::from_rotation_arc(Vec3::Z, ground.up().as_vec3()),
</span><span style=color:#86b300>+            ),
</span><span style=color:#86b300>+            0.2,
</span><span style=color:#86b300>+            Color::WHITE,
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+    }
</span><span> }
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/reference/expressions/if-expr.html#let-chains target=_blank>Rust Reference: Let Chains</a> - Official documentation on let chain syntax<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/getting-started/ecs/#queries target=_blank>Bevy ECS: Query System</a> - How queries work in Bevy’s ECS<li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch18-00-patterns.html target=_blank>Rust Pattern Matching</a> - Comprehensive guide to pattern matching in Rust<li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_gizmos/latest/bevy_gizmos/ target=_blank>Bevy Gizmos Documentation</a> - Reference for drawing debug visuals in Bevy</ol><h2 id=full-code-diff>Full Code Diff</h2><pre style=color:#61676c;background-color:#fafafa><code><span>diff --git a/examples/3d/3d_viewport_to_world.rs b/examples/3d/3d_viewport_to_world.rs
</span><span>index 9aabd6f629caf..883121779a635 100644
</span><span>--- a/examples/3d/3d_viewport_to_world.rs
</span><span>+++ b/examples/3d/3d_viewport_to_world.rs
</span><span>@@ -13,41 +13,30 @@ fn main() {
</span><span> fn draw_cursor(
</span><span>     camera_query: Single<(&Camera, &GlobalTransform)>,
</span><span>     ground: Single<&GlobalTransform, With&LTGround>>,
</span><span>-    windows: Query<&Window>,
</span><span>+    window: Single<&Window>,
</span><span>     mut gizmos: Gizmos,
</span><span> ) {
</span><span>-    let Ok(windows) = windows.single() else {
</span><span>-        return;
</span><span>-    };
</span><span>-
</span><span>     let (camera, camera_transform) = *camera_query;
</span><span> 
</span><span>-    let Some(cursor_position) = windows.cursor_position() else {
</span><span>-        return;
</span><span>-    };
</span><span>-
</span><span>-    // Calculate a ray pointing from the camera into the world based on the cursor's position.
</span><span>-    let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position) else {
</span><span>-        return;
</span><span>-    };
</span><span>-
</span><span>-    // Calculate if and where the ray is hitting the ground plane.
</span><span>-    let Some(distance) =
</span><span>-        ray.intersect_plane(ground.translation(), InfinitePlane3d::new(ground.up()))
</span><span>-    else {
</span><span>-        return;
</span><span>-    };
</span><span>-    let point = ray.get_point(distance);
</span><span>+    if let Some(cursor_position) = window.cursor_position()
</span><span>+        // Calculate a ray pointing from the camera into the world based on the cursor's position.
</span><span>+        && let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_position)
</span><span>+        // Calculate if and at what distance the ray is hitting the ground plane.
</span><span>+        && let Some(distance) =
</span><span>+            ray.intersect_plane(ground.translation(), InfinitePlane3d::new(ground.up()))
</span><span>+    {
</span><span>+        let point = ray.get_point(distance);
</span><span> 
</span><span>-    // Draw a circle just above the ground plane at that position.
</span><span>-    gizmos.circle(
</span><span>-        Isometry3d::new(
</span><span>-            point + ground.up() * 0.01,
</span><span>-            Quat::from_rotation_arc(Vec3::Z, ground.up().as_vec3()),
</span><span>-        ),
</span><span>-        0.2,
</span><span>-        Color::WHITE,
</span><span>-    );
</span><span>+        // Draw a circle just above the ground plane at that position.
</span><span>+        gizmos.circle(
</span><span>+            Isometry3d::new(
</span><span>+                point + ground.up() * 0.01,
</span><span>+                Quat::from_rotation_arc(Vec3::Z, ground.up().as_vec3()),
</span><span>+            ),
</span><span>+            0.2,
</span><span>+            Color::WHITE,
</span><span>+        );
</span><span>+    }
</span><span> }
</span><span> 
</span><span> #[derive(Component)]
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_20071.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>