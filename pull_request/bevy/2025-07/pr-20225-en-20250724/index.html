<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20225 Make load gltf public
        
    </title><meta content="#20225 Make load gltf public" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-24</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-20225-zh-cn-20250724>中文</a></div></div><div class=pr-content><h3 id=make-load-gltf-public>Make load gltf public</h3><h4 id=basic-information>Basic Information</h4><ul><li><strong>Title</strong>: Make load gltf public<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20225<li><strong>Author</strong>: jiangheng90<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Usability, S-Ready-For-Final-Review, D-Straightforward, A-glTF<li><strong>Created</strong>: 2025-07-21T11:43:53Z<li><strong>Merged</strong>: 2025-07-24T17:09:19Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h4 id=description>Description</h4><p>In some case, there are many gltf like format which I need to parse to make custom loader, so I make load_gltf to a static method public on GltfLoader<h4 id=the-story-of-this-pull-request>The Story of This Pull Request</h4><p>The glTF loader implementation in Bevy had a private <code>load_gltf</code> function that handled the core loading logic. This function was only accessible through the <code>AssetLoader</code> trait implementation, which limited its reuse for custom formats similar to glTF. Developers working with glTF-like formats needed to duplicate this complex loading logic in their projects.<p>The solution was straightforward: move the <code>load_gltf</code> function into the <code>GltfLoader</code> impl block and make it public. This preserves the existing functionality while exposing the core loading mechanism. The <code>AssetLoader</code> implementation was updated to call this new public method, maintaining backward compatibility.<p>The implementation change involved:<ol><li>Moving the entire <code>load_gltf</code> function into the <code>impl GltfLoader</code> block<li>Changing its visibility to <code>pub</code><li>Updating the <code>AssetLoader</code> implementation to call <code>Self::load_gltf</code><li>Maintaining identical function parameters and behavior</ol><p>No logic changes were made to the loading process itself. The public method signature matches the original private function, accepting the same parameters (<code>&GltfLoader</code>, <code>&[u8]</code>, <code>&mut LoadContext</code>, and <code>&GltfLoaderSettings</code>) and returning the same <code>Result&LTGltf, GltfError></code>.<p>This change enables developers to create custom loaders for glTF-like formats by reusing the core parsing and loading logic. The public method provides access to the full glTF loading pipeline including buffer processing, texture loading, mesh creation, and scene construction.<h4 id=visual-representation>Visual Representation</h4><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[Custom Loader] --> B[GltfLoader::load_gltf]
</span><span>    B --> C[Buffer Loading]
</span><span>    B --> D[Mesh Creation]
</span><span>    B --> E[Texture Processing]
</span><span>    B --> F[Scene Assembly]
</span></code></pre><h4 id=key-files-changed>Key Files Changed</h4><ul><li><code>crates/bevy_gltf/src/loader/mod.rs</code> (+736/-698)</ul><p><strong>Changes</strong>:<ol><li>The core glTF loading function was moved from a private module-level function to a public method of <code>GltfLoader</code><li>The <code>AssetLoader</code> implementation now delegates to this public method<li>All functionality remains unchanged</ol><p><strong>Code Comparison</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load_gltf</span><span><</span><span style=color:#fa6e32>'a</span><span>, </span><span style=color:#fa6e32>'b</span><span>, </span><span style=color:#fa6e32>'c</span><span>>(
</span><span>    </span><span style=color:#ff8f40>loader</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>GltfLoader,
</span><span>    </span><span style=color:#ff8f40>bytes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> [</span><span style=color:#fa6e32>u8</span><span>],
</span><span>    </span><span style=color:#ff8f40>load_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'b mut </span><span>LoadContext<</span><span style=color:#fa6e32>'c</span><span>>,
</span><span>    </span><span style=color:#ff8f40>settings</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'b</span><span> GltfLoaderSettings,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTGltf, GltfError> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Original implementation
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span>AssetLoader </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>GltfLoader </span><span>{
</span><span>    async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load</span><span>(...) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>... </span><span>{
</span><span>        </span><span style=color:#f07171>load_gltf</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>.</span><span>await
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>GltfLoader </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub</span><span> async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load_gltf</span><span><</span><span style=color:#fa6e32>'a</span><span>, </span><span style=color:#fa6e32>'b</span><span>, </span><span style=color:#fa6e32>'c</span><span>>(
</span><span>        </span><span style=color:#ff8f40>loader</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>GltfLoader,
</span><span>        </span><span style=color:#ff8f40>bytes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> [</span><span style=color:#fa6e32>u8</span><span>],
</span><span>        </span><span style=color:#ff8f40>load_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'b mut </span><span>LoadContext<</span><span style=color:#fa6e32>'c</span><span>>,
</span><span>        </span><span style=color:#ff8f40>settings</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'b</span><span> GltfLoaderSettings,
</span><span>    ) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTGltf, GltfError> {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Same implementation moved here
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span>AssetLoader </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>GltfLoader </span><span>{
</span><span>    async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load</span><span>(...) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>... </span><span>{
</span><span>        </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>load_gltf(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>.</span><span>await
</span><span>    }
</span><span>}
</span></code></pre><h4 id=further-reading>Further Reading</h4><ol><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/assets/ target=_blank>Bevy Asset System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html target=_blank>glTF 2.0 Specification</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/examples/Assets/custom-asset-loaders/ target=_blank>Extending Bevy’s Asset Loaders</a></ol><h4 id=full-code-diff>Full Code Diff</h4><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
</span><span>index 3e4c38453240c..9597f8699bb84 100644
</span><span style=color:#c594c5>--- a/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>@@ -241,812 +241,850 @@ </span><span style=color:#399ee6>impl Default for GltfLoaderSettings {
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-impl AssetLoader for GltfLoader {
</span><span style=color:#f07171>-    type Asset = Gltf;
</span><span style=color:#f07171>-    type Settings = GltfLoaderSettings;
</span><span style=color:#f07171>-    type Error = GltfError;
</span><span style=color:#f07171>-    async fn load(
</span><span style=color:#f07171>-        &self,
</span><span style=color:#f07171>-        reader: &mut dyn Reader,
</span><span style=color:#f07171>-        settings: &GltfLoaderSettings,
</span><span style=color:#f07171>-        load_context: &mut LoadContext<'_>,
</span><span style=color:#f07171>-    ) -> Result&LTGltf, Self::Error> {
</span><span style=color:#f07171>-        let mut bytes = Vec::new();
</span><span style=color:#f07171>-        reader.read_to_end(&mut bytes).await?;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        load_gltf(self, &bytes, load_context, settings).await
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    fn extensions(&self) -> &[&str] {
</span><span style=color:#f07171>-        &["gltf", "glb"]
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-/// Loads an entire glTF file.
</span><span style=color:#f07171>-async fn load_gltf<'a, 'b, 'c>(
</span><span style=color:#f07171>-    loader: &GltfLoader,
</span><span style=color:#f07171>-    bytes: &'a [u8],
</span><span style=color:#f07171>-    load_context: &'b mut LoadContext<'c>,
</span><span style=color:#f07171>-    settings: &'b GltfLoaderSettings,
</span><span style=color:#f07171>-) -> Result&LTGltf, GltfError> {
</span><span style=color:#f07171>-    let gltf = gltf::Gltf::from_slice(bytes)?;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    let file_name = load_context
</span><span style=color:#f07171>-        .asset_path()
</span><span style=color:#f07171>-        .path()
</span><span style=color:#f07171>-        .to_str()
</span><span style=color:#f07171>-        .ok_or(GltfError::Gltf(gltf::Error::Io(Error::new(
</span><span style=color:#f07171>-            std::io::ErrorKind::InvalidInput,
</span><span style=color:#f07171>-            "Gltf file name invalid",
</span><span style=color:#f07171>-        ))))?
</span><span style=color:#f07171>-        .to_string();
</span><span style=color:#f07171>-    let buffer_data = load_buffers(&gltf, load_context).await?;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    let linear_textures = get_linear_textures(&gltf.document);
</span><span style=color:#86b300>+impl GltfLoader {
</span><span style=color:#86b300>+    /// Loads an entire glTF file.
</span><span style=color:#86b300>+    pub async fn load_gltf<'a, 'b, 'c>(
</span><span style=color:#86b300>+        loader: &GltfLoader,
</span><span style=color:#86b300>+        bytes: &'a [u8],
</span><span style=color:#86b300>+        load_context: &'b mut LoadContext<'c>,
</span><span style=color:#86b300>+        settings: &'b GltfLoaderSettings,
</span><span style=color:#86b300>+    ) -> Result&LTGltf, GltfError> {
</span><span style=color:#86b300>+        let gltf = gltf::Gltf::from_slice(bytes)?;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let file_name = load_context
</span><span style=color:#86b300>+            .asset_path()
</span><span style=color:#86b300>+            .path()
</span><span style=color:#86b300>+            .to_str()
</span><span style=color:#86b300>+            .ok_or(GltfError::Gltf(gltf::Error::Io(Error::new(
</span><span style=color:#86b300>+                std::io::ErrorKind::InvalidInput,
</span><span style=color:#86b300>+                "Gltf file name invalid",
</span><span style=color:#86b300>+            ))))?
</span><span style=color:#86b300>+            .to_string();
</span><span style=color:#86b300>+        let buffer_data = load_buffers(&gltf, load_context).await?;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let linear_textures = get_linear_textures(&gltf.document);
</span><span> 
</span><span style=color:#f07171>-    #[cfg(feature = "bevy_animation")]
</span><span style=color:#f07171>-    let paths = {
</span><span style=color:#f07171>-        let mut paths = HashMap::&LTusize, (usize, Vec&LTName>)>::default();
</span><span style=color:#f07171>-        for scene in gltf.scenes() {
</span><span style=color:#f07171>-            for node in scene.nodes() {
</span><span style=color:#f07171>-                let root_index = node.index();
</span><span style=color:#f07171>-                collect_path(&node, &[], &mut paths, root_index, &mut HashSet::default());
</span><span style=color:#86b300>+        #[cfg(feature = "bevy_animation")]
</span><span style=color:#86b300>+        let paths = {
</span><span style=color:#86b300>+            let mut paths = HashMap::&LTusize, (usize, Vec&LTName>)>::default();
</span><span style=color:#86b300>+            for scene in gltf.scenes() {
</span><span style=color:#86b300>+                for node in scene.nodes() {
</span><span style=color:#86b300>+                    let root_index = node.index();
</span><span style=color:#86b300>+                    collect_path(&node, &[], &mut paths, root_index, &mut HashSet::default());
</span><span style=color:#86b300>+                }
</span><span>             }
</span><span style=color:#f07171>-        }
</span><span style=color:#f07171>-        paths
</span><span style=color:#f07171>-    };
</span><span style=color:#86b300>+            paths
</span><span style=color:#86b300>+        };
</span><span> 
</span><span style=color:#f07171>-    let convert_coordinates = match settings.convert_coordinates {
</span><span style=color:#f07171>-        Some(convert_coordinates) => convert_coordinates,
</span><span style=color:#f07171>-        None => {
</span><span style=color:#f07171>-            let convert_by_default = loader.default_convert_coordinates;
</span><span style=color:#f07171>-            if !convert_by_default && !cfg!(feature = "gltf_convert_coordinates_default") {
</span><span style=color:#f07171>-                warn_once!(
</span><span style=color:#86b300>+        let convert_coordinates = match settings.convert_coordinates {
</span><span style=color:#86b300>+            Some(convert_coordinates) => convert_coordinates,
</span><span style=color:#86b300>+            None => {
</span><span style=color:#86b300>+                let convert_by_default = loader.default_convert_coordinates;
</span><span style=color:#86b300>+                if !convert_by_default && !cfg!(feature = "gltf_convert_coordinates_default") {
</span><span style=color:#86b300>+                    warn_once!(
</span><span>                     "Starting from Bevy 0.18, by default all imported glTF models will be rotated by 180 degrees around the Y axis to align with Bevy's coordinate system. \
</span><span>                     You are currently importing glTF files using the old behavior. Consider opting-in to the new import behavior by enabling the `gltf_convert_coordinates_default` feature. \
</span><span>                     If you encounter any issues please file a bug! \
</span><span>                     If you want to continue using the old behavior going forward (even when the default changes in 0.18), manually set the corresponding option in the `GltfPlugin` or `GltfLoaderSettings`. See the migration guide for more details."
</span><span>                 );
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+                convert_by_default
</span><span>             }
</span><span style=color:#f07171>-            convert_by_default
</span><span style=color:#f07171>-        }
</span><span style=color:#f07171>-    };
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    #[cfg(feature = "bevy_animation")]
</span><span style=color:#f07171>-    let (animations, named_animations, animation_roots) = {
</span><span style=color:#f07171>-        use bevy_animation::{animated_field, animation_curves::*, gltf_curves::*, VariableCurve};
</span><span style=color:#f07171>-        use bevy_math::{
</span><span style=color:#f07171>-            curve::{ConstantCurve, Interval, UnevenSampleAutoCurve},
</span><span style=color:#f07171>-            Quat, Vec4,
</span><span>         };
</span><span style=color:#f07171>-        use gltf::animation::util::ReadOutputs;
</span><span style=color:#f07171>-        let mut animations = vec![];
</span><span style=color:#f07171>-        let mut named_animations = &LTHashMap<_, _>>::default();
</span><span style=color:#f07171>-        let mut animation_roots = &LTHashSet<_>>::default();
</span><span style=color:#f07171>-        for animation in gltf.animations() {
</span><span style=color:#f07171>-            let mut animation_clip = AnimationClip::default();
</span><span style=color:#f07171>-            for channel in animation.channels() {
</span><span style=color:#f07171>-                let node = channel.target().node();
</span><span style=color:#f07171>-                let interpolation = channel.sampler().interpolation();
</span><span style=color:#f07171>-                let reader = channel.reader(|buffer| Some(&buffer_data[buffer.index()]));
</span><span style=color:#f07171>-                let keyframe_timestamps: Vec&LTf32> = if let Some(inputs) = reader.read_inputs() {
</span><span style=color:#f07171>-                    match inputs {
</span><span style=color:#f07171>-                        Iter::Standard(times) => times.collect(),
</span><span style=color:#f07171>-                        Iter::Sparse(_) => {
</span><span style=color:#f07171>-                            warn!("Sparse accessor not supported for animation sampler input");
</span><span style=color:#f07171>-                            continue;
</span><span style=color:#f07171>-                        }
</span><span style=color:#f07171>-                    }
</span><span style=color:#f07171>-                } else {
</span><span style=color:#f07171>-                    warn!("Animations without a sampler input are not supported");
</span><span style=color:#f07171>-                    return Err(GltfError::MissingAnimationSampler(animation.index()));
</span><span style=color:#f07171>-                };
</span><span> 
</span><span style=color:#f07171>-                if keyframe_timestamps.is_empty() {
</span><span style=color:#f07171>-                    warn!("Tried to load animation with no keyframe timestamps");
</span><span style=color:#f07171>-                    continue;
</span><span style=color:#f07171>-                }
</span><span style=color:#86b300>+        #[cfg(feature = "bevy_animation")]
</span><span style=color:#86b300>+        let (animations, named_animations, animation_roots) = {
</span><span style=color:#86b300>+            use bevy_animation::{
</span><span style=color:#86b300>+                animated_field, animation_curves::*, gltf_curves::*, VariableCurve,
</span><span style=color:#86b300>+            };
</span><span style=color:#86b300>+            use bevy_math::{
</span><span style=color:#86b300>+                curve::{ConstantCurve, Interval, UnevenSampleAutoCurve},
</span><span style=color:#86b300>+                Quat, Vec4,
</span><span style=color:#86b300>+            };
</span><span style=color:#86b300>+            use gltf::animation::util::ReadOutputs;
</span><span style=color:#86b300>+            let mut animations = vec![];
</span><span style=color:#86b300>+            let mut named_animations = &LTHashMap<_, _>>::default();
</span><span style=color:#86b300>+            let mut animation_roots = &LTHashSet<_>>::default();
</span><span style=color:#86b300>+            for animation in gltf.animations() {
</span><span style=color:#86b300>+                let mut animation_clip = AnimationClip::default();
</span><span style=color:#86b300>+                for channel in animation.channels() {
</span><span style=color:#86b300>+                    let node = channel.target().node();
</span><span style=color:#86b300>+                    let interpolation = channel.sampler().interpolation();
</span><span style=color:#86b300>+                    let reader = channel.reader(|buffer| Some(&buffer_data[buffer.index()]));
</span><span style=color:#86b300>+                    let keyframe_timestamps: Vec&LTf32> = if let Some(inputs) = reader.read_inputs() {
</span><span style=color:#86b300>+                        match inputs {
</span><span style=color:#86b300>+                            Iter::Standard(times) => times.collect(),
</span><span style=color:#86b300>+                            Iter::Sparse(_) => {
</span><span style=color:#86b300>+                                warn!("Sparse accessor not supported for animation sampler input");
</span><span style=color:#86b300>+                                continue;
</span><span style=color:#86b300>+                            }
</span><span style=color:#86b300>+                        }
</span><span style=color:#86b300>+                    } else {
</span><span style=color:#86b300>+                        warn!("Animations without a sampler input are not supported");
</span><span style=color:#86b300>+                        return Err(GltfError::MissingAnimationSampler(animation.index()));
</span><span style=color:#86b300>+                    };
</span><span> 
</span><span style=color:#f07171>-                let maybe_curve: Option&LTVariableCurve> = if let Some(outputs) =
</span><span style=color:#f07171>-                    reader.read_outputs()
</span><span style=color:#f07171>-                {
</span><span style=color:#f07171>-                    match outputs {
</span><span style=color:#f07171>-                        ReadOutputs::Translations(tr) => {
</span><span style=color:#f07171>-                            let translation_property = animated_field!(Transform::translation);
</span><span style=color:#f07171>-                            let translations: Vec&LTVec3> = tr
</span><span style=color:#f07171>-                                .map(Vec3::from)
</span><span style=color:#f07171>-                                .map(|verts| {
</span><span style=color:#f07171>-                                    if convert_coordinates {
</span><span style=color:#f07171>-                                        Vec3::convert_coordinates(verts)
</span><span style=color:#f07171>-                                    } else {
</span><span style=color:#f07171>-                                        verts
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                })
</span><span style=color:#f07171>-                                .collect();
</span><span style=color:#f07171>-                            if keyframe_timestamps.len() == 1 {
</span><span style=color:#f07171>-                                Some(VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                    translation_property,
</span><span style=color:#f07171>-                                    ConstantCurve::new(Interval::EVERYWHERE, translations[0]),
</span><span style=color:#f07171>-                                )))
</span><span style=color:#f07171>-                            } else {
</span><span style=color:#f07171>-                                match interpolation {
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::Linear => {
</span><span style=color:#f07171>-                                        UnevenSampleAutoCurve::new(
</span><span style=color:#f07171>-                                            keyframe_timestamps.into_iter().zip(translations),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .ok()
</span><span style=color:#f07171>-                                        .map(|curve| {
</span><span style=color:#f07171>-                                            VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                translation_property,
</span><span style=color:#f07171>-                                                curve,
</span><span style=color:#f07171>-                                            ))
</span><span style=color:#f07171>-                                        })
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::Step => {
</span><span style=color:#f07171>-                                        SteppedKeyframeCurve::new(
</span><span style=color:#f07171>-                                            keyframe_timestamps.into_iter().zip(translations),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .ok()
</span><span style=color:#f07171>-                                        .map(|curve| {
</span><span style=color:#f07171>-                                            VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                translation_property,
</span><span style=color:#f07171>-                                                curve,
</span><span style=color:#f07171>-                                            ))
</span><span style=color:#f07171>-                                        })
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::CubicSpline => {
</span><span style=color:#f07171>-                                        CubicKeyframeCurve::new(keyframe_timestamps, translations)
</span><span style=color:#86b300>+                    if keyframe_timestamps.is_empty() {
</span><span style=color:#86b300>+                        warn!("Tried to load animation with no keyframe timestamps");
</span><span style=color:#86b300>+                        continue;
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                    let maybe_curve: Option&LTVariableCurve> = if let Some(outputs) =
</span><span style=color:#86b300>+                        reader.read_outputs()
</span><span style=color:#86b300>+                    {
</span><span style=color:#86b300>+                        match outputs {
</span><span style=color:#86b300>+                            ReadOutputs::Translations(tr) => {
</span><span style=color:#86b300>+                                let translation_property = animated_field!(Transform::translation);
</span><span style=color:#86b300>+                                let translations: Vec&LTVec3> = tr
</span><span style=color:#86b300>+                                    .map(Vec3::from)
</span><span style=color:#86b300>+                                    .map(|verts| {
</span><span style=color:#86b300>+                                        if convert_coordinates {
</span><span style=color:#86b300>+                                            Vec3::convert_coordinates(verts)
</span><span style=color:#86b300>+                                        } else {
</span><span style=color:#86b300>+                                            verts
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                    })
</span><span style=color:#86b300>+                                    .collect();
</span><span style=color:#86b300>+                                if keyframe_timestamps.len() == 1 {
</span><span style=color:#86b300>+                                    Some(VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                        translation_property,
</span><span style=color:#86b300>+                                        ConstantCurve::new(Interval::EVERYWHERE, translations[0]),
</span><span style=color:#86b300>+                                    )))
</span><span style=color:#86b300>+                                } else {
</span><span style=color:#86b300>+                                    match interpolation {
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Linear => {
</span><span style=color:#86b300>+                                            UnevenSampleAutoCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps.into_iter().zip(translations),
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        translation_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Step => {
</span><span style=color:#86b300>+                                            SteppedKeyframeCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps.into_iter().zip(translations),
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        translation_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::CubicSpline => {
</span><span style=color:#86b300>+                                            CubicKeyframeCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps,
</span><span style=color:#86b300>+                                                translations,
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        translation_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                    }
</span><span style=color:#86b300>+                                }
</span><span style=color:#86b300>+                            }
</span><span style=color:#86b300>+                            ReadOutputs::Rotations(rots) => {
</span><span style=color:#86b300>+                                let rotation_property = animated_field!(Transform::rotation);
</span><span style=color:#86b300>+                                let rotations: Vec&LTQuat> = rots
</span><span style=color:#86b300>+                                    .into_f32()
</span><span style=color:#86b300>+                                    .map(Quat::from_array)
</span><span style=color:#86b300>+                                    .map(|quat| {
</span><span style=color:#86b300>+                                        if convert_coordinates {
</span><span style=color:#86b300>+                                            Quat::convert_coordinates(quat)
</span><span style=color:#86b300>+                                        } else {
</span><span style=color:#86b300>+                                            quat
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                    })
</span><span style=color:#86b300>+                                    .collect();
</span><span style=color:#86b300>+                                if keyframe_timestamps.len() == 1 {
</span><span style=color:#86b300>+                                    Some(VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                        rotation_property,
</span><span style=color:#86b300>+                                        ConstantCurve::new(Interval::EVERYWHERE, rotations[0]),
</span><span style=color:#86b300>+                                    )))
</span><span style=color:#86b300>+                                } else {
</span><span style=color:#86b300>+                                    match interpolation {
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Linear => {
</span><span style=color:#86b300>+                                            UnevenSampleAutoCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps.into_iter().zip(rotations),
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        rotation_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Step => {
</span><span style=color:#86b300>+                                            SteppedKeyframeCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps.into_iter().zip(rotations),
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        rotation_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::CubicSpline => {
</span><span style=color:#86b300>+                                            CubicRotationCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps,
</span><span style=color:#86b300>+                                                rotations.into_iter().map(Vec4::from),
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        rotation_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                    }
</span><span style=color:#86b300>+                                }
</span><span style=color:#86b300>+                            }
</span><span style=color:#86b300>+                            ReadOutputs::Scales(scale) => {
</span><span style=color:#86b300>+                                let scale_property = animated_field!(Transform::scale);
</span><span style=color:#86b300>+                                let scales: Vec&LTVec3> = scale.map(Vec3::from).collect();
</span><span style=color:#86b300>+                                if keyframe_timestamps.len() == 1 {
</span><span style=color:#86b300>+                                    Some(VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                        scale_property,
</span><span style=color:#86b300>+                                        ConstantCurve::new(Interval::EVERYWHERE, scales[0]),
</span><span style=color:#86b300>+                                    )))
</span><span style=color:#86b300>+                                } else {
</span><span style=color:#86b300>+                                    match interpolation {
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Linear => {
</span><span style=color:#86b300>+                                            UnevenSampleAutoCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps.into_iter().zip(scales),
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        scale_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Step => {
</span><span style=color:#86b300>+                                            SteppedKeyframeCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps.into_iter().zip(scales),
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(
</span><span style=color:#86b300>+                                                |curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        scale_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                },
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::CubicSpline => {
</span><span style=color:#86b300>+                                            CubicKeyframeCurve::new(keyframe_timestamps, scales)
</span><span style=color:#86b300>+                                                .ok()
</span><span style=color:#86b300>+                                                .map(|curve| {
</span><span style=color:#86b300>+                                                    VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#86b300>+                                                        scale_property,
</span><span style=color:#86b300>+                                                        curve,
</span><span style=color:#86b300>+                                                    ))
</span><span style=color:#86b300>+                                                })
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                    }
</span><span style=color:#86b300>+                                }
</span><span style=color:#86b300>+                            }
</span><span style=color:#86b300>+                            ReadOutputs::MorphTargetWeights(weights) => {
</span><span style=color:#86b300>+                                let weights: Vec&LTf32> = weights.into_f32().collect();
</span><span style=color:#86b300>+                                if keyframe_timestamps.len() == 1 {
</span><span style=color:#86b300>+                                    #[expect(
</span><span style=color:#86b300>+                                        clippy::unnecessary_map_on_constructor,
</span><span style=color:#86b300>+                                        reason = "While the mapping is unnecessary, it is much more readable at this level of indentation. Additionally, mapping makes it more consistent with the other branches."
</span><span style=color:#86b300>+                                    )]
</span><span style=color:#86b300>+                                    Some(ConstantCurve::new(Interval::EVERYWHERE, weights))
</span><span style=color:#86b300>+                                        .map(WeightsCurve)
</span><span style=color:#86b300>+                                        .map(VariableCurve::new)
</span><span style=color:#86b300>+                                } else {
</span><span style=color:#86b300>+                                    match interpolation {
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Linear => {
</span><span style=color:#86b300>+                                            WideLinearKeyframeCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps,
</span><span style=color:#86b300>+                                                weights,
</span><span style=color:#86b300>+                                            )
</span><span>                                             .ok()
</span><span style=color:#f07171>-                                            .map(|curve| {
</span><span style=color:#f07171>-                                                VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                    translation_property,
</span><span style=color:#f07171>-                                                    curve,
</span><span style=color:#f07171>-                                                ))
</span><span style=color:#f07171>-                                            })
</span><span style=color:#86b300>+                                            .map(WeightsCurve)
</span><span style=color:#86b300>+                                            .map(VariableCurve::new)
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::Step => {
</span><span style=color:#86b300>+                                            WideSteppedKeyframeCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps,
</span><span style=color:#86b300>+                                                weights,
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(WeightsCurve)
</span><span style=color:#86b300>+                                            .map(VariableCurve::new)
</span><span style=color:#86b300>+                                        }
</span><span style=color:#86b300>+                                        gltf::animation::Interpolation::CubicSpline => {
</span><span style=color:#86b300>+                                            WideCubicKeyframeCurve::new(
</span><span style=color:#86b300>+                                                keyframe_timestamps,
</span><span style=color:#86b300>+                                                weights,
</span><span style=color:#86b300>+                                            )
</span><span style=color:#86b300>+                                            .ok()
</span><span style=color:#86b300>+                                            .map(WeightsCurve)
</span><span style=color:#86b300>+                                            .map(VariableCurve::new)
</span><span style=color:#86b300>+                                        }
</span><span>                                     }
</span><span>                                 }
</span><span>                             }
</span><span>                         }
</span><span style=color:#f07171>-                        ReadOutputs::Rotations(rots) => {
</span><span style=color:#f07171>-                            let rotation_property = animated_field!(Transform::rotation);
</span><span style=color:#f07171>-                            let rotations: Vec&LTQuat> = rots
</span><span style=color:#f07171>-                                .into_f32()
</span><span style=color:#f07171>-                                .map(Quat::from_array)
</span><span style=color:#f07171>-                                .map(|quat| {
</span><span style=color:#f07171>-                                    if convert_coordinates {
</span><span style=color:#f07171>-                                        Quat::convert_coordinates(quat)
</span><span style=color:#f07171>-                                    } else {
</span><span style=color:#f07171>-                                        quat
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                })
</span><span style=color:#f07171>-                                .collect();
</span><span style=color:#f07171>-                            if keyframe_timestamps.len() == 1 {
</span><span style=color:#f07171>-                                Some(VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                    rotation_property,
</span><span style=color:#f07171>-                                    ConstantCurve::new(Interval::EVERYWHERE, rotations[0]),
</span><span style=color:#f07171>-                                )))
</span><span style=color:#f07171>-                            } else {
</span><span style=color:#f07171>-                                match interpolation {
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::Linear => {
</span><span style=color:#f07171>-                                        UnevenSampleAutoCurve::new(
</span><span style=color:#f07171>-                                            keyframe_timestamps.into_iter().zip(rotations),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .ok()
</span><span style=color:#f07171>-                                        .map(|curve| {
</span><span style=color:#f07171>-                                            VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                rotation_property,
</span><span style=color:#f07171>-                                                curve,
</span><span style=color:#f07171>-                                            ))
</span><span style=color:#f07171>-                                        })
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::Step => {
</span><span style=color:#f07171>-                                        SteppedKeyframeCurve::new(
</span><span style=color:#f07171>-                                            keyframe_timestamps.into_iter().zip(rotations),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .ok()
</span><span style=color:#f07171>-                                        .map(|curve| {
</span><span style=color:#f07171>-                                            VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                rotation_property,
</span><span style=color:#f07171>-                                                curve,
</span><span style=color:#f07171>-                                            ))
</span><span style=color:#f07171>-                                        })
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::CubicSpline => {
</span><span style=color:#f07171>-                                        CubicRotationCurve::new(
</span><span style=color:#f07171>-                                            keyframe_timestamps,
</span><span style=color:#f07171>-                                            rotations.into_iter().map(Vec4::from),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .ok()
</span><span style=color:#f07171>-                                        .map(|curve| {
</span><span style=color:#f07171>-                                            VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                rotation_property,
</span><span style=color:#f07171>-                                                curve,
</span><span style=color:#f07171>-                                            ))
</span><span style=color:#f07171>-                                        })
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                }
</span><span style=color:#f07171>-                            }
</span><span style=color:#f07171>-                        }
</span><span style=color:#f07171>-                        ReadOutputs::Scales(scale) => {
</span><span style=color:#f07171>-                            let scale_property = animated_field!(Transform::scale);
</span><span style=color:#f07171>-                            let scales: Vec&LTVec3> = scale.map(Vec3::from).collect();
</span><span style=color:#f07171>-                            if keyframe_timestamps.len() == 1 {
</span><span style=color:#f07171>-                                Some(VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                    scale_property,
</span><span style=color:#f07171>-                                    ConstantCurve::new(Interval::EVERYWHERE, scales[0]),
</span><span style=color:#f07171>-                                )))
</span><span style=color:#f07171>-                            } else {
</span><span style=color:#f07171>-                                match interpolation {
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::Linear => {
</span><span style=color:#f07171>-                                        UnevenSampleAutoCurve::new(
</span><span style=color:#f07171>-                                            keyframe_timestamps.into_iter().zip(scales),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .ok()
</span><span style=color:#f07171>-                                        .map(|curve| {
</span><span style=color:#f07171>-                                            VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                scale_property,
</span><span style=color:#f07171>-                                                curve,
</span><span style=color:#f07171>-                                            ))
</span><span style=color:#f07171>-                                        })
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::Step => {
</span><span style=color:#f07171>-                                        SteppedKeyframeCurve::new(
</span><span style=color:#f07171>-                                            keyframe_timestamps.into_iter().zip(scales),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .ok()
</span><span style=color:#f07171>-                                        .map(|curve| {
</span><span style=color:#f07171>-                                            VariableCurve::new(AnimatableCurve::new(
</span><span style=color:#f07171>-                                                scale_property,
</span><span style=color:#f07171>-                                                curve,
</span><span style=color:#f07171>-                                            ))
</span><span style=color:#f07171>-                                        })
</span><span style=color:#f07171>-                                    }
</span><span style=color:#f07171>-                                    gltf::animation::Interpolation::CubicSpline => {
</span><span style=color:#f07171>-                                        CubicKeyframeCurve::new(keyframe_timestamps, scales)
</span><span style=color:#86b300>+                    } else {
</span><span style=color:#86b300>+                        warn!("Animations without a sampler output are not supported");
</span><span style=color:#86b300>+                        return Err(GltfError::MissingAnimationSampler(animation.index()));
</span><span style=color:#86b300>+                    };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                    let Some(curve) = maybe_curve else {
</span><span style=color:#86b300>+                        warn!(
</span><span style=color:#86b300>+                            "Invalid keyframe data for node {}; curve could not be constructed",
</span><span style=color:#86b300>+                            node.index()
</span><span style=color:#86b300>+                        );
</span><span style=color:#86b300>+                        continue;
</span><span style=color:#86b300>+                    };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                    if let Some((root_index, path)) = paths.get(&node.index()) {
</span><span style=color:#86b300>+                        animation_roots.insert(*root_index);
</span><span style=color:#86b300>+                        animation_clip.add_variable_curve_to_target(
</span><span style=color:#86b300>+                            AnimationTargetId::from_names(path.iter()),
</span><span style=color:#86b300>+                            curve,
</span><span style=color:#86b300>+                        );
</span><span style=color:#86b300>+                    } else {
</span><span style=color:#86b300>+                        warn!(
</span><span style=color:#86b300>+                        "Animation ignored for node {}: part of its hierarchy is missing a name",
</span><span style=color:#86b300>+                        node.index()
</span><span style=color:#86b300>+                    );
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+                let handle = load_context.add_labeled_asset(
</span><span style=color:#86b300>+                    GltfAssetLabel::Animation(animation.index()).to_string(),
</span><span style=color:#86b300>+                    animation_clip,
</span><span style=color:#86b300>+                );
</span><span style=color:#86b300>+                if let Some(name) = animation.name() {
</span><span style=color:#86b300>+                    named_animations.insert(name.into(), handle.clone());
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+                animations.push(handle);
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+            (animations, named_animations, animation_roots)
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let default_sampler = match settings.default_sampler.as_ref() {
</span><span style=color:#86b300>+            Some(sampler) => sampler,
</span><span style=color:#86b300>+            None => &loader.default_sampler.lock().unwrap().clone(),
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+        // We collect handles to ensure loaded images from paths are not unloaded before they are used elsewhere
</span><span style=color:#86b300>+        // in the loader. This prevents "reloads", but it also prevents dropping the is_srgb context on reload.
</span><span style=color:#86b300>+        //
</span><span style=color:#86b300>+        // In theory we could store a mapping between texture.index() and handle to use
</span><span style=color:#86b300>+        // later in the loader when looking up handles for materials. However this would mean
</span><span style=color:#86b300>+        // that the material's load context would no longer track those images as dependencies.
</span><span style=color:#86b300>+        let mut _texture_handles = Vec::new();
</span><span style=color:#86b300>+        if gltf.textures().len() == 1 || cfg!(target_arch = "wasm32") {
</span><span style=color:#86b300>+            for texture in gltf.textures() {
</span><span style=color:#86b300>+                let parent_path = load_context.path().parent().unwrap();
</span><span style=color:#86b300>+                let image = load_image(
</span><span style=color:#86b300>+                    texture,
</span><span style=color:#86b300>+                    &buffer_data,
</span><span style=color:#86b300>+                    &linear_textures,
</span><span style=color:#86b300>+                    parent_path,
</span><span style=color:#86b300>+                    loader.supported_compressed_formats,
</span><span style=color:#86b300>+                    default_sampler,
</span><span style=color:#86b300>+                    settings,
</span><span style=color:#86b300>+                )
</span><span style=color:#86b300>+                .await?;
</span><span style=color:#86b300>+                image.process_loaded_texture(load_context, &mut _texture_handles);
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        } else {
</span><span style=color:#86b300>+            #[cfg(not(target_arch = "wasm32"))]
</span><span style=color:#86b300>+            IoTaskPool::get()
</span><span style=color:#86b300>+                .scope(|scope| {
</span><span style=color:#86b300>+                    gltf.textures().for_each(|gltf_texture| {
</span><span style=color:#86b300>+                        let parent_path = load_context.path().parent().unwrap();
</span><span style=color:#86b300>+                        let linear_textures = &linear_textures;
</span><span style=color:#86b300>+                        let buffer_data = &buffer_data;
</span><span style=color:#86b300>+                        scope.spawn(async move {
</span><span style=color:#86b300>+                            load_image(
</span><span style=color:#86b300>+                                gltf_texture,
</span><span style=color:#86b300>+                                buffer_data,
</span><span style=color:#86b300>+                                linear_textures,
</span><span style=color:#86b300>+                                parent_path,
</span><span style=color:#86b300>+                                loader.supported_compressed_formats,
</span><span style=color:#86b300>+                                default_sampler,
</span><span style=color:#86b300>+                                settings,
</span><span style=color:#86b300>+                            )
</span><span style=color:#86b300>+                            .await
</span><span style=color:#86b300>+                        });
</span><span style=color:#86b300>+                    });
</span><span style=color:#86b300>+                })
</span><span style=color:#86b300>+                .into_iter()
</span><span style=color:#86b300>+                .for_each(|result| match result {
</span><span style=color:#86b300>+                    Ok(image) => {
</span><span style=color:#86b300>+                        image.process_loaded_texture(load_context, &mut _texture_handles);
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                    Err(err) => {
</span><span style=color:#86b300>+                        warn!("Error loading glTF texture: {}", err);
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                });
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let mut materials = vec![];
</span><span style=color:#86b300>+        let mut named_materials = &LTHashMap<_, _>>::default();
</span><span style=color:#86b300>+        // Only include materials in the output if they're set to be retained in the MAIN_WORLD and/or RENDER_WORLD by the load_materials flag
</span><span style=color:#86b300>+        if !settings.load_materials.is_empty() {
</span><span style=color:#86b300>+            // NOTE: materials must be loaded after textures because image load() calls will happen before load_with_settings, preventing is_srgb from being set properly
</span><span style=color:#86b300>+            for material in gltf.materials() {
</span><span style=color:#86b300>+                let handle = load_material(&material, load_context, &gltf.document, false);
</span><span style=color:#86b300>+                if let Some(name) = material.name() {
</span><span style=color:#86b300>+                    named_materials.insert(name.into(), handle.clone());
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+                materials.push(handle);
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+        let mut meshes = vec![];
</span><span style=color:#86b300>+        let mut named_meshes = &LTHashMap<_, _>>::default();
</span><span style=color:#86b300>+        let mut meshes_on_skinned_nodes = &LTHashSet<_>>::default();
</span><span style=color:#86b300>+        let mut meshes_on_non_skinned_nodes = &LTHashSet<_>>::default();
</span><span style=color:#86b300>+        for gltf_node in gltf.nodes() {
</span><span style=color:#86b300>+            if gltf_node.skin().is_some() {
</span><span style=color:#86b300>+                if let Some(mesh) = gltf_node.mesh() {
</span><span style=color:#86b300>+                    meshes_on_skinned_nodes.insert(mesh.index());
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+            } else if let Some(mesh) = gltf_node.mesh() {
</span><span style=color:#86b300>+                meshes_on_non_skinned_nodes.insert(mesh.index());
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+        for gltf_mesh in gltf.meshes() {
</span><span style=color:#86b300>+            let mut primitives = vec![];
</span><span style=color:#86b300>+            for primitive in gltf_mesh.primitives() {
</span><span style=color:#86b300>+                let primitive_label = GltfAssetLabel::Primitive {
</span><span style=color:#86b300>+                    mesh: gltf_mesh.index(),
</span><span style=color:#86b300>+                    primitive: primitive.index(),
</span><span style=color:#86b300>+                };
</span><span style=color:#86b300>+                let primitive_topology = primitive_topology(primitive.mode())?;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                let mut mesh = Mesh::new(primitive_topology, settings.load_meshes);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                // Read vertex attributes
</span><span style=color:#86b300>+                for (semantic, accessor) in primitive.attributes() {
</span><span style=color:#86b300>+                    if [Semantic::Joints(0), Semantic::Weights(0)].contains(&semantic) {
</span><span style=color:#86b300>+                        if !meshes_on_skinned_nodes.contains(&gltf_mesh.index()) {
</span><span style=color:#86b300>+                            warn!(
</span><span style=color:#86b300>+                        "Ignoring attribute {:?} for skinned mesh {} used on non skinned nodes (NODE_SKINNED_MESH_WITHOUT_SKIN)",
</span><span style=color:#86b300>+                        semantic,
</span><span style=color:#86b300>+                        primitive_label
</span><span style=color:#86b300>+                    );
</span><span style=color:#86b300>+                            continue;
</span><span style=color:#86b300>+                        } else if meshes_on_non_skinned_nodes.contains(&gltf_mesh.index()) {
</span><span style=color:#86b300>+                            error!("Skinned mesh {} used on both skinned and non skin nodes, this is likely to cause an error (NODE_SKINNED_MESH_WITHOUT_SKIN)", primitive_label);
</span><span style=color:#86b300>+                        }
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                    match convert_attribute(
</span><span style=color:#86b300>+                        semantic,
</span><span style=color:#86b300>+                        accessor,
</span><span style=color:#86b300>+                        &buffer_data,
</span><span style=color:#86b300>+                        &loader.custom_vertex_attributes,
</span><span style=color:#86b300>+                        convert_coordinates,
</span><span style=color:#86b300>+                    ) {
</span><span style=color:#86b300>+                        Ok((attribute, values)) => mesh.insert_attribute(attribute, values),
</span><span style=color:#86b300>+                        Err(err) => warn!("{}", err),
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                // Read vertex indices
</span><span style=color:#86b300>+                let reader =
</span><span style=color:#86b300>+                    primitive.reader(|buffer| Some(buffer_data[buffer.index()].as_slice()));
</span><span style=color:#86b300>+                if let Some(indices) = reader.read_indices() {
</span><span style=color:#86b300>+                    mesh.insert_indices(match indices {
</span><span style=color:#86b300>+                        ReadIndices::U8(is) => Indices::U16(is.map(|x| x as u16).collect()),
</span><span style=color:#86b300>+                        ReadIndices::U16(is) => Indices::U16(is.collect()),
</span><span style=color:#86b300>+                        ReadIndices::U32(is) => Indices::U32(is.collect()),
</span><span style=color:#86b300>+                    });
</span><span style=color:#86b300>+                };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                {
</span><span style=color:#86b300>+                    let morph_target_reader = reader.read_morph_targets();
</span><span style=color:#86b300>+                    if morph_target_reader.len() != 0 {
</span><span style=color:#86b300>+                        let morph_targets_label = GltfAssetLabel::MorphTarget {
</span><span style=color:#86b300>+</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_20225.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>