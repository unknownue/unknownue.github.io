<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20191 Deduplicate orthonormal basis construction
        
    </title><meta content="#20191 Deduplicate orthonormal basis construction" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-20</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-20191-zh-cn-20250720>中文</a></div></div><div class=pr-content><h1 id=deduplicate-orthonormal-basis-construction>Deduplicate orthonormal basis construction</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Deduplicate orthonormal basis construction<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20191<li><strong>Author</strong>: atlv24<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, S-Ready-For-Final-Review, D-Shaders, M-Deliberate-Rendering-Change<li><strong>Created</strong>: 2025-07-18T17:46:56Z<li><strong>Merged</strong>: 2025-07-20T16:27:13Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Deduplicate orthonormal basis construction<li>fix a bug with handling of negative zero in spotlight basis construction<li>separate handedness flip from basis construction in spotlight basis<li>improve performance and stability of point light orthonormal basis construction<li>improve docs</ul><h2 id=solution>Solution</h2><ul><li>edit the code</ul><h2 id=testing>Testing</h2><ul><li>spotlight example and 3d_scene</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>Orthonormal basis construction is a fundamental operation used throughout Bevy’s rendering pipeline, particularly for lighting calculations. Before this PR, several independent implementations existed across Rust code and WGSL shaders. This duplication created maintenance challenges and risked subtle inconsistencies that could cause rendering artifacts.<p>Specifically, spotlight calculations used slightly different implementations between CPU (Rust) and GPU (WGSL) code paths. The WGSL implementation had a bug in handling negative zero values, which could lead to incorrect basis vectors in certain edge cases. Additionally, the existing implementations used different algorithms - some used Gram-Schmidt while others used Duff’s method - making it difficult to ensure consistent behavior.<h3 id=the-solution-approach>The Solution Approach</h3><p>The core solution was to consolidate all orthonormal basis construction into a single, shared implementation. We chose Duff’s method from <a rel="noopener nofollow noreferrer" href=https://jcgt.org/published/0006/01/01/ target=_blank>“Building an Orthonormal Basis, Revisited”</a> for its numerical stability and performance characteristics. This algorithm is branchless, avoids degenerate cases, and matches what <code>glam::Vec3::any_orthonormal_pair</code> uses.<p>Key engineering decisions:<ol><li>Create a shared <code>orthonormalize</code> function in both Rust and WGSL<li>Fix negative zero handling using bitwise copysign operation<li>Separate basis construction from handedness flipping<li>Replace all custom implementations with the shared function<li>Maintain exact CPU-GPU implementation parity</ol><h3 id=the-implementation>The Implementation</h3><p>The implementation centered around creating a unified <code>orthonormalize</code> function that could be reused across multiple systems. In Rust, we added this to <code>spot_light.rs</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>orthonormalize</span><span>(</span><span style=color:#ff8f40>z_basis</span><span style=color:#61676ccc>:</span><span> Dir3) </span><span style=color:#61676ccc>-></span><span> Mat3 {
</span><span>    </span><span style=color:#fa6e32>let</span><span> sign </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#fa6e32>f32</span><span style=color:#ed9366>.</span><span style=color:#f07171>copysign</span><span>(z_basis</span><span style=color:#ed9366>.</span><span>z)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> a </span><span style=color:#ed9366>= -</span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>/ </span><span>(sign </span><span style=color:#ed9366>+</span><span> z_basis</span><span style=color:#ed9366>.</span><span>z)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> b </span><span style=color:#ed9366>=</span><span> z_basis</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>*</span><span> z_basis</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>*</span><span> a</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> x_basis </span><span style=color:#ed9366>= </span><span>Vec3</span><span style=color:#ed9366>::</span><span>new(
</span><span>        </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>+</span><span> sign </span><span style=color:#ed9366>*</span><span> z_basis</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>*</span><span> z_basis</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>*</span><span> a</span><span style=color:#61676ccc>,
</span><span>        sign </span><span style=color:#ed9366>*</span><span> b</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>-</span><span>sign </span><span style=color:#ed9366>*</span><span> z_basis</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> y_basis </span><span style=color:#ed9366>= </span><span>Vec3</span><span style=color:#ed9366>::</span><span>new(b</span><span style=color:#61676ccc>,</span><span> sign </span><span style=color:#ed9366>+</span><span> z_basis</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>*</span><span> z_basis</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>*</span><span> a</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>-</span><span>z_basis</span><span style=color:#ed9366>.</span><span>y)</span><span style=color:#61676ccc>;
</span><span>    Mat3</span><span style=color:#ed9366>::</span><span>from_cols(x_basis</span><span style=color:#61676ccc>,</span><span> y_basis</span><span style=color:#61676ccc>,</span><span> z_basis</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())
</span><span>}
</span></code></pre><p>In WGSL, we implemented the same algorithm with proper negative zero handling:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn copysign(a: f32, b: f32) -> f32 {
</span><span>    return bitcast&LTf32>((bitcast&LTu32>(a) & 0x7FFFFFFF) | (bitcast&LTu32>(b) & 0x80000000);
</span><span>}
</span><span>
</span><span>fn orthonormalize(z_basis: vec3&LTf32>) -> mat3x3&LTf32> {
</span><span>    let sign = copysign(1.0, z_basis.z);
</span><span>    let a = -1.0 / (sign + z_basis.z);
</span><span>    let b = z_basis.x * z_basis.y * a;
</span><span>    let x_basis = vec3(1.0 + sign * z_basis.x * z_basis.x * a, sign * b, -sign * z_basis.x);
</span><span>    let y_basis = vec3(b, sign + z_basis.y * z_basis.y * a, -z_basis.y);
</span><span>    return mat3x3(x_basis, y_basis, z_basis);
</span><span>}
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>The key technical improvements:<ol><li><p><strong>Negative Zero Fix</strong>: The previous WGSL implementation used conditional checks for sign determination which didn’t properly handle negative zero. The new bitwise <code>copysign</code> implementation matches Rust’s behavior exactly.</p><li><p><strong>Handedness Separation</strong>: Spotlight calculations require left-handed coordinate systems. Instead of baking this into the basis construction, we now:</p> <ul><li>Create a right-handed basis with <code>orthonormalize</code><li>Explicitly flip the x-axis for handedness conversion</ul> <p>This separation makes the code more reusable and clear:</p></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> basis </span><span style=color:#ed9366>= </span><span style=color:#f07171>orthonormalize</span><span>(fwd_dir)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let mut</span><span> mat </span><span style=color:#ed9366>= </span><span>Mat4</span><span style=color:#ed9366>::</span><span>from_mat3(basis)</span><span style=color:#61676ccc>;
</span><span>mat</span><span style=color:#ed9366>.</span><span>x_axis </span><span style=color:#ed9366>= -</span><span>mat</span><span style=color:#ed9366>.</span><span>x_axis</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// Handedness flip
</span></code></pre><ol start=3><li><p><strong>Performance</strong>: Duff’s method is branchless and requires fewer operations than the previous Gram-Schmidt implementation in <code>bevy_render/maths.wgsl</code>. This improves shader performance, especially on mobile GPUs.</p><li><p><strong>Consistency</strong>: All systems now use the same algorithm - spotlight rendering, point lights, and ray tracing (bevy_solari) all share the identical implementation.</p></ol><h3 id=the-impact>The Impact</h3><p>These changes provide several concrete improvements:<ol><li><strong>Bug Fix</strong>: Negative zero values are now handled correctly in spotlight basis calculations<li><strong>Code Health</strong>: Eliminated 4 separate implementations, reducing maintenance burden<li><strong>Performance</strong>: More efficient basis calculation in shaders<li><strong>Clarity</strong>: Explicit handedness conversion makes coordinate system intentions clear<li><strong>Portability</strong>: Shared implementation works consistently across CPU and GPU</ol><p>The changes particularly benefit spotlight rendering where numerical stability is critical for shadow mapping. Developers can now rely on consistent behavior when working with coordinate systems throughout Bevy’s rendering pipeline.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    orthonormalize[orthonormalize function] --> spotlight_rust[SpotLight Rust]
</span><span>    orthonormalize --> shadows_wgsl[Shadows WGSL]
</span><span>    orthonormalize --> maths_wgsl[Maths WGSL]
</span><span>    orthonormalize --> solari_wgsl[Solari WGSL]
</span><span>    
</span><span>    maths_wgsl -. exports .-> shadows_wgsl
</span><span>    maths_wgsl -. exports .-> solari_wgsl
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-light-src-spot-light-rs-32-24><code>crates/bevy_light/src/spot_light.rs</code> (+32/-24)</h3><p>Central change: extracted orthonormal basis logic into reusable function and separated handedness conversion.<p>Key changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>spot_light_world_from_view</span><span>(</span><span style=color:#ff8f40>transform</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>GlobalTransform) </span><span style=color:#61676ccc>-></span><span> Mat4 {
</span><span>    </span><span style=color:#fa6e32>let</span><span> fwd_dir </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>back</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> sign </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#fa6e32>f32</span><span style=color:#ed9366>.</span><span style=color:#f07171>copysign</span><span>(fwd_dir</span><span style=color:#ed9366>.</span><span>z)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... inline basis calculation ...
</span><span>    Mat4</span><span style=color:#ed9366>::</span><span>from_cols(right_dir</span><span style=color:#61676ccc>,</span><span> up_dir</span><span style=color:#61676ccc>,</span><span> fwd_dir</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>...</span><span>)
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>orthonormalize</span><span>(</span><span style=color:#ff8f40>z_basis</span><span style=color:#61676ccc>:</span><span> Dir3) </span><span style=color:#61676ccc>-></span><span> Mat3 {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Shared basis calculation
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>spot_light_world_from_view</span><span>(</span><span style=color:#ff8f40>transform</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>GlobalTransform) </span><span style=color:#61676ccc>-></span><span> Mat4 {
</span><span>    </span><span style=color:#fa6e32>let</span><span> fwd_dir </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>back</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> basis </span><span style=color:#ed9366>= </span><span style=color:#f07171>orthonormalize</span><span>(fwd_dir)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> mat </span><span style=color:#ed9366>= </span><span>Mat4</span><span style=color:#ed9366>::</span><span>from_mat3(basis)</span><span style=color:#61676ccc>;
</span><span>    mat</span><span style=color:#ed9366>.</span><span>x_axis </span><span style=color:#ed9366>= -</span><span>mat</span><span style=color:#ed9366>.</span><span>x_axis</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// Handedness flip
</span><span>    mat</span><span style=color:#ed9366>.</span><span>w_axis </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>translation</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(</span><span style=color:#ff8f40>1.0</span><span>)</span><span style=color:#61676ccc>;
</span><span>    mat
</span><span>}
</span></code></pre><h3 id=crates-bevy-render-src-maths-wgsl-17-11><code>crates/bevy_render/src/maths.wgsl</code> (+17/-11)</h3><p>Replaced Gram-Schmidt implementation with Duff’s method and added proper negative zero handling.<p>Key changes:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>fn orthonormalize(z_normalized: vec3&LTf32>) -> mat3x3&LTf32> {
</span><span>    var up = vec3(0.0, 1.0, 0.0);
</span><span>    if (abs(dot(up, z_normalized)) > 0.99) {
</span><span>        up = vec3(1.0, 0.0, 0.0);
</span><span>    }
</span><span>    // ... Gram-Schmidt process ...
</span><span>}
</span><span>
</span><span>// After:
</span><span>fn copysign(a: f32, b: f32) -> f32 {
</span><span>    return bitcast&LTf32>((bitcast&LTu32>(a) & 0x7FFFFFFF) | (bitcast&LTu32>(b) & 0x80000000));
</span><span>}
</span><span>
</span><span>fn orthonormalize(z_basis: vec3&LTf32>) -> mat3x3&LTf32> {
</span><span>    let sign = copysign(1.0, z_basis.z);
</span><span>    // Duff's method implementation
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-render-shadows-wgsl-12-13><code>crates/bevy_pbr/src/render/shadows.wgsl</code> (+12/-13)</h3><p>Updated to use shared orthonormalize function and explicit handedness flip.<p>Key changes:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>fn spot_light_world_from_view(fwd: vec3&LTf32>) -> mat3x3&LTf32> {
</span><span>    var sign = -1.0;
</span><span>    if (fwd.z >= 0.0) { sign = 1.0; }
</span><span>    // ... inline basis calculation ...
</span><span>}
</span><span>
</span><span>// After:
</span><span>fn spot_light_world_from_view(z_basis: vec3&LTf32>) -> mat3x3&LTf32> {
</span><span>    var basis = orthonormalize(z_basis);
</span><span>    basis[0] = -basis[0]; // Handedness flip
</span><span>    return basis;
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-scene-sampling-wgsl-4-14><code>crates/bevy_solari/src/scene/sampling.wgsl</code> (+4/-14)</h3><p>Removed local implementation in favor of shared function.<p>Key changes:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>fn build_orthonormal_basis(normal: vec3&LTf32>) -> mat3x3&LTf32> {
</span><span>    // Local implementation
</span><span>}
</span><span>
</span><span>// After:
</span><span>// Replaced with orthonormalize from bevy_render
</span></code></pre><h3 id=crates-bevy-light-src-lib-rs-2-2><code>crates/bevy_light/src/lib.rs</code> (+2/-2)</h3><p>Exported the new orthonormalize function.<h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://jcgt.org/published/0006/01/01/ target=_blank>Building an Orthonormal Basis, Revisited</a> - The paper describing the algorithm used<li><a rel="noopener nofollow noreferrer" href=https://github.com/bitshifter/glam-rs/blob/main/src/f32/vec3.rs target=_blank>glam’s any_orthonormal_pair implementation</a> - Reference implementation that inspired this approach<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/IEEE_754 target=_blank>IEEE 754 Floating Point Standard</a> - Background on negative zero handling<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Right-hand_rule target=_blank>Coordinate System Handedness</a> - Explanation of left vs right-handed systems</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_20191.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>