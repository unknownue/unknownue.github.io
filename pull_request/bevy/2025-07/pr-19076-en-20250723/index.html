<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #19076 Environment Map Filtering GPU pipeline
        
    </title><meta content="#19076 Environment Map Filtering GPU pipeline" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-23</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-19076-zh-cn-20250723>中文</a></div></div><div class=pr-content><h1 id=environment-map-filtering-gpu-pipeline>Environment Map Filtering GPU pipeline</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Environment Map Filtering GPU pipeline<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/19076<li><strong>Author</strong>: mate-h<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, D-Complex, M-Needs-Release-Note, M-Deliberate-Rendering-Change<li><strong>Created</strong>: 2025-05-05T16:22:04Z<li><strong>Merged</strong>: 2025-07-23T19:51:10Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>This PR implements a robust GPU-based pipeline for dynamically generating environment maps in Bevy. It builds upon PR #19037, allowing these changes to be evaluated independently from the atmosphere implementation.<p>While existing offline tools can process environment maps, generate mip levels, and calculate specular lighting with importance sampling, they’re limited to static file-based workflows. This PR introduces a real-time GPU pipeline that dynamically generates complete environment maps from a single cubemap texture on each frame.<p>Closes #9380<h2 id=solution>Solution</h2><p>Implemented a Single Pass Downsampling (SPD) pipeline that processes textures without pre-existing mip levels or pre-filtered lighting data.<p>Single Pass Downsampling (SPD) pipeline:<ul><li>accepts any square, power-of-two cubemap up to 8192 × 8192 per face and generates the complete mip chain in one frame;<li>copies the base mip (level 0) in a dedicated compute dispatch (<code>copy_mip0</code>) before the down-sampling pass;<li>performs the down-sampling itself in two compute dispatches to fit within subgroup limits;<li>heavily inspired by Jasmine’s prototype code.</ul><p>Pre-filtering pipeline:<ul><li>generates the specular Radiance Map using bounded-VNDF GGX importance sampling for higher quality highlights and fewer fireflies;<li>computes the diffuse Irradiance Map with cosine-weighted hemisphere sampling;<li>mirrors the forward-/reverse-tonemap workflow used by TAA instead of exposing a separate <em>white-point</em> parameter;<li>is based on the resources below together with the “Bounded VNDF Sampling for Smith-GGX Reflections” paper.</ul><p>The pre-filtering pipeline is largely based on these articles:<ul><li>https://placeholderart.wordpress.com/2015/07/28/implementation-notes-runtime-environment-map-filtering-for-image-based-lighting/<li>https://bruop.github.io/ibl/<li>https://gpuopen.com/download/Bounded_VNDF_Sampling_for_Smith-GGX_Reflections.pdf</ul><blockquote><p>The forward-/reverse-tonemap trick removes almost all fireflies without the need for a separate white-point parameter.</blockquote><p>Previous work: #9414<h2 id=testing>Testing</h2><p>The <code>reflection_probes.rs</code> example has been updated:<ul><li>The camera starts closer to the spheres so the reflections are easier to see.<li>The GLTF scene is spawned only when the reflection probe mode is active (press Space).<li>The third display mode (toggled with Space) shows the generated cubemap chain.<li>You can change the roughness of the center sphere with the Up/Down keys.</ul><h2 id=render-graph>Render Graph</h2><p>Composed of two nodes and a graph edge:<pre style=color:#61676c;background-color:#fafafa><code><span>Downsampling -> Filtering
</span></code></pre><p>Pass breakdown:<pre style=color:#61676c;background-color:#fafafa><code><span>dowsampling_first_pass -> dowsampling_second_pass ->
</span><span>radiance_map_pass -> irradiance_map_pass
</span></code></pre><img alt=render-graph height=2281 src=https://github.com/user-attachments/assets/3c240688-32f7-447a-9ede-6050b77c0bd1 width=1601><hr><h2 id=showcase>Showcase</h2><img alt=image height=1500 src=https://github.com/user-attachments/assets/56e68dd7-9488-4d35-9bba-7f713a3e2831 width=2564><p>User facing API:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(camera)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(GeneratedEnvironmentMapLight {
</span><span>        environment_map</span><span style=color:#61676ccc>:</span><span> world</span><span style=color:#ed9366>.</span><span style=color:#f07171>load_asset</span><span>(</span><span style=color:#86b300>"environment_maps/pisa_specular_rgb9e5_zstd.ktx2"</span><span>)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>    })</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=computed-environment-maps>Computed Environment Maps</h2><p>To use fully dynamic environment maps, create a new placeholder image handle with <code>Image::new_fill</code>, extract it to the render world. Then dispatch a compute shader, bind the image as a 2d array storage texture. Anything can be rendered to the custom dynamic environment map. This is already demonstrated in PR #19037 with the <code>atmosphere.rs</code> example.<p>We can extend this idea further and run the entire PBR pipeline from the perspective of the light probe, and it is possible to have some form of global illumination or baked lighting information this way, especially if we make use of irradiance volumes for the realtime aspect. This method could very well be extended to bake indirect lighting in the scene. #13840 should make this possible!<h2 id=notes-for-reviewers>Notes for reviewers</h2><p>This PR no longer bundles any large test textures.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>Environment maps are essential for realistic rendering, providing ambient lighting and reflections. Traditionally, Bevy required prefiltered environment maps generated offline. This limitation prevented real-time updates and dynamic environment sources. The existing solution couldn’t handle cases like:<ul><li>Runtime-loaded environment maps<li>Dynamic scenes where environment lighting changes<li>Reflection probes needing real-time updates</ul><p>The challenge was implementing a robust GPU pipeline that could:<ol><li>Efficiently downsample cubemaps with full mip chains<li>Perform high-quality filtering in real-time<li>Integrate with Bevy’s existing rendering architecture<li>Maintain performance across different hardware capabilities</ol><h3 id=the-solution-approach>The Solution Approach</h3><p>The implementation uses a two-stage GPU pipeline:<ol><li><strong>Downsampling</strong>: Single Pass Downsampling (SPD) generates mip chains efficiently<li><strong>Filtering</strong>: Importance sampling creates specular (radiance) and diffuse (irradiance) maps</ol><p>Key engineering decisions:<ul><li>Split downsampling into two passes to handle device limitations<li>Use bounded VNDF sampling for GGX reflections to reduce noise<li>Mirror TAA’s tonemapping workflow to eliminate fireflies<li>Add blue noise textures for improved sample distribution</ul><p>The pipeline dynamically adapts to device capabilities:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> storage_texture_limit </span><span style=color:#ed9366>=</span><span> render_device</span><span style=color:#ed9366>.</span><span style=color:#f07171>limits</span><span>()</span><span style=color:#ed9366>.</span><span>max_storage_textures_per_shader_stage</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> read_write_support </span><span style=color:#ed9366>= </span><span style=color:#abb0b6;font-style:italic>/* check texture format features */</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> combine_bind_group </span><span style=color:#ed9366>=</span><span> storage_texture_limit </span><span style=color:#ed9366>>= </span><span style=color:#ff8f40>12 </span><span style=color:#ed9366>&&</span><span> read_write_support</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=the-implementation>The Implementation</h3><p>The implementation adds several key components:<ol><li><p><strong>New <code>GeneratedEnvironmentMapLight</code> component</strong>:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>GeneratedEnvironmentMapLight </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>environment_map</span><span style=color:#61676ccc>: </span><span>Handle&LTImage>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>intensity</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>rotation</span><span style=color:#61676ccc>:</span><span> Quat,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>affects_lightmapped_mesh_diffuse</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>}
</span></code></pre><li><p><strong>Downsampling shaders</strong>:</p> <ul><li>SPD algorithm processes 6× faster than traditional methods<li>Handles cubemaps up to 8192×8192<li>Uses compute shaders with workgroup optimizations</ul><li><p><strong>Filtering pipeline</strong>:</p> <ul><li>Radiance map uses importance sampling with 32-1024 samples<li>Irradiance map uses cosine-weighted hemisphere sampling<li>Blue noise improves sample distribution</ul></ol><p>The render graph integrates these stages:<pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    Downsampling --> Filtering
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>Key technical aspects:<ol><li><p><strong>Mip chain generation</strong>:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>compute_mip_count</span><span>(</span><span style=color:#ff8f40>size</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u32 </span><span>{
</span><span>    </span><span style=color:#ff8f40>32 </span><span style=color:#ed9366>-</span><span> size</span><span style=color:#ed9366>.</span><span style=color:#f07171>leading_zeros</span><span>()
</span><span>}
</span></code></pre> <p>Calculates mip levels from texture size</p><li><p><strong>Bounded VNDF sampling</strong>:</p> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn sample_visible_ggx(xi: vec2f, roughness: f32, normal: vec3f, view: vec3f) -> vec3f {
</span><span>    // Implementation based on GPUOpen paper
</span><span>}
</span></code></pre> <p>Reduces noise in specular reflections</p><li><p><strong>Adaptive LOD selection</strong>:</p> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn calculate_environment_map_lod(pdf: f32, width: f32, samples: f32) -> f32 {
</span><span>    let omega_s = 1.0 / (samples * pdf);
</span><span>    let omega_p = 4.0 * PI / (6.0 * width * width);
</span><span>    return 0.5 * log2(omega_s / omega_p);
</span><span>}
</span></code></pre> <p>Dynamically selects mip level based on sample density</p></ol><h3 id=the-impact>The Impact</h3><p>These changes enable:<ul><li>Real-time environment map processing<li>Dynamic reflection probes<li>Runtime-generated skyboxes<li>Higher quality reflections with reduced noise<li>Support for cubemaps up to 8192×8192</ul><p>The implementation maintains compatibility across devices by:<ul><li>Providing fallbacks for limited storage textures<li>Supporting both read-write and write-only storage<li>Automatically adapting to subgroup support</ul><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    Downsampling[Downsampling Node] --> Filtering[Filtering Node]
</span><span>    Core3d.EndPrepasses --> Downsampling
</span><span>    Downsampling --> Filtering
</span><span>    Filtering --> Core3d.StartMainPass
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><p><code>crates/bevy_pbr/src/light_probe/generate.rs</code> (+1097/-0)</p> <ul><li>Implements the core environment map generation logic<li>Manages GPU pipelines, bind groups, and resources<li>Handles extraction and preparation of render data</ul><li><p><code>crates/bevy_pbr/src/light_probe/downsample.wgsl</code> (+460/-0)</p> <ul><li>Single Pass Downsampling implementation<li>Efficiently generates mip chains in two compute passes<li>Key function:</ul> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>@compute @workgroup_size(256, 1, 1)
</span><span>fn downsample_first(...) {
</span><span>    // SPD implementation
</span><span>}
</span></code></pre><li><p><code>examples/3d/reflection_probes.rs</code> (+141/-53)</p> <ul><li>Updated example showcasing the new functionality<li>Added roughness control to center sphere:</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>change_sphere_roughness</span><span>(...) {
</span><span>    app_status</span><span style=color:#ed9366>.</span><span>sphere_roughness </span><span style=color:#ed9366>= ...</span><span style=color:#61676ccc>;
</span><span>    material</span><span style=color:#ed9366>.</span><span>perceptual_roughness </span><span style=color:#ed9366>= ...</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><li><p><code>crates/bevy_pbr/src/light_probe/environment_filter.wgsl</code> (+176/-0)</p> <ul><li>Implements environment filtering algorithms<li>Key radiance map function:</ul> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>@compute @workgroup_size(8, 8, 1)
</span><span>fn generate_radiance_map(...) {
</span><span>    // Importance sampling implementation
</span><span>}
</span></code></pre><li><p><code>crates/bevy_pbr/src/render/utils.wgsl</code> (+114/-0)</p> <ul><li>Added utility functions for cubemap processing:</ul> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn sample_cube_dir(uv: vec2f, face: u32) -> vec3f {
</span><span>    // Convert UV/face to direction vector
</span><span>}
</span><span>
</span><span>fn dir_to_cube_uv(dir: vec3f) -> CubeUV {
</span><span>    // Convert direction to UV/face
</span><span>}
</span></code></pre></ol><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://gpuopen.com/download/Bounded_VNDF_Sampling_for_Smith-GGX_Reflections.pdf target=_blank>Bounded VNDF Sampling for Smith-GGX Reflections</a> - Core sampling technique<li><a rel="noopener nofollow noreferrer" href=https://placeholderart.wordpress.com/2015/07/28/implementation-notes-runtime-environment-map-filtering-for-image-based-lighting/ target=_blank>Runtime Environment Map Filtering</a> - Implementation reference<li><a rel="noopener nofollow noreferrer" href=https://bruop.github.io/ibl/ target=_blank>Image Based Lighting</a> - IBL concepts<li><a rel="noopener nofollow noreferrer" href=https://gpuopen.com/fidelityfx-spd/ target=_blank>FidelityFX SPD</a> - Single Pass Downsampling reference<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/blob/main/examples/3d/reflection_probes.rs target=_blank>Bevy Reflection Probes Example</a> - Usage example</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_19076.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>