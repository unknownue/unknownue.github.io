<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20202 Refresh hotpatches using change ticks instead of checking for a event
        
    </title><meta content="#20202 Refresh hotpatches using change ticks instead of checking for a event" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-21</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-20202-zh-cn-20250721>中文</a></div></div><div class=pr-content><h2 id=technical-report-refresh-hotpatches-using-change-ticks>Technical Report: Refresh Hotpatches Using Change Ticks</h2><h3 id=basic-information>Basic Information</h3><ul><li><strong>Title</strong>: Refresh hotpatches using change ticks instead of checking for a event<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20202<li><strong>Author</strong>: laundmo<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, A-Dev-Tools<li><strong>Created</strong>: 2025-07-19T17:22:21Z<li><strong>Merged</strong>: 2025-07-21T06:32:21Z<li><strong>Merged By</strong>: mockersf</ul><h3 id=description>Description</h3><p><strong>Objective</strong><br> Hotpatches were being applied only when a <code>HotPatched</code> event was received, which caused systems in Schedules which only run rarely to miss the event, and their systems to never be hotpatched.<p><strong>Solution</strong><br> Instead of relying on the <code>HotPatched</code> event, I introduced a new empty/unit resource <code>HotPatchChanges</code> and rely on change-detection to apply patches. That means even system run long after the actual hotpatch happened can be updated by to comparing their last run ticks to the <code>HotPatchChanges</code>.<p>Due to this its now also possible to avoid applying patches for Observers each run.<p>I also noticed while reading the code that <code>World::run_system_with</code> didn’t apply patches, so I added the same logic there.<p><strong>Testing</strong><br> I originally noticed this issue because I tried to use states and <code>DespawnOnExitState</code> to re-run setup systems.<p>This is the logic, ripped out of my project and simplified:<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(States</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>enum </span><span style=color:#399ee6>WorkingState </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>default</span><span>]
</span><span>    Running</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"hotpatching"</span><span>)]
</span><span>    Reloading</span><span style=color:#61676ccc>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>hotpatch_setup</span><span>(</span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>    app</span><span style=color:#ed9366>.</span><span>init_state</span><span style=color:#ed9366>::</span><span>&LTWorkingState>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(OnEnter(WorkingState</span><span style=color:#ed9366>::</span><span>Running)</span><span style=color:#61676ccc>,</span><span> hotpatchable_setup)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>            OnEnter(WorkingState</span><span style=color:#ed9366>::</span><span>Reloading)</span><span style=color:#61676ccc>,
</span><span>            |</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>next_state</span><span style=color:#61676ccc>: </span><span>ResMut&LTNextState&LTWorkingState>>| next_state</span><span style=color:#ed9366>.</span><span style=color:#f07171>set</span><span>(WorkingState</span><span style=color:#ed9366>::</span><span>Running)</span><span style=color:#61676ccc>,
</span><span>        )
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>            Update</span><span style=color:#61676ccc>,
</span><span>            (|</span><span style=color:#ff8f40>reload</span><span style=color:#61676ccc>: </span><span>EventReader&LTHotPatched></span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>next_state</span><span style=color:#61676ccc>: </span><span>ResMut&LTNextState&LTWorkingState>>| {
</span><span>                </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>reload</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>() {
</span><span>                    next_state</span><span style=color:#ed9366>.</span><span style=color:#f07171>set</span><span>(WorkingState</span><span style=color:#ed9366>::</span><span>Reloading)</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            })
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>run_if</span><span>(</span><span style=color:#f07171>in_state</span><span>(WorkingState</span><span style=color:#ed9366>::</span><span>Running))</span><span style=color:#61676ccc>,
</span><span>        )</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>hotpatchable_setup</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands) {
</span><span>    commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>        Sprite {
</span><span>            color</span><span style=color:#61676ccc>: </span><span>Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>WHITE</span><span style=color:#61676ccc>,
</span><span>            custom_size</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Vec2</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ONE </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>200.0</span><span>)</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>        }</span><span style=color:#61676ccc>,
</span><span>        DespawnOnExitState(WorkingState</span><span style=color:#ed9366>::</span><span>Running)</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>I didn’t test:<ul><li>cached one-shot systems hotpatching</ul><hr><h3 id=the-story-of-this-pull-request>The Story of This Pull Request</h3><h4 id=the-problem>The Problem</h4><p>The original hotpatching implementation relied on <code>HotPatched</code> events to trigger system updates. This approach had a critical flaw: systems in schedules that run infrequently (like state transition systems) could miss the event entirely. When systems missed the event, they would never refresh their hotpatched pointers, leading to stale implementations being used indefinitely. This was particularly problematic for setup systems that run once during initialization but need to be updated when hotpatching occurs.<p>The author encountered this issue when using <code>DespawnOnExitState</code> to trigger re-runs of setup systems. Their state machine implementation would transition states to force re-execution of setup logic, but without receiving the <code>HotPatched</code> event, these systems never updated their function pointers after hotpatching.<h4 id=the-solution-approach>The Solution Approach</h4><p>The core insight was to leverage Bevy’s existing change detection system instead of relying solely on events. The solution introduces:<ol><li>A new <code>HotPatchChanges</code> resource that acts as a change detection marker<li>Logic to mark this resource as changed when hotpatching occurs<li>System executors that check this resource’s change tick before refreshing hotpatches</ol><p>This approach ensures systems refresh their hotpatched pointers if any hotpatch occurred since their last execution, regardless of whether they processed the event. It also optimizes performance by avoiding unnecessary hotpatch checks when no changes occurred.<h4 id=implementation-details>Implementation Details</h4><p>The changes span multiple parts of the ECS core:<ol><li><p><strong>HotPatchPlugin Modification</strong><br> Updated to initialize <code>HotPatchChanges</code> and set it as changed when hotpatching occurs:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>app</span><span style=color:#ed9366>.</span><span>init_resource</span><span style=color:#ed9366>::</span><span>&LTHotPatchChanges>()
</span><span>   </span><span style=color:#ed9366>.</span><span>add_event</span><span style=color:#ed9366>::</span><span>&LTHotPatched>()
</span><span>   </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>       Last</span><span style=color:#61676ccc>,
</span><span>       </span><span style=color:#fa6e32>move </span><span style=color:#ed9366>|</span><span style=color:#fa6e32>mut</span><span> events</span><span style=color:#61676ccc>: </span><span>EventWriter&LTHotPatched></span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> res</span><span style=color:#61676ccc>: </span><span>ResMut&LTHotPatchChanges></span><span style=color:#ed9366>| </span><span>{
</span><span>           </span><span style=color:#fa6e32>if</span><span> receiver</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_recv</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_ok</span><span>() {
</span><span>               events</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_default</span><span>()</span><span style=color:#61676ccc>;
</span><span>               res</span><span style=color:#ed9366>.</span><span style=color:#f07171>set_changed</span><span>()</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// Critical change
</span><span>           }
</span><span>       }</span><span style=color:#61676ccc>,
</span><span>   )</span><span style=color:#61676ccc>;
</span></code></pre><li><p><strong>Executor Logic Updates</strong><br> All executors (simple, single-threaded, multi-threaded) now check <code>HotPatchChanges</code> instead of event presence. The pattern is consistent:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> hotpatch_tick </span><span style=color:#ed9366>=</span><span> world
</span><span>    </span><span style=color:#ed9366>.</span><span>get_resource_ref</span><span style=color:#ed9366>::</span><span>&LTHotPatchChanges>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>r</span><span>| r</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or_default</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Later in system execution:
</span><span style=color:#fa6e32>if</span><span> hotpatch_tick</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(system</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_last_run</span><span>()</span><span style=color:#61676ccc>,</span><span> world</span><span style=color:#ed9366>.</span><span style=color:#f07171>change_tick</span><span>()) {
</span><span>    system</span><span style=color:#ed9366>.</span><span style=color:#f07171>refresh_hotpatch</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre> <p>This change ensures systems only refresh when necessary based on actual changes.</p><li><p><strong>Observer System Support</strong><br> Observers now use the same change-tick comparison:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if</span><span> world
</span><span>    </span><span style=color:#ed9366>.</span><span>get_resource_ref</span><span style=color:#ed9366>::</span><span>&LTcrate</span><span style=color:#ed9366>::</span><span>HotPatchChanges>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>r</span><span>| r</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(</span><span style=color:#abb0b6;font-style:italic>/* ... */</span><span>))
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>true</span><span>)
</span><span>{
</span><span>    (</span><span style=color:#ed9366>*</span><span>system)</span><span style=color:#ed9366>.</span><span style=color:#f07171>refresh_hotpatch</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><li><p><strong>World::run_system_with Fix</strong><br> Added missing hotpatch support to direct system execution:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    </span><span style=color:#ed9366>.</span><span>get_resource_ref</span><span style=color:#ed9366>::</span><span>&LTHotPatchChanges>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>r</span><span>| r</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or_default</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(system</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_last_run</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>change_tick</span><span>())
</span><span>{
</span><span>    system</span><span style=color:#ed9366>.</span><span style=color:#f07171>refresh_hotpatch</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre></ol><h4 id=technical-insights>Technical Insights</h4><p>Key technical aspects of this solution:<ul><li><strong>Change Detection Efficiency</strong>: Uses Bevy’s existing change tick comparison (<code>Tick::is_newer_than</code>) which is highly optimized<li><strong>Resource Semantics</strong>: <code>HotPatchChanges</code> is a unit struct (zero-sized) that only exists for its change detection metadata<li><strong>Backward Compatibility</strong>: Maintains <code>HotPatched</code> event for systems that need to react to hotpatches<li><strong>Optimized Execution</strong>: Avoids unnecessary pointer refreshes by only updating when changes occurred since last run</ul><h4 id=impact>Impact</h4><p>These changes:<ol><li>Fix hotpatching for infrequently-run systems<li>Reduce unnecessary hotpatch checks in observers<li>Add missing hotpatch support to <code>run_system_with</code><li>Maintain backward compatibility with existing event-based logic<li>Improve performance by eliminating redundant refreshes</ol><p>The solution demonstrates effective use of Bevy’s change detection system to solve event delivery reliability issues.<hr><h3 id=visual-representation>Visual Representation</h3><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[HotPatchPlugin] -->|Sets changed| B[HotPatchChanges]
</span><span>    B -->|Checked by| C[System Executors]
</span><span>    B -->|Checked by| D[Observer Systems]
</span><span>    B -->|Checked by| E[run_system_with]
</span><span>    C -->|Conditionally refreshes| F[Systems]
</span><span>    D -->|Conditionally refreshes| G[Observer Systems]
</span><span>    E -->|Conditionally refreshes| H[Directly Run Systems]
</span></code></pre><hr><h3 id=key-files-changed>Key Files Changed</h3><ol><li><p><strong>crates/bevy_app/src/hotpatch.rs</strong> (+16/-10)<br> Modified the hotpatch plugin to update <code>HotPatchChanges</code> resource:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>app</span><span style=color:#ed9366>.</span><span>add_event</span><span style=color:#ed9366>::</span><span>&LTHotPatched>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>    Last</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#fa6e32>move </span><span style=color:#ed9366>|</span><span style=color:#fa6e32>mut</span><span> events</span><span style=color:#61676ccc>: </span><span>EventWriter&LTHotPatched></span><span style=color:#ed9366>| </span><span>{
</span><span>        </span><span style=color:#fa6e32>if</span><span> receiver</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_recv</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_ok</span><span>() {
</span><span>            events</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_default</span><span>()</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>app</span><span style=color:#ed9366>.</span><span>init_resource</span><span style=color:#ed9366>::</span><span>&LTHotPatchChanges>()
</span><span>    </span><span style=color:#ed9366>.</span><span>add_event</span><span style=color:#ed9366>::</span><span>&LTHotPatched>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>        Last</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#fa6e32>move </span><span style=color:#ed9366>|</span><span style=color:#fa6e32>mut</span><span> events</span><span style=color:#61676ccc>: </span><span>EventWriter&LTHotPatched></span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> res</span><span style=color:#61676ccc>: </span><span>ResMut&LTHotPatchChanges></span><span style=color:#ed9366>| </span><span>{
</span><span>            </span><span style=color:#fa6e32>if</span><span> receiver</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_recv</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_ok</span><span>() {
</span><span>                events</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_default</span><span>()</span><span style=color:#61676ccc>;
</span><span>                res</span><span style=color:#ed9366>.</span><span style=color:#f07171>set_changed</span><span>()</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// Key addition
</span><span>            }
</span><span>        }</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span></code></pre><li><p><strong>crates/bevy_ecs/src/lib.rs</strong> (+13/-1)<br> Added the new resource definition:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"hotpatching"</span><span>)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(resource::Resource</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>HotPatchChanges</span><span style=color:#61676ccc>;
</span></code></pre><li><p><strong>crates/bevy_ecs/src/schedule/executor/multi_threaded.rs</strong> (+9/-6)<br> Updated executor logic to use change ticks:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> should_update_hotpatch </span><span style=color:#ed9366>= !</span><span>context
</span><span>    </span><span style=color:#ed9366>.</span><span>world_cell
</span><span>    </span><span style=color:#ed9366>.</span><span>get_resource</span><span style=color:#ed9366>::</span><span>&LTEvents&LTHotPatched>>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(Events</span><span style=color:#ed9366>::</span><span>is_empty)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>true</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> hotpatch_tick </span><span style=color:#ed9366>=</span><span> context
</span><span>    </span><span style=color:#ed9366>.</span><span>world_cell
</span><span>    </span><span style=color:#ed9366>.</span><span>get_resource_ref</span><span style=color:#ed9366>::</span><span>&LTHotPatchChanges>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>r</span><span>| r</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or_default</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Usage:
</span><span style=color:#fa6e32>if</span><span> hotpatch_tick</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(</span><span style=color:#abb0b6;font-style:italic>/* ... */</span><span>) {
</span><span>    system</span><span style=color:#ed9366>.</span><span style=color:#f07171>refresh_hotpatch</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><li><p><strong>crates/bevy_ecs/src/system/system_registry.rs</strong><br> Fixed <code>World::run_system_with</code>:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Added:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"hotpatching"</span><span>)]
</span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    </span><span style=color:#ed9366>.</span><span>get_resource_ref</span><span style=color:#ed9366>::</span><span>&LTHotPatchChanges>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>r</span><span>| r</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_changed</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or_default</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>is_newer_than</span><span>(system</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_last_run</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>change_tick</span><span>())
</span><span>{
</span><span>    system</span><span style=color:#ed9366>.</span><span style=color:#f07171>refresh_hotpatch</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre></ol><hr><h3 id=further-reading>Further Reading</h3><ol><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/change-detection/ target=_blank>Bevy Change Detection Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/scheduling/ target=_blank>ECS System Execution Model</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/resources/ target=_blank>Resource Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://fasterthanli.me/articles/hot-reloading-rust target=_blank>Hot Reloading in Rust</a></ol><p>This solution demonstrates effective use of change detection for system management and provides a robust pattern for handling infrastructure-level events in ECS architectures.</div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_20202.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>