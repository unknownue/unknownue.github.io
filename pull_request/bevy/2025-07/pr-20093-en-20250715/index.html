<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20093 Improved UI scrolling support and bug fixes
        
    </title><meta content="#20093 Improved UI scrolling support and bug fixes" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-15</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-20093-zh-cn-20250715>中文</a></div></div><div class=pr-content><h1 id=improved-ui-scrolling-support-and-bug-fixes>Improved UI scrolling support and bug fixes</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Improved UI scrolling support and bug fixes<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20093<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, C-Feature, A-UI, S-Ready-For-Final-Review, M-Needs-Migration-Guide, M-Needs-Release-Note<li><strong>Created</strong>: 2025-07-11T20:47:18Z<li><strong>Merged</strong>: 2025-07-15T17:53:56Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description>Description</h2><h1 id=objective>Objective</h1><h4 id=goals>Goals</h4><ul><li>Stop layout updates from overwriting <code>ScrollPosition</code>.<li>Make <code>ScrollPosition</code> respect scale factor.<li>Automatically allocate space for a scrollbar on an axis when <code>OverflowAxis::Scroll</code> is set.</ul><h4 id=non-goals>Non-Goals</h4><ul><li>Overflow-auto support (I was certain Taffy had this already, but apparently I was hallucinating).<li>Implement any sort of scrollbar widgets.<li>Stability (not needed because no overflow-auto support).<li>Maybe in the future we could make a <code>ScrollbarWidth</code> enum to more closely match the CSS API with its auto/narrow/none options. For now <code>scrollbar_width</code> is just an <code>f32</code> which matches Taffy’s API.</ul><h2 id=solution>Solution</h2><ul><li>Layout updates no longer overwrite <code>ScrollPosition</code>’s value.<li>Added the field <code>scrollbar_width: f32</code> to <code>Node</code>. This is sent to <code>Taffy</code> which will automatically allocate space for scrollbars with this width in the layout as needed.<li>Added the fields <code>scrollbar_width: f32</code> and <code>scroll_position: Vec2</code> to <code>ComputedNode</code>. These are updated automatically during layout.<li><code>ScrollPosition</code> now respects scale factor.<li><code>ScrollPosition</code> is no longer automatically added to every UI node entity by <code>ui_layout_system</code>. If every node needs it, it should just be required by (or be a field on) <code>Node</code>. Not sure if that’s necessary or not.</ul><h2 id=testing>Testing</h2><p>For testing you can look at:<ul><li>The <code>scrollbars</code> example, which should work as before.<li>The new example <code>drag_to_scroll</code>.<li>The <code>scroll</code> example which automatically allocates space for scrollbars on the left hand scrolling list. Did not implement actual scrollbars so you’ll just see a gap atm.</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>The Bevy UI system had several limitations in its scrolling implementation that needed addressing. First, layout updates were overwriting <code>ScrollPosition</code> values, causing unexpected behavior when users tried to programmatically control scrolling. Second, <code>ScrollPosition</code> didn’t respect UI scale factors, leading to inconsistent behavior across different display configurations. Finally, there was no automatic allocation of space for scrollbars when <code>OverflowAxis::Scroll</code> was set, causing content to overlap with scrollbars.<h3 id=the-solution-approach>The Solution Approach</h3><p>The solution involved three key changes:<ol><li>Preventing layout updates from overwriting <code>ScrollPosition</code><li>Making <code>ScrollPosition</code> respect scale factors<li>Adding automatic scrollbar space allocation</ol><p>The approach focused on enhancing existing systems rather than complete rewrites. For scrollbar space allocation, we added a <code>scrollbar_width</code> property to <code>Node</code> that gets passed to Taffy (the layout library). This allows Taffy to automatically reserve space when overflow is set to scroll. The team considered but deferred overflow-auto support since Taffy lacked this capability.<h3 id=the-implementation>The Implementation</h3><p>The core changes occurred in the layout system (<code>ui_layout_system</code>). Previously, this system used commands to update <code>ScrollPosition</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before in crates/bevy_ui/src/layout/mod.rs
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>ui_layout_system</span><span>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,  </span><span style=color:#abb0b6;font-style:italic>// Commands were needed
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>if</span><span> clamped_scroll_position </span><span style=color:#ed9366>!=</span><span> scroll_position {
</span><span>        commands
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(ScrollPosition(clamped_scroll_position))</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The updated implementation removes command usage and instead stores scroll position directly in <code>ComputedNode</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// After in crates/bevy_ui/src/layout/mod.rs
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>ui_layout_system</span><span>(
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// No commands parameter
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    node</span><span style=color:#ed9366>.</span><span style=color:#f07171>bypass_change_detection</span><span>()</span><span style=color:#ed9366>.</span><span>scroll_position </span><span style=color:#ed9366>=</span><span> physical_scroll_position</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>Scale factor handling was improved by applying inverse scaling to scroll positions:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// crates/bevy_ui/src/layout/mod.rs
</span><span style=color:#fa6e32>let</span><span> scroll_position</span><span style=color:#61676ccc>:</span><span> Vec2 </span><span style=color:#ed9366>=</span><span> maybe_scroll_position
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>scroll_pos</span><span>| {
</span><span>        Vec2</span><span style=color:#ed9366>::</span><span>new(
</span><span>            </span><span style=color:#fa6e32>if</span><span> style</span><span style=color:#ed9366>.</span><span>overflow</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>== </span><span>OverflowAxis</span><span style=color:#ed9366>::</span><span>Scroll {
</span><span>                scroll_pos</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>*</span><span> inverse_target_scale_factor</span><span style=color:#ed9366>.</span><span style=color:#f07171>recip</span><span>()
</span><span>            } </span><span style=color:#fa6e32>else </span><span>{
</span><span>                </span><span style=color:#ff8f40>0.0
</span><span>            }</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// Similar for Y axis
</span><span>        )
</span><span>    })
</span></code></pre><p>For scrollbar allocation, we added a new <code>scrollbar_width</code> field to <code>Node</code> that gets passed to Taffy:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// crates/bevy_ui/src/layout/convert.rs
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>from_node</span><span>(</span><span style=color:#ff8f40>node</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Node, </span><span style=color:#ff8f40>context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>LayoutContext, </span><span style=color:#ff8f40>ignore_border</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>) </span><span style=color:#61676ccc>-> </span><span>taffy</span><span style=color:#ed9366>::</span><span>Style {
</span><span>    taffy</span><span style=color:#ed9366>::</span><span>Style {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>        scrollbar_width</span><span style=color:#61676ccc>:</span><span> node</span><span style=color:#ed9366>.</span><span>scrollbar_width </span><span style=color:#ed9366>*</span><span> context</span><span style=color:#ed9366>.</span><span>scale_factor</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>The key insight was separating logical scroll position (set by users) from physical scroll position (used in layout). The <code>ScrollPosition</code> component now stores values in logical pixels while <code>ComputedNode::scroll_position</code> stores physical pixels. This separation maintains user expectations while allowing proper layout calculations.<p>The clipping system was updated to account for scrollbar space:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// crates/bevy_ui/src/update.rs
</span><span>clip_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>-=</span><span> clip_inset</span><span style=color:#ed9366>.</span><span>right </span><span style=color:#ed9366>+</span><span> computed_node</span><span style=color:#ed9366>.</span><span>scrollbar_size</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>;
</span><span>clip_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>-=</span><span> clip_inset</span><span style=color:#ed9366>.</span><span>bottom </span><span style=color:#ed9366>+</span><span> computed_node</span><span style=color:#ed9366>.</span><span>scrollbar_size</span><span style=color:#ed9366>.</span><span>y</span><span style=color:#61676ccc>;
</span></code></pre><p>This prevents content from appearing under scrollbars. The <code>ComputedNode</code> struct was extended to store scrollbar dimensions and scroll position:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// crates/bevy_ui/src/ui_node.rs
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ComputedNode </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>pub </span><span>scrollbar_size</span><span style=color:#61676ccc>:</span><span> Vec2,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>scroll_position</span><span style=color:#61676ccc>:</span><span> Vec2,
</span><span>}
</span></code></pre><h3 id=the-impact>The Impact</h3><p>These changes significantly improve UI scrolling reliability and flexibility:<ol><li><code>ScrollPosition</code> values persist across layout updates<li>Scrolling behavior is consistent across different scale factors<li>Developers can reserve space for scrollbars by setting <code>scrollbar_width</code><li>The new <code>drag_to_scroll</code> example demonstrates these capabilities</ol><p>The changes require minor migration: <code>ScrollPosition</code> now uses logical pixels and isn’t overwritten during layout. The computed scroll position is now stored in <code>ComputedNode::scroll_position</code>.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Node.scrollbar_width] --> B(Taffy Layout)
</span><span>    B --> C[ComputedNode.scrollbar_size]
</span><span>    C --> D[Layout Clipping]
</span><span>    E[ScrollPosition] --> F[Physical Scroll Calculation]
</span><span>    F --> G[ComputedNode.scroll_position]
</span><span>    G --> H[Node Transformation]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=examples-ui-drag-to-scroll-rs-120-0><code>examples/ui/drag_to_scroll.rs</code> (+120/-0)</h3><p>Added a new example demonstrating scrolling with scale factor and drag interactions. The example creates a grid of colored tiles that can be scrolled by dragging.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>commands
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>        Node {
</span><span>            width</span><span style=color:#61676ccc>: </span><span>Val</span><span style=color:#ed9366>::</span><span>Percent(</span><span style=color:#ff8f40>100.</span><span>)</span><span style=color:#61676ccc>,
</span><span>            height</span><span style=color:#61676ccc>: </span><span>Val</span><span style=color:#ed9366>::</span><span>Percent(</span><span style=color:#ff8f40>100.</span><span>)</span><span style=color:#61676ccc>,
</span><span>            overflow</span><span style=color:#61676ccc>: </span><span>Overflow</span><span style=color:#ed9366>::</span><span>scroll()</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>..</span><span style=color:#55b4d4;font-style:italic>Default</span><span style=color:#ed9366>::</span><span>default()
</span><span>        }</span><span style=color:#61676ccc>,
</span><span>        ScrollPosition(Vec2</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ZERO</span><span>)</span><span style=color:#61676ccc>,
</span><span>        ScrollableNode</span><span style=color:#61676ccc>,
</span><span>        ScrollStart(Vec2</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ZERO</span><span>)</span><span style=color:#61676ccc>,
</span><span>    ))
</span></code></pre><h3 id=crates-bevy-ui-src-layout-mod-rs-11-19><code>crates/bevy_ui/src/layout/mod.rs</code> (+11/-19)</h3><p>Refactored the layout system to handle scroll position without commands and improved scale factor handling.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>if</span><span> clamped_scroll_position </span><span style=color:#ed9366>!=</span><span> scroll_position {
</span><span>    commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(ScrollPosition(clamped_scroll_position))</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> physical_scroll_position </span><span style=color:#ed9366>=</span><span> clamped_scroll_position</span><span style=color:#ed9366>.</span><span style=color:#f07171>floor</span><span>()</span><span style=color:#61676ccc>;
</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>bypass_change_detection</span><span>()</span><span style=color:#ed9366>.</span><span>scroll_position </span><span style=color:#ed9366>=</span><span> physical_scroll_position</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ui-src-ui-node-rs-14-0><code>crates/bevy_ui/src/ui_node.rs</code> (+14/-0)</h3><p>Added new fields to <code>Node</code> and <code>ComputedNode</code> to support scrollbar allocation and scroll position storage.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Node </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>pub </span><span>scrollbar_width</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ComputedNode </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>pub </span><span>scrollbar_size</span><span style=color:#61676ccc>:</span><span> Vec2,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>scroll_position</span><span style=color:#61676ccc>:</span><span> Vec2,
</span><span>}
</span></code></pre><h3 id=cargo-toml-11-0><code>Cargo.toml</code> (+11/-0)</h3><p>Registered the new <code>drag_to_scroll</code> example.<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[[</span><span style=color:#399ee6>example</span><span>]]
</span><span style=color:#399ee6>name </span><span>= </span><span style=color:#86b300>"drag_to_scroll"
</span><span style=color:#399ee6>path </span><span>= </span><span style=color:#86b300>"examples/ui/drag_to_scroll.rs"
</span><span style=color:#399ee6>doc-scrape-examples </span><span>= </span><span style=color:#ff8f40>true
</span></code></pre><h3 id=release-content-release-notes-automatic-scrollbar-space-allocation-md-7-0><code>release-content/release-notes/automatic_scrollbar_space_allocation.md</code> (+7/-0)</h3><p>Added release notes explaining the new scrollbar allocation feature.<pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span style=color:#abb0b6;background-color:#61676c10;font-weight:700>---
</span><span>title: Automatically allocate space for scrollbars
</span><span>authors: ["@ickshonpe"]
</span><span>pull_requests: [20093]
</span><span style=color:#fa6e32;font-weight:700>---
</span><span>
</span><span style=color:#ed9366;background-color:#61676c10>`Node`</span><span> has a new field </span><span style=color:#ed9366;background-color:#61676c10>`scrollbar_width`</span><span>. If </span><span style=color:#ed9366;background-color:#61676c10>`OverflowAxis::Scroll`</span><span> is set for a UI Node's axis, a space for a scrollbars of width </span><span style=color:#ed9366;background-color:#61676c10>`scrollbar_width`</span><span> will automatically be left in the layout.
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://github.com/DioxusLabs/taffy target=_blank>Taffy Layout Documentation</a> - The layout library used by Bevy UI<li><a rel="noopener nofollow noreferrer" href=https://developer.mozilla.org/en-US/docs/Web/CSS/overflow target=_blank>CSS Overflow Property</a> - Web standard that inspired Bevy’s overflow implementation<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/features/ui/ target=_blank>Bevy UI System Overview</a> - Official Bevy documentation on UI systems</ol><h1 id=full-code-diff>Full Code Diff</h1><details><summary>View full diff</summary> <pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/Cargo.toml b/Cargo.toml
</span><span>index f047040bdc9f7..b1cfe08c05054 100644
</span><span style=color:#c594c5>--- a/Cargo.toml
</span><span style=color:#c594c5>+++ b/Cargo.toml
</span><span style=color:#c594c5>@@ -3832,6 +3832,17 @@ </span><span style=color:#399ee6>description = "Demonstrates resizing and responding to resizing a window"
</span><span> category = "Window"
</span><span> wasm = true
</span><span> 
</span><span style=color:#86b300>+[[example]]
</span><span style=color:#86b300>+name = "drag_to_scroll"
</span><span style=color:#86b300>+path = "examples/ui/drag_to_scroll.rs"
</span><span style=color:#86b300>+doc-scrape-examples = true
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+[package.metadata.example.drag_to_scroll]
</span><span style=color:#86b300>+name = "Drag to Scroll"
</span><span style=color:#86b300>+description = "This example tests scale factor, dragging and scrolling"
</span><span style=color:#86b300>+category = "UI (User Interface)"
</span><span style=color:#86b300>+wasm = true
</span><span style=color:#86b300>+
</span><span> [[example]]
</span><span> name = "ui_material"
</span><span> path = "examples/ui/ui_material.rs"
</span><span>diff --git a/crates/bevy_ui/src/layout/convert.rs b/crates/bevy_ui/src/layout/convert.rs
</span><span>index 53c03113b9b60..161fc12751650 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ui/src/layout/convert.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ui/src/layout/convert.rs
</span><span style=color:#c594c5>@@ -73,7 +73,7 @@ </span><span style=color:#399ee6>pub fn from_node(node: &Node, context: &LayoutContext, ignore_border: bool) -> t
</span><span>             x: node.overflow.x.into(),
</span><span>             y: node.overflow.y.into(),
</span><span>         },
</span><span style=color:#f07171>-        scrollbar_width: 0.0,
</span><span style=color:#86b300>+        scrollbar_width: node.scrollbar_width * context.scale_factor,
</span><span>         position: node.position_type.into(),
</span><span>         flex_direction: node.flex_direction.into(),
</span><span>         flex_wrap: node.flex_wrap.into(),
</span><span style=color:#c594c5>@@ -503,6 +503,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span>             aspect_ratio: None,
</span><span>             overflow: crate::Overflow::clip(),
</span><span>             overflow_clip_margin: crate::OverflowClipMargin::default(),
</span><span style=color:#86b300>+            scrollbar_width: 7.,
</span><span>             column_gap: Val::ZERO,
</span><span>             row_gap: Val::ZERO,
</span><span>             grid_auto_flow: GridAutoFlow::ColumnDense,
</span><span style=color:#c594c5>@@ -624,6 +625,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         assert_eq!(taffy_style.max_size.width, taffy::style::Dimension::Auto);
</span><span>         assert_eq!(taffy_style.max_size.height, taffy::style::Dimension::ZERO);
</span><span>         assert_eq!(taffy_style.aspect_ratio, None);
</span><span style=color:#86b300>+        assert_eq!(taffy_style.scrollbar_width, 7.);
</span><span>         assert_eq!(taffy_style.gap.width, taffy::style::LengthPercentage::ZERO);
</span><span>         assert_eq!(taffy_style.gap.height, taffy::style::LengthPercentage::ZERO);
</span><span>         assert_eq!(
</span><span>diff --git a/crates/bevy_ui/src/layout/mod.rs b/crates/bevy_ui/src/layout/mod.rs
</span><span>index 655ec17e90ac6..adbfb3d09bf52 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ui/src/layout/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ui/src/layout/mod.rs
</span><span style=color:#c594c5>@@ -10,7 +10,7 @@ </span><span style=color:#399ee6>use bevy_ecs::{
</span><span>     hierarchy::{ChildOf, Children},
</span><span>     lifecycle::RemovedComponents,
</span><span>     query::With,
</span><span style=color:#f07171>-    system::{Commands, Query, ResMut},
</span><span style=color:#86b300>+    system::{Query, ResMut},
</span><span>     world::Ref,
</span><span> };
</span><span> 
</span><span style=color:#c594c5>@@ -71,7 +71,6 @@ </span><span style=color:#399ee6>pub enum LayoutError {
</span><span> 
</span><span> /// Updates the UI's layout tree, computes the new layout geometry and then updates the sizes and transforms of all the UI nodes.
</span><span> pub fn ui_layout_system(
</span><span style=color:#f07171>-    mut commands: Commands,
</span><span>     mut ui_surface: ResMut&LTUiSurface>,
</span><span>     ui_root_node_query: UiRootNodes,
</span><span>     mut node_query: Query<(
</span><span style=color:#c594c5>@@ -172,7 +171,6 @@ </span><span style=color:#399ee6>with UI components as a child of an entity without UI components, your UI layout
</span><span>         );
</span><span> 
</span><span>         update_uinode_geometry_recursive(
</span><span style=color:#f07171>-            &mut commands,
</span><span>             ui_root_entity,
</span><span>             &mut ui_surface,
</span><span>             true,
</span><span style=color:#c594c5>@@ -188,7 +186,6 @@ </span><span style=color:#399ee6>with UI components as a child of an entity without UI components, your UI layout
</span><span> 
</span><span>     // Returns the combined bounding box of the node and any of its overflowing children.
</span><span>     fn update_uinode_geometry_recursive(
</span><span style=color:#f07171>-        commands: &mut Commands,
</span><span>         entity: Entity,
</span><span>         ui_surface: &mut UiSurface,
</span><span>         inherited_use_rounding: bool,
</span><span style=color:#c594c5>@@ -307,16 +304,19 @@ </span><span style=color:#399ee6>with UI components as a child of an entity without UI components, your UI layout
</span><span>                     .max(0.);
</span><span>             }
</span><span> 
</span><span style=color:#86b300>+            node.bypass_change_detection().scrollbar_size =
</span><span style=color:#86b300>+                Vec2::new(layout.scrollbar_size.width, layout.scrollbar_size.height);
</span><span style=color:#86b300>+
</span><span>             let scroll_position: Vec2 = maybe_scroll_position
</span><span>                 .map(|scroll_pos| {
</span><span>                     Vec2::new(
</span><span>                         if style.overflow.x == OverflowAxis::Scroll {
</span><span style=color:#f07171>-                            scroll_pos.x
</span><span style=color:#86b300>+                            scroll_pos.x * inverse_target_scale_factor.recip()
</span><span>                         } else {
</span><span>                             0.0
</span><span>                         },
</span><span>                         if style.overflow.y == OverflowAxis::Scroll {
</span><span style=color:#f07171>-                            scroll_pos.y
</span><span style=color:#86b300>+                            scroll_pos.y * inverse_target_scale_factor.recip()
</span><span>                         } else {
</span><span>                             0.0
</span><span>                         },
</span><span style=color:#c594c5>@@ -324,24 +324,16 @@ </span><span style=color:#399ee6>with UI components as a child of an entity without UI components, your UI layout
</span><span>                 })
</span><span>                 .unwrap_or_default();
</span><span> 
</span><span style=color:#f07171>-            let max_possible_offset = (content_size - layout_size).max(Vec2::ZERO);
</span><span style=color:#f07171>-            let clamped_scroll_position = scroll_position.clamp(
</span><span style=color:#f07171>-                Vec2::ZERO,
</span><span style=color:#f07171>-                max_possible_offset * inverse_target_scale_factor,
</span><span style=color:#f07171>-            );
</span><span style=color:#86b300>+            let max_possible_offset =
</span><span style=color:#86b300>+                (content_size - layout_size + node.scrollbar_size).max(Vec2::ZERO);
</span><span style=color:#86b300>+            let clamped_scroll_position = scroll_position.clamp(Vec2::ZERO, max_possible_offset);
</span><span> 
</span><span style=color:#f07171>-            if clamped_scroll_position != scroll_position {
</span><span style=color:#f07171>-                commands
</span><span style=color:#f07171>-                    .entity(entity)
</span><span style=color:#f07171>-                    .insert(ScrollPosition(clamped_scroll_position));
</span><span style=color:#f07171>-            }
</span><span style=color:#86b300>+            let physical_scroll_position = clamped_scroll_position.floor();
</span><span> 
</span><span style=color:#f07171>-            let physical_scroll_position =
</span><span style=color:#f07171>-                (clamped_scroll_position / inverse_target_scale_factor).round();
</span><span style=color:#86b300>+            node.bypass_change_detection().scroll_position = physical_scroll_position;
</span><span> 
</span><span>             for child_uinode in ui_children.iter_ui_children(entity) {
</span><span>                 update_uinode_geometry_recursive(
</span><span style=color:#f07171>-                    commands,
</span><span>                     child_uinode,
</span><span>                     ui_surface,
</span><span>                     use_rounding,
</span><span>diff --git a/crates/bevy_ui/src/ui_node.rs b/crates/bevy_ui/src/ui_node.rs
</span><span>index 7aed57931cb60..bda1b48bc4741 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ui/src/ui_node.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ui/src/ui_node.rs
</span><span style=color:#c594c5>@@ -42,6 +42,14 @@ </span><span style=color:#399ee6>pub struct ComputedNode {
</span><span>     ///
</span><span>     /// Automatically calculated by [`super::layout::ui_layout_system`].
</span><span>     pub content_size: Vec2,
</span><span style=color:#86b300>+    /// Space allocated for scrollbars.
</span><span style=color:#86b300>+    ///
</span><span style=color:#86b300>+    /// Automatically calculated by [`super::layout::ui_layout_system`].
</span><span style=color:#86b300>+    pub scrollbar_size: Vec2,
</span><span style=color:#86b300>+    /// Resolved offset of scrolled content
</span><span style=color:#86b300>+    ///
</span><span style=color:#86b300>+    /// Automatically calculated by [`super::layout::ui_layout_system`].
</span><span style=color:#86b300>+    pub scroll_position: Vec2,
</span><span>     /// The width of this node's outline.
</span><span>     /// If this value is `Auto`, negative or `0.` then no outline will be rendered.
</span><span>     /// Outline updates bypass change detection.
</span><span style=color:#c594c5>@@ -305,6 +313,8 @@ </span><span style=color:#399ee6>impl ComputedNode {
</span><span>         stack_index: 0,
</span><span>         size: Vec2::ZERO,
</span><span>         content_size: Vec2::ZERO,
</span><span style=color:#86b300>+        scrollbar_size: Vec2::ZERO,
</span><span style=color:#86b300>+        scroll_position: Vec2::ZERO,
</span><span>         outline_width: 0.,
</span><span>         outline_offset: 0.,
</span><span>         unrounded_size: Vec2::ZERO,
</span><span style=color:#c594c5>@@ -419,6 +429,9 @@ </span><span style=color:#399ee6>pub struct Node {
</span><span>     /// &LThttps://developer.mozilla.org/en-US/docs/Web/CSS/overflow>
</span><span>     pub overflow: Overflow,
</span><span> 
</span><span style=color:#86b300>+    /// How much space in logical pixels should be reserved for scrollbars when overflow is set to scroll or auto on an axis.
</span><span style=color:#86b300>+    pub scrollbar_width: f32,
</span><span style=color:#86b300>+
</span><span>     /// How the bounds of clipped content should be determined
</span><span>     ///
</span><span>     /// &LThttps://developer.mozilla.org/en-US/docs/Web/CSS/overflow-clip-margin>
</span><span style=color:#c594c5>@@ -703,6 +716,7 @@ </span><span style=color:#399ee6>impl Node {
</span><span>         aspect_ratio: None,
</span><span>         overflow: Overflow::DEFAULT,
</span><span>         overflow_clip_margin: OverflowClipMargin::DEFAULT,
</span><span style=color:#86b300>+        scrollbar_width: 0.,
</span><span>         row_gap: Val::ZERO,
</span><span>         column_gap: Val::ZERO,
</span><span>         grid_auto_flow: GridAutoFlow::DEFAULT,
</span><span>diff --git a/crates/bevy_ui/src/update.rs b/crates/bevy_ui/src/update.rs
</span><span>index f8699fb7fca44..313b4af192f46 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ui/src/update.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ui/src/update.rs
</span><span style=color:#c594c5>@@ -112,8 +112,8 @@ </span><span style=color:#399ee6>fn update_clipping(
</span><span> 
</span><span>         clip_rect.min.x += clip_inset.left;
</span><span>         clip_rect.min.y += clip_inset.top;
</span><span style=color:#f07171>-        clip_rect.max.x -= clip_inset.right;
</span><span style=color:#f07171>-        clip_rect.max.y -= clip_inset.bottom;
</span><span style=color:#86b300>+        clip_rect.max.x -= clip_inset.right + computed_node.scrollbar_size.x;
</span><span style=color:#86b300>+        clip_rect.max.y -= clip_inset.bottom + computed_node.scrollbar_size.y;
</span><span> 
</span><span>         clip_rect = clip_rect
</span><span>             .inflate(node.overflow_clip_margin.margin.max(0.) / computed_node.inverse_scale_factor);
</span><span>diff --git a/examples/README.md b/examples/README.md
</span><span>index 993299dfc6699..aabe0199054b2 100644
</span><span style=color:#c594c5>--- a/examples/README.md
</span><span style=color:#c594c5>+++ b/examples/README.md
</span><span style=color:#c594c5>@@ -553,6 +553,7 @@ </span><span style=color:#399ee6>Example | Description
</span><span> [Core Widgets (w/Observers)](../examples/ui/core_widgets_observers.rs) | Demonstrates use of core (headless) widgets in Bevy UI, with Observers
</span><span> [Directional Navigation](../examples/ui/directional_navigation.rs) | Demonstration of Directional Navigation between UI elements
</span><span> [Display and Visibility](../examples/ui/display_and_visibility.rs) | Demonstrates how Display and Visibility work in the UI.
</span><span style=color:#86b300>+[Drag to Scroll](../examples/ui/drag_to_scroll.rs) | This example tests scale factor, dragging and scrolling
</span><span> [Flex Layout](../examples/ui/flex_layout.rs) | Demonstrates how the AlignItems and JustifyContent properties can be composed to layout nodes and position text
</span><span> [Font Atlas Debug](../examples/ui/font_atlas_debug.rs) | Illustrates how FontAtlases are populated (used to optimize text rendering internally)
</span><span> [Ghost Nodes](../examples/ui/ghost_nodes.rs) | Demonstrates the use of Ghost Nodes to skip entities in the UI layout hierarchy
</span><span>diff --git a/examples/ui/drag_to_scroll.rs b/examples/ui/drag_to_scroll.rs
</span><span>new file mode 100644
</span><span>index 0000000000000..b66d85c80056c
</span><span style=color:#c594c5>--- /dev/null
</span><span style=color:#c594c5>+++ b/examples/ui/drag_to_scroll.rs
</span><span style=color:#c594c5>@@ -0,0 +1,120 @@
</span><span style=color:#86b300>+//! This example tests scale factor, dragging and scrolling
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+use bevy::color::palettes::css::RED;
</span><span style=color:#86b300>+use bevy::prelude::*;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#[derive(Component)]
</span><span style=color:#86b300>+struct DragNode;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#[derive(Component)]
</span><span style=color:#86b300>+struct ScrollableNode;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#[derive(Component)]
</span><span style=color:#86b300>+struct TileColor(Color);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn main() {
</span><span style=color:#86b300>+    App::new()
</span><span style=color:#86b300>+        .add_plugins(DefaultPlugins)
</span><span style=color:#86b300>+        .add_systems(Startup, setup)
</span><span style=color:#86b300>+        .run();
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#[derive(Component)]
</span><span style=color:#86b300>+struct ScrollStart(Vec2);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn setup(mut commands: Commands) {
</span><span style=color:#86b300>+    let w = 60;
</span><span style=color:#86b300>+    let h = 40;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    commands.spawn(Camera2d);
</span><span style=color:#86b300>+    commands.insert_resource(UiScale(0.5));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    commands
</span><span style=color:#86b300>+        .spawn((
</span><span style=color:#86b300>+            Node {
</span><span style=color:#86b300>+                width: Val::Percent(100.),
</span><span style=color:#86b300>+                height: Val::Percent(100.),
</span><span style=color:#86b300>+                overflow: Overflow::scroll(),
</span><span style=color:#86b300>+                ..Default::default()
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+            ScrollPosition(Vec2::ZERO),
</span><span style=color:#86b300>+            ScrollableNode,
</span><span style=color:#86b300>+            ScrollStart(Vec2::ZERO),
</span><span style=color:#86b300>+        ))
</span><span style=color:#86b300>+        .observe(
</span><span style=color:#86b300>+            |
</span><span style=color:#86b300>+            drag: On&LTPointer&LTDrag>>,
</span><span style=color:#86b300>+             ui_scale: Res&LTUiScale>,
</span><span style=color:#86b300>+             mut scroll_position_query: Query<(
</span><span style=color:#86b300>+                &mut ScrollPosition,
</span><span style=color:#86b300>+                &ScrollStart),
</span><span style=color:#86b300>+                With&LTScrollableNode>,
</span><span style=color:#86b300>+             >| {
</span><span style=color:#86b300>+                if let Ok((mut scroll_position, start)) = scroll_position_query.single_mut() {
</span><span style=color:#86b300>+                    scroll_position.0 = (start.0 - drag.distance / ui_scale.0).max(Vec2::ZERO);
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        )
</span><span style=color:#86b300>+        .observe(
</span><span style=color:#86b300>+            |
</span><span style=color:#86b300>+            on: On&LTPointer&LTDragStart>>,
</span><span style=color:#86b300>+             mut scroll_position_query: Query<(
</span><span style=color:#86b300>+                &ComputedNode,
</span><span style=color:#86b300>+                &mut ScrollStart),
</span><span style=color:#86b300>+                With&LTScrollableNode>,
</span><span style=color:#86b300>+            >| {
</span><span style=color:#86b300>+                if on.target() != on.original_target() {
</span><span style=color:#86b300>+                    return;
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+                if let Ok((computed_node, mut start)) = scroll_position_query.single_mut() {
</span><span style=color:#86b300>+                    start.0 = computed_node.scroll_position * computed_node.inverse_scale_factor;
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        )
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        .with_children(|commands| {
</span><span style=color:#86b300>+            commands
</span><span style=color:#86b300>+            .spawn(Node {
</span><span style=color:#86b300>+                display: Display::Grid,
</span><span style=color:#86b300>+                grid_template_rows: RepeatedGridTrack::px(w as i32, 100.),
</span><span style=color:#86b300>+                grid_template_columns: RepeatedGridTrack::px(h as i32, 100.),
</span><span style=color:#86b300>+                ..Default::default()
</span><span style=color:#86b300>+            })
</span><span style=color:#86b300>+            .with_children(|commands| {
</span><span style=color:#86b300>+                for y in 0..h {
</span><span style=color:#86b300>+                    for x in 0..w {
</span><span style=color:#86b300>+                        let tile_color = if (x + y) % 2 == 1 {
</span><span style=color:#86b300>+                            let hue = ((x as f32 / w as f32) * 270.0) + ((y as f32 / h as f32) * 90.0);
</span><span style=color:#86b300>+                            Color::hsl(hue, 1., 0.5)
</span><span style=color:#86b300>+                        } else {
</span><span style=color:#86b300>+                            Color::BLACK
</span><span style=color:#86b300>+                        };
</span><span style=color:#86b300>+                        commands
</span><span style=color:#86b300>+                            .spawn((
</span><span style=color:#86b300>+                                Node {
</span><span style=color:#86b300>+                                    grid_row: GridPlacement::start(y + 1),
</span><span style=color:#86b300>+                                    grid_column: GridPlacement::start(x + 1),
</span><span style=color:#86b300>+                                    ..Default::default()
</span><span style=color:#86b300>+                                },
</span><span style=color:#86b300>+                                Pickable {
</span><span style=color:#86b300>+                                    should_block_lower: false,
</span><span style=color:#86b300>+                                    is_hoverable: true,
</span><span style=color:#86b300>+                                },
</span><span style=color:#86b300>+                                TileColor(tile_color),
</span><span style=color:#86b300>+                                BackgroundColor(tile_color),
</span><span style=color:#86b300>+                            ))
</span><span style=color:#86b300>+                            .observe(|on_enter: On&LTPointer&LTOver>>, mut query: Query<&mut BackgroundColor>, | {
</span><span style=color:#86b300>+                                if let Ok(mut background_color) = query.get_mut(on_enter.target()) {
</span><span style=color:#86b300>+                                    background_color.0 = RED.into();
</span><span style=color:#86b300>+                                }
</span><span style=color:#86b300>+                            })
</span><span style=color:#86b300>+                            .observe(|on_enter: On&LTPointer&LTOut>>, mut query: Query<(&mut BackgroundColor, &TileColor)>,| {
</span><span style=color:#86b300>+                                if let Ok((mut background_color, tile_color)) = query.get_mut(on_enter.target()) {
</span><span style=color:#86b300>+                                    background_color.0 = tile_color.0;
</span><span style=color:#86b300>+                                }
</span><span style=color:#86b300>+                            });
</span><span style=color:#86b300>+                        }
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+}
</span><span>diff --git a/release-content/migration-guides/UI_scroll_position_is_now_logical.md b/release-content/migration-guides/UI_scroll_position_is_now_logical.md
</span><span>new file mode 100644
</span><span>index 0000000000000..d0c61e487a240
</span><span style=color:#c594c5>--- /dev/null
</span><span style=color:#c594c5>+++ b/release-content/migration-guides/UI_scroll_position_is_now_logical.md
</span><span style=color:#c594c5>@@ -0,0 +1,5 @@
</span><span style=color:#86b300>+---
</span><span style=color:#86b300>+title: `ScrollPosition` now uses logical pixel units and is no longer overwritten during layout updates
</span><span style=color:#86b300>+pull_requests: [20093]
</span><span style=color:#86b300>+---
</span><span style=color:#86b300>+`ScrollPosition` is no longer overwritten during layout updates. Instead the computed scroll position is stored in the new `scroll_position` field on `ComputedNode`.
</span><span>diff --git a/release-content/release-notes/automatic_scrollbar_space_allocation.md b/release-content/release-notes/automatic_scrollbar_space_allocation.md
</span><span>new file mode 100644
</span><span>index 0000000000000..9430281a1b130
</span><span style=color:#c594c5>--- /dev/null
</span><span style=color:#c594c5>+++ b/release-content/release-notes/automatic_scrollbar_space_allocation.md
</span><span style=color:#c594c5>@@ -0,0 +1,7 @@
</span><span style=color:#86b300>+---
</span><span style=color:#86b300>+title: Automatically allocate space for scrollbars
</span><span style=color:#86b300>+authors: ["@ickshonpe"]
</span><span style=color:#86b300>+pull_requests: [20093]
</span><span style=color:#86b300>+---
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+`Node` has a new field `scrollbar_width`. If `OverflowAxis::Scroll` is set for a UI Node's axis, a space for a scrollbars of width `scrollbar_width` will automatically be left in the layout.
</span></code></pre></details></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_20093.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>