<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20074 Preconvert colors before sending to shader
        
    </title><meta content="#20074 Preconvert colors before sending to shader" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-16</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-20074-zh-cn-20250716>中文</a></div></div><div class=pr-content><h2 id=preconvert-colors-before-sending-to-shader>Preconvert colors before sending to shader</h2><h3 id=basic-information>Basic Information</h3><ul><li><strong>Title</strong>: Preconvert colors before sending to shader<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20074<li><strong>Author</strong>: tylercritchlow<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, A-UI, C-Code-Quality, S-Ready-For-Final-Review, M-Deliberate-Rendering-Change<li><strong>Created</strong>: 2025-07-10T02:48:22Z<li><strong>Merged</strong>: 2025-07-16T16:27:05Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h3 id=description-translation>Description Translation</h3><p><strong>Objective</strong><ul><li>Fixes #20008 - Preconvert colors before sending them to the UI gradients shader for better performance</ul><p><strong>Solution</strong><ul><li>Modified <code>prepare_gradient</code> in <code>gradient.rs</code> to convert colors from <code>LinearRgba</code> to <code>Srgba</code> on the CPU before sending to the GPU<li>Updated the gradient shader to remove per-pixel color space conversions since colors are now pre-converted<li>Added documentation to clarify that vertex colors are in sRGB space</ul><p>This optimization reduces the number of power operations per pixel from 3 to 1:<ul><li><strong>Before</strong>: Convert start color to sRGB, convert end color to sRGB, mix, convert back to linear (3 pow operations per pixel)<li><strong>After</strong>: Colors pre-converted on CPU, mix in sRGB space, convert back to linear (1 pow operation per pixel)</ul><p><strong>Testing</strong><ul><li>Verified that the UI gradient examples (<code>cargo run --example gradients</code>) compile and render correctly<li>The visual output should remain identical while performance improves, especially for large gradient areas<li>Changes maintain the same color interpolation behavior (mixing in sRGB space)</ul><p>To test:<ol><li>Run <code>cargo run --example gradients</code> or <code>cargo run --example stacked_gradients</code><li>Verify gradients render correctly</ol><h3 id=the-story-of-this-pull-request>The Story of This Pull Request</h3><p>The problem began with performance profiling of UI gradients in Bevy. Analysis revealed that the gradient shader was performing expensive per-pixel color space conversions during rendering. Specifically, for each pixel in a gradient, the shader was converting both start and end colors from linear RGB to sRGB, mixing them, then converting the result back to linear RGB. This required three power operations per pixel, which became a significant bottleneck for scenes with large gradient areas or many gradients.<p>The core issue was identified in the shader’s color handling approach. By performing color space conversions on the GPU for every fragment, the engine incurred unnecessary computational overhead. This was particularly problematic for UI elements where gradients are common and performance is critical for smooth rendering.<p>The solution shifted the color conversion work from the GPU to the CPU. Instead of sending linear RGB colors to the GPU and converting them per-pixel, we now preconvert colors to their target color space during gradient preparation on the CPU. This required:<ol><li>Creating a new conversion function (<code>convert_color_to_space</code>) to handle different color spaces<li>Modifying the gradient preparation system to use this conversion<li>Simplifying the shader logic to remove per-pixel conversions</ol><p>The implementation introduced a centralized color conversion function that handles all supported color spaces (Oklaba, Oklcha, Srgba, LinearRgba, Hsla, Hsva). This function converts colors during the <code>prepare_gradient</code> stage:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>convert_color_to_space</span><span>(</span><span style=color:#ff8f40>color</span><span style=color:#61676ccc>:</span><span> LinearRgba, </span><span style=color:#ff8f40>space</span><span style=color:#61676ccc>:</span><span> InterpolationColorSpace) </span><span style=color:#61676ccc>-> </span><span>[</span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>; </span><span style=color:#ff8f40>4</span><span>] {
</span><span>    </span><span style=color:#fa6e32>match</span><span> space {
</span><span>        InterpolationColorSpace</span><span style=color:#ed9366>::</span><span>Srgba </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#fa6e32>let</span><span> srgba</span><span style=color:#61676ccc>:</span><span> Srgba </span><span style=color:#ed9366>=</span><span> color</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>;
</span><span>            [srgba</span><span style=color:#ed9366>.</span><span>red</span><span style=color:#61676ccc>,</span><span> srgba</span><span style=color:#ed9366>.</span><span>green</span><span style=color:#61676ccc>,</span><span> srgba</span><span style=color:#ed9366>.</span><span>blue</span><span style=color:#61676ccc>,</span><span> srgba</span><span style=color:#ed9366>.</span><span>alpha]
</span><span>        }
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Other color space conversions...
</span><span>    }
</span><span>}
</span></code></pre><p>In the shader, the major simplification was removing all color-to-space conversion functions since colors now arrive pre-converted. The shader now focuses solely on mixing colors in the target space and converting the final result back to linear RGB:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn interpolate_gradient(...) -> vec4&LTf32> {
</span><span>    // ...
</span><span>    return convert_to_linear_rgba(mix_colors(start_color, end_color, t));
</span><span>}
</span></code></pre><p>The mixing functions were also optimized. For example, the HSL mixing was simplified to operate directly on pre-converted values:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn mix_hsla(a: vec4&LTf32>, b: vec4&LTf32>, t: f32) -> vec4&LTf32> {
</span><span>    return vec4(
</span><span>        fract(a.x + (fract(b.x - a.x + 0.5) - 0.5) * t),
</span><span>        mix(a.y, b.y, t),
</span><span>        mix(a.z, b.z, t),
</span><span>        mix(a.w, b.w, t)
</span><span>    );
</span><span>}
</span></code></pre><p>To validate the changes and measure performance impact, a new stress test example (<code>many_gradients.rs</code>) was added. This example renders a configurable number of gradients with options to test different color spaces and animation patterns:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> args</span><span style=color:#61676ccc>:</span><span> Args </span><span style=color:#ed9366>= </span><span>argh</span><span style=color:#ed9366>::</span><span>from_env()</span><span style=color:#61676ccc>;
</span><span>    App</span><span style=color:#ed9366>::</span><span>new()
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(Startup</span><span style=color:#61676ccc>,</span><span> setup)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(Update</span><span style=color:#61676ccc>,</span><span> animate_gradients)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>run</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The key performance improvement comes from reducing GPU operations. Previously, each pixel required three pow operations (two for conversion to sRGB, one for conversion back to linear). Now only one pow operation is needed per pixel (for the final conversion back to linear). This change is particularly impactful for:<ul><li>Large gradient areas<li>Scenes with many gradients<li>Lower-powered devices</ul><p>Visual output remains identical to the previous implementation since the same color space conversions are applied - just at a different stage in the pipeline. The solution maintains backward compatibility while significantly improving rendering performance for gradient-heavy UI scenes.<h3 id=visual-representation>Visual Representation</h3><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[CPU: prepare_gradient] --> B[Convert colors to target space]
</span><span>    B --> C[GPU: gradient.wgsl]
</span><span>    C --> D[Mix pre-converted colors]
</span><span>    D --> E[Convert result to linear RGB]
</span></code></pre><h3 id=key-files-changed>Key Files Changed</h3><ol><li><p><strong>crates/bevy_ui_render/src/gradient.rs</strong><br> Added color conversion logic on CPU before sending to GPU</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Added conversion function
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>convert_color_to_space</span><span>(</span><span style=color:#ff8f40>color</span><span style=color:#61676ccc>:</span><span> LinearRgba, </span><span style=color:#ff8f40>space</span><span style=color:#61676ccc>:</span><span> InterpolationColorSpace) </span><span style=color:#61676ccc>-> </span><span>[</span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>; </span><span style=color:#ff8f40>4</span><span>] {
</span><span>    </span><span style=color:#fa6e32>match</span><span> space {
</span><span>        InterpolationColorSpace</span><span style=color:#ed9366>::</span><span>Srgba </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#fa6e32>let</span><span> srgba</span><span style=color:#61676ccc>:</span><span> Srgba </span><span style=color:#ed9366>=</span><span> color</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>;
</span><span>            [srgba</span><span style=color:#ed9366>.</span><span>red</span><span style=color:#61676ccc>,</span><span> srgba</span><span style=color:#ed9366>.</span><span>green</span><span style=color:#61676ccc>,</span><span> srgba</span><span style=color:#ed9366>.</span><span>blue</span><span style=color:#61676ccc>,</span><span> srgba</span><span style=color:#ed9366>.</span><span>alpha]
</span><span>        }
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Other color space conversions...
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Modified gradient preparation
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>prepare_gradient</span><span>(...) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>let</span><span> start_color </span><span style=color:#ed9366>= </span><span style=color:#f07171>convert_color_to_space</span><span>(start_stop</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,</span><span> gradient</span><span style=color:#ed9366>.</span><span>color_space)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> end_color </span><span style=color:#ed9366>= </span><span style=color:#f07171>convert_color_to_space</span><span>(end_stop</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,</span><span> gradient</span><span style=color:#ed9366>.</span><span>color_space)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>}
</span></code></pre><li><p><strong>crates/bevy_ui_render/src/gradient.wgsl</strong><br> Simplified shader by removing per-pixel conversions</p> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Removed conversion functions like:
</span><span>// fn linear_rgba_to_oklaba() {...}
</span><span>// fn mix_linear_rgba_in_srgba_space() {...}
</span><span>
</span><span>// Added optimized mixing functions
</span><span>fn mix_hsla(a: vec4&LTf32>, b: vec4&LTf32>, t: f32) -> vec4&LTf32> {
</span><span>    return vec4(
</span><span>        fract(a.x + (fract(b.x - a.x + 0.5) - 0.5) * t),
</span><span>        mix(a.y, b.y, t),
</span><span>        mix(a.z, b.z, t),
</span><span>        mix(a.w, b.w, t)
</span><span>    );
</span><span>}
</span><span>
</span><span>// Unified color conversion at end
</span><span>fn convert_to_linear_rgba(color: vec4&LTf32>) -> vec4&LTf32> {
</span><span>#ifdef IN_SRGB
</span><span>    return vec4(pow(color.rgb, vec3(2.2)), color.a);
</span><span>#else
</span><span>    // Other conversions...
</span><span>#endif
</span><span>}
</span></code></pre><li><p><strong>examples/stress_tests/many_gradients.rs</strong><br> Added new performance test for gradients</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Configurable gradient test
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>setup</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands, </span><span style=color:#ff8f40>args</span><span style=color:#61676ccc>: </span><span>Res&LTArgs>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>        Node { </span><span style=color:#abb0b6;font-style:italic>/* ... */ </span><span>}</span><span style=color:#61676ccc>,
</span><span>        BackgroundGradient(</span><span style=color:#f07171>vec!</span><span>[Gradient</span><span style=color:#ed9366>::</span><span>Linear(gradient)])</span><span style=color:#61676ccc>,
</span><span>        GradientNode { index</span><span style=color:#61676ccc>:</span><span> i }</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Gradient animation system
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>animate_gradients</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>gradients</span><span style=color:#61676ccc>: </span><span>Query<(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> BackgroundGradient, </span><span style=color:#ed9366>&</span><span>GradientNode)>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Update gradient colors based on time
</span><span>}
</span></code></pre><li><p><strong>Cargo.toml</strong><br> Added new example to workspace</p> <pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[[</span><span style=color:#399ee6>example</span><span>]]
</span><span style=color:#399ee6>name </span><span>= </span><span style=color:#86b300>"many_gradients"
</span><span style=color:#399ee6>path </span><span>= </span><span style=color:#86b300>"examples/stress_tests/many_gradients.rs"
</span></code></pre><li><p><strong>examples/README.md</strong><br> Added documentation for new example</p> <pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span>[Many Gradients](</span><span style=color:#4cbf99;font-style:italic;text-decoration:underline>../examples/stress_tests/many_gradients.rs</span><span>) </span><span style=color:#61676ccc>|</span><span> Stress test for gradient rendering performance
</span></code></pre></ol><h3 id=further-reading>Further Reading</h3><ol><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/features/ui/ target=_blank>Bevy UI Rendering Architecture</a><li><a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/wgsl/ target=_blank>WGSL Shading Language Specification</a><li><a rel="noopener nofollow noreferrer" href=https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear target=_blank>Color Spaces in Computer Graphics</a><li><a rel="noopener nofollow noreferrer" href=https://developer.nvidia.com/gdc/gdc12-presentation target=_blank>Performance Optimization Techniques in Rendering</a></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_20074.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>