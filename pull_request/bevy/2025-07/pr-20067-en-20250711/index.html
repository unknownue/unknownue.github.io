<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20067 Fix SSAO specular occlusion roughness bug
        
    </title><meta content="#20067 Fix SSAO specular occlusion roughness bug" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-07/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-07-11</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-07/pr-20067-zh-cn-20250711>中文</a></div></div><div class=pr-content><h1 id=analysis-fix-ssao-specular-occlusion-roughness-bug>Analysis: Fix SSAO Specular Occlusion Roughness Bug</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix SSAO specular occlusion roughness bug<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20067<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-07-09T20:52:44Z<li><strong>Merged</strong>: 2025-07-11T05:22:35Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Noticed that we’re converting perceptual_roughness to roughness for SSAO specular occlusion up here, <em>but</em> that happens <em>before</em> we sample the metallic_roughness texture map. So we’re using the wrong roughness. I assume this is a bug and was not intentional.<p>Suggest reviewing while hiding the whitespace diff.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>The PR addresses a bug in Bevy’s physically-based rendering (PBR) pipeline related to screen-space ambient occlusion (SSAO) calculations. Specifically, the specular occlusion computation was using an incorrect roughness value. The root cause was a timing issue in the shader where roughness conversion happened before texture sampling.<p>In the PBR workflow:<ol><li>Perceptual roughness is either provided directly or sampled from textures<li>This value is converted to mathematical roughness using <code>perceptualRoughnessToRoughness()</code><li>The mathematical roughness is used in lighting calculations</ol><p>The bug occurred because step 2 (conversion) was happening before step 1 (texture sampling) was complete. This meant materials using metallic-roughness textures had specular occlusion calculations based on unconverted base values rather than final sampled values. The visual impact would be incorrect specular occlusion for textured materials, particularly noticeable in SSAO effects.<h3 id=the-solution-approach>The Solution Approach</h3><p>The solution required repositioning the roughness conversion in the shader execution flow. Instead of converting perceptual roughness to mathematical roughness early in the process, we delay this conversion until immediately before the specular occlusion calculation. This ensures:<ol><li>Texture sampling completes first<li>We use the final perceptual roughness value<li>The conversion happens just-in-time for the occlusion calculation</ol><p>No alternative approaches were considered since this was a clear sequencing error. The fix maintains the existing algorithm from Lagarde and Rousiers’ 2014 PBR implementation while correcting the input timing.<h3 id=the-implementation>The Implementation</h3><p>The implementation modifies <code>pbr_fragment.wgsl</code> with three precise changes:<ol><li><strong>Remove early roughness conversion</strong>: Eliminates the premature conversion that used base material values<li><strong>Fix whitespace artifact</strong>: Corrects a minor formatting issue in occlusion texture sampling<li><strong>Add just-in-time conversion</strong>: Inserts the roughness conversion immediately before specular occlusion calculation</ol><p>The key technical insight is that <code>pbr_input.material.perceptual_roughness</code> contains the final value after texture sampling, making it the correct input for conversion when used at the point of specular occlusion calculation.<h3 id=technical-insights>Technical Insights</h3><ul><li><strong>Roughness Conversion</strong>: The <code>lighting::perceptualRoughnessToRoughness</code> function squares the perceptual roughness value to obtain mathematical roughness used in lighting equations<li><strong>Data Flow</strong>: The fix ensures the shader uses the final perceptual roughness (after texture sampling) rather than the base material value<li><strong>Performance</strong>: No measurable performance impact since we’re moving an existing calculation rather than adding new operations</ul><h3 id=the-impact>The Impact</h3><p>This correction ensures specular occlusion calculations accurately reflect material properties defined in textures. Materials using metallic-roughness textures will now have correct SSAO interactions with specular highlights. The fix maintains visual consistency between materials with and without textures.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Base Perceptual Roughness] --> B[Texture Sampling]
</span><span>    B --> C[Final Perceptual Roughness]
</span><span>    C --> D[Specular Occlusion Calculation]
</span><span>    D -->|Requires| E[Mathematical Roughness]
</span><span>    C -->|Converted at point of use| E
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-pbr-src-render-pbr-fragment-wgsl><code>crates/bevy_pbr/src/render/pbr_fragment.wgsl</code></h3><p><strong>Changes:</strong><ol><li>Removed early roughness conversion that occurred before texture sampling<li>Fixed whitespace in occlusion texture sampling<li>Added roughness conversion at point of specular occlusion calculation</ol><p><strong>Code Snippets:</strong><p>Before (incorrect timing):<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before texture sampling
</span><span>var perceptual_roughness: f32 = pbr_bindings::material.perceptual_roughness;
</span><span>let roughness = lighting::perceptualRoughnessToRoughness(perceptual_roughness);
</span><span>
</span><span>// Texture sampling happens later...
</span><span>#ifdef VERTEX_UVS
</span><span>if ((flags & pbr_types::STANDARD_MATERIAL_FLAGS_METALLIC_ROUGHNESS_TEXTURE_BIT) != 0u) {
</span><span>    // Modifies perceptual_roughness but roughness is already calculated
</span><span>}
</span><span>#endif
</span><span>
</span><span>// Later usage with stale roughness value
</span><span>specular_occlusion = saturate(pow(NdotV + ssao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ssao);
</span></code></pre><p>After (corrected flow):<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>var perceptual_roughness: f32 = pbr_bindings::material.perceptual_roughness;
</span><span>
</span><span>// Texture sampling happens first...
</span><span>#ifdef VERTEX_UVS
</span><span>if ((flags & pbr_types::STANDARD_MATERIAL_FLAGS_METALLIC_ROUGHNESS_TEXTURE_BIT) != 0u) {
</span><span>    // Modifies perceptual_roughness
</span><span>}
</span><span>#endif
</span><span>
</span><span>// Conversion at point of use with final value
</span><span>let roughness = lighting::perceptualRoughnessToRoughness(pbr_input.material.perceptual_roughness);
</span><span>specular_occlusion = saturate(pow(NdotV + ssao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ssao);
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://www.ea.com/frostbite/news/moving-frostbite-to-pb target=_blank>Moving Frostbite to Physically Based Rendering (2014)</a> - Original reference for specular occlusion technique<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/features/pbr/ target=_blank>Bevy PBR Documentation</a> - Bevy’s PBR implementation overview<li><a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/wgsl/ target=_blank>WGSL Spec</a> - WebGPU Shading Language reference</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-07/pr_20067.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>