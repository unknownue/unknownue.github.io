<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #19647 Event Split: `Event`, `EntityEvent`, and `BufferedEvent`
        
    </title><meta content="#19647 Event Split: `Event`, `EntityEvent`, and `BufferedEvent`" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-06/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-06-15</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-06/pr-19647-zh-cn-20250615>中文</a></div></div><div class=pr-content><h1 id=event-split-event-entityevent-and-bufferedevent>Event Split: <code>Event</code>, <code>EntityEvent</code>, and <code>BufferedEvent</code></h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Event Split: <code>Event</code>, <code>EntityEvent</code>, and <code>BufferedEvent</code><li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/19647<li><strong>Author</strong>: Jondolf<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Docs, A-ECS, C-Usability, S-Ready-For-Final-Review, M-Needs-Migration-Guide, M-Needs-Release-Note, X-Contentious, D-Modest<li><strong>Created</strong>: 2025-06-14T20:51:54Z<li><strong>Merged</strong>: 2025-06-15T17:10:23Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Closes #19564.<p>The current <code>Event</code> trait looks like this:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><p>The <code>Event</code> trait is used by both buffered events (<code>EventReader</code>/<code>EventWriter</code>) and observer events. If they are observer events, they can optionally be targeted at specific <code>Entity</code>s or <code>ComponentId</code>s, and can even be propagated to other entities.<p>However, there has long been a desire to split the trait semantically for a variety of reasons, see #14843, #14272, and #16031 for discussion. Some reasons include:<ul><li>It’s very uncommon to use a single event type as both a buffered event and targeted observer event. They are used differently and tend to have distinct semantics.<li>A common footgun is using buffered events with observers or event readers with observer events, as there is no type-level error that prevents this kind of misuse.<li>#19440 made <code>Trigger::target</code> return an <code>Option&LTEntity></code>. This <em>seriously</em> hurts ergonomics for the general case of entity observers, as you need to <code>.unwrap()</code> each time. If we could statically determine whether the event is expected to have an entity target, this would be unnecessary.</ul><p>There’s really two main ways that we can categorize events: push vs. pull (i.e. “observer event” vs. “buffered event”) and global vs. targeted:<table><thead><tr><th><th>Push<th>Pull<tbody><tr><td><strong>Global</strong><td>Global observer<td><code>EventReader</code>/<code>EventWriter</code><tr><td><strong>Targeted</strong><td>Entity observer<td>-</table><p>There are many ways to approach this, each with their tradeoffs. Ultimately, we kind of want to split events both ways:<ul><li>A type-level distinction between observer events and buffered events, to prevent people from using the wrong kind of event in APIs<li>A statically designated entity target for observer events to avoid accidentally using untargeted events for targeted APIs</ul><p>This PR achieves these goals by splitting event traits into <code>Event</code>, <code>EntityEvent</code>, and <code>BufferedEvent</code>, with <code>Event</code> being the shared trait implemented by all events.<h2 id=event-entityevent-and-bufferedevent><code>Event</code>, <code>EntityEvent</code>, and <code>BufferedEvent</code></h2><p><code>Event</code> is now a very simple trait shared by all events.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Required for observer APIs
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><p>You can call <code>trigger</code> for <em>any</em> event, and use a global observer for listening to the event.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Event)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Speak </span><span>{
</span><span>    message</span><span style=color:#61676ccc>:</span><span> String,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(|</span><span style=color:#ff8f40>trigger</span><span style=color:#61676ccc>: </span><span>On&LTSpeak>| {
</span><span>    </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> trigger</span><span style=color:#ed9366>.</span><span>message)</span><span style=color:#61676ccc>;
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>
</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(Speak {
</span><span>    message</span><span style=color:#61676ccc>: </span><span style=color:#86b300>"Y'all like these reworked events?"</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_string</span><span>()</span><span style=color:#61676ccc>,
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p>To allow an event to be targeted at entities and even propagated further, you can additionally implement the <code>EntityEvent</code> trait:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>EntityEvent</span><span>: Event {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This lets you call <code>trigger_targets</code>, and to use targeted observer APIs like <code>EntityCommands::observe</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Event</span><span style=color:#61676ccc>,</span><span> EntityEvent)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>entity_event</span><span>(traversal </span><span style=color:#ed9366>=</span><span> &'static ChildOf</span><span style=color:#61676ccc>,</span><span> auto_propagate)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Damage </span><span>{
</span><span>    amount</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>
</span><span style=color:#fa6e32>let</span><span> enemy </span><span style=color:#ed9366>=</span><span> commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((Enemy</span><span style=color:#61676ccc>,</span><span> Health(</span><span style=color:#ff8f40>100.0</span><span>)))</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Spawn some armor as a child of the enemy entity.
</span><span style=color:#abb0b6;font-style:italic>// When the armor takes damage, it will bubble the event up to the enemy.
</span><span style=color:#fa6e32>let</span><span> armor_piece </span><span style=color:#ed9366>=</span><span> commands
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((ArmorPiece</span><span style=color:#61676ccc>,</span><span> Health(</span><span style=color:#ff8f40>25.0</span><span>)</span><span style=color:#61676ccc>,</span><span> ChildOf(enemy)))
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>observe</span><span>(|</span><span style=color:#ff8f40>trigger</span><span style=color:#61676ccc>: </span><span>On&LTDamage></span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>query</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Health>| {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Note: `On::target` only exists because this is an `EntityEvent`.
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> health </span><span style=color:#ed9366>=</span><span> query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(trigger</span><span style=color:#ed9366>.</span><span style=color:#f07171>target</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>        health</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>-=</span><span> trigger</span><span style=color:#ed9366>.</span><span style=color:#f07171>amount</span><span>()</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>
</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_targets</span><span>(Damage { amount</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>10.0 </span><span>}</span><span style=color:#61676ccc>,</span><span> armor_piece)</span><span style=color:#61676ccc>;
</span></code></pre><blockquote><p>[!NOTE] You <em>can</em> still also trigger an <code>EntityEvent</code> without targets using <code>trigger</code>. We probably <em>could</em> make this an either-or thing, but I’m not sure that’s actually desirable.</blockquote><p>To allow an event to be used with the buffered API, you can implement <code>BufferedEvent</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>BufferedEvent</span><span>: Event {}
</span></code></pre><p>The event can then be used with <code>EventReader</code>/<code>EventWriter</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Event</span><span style=color:#61676ccc>,</span><span> BufferedEvent)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Message</span><span>(String)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>write_hello</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>writer</span><span style=color:#61676ccc>: </span><span>EventWriter&LTMessage>) {
</span><span>    writer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>(Message(</span><span style=color:#86b300>"I hope these examples are alright"</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_string</span><span>()))</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>read_messages</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>reader</span><span style=color:#61676ccc>: </span><span>EventReader&LTMessage>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Process all buffered events of type `Message`.
</span><span>    </span><span style=color:#fa6e32>for</span><span> Message(message) </span><span style=color:#ed9366>in</span><span> reader</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>() {
</span><span>        </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{message}</span><span style=color:#86b300>"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>In summary:<ul><li>Need a basic event you can trigger and observe? Derive <code>Event</code>!<li>Need the event to be targeted at an entity? Derive <code>EntityEvent</code>!<li>Need the event to be buffered and support the <code>EventReader</code>/<code>EventWriter</code> API? Derive <code>BufferedEvent</code>!</ul><h2 id=alternatives>Alternatives</h2><p>I’ll now cover some of the alternative approaches I have considered and briefly explored. I made this section collapsible since it ended up being quite long :P<details><summary>Expand this to see alternatives</summary> <h3 id=1-unified-event-trait>1. Unified <code>Event</code> Trait</h3> <p>One option is not to have <em>three</em> separate traits (<code>Event</code>, <code>EntityEvent</code>, <code>BufferedEvent</code>), and to instead just use associated constants on <code>Event</code> to determine whether an event supports targeting and buffering or not:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>TARGETED</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>BUFFERED</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre> <p>Methods can then use bounds like <code>where E: Event&LTTARGETED = true></code> or <code>where E: Event&LTBUFFERED = true></code> to limit APIs to specific kinds of events.</p> <p>This would keep everything under one <code>Event</code> trait, but I don’t think it’s necessarily a good idea. It makes APIs harder to read, and docs can’t easily refer to specific types of events. You can also create weird invariants: what if you specify <code>TARGETED = false</code>, but have <code>Traversal</code> and/or <code>AUTO_PROPAGATE</code> enabled?</p> <h3 id=2-event-and-trigger>2. <code>Event</code> and <code>Trigger</code></h3> <p>Another option is to only split the traits between buffered events and observer events, since that is the main thing people have been asking for, and they have the largest API difference.</p> <p>If we did this, I think we would need to make the terms <em>clearly</em> separate. We can’t really use <code>Event</code> and <code>BufferedEvent</code> as the names, since it would be strange that <code>BufferedEvent</code> doesn’t implement <code>Event</code>. Something like <code>ObserverEvent</code> and <code>BufferedEvent</code> could work, but it’d be more verbose.</p> <p>For this approach, I would instead keep <code>Event</code> for the current <code>EventReader</code>/<code>EventWriter</code> API, and call the observer event a <code>Trigger</code>, since the “trigger” terminology is already used in the observer context within Bevy (both as a noun and a verb). This is also what a long <a rel="noopener nofollow noreferrer" href=https://discord.com/channels/691052431525675048/749335865876021248/1298057661878898791 target=_blank>bikeshed on Discord</a> seemed to land on at the end of last year.</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// For `EventReader`/`EventWriter`
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// For observers
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Trigger</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>TARGETED</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre> <p>The problem is that “event” is just a really good term for something that “happens”. Observers are rapidly becoming the more prominent API, so it’d be weird to give them the <code>Trigger</code> name and leave the good <code>Event</code> name for the less common API.</p> <p>So, even though a split like this seems neat on the surface, I think it ultimately wouldn’t really work. We want to keep the <code>Event</code> name for observer events, and there is no good alternative for the buffered variant. (<code>Message</code> was suggested, but saying stuff like “sends a collision message” is weird.)</p> <h3 id=3-globalevent-targetedevent>3. <code>GlobalEvent</code> + <code>TargetedEvent</code></h3> <p>What if instead of focusing on the buffered vs. observed split, we <em>only</em> make a distinction between global and targeted events?</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// A shared event trait to allow global observers to work
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// For buffered events and non-targeted observer events
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>GlobalEvent</span><span>: Event {}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// For targeted observer events
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>TargetedEvent</span><span>: Event {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre> <p>This is actually the first approach I implemented, and it has the neat characteristic that you can only use non-targeted APIs like <code>trigger</code> with a <code>GlobalEvent</code> and targeted APIs like <code>trigger_targets</code> with a <code>TargetedEvent</code>. You have full control over whether the entity should or should not have a target, as they are fully distinct at the type-level.</p> <p>However, there’s a few problems:</p> <ul><li>There is no type-level indication of whether a <code>GlobalEvent</code> supports buffered events or just non-targeted observer events<li>An <code>Event</code> on its own does literally nothing, it’s just a shared trait required to make global observers accept both non-targeted and targeted events<li>If an event is both a <code>GlobalEvent</code> and <code>TargetedEvent</code>, global observers again have ambiguity on whether an event has a target or not, undermining some of the benefits<li>The names are not ideal</ul> <h3 id=4-event-and-entityevent>4. <code>Event</code> and <code>EntityEvent</code></h3> <p>We can fix some of the problems of Alternative 3 by accepting that targeted events can also be used in non-targeted contexts, and simply having the <code>Event</code> and <code>EntityEvent</code> traits:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// For buffered events and non-targeted observer events
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// For targeted observer events
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>EntityEvent</span><span>: Event {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre> <p>This is essentially identical to this PR, just without a dedicated <code>BufferedEvent</code>. The remaining major “problem” is that there is still zero type-level indication of whether an <code>Event</code> event <em>actually</em> supports the buffered API. This leads us to the solution proposed in this PR, using <code>Event</code>, <code>EntityEvent</code>, and <code>BufferedEvent</code>.</p></details><h2 id=conclusion>Conclusion</h2><p>The <code>Event</code> + <code>EntityEvent</code> + <code>BufferedEvent</code> split proposed in this PR aims to solve all the common problems with Bevy’s current event model while keeping the “weirdness” factor minimal. It splits in terms of both the push vs. pull <em>and</em> global vs. targeted aspects, while maintaining a shared concept for an “event”.<h3 id=why-i-like-this>Why I Like This</h3><ul><li>The term “event” remains as a single concept for all the different kinds of events in Bevy.<li>Despite all event types being “events”, they use fundamentally different APIs. Instead of assuming that you can use an event type with any pattern (when only one is typically supported), you explicitly opt in to each one with dedicated traits.<li>Using separate traits for each type of event helps with documentation and clearer function signatures.<li>I can safely make assumptions on expected usage. <ul><li>If I see that an event is an <code>EntityEvent</code>, I can assume that I can use <code>observe</code> on it and get targeted events.<li>If I see that an event is a <code>BufferedEvent</code>, I can assume that I can use <code>EventReader</code> to read events.<li>If I see both <code>EntityEvent</code> and <code>BufferedEvent</code>, I can assume that both APIs are supported.</ul></ul><p>In summary: This allows for a unified concept for events, while limiting the different ways to use them with opt-in traits. No more guess-work involved when using APIs.<h3 id=problems>Problems?</h3><ul><li>Because <code>BufferedEvent</code> implements <code>Event</code> (for more consistent semantics etc.), you can still use all buffered events for non-targeted observers. I think this is fine/good. The important part is that if you see that an event implements <code>BufferedEvent</code>, you know that the <code>EventReader</code>/<code>EventWriter</code> API should be supported. Whether it <em>also</em> supports other APIs is secondary.<li>I currently only support <code>trigger_targets</code> for an <code>EntityEvent</code>. However, you can technically target components too, without targeting any entities. I consider that such a niche and advanced use case that it’s not a huge problem to only support it for <code>EntityEvent</code>s, but we could also split <code>trigger_targets</code> into <code>trigger_entities</code> and <code>trigger_components</code> if we wanted to (or implement components as entities :P).<li>You can still trigger an <code>EntityEvent</code> <em>without</em> targets. I consider this correct, since <code>Event</code> implements the non-targeted behavior, and it’d be weird if implementing another trait <em>removed</em> behavior. However, it does mean that global observers for entity events can technically return <code>Entity::PLACEHOLDER</code> again (since I got rid of the <code>Option&LTEntity></code> added in #19440 for ergonomics). I think that’s enough of an edge case that it’s not a huge problem, but it is worth keeping in mind.<li><del>Deriving both <code>EntityEvent</code> and <code>BufferedEvent</code> for the same type currently duplicates the <code>Event</code> implementation, so you instead need to manually implement one of them.</del> Changed to always requiring <code>Event</code> to be derived.</ul><h2 id=related-work>Related Work</h2><p>There are plans to implement multi-event support for observers, especially for UI contexts. <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/14649#issuecomment-2960402508 target=_blank>Cart’s example</a> API looked like this:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Truncated for brevity
</span><span>trigger</span><span style=color:#61676ccc>: </span><span>Trigger<(
</span><span>    OnAdd&LTPressed>,
</span><span>    OnRemove&LTPressed>,
</span><span>    OnAdd&LTInteractionDisabled>,
</span><span>    OnRemove&LTInteractionDisabled>,
</span><span>    OnInsert&LTHovered>,
</span><span>)></span><span style=color:#61676ccc>,
</span></code></pre><p>I believe this shouldn’t be in conflict with this PR. If anything, this PR might <em>help</em> achieve the multi-event pattern for entity observers with fewer footguns: by statically enforcing that all of these events are <code>EntityEvent</code>s in the context of <code>EntityCommands::observe</code>, we can avoid misuse or weird cases where <em>some</em> events inside the trigger are targeted while others are not.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=problem-and-context>Problem and Context</h3><p>Bevy’s existing event system used a single <code>Event</code> trait for both buffered events (handled via <code>EventReader</code>/<code>EventWriter</code>) and observer events (triggered immediately with <code>Commands::trigger</code>). This design led to several issues:<ol><li><strong>Semantic ambiguity</strong>: Most events are used exclusively as either buffered or observer events, but the unified trait suggested they could be used interchangeably<li><strong>Runtime errors</strong>: No compile-time prevention for using buffered events with observers or vice versa<li><strong>Ergonomics issues</strong>: Recent changes to entity targeting required <code>.unwrap()</code> calls for common cases<li><strong>Lack of static guarantees</strong>: Unable to enforce correct usage patterns at the type level</ol><p>The core problem was that Bevy’s event system needed clearer boundaries between fundamentally different event handling patterns.<h3 id=solution-approach>Solution Approach</h3><p>The PR introduces a clear separation of concerns by splitting the event system into three distinct traits:<ol><li><strong><code>Event</code></strong>: Base trait for all events, supporting global observers<li><strong><code>EntityEvent</code></strong>: Extends <code>Event</code> with entity targeting and propagation capabilities<li><strong><code>BufferedEvent</code></strong>: Extends <code>Event</code> for use with <code>EventReader</code>/<code>EventWriter</code></ol><p>This approach was chosen after evaluating several alternatives (documented in the PR description) that proved less optimal due to:<ul><li>Reduced API clarity<li>Weaker type guarantees<li>Unintuitive naming schemes<li>Incomplete coverage of use cases</ul><p>The key engineering decisions were:<ul><li>Maintaining <code>Event</code> as the shared base trait<li>Making <code>EntityEvent</code> and <code>BufferedEvent</code> opt-in extensions<li>Preserving backward compatibility where possible<li>Providing clear migration paths</ul><h3 id=implementation>Implementation</h3><p>The implementation required changes across multiple areas of the codebase:<p><strong>Core Trait Definitions (<code>base.rs</code>):</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Base event trait
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId></span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Entity-targeting extension
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>EntityEvent</span><span>: Event {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Buffered event marker
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>BufferedEvent</span><span>: Event {}
</span></code></pre><p><strong>Derive Macros (<code>component.rs</code>):</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Event derive
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>derive_event</span><span>(</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>:</span><span> TokenStream) </span><span style=color:#61676ccc>-></span><span> TokenStream {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... generates Event implementation
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// EntityEvent derive
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>derive_entity_event</span><span>(</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>:</span><span> TokenStream) </span><span style=color:#61676ccc>-></span><span> TokenStream {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... generates EntityEvent implementation
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// BufferedEvent derive
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>derive_buffered_event</span><span>(</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>:</span><span> TokenStream) </span><span style=color:#61676ccc>-></span><span> TokenStream {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... generates BufferedEvent implementation
</span><span>}
</span></code></pre><p><strong>Observer System (<code>observer/mod.rs</code>):</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Only provide target() for EntityEvents
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>, E</span><span style=color:#61676ccc>:</span><span> EntityEvent, B</span><span style=color:#61676ccc>:</span><span> Bundle> </span><span style=color:#399ee6>On</span><span><</span><span style=color:#fa6e32>'w</span><span>, E, B> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>target</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Entity {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>trigger</span><span style=color:#ed9366>.</span><span>target</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(Entity</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>PLACEHOLDER</span><span>)
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>set_propagate</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>propagate</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>) { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get_propagate</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{ </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><p><strong>Migration Changes:</strong><ul><li>Updated all existing events to derive appropriate traits<li>Converted benchmark events to use <code>BufferedEvent</code><li>Fixed examples to use new event traits<li>Updated documentation throughout</ul><h3 id=technical-insights>Technical Insights</h3><p>Key technical aspects of the implementation:<ol><li><p><strong>Trait Hierarchy</strong>:</p> <ul><li><code>EntityEvent</code> and <code>BufferedEvent</code> both require <code>Event</code><li>This maintains a unified event concept while allowing specialization</ul><li><p><strong>Observer Ergonomics</strong>:</p> <ul><li><code>On::target()</code> now directly returns <code>Entity</code> for <code>EntityEvent</code>s<li>Removes need for <code>.unwrap()</code> in common cases<li>Uses <code>Entity::PLACEHOLDER</code> for non-targeted events</ul><li><p><strong>Propagation Control</strong>:</p> <ul><li>Propagation methods only available for <code>EntityEvent</code>s<li>Matches the only context where propagation makes sense</ul><li><p><strong>Backward Compatibility</strong>:</p> <ul><li>Existing events can be upgraded by adding derives<li>Most changes are mechanical additions of <code>EntityEvent</code> or <code>BufferedEvent</code></ul><li><p><strong>Performance</strong>:</p> <ul><li>Zero-cost abstractions maintain existing performance characteristics<li>No additional runtime overhead for event handling</ul></ol><h3 id=impact>Impact</h3><p>The changes provide significant benefits:<ol><li><p><strong>Clearer APIs</strong>:</p> <ul><li>Function signatures now clearly indicate supported event types<li>Removes ambiguity about how an event should be used</ul><li><p><strong>Stronger Guarantees</strong>:</p> <ul><li>Compile-time prevention of invalid event usage patterns<li>Eliminates entire categories of runtime errors</ul><li><p><strong>Improved Ergonomics</strong>:</p> <ul><li>Direct <code>Entity</code> access for targeted events<li>No more <code>.unwrap()</code> for entity observers</ul><li><p><strong>Better Documentation</strong>:</p> <ul><li>Traits serve as self-documenting markers for event capabilities<li>Examples demonstrate proper usage patterns</ul><li><p><strong>Foundation for Future Features</strong>:</p> <ul><li>Enables safer implementation of multi-event observers<li>Provides clearer extension points for event system improvements</ul></ol><p>The main trade-off is the need to add additional derives to existing events, but this is a straightforward mechanical change that improves long-term maintainability.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Event] --> B[EntityEvent]
</span><span>    A[Event] --> C[BufferedEvent]
</span><span>    
</span><span>    B --> D[Supports entity targeting]
</span><span>    B --> E[Supports propagation]
</span><span>    
</span><span>    C --> F[Works with EventReader]
</span><span>    C --> G[Works with EventWriter]
</span><span>    
</span><span>    A --> H[Global observers]
</span><span>    A --> I[trigger API]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-event-base-rs-276-38><code>crates/bevy_ecs/src/event/base.rs</code> (+276/-38)</h3><ul><li>Simplified <code>Event</code> trait by removing <code>Traversal</code> and <code>AUTO_PROPAGATE</code><li>Added <code>EntityEvent</code> and <code>BufferedEvent</code> traits<li>Updated documentation to explain the new event types</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId></span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> ComponentId</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>component_id</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTComponentId></span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>EntityEvent</span><span>: Event {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal</span><span style=color:#61676ccc>: </span><span>Traversal<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>BufferedEvent</span><span>: Event {}
</span></code></pre><h3 id=crates-bevy-ecs-src-observer-mod-rs-68-42><code>crates/bevy_ecs/src/observer/mod.rs</code> (+68/-42)</h3><ul><li>Modified <code>On</code> to provide <code>target()</code> only for <code>EntityEvent</code>s<li>Made propagation methods exclusive to <code>EntityEvent</code>s<li>Updated documentation examples</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>, E, B</span><span style=color:#61676ccc>:</span><span> Bundle> </span><span style=color:#399ee6>On</span><span><</span><span style=color:#fa6e32>'w</span><span>, E, B> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>target</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>, E</span><span style=color:#61676ccc>:</span><span> EntityEvent, B</span><span style=color:#61676ccc>:</span><span> Bundle> </span><span style=color:#399ee6>On</span><span><</span><span style=color:#fa6e32>'w</span><span>, E, B> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>target</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Entity { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>set_propagate</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>propagate</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>) { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get_propagate</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{ </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-macros-src-component-rs><code>crates/bevy_ecs/macros/src/component.rs</code></h3><ul><li>Added derive implementations for new traits<li>Updated attribute handling for <code>EntityEvent</code></ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// EntityEvent derive with attributes
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>derive_entity_event</span><span>(</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>:</span><span> TokenStream) </span><span style=color:#61676ccc>-></span><span> TokenStream {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> ast </span><span style=color:#ed9366>= </span><span style=color:#f07171>parse_macro_input!</span><span>(input </span><span style=color:#ed9366>as</span><span> DeriveInput)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> auto_propagate </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> traversal</span><span style=color:#61676ccc>:</span><span> Type </span><span style=color:#ed9366>= </span><span style=color:#f07171>parse_quote!</span><span>(())</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Parse #[entity_event(...)] attributes
</span><span>    </span><span style=color:#fa6e32>for</span><span> attr </span><span style=color:#ed9366>in &</span><span>ast</span><span style=color:#ed9366>.</span><span>attrs {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... attribute processing
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Generate implementation
</span><span>    </span><span style=color:#f07171>quote! </span><span>{
</span><span>        </span><span style=color:#fa6e32>impl </span><span>#</span><span style=color:#399ee6>impl_generics</span><span> #</span><span style=color:#399ee6>bevy_ecs_path</span><span>::</span><span style=color:#399ee6>event</span><span>::</span><span style=color:#399ee6>EntityEvent for</span><span> #</span><span style=color:#399ee6>struct_name</span><span> #</span><span style=color:#399ee6>type_generics</span><span> #</span><span style=color:#399ee6>where_clause </span><span>{
</span><span>            </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Traversal </span><span style=color:#ed9366>= #</span><span>traversal</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>AUTO_PROPAGATE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool </span><span style=color:#ed9366>= #</span><span>auto_propagate</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-readme-md-22-22><code>crates/bevy_ecs/README.md</code> (+22/-22)</h3><ul><li>Updated examples to use new event traits<li>Clarified differences between event types</ul><pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span>// Before:
</span><span style=color:#fa6e32;font-weight:700>#</span><span style=color:#399ee6;font-weight:700>[derive(Event)]
</span><span>struct MyEvent;
</span><span>
</span><span>// After:
</span><span style=color:#fa6e32;font-weight:700>#</span><span style=color:#399ee6;font-weight:700>[derive(Event, BufferedEvent)]
</span><span>struct MyBufferedEvent;
</span><span>
</span><span style=color:#fa6e32;font-weight:700>#</span><span style=color:#399ee6;font-weight:700>[derive(Event, EntityEvent)]
</span><span>struct MyEntityEvent;
</span></code></pre><h3 id=crates-bevy-window-src-event-rs-24-21><code>crates/bevy_window/src/event.rs</code> (+24/-21)</h3><ul><li>Added <code>BufferedEvent</code> to window events<li>Maintained existing functionality while updating to new trait</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Event)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>WindowResized </span><span>{ ... }
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Event</span><span style=color:#61676ccc>,</span><span> BufferedEvent)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>WindowResized </span><span>{ ... }
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/observer/ target=_blank>Observer System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/rfcs/pull/45 target=_blank>Event System RFC</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/tree/main/examples/ecs/observer_propagation.rs target=_blank>Entity Targeting Examples</a></ul><h2 id=full-code-diff>Full Code Diff</h2><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/benches/benches/bevy_ecs/events/iter.rs b/benches/benches/bevy_ecs/events/iter.rs
</span><span>index dc20bc3395a52..9ad17ed8c8536 100644
</span><span style=color:#c594c5>--- a/benches/benches/bevy_ecs/events/iter.rs
</span><span style=color:#c594c5>+++ b/benches/benches/bevy_ecs/events/iter.rs
</span><span style=color:#c594c5>@@ -1,6 +1,6 @@
</span><span> use bevy_ecs::prelude::*;
</span><span> 
</span><span style=color:#f07171>-#[derive(Event)]
</span><span style=color:#86b300>+#[derive(Event, BufferedEvent)]
</span><span> struct BenchEvent&LTconst SIZE: usize>([u8; SIZE]);
</span><span> 
</span><span> pub struct Benchmark&LTconst SIZE: usize>(Events&LTBenchEvent&LTSIZE>>);
</span><span>diff --git a/benches/benches/bevy_ecs/events/send.rs b/benches/benches/bevy_ecs/events/send.rs
</span><span>index fa996b50aa5d0..be8934e789152 100644
</span><span style=color:#c594c5>--- a/benches/benches/bevy_ecs/events/send.rs
</span><span style=color:#c594c5>+++ b/benches/benches/bevy_ecs/events/send.rs
</span><span style=color:#c594c5>@@ -1,6 +1,6 @@
</span><span> use bevy_ecs::prelude::*;
</span><span> 
</span><span style=color:#f07171>-#[derive(Event)]
</span><span style=color:#86b300>+#[derive(Event, BufferedEvent)]
</span><span> struct BenchEvent&LTconst SIZE: usize>([u8; SIZE]);
</span><span> 
</span><span> impl&LTconst SIZE: usize> Default for BenchEvent&LTSIZE> {
</span><span>diff --git a/benches/benches/bevy_ecs/observers/propagation.rs b/benches/benches/bevy_ecs/observers/propagation.rs
</span><span>index e2be1afed4850..808c3727d5af9 100644
</span><span style=color:#c594c5>--- a/benches/benches/bevy_ecs/observers/propagation.rs
</span><span style=color:#c594c5>+++ b/benches/benches/bevy_ecs/observers/propagation.rs
</span><span style=color:#c594c5>@@ -61,14 +61,10 @@ </span><span style=color:#399ee6>pub fn event_propagation(criterion: &mut Criterion) {
</span><span>     group.finish();
</span><span> }
</span><span> 
</span><span style=color:#f07171>-#[derive(Clone, Component)]
</span><span style=color:#86b300>+#[derive(Event, EntityEvent, Clone, Component)]
</span><span style=color:#86b300>+#[entity_event(traversal = &'static ChildOf, auto_propagate)]
</span><span> struct TestEvent&LTconst N: usize> {}
</span><span> 
</span><span style=color:#f07171>-impl&LTconst N: usize> Event for TestEvent&LTN> {
</span><span style=color:#f07171>-    type Traversal = &'static ChildOf;
</span><span style=color:#f07171>-    const AUTO_PROPAGATE: bool = true;
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span> fn send_events&LTconst N: usize, const N_EVENTS: usize>(world: &mut World, leaves: &[Entity]) {
</span><span>     let target = leaves.iter().choose(&mut rand::thread_rng()).unwrap();
</span><span> 
</span><span>diff --git a/benches/benches/bevy_ecs/observers/simple.rs b/benches/benches/bevy_ecs/observers/simple.rs
</span><span>index b3006ec9249bc..9c26b074e5adf 100644
</span><span style=color:#c594c5>--- a/benches/benches/bevy_ecs/observers/simple.rs
</span><span style=color:#c594c5>+++ b/benches/benches/bevy_ecs/observers/simple.rs
</span><span style=color:#c594c5>@@ -1,7 +1,7 @@
</span><span> use core::hint::black_box;
</span><span> 
</span><span> use bevy_ecs::{
</span><span style=color:#f07171>-    event::Event,
</span><span style=color:#86b300>+    event::{EntityEvent, Event},
</span><span>     observer::{On, TriggerTargets},
</span><span>     world::World,
</span><span> };
</span><span style=color:#c594c5>@@ -13,7 +13,7 @@ </span><span style=color:#399ee6>fn deterministic_rand() -> ChaCha8Rng {
</span><span>     ChaCha8Rng::seed_from_u64(42)
</span><span> }
</span><span> 
</span><span style=color:#f07171>-#[derive(Clone, Event)]
</span><span style=color:#86b300>+#[derive(Clone, Event, EntityEvent)]
</span><span> struct EventBase;
</span><span> 
</span><span> pub fn observe_simple(criterion: &mut Criterion) {
</span><span>diff --git a/crates/bevy_a11y/src/lib.rs b/crates/bevy_a11y/src/lib.rs
</span><span>index f8c46757ddf93..22b2f71f075e9 100644
</span><span style=color:#c594c5>--- a/crates/bevy_a11y/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_a11y/src/lib.rs
</span><span style=color:#c594c5>@@ -26,7 +26,8 @@ </span><span style=color:#399ee6>use accesskit::Node;
</span><span> use bevy_app::Plugin;
</span><span> use bevy_derive::{Deref, DerefMut};
</span><span> use bevy_ecs::{
</span><span style=color:#f07171>-    prelude::{Component, Event},
</span><span style=color:#86b300>+    component::Component,
</span><span style=color:#86b300>+    event::{BufferedEvent, Event},
</span><span>     resource::Resource,
</span><span>     schedule::SystemSet,
</span><span> };
</span><span style=color:#c594c5>@@ -44,7 +45,7 @@ </span><span style=color:#399ee6>use serde::{Deserialize, Serialize};
</span><span> use bevy_reflect::{ReflectDeserialize, ReflectSerialize};
</span><span> 
</span><span> /// Wrapper struct for [`accesskit::ActionRequest`]. Required to allow it to be used as an `Event`.
</span><span style=color:#f07171>-#[derive(Event, Deref, DerefMut)]
</span><span style=color:#86b300>+#[derive(Event, BufferedEvent, Deref, DerefMut)]
</span><span> #[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
</span><span> pub struct ActionRequest(pub accesskit::ActionRequest);
</span><span> 
</span><span>diff --git a/crates/bevy_animation/src/lib.rs b/crates/bevy_animation/src/lib.rs
</span><span>index dd68595961405..ae7ce42ed67a2 100644
</span><span style=color:#c594c5>--- a/crates/bevy_animation/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_animation/src/lib.rs
</span><span style=color:#c594c5>@@ -324,13 +324,13 @@ </span><span style=color:#399ee6>impl AnimationClip {
</span><span>             .push(variable_curve);
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    /// Add a untargeted [`Event`] to this [`AnimationClip`].
</span><span style=color:#86b300>+    /// Add an [`EntityEvent`] with no [`AnimationTarget`] to this [`AnimationClip`].
</span><span>     ///
</span><span>     /// The `event` will be cloned and triggered on the [`AnimationPlayer`] entity once the `time` (in seconds)
</span><span>     /// is reached in the animation.
</span><span>     ///
</span><span>     /// See also [`add_event_to_target`](Self::add_event_to_target).
</span><span style=color:#f07171>-    pub fn add_event(&mut self, time: f32, event: impl Event + Clone) {
</span><span style=color:#86b300>+    pub fn add_event(&mut self, time: f32, event: impl EntityEvent + Clone) {
</span><span>         self.add_event_fn(
</span><span>             time,
</span><span>             move |commands: &mut Commands, entity: Entity, _time: f32, _weight: f32| {
</span><span style=color:#c594c5>@@ -339,7 +339,7 @@ </span><span style=color:#399ee6>impl AnimationClip {
</span><span>         );
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    /// Add an [`Event`] to an [`AnimationTarget`] named by an [`AnimationTargetId`].
</span><span style=color:#86b300>+    /// Add an [`EntityEvent`] to an [`AnimationTarget`] named by an [`AnimationTargetId`].
</span><span>     ///
</span><span>     /// The `event` will be cloned and triggered on the entity matching the target once the `time` (in seconds)
</span><span>     /// is reached in the animation.
</span><span style=color:#c594c5>@@ -349,7 +349,7 @@ </span><span style=color:#399ee6>impl AnimationClip {
</span><span>         &mut self,
</span><span>         target_id: AnimationTargetId,
</span><span>         time: f32,
</span><span style=color:#f07171>-        event: impl Event + Clone,
</span><span style=color:#86b300>+        event: impl EntityEvent + Clone,
</span><span>     ) {
</span><span>         self.add_event_fn_to_target(
</span><span>             target_id,
</span><span style=color:#c594c5>@@ -360,19 +360,19 @@ </span><span style=color:#399ee6>impl AnimationClip {
</span><span>         );
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    /// Add a untargeted event function to this [`AnimationClip`].
</span><span style=color:#86b300>+    /// Add an event function with no [`AnimationTarget`] to this [`AnimationClip`].
</span><span>     ///
</span><span>     /// The `func` will trigger on the [`AnimationPlayer`] entity once the `time` (in seconds)
</span><span>     /// is reached in the animation.
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-06/pr_19647.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>