<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #19058 Initial raytraced lighting progress (bevy_solari)
        
    </title><meta content="#19058 Initial raytraced lighting progress (bevy_solari)" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-06/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-06-12</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-06/pr-19058-zh-cn-20250612>中文</a></div></div><div class=pr-content><h1 id=analysis-of-pr-19058-initial-raytraced-lighting-progress-bevy-solari>Analysis of PR #19058: Initial raytraced lighting progress (bevy_solari)</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Initial raytraced lighting progress (bevy_solari)<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/19058<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, D-Complex, M-Needs-Release-Note, X-Contentious<li><strong>Created</strong>: 2025-05-04T16:56:14Z<li><strong>Merged</strong>: 2025-06-12T21:43:13Z<li><strong>Merged By</strong>: cart</ul><h2 id=description-translation>Description Translation</h2><h1 id=bevy-solari>Bevy Solari</h1><img src=https://github.com/user-attachments/assets/94061fc8-01cf-4208-b72a-8eecad610d76 width=100><h2 id=preface>Preface</h2><ul><li>See release notes.<li>Please talk to me in #rendering-dev on discord or open a github discussion if you have questions about the long term plan, and keep discussion in this PR limited to the contents of the PR :)</ul><h2 id=connections>Connections</h2><ul><li>Works towards #639, #16408.<li>Spawned https://github.com/bevyengine/bevy/issues/18993.<li>Need to fix RT stuff in naga_oil first https://github.com/bevyengine/naga_oil/pull/116.</ul><h2 id=this-pr>This PR</h2><p>After nearly two years, I’ve revived the raytraced lighting effort I first started in https://github.com/bevyengine/bevy/pull/10000.<p>Unlike that PR, which has realtime techniques, I’ve limited this PR to:<ul><li><code>RaytracingScenePlugin</code> - BLAS and TLAS building, geometry and texture binding, sampling functions.<li><code>PathtracingPlugin</code> - A non-realtime path tracer intended to serve as a testbed and reference.</ul><h2 id=what-s-implemented>What’s implemented?</h2><p><img alt=image src=https://github.com/user-attachments/assets/06522007-c205-46eb-8178-823f19917def><ul><li>BLAS building on mesh load<li>Emissive lights<li>Directional lights with soft shadows<li>Diffuse (lambert, not Bevy’s diffuse BRDF) and emissive materials<li>A reference path tracer with: <ul><li>Antialiasing<li>Direct light sampling (next event estimation) with 0/1 MIS weights<li>Importance-sampled BRDF bounces<li>Russian roulette</ul></ul><h2 id=what-s-not-implemented>What’s <em>not</em> implemented?</h2><ul><li>Anything realtime, including a real-time denoiser<li>Integration with Bevy’s rasterized gbuffer<li>Specular materials<li>Non-opaque geometry<li>Any sort of CPU or GPU optimizations <ul><li>BLAS compaction, proper bindless, and further RT APIs are things that we need wgpu to add</ul><li>PointLights, SpotLights, or skyboxes / environment lighting<li>Support for materials other than StandardMaterial (and only a subset of properties are supported)<li>Skinned/morphed or otherwise animating/deformed meshes<li>Mipmaps<li>Adaptive self-intersection ray bias<li>A good way for developers to detect whether the user’s GPU supports RT or not, and fallback to baked lighting.<li>Documentation and actual finalized APIs (literally everything is subject to change)</ul><h2 id=end-user-usage>End-user Usage</h2><ul><li>Have a GPU that supports RT with inline ray queries<li>Add <code>SolariPlugin</code> to your app<li>Ensure any <code>Mesh</code> asset you want to use for raytracing has <code>enable_raytracing: true</code> (defaults to true), and that it uses the standard uncompressed position/normal/uv_0/tangent vertex attribute set, triangle list topology, and 32-bit indices. <ul><li>If you don’t want to build a BLAS and use the mesh for RT, set enable_raytracing to false.</ul><li>Add the <code>RaytracingMesh3d</code> component to your entity (separate from <code>Mesh3d</code> or <code>MeshletMesh3d</code>).</ul><h2 id=testing>Testing</h2><ul><li>Did you test these changes? If so, how? <ul><li>Ran the solari example.</ul><li>Are there any parts that need more testing? <ul><li>Other test scenes probably. Normal mapping would be good to test.</ul><li>How can other people (reviewers) test your changes? Is there anything specific they need to know? <ul><li>See the solari.rs example for how to setup raytracing.</ul><li>If relevant, what platforms did you test these changes on, and are there any important ones you can’t test? <ul><li>Windows 11, NVIDIA RTX 3080.</ul></ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR introduces the foundation for raytraced lighting in Bevy through the new <code>bevy_solari</code> crate. The implementation focuses on building the necessary infrastructure for acceleration structures and provides a non-realtime path tracer as a reference implementation.<h3 id=problem-and-context>Problem and Context</h3><p>Bevy’s existing lighting solutions rely on rasterization techniques, which have inherent limitations in handling complex lighting scenarios like global illumination. Raytraced lighting can provide more realistic results but requires significant GPU capabilities and specialized data structures. The challenge was to create a foundation for raytracing in Bevy that could be built upon in future iterations.<h3 id=solution-approach>Solution Approach</h3><p>The implementation is structured around two main plugins:<ol><li><code>RaytracingScenePlugin</code>: Handles Bottom-Level Acceleration Structure (BLAS) and Top-Level Acceleration Structure (TLAS) creation<li><code>PathtracingPlugin</code>: Provides a reference path tracer for validation</ol><p>The solution uses inline ray queries via WGSL’s ray query API, avoiding full ray tracing pipelines for wider hardware compatibility. Key engineering decisions include:<ul><li>Using acceleration structures compatible with current wgpu capabilities<li>Implementing a mesh flag (<code>enable_raytracing</code>) to control BLAS creation<li>Creating separate components (<code>RaytracingMesh3d</code>) for raytracing-specific data</ul><h3 id=implementation-details>Implementation Details</h3><p>The implementation adds:<ol><li>BLAS management that builds acceleration structures when meshes are loaded<li>TLAS construction that aggregates scene instances<li>Bind group management for GPU resource access<li>A path tracer compute shader for reference rendering</ol><p>Mesh compatibility is enforced through vertex attribute checks:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_mesh_raytracing_compatible</span><span>(</span><span style=color:#ff8f40>mesh</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Mesh) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> triangle_list </span><span style=color:#ed9366>=</span><span> mesh</span><span style=color:#ed9366>.</span><span style=color:#f07171>primitive_topology</span><span>() </span><span style=color:#ed9366>== </span><span>PrimitiveTopology</span><span style=color:#ed9366>::</span><span>TriangleList</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> vertex_attributes </span><span style=color:#ed9366>=</span><span> mesh</span><span style=color:#ed9366>.</span><span style=color:#f07171>attributes</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|(</span><span style=color:#ff8f40>attribute</span><span style=color:#61676ccc>,</span><span> _)| attribute</span><span style=color:#ed9366>.</span><span>id)</span><span style=color:#ed9366>.</span><span style=color:#f07171>eq</span><span>([
</span><span>        Mesh</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_POSITION</span><span style=color:#ed9366>.</span><span>id</span><span style=color:#61676ccc>,
</span><span>        Mesh</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_NORMAL</span><span style=color:#ed9366>.</span><span>id</span><span style=color:#61676ccc>,
</span><span>        Mesh</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_UV_0</span><span style=color:#ed9366>.</span><span>id</span><span style=color:#61676ccc>,
</span><span>        Mesh</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_TANGENT</span><span style=color:#ed9366>.</span><span>id</span><span style=color:#61676ccc>,
</span><span>    ])</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> indexed_32 </span><span style=color:#ed9366>= </span><span style=color:#f07171>matches!</span><span>(mesh</span><span style=color:#ed9366>.</span><span style=color:#f07171>indices</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Indices</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>U32</span><span>(</span><span style=color:#ed9366>..</span><span>)))</span><span style=color:#61676ccc>;
</span><span>    mesh</span><span style=color:#ed9366>.</span><span>enable_raytracing </span><span style=color:#ed9366>&&</span><span> triangle_list </span><span style=color:#ed9366>&&</span><span> vertex_attributes </span><span style=color:#ed9366>&&</span><span> indexed_32
</span><span>}
</span></code></pre><p>The path tracer implements core rendering techniques:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn pathtrace(@builtin(global_invocation_id) global_id: vec3&LTu32>) {
</span><span>    // ... setup RNG, shoot primary ray ...
</span><span>    
</span><span>    // Path tracing loop
</span><span>    var radiance = vec3(0.0);
</span><span>    var throughput = vec3(1.0);
</span><span>    loop {
</span><span>        let ray_hit = trace_ray(ray_origin, ray_direction, ray_t_min, RAY_T_MAX, RAY_FLAG_NONE);
</span><span>        if ray_hit.kind != RAY_QUERY_INTERSECTION_NONE {
</span><span>            // ... evaluate material, sample lighting ...
</span><span>            
</span><span>            // Russian roulette termination
</span><span>            let p = luminance(throughput);
</span><span>            if rand_f(&rng) > p { break; }
</span><span>            throughput /= p;
</span><span>        } else { break; }
</span><span>    }
</span><span>    
</span><span>    // ... accumulate results ...
</span><span>}
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>Key technical aspects include:<ol><li><strong>Acceleration Structures</strong>: Uses BLAS for mesh geometry and TLAS for scene instances<li><strong>Resource Binding</strong>: Creates large bind groups for textures, buffers, and acceleration structures<li><strong>Sampling Techniques</strong>: Implements cosine-weighted hemisphere sampling and light source sampling<li><strong>Material System</strong>: Supports a subset of StandardMaterial properties for raytracing</ol><p>The implementation requires specific GPU features enabled through wgpu:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#399ee6>SolariPlugin </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>required_wgpu_features</span><span>() </span><span style=color:#61676ccc>-></span><span> WgpuFeatures {
</span><span>        WgpuFeatures</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>EXPERIMENTAL_RAY_TRACING_ACCELERATION_STRUCTURE
</span><span>            </span><span style=color:#ed9366>| </span><span>WgpuFeatures</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>EXPERIMENTAL_RAY_QUERY
</span><span>            </span><span style=color:#ed9366>| </span><span>WgpuFeatures</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>BUFFER_BINDING_ARRAY
</span><span>            </span><span style=color:#ed9366>| </span><span>WgpuFeatures</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>TEXTURE_BINDING_ARRAY
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// ... additional features ...
</span><span>    }
</span><span>}
</span></code></pre><h3 id=impact>Impact</h3><p>This PR:<ol><li>Adds foundational infrastructure for future raytraced lighting solutions<li>Provides a reference path tracer for validation and testing<li>Introduces new components and APIs for raytracing-specific data<li>Sets the stage for future realtime global illumination solutions</ol><p>The implementation is explicitly not optimized for realtime use yet, serving instead as a testbed for future development. Key limitations around performance, material support, and hardware compatibility will be addressed in subsequent PRs.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[RaytracingScenePlugin] --> B[BLAS Manager]
</span><span>    A --> C[TLAS Builder]
</span><span>    A --> D[Resource Binder]
</span><span>    E[PathtracingPlugin] --> F[Path Tracer Node]
</span><span>    E --> G[Accumulation Texture]
</span><span>    B --> H[Mesh Processing]
</span><span>    C --> I[Instance Management]
</span><span>    D --> J[Bind Group Creation]
</span><span>    F --> K[Compute Shader]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><code>crates/bevy_solari/src/scene/binder.rs</code> (+366/-0) <ul><li>Manages GPU resource binding for raytracing<li>Creates bind groups for acceleration structures, buffers, and textures<li>Implements material processing for raytracing</ul></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>prepare_raytracing_scene_bindings</span><span>(
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... query parameters ...
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... resource binding logic ...
</span><span>    </span><span style=color:#fa6e32>let</span><span> bind_group </span><span style=color:#ed9366>=</span><span> render_device</span><span style=color:#ed9366>.</span><span style=color:#f07171>create_bind_group</span><span>(
</span><span>        </span><span style=color:#86b300>"raytracing_scene_bind_group"</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>&</span><span>layout</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>&</span><span>BindGroupEntries</span><span style=color:#ed9366>::</span><span>sequential((
</span><span>            vertex_buffers</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_slice</span><span>()</span><span style=color:#61676ccc>,
</span><span>            index_buffers</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_slice</span><span>()</span><span style=color:#61676ccc>,
</span><span>            textures</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_slice</span><span>()</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// ... additional resources ...
</span><span>        ))</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=2><li><code>crates/bevy_solari/src/scene/blas.rs</code> (New File) <ul><li>Manages Bottom-Level Acceleration Structures (BLAS)<li>Processes meshes for raytracing compatibility<li>Handles BLAS creation and updates</ul></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>prepare_raytracing_blas</span><span>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>blas_manager</span><span style=color:#61676ccc>: </span><span>ResMut&LTBlasManager>,
</span><span>    </span><span style=color:#ff8f40>extracted_meshes</span><span style=color:#61676ccc>: </span><span>Res&LTExtractedAssets&LTRenderMesh>>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... other resources ...
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... BLAS management logic ...
</span><span>    </span><span style=color:#fa6e32>let</span><span> blas </span><span style=color:#ed9366>=</span><span> render_device</span><span style=color:#ed9366>.</span><span style=color:#f07171>wgpu_device</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>create_blas</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span>CreateBlasDescriptor { </span><span style=color:#abb0b6;font-style:italic>/* ... */ </span><span>}</span><span style=color:#61676ccc>,
</span><span>        BlasGeometrySizeDescriptors</span><span style=color:#ed9366>::</span><span>Triangles { </span><span style=color:#abb0b6;font-style:italic>/* ... */ </span><span>}</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=3><li><code>crates/bevy_solari/src/pathtracer/node.rs</code> (+134/-0) <ul><li>Implements the path tracer compute node<li>Manages the accumulation texture<li>Dispatches the path tracing compute shader</ul></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>run</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>_graph</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> RenderGraphContext,
</span><span>    </span><span style=color:#ff8f40>render_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> RenderContext,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... query items ...
</span><span>    </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), NodeRunError> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... path tracing implementation ...
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> pass </span><span style=color:#ed9366>=</span><span> command_encoder</span><span style=color:#ed9366>.</span><span style=color:#f07171>begin_compute_pass</span><span>(</span><span style=color:#ed9366>&</span><span>ComputePassDescriptor {
</span><span>        label</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#86b300>"pathtracer"</span><span>)</span><span style=color:#61676ccc>,
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    pass</span><span style=color:#ed9366>.</span><span style=color:#f07171>set_pipeline</span><span>(pipeline)</span><span style=color:#61676ccc>;
</span><span>    pass</span><span style=color:#ed9366>.</span><span style=color:#f07171>set_bind_group</span><span>(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,</span><span> scene_bindings</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>[])</span><span style=color:#61676ccc>;
</span><span>    pass</span><span style=color:#ed9366>.</span><span style=color:#f07171>dispatch_workgroups</span><span>(</span><span style=color:#abb0b6;font-style:italic>/* ... */</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=4><li><code>crates/bevy_mesh/src/mesh.rs</code> (Modification) <ul><li>Adds <code>enable_raytracing</code> flag to Mesh<li>Controls whether BLAS is built for a mesh</ul></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Mesh </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing fields ...
</span><span>    </span><span style=color:#fa6e32>pub </span><span>enable_raytracing</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>}
</span></code></pre><ol start=5><li><code>crates/bevy_solari/src/lib.rs</code> (New File) <ul><li>Main crate entry point<li>Defines plugin structure and required features</ul></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>SolariPlugin</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl </span><span>Plugin </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>SolariPlugin </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>build</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>        app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>((RaytracingScenePlugin</span><span style=color:#61676ccc>,</span><span> PathtracingPlugin))</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/WGSL/#ray-query target=_blank>WGSL Ray Query Specification</a><li><a rel="noopener nofollow noreferrer" href=http://raytracinggems.com/ target=_blank>Ray Tracing Gems</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/rendering/ target=_blank>Bevy Rendering Architecture</a><li><a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/#acceleration-structure target=_blank>WGPU Acceleration Structure API</a></ol><p>This PR establishes the architectural foundation for raytraced lighting in Bevy while explicitly limiting scope to non-realtime applications initially. The implementation provides valuable infrastructure that will enable more advanced realtime solutions in future iterations.</div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-06/pr_19058.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>