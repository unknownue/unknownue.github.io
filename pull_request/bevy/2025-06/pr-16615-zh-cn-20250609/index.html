<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #16615 Specialized UI transform
        
    </title><meta content="#16615 Specialized UI transform" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-06/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-06-09</span><div class=language-switcher><span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=specialized-ui-transform>Specialized UI transform</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Specialized UI transform<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/16615<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, C-Feature, A-Rendering, A-UI, C-Usability, S-Ready-For-Final-Review, A-Animation, A-Transform, M-Needs-Migration-Guide, M-Needs-Release-Note, X-Contentious<li><strong>Created</strong>: 2024-12-02T20:04:19Z<li><strong>Merged</strong>: 2025-06-09T19:24:04Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>添加专门的 UI transform <code>Component</code> 并修复相关问题：<ul><li>通过修改 UI 节点的 <code>Transform</code> 组件来动画化 UI 元素效果不佳，因为 <code>ui_layout_system</code> 每帧都会覆盖 translation 值。<code>overflow_debug</code> 示例使用了一个糟糕的 hack，它将 transform 复制到 position 中，如果用户天真地复制它，很可能会导致 panic。<li>点选（picking）忽略了旋转和缩放，并假设 UI 节点始终是轴对齐的。<li>存储在 <code>CalculatedClip</code> 中的裁剪几何对于旋转和缩放的元素是错误的。<li>变换传播（transform propagation）对于 UI 是不必要的，变换可以在布局更新期间更新。<li>UI 内部同时使用对象中心坐标系和基于左上角的坐标系。根据上下文，有时必须在坐标系之间转换之前添加或减去一半大小。我们应该始终使用一个系统，以便变换可以直接应用。<li><code>Transform</code> 不支持响应式坐标（responsive coordinates）。</ul><h2 id=jie-jue-fang-an>解决方案</h2><ul><li>取消 <code>Node</code> 对 <code>Transform</code> 的要求。<li>新组件 <code>UiTransform</code>, <code>UiGlobalTransform</code>： <ul><li><code>Node</code> 需要 <code>UiTransform</code>，<code>UiTransform</code> 需要 <code>UiGlobalTransform</code><li><code>UiTransform</code> 是 <code>Transform</code> 的纯 2D 等效物，其 translation 使用 <code>Val</code>。<li><code>UiGlobalTransform</code> 是 <code>Affine2</code> 的新类型（newtype），在 <code>ui_layout_system</code> 中更新。</ul><li><code>ComputedNode</code> 上新增辅助函数，用于在视口空间和本地节点空间之间映射。<li>在点选过程中，光标位置会转换到本地节点空间，以支持旋转和缩放。<li>为了检查光标是否悬停在节点上，递归向上遍历树，检查是否有任何祖先节点裁剪光标处的点。如果点被裁剪，则忽略交互。<li>对 UI 节点使用对象中心坐标系。<li><code>RelativeCursorPosition</code> 的坐标现在是对象中心的，(0,0) 在节点中心，角落位于 (±0.5, ±0.5)。<li>将 <code>RelativeCursorPosition</code> 的 <code>normalized_visible_node_rect: Rect</code> 字段替换为 <code>cursor_over: bool</code>，当光标在节点的未裁剪点上时为 true。节点的可见区域不一定是矩形，因此先前的实现无效。</ul><p>这应该修复所有与非轴对齐交互和裁剪相关的逻辑错误。渲染仍然需要更改，但这超出了本 PR 的范围。<p>尝试并放弃了另外两种方法：<ul><li><code>Node</code> 上的新 <code>transform</code> 字段，<code>Node</code> 需要 <code>GlobalTransform</code>，并取消 <code>Node</code> 对 <code>Transform</code> 的要求。取消 <code>Transform</code> 要求会退出变换传播，因此与在 <code>ui_layout_system</code> 中更新 <code>GlobalTransform</code> 没有冲突。这个改动在简单性上很好，但我认为对用户来说可能令人困惑，所有 <code>GlobalTransform</code> 文档都提到 <code>Transform</code>，仅为 UI 设置特殊规则更新方式令人不快地出乎意料。<li><code>Node</code> 上的新 <code>transform</code> 字段。取消 <code>Node</code> 对 <code>Transform</code> 的要求。<code>ComputedNode</code> 上的新 <code>transform: Affine2</code> 字段。 这样也可以，但我认为大多数用户希望有单独的专用 UI 变换组件。臃肿的 <code>ComputedNode</code> 与变更检测配合不佳。</ul><p>修复 #18929, #18930<h2 id=ce-shi>测试</h2><p>有一个示例可以参考：<pre style=color:#61676c;background-color:#fafafa><code><span>cargo run --example ui_transform
</span></code></pre><p>有时在示例中，如果多次按下旋转按钮，顶部标签的第一个字形会消失，我还不确定是什么原因，但我认为与本 PR 无关。<h2 id=qian-yi-zhi-nan>迁移指南</h2><p>新的专用 2D UI 变换组件 <code>UiTransform</code> 和 <code>UiGlobalTransform</code>。<code>UiTransform</code> 是 <code>Transform</code> 的纯 2D 等效物，其 translation 使用 <code>Val</code>。<code>UiGlobalTransform</code> 是 <code>Affine2</code> 的新类型（newtype），在 <code>ui_layout_system</code> 中更新。 <code>Node</code> 现在需要 <code>UiTransform</code> 而不是 <code>Transform</code>。<code>UiTransform</code> 需要 <code>UiGlobalTransform</code>。<p>在 Bevy 的先前版本中，<code>ui_layout_system</code> 每帧都会覆盖 UI 节点的 <code>Transform::translation</code>。<code>UiTransform</code> 不会被覆盖，不再需要缓存和重写平移 UI 元素的变换的系统。<p><code>RelativeCursorPosition</code> 的坐标现在是对象中心的，(0,0) 在节点中心，角落位于 (±0.5, ±0.5)。其 <code>normalized_visible_node_rect</code> 字段已被移除，并替换为新的 <code>cursor_over: bool</code> 字段，当光标悬停在 UI 节点的未裁剪区域上时设置为 true。<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=wen-ti-yu-bei-jing>问题与背景</h3><p>Bevy UI 系统在处理变换（平移、旋转、缩放）时存在几个核心问题：<ol><li>布局系统每帧覆盖 <code>Transform</code> 的平移值，导致动画实现困难<li>点选系统忽略旋转和缩放，假设 UI 总是轴对齐<li>裁剪计算在旋转/缩放后不正确<li>UI 节点同时使用对象中心和左上角坐标系，导致变换应用不一致<li>现有的 <code>Transform</code> 组件不支持响应式坐标（如百分比）</ol><p>这些问题在用户尝试创建非轴对齐 UI 或实现复杂动画时尤其明显。例如，<code>overflow_debug</code> 示例不得不使用 hack 来绕过布局系统对变换的覆盖。<h3 id=jie-jue-fang-an-fang-fa>解决方案方法</h3><p>开发者采用了专用 UI 变换组件的方案：<ol><li>引入 <code>UiTransform</code> - 纯 2D 变换组件，支持响应式坐标<li>引入 <code>UiGlobalTransform</code> - 存储计算后的 <code>Affine2</code> 变换<li>重构布局系统直接在布局更新中计算全局变换<li>统一使用对象中心坐标系<li>重写点选和裁剪系统以支持任意变换</ol><p>替代方案考虑：<ul><li>在 <code>Node</code> 中添加 <code>transform</code> 字段并使用 <code>GlobalTransform</code>：被否决，因与现有 <code>Transform</code> 文档冲突<li>在 <code>ComputedNode</code> 中添加 <code>Affine2</code> 字段：被否决，因组件臃肿且变更检测困难</ul><h3 id=shi-xian-xi-jie>实现细节</h3><p>核心实现在 <code>ui_transform.rs</code> 中定义新组件：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>UiTransform </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>translation</span><span style=color:#61676ccc>:</span><span> Val2, </span><span style=color:#abb0b6;font-style:italic>// 响应式平移
</span><span>    </span><span style=color:#fa6e32>pub </span><span>scale</span><span style=color:#61676ccc>:</span><span> Vec2,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>rotation</span><span style=color:#61676ccc>:</span><span> Rot2,    </span><span style=color:#abb0b6;font-style:italic>// 纯 2D 旋转
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>UiGlobalTransform</span><span>(Affine2)</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 计算后的全局变换
</span></code></pre><p>布局系统 (<code>layout/mod.rs</code>) 改为直接计算全局变换：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 计算局部变换
</span><span style=color:#fa6e32>let mut</span><span> local_transform </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>compute_affine</span><span>(inverse_target_scale_factor</span><span style=color:#61676ccc>,</span><span> layout_size</span><span style=color:#61676ccc>,</span><span> target_size)</span><span style=color:#61676ccc>;
</span><span>local_transform</span><span style=color:#ed9366>.</span><span>translation </span><span style=color:#ed9366>+=</span><span> local_center</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 累积全局变换
</span><span>inherited_transform </span><span style=color:#ed9366>*=</span><span> local_transform</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 更新 UiGlobalTransform
</span><span style=color:#fa6e32>if</span><span> inherited_transform </span><span style=color:#ed9366>!= **</span><span>global_transform {
</span><span>    </span><span style=color:#ed9366>*</span><span>global_transform </span><span style=color:#ed9366>=</span><span> inherited_transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>点选系统 (<code>focus.rs</code>) 现在正确处理变换：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> contains_cursor </span><span style=color:#ed9366>=</span><span> cursor_position</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some_and</span><span>(|</span><span style=color:#ff8f40>point</span><span>| {
</span><span>    node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains_point</span><span>(</span><span style=color:#ed9366>*</span><span>node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>point)
</span><span>        </span><span style=color:#ed9366>&& </span><span style=color:#f07171>clip_check_recursive</span><span>(</span><span style=color:#ed9366>*</span><span>point</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>entity</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>clipping_query</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>child_of_query)
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p>新增 <code>clip_check_recursive</code> 函数递归检查裁剪：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>clip_check_recursive</span><span>(...) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(child_of) </span><span style=color:#ed9366>=</span><span> child_of_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(entity) {
</span><span>        </span><span style=color:#fa6e32>let</span><span> parent </span><span style=color:#ed9366>=</span><span> child_of</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>((computed_node</span><span style=color:#61676ccc>,</span><span> transform</span><span style=color:#61676ccc>,</span><span> node)) </span><span style=color:#ed9366>=</span><span> clipping_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(parent) {
</span><span>            </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>computed_node</span><span style=color:#ed9366>.</span><span style=color:#f07171>resolve_clip_rect</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(</span><span style=color:#ed9366>...</span><span>) {
</span><span>                </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#f07171>clip_check_recursive</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#ff8f40>true
</span><span>}
</span></code></pre><h3 id=ji-shu-dong-cha>技术洞察</h3><p>关键实现点：<ol><li><strong>坐标系统一</strong>：所有 UI 元素现在使用对象中心坐标系，简化了变换应用<li><strong>响应式平移</strong>：<code>Val2</code> 支持基于百分比和像素的混合定位<li><strong>变换计算</strong>：布局期间直接计算 <code>Affine2</code>，避免冗余的变换传播<li><strong>点选优化</strong>：使用仿射逆变换将光标转换到局部空间</ol><p>性能考虑：<ul><li>避免每帧完整变换传播<li>使用 <code>Affine2</code> 比完整的 3D 变换更轻量<li>递归裁剪检查针对 UI 树结构优化</ul><h3 id=ying-xiang>影响</h3><ol><li><strong>功能改进</strong>： <ul><li>支持旋转/缩放的 UI 元素<li>正确的点选和裁剪<li>响应式平移支持</ul><li><strong>API 变化</strong>： <ul><li><code>Node</code> 现在需要 <code>UiTransform</code> 而非 <code>Transform</code><li><code>RelativeCursorPosition</code> 坐标语义改变</ul><li><strong>性能</strong>：移除不必要的变换传播，优化点选计算<li><strong>迁移路径</strong>：提供清晰的迁移指南和示例</ol><p>技术启示：<ul><li>专用组件比通用方案更适合领域特定需求<li>仿射变换在 2D UI 中比完整 3D 变换更高效<li>递归检查在处理层次化 UI 时更可靠</ul><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[UiTransform] --> B[UiGlobalTransform]
</span><span>    B --> C[ui_layout_system]
</span><span>    C --> D[ComputedNode]
</span><span>    D --> E[Render System]
</span><span>    D --> F[Picking System]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=examples-ui-ui-transform-rs-302-0><code>examples/ui/ui_transform.rs</code> (+302/-0)</h3><p>新增示例展示 UI 变换功能：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 创建带旋转的按钮
</span><span>parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>    Button</span><span style=color:#61676ccc>,
</span><span>    UiTransform {
</span><span>        rotation</span><span style=color:#61676ccc>: </span><span>Rot2</span><span style=color:#ed9366>::</span><span>radians(</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>FRAC_PI_2</span><span>)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#f07171>children!</span><span>[(Text</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#86b300>"Left"</span><span>)</span><span style=color:#61676ccc>,</span><span> TextColor(Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>BLACK</span><span>)</span><span style=color:#61676ccc>,</span><span>]
</span><span>))</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 旋转按钮系统
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>button_system</span><span>(..., </span><span style=color:#ff8f40>maybe_rotate</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>RotateButton>, ...) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(step) </span><span style=color:#ed9366>=</span><span> maybe_rotate {
</span><span>        </span><span style=color:#fa6e32>for mut</span><span> transform </span><span style=color:#ed9366>in</span><span> rotator_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>            transform</span><span style=color:#ed9366>.</span><span>rotation </span><span style=color:#ed9366>*=</span><span> step</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>该示例演示了如何创建可旋转、缩放的 UI 元素，以及如何通过按钮控制它们。<h3 id=crates-bevy-ui-src-ui-transform-rs-191-0><code>crates/bevy_ui/src/ui_transform.rs</code> (+191/-0)</h3><p>定义新组件和功能：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 响应式平移组件
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Val2 </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>x</span><span style=color:#61676ccc>:</span><span> Val,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>y</span><span style=color:#61676ccc>:</span><span> Val,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// UI 专用变换组件
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>UiTransform </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>translation</span><span style=color:#61676ccc>:</span><span> Val2,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>scale</span><span style=color:#61676ccc>:</span><span> Vec2,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>rotation</span><span style=color:#61676ccc>:</span><span> Rot2,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 全局变换组件
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>UiGlobalTransform</span><span>(Affine2)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 计算仿射变换
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>UiTransform </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>compute_affine</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, ...) </span><span style=color:#61676ccc>-></span><span> Affine2 {
</span><span>        Affine2</span><span style=color:#ed9366>::</span><span>from_scale_angle_translation(
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>scale</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>rotation</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_radians</span><span>()</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>translation</span><span style=color:#ed9366>.</span><span style=color:#f07171>resolve</span><span>(</span><span style=color:#ed9366>...</span><span>)
</span><span>        )
</span><span>    }
</span><span>}
</span></code></pre><p>该文件提供了 UI 专用变换的核心实现，支持响应式坐标和高效变换计算。<h3 id=crates-bevy-ui-src-render-mod-rs-47-53><code>crates/bevy_ui/src/render/mod.rs</code> (+47/-53)</h3><p>适配渲染系统使用新变换：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 更新顶点位置计算
</span><span style=color:#fa6e32>let</span><span> positions </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>QUAD_VERTEX_POSITIONS</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>pos</span><span>| {
</span><span>    transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>transform_point2</span><span>(pos </span><span style=color:#ed9366>*</span><span> rect_size)</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(</span><span style=color:#ff8f40>0.</span><span>)
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 更新边界计算
</span><span style=color:#fa6e32>let</span><span> transformed_rect_size </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>transform_vector2</span><span>(rect_size)</span><span style=color:#61676ccc>;
</span></code></pre><p>渲染系统现在使用 <code>Affine2</code> 变换，避免不必要的 3D 矩阵计算。<h3 id=crates-bevy-ui-src-focus-rs-28-63><code>crates/bevy_ui/src/focus.rs</code> (+28/-63)</h3><p>重构点选系统：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 相对光标位置新结构
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>RelativeCursorPosition </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>cursor_over</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>normalized</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTVec2>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 点选检查逻辑
</span><span style=color:#fa6e32>let</span><span> contains_cursor </span><span style=color:#ed9366>=</span><span> cursor_position</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some_and</span><span>(|</span><span style=color:#ff8f40>point</span><span>| {
</span><span>    node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains_point</span><span>(</span><span style=color:#ed9366>*</span><span>node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>point)
</span><span>        </span><span style=color:#ed9366>&& </span><span style=color:#f07171>clip_check_recursive</span><span>(</span><span style=color:#ed9366>*</span><span>point</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>entity</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>clipping_query</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>child_of_query)
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p>点选系统现在正确处理变换后的 UI 元素，并使用新的对象中心坐标系。<h3 id=crates-bevy-ui-src-ui-node-rs-72-3><code>crates/bevy_ui/src/ui_node.rs</code> (+72/-3)</h3><p>增强 <code>ComputedNode</code> 功能：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#399ee6>ComputedNode </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 检查点是否在节点内（考虑变换）
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>contains_point</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>transform</span><span style=color:#61676ccc>:</span><span> UiGlobalTransform, </span><span style=color:#ff8f40>point</span><span style=color:#61676ccc>:</span><span> Vec2) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// SDF 算法实现
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 解析裁剪矩形
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>resolve_clip_rect</span><span>(...) </span><span style=color:#61676ccc>-></span><span> Rect {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 考虑溢出和裁剪边距
</span><span>    }
</span><span>}
</span></code></pre><p>这些新增方法使点选和裁剪系统能正确处理变换后的 UI 元素。<h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Affine_transformation target=_blank>Affine Transformations - Wikipedia</a><li><a rel="noopener nofollow noreferrer" href=https://learnopengl.com/Getting-started/Coordinate-Systems target=_blank>Coordinate Systems in Graphics Programming</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ui/latest/bevy_ui/ target=_blank>Bevy UI Documentation</a></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-06/pr_16615.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>