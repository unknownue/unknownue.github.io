<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #19608 Make observers metadata / storage publicly visible
        
    </title><meta content="#19608 Make observers metadata / storage publicly visible" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-06/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-06-16</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-06/pr-19608-zh-cn-20250616>中文</a></div></div><div class=pr-content><h1 id=make-observers-metadata-storage-publicly-visible>Make observers metadata / storage publicly visible</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Make observers metadata / storage publicly visible<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/19608<li><strong>Author</strong>: alice-i-cecile<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Usability, S-Ready-For-Final-Review, X-Contentious, D-Straightforward<li><strong>Created</strong>: 2025-06-13T01:01:37Z<li><strong>Merged</strong>: 2025-06-16T22:20:39Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description>Description</h2><h3 id=objective>Objective</h3><p>Our strategy for storing observers is made up of several moving parts, which are ultimately fairly simple nested HashMaps.<p>These types are currently <code>pub</code>, but lack any meaningful way to access this data.<p>We have three options here:<ol><li>Make these internals not <code>pub</code> at all.<li>Make the data read-only accessible.<li>Make the data mutably accessible.</ol><h3 id=solution>Solution</h3><p>I’ve opted for option 2, exposing read-only values. This is consistent with our existing approach to the ECS internals, allowing for easier debugging without risking wanton data corruption. If one day you would like to mutably access this data, please open an issue clearly explaining what you’re trying to do.<p>This was a pretty mechanical change, exposing fields via getters. I’ve also opted to do my best to clarify some field names and documentation: please double-check those for correctness. It was hard to be fully confident, as the field names and documentation was not very clear ;)<h3 id=testing>Testing</h3><p>I spent some time going through the code paths, making sure that users can trace all the way from <code>World</code> to the leaf nodes. Reviewers, please ensure the same!<h3 id=notes-for-reviewers>Notes for reviewers</h3><p>This is part of a broader observer overhaul: I fully expect us to change up these internals and break these shiny new APIs. Probably even within the same cycle!<p>But clean up your work area first: this sort of read-only getter and improved docs will be important to replace as we work.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The PR addresses a structural issue in Bevy’s ECS observer system. Observer metadata was publicly visible but inaccessible due to missing access methods. The current implementation used nested HashMaps to organize observers by event type, component, and entity, but these data structures couldn’t be inspected externally. This created debugging difficulties since developers couldn’t examine the observer state during development or troubleshooting.<p>The author evaluated three approaches: fully privatizing the internals, exposing read-only access, or enabling mutable access. Read-only access was selected as it maintains consistency with Bevy’s existing ECS internals strategy. This approach provides debugging visibility without risking accidental data corruption that mutable access could introduce. The author explicitly noted that if mutable access becomes necessary in the future, it should be proposed through a separate issue with clear use case justification.<p>The implementation involved mechanical changes across three key areas. First, internal field names were clarified to better reflect their purpose - <code>map</code> became <code>global_observers</code>, and <code>entity_map</code> became <code>entity_component_observers</code>. These naming improvements enhance code readability and reduce cognitive load when working with the observer system. Second, public getter methods were added to expose the data in a read-only manner. Finally, a new public method was added to the <code>World</code> struct to provide access to the observers container.<p>The changes maintain encapsulation while providing necessary visibility. For example, the <code>CachedComponentObservers</code> struct now provides two access methods:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>global_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>ObserverMap {
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>global_observers
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>entity_component_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>EntityHashMap&LTObserverMap> {
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>entity_component_observers
</span><span>}
</span></code></pre><p>Similarly, the <code>CachedObservers</code> struct gained three accessors:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>global_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>ObserverMap {
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>global_observers
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get_component_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>HashMap&LTComponentId, CachedComponentObservers> {
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>component_observers
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>entity_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>HashMap&LTComponentId, CachedComponentObservers> {
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>component_observers
</span><span>}
</span></code></pre><p>The <code>try_get_observers</code> method was made public with added documentation clarifying its usage, particularly for lifecycle events:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Attempts to get the observers for the given `event_type`.
</span><span style=color:#abb0b6;font-style:italic>///
</span><span style=color:#abb0b6;font-style:italic>/// When accessing the observers for lifecycle events, such as [`Add`], [`Insert`], [`Replace`], [`Remove`], and [`Despawn`],
</span><span style=color:#abb0b6;font-style:italic>/// use the [`ComponentId`] constants from the [`lifecycle`](crate::lifecycle) module.
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>try_get_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>event_type</span><span style=color:#61676ccc>:</span><span> ComponentId) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>CachedObservers> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... implementation ...
</span><span>}
</span></code></pre><p>To complete the access pathway, the <code>World</code> struct gained a new public method:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Retrieves this world's [`Observers`] list
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>Observers {
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>observers
</span><span>}
</span></code></pre><p>The author noted that these changes are likely temporary, as they’re part of a larger observer system overhaul. However, the current improvements establish a foundation for future work by cleaning up naming and providing basic introspection capabilities. The changes are non-breaking and maintain existing functionality while improving debuggability.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    World -->|observers()| Observers
</span><span>    Observers -->|try_get_observers()| CachedObservers
</span><span>    CachedObservers -->|global_observers()| ObserverMap
</span><span>    CachedObservers -->|get_component_observers()| CachedComponentObservers
</span><span>    CachedObservers -->|entity_observers()| EntityHashMap
</span><span>    CachedComponentObservers -->|global_observers()| ObserverMap
</span><span>    CachedComponentObservers -->|entity_component_observers()| EntityHashMap
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-observer-mod-rs-79-26>crates/bevy_ecs/src/observer/mod.rs (+79/-26)</h3><p>This file contains the core observer storage structures. The changes include:<ol><li>Renamed internal fields for clarity<li>Added public getter methods for read-only access<li>Made <code>ObserverMap</code> public<li>Added documentation for public methods</ol><p>Key changes in struct definitions:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>CachedComponentObservers </span><span>{
</span><span>    map</span><span style=color:#61676ccc>:</span><span> ObserverMap,
</span><span>    entity_map</span><span style=color:#61676ccc>: </span><span>EntityHashMap&LTObserverMap>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>CachedObservers </span><span>{
</span><span>    map</span><span style=color:#61676ccc>:</span><span> ObserverMap,
</span><span>    component_observers</span><span style=color:#61676ccc>: </span><span>HashMap&LTComponentId, CachedComponentObservers>,
</span><span>    entity_observers</span><span style=color:#61676ccc>: </span><span>EntityHashMap&LTObserverMap>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>CachedComponentObservers </span><span>{
</span><span>    global_observers</span><span style=color:#61676ccc>:</span><span> ObserverMap,
</span><span>    entity_component_observers</span><span style=color:#61676ccc>: </span><span>EntityHashMap&LTObserverMap>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>CachedObservers </span><span>{
</span><span>    global_observers</span><span style=color:#61676ccc>:</span><span> ObserverMap,
</span><span>    component_observers</span><span style=color:#61676ccc>: </span><span>HashMap&LTComponentId, CachedComponentObservers>,
</span><span>    entity_observers</span><span style=color:#61676ccc>: </span><span>EntityHashMap&LTObserverMap>,
</span><span>}
</span></code></pre><p>New public methods:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#399ee6>CachedComponentObservers </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>global_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>ObserverMap { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>entity_component_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>EntityHashMap&LTObserverMap> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>CachedObservers </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>global_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>ObserverMap { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get_component_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>HashMap&LTComponentId, CachedComponentObservers> { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>entity_observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>HashMap&LTComponentId, CachedComponentObservers> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-observer-entity-observer-rs-5-3>crates/bevy_ecs/src/observer/entity_observer.rs (+5/-3)</h3><p>Minor updates to use new field names and method:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> observers </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span>observers</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_observers</span><span>(event_type)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(map) </span><span style=color:#ed9366>=</span><span> observers</span><span style=color:#ed9366>.</span><span>entity_map</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>source)</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>() {
</span><span>    observers</span><span style=color:#ed9366>.</span><span>entity_map</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(target</span><span style=color:#61676ccc>,</span><span> map)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> observers </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span>observers</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_observers_mut</span><span>(event_type)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(map) </span><span style=color:#ed9366>=</span><span> observers</span><span style=color:#ed9366>.</span><span>entity_component_observers</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>source)</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>() {
</span><span>    observers</span><span style=color:#ed9366>.</span><span>entity_component_observers</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(target</span><span style=color:#61676ccc>,</span><span> map)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-world-mod-rs-6-0>crates/bevy_ecs/src/world/mod.rs (+6/-0)</h3><p>Added public accessor to world’s observers:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#399ee6>World </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Retrieves this world's [`Observers`] list
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>observers</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>Observers {
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>observers
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/observer/index.html target=_blank>Bevy ECS Observer System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Entity_component_system target=_blank>Entity Component System Pattern</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/std/collections/struct.HashMap.html target=_blank>Rust HashMap Documentation</a></ol><h1 id=full-code-diff>Full Code Diff</h1><details><summary>View full diff</summary> <pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_ecs/src/observer/entity_observer.rs b/crates/bevy_ecs/src/observer/entity_observer.rs
</span><span>index 5530b1f0fc1e5..23be0e9672248 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/observer/entity_observer.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/observer/entity_observer.rs
</span><span style=color:#c594c5>@@ -97,7 +97,7 @@ </span><span style=color:#399ee6>fn component_clone_observed_by(_source: &SourceComponent, ctx: &mut ComponentClo
</span><span>             let event_types = observer_state.descriptor.events.clone();
</span><span>             let components = observer_state.descriptor.components.clone();
</span><span>             for event_type in event_types {
</span><span style=color:#f07171>-                let observers = world.observers.get_observers(event_type);
</span><span style=color:#86b300>+                let observers = world.observers.get_observers_mut(event_type);
</span><span>                 if components.is_empty() {
</span><span>                     if let Some(map) = observers.entity_observers.get(&source).cloned() {
</span><span>                         observers.entity_observers.insert(target, map);
</span><span style=color:#c594c5>@@ -108,8 +108,10 @@ </span><span style=color:#399ee6>fn component_clone_observed_by(_source: &SourceComponent, ctx: &mut ComponentClo
</span><span>                         else {
</span><span>                             continue;
</span><span>                         };
</span><span style=color:#f07171>-                        if let Some(map) = observers.entity_map.get(&source).cloned() {
</span><span style=color:#f07171>-                            observers.entity_map.insert(target, map);
</span><span style=color:#86b300>+                        if let Some(map) =
</span><span style=color:#86b300>+                            observers.entity_component_observers.get(&source).cloned()
</span><span style=color:#86b300>+                        {
</span><span style=color:#86b300>+                            observers.entity_component_observers.insert(target, map);
</span><span>                         }
</span><span>                     }
</span><span>                 }
</span><span>diff --git a/crates/bevy_ecs/src/observer/mod.rs b/crates/bevy_ecs/src/observer/mod.rs
</span><span>index 4db65b888d6a2..b3a8b3b5cd2c7 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/observer/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/observer/mod.rs
</span><span style=color:#c594c5>@@ -515,40 +515,72 @@ </span><span style=color:#399ee6>impl ObserverTrigger {
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-// Map between an observer entity and its runner
</span><span style=color:#f07171>-type ObserverMap = EntityHashMap&LTObserverRunner>;
</span><span style=color:#86b300>+/// Map between an observer entity and its [`ObserverRunner`]
</span><span style=color:#86b300>+pub type ObserverMap = EntityHashMap&LTObserverRunner>;
</span><span> 
</span><span style=color:#f07171>-/// Collection of [`ObserverRunner`] for [`Observer`] registered to a particular trigger targeted at a specific component.
</span><span style=color:#86b300>+/// Collection of [`ObserverRunner`] for [`Observer`] registered to a particular event targeted at a specific component.
</span><span> ///
</span><span> /// This is stored inside of [`CachedObservers`].
</span><span> #[derive(Default, Debug)]
</span><span> pub struct CachedComponentObservers {
</span><span style=color:#f07171>-    // Observers listening to triggers targeting this component
</span><span style=color:#f07171>-    map: ObserverMap,
</span><span style=color:#f07171>-    // Observers listening to triggers targeting this component on a specific entity
</span><span style=color:#f07171>-    entity_map: EntityHashMap&LTObserverMap>,
</span><span style=color:#86b300>+    // Observers listening to events targeting this component, but not a specific entity
</span><span style=color:#86b300>+    global_observers: ObserverMap,
</span><span style=color:#86b300>+    // Observers listening to events targeting this component on a specific entity
</span><span style=color:#86b300>+    entity_component_observers: EntityHashMap&LTObserverMap>,
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Collection of [`ObserverRunner`] for [`Observer`] registered to a particular trigger.
</span><span style=color:#86b300>+impl CachedComponentObservers {
</span><span style=color:#86b300>+    /// Returns the observers listening for this trigger, regardless of target.
</span><span style=color:#86b300>+    /// These observers will also respond to events targeting specific entities.
</span><span style=color:#86b300>+    pub fn global_observers(&self) -> &ObserverMap {
</span><span style=color:#86b300>+        &self.global_observers
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    /// Returns the observers listening for this trigger targeting this component on a specific entity.
</span><span style=color:#86b300>+    pub fn entity_component_observers(&self) -> &EntityHashMap&LTObserverMap> {
</span><span style=color:#86b300>+        &self.entity_component_observers
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+/// Collection of [`ObserverRunner`] for [`Observer`] registered to a particular event.
</span><span> ///
</span><span> /// This is stored inside of [`Observers`], specialized for each kind of observer.
</span><span> #[derive(Default, Debug)]
</span><span> pub struct CachedObservers {
</span><span style=color:#f07171>-    // Observers listening for any time this trigger is fired
</span><span style=color:#f07171>-    map: ObserverMap,
</span><span style=color:#86b300>+    // Observers listening for any time this event is fired, regardless of target
</span><span style=color:#86b300>+    // This will also respond to events targeting specific components or entities
</span><span style=color:#86b300>+    global_observers: ObserverMap,
</span><span>     // Observers listening for this trigger fired at a specific component
</span><span>     component_observers: HashMap&LTComponentId, CachedComponentObservers>,
</span><span>     // Observers listening for this trigger fired at a specific entity
</span><span>     entity_observers: EntityHashMap&LTObserverMap>,
</span><span> }
</span><span> 
</span><span style=color:#86b300>+impl CachedObservers {
</span><span style=color:#86b300>+    /// Returns the observers listening for this trigger, regardless of target.
</span><span style=color:#86b300>+    /// These observers will also respond to events targeting specific components or entities.
</span><span style=color:#86b300>+    pub fn global_observers(&self) -> &ObserverMap {
</span><span style=color:#86b300>+        &self.global_observers
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    /// Returns the observers listening for this trigger targeting components.
</span><span style=color:#86b300>+    pub fn get_component_observers(&self) -> &HashMap&LTComponentId, CachedComponentObservers> {
</span><span style=color:#86b300>+        &self.component_observers
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    /// Returns the observers listening for this trigger targeting entities.
</span><span style=color:#86b300>+    pub fn entity_observers(&self) -> &HashMap&LTComponentId, CachedComponentObservers> {
</span><span style=color:#86b300>+        &self.component_observers
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span> /// An internal lookup table tracking all of the observers in the world.
</span><span> ///
</span><span> /// Stores a cache mapping trigger ids to the registered observers.
</span><span> /// Some observer kinds (like [lifecycle](crate::lifecycle) observers) have a dedicated field,
</span><span> /// saving lookups for the most common triggers.
</span><span> ///
</span><span style=color:#f07171>-/// This is stored as a field of the [`World`].
</span><span style=color:#86b300>+/// This can be accessed via [`World::observers`].
</span><span> #[derive(Default, Debug)]
</span><span> pub struct Observers {
</span><span>     // Cached ECS observers to save a lookup most common triggers.
</span><span style=color:#c594c5>@@ -562,7 +594,7 @@ </span><span style=color:#399ee6>pub struct Observers {
</span><span> }
</span><span> 
</span><span> impl Observers {
</span><span style=color:#f07171>-    pub(crate) fn get_observers(&mut self, event_type: ComponentId) -> &mut CachedObservers {
</span><span style=color:#86b300>+    pub(crate) fn get_observers_mut(&mut self, event_type: ComponentId) -> &mut CachedObservers {
</span><span>         use crate::lifecycle::*;
</span><span> 
</span><span>         match event_type {
</span><span style=color:#c594c5>@@ -575,7 +607,11 @@ </span><span style=color:#399ee6>impl Observers {
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    pub(crate) fn try_get_observers(&self, event_type: ComponentId) -> Option<&CachedObservers> {
</span><span style=color:#86b300>+    /// Attempts to get the observers for the given `event_type`.
</span><span style=color:#86b300>+    ///
</span><span style=color:#86b300>+    /// When accessing the observers for lifecycle events, such as [`Add`], [`Insert`], [`Replace`], [`Remove`], and [`Despawn`],
</span><span style=color:#86b300>+    /// use the [`ComponentId`] constants from the [`lifecycle`](crate::lifecycle) module.
</span><span style=color:#86b300>+    pub fn try_get_observers(&self, event_type: ComponentId) -> Option<&CachedObservers> {
</span><span>         use crate::lifecycle::*;
</span><span> 
</span><span>         match event_type {
</span><span style=color:#c594c5>@@ -630,7 +666,10 @@ </span><span style=color:#399ee6>impl Observers {
</span><span>             );
</span><span>         };
</span><span>         // Trigger observers listening for any kind of this trigger
</span><span style=color:#f07171>-        observers.map.iter().for_each(&mut trigger_observer);
</span><span style=color:#86b300>+        observers
</span><span style=color:#86b300>+            .global_observers
</span><span style=color:#86b300>+            .iter()
</span><span style=color:#86b300>+            .for_each(&mut trigger_observer);
</span><span> 
</span><span>         // Trigger entity observers listening for this kind of trigger
</span><span>         if let Some(target_entity) = current_target {
</span><span style=color:#c594c5>@@ -643,12 +682,15 @@ </span><span style=color:#399ee6>impl Observers {
</span><span>         trigger_for_components.for_each(|id| {
</span><span>             if let Some(component_observers) = observers.component_observers.get(&id) {
</span><span>                 component_observers
</span><span style=color:#f07171>-                    .map
</span><span style=color:#86b300>+                    .global_observers
</span><span>                     .iter()
</span><span>                     .for_each(&mut trigger_observer);
</span><span> 
</span><span>                 if let Some(target_entity) = current_target {
</span><span style=color:#f07171>-                    if let Some(map) = component_observers.entity_map.get(&target_entity) {
</span><span style=color:#86b300>+                    if let Some(map) = component_observers
</span><span style=color:#86b300>+                        .entity_component_observers
</span><span style=color:#86b300>+                        .get(&target_entity)
</span><span style=color:#86b300>+                    {
</span><span>                         map.iter().for_each(&mut trigger_observer);
</span><span>                     }
</span><span>                 }
</span><span style=color:#c594c5>@@ -926,10 +968,12 @@ </span><span style=color:#399ee6>impl World {
</span><span>         let descriptor = &observer_state.descriptor;
</span><span> 
</span><span>         for &event_type in &descriptor.events {
</span><span style=color:#f07171>-            let cache = observers.get_observers(event_type);
</span><span style=color:#86b300>+            let cache = observers.get_observers_mut(event_type);
</span><span> 
</span><span>             if descriptor.components.is_empty() && descriptor.entities.is_empty() {
</span><span style=color:#f07171>-                cache.map.insert(observer_entity, observer_state.runner);
</span><span style=color:#86b300>+                cache
</span><span style=color:#86b300>+                    .global_observers
</span><span style=color:#86b300>+                    .insert(observer_entity, observer_state.runner);
</span><span>             } else if descriptor.components.is_empty() {
</span><span>                 // Observer is not targeting any components so register it as an entity observer
</span><span>                 for &watched_entity in &observer_state.descriptor.entities {
</span><span style=color:#c594c5>@@ -951,11 +995,16 @@ </span><span style=color:#399ee6>impl World {
</span><span>                             });
</span><span>                     if descriptor.entities.is_empty() {
</span><span>                         // Register for all triggers targeting the component
</span><span style=color:#f07171>-                        observers.map.insert(observer_entity, observer_state.runner);
</span><span style=color:#86b300>+                        observers
</span><span style=color:#86b300>+                            .global_observers
</span><span style=color:#86b300>+                            .insert(observer_entity, observer_state.runner);
</span><span>                     } else {
</span><span>                         // Register for each watched entity
</span><span>                         for &watched_entity in &descriptor.entities {
</span><span style=color:#f07171>-                            let map = observers.entity_map.entry(watched_entity).or_default();
</span><span style=color:#86b300>+                            let map = observers
</span><span style=color:#86b300>+                                .entity_component_observers
</span><span style=color:#86b300>+                                .entry(watched_entity)
</span><span style=color:#86b300>+                                .or_default();
</span><span>                             map.insert(observer_entity, observer_state.runner);
</span><span>                         }
</span><span>                     }
</span><span style=color:#c594c5>@@ -970,9 +1019,9 @@ </span><span style=color:#399ee6>impl World {
</span><span>         let observers = &mut self.observers;
</span><span> 
</span><span>         for &event_type in &descriptor.events {
</span><span style=color:#f07171>-            let cache = observers.get_observers(event_type);
</span><span style=color:#86b300>+            let cache = observers.get_observers_mut(event_type);
</span><span>             if descriptor.components.is_empty() && descriptor.entities.is_empty() {
</span><span style=color:#f07171>-                cache.map.remove(&entity);
</span><span style=color:#86b300>+                cache.global_observers.remove(&entity);
</span><span>             } else if descriptor.components.is_empty() {
</span><span>                 for watched_entity in &descriptor.entities {
</span><span>                     // This check should be unnecessary since this observer hasn't been unregistered yet
</span><span style=color:#c594c5>@@ -990,20 +1039,24 @@ </span><span style=color:#399ee6>impl World {
</span><span>                         continue;
</span><span>                     };
</span><span>                     if descriptor.entities.is_empty() {
</span><span style=color:#f07171>-                        observers.map.remove(&entity);
</span><span style=color:#86b300>+                        observers.global_observers.remove(&entity);
</span><span>                     } else {
</span><span>                         for watched_entity in &descriptor.entities {
</span><span style=color:#f07171>-                            let Some(map) = observers.entity_map.get_mut(watched_entity) else {
</span><span style=color:#86b300>+                            let Some(map) =
</span><span style=color:#86b300>+                                observers.entity_component_observers.get_mut(watched_entity)
</span><span style=color:#86b300>+                            else {
</span><span>                                 continue;
</span><span>                             };
</span><span>                             map.remove(&entity);
</span><span>                             if map.is_empty() {
</span><span style=color:#f07171>-                                observers.entity_map.remove(watched_entity);
</span><span style=color:#86b300>+                                observers.entity_component_observers.remove(watched_entity);
</span><span>                             }
</span><span>                         }
</span><span>                     }
</span><span> 
</span><span style=color:#f07171>-                    if observers.map.is_empty() && observers.entity_map.is_empty() {
</span><span style=color:#86b300>+                    if observers.global_observers.is_empty()
</span><span style=color:#86b300>+                        && observers.entity_component_observers.is_empty()
</span><span style=color:#86b300>+                    {
</span><span>                         cache.component_observers.remove(component);
</span><span>                         if let Some(flag) = Observers::is_archetype_cached(event_type) {
</span><span>                             if let Some(by_component) = archetypes.by_component.get(component) {
</span><span>diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
</span><span>index ed7c1f2cdd82b..95accb20b5553 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/world/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/world/mod.rs
</span><span style=color:#c594c5>@@ -261,6 +261,12 @@ </span><span style=color:#399ee6>impl World {
</span><span>         &self.removed_components
</span><span>     }
</span><span> 
</span><span style=color:#86b300>+    /// Retrieves this world's [`Observers`] list
</span><span style=color:#86b300>+    #[inline]
</span><span style=color:#86b300>+    pub fn observers(&self) -> &Observers {
</span><span style=color:#86b300>+        &self.observers
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span>     /// Creates a new [`Commands`] instance that writes to the world's command queue
</span><span>     /// Use [`World::flush`] to apply all queued commands
</span><span>     #[inline]
</span></code></pre></details></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-06/pr_19608.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>