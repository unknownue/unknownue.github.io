<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #19194 Improve Bevy's double-precision story for third-party crates
        
    </title><meta content="#19194 Improve Bevy's double-precision story for third-party crates" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-06/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-06-08</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-06/pr-19194-zh-cn-20250608>中文</a></div></div><div class=pr-content><h1 id=analysis-of-pr-19194-improve-bevy-s-double-precision-story-for-third-party-crates>Analysis of PR #19194: Improve Bevy’s double-precision story for third-party crates</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Improve Bevy’s double-precision story for third-party crates<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/19194<li><strong>Author</strong>: jnhyatt<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: S-Ready-For-Final-Review, A-Math, M-Needs-Migration-Guide, D-Modest<li><strong>Created</strong>: 2025-05-12T20:06:18Z<li><strong>Merged</strong>: 2025-06-08T02:20:25Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>Objective</strong><p>Certain classes of games, usually those with enormous worlds, require some amount of support for double-precision. Libraries like <code>big_space</code> exist to allow for large worlds while integrating cleanly with Bevy’s primarily single-precision ecosystem, but even then, games will often still work directly in double-precision throughout the part of the pipeline that feeds into the Bevy interface.<p>Currently, working with double-precision types in Bevy is a pain. <code>glam</code> provides types like <code>DVec3</code>, but Bevy doesn’t provide double-precision analogs for <code>glam</code> wrappers like <code>Dir3</code>. This is mostly because doing so involves one of:<ul><li>code duplication<li>generics<li>templates (like <code>glam</code> uses)<li>macros</ul><p>Each of these has issues that are enough to be deal-breakers as far as maintainability, usability or readability. To work around this, I’m putting together <code>bevy_dmath</code>, a crate that duplicates <code>bevy_math</code> types and functionality to allow downstream users to enjoy the ergonomics and power of <code>bevy_math</code> in double-precision. For the most part, it’s a smooth process, but in order to fully integrate, there are some necessary changes that can only be made in <code>bevy_math</code>.<p><strong>Solution</strong><p>This PR addresses the first and easiest issue with downstream double-precision math support: <code>VectorSpace</code> currently can only represent vector spaces over <code>f32</code>. This automatically closes the door to double-precision curves, among other things. This restriction can be easily lifted by allowing vector spaces to specify the underlying scalar field. This PR adds a new trait <code>ScalarField</code> that satisfies the properties of a scalar field (the ones that can be upheld statically) and adds a new associated type <code>type Scalar: ScalarField</code> to <code>VectorSpace</code>. It’s mostly an unintrusive change. The biggest annoyances are:<ul><li>it touches a lot of curve code<li><code>bevy_math::ops</code> doesn’t support <code>f64</code>, so there are some annoying workarounds</ul><p>As far as curves code, I wanted to make this change unintrusive and bite-sized, so I’m trying to touch as little code as possible. To prove to myself it can be done, I went ahead and (<em>not</em> in this PR) migrated most of the curves API to support different <code>ScalarField</code>s and it went really smoothly! The ugliest thing was adding <code>P::Scalar: From&LTusize></code> in several places. There’s an argument to be made here that we should be using <code>num-traits</code>, but that’s not immediately relevant. The point is that for now, the smallest change I could make was to go into every curve impl and make them generic over <code>VectorSpace&LTScalar = f32></code>. Curves work exactly like before and don’t change the user API at all.<p><strong>Follow-up</strong><ul><li><strong>Extend <code>bevy_math::ops</code> to work with <code>f64</code>.</strong> <code>bevy_math::ops</code> is used all over, and if curves are ever going to support different <code>ScalarField</code> types, we’ll need to be able to use the correct <code>std</code> or <code>libm</code> ops for <code>f64</code> types as well. Adding an <code>ops64</code> mod turned out to be really ugly, but I’ll point out the maintenance burden is low because we’re not going to be adding new floating-point ops anytime soon. Another solution is to build a floating-point trait that calls the right op variant and impl it for <code>f32</code> and <code>f64</code>. This reduces maintenance burden because on the off chance we ever <em>do</em> want to go modify it, it’s all tied together: you can’t change the interface on one without changing the trait, which forces you to update the other. A third option is to use <code>num-traits</code>, which is basically option 2 but someone else did the work for us. They already support <code>no_std</code> using <code>libm</code>, so it would be more or less a drop-in replacement. They’re missing a couple floating-point ops like <code>floor</code> and <code>ceil</code>, but we could make our own floating-point traits for those (there’s even the potential for upstreaming them into <code>num-traits</code>).<li><strong>Tweak curves to accept vector spaces over any <code>ScalarField</code>.</strong> Curves are ready to support custom scalar types as soon as the bullet above is addressed. I will admit that the code is not as fun to look at: <code>P::Scalar</code> instead of <code>f32</code> everywhere. We could consider an alternate design where we use <code>f32</code> even to interpolate something like a <code>DVec3</code>, but personally I think that’s a worse solution than parameterizing curves over the vector space’s scalar type. At the end of the day, it’s not really bad to deal with in my opinion… <code>ScalarType</code> supports enough operations that working with them is almost like working with raw float types, and it unlocks a whole ecosystem for games that want to use double-precision.</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>Bevy’s math system was designed primarily for single-precision (<code>f32</code>) operations. While this works well for most games, titles with extremely large worlds (e.g., space exploration games) often require double-precision (<code>f64</code>) coordinates to prevent floating-point precision artifacts. Third-party crates like <code>big_space</code> attempted to bridge this gap but faced limitations because Bevy’s <code>VectorSpace</code> trait was hardcoded to <code>f32</code>. This made it impossible to use double-precision vectors with Bevy’s curve systems or other math utilities without significant workarounds.<p>The core issue was that <code>VectorSpace</code> operations like <code>lerp</code> and <code>norm</code> were tied to <code>f32</code> scalars. For example, the <code>VectorSpace</code> trait defined multiplication and division exclusively with <code>f32</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>VectorSpace</span><span>:
</span><span>    Mul&LTf32, Output = Self>
</span><span>    + Div&LTf32, Output = Self>
</span><span>    ...
</span></code></pre><p>This prevented types like <code>DVec3</code> from implementing <code>VectorSpace</code> properly since they require <code>f64</code> operations. The only solutions available were code duplication or complex generics, both of which introduced maintenance overhead and reduced ergonomics.<h3 id=the-solution-approach>The Solution Approach</h3><p>The solution introduces a generic scalar type to <code>VectorSpace</code> through an associated type and a new <code>ScalarField</code> trait. The key changes are:<ol><li>Added <code>type Scalar: ScalarField</code> to <code>VectorSpace</code><li>Created <code>ScalarField</code> trait with basic arithmetic operations<li>Implemented <code>ScalarField</code> for <code>f32</code> and <code>f64</code><li>Updated all existing <code>VectorSpace</code> implementations to specify their scalar type<li>Added new <code>VectorSpace</code> implementations for <code>DVec2</code>, <code>DVec3</code>, and <code>DVec4</code></ol><p>The <code>ScalarField</code> trait encapsulates the properties of a mathematical scalar field:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>ScalarField</span><span>:
</span><span>    Mul&LTSelf, Output = Self>
</span><span>    + Div&LTSelf, Output = Self>
</span><span>    ...
</span><span>{
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ZERO</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>Self</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ONE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>Self</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>recip</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{ </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><p>This abstraction allows vector operations to work with any scalar type while maintaining static guarantees about supported operations. The <code>lerp</code> method was updated to use the associated scalar type:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>lerp</span><span>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>rhs</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>Self</span><span>, </span><span style=color:#ff8f40>t</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Scalar) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self </span><span style=color:#ed9366>* </span><span>(</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Scalar</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ONE </span><span style=color:#ed9366>-</span><span> t) </span><span style=color:#ed9366>+</span><span> rhs </span><span style=color:#ed9366>*</span><span> t
</span><span>}
</span></code></pre><p>To minimize disruption, curve implementations were constrained to <code>VectorSpace&LTScalar = f32></code> for now. This maintains backward compatibility while laying the groundwork for future double-precision support in curves.<h3 id=the-implementation>The Implementation</h3><p>The changes required updates throughout Bevy’s math system. The <code>NormedVectorSpace</code> trait was extended to return the associated scalar type for norm calculations:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>NormedVectorSpace</span><span>: VectorSpace {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>norm</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Scalar</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre><p>Implementations for <code>DVec</code> types were straightforward since they already had length methods:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>NormedVectorSpace </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>DVec3 </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>norm</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f64 </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>length</span><span>()
</span><span>    }
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre><p>The curve systems required the most changes due to their heavy use of <code>VectorSpace</code>. Each curve implementation was updated to require <code>VectorSpace&LTScalar = f32></code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>impl</span><span>&LTP</span><span style=color:#61676ccc>:</span><span> VectorSpace> Curve&LTP> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>CubicSegment</span><span>&LTP>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#399ee6>impl</span><span>&LTP</span><span style=color:#61676ccc>: </span><span>VectorSpace&LTScalar = </span><span style=color:#fa6e32>f32</span><span>>> </span><span style=color:#399ee6>Curve</span><span>&LTP> </span><span style=color:#399ee6>for CubicSegment</span><span>&LTP>
</span></code></pre><p>This constraint ensures existing code continues to work while explicitly stating that curves currently only support <code>f32</code>. The sampling system also needed updates to handle the new scalar types in boundary cases.<h3 id=technical-insights>Technical Insights</h3><p>The design maintains zero-cost abstractions for single-precision use cases. When <code>Scalar = f32</code>, the compiler generates the same machine code as before. For double-precision, the scalar operations naturally map to <code>f64</code> instructions.<p>A notable challenge was handling scalar operations in <code>no_std</code> environments. The implementation uses conditional compilation to select between <code>std</code> and <code>libm</code> for <code>f64</code> operations:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>NormedVectorSpace </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>f64 </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"std"</span><span>)]
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>norm</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f64 </span><span>{ </span><span style=color:#ed9366>... </span><span>}
</span><span>    
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(</span><span style=color:#f29718>all</span><span>(</span><span style=color:#f29718>any</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"libm"</span><span style=color:#61676ccc>,</span><span> feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"nostd-libm"</span><span>)</span><span style=color:#61676ccc>, </span><span style=color:#f29718>not</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"std"</span><span>))]
</span><span>    fn </span><span style=color:#f29718>norm</span><span>(self) -> f64 { ... }
</span><span>}
</span></code></pre><p>The PR intentionally avoids migrating curves to full scalar genericity since that would require solving the <code>f64</code> operations problem first. The author notes this as a follow-up task.<h3 id=the-impact>The Impact</h3><p>These changes significantly improve Bevy’s compatibility with double-precision workflows:<ol><li>Third-party crates can now implement <code>VectorSpace</code> for double-precision types<li><code>DVec</code> types gain full <code>VectorSpace</code> and <code>NormedVectorSpace</code> implementations<li>The curve system is prepared for future double-precision support<li>Existing code remains unchanged due to the <code>Scalar = f32</code> constraint on curves</ol><p>For users, this means:<ul><li>Double-precision vectors now work with Bevy’s math traits<li>No changes required for existing single-precision code<li>A migration path exists for custom <code>VectorSpace</code> implementations (add <code>type Scalar = f32</code>)</ul><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[VectorSpace] --> B[ScalarField]
</span><span>    B --> C[f32]
</span><span>    B --> D[f64]
</span><span>    A --> E[NormedVectorSpace]
</span><span>    E --> F[Vec2/3/4]
</span><span>    E --> G[DVec2/3/4]
</span><span>    H[Curve Systems] --> I[VectorSpace&LTScalar=f32>]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-math-src-common-traits-rs-154-32><code>crates/bevy_math/src/common_traits.rs</code> (+154/-32)</h3><p>Added <code>ScalarField</code> trait and associated scalar type to <code>VectorSpace</code>. Implemented traits for <code>f32</code>, <code>f64</code>, and <code>DVec</code> types.<p><strong>Key changes:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>VectorSpace</span><span>:
</span><span>    Mul&LTSelf::Scalar, Output = Self>
</span><span>    + Div&LTSelf::Scalar, Output = Self>
</span><span>    ...
</span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Scalar</span><span style=color:#61676ccc>:</span><span> ScalarField</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>ScalarField</span><span>: ... {
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ZERO</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>Self</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>ONE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>Self</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Implementation for Vec3
</span><span style=color:#fa6e32>impl </span><span>VectorSpace </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Vec3 </span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Scalar </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Implementation for DVec3
</span><span style=color:#fa6e32>impl </span><span>VectorSpace </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>DVec3 </span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Scalar </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>f64</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre><h3 id=crates-bevy-math-src-curve-derivatives-adaptor-impls-rs-28-18><code>crates/bevy_math/src/curve/derivatives/adaptor_impls.rs</code> (+28/-18)</h3><p>Updated curve adaptors to work with <code>VectorSpace&LTScalar = f32></code>.<p><strong>Key change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTU, V, S, T, C, D> SampleDerivative<(S, T)> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>ZipCurve</span><span>&LTS, T, C, D>
</span><span style=color:#fa6e32>where
</span><span>    U</span><span style=color:#61676ccc>: </span><span>VectorSpace&LTScalar = </span><span style=color:#fa6e32>f32</span><span>>,
</span><span>    V</span><span style=color:#61676ccc>: </span><span>VectorSpace&LTScalar = </span><span style=color:#fa6e32>f32</span><span>>,
</span><span>    ...
</span><span>{
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre><h3 id=crates-bevy-math-src-sampling-shape-sampling-rs-20-15><code>crates/bevy_math/src/sampling/shape_sampling.rs</code> (+20/-15)</h3><p>Made triangle sampling generic over scalar types.<p><strong>Key change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>sample_triangle_interior</span><span>&LTP, R>(</span><span style=color:#ff8f40>vertices</span><span style=color:#61676ccc>:</span><span> [P; 3], </span><span style=color:#ff8f40>rng</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> R) </span><span style=color:#61676ccc>-></span><span> P
</span><span style=color:#fa6e32>where
</span><span>    P</span><span style=color:#61676ccc>:</span><span> NormedVectorSpace,
</span><span>    </span><span style=color:#fa6e32>P</span><span style=color:#ed9366>::</span><span>Scalar</span><span style=color:#61676ccc>:</span><span> SampleUniform + PartialOrd,
</span><span>    ...
</span><span>{
</span><span>    </span><span style=color:#ed9366>...
</span><span>    </span><span style=color:#fa6e32>let</span><span> u </span><span style=color:#ed9366>=</span><span> rng</span><span style=color:#ed9366>.</span><span style=color:#f07171>gen_range</span><span>(P</span><span style=color:#ed9366>::</span><span>Scalar</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ZERO</span><span style=color:#ed9366>..=</span><span>P</span><span style=color:#ed9366>::</span><span>Scalar</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ONE</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre><h3 id=crates-bevy-math-src-cubic-splines-mod-rs-13-13><code>crates/bevy_math/src/cubic_splines/mod.rs</code> (+13/-13)</h3><p>Constrained curve generators to <code>VectorSpace&LTScalar = f32></code>.<p><strong>Key change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTP</span><span style=color:#61676ccc>: </span><span>VectorSpace&LTScalar = </span><span style=color:#fa6e32>f32</span><span>>> CubicGenerator&LTP> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>CubicBezier</span><span>&LTP> {
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre><h3 id=crates-bevy-math-src-cubic-splines-curve-impls-rs-12-12><code>crates/bevy_math/src/cubic_splines/curve_impls.rs</code> (+12/-12)</h3><p>Constrained curve segments to <code>VectorSpace&LTScalar = f32></code>.<p><strong>Key change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTP</span><span style=color:#61676ccc>: </span><span>VectorSpace&LTScalar = </span><span style=color:#fa6e32>f32</span><span>>> Curve&LTP> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>CubicSegment</span><span>&LTP> {
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Scalar_field target=_blank>Scalar Field (Mathematics)</a><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Vector_space target=_blank>Vector Space Fundamentals</a><li><a rel="noopener nofollow noreferrer" href=https://randomascii.wordpress.com/2012/02/13/dont-store-that-in-a-float/ target=_blank>Floating-Point Precision Considerations</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/glam/latest/glam/f64/index.html target=_blank><code>glam</code> Double-Precision Vectors</a></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-06/pr_19194.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>