<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #19590 Thoroughly document the current state of observers
        
    </title><meta content="#19590 Thoroughly document the current state of observers" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-06/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-06-11</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-06/pr-19590-zh-cn-20250611>中文</a></div></div><div class=pr-content><h2 id=technical-report-thoroughly-documenting-bevy-observers>Technical Report: Thoroughly Documenting Bevy Observers</h2><h3 id=basic-information>Basic Information</h3><ul><li><strong>Title</strong>: Thoroughly document the current state of observers<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/19590<li><strong>Author</strong>: alice-i-cecile<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Docs, A-ECS, S-Ready-For-Final-Review, X-Uncontroversial, D-Modest<li><strong>Created</strong>: 2025-06-11T20:43:14Z<li><strong>Merged</strong>: 2025-06-11T22:23:11Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h3 id=description-translation>Description Translation</h3><h1 id=objective>Objective</h1><p>The documentation for observers is not very good. This poses a problem to users, but <em>also</em> causes serious problems for engine devs, as they attempt to improve assorted issues surrounding observers.<p>This PR:<ul><li>Fixes #14084.<li>Fixes #14726.<li>Fixes #16538.<li>Closes #18914, by attempting to solve the same issue.</ul><p>To keep this PR at all reviewable, I’ve opted to simply note the various limitations (some may call them bugs!) in place, rather than attempting to fix them. There is a huge amount of cleanup work to be done here: see https://github.com/orgs/bevyengine/projects/17.<h2 id=solution>Solution</h2><ul><li>Write good module docs for observers, offering bread crumbs to the most common methods and techniques and comparing-and-contrasting as needed.<li>Fix any actively misleading documentation.<li>Try to explain how the various bits of the (public?!) internals are related.</ul><h3 id=the-problem-and-context>The Problem and Context</h3><p>Observers in Bevy’s ECS provided push-based event handling but suffered from inadequate documentation. This caused multiple issues:<ol><li>Users struggled to understand observer targeting (global vs entity-specific)<li>Engine developers faced obstacles improving observer-related systems<li>Key limitations like observer retargeting constraints weren’t documented<li>Misleading comments created incorrect mental models of observer behavior</ol><p>The documentation gaps directly impacted four open issues (#14084, #14726, #16538, #18914) and hindered ongoing work in the observer system.<h3 id=the-solution-approach>The Solution Approach</h3><p>Instead of implementing behavioral changes, this PR focuses exclusively on documentation improvements:<ol><li>Comprehensive module-level docs explaining core concepts<li>Targeted fixes to misleading comments in critical structs<li>Explicit documentation of current limitations and workarounds<li>Clear comparisons between observers and buffered events (EventReader/Writer)</ol><p>Key engineering decisions:<ul><li>Preserved existing behavior while clarifying functionality<li>Documented known issues instead of attempting fixes in this PR<li>Structured documentation for both users and engine developers<li>Added cross-references to related systems like lifecycle events</ul><h3 id=implementation-details>Implementation Details</h3><p>The implementation consists entirely of documentation improvements to <code>observer/mod.rs</code>:<p><strong>Module Documentation</strong><br> Added comprehensive module-level docs covering:<ul><li>Observer targeting and spawning patterns<li>Event propagation mechanics<li>Timing characteristics relative to schedules<li>Comparison with buffered event systems<li>Lifecycle event interactions</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>//! Observers are a push-based tool for responding to [`Event`]s.
</span><span style=color:#abb0b6;font-style:italic>//!
</span><span style=color:#abb0b6;font-style:italic>//! ## Observer targeting
</span><span style=color:#abb0b6;font-style:italic>//!
</span><span style=color:#abb0b6;font-style:italic>//! Observers can be "global"... [detailed explanation continues]
</span></code></pre><p><strong>Struct Documentation</strong><br> Enhanced docs for critical structs including:<ol><li><code>Trigger</code> - Clarified generic <code>B</code> parameter behavior and target semantics<li><code>TriggerTargets</code> - Explained collection semantics<li><code>ObserverDescriptor</code> - Added component relationship context<li>Internal caching structs - Documented their roles in observer lookup</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// The generic `B: Bundle` is used to modify the further specialize...
</span><span style=color:#abb0b6;font-style:italic>/// Providing multiple components... [rather than requiring all of them](
</span><span>https</span><span style=color:#61676ccc>:</span><span style=color:#abb0b6;font-style:italic>//github.com/bevyengine/bevy/issues/15325).
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Trigger</span><span><</span><span style=color:#fa6e32>'w</span><span>, E, B</span><span style=color:#61676ccc>:</span><span> Bundle = ()> { ... }
</span></code></pre><p><strong>Behavioral Caveats</strong><br> Explicitly documented current limitations:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>//! Currently, [observers cannot be retargeted after spawning](
</span><span>https</span><span style=color:#61676ccc>:</span><span style=color:#abb0b6;font-style:italic>//github.com/bevyengine/bevy/issues/19587)
</span><span style=color:#abb0b6;font-style:italic>//! Currently, Bevy does not provide [a way to specify the ordering of observers](
</span><span>https</span><span style=color:#61676ccc>:</span><span style=color:#abb0b6;font-style:italic>//github.com/bevyengine/bevy/issues/14890)
</span><span style=color:#abb0b6;font-style:italic>//! Commands sent by observers are [currently not immediately applied](
</span><span>https</span><span style=color:#61676ccc>:</span><span style=color:#abb0b6;font-style:italic>//github.com/bevyengine/bevy/issues/19569)
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>Key technical clarifications provided:<p><strong>Observer Targeting</strong><ul><li>Explained difference between global and entity-specific observation<li>Documented <code>ObservedBy</code> component relationship<li>Clarified component-based targeting via generic <code>B</code> bundle</ul><p><strong>Lifecycle Events</strong><ul><li>Detailed hook vs observer execution order: <ul><li>Component addition: hooks → observers<li>Component removal: observers → hooks</ul><li>Explained rationale for ordering (constructors/destructors)</ul><p><strong>Performance Characteristics</strong><ul><li>Compared observers (push-based) vs buffered events (pull-based): <ul><li>Observers better for rare events<li>Buffered events better for high-frequency events</ul><li>Documented command application timing constraints</ul><p><strong>Architectural Notes</strong><ul><li>Explained relationship between: <ul><li><code>Observer</code> component and observer entities<li><code>CachedObservers</code> and world storage<li><code>TriggerTargets</code> and event propagation</ul></ul><h3 id=impact>Impact</h3><ol><li>Resolved four documentation-related issues<li>Provided clear usage guidance for common patterns<li>Documented 8 current limitations with issue links<li>Established foundation for future observer improvements<li>Clarified internal structures for engine developers</ol><h3 id=key-files-changed>Key Files Changed</h3><p><strong>crates/bevy_ecs/src/observer/mod.rs</strong> (+167/-18)<br> Complete overhaul of module documentation and struct comments.<p>Key additions:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: minimal module docs
</span><span style=color:#abb0b6;font-style:italic>//! Types for creating and storing [`Observer`]s
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: comprehensive usage guide
</span><span style=color:#abb0b6;font-style:italic>//! Observers are a push-based tool for responding to [`Event`]s.
</span><span style=color:#abb0b6;font-style:italic>//!
</span><span style=color:#abb0b6;font-style:italic>//! ## Observer targeting
</span><span style=color:#abb0b6;font-style:italic>//! [Detailed sections covering 10+ aspects of observer usage]...
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: minimal struct docs
</span><span style=color:#abb0b6;font-style:italic>/// Type containing triggered event information...
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: technical precision
</span><span style=color:#abb0b6;font-style:italic>/// The generic `B: Bundle` is used to modify...
</span><span style=color:#abb0b6;font-style:italic>/// Providing multiple components... [rather than requiring all](
</span><span>https</span><span style=color:#61676ccc>:</span><span style=color:#abb0b6;font-style:italic>//github.com/bevyengine/bevy/issues/15325).
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Trigger</span><span><</span><span style=color:#fa6e32>'w</span><span>, E, B</span><span style=color:#61676ccc>:</span><span> Bundle = ()> { ... }
</span></code></pre><h3 id=further-reading>Further Reading</h3><ul><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/discussions/19589 target=_blank>Observer System Design Discussion</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/lifecycle/index.html target=_blank>Lifecycle Events Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/discussions/14891 target=_blank>ECS Event Systems Comparison</a></ul><h3 id=full-code-diff>Full Code Diff</h3><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_ecs/src/observer/mod.rs b/crates/bevy_ecs/src/observer/mod.rs
</span><span>index 6fcfa1621c6f0..43beca35b4da8 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/observer/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/observer/mod.rs
</span><span style=color:#c594c5>@@ -1,4 +1,136 @@
</span><span style=color:#f07171>-//! Types for creating and storing [`Observer`]s
</span><span style=color:#86b300>+//! Observers are a push-based tool for responding to [`Event`]s.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Observer targeting
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Observers can be "global", listening for events that are both targeted at and not targeted at any specific entity,
</span><span style=color:#86b300>+//! or they can be "entity-specific", listening for events that are targeted at specific entities.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! They can also be further refined by listening to events targeted at specific components
</span><span style=color:#86b300>+//! (instead of using a generic event type), as is done with the [`OnAdd`] family of lifecycle events.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! When entities are observed, they will receive an [`ObservedBy`] component,
</span><span style=color:#86b300>+//! which will be updated to track the observers that are currently observing them.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Currently, [observers cannot be retargeted after spawning](https://github.com/bevyengine/bevy/issues/19587):
</span><span style=color:#86b300>+//! despawn and respawn an observer as a workaround.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Writing observers
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Observers are systems which implement [`IntoObserverSystem`] that listen for [`Event`]s matching their
</span><span style=color:#86b300>+//! type and target(s).
</span><span style=color:#86b300>+//! To write observer systems, use the [`Trigger`] system parameter as the first parameter of your system.
</span><span style=color:#86b300>+//! This parameter provides access to the specific event that triggered the observer,
</span><span style=color:#86b300>+//! as well as the entity that the event was targeted at, if any.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Observers can request other data from the world,
</span><span style=color:#86b300>+//! such as via a [`Query`] or [`Res`]. Commonly, you might want to verify that
</span><span style=color:#86b300>+//! the entity that the observable event is targeting has a specific component,
</span><span style=color:#86b300>+//! or meets some other condition.
</span><span style=color:#86b300>+//! [`Query::get`] or [`Query::contains`] on the [`Trigger::target`] entity
</span><span style=color:#86b300>+//! is a good way to do this.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! [`Commands`] can also be used inside of observers.
</span><span style=color:#86b300>+//! This can be particularly useful for triggering other observers!
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Spawning observers
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Observers can be spawned via [`World::add_observer`], or the equivalent app method.
</span><span style=color:#86b300>+//! This will cause an entity with the [`Observer`] component to be created,
</span><span style=color:#86b300>+//! which will then run the observer system whenever the event it is watching is triggered.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! You can control the targets that an observer is watching by calling [`Observer::watch_entity`]
</span><span style=color:#86b300>+//! once the entity is spawned, or by manually spawning an entity with the [`Observer`] component
</span><span style=color:#86b300>+//! configured with the desired targets.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Observers are fundamentally defined as "entities which have the [`Observer`] component"
</span><span style=color:#86b300>+//! allowing you to add it manually to existing entities.
</span><span style=color:#86b300>+//! At first, this seems convenient, but only one observer can be added to an entity at a time,
</span><span style=color:#86b300>+//! regardless of the event it responds to: like always, components are unique.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Instead, a better way to achieve a similar aim is to
</span><span style=color:#86b300>+//! use the [`EntityWorldMut::observe`] / [`EntityCommands::observe`] method,
</span><span style=color:#86b300>+//! which spawns a new observer, and configures it to watch the entity it is called on.
</span><span style=color:#86b300>+//! Unfortunately, observers defined in this way
</span><span style=color:#86b300>+//! [currently cannot be spawned as part of bundles](https://github.com/bevyengine/bevy/issues/14204).
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Triggering observers
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Observers are most commonly triggered by [`Commands`],
</span><span style=color:#86b300>+//! via [`Commands::trigger`] (for untargeted events) or [`Commands::trigger_targets`] (for targeted events).
</span><span style=color:#86b300>+//! Like usual, equivalent methods are available on [`World`], allowing you to reduce overhead when working with exclusive world access.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! If your observer is configured to watch for a specific component or set of components instead,
</span><span style=color:#86b300>+//! you can pass in [`ComponentId`]s into [`Commands::trigger_targets`] by using the [`TriggerTargets`] trait.
</span><span style=color:#86b300>+//! As discussed in the [`Trigger`] documentation, this use case is rare, and is currently only used
</span><span style=color:#86b300>+//! for [lifecycle](crate::lifecycle) events, which are automatically emitted.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Observer bubbling
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! When events are targeted at an entity, they can optionally bubble to other targets,
</span><span style=color:#86b300>+//! typically up to parents in an entity hierarchy.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! This behavior is controlled via [`Event::Traversal`] and [`Event::AUTO_PROPAGATE`],
</span><span style=color:#86b300>+//! with the details of the propagation path specified by the [`Traversal`](crate::traversal::Traversal) trait.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! When auto-propagation is enabled, propagaion must be manually stopped to prevent the event from
</span><span style=color:#86b300>+//! continuing to other targets.
</span><span style=color:#86b300>+//! This can be done using the [`Trigger::propagate`] method on the [`Trigger`] system parameter inside of your observer.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//!  ## Observer timing
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Observers are triggered via [`Commands`], which imply that they are evaluated at the next sync point in the ECS schedule.
</span><span style=color:#86b300>+//! Accordingly, they have full access to the world, and are evaluated sequentially, in the order that the commands were sent.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! To control the relative ordering of observers sent from different systems,
</span><span style=color:#86b300>+//! order the systems in the schedule relative to each other.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Currently, Bevy does not provide [a way to specify the ordering of observers](https://github.com/bevyengine/bevy/issues/14890)
</span><span style=color:#86b300>+//! listening to the same event relative to each other.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Commands sent by observers are [currently not immediately applied](https://github.com/bevyengine/bevy/issues/19569).
</span><span style=color:#86b300>+//! Instead, all queued observers will run, and then all of the commands from those observers will be applied.
</span><span style=color:#86b300>+//! Careful use of [`Schedule::apply_deferred`] may help as a workaround.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Lifecycle events and observers
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! It is important to note that observers, just like [hooks](crate::lifecycle::ComponentHooks),
</span><span style=color:#86b300>+//! can listen to and respond to [lifecycle](crate::lifecycle) events.
</span><span style=color:#86b300>+//! Unlike hooks, observers are not treated as an "innate" part of component behavior:
</span><span style=color:#86b300>+//! they can be added or removed at runtime, and multiple observers
</span><span style=color:#86b300>+//! can be registered for the same lifecycle event for the same component.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! The ordering of hooks versus observers differs based on the lifecycle event in question:
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! - when adding components, hooks are evaluated first, then observers
</span><span style=color:#86b300>+//! - when removing components, observers are evaluated first, then hooks
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! This allows hooks to act as constructors and destructors for components,
</span><span style=color:#86b300>+//! as they always have the first and final say in the component's lifecycle.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Cleaning up observers
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! Currently, observer entities are never cleaned up, even if their target entity(s) are despawned.
</span><span style=color:#86b300>+//! This won't cause any runtime overhead, but is a waste of memory and can result in memory leaks.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! If you run into this problem, you could manually scan the world for observer entities and despawn them,
</span><span style=color:#86b300>+//! by checking if the entity in [`Observer::descriptor`] still exists.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! ## Observers vs buffered events
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! By contrast, [`EventReader`] and [`EventWriter`] ("buffered events"), are pull-based.
</span><span style=color:#86b300>+//! They require periodically polling the world to check for new events, typically in a system that runs as part of a schedule.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! This imposes a small overhead, making observers a better choice for extremely rare events,
</span><span style=color:#86b300>+//! but buffered events can be more efficient for events that are expected to occur multiple times per frame,
</span><span style=color:#86b300>+//! as it allows for batch processing of events.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! The difference in timing is also an important consideration:
</span><span style=color:#86b300>+//! buffered events are evaluated at fixed points during schedules,
</span><span style=color:#86b300>+//! while observers are evaluated as soon as possible after the event is triggered.
</span><span style=color:#86b300>+//!
</span><span style=color:#86b300>+//! This provides more control over the timing of buffered event evaluation,
</span><span style=color:#86b300>+//! but allows for a more ad hoc approach with observers,
</span><span style=color:#86b300>+//! and enables indefinite chaining of observers triggering other observers (for both better and worse!).
</span><span> 
</span><span> mod entity_observer;
</span><span> mod runner;
</span><span style=color:#c594c5>@@ -29,6 +161,17 @@ </span><span style=color:#399ee6>use smallvec::SmallVec;
</span><span> /// Type containing triggered [`Event`] information for a given run of an [`Observer`]. This contains the
</span><span> /// [`Event`] data itself. If it was triggered for a specific [`Entity`], it includes that as well. It also
</span><span> /// contains event propagation information. See [`Trigger::propagate`] for more information.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// The generic `B: Bundle` is used to modify the further specialize the events that this observer is interested in.
</span><span style=color:#86b300>+/// The entity involved *does not* have to have these components, but the observer will only be
</span><span style=color:#86b300>+/// triggered if the event matches the components in `B`.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This is used to to avoid providing a generic argument in your event, as is done for [`OnAdd`]
</span><span style=color:#86b300>+/// and the other lifecycle events.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// Providing multiple components in this bundle will cause this event to be triggered by any
</span><span style=color:#86b300>+/// matching component in the bundle,
</span><span style=color:#86b300>+/// [rather than requiring all of them to be present](https://github.com/bevyengine/bevy/issues/15325).
</span><span> pub struct Trigger<'w, E, B: Bundle = ()> {
</span><span>     event: &'w mut E,
</span><span>     propagate: &'w mut bool,
</span><span style=color:#c594c5>@@ -69,18 +212,6 @@ </span><span style=color:#399ee6>impl<'w, E, B: Bundle> Trigger<'w, E, B> {
</span><span> 
</span><span>     /// Returns the [`Entity`] that was targeted by the `event` that triggered this observer. It may
</span><span>     /// be [`None`] if the trigger is not for a particular entity.
</span><span style=color:#f07171>-    ///
</span><span style=color:#f07171>-    /// Observable events can target specific entities. When those events fire, they will trigger
</span><span style=color:#f07171>-    /// any observers on the targeted entities. In this case, the `target()` and `observer()` are
</span><span style=color:#f07171>-    /// the same, because the observer that was triggered is attached to the entity that was
</span><span style=color:#f07171>-    /// targeted by the event.
</span><span style=color:#f07171>-    ///
</span><span style=color:#f07171>-    /// However, it is also possible for those events to bubble up the entity hierarchy and trigger
</span><span style=color:#f07171>-    /// observers on *different* entities, or trigger a global observer. In these cases, the
</span><span style=color:#f07171>-    /// observing entity is *different* from the entity being targeted by the event.
</span><span style=color:#f07171>-    ///
</span><span style=color:#f07171>-    /// This is an important distinction: the entity reacting to an event is not always the same as
</span><span style=color:#f07171>-    /// the entity triggered by the event.
</span><span>     pub fn target(&self) -> Option&LTEntity> {
</span><span>         self.trigger.target
</span><span>     }
</span><span style=color:#c594c5>@@ -172,10 +303,14 @@ </span><span style=color:#399ee6>impl<'w, E, B: Bundle> DerefMut for Trigger<'w, E, B> {
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Represents a collection of targets for a specific [`Trigger`] of an [`Event`]. Targets can be of type [`Entity`] or [`ComponentId`].
</span><span style=color:#86b300>+/// Represents a collection of targets for a specific [`Trigger`] of an [`Event`].
</span><span> ///
</span><span> /// When a trigger occurs for a given event and [`TriggerTargets`], any [`Observer`] that watches for that specific event-target combination
</span><span> /// will run.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This trait is implemented for both [`Entity`] and [`ComponentId`], allowing you to target specific entities or components.
</span><span style=color:#86b300>+/// It is also implemented for various collections of these types, such as [`Vec`], arrays, and tuples,
</span><span style=color:#86b300>+/// allowing you to trigger events for multiple targets at once.
</span><span> pub trait TriggerTargets {
</span><span>     /// The components the trigger should target.
</span><span>     fn components(&self) -> impl Iterator&LTItem = ComponentId> + Clone + '_;
</span><span style=color:#c594c5>@@ -280,7 +415,9 @@ </span><span style=color:#399ee6>all_tuples!(
</span><span>     T
</span><span> );
</span><span> 
</span><span style=color:#f07171>-/// A description of what an [`Observer`] observes.
</span><span style=color:#86b300>+/// Store information about what an [`Observer`] observes.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This information is stored inside of the [`Observer`] component,
</span><span> #[derive(Default, Clone)]
</span><span> pub struct ObserverDescriptor {
</span><span>     /// The events the observer is watching.
</span><span style=color:#c594c5>@@ -331,7 +468,9 @@ </span><span style=color:#399ee6>impl ObserverDescriptor {
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Event trigger metadata for a given [`Observer`],
</span><span style=color:#86b300>+/// Metadata about a specific [`Event`] which triggered an observer.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This information is exposed via methods on the [`Trigger`] system parameter.
</span><span> #[derive(Debug)]
</span><span> pub struct ObserverTrigger {
</span><span>     /// The [`Entity`] of the observer handling the trigger.
</span><span style=color:#c594c5>@@ -357,6 +496,8 @@ </span><span style=color:#399ee6>impl ObserverTrigger {
</span><span> type ObserverMap = EntityHashMap&LTObserverRunner>;
</span><span> 
</span><span> /// Collection of [`ObserverRunner`] for [`Observer`] registered to a particular trigger targeted at a specific component.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This is stored inside of [`CachedObservers`].
</span><span> #[derive(Default, Debug)]
</span><span> pub struct CachedComponentObservers {
</span><span>     // Observers listening to triggers targeting this component
</span><span style=color:#c594c5>@@ -366,6 +507,8 @@ </span><span style=color:#399ee6>pub struct CachedComponentObservers {
</span><span> }
</span><span> 
</span><span> /// Collection of [`ObserverRunner`] for [`Observer`] registered to a particular trigger.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This is stored inside of [`Observers`], specialized for each kind of observer.
</span><span> #[derive(Default, Debug)]
</span><span> pub struct CachedObservers {
</span><span>     // Observers listening for any time this trigger is fired
</span><span style=color:#c594c5>@@ -376,7 +519,13 @@ </span><span style=color:#399ee6>pub struct CachedObservers {
</span><span>     entity_observers: EntityHashMap&LTObserverMap>,
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Metadata for observers. Stores a cache mapping trigger ids to the registered observers.
</span><span style=color:#86b300>+/// An internal lookup table tracking all of the observers in the world.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// Stores a cache mapping trigger ids to the registered observers.
</span><span style=color:#86b300>+/// Some observer kinds (like [lifecycle](crate::lifecycle) observers) have a dedicated field,
</span><span style=color:#86b300>+/// saving lookups for the most common triggers.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This is stored as a field of the [`World`].
</span><span> #[derive(Default, Debug)]
</span><span> pub struct Observers {
</span><span>     // Cached ECS observers to save a lookup most common triggers.
</span><span style=color:#c594c5>@@ -385,7 +534,7 @@ </span><span style=color:#399ee6>pub struct Observers {
</span><span>     on_replace: CachedObservers,
</span><span>     on_remove: CachedObservers,
</span><span>     on_despawn: CachedObservers,
</span><span style=color:#f07171>-    // Map from trigger type to set of observers
</span><span style=color:#86b300>+    // Map from trigger type to set of observers listening to that trigger
</span><span>     cache: HashMap&LTComponentId, CachedObservers>,
</span><span> }
</span><span> 
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-06/pr_19590.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>