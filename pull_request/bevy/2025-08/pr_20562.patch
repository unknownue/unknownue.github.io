diff --git a/crates/bevy_asset/src/io/source.rs b/crates/bevy_asset/src/io/source.rs
index 4852a2a71fff2..500a1657f353c 100644
--- a/crates/bevy_asset/src/io/source.rs
+++ b/crates/bevy_asset/src/io/source.rs
@@ -72,26 +72,12 @@ impl<'a> AssetSourceId<'a> {
     }
 }
 
-impl AssetSourceId<'static> {
-    /// Indicates this [`AssetSourceId`] should have a static lifetime.
-    #[inline]
-    pub fn as_static(self) -> Self {
-        match self {
-            Self::Default => Self::Default,
-            Self::Name(value) => Self::Name(value.as_static()),
-        }
-    }
-
-    /// Constructs an [`AssetSourceId`] with a static lifetime.
-    #[inline]
-    pub fn from_static(value: impl Into<Self>) -> Self {
-        value.into().as_static()
-    }
-}
-
-impl<'a> From<&'a str> for AssetSourceId<'a> {
-    fn from(value: &'a str) -> Self {
-        AssetSourceId::Name(CowArc::Borrowed(value))
+// This is only implemented for static lifetimes to ensure `Path::clone` does not allocate
+// by ensuring that this is stored as a `CowArc::Static`.
+// Please read https://github.com/bevyengine/bevy/issues/19844 before changing this!
+impl From<&'static str> for AssetSourceId<'static> {
+    fn from(value: &'static str) -> Self {
+        AssetSourceId::Name(value.into())
     }
 }
 
@@ -101,10 +87,10 @@ impl<'a, 'b> From<&'a AssetSourceId<'b>> for AssetSourceId<'b> {
     }
 }
 
-impl<'a> From<Option<&'a str>> for AssetSourceId<'a> {
-    fn from(value: Option<&'a str>) -> Self {
+impl From<Option<&'static str>> for AssetSourceId<'static> {
+    fn from(value: Option<&'static str>) -> Self {
         match value {
-            Some(value) => AssetSourceId::Name(CowArc::Borrowed(value)),
+            Some(value) => AssetSourceId::Name(value.into()),
             None => AssetSourceId::Default,
         }
     }
@@ -329,7 +315,7 @@ pub struct AssetSourceBuilders {
 impl AssetSourceBuilders {
     /// Inserts a new builder with the given `id`
     pub fn insert(&mut self, id: impl Into<AssetSourceId<'static>>, source: AssetSourceBuilder) {
-        match AssetSourceId::from_static(id) {
+        match id.into() {
             AssetSourceId::Default => {
                 self.default = Some(source);
             }
diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
index ed3204cc30b06..9302a73125b88 100644
--- a/crates/bevy_asset/src/lib.rs
+++ b/crates/bevy_asset/src/lib.rs
@@ -560,7 +560,7 @@ impl AssetApp for App {
         id: impl Into<AssetSourceId<'static>>,
         source: AssetSourceBuilder,
     ) -> &mut Self {
-        let id = AssetSourceId::from_static(id);
+        let id = id.into();
         if self.world().get_resource::<AssetServer>().is_some() {
             error!("{} must be registered before `AssetPlugin` (typically added as part of `DefaultPlugins`)", id);
         }
@@ -2000,94 +2000,6 @@ mod tests {
         app.world_mut().run_schedule(Update);
     }
 
-    #[test]
-    #[ignore = "blocked on https://github.com/bevyengine/bevy/issues/11111"]
-    fn same_asset_different_settings() {
-        // Test loading the same asset twice with different settings. This should
-        // produce two distinct assets.
-
-        // First, implement an asset that's a single u8, whose value is copied from
-        // the loader settings.
-
-        #[derive(Asset, TypePath)]
-        struct U8Asset(u8);
-
-        #[derive(Serialize, Deserialize, Default)]
-        struct U8LoaderSettings(u8);
-
-        struct U8Loader;
-
-        impl AssetLoader for U8Loader {
-            type Asset = U8Asset;
-            type Settings = U8LoaderSettings;
-            type Error = crate::loader::LoadDirectError;
-
-            async fn load(
-                &self,
-                _: &mut dyn Reader,
-                settings: &Self::Settings,
-                _: &mut LoadContext<'_>,
-            ) -> Result<Self::Asset, Self::Error> {
-                Ok(U8Asset(settings.0))
-            }
-
-            fn extensions(&self) -> &[&str] {
-                &["u8"]
-            }
-        }
-
-        // Create a test asset.
-
-        let dir = Dir::default();
-        dir.insert_asset(Path::new("test.u8"), &[]);
-
-        let asset_source = AssetSource::build()
-            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }));
-
-        // Set up the app.
-
-        let mut app = App::new();
-
-        app.register_asset_source(AssetSourceId::Default, asset_source)
-            .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
-            .init_asset::<U8Asset>()
-            .register_asset_loader(U8Loader);
-
-        let asset_server = app.world().resource::<AssetServer>();
-
-        // Load the test asset twice but with different settings.
-
-        fn load(asset_server: &AssetServer, path: &str, value: u8) -> Handle<U8Asset> {
-            asset_server.load_with_settings::<U8Asset, U8LoaderSettings>(
-                path,
-                move |s: &mut U8LoaderSettings| s.0 = value,
-            )
-        }
-
-        let handle_1 = load(asset_server, "test.u8", 1);
-        let handle_2 = load(asset_server, "test.u8", 2);
-
-        // Handles should be different.
-
-        assert_ne!(handle_1, handle_2);
-
-        run_app_until(&mut app, |world| {
-            let (Some(asset_1), Some(asset_2)) = (
-                world.resource::<Assets<U8Asset>>().get(&handle_1),
-                world.resource::<Assets<U8Asset>>().get(&handle_2),
-            ) else {
-                return None;
-            };
-
-            // Values should match the settings.
-
-            assert_eq!(asset_1.0, 1);
-            assert_eq!(asset_2.0, 2);
-
-            Some(())
-        });
-    }
-
     #[test]
     fn insert_dropped_handle_returns_error() {
         let mut app = App::new();
diff --git a/crates/bevy_asset/src/path.rs b/crates/bevy_asset/src/path.rs
index d4e8b9a0370af..de9dfa5ca583a 100644
--- a/crates/bevy_asset/src/path.rs
+++ b/crates/bevy_asset/src/path.rs
@@ -535,43 +535,17 @@ impl<'a> AssetPath<'a> {
     }
 }
 
-impl AssetPath<'static> {
-    /// Indicates this [`AssetPath`] should have a static lifetime.
+// This is only implemented for static lifetimes to ensure `Path::clone` does not allocate
+// by ensuring that this is stored as a `CowArc::Static`.
+// Please read https://github.com/bevyengine/bevy/issues/19844 before changing this!
+impl From<&'static str> for AssetPath<'static> {
     #[inline]
-    pub fn as_static(self) -> Self {
-        let Self {
-            source,
-            path,
-            label,
-        } = self;
-
-        let source = source.as_static();
-        let path = path.as_static();
-        let label = label.map(CowArc::as_static);
-
-        Self {
-            source,
-            path,
-            label,
-        }
-    }
-
-    /// Constructs an [`AssetPath`] with a static lifetime.
-    #[inline]
-    pub fn from_static(value: impl Into<Self>) -> Self {
-        value.into().as_static()
-    }
-}
-
-impl<'a> From<&'a str> for AssetPath<'a> {
-    #[inline]
-    fn from(asset_path: &'a str) -> Self {
+    fn from(asset_path: &'static str) -> Self {
         let (source, path, label) = Self::parse_internal(asset_path).unwrap();
-
         AssetPath {
             source: source.into(),
-            path: CowArc::Borrowed(path),
-            label: label.map(CowArc::Borrowed),
+            path: CowArc::Static(path),
+            label: label.map(CowArc::Static),
         }
     }
 }
@@ -590,12 +564,12 @@ impl From<String> for AssetPath<'static> {
     }
 }
 
-impl<'a> From<&'a Path> for AssetPath<'a> {
+impl From<&'static Path> for AssetPath<'static> {
     #[inline]
-    fn from(path: &'a Path) -> Self {
+    fn from(path: &'static Path) -> Self {
         Self {
             source: AssetSourceId::Default,
-            path: CowArc::Borrowed(path),
+            path: CowArc::Static(path),
             label: None,
         }
     }
