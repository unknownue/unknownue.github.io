<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20242 Solari specular scene/PT support
        
    </title><meta content="#20242 Solari specular scene/PT support" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-08/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-08-01</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-08/pr-20242-zh-cn-20250801>中文</a></div></div><div class=pr-content><h1 id=technical-report-solari-specular-scene-pt-support>Technical Report: Solari specular scene/PT support</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari specular scene/PT support<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20242<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, M-Needs-Release-Note<li><strong>Created</strong>: 2025-07-22T04:11:46Z<li><strong>Merged</strong>: 2025-08-01T16:00:52Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Adds roughness, metallic, and reflectance properties to solari’s material system<br> Always calculate and expose world_tangent in ResolvedRayHitFull<br> Add brdf.wgsl with mixed diffuse/specular BRDF<br> Add GGX VNDF importance sampling functions to sampling.wgsl<br> Rewrite the pathtracer to use the specular BRDF<br> MIS for NEE/BRDF sampling implemented in the pathtracer thanks to @SparkyPotato<p>Note that specular support for the realtime lighting plugin will come at a future date. I think I want to focus on getting GI more stable and hooking up a denoiser first. This is <em>just</em> support for the material properties in RaytracingScenePlugin, and specular lighting in the PathtracingPlugin.</p><img alt=image height=1500 src=https://github.com/user-attachments/assets/e322b770-179d-4255-84ce-996c531ce811 width=2564><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The existing Solari pathtracer only supported diffuse materials, limiting its ability to render realistic surfaces. This PR extends the material system with specular properties and implements physically-based rendering in the pathtracer. The core problem was integrating metallic/roughness workflows while maintaining performance and reducing noise through proper importance sampling.<p>First, the material representation needed expansion. The Rust-side <code>GpuMaterial</code> struct was extended to include metallic, roughness, and reflectance properties. This required updating the scene binder to process metallic-roughness textures:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>GpuMaterial </span><span>{
</span><span>    base_color</span><span style=color:#61676ccc>:</span><span> LinearRgba,
</span><span>    emissive</span><span style=color:#61676ccc>:</span><span> LinearRgba,
</span><span>    base_color_texture_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    normal_map_texture_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    emissive_texture_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    _padding</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>GpuMaterial </span><span>{
</span><span>    normal_map_texture_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    base_color_texture_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    emissive_texture_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    metallic_roughness_texture_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>
</span><span>    base_color</span><span style=color:#61676ccc>:</span><span> Vec3,
</span><span>    perceptual_roughness</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    emissive</span><span style=color:#61676ccc>:</span><span> Vec3,
</span><span>    metallic</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    reflectance</span><span style=color:#61676ccc>:</span><span> Vec3,
</span><span>    _padding</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>}
</span></code></pre><p>For proper BRDF evaluation, we needed consistent tangent space information. The <code>ResolvedRayHitFull</code> struct now always calculates and exposes <code>world_tangent</code>:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>struct ResolvedRayHitFull {
</span><span>    world_position: vec3&LTf32>,
</span><span>    world_normal: vec3&LTf32>,
</span><span>    geometric_world_normal: vec3&LTf32>,
</span><span>    uv: vec2&LTf32>,
</span><span>    triangle_area: f32,
</span><span>    material: ResolvedMaterial,
</span><span>}
</span><span>
</span><span>// After:
</span><span>struct ResolvedRayHitFull {
</span><span>    world_position: vec3&LTf32>,
</span><span>    world_normal: vec3&LTf32>,
</span><span>    geometric_world_normal: vec3&LTf32>,
</span><span>    world_tangent: vec4&LTf32>,
</span><span>    uv: vec2&LTf32>,
</span><span>    triangle_area: f32,
</span><span>    triangle_count: u32,
</span><span>    material: ResolvedMaterial,
</span><span>}
</span></code></pre><p>The new <code>brdf.wgsl</code> module implements a physically-based BRDF combining diffuse and specular components. The key function evaluates both terms:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn evaluate_brdf(
</span><span>    world_normal: vec3&LTf32>,
</span><span>    wo: vec3&LTf32>,
</span><span>    wi: vec3&LTf32>,
</span><span>    material: ResolvedMaterial,
</span><span>) -> vec3&LTf32> {
</span><span>    let diffuse_brdf = diffuse_brdf(material.base_color, material.metallic);
</span><span>    let specular_brdf = specular_brdf(
</span><span>        world_normal,
</span><span>        wo,
</span><span>        wi,
</span><span>        material.base_color,
</span><span>        material.metallic,
</span><span>        material.reflectance,
</span><span>        material.perceptual_roughness,
</span><span>        material.roughness,
</span><span>    );
</span><span>    return diffuse_brdf + specular_brdf;
</span><span>}
</span></code></pre><p>For importance sampling, GGX VNDF functions were added to <code>sampling.wgsl</code> based on GPUOpen’s reference implementation. These allow proper sampling of specular lobes:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn sample_ggx_vndf(wi_tangent: vec3&LTf32>, roughness: f32, rng: ptr&LTfunction, u32>) -> vec3&LTf32> {
</span><span>    // Implementation based on GPUOpen's bounded VNDF sampling
</span><span>}
</span><span>
</span><span>fn ggx_vndf_pdf(wi_tangent: vec3&LTf32>, wo_tangent: vec3&LTf32>, roughness: f32) -> f32 {
</span><span>    // PDF calculation for GGX VNDF sampling
</span><span>}
</span></code></pre><p>The pathtracer core was rewritten to leverage these new capabilities. The most significant change is the implementation of Multiple Importance Sampling (MIS) between Next Event Estimation (light sampling) and BRDF sampling:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Direct lighting with MIS weighting
</span><span>if !is_perfectly_specular {
</span><span>    let direct_lighting = sample_random_light(ray_hit.world_position, ray_hit.world_normal, &rng);
</span><span>    let pdf_of_bounce = brdf_pdf(wo, direct_lighting.wi, ray_hit);
</span><span>    mis_weight = power_heuristic(1.0 / direct_lighting.inverse_pdf, pdf_of_bounce);
</span><span>    let direct_lighting_brdf = evaluate_brdf(ray_hit.world_normal, wo, direct_lighting.wi, ray_hit.material);
</span><span>    radiance += mis_weight * throughput * direct_lighting.radiance * direct_lighting.inverse_pdf * direct_lighting_brdf;
</span><span>}
</span><span>
</span><span>// BRDF importance sampling
</span><span>let next_bounce = importance_sample_next_bounce(wo, ray_hit, &rng);
</span><span>ray_direction = next_bounce.wi;
</span><span>throughput *= (evaluate_brdf(...) * cos_theta) / next_bounce.pdf;
</span></code></pre><p>The <code>importance_sample_next_bounce</code> function selects between diffuse and specular sampling based on material properties, using the new GGX VNDF sampling for specular:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>if diffuse_selected {
</span><span>    wi = sample_cosine_hemisphere(ray_hit.world_normal, rng);
</span><span>} else {
</span><span>    wi_tangent = sample_ggx_vndf(wo_tangent, ray_hit.material.roughness, rng);
</span><span>    wi = wi_tangent.x * T + wi_tangent.y * B + wi_tangent.z * N;
</span><span>}
</span></code></pre><p>Performance considerations included:<ul><li>Russian roulette termination for long paths<li>Avoiding specular calculations for perfectly smooth surfaces<li>Efficient PDF combination for mixed materials<li>Proper MIS weighting using the power heuristic</ul><p>The changes significantly improve material fidelity while maintaining performance. The pathtracer now handles metallic surfaces, roughness variations, and proper specular reflections. The MIS implementation reduces noise by optimally combining light and BRDF sampling.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[Pathtracer] --> B[BRDF Evaluation]
</span><span>    A --> C[Light Sampling]
</span><span>    A --> D[BRDF Sampling]
</span><span>    B --> E[Diffuse BRDF]
</span><span>    B --> F[Specular BRDF]
</span><span>    D --> G[Cosine Hemisphere]
</span><span>    D --> H[GGX VNDF]
</span><span>    C --> I[MIS]
</span><span>    D --> I
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><p><strong><code>crates/bevy_solari/src/pathtracer/pathtracer.wgsl</code> (+88/-16)</strong><br> Rewrote pathtracer core to implement specular BRDF and MIS:</p> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before (diffuse only):
</span><span>let diffuse_brdf = ray_hit.material.base_color / PI;
</span><span>radiance += throughput * diffuse_brdf * direct_lighting.radiance * direct_lighting.inverse_pdf;
</span><span>ray_direction = sample_cosine_hemisphere(ray_hit.world_normal, &rng);
</span><span>
</span><span>// After (specular + MIS):
</span><span>if !is_perfectly_specular {
</span><span>    let direct_lighting = sample_random_light(...);
</span><span>    let pdf_of_bounce = brdf_pdf(...);
</span><span>    mis_weight = power_heuristic(...);
</span><span>    radiance += mis_weight * throughput * ...;
</span><span>}
</span><span>let next_bounce = importance_sample_next_bounce(...);
</span></code></pre><li><p><strong><code>crates/bevy_solari/src/scene/sampling.wgsl</code> (+57/-2)</strong><br> Added GGX VNDF sampling functions:</p> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// New functions
</span><span>fn sample_ggx_vndf(wi_tangent: vec3&LTf32>, roughness: f32, rng: ptr&LTfunction, u32>) -> vec3&LTf32> {
</span><span>    // GPUOpen implementation
</span><span>}
</span><span>
</span><span>fn ggx_vndf_pdf(wi_tangent: vec3&LTf32>, wo_tangent: vec3&LTf32>, roughness: f32) -> f32 {
</span><span>    // PDF calculation
</span><span>}
</span></code></pre><li><p><strong><code>crates/bevy_solari/src/scene/brdf.wgsl</code> (+56/-0)</strong><br> New BRDF implementation:</p> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn evaluate_brdf(...) -> vec3&LTf32> {
</span><span>    let diffuse_brdf = ...;
</span><span>    let specular_brdf = ...;
</span><span>    return diffuse_brdf + specular_brdf;
</span><span>}
</span></code></pre><li><p><strong><code>crates/bevy_solari/src/scene/raytracing_scene_bindings.wgsl</code> (+41/-10)</strong><br> Extended material and hit data:</p> <pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Material additions
</span><span>struct Material {
</span><span>    // ...
</span><span>    metallic: f32,
</span><span>    reflectance: vec3&LTf32>,
</span><span>    perceptual_roughness: f32,
</span><span>}
</span><span>
</span><span>// Hit data additions
</span><span>struct ResolvedRayHitFull {
</span><span>    world_tangent: vec4&LTf32>,
</span><span>    triangle_count: u32,
</span><span>}
</span></code></pre><li><p><strong><code>crates/bevy_solari/src/scene/binder.rs</code> (+25/-8)</strong><br> Updated Rust-side material representation:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(GpuMaterial {
</span><span>    base_color</span><span style=color:#61676ccc>:</span><span> material</span><span style=color:#ed9366>.</span><span>base_color</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_linear</span><span>()</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(GpuMaterial {
</span><span>    metallic</span><span style=color:#61676ccc>:</span><span> material</span><span style=color:#ed9366>.</span><span>metallic</span><span style=color:#61676ccc>,
</span><span>    reflectance</span><span style=color:#61676ccc>: </span><span>LinearRgba</span><span style=color:#ed9366>::</span><span>from(material</span><span style=color:#ed9366>.</span><span>specular_tint)</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_vec3</span><span>() </span><span style=color:#ed9366>*</span><span> material</span><span style=color:#ed9366>.</span><span>reflectance</span><span style=color:#61676ccc>,
</span><span>    perceptual_roughness</span><span style=color:#61676ccc>:</span><span> material</span><span style=color:#ed9366>.</span><span>perceptual_roughness</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre></ol><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://gpuopen.com/download/Bounded_VNDF_Sampling_for_Smith-GGX_Reflections.pdf target=_blank>Bounded VNDF Sampling for Smith-GGX Reflections</a> - Reference for GGX sampling<li><a rel="noopener nofollow noreferrer" href=https://pbr-book.org/ target=_blank>Physically Based Rendering: From Theory to Implementation</a> - Comprehensive PBR reference<li><a rel="noopener nofollow noreferrer" href=https://graphics.stanford.edu/papers/veach_thesis/chapter9.pdf target=_blank>Multiple Importance Sampling</a> - Veach’s thesis on MIS<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/blob/main/crates/bevy_pbr/src/render/pbr_types.wgsl target=_blank>Bevy PBR Shader Code</a> - Reference for PBR implementations</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-08/pr_20242.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>