diff --git a/crates/bevy_pbr/src/volumetric_fog/render.rs b/crates/bevy_pbr/src/volumetric_fog/render.rs
index 7d1a55700e429..0c558fe2e804d 100644
--- a/crates/bevy_pbr/src/volumetric_fog/render.rs
+++ b/crates/bevy_pbr/src/volumetric_fog/render.rs
@@ -19,7 +19,7 @@ use bevy_ecs::{
 };
 use bevy_image::{BevyDefault, Image};
 use bevy_light::{FogVolume, VolumetricFog, VolumetricLight};
-use bevy_math::{vec4, Mat3A, Mat4, Vec3, Vec3A, Vec4, Vec4Swizzles as _};
+use bevy_math::{vec4, Affine3A, Mat4, Vec3, Vec3A, Vec4};
 use bevy_mesh::{Mesh, MeshVertexBufferLayoutRef};
 use bevy_render::{
     diagnostic::RecordDiagnostics,
@@ -698,12 +698,12 @@ pub fn prepare_volumetric_fog_uniforms(
     fog_volumes: Query<(Entity, &FogVolume, &GlobalTransform)>,
     render_device: Res<RenderDevice>,
     render_queue: Res<RenderQueue>,
-    mut local_from_world_matrices: Local<Vec<Mat4>>,
+    mut local_from_world_matrices: Local<Vec<Affine3A>>,
 ) {
     // Do this up front to avoid O(n^2) matrix inversion.
     local_from_world_matrices.clear();
     for (_, _, fog_transform) in fog_volumes.iter() {
-        local_from_world_matrices.push(fog_transform.to_matrix().inverse());
+        local_from_world_matrices.push(fog_transform.affine().inverse());
     }
 
     let uniform_count = view_targets.iter().len() * local_from_world_matrices.len();
@@ -715,7 +715,7 @@ pub fn prepare_volumetric_fog_uniforms(
     };
 
     for (view_entity, extracted_view, volumetric_fog) in view_targets.iter() {
-        let world_from_view = extracted_view.world_from_view.to_matrix();
+        let world_from_view = extracted_view.world_from_view.affine();
 
         let mut view_fog_volumes = vec![];
 
@@ -736,7 +736,9 @@ pub fn prepare_volumetric_fog_uniforms(
             );
 
             // Calculate the radius of the sphere that bounds the fog volume.
-            let bounding_radius = (Mat3A::from_mat4(view_from_local) * Vec3A::splat(0.5)).length();
+            let bounding_radius = view_from_local
+                .transform_vector3a(Vec3A::splat(0.5))
+                .length();
 
             // Write out our uniform.
             let uniform_buffer_offset = writer.write(&VolumetricFogUniform {
@@ -788,9 +790,8 @@ pub fn prepare_view_depth_textures_for_volumetric_fog(
     }
 }
 
-fn get_far_planes(view_from_local: &Mat4) -> [Vec4; 3] {
+fn get_far_planes(view_from_local: &Affine3A) -> [Vec4; 3] {
     let (mut far_planes, mut next_index) = ([Vec4::ZERO; 3], 0);
-    let view_from_normal_local = Mat3A::from_mat4(*view_from_local);
 
     for &local_normal in &[
         Vec3A::X,
@@ -800,13 +801,15 @@ fn get_far_planes(view_from_local: &Mat4) -> [Vec4; 3] {
         Vec3A::Z,
         Vec3A::NEG_Z,
     ] {
-        let view_normal = (view_from_normal_local * local_normal).normalize_or_zero();
+        let view_normal = view_from_local
+            .transform_vector3a(local_normal)
+            .normalize_or_zero();
         if view_normal.z <= 0.0 {
             continue;
         }
 
-        let view_position = *view_from_local * (-local_normal * 0.5).extend(1.0);
-        let plane_coords = view_normal.extend(-view_normal.dot(view_position.xyz().into()));
+        let view_position = view_from_local.transform_point3a(-local_normal * 0.5);
+        let plane_coords = view_normal.extend(-view_normal.dot(view_position));
 
         far_planes[next_index] = plane_coords;
         next_index += 1;
@@ -846,8 +849,9 @@ impl VolumetricFogBindGroupLayoutKey {
 
 /// Given the transform from the view to the 1×1×1 cube in local fog volume
 /// space, returns true if the camera is inside the volume.
-fn camera_is_inside_fog_volume(local_from_view: &Mat4) -> bool {
-    Vec3A::from(local_from_view.col(3).xyz())
+fn camera_is_inside_fog_volume(local_from_view: &Affine3A) -> bool {
+    local_from_view
+        .translation
         .abs()
         .cmple(Vec3A::splat(0.5))
         .all()
@@ -858,10 +862,10 @@ fn camera_is_inside_fog_volume(local_from_view: &Mat4) -> bool {
 fn calculate_fog_volume_clip_from_local_transforms(
     interior: bool,
     clip_from_view: &Mat4,
-    view_from_local: &Mat4,
+    view_from_local: &Affine3A,
 ) -> Mat4 {
     if !interior {
-        return *clip_from_view * *view_from_local;
+        return *clip_from_view * Mat4::from(*view_from_local);
     }
 
     // If the camera is inside the fog volume, then we'll be rendering a full
