diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index ee1540ba6eb91..9e3a611c318af 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -74,10 +74,13 @@ bluenoise_texture = ["bevy_pbr?/bluenoise_texture"]
 smaa_luts = ["bevy_anti_aliasing/smaa_luts"]
 
 # NVIDIA Deep Learning Super Sampling
-dlss = ["bevy_anti_aliasing/dlss"]
+dlss = ["bevy_anti_aliasing/dlss", "bevy_solari?/dlss"]
 
 # Forcibly disable DLSS so that cargo build --all-features works without the DLSS SDK being installed. Not meant for users.
-force_disable_dlss = ["bevy_anti_aliasing?/force_disable_dlss"]
+force_disable_dlss = [
+  "bevy_anti_aliasing?/force_disable_dlss",
+  "bevy_solari?/force_disable_dlss",
+]
 
 # Audio format support (vorbis is enabled by default)
 flac = ["bevy_audio/flac"]
diff --git a/crates/bevy_solari/Cargo.toml b/crates/bevy_solari/Cargo.toml
index 1b80c65c8a8c9..4cfb46c742f6e 100644
--- a/crates/bevy_solari/Cargo.toml
+++ b/crates/bevy_solari/Cargo.toml
@@ -10,6 +10,7 @@ keywords = ["bevy"]
 
 [dependencies]
 # bevy
+bevy_anti_aliasing = { path = "../bevy_anti_aliasing", version = "0.17.0-dev" }
 bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
 bevy_asset = { path = "../bevy_asset", version = "0.17.0-dev" }
 bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
@@ -36,6 +37,10 @@ bytemuck = { version = "1" }
 derive_more = { version = "2", default-features = false, features = ["from"] }
 tracing = { version = "0.1", default-features = false, features = ["std"] }
 
+[features]
+dlss = ["bevy_anti_aliasing/dlss"]
+force_disable_dlss = ["bevy_anti_aliasing/force_disable_dlss"]
+
 [lints]
 workspace = true
 
diff --git a/crates/bevy_solari/src/realtime/mod.rs b/crates/bevy_solari/src/realtime/mod.rs
index ac0ef457022f3..04e3528e63004 100644
--- a/crates/bevy_solari/src/realtime/mod.rs
+++ b/crates/bevy_solari/src/realtime/mod.rs
@@ -39,6 +39,9 @@ impl Plugin for SolariLightingPlugin {
         embedded_asset!(app, "world_cache_compact.wgsl");
         embedded_asset!(app, "world_cache_update.wgsl");
 
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        embedded_asset!(app, "resolve_dlss_rr_textures.wgsl");
+
         app.insert_resource(DefaultOpaqueRendererMethod::deferred());
     }
 
diff --git a/crates/bevy_solari/src/realtime/node.rs b/crates/bevy_solari/src/realtime/node.rs
index 02ec72e729bab..79a4eda3d9dff 100644
--- a/crates/bevy_solari/src/realtime/node.rs
+++ b/crates/bevy_solari/src/realtime/node.rs
@@ -3,6 +3,8 @@ use super::{
     SolariLighting,
 };
 use crate::scene::RaytracingSceneBindings;
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_anti_aliasing::dlss::ViewDlssRayReconstructionTextures;
 use bevy_asset::{load_embedded_asset, Handle};
 use bevy_core_pipeline::prepass::{
     PreviousViewData, PreviousViewUniformOffset, PreviousViewUniforms, ViewPrepassTextures,
@@ -40,6 +42,8 @@ pub mod graph {
 pub struct SolariLightingNode {
     bind_group_layout: BindGroupLayout,
     bind_group_layout_world_cache_active_cells_dispatch: BindGroupLayout,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    bind_group_layout_resolve_dlss_rr_textures: BindGroupLayout,
     decay_world_cache_pipeline: CachedComputePipelineId,
     compact_world_cache_single_block_pipeline: CachedComputePipelineId,
     compact_world_cache_blocks_pipeline: CachedComputePipelineId,
@@ -51,9 +55,12 @@ pub struct SolariLightingNode {
     di_spatial_and_shade_pipeline: CachedComputePipelineId,
     gi_initial_and_temporal_pipeline: CachedComputePipelineId,
     gi_spatial_and_shade_pipeline: CachedComputePipelineId,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    resolve_dlss_rr_textures_pipeline: CachedComputePipelineId,
 }
 
 impl ViewNode for SolariLightingNode {
+    #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))]
     type ViewQuery = (
         &'static SolariLighting,
         &'static SolariLightingResources,
@@ -62,12 +69,22 @@ impl ViewNode for SolariLightingNode {
         &'static ViewUniformOffset,
         &'static PreviousViewUniformOffset,
     );
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    type ViewQuery = (
+        &'static SolariLighting,
+        &'static SolariLightingResources,
+        &'static ViewTarget,
+        &'static ViewPrepassTextures,
+        &'static ViewUniformOffset,
+        &'static PreviousViewUniformOffset,
+        Option<&'static ViewDlssRayReconstructionTextures>,
+    );
 
     fn run(
         &self,
         _graph: &mut RenderGraphContext,
         render_context: &mut RenderContext,
-        (
+        #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))] (
             solari_lighting,
             solari_lighting_resources,
             view_target,
@@ -75,6 +92,15 @@ impl ViewNode for SolariLightingNode {
             view_uniform_offset,
             previous_view_uniform_offset,
         ): QueryItem<Self::ViewQuery>,
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] (
+            solari_lighting,
+            solari_lighting_resources,
+            view_target,
+            view_prepass_textures,
+            view_uniform_offset,
+            previous_view_uniform_offset,
+            view_dlss_rr_textures,
+        ): QueryItem<Self::ViewQuery>,
         world: &World,
     ) -> Result<(), NodeRunError> {
         let pipeline_cache = world.resource::<PipelineCache>();
@@ -123,6 +149,12 @@ impl ViewNode for SolariLightingNode {
         else {
             return Ok(());
         };
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let Some(resolve_dlss_rr_textures_pipeline) =
+            pipeline_cache.get_compute_pipeline(self.resolve_dlss_rr_textures_pipeline)
+        else {
+            return Ok(());
+        };
 
         let s = solari_lighting_resources;
         let bind_group = render_context.render_device().create_bind_group(
@@ -160,6 +192,19 @@ impl ViewNode for SolariLightingNode {
                 &self.bind_group_layout_world_cache_active_cells_dispatch,
                 &BindGroupEntries::single(s.world_cache_active_cells_dispatch.as_entire_binding()),
             );
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let bind_group_resolve_dlss_rr_textures = view_dlss_rr_textures.map(|d| {
+            render_context.render_device().create_bind_group(
+                "solari_lighting_bind_group_resolve_dlss_rr_textures",
+                &self.bind_group_layout_resolve_dlss_rr_textures,
+                &BindGroupEntries::sequential((
+                    &d.diffuse_albedo.default_view,
+                    &d.specular_albedo.default_view,
+                    &d.normal_roughness.default_view,
+                    &d.specular_motion_vectors.default_view,
+                )),
+            )
+        });
 
         // Choice of number here is arbitrary
         let frame_index = frame_count.0.wrapping_mul(5782582);
@@ -185,6 +230,14 @@ impl ViewNode for SolariLightingNode {
                 previous_view_uniform_offset.offset,
             ],
         );
+
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        if let Some(bind_group_resolve_dlss_rr_textures) = bind_group_resolve_dlss_rr_textures {
+            pass.set_bind_group(2, &bind_group_resolve_dlss_rr_textures, &[]);
+            pass.set_pipeline(resolve_dlss_rr_textures_pipeline);
+            pass.dispatch_workgroups(dx, dy, 1);
+        }
+
         pass.set_bind_group(2, &bind_group_world_cache_active_cells_dispatch, &[]);
 
         pass.set_pipeline(decay_world_cache_pipeline);
@@ -333,6 +386,20 @@ impl FromWorld for SolariLightingNode {
                 ),
             );
 
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let bind_group_layout_resolve_dlss_rr_textures = render_device.create_bind_group_layout(
+            "solari_lighting_bind_group_layout_resolve_dlss_rr_textures",
+            &BindGroupLayoutEntries::sequential(
+                ShaderStages::COMPUTE,
+                (
+                    texture_storage_2d(TextureFormat::Rgba8Unorm, StorageTextureAccess::WriteOnly),
+                    texture_storage_2d(TextureFormat::Rgba8Unorm, StorageTextureAccess::WriteOnly),
+                    texture_storage_2d(TextureFormat::Rgba16Float, StorageTextureAccess::WriteOnly),
+                    texture_storage_2d(TextureFormat::Rg16Float, StorageTextureAccess::WriteOnly),
+                ),
+            ),
+        );
+
         let create_pipeline = |label: &'static str,
                                entry_point: &'static str,
                                shader: Handle<Shader>,
@@ -370,6 +437,9 @@ impl FromWorld for SolariLightingNode {
             bind_group_layout: bind_group_layout.clone(),
             bind_group_layout_world_cache_active_cells_dispatch:
                 bind_group_layout_world_cache_active_cells_dispatch.clone(),
+            #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+            bind_group_layout_resolve_dlss_rr_textures: bind_group_layout_resolve_dlss_rr_textures
+                .clone(),
             decay_world_cache_pipeline: create_pipeline(
                 "solari_lighting_decay_world_cache_pipeline",
                 "decay_world_cache",
@@ -447,6 +517,14 @@ impl FromWorld for SolariLightingNode {
                 None,
                 vec![],
             ),
+            #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+            resolve_dlss_rr_textures_pipeline: create_pipeline(
+                "solari_lighting_resolve_dlss_rr_textures_pipeline",
+                "resolve_dlss_rr_textures",
+                load_embedded_asset!(world, "resolve_dlss_rr_textures.wgsl"),
+                Some(&bind_group_layout_resolve_dlss_rr_textures),
+                vec![],
+            ),
         }
     }
 }
diff --git a/crates/bevy_solari/src/realtime/prepare.rs b/crates/bevy_solari/src/realtime/prepare.rs
index 68e8af9dd26b4..b803269a07a01 100644
--- a/crates/bevy_solari/src/realtime/prepare.rs
+++ b/crates/bevy_solari/src/realtime/prepare.rs
@@ -1,6 +1,12 @@
 use super::SolariLighting;
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_anti_aliasing::dlss::{
+    Dlss, DlssRayReconstructionFeature, ViewDlssRayReconstructionTextures,
+};
 use bevy_camera::MainPassResolutionOverride;
 use bevy_core_pipeline::{core_3d::CORE_3D_DEPTH_FORMAT, deferred::DEFERRED_PREPASS_FORMAT};
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_ecs::query::Has;
 use bevy_ecs::{
     component::Component,
     entity::Entity,
@@ -9,6 +15,8 @@ use bevy_ecs::{
 };
 use bevy_image::ToExtents;
 use bevy_math::UVec2;
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_render::texture::CachedTexture;
 use bevy_render::{
     camera::ExtractedCamera,
     render_resource::{
@@ -58,19 +66,35 @@ pub struct SolariLightingResources {
 }
 
 pub fn prepare_solari_lighting_resources(
-    query: Query<
+    #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))] query: Query<
+        (
+            Entity,
+            &ExtractedCamera,
+            Option<&SolariLightingResources>,
+            Option<&MainPassResolutionOverride>,
+        ),
+        With<SolariLighting>,
+    >,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] query: Query<
         (
             Entity,
             &ExtractedCamera,
             Option<&SolariLightingResources>,
             Option<&MainPassResolutionOverride>,
+            Has<Dlss<DlssRayReconstructionFeature>>,
         ),
         With<SolariLighting>,
     >,
     render_device: Res<RenderDevice>,
     mut commands: Commands,
 ) {
-    for (entity, camera, solari_lighting_resources, resolution_override) in &query {
+    for query_item in &query {
+        #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))]
+        let (entity, camera, solari_lighting_resources, resolution_override) = query_item;
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let (entity, camera, solari_lighting_resources, resolution_override, has_dlss_rr) =
+            query_item;
+
         let Some(mut view_size) = camera.physical_viewport_size else {
             continue;
         };
@@ -241,5 +265,80 @@ pub fn prepare_solari_lighting_resources(
             world_cache_active_cells_dispatch,
             view_size,
         });
+
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        if has_dlss_rr {
+            let diffuse_albedo = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_diffuse_albedo"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rgba8Unorm,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let diffuse_albedo_view = diffuse_albedo.create_view(&TextureViewDescriptor::default());
+
+            let specular_albedo = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_specular_albedo"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rgba8Unorm,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let specular_albedo_view =
+                specular_albedo.create_view(&TextureViewDescriptor::default());
+
+            let normal_roughness = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_normal_roughness"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rgba16Float,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let normal_roughness_view =
+                normal_roughness.create_view(&TextureViewDescriptor::default());
+
+            let specular_motion_vectors = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_specular_motion_vectors"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rg16Float,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let specular_motion_vectors_view =
+                specular_motion_vectors.create_view(&TextureViewDescriptor::default());
+
+            commands
+                .entity(entity)
+                .insert(ViewDlssRayReconstructionTextures {
+                    diffuse_albedo: CachedTexture {
+                        texture: diffuse_albedo,
+                        default_view: diffuse_albedo_view,
+                    },
+                    specular_albedo: CachedTexture {
+                        texture: specular_albedo,
+                        default_view: specular_albedo_view,
+                    },
+                    normal_roughness: CachedTexture {
+                        texture: normal_roughness,
+                        default_view: normal_roughness_view,
+                    },
+                    specular_motion_vectors: CachedTexture {
+                        texture: specular_motion_vectors,
+                        default_view: specular_motion_vectors_view,
+                    },
+                });
+        }
     }
 }
diff --git a/crates/bevy_solari/src/realtime/resolve_dlss_rr_textures.wgsl b/crates/bevy_solari/src/realtime/resolve_dlss_rr_textures.wgsl
new file mode 100644
index 0000000000000..007498968bfb0
--- /dev/null
+++ b/crates/bevy_solari/src/realtime/resolve_dlss_rr_textures.wgsl
@@ -0,0 +1,28 @@
+#import bevy_pbr::pbr_deferred_types::unpack_24bit_normal
+#import bevy_pbr::utils::octahedral_decode
+#import bevy_render::view::View
+
+@group(1) @binding(7) var gbuffer: texture_2d<u32>;
+@group(1) @binding(12) var<uniform> view: View;
+
+@group(2) @binding(0) var diffuse_albedo: texture_storage_2d<rgba8unorm, write>;
+@group(2) @binding(1) var specular_albedo: texture_storage_2d<rgba8unorm, write>;
+@group(2) @binding(2) var normal_roughness: texture_storage_2d<rgba16float, write>;
+@group(2) @binding(3) var specular_motion_vectors: texture_storage_2d<rg16float, write>;
+
+@compute @workgroup_size(8, 8, 1)
+fn resolve_dlss_rr_textures(@builtin(global_invocation_id) global_id: vec3<u32>) {
+    let pixel_id = global_id.xy;
+    if any(pixel_id >= vec2u(view.main_pass_viewport.zw)) { return; }
+
+    let gpixel = textureLoad(gbuffer, pixel_id, 0);
+    let base_rough = unpack4x8unorm(gpixel.r);
+    let base_color = pow(base_rough.rgb, vec3(2.2));
+    let world_normal = octahedral_decode(unpack_24bit_normal(gpixel.a));
+    let perceptual_roughness = base_rough.a;
+
+    textureStore(diffuse_albedo, pixel_id, vec4(base_color, 0.0));
+    textureStore(specular_albedo, pixel_id, vec4(0.0)); // TODO
+    textureStore(normal_roughness, pixel_id, vec4(world_normal, perceptual_roughness));
+    textureStore(specular_motion_vectors, pixel_id, vec4(0.0)); // TODO
+}
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 57a9ddd4ac517..8907f8433f99f 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -18,6 +18,11 @@ use bevy::{
 use camera_controller::{CameraController, CameraControllerPlugin};
 use std::f32::consts::PI;
 
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy::anti_aliasing::dlss::{
+    Dlss, DlssProjectId, DlssRayReconstructionFeature, DlssRayReconstructionSupported,
+};
+
 /// `bevy_solari` demo.
 #[derive(FromArgs, Resource, Clone, Copy)]
 struct Args {
@@ -30,6 +35,12 @@ fn main() {
     let args: Args = argh::from_env();
 
     let mut app = App::new();
+
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    app.insert_resource(DlssProjectId(bevy_asset::uuid::uuid!(
+        "5417916c-0291-4e3f-8f65-326c1858ab96" // Don't copy paste this - generate your own UUID!
+    )));
+
     app.add_plugins((DefaultPlugins, SolariPlugins, CameraControllerPlugin))
         .insert_resource(args)
         .add_systems(Startup, setup);
@@ -41,7 +52,14 @@ fn main() {
     app.run();
 }
 
-fn setup(mut commands: Commands, asset_server: Res<AssetServer>, args: Res<Args>) {
+fn setup(
+    mut commands: Commands,
+    asset_server: Res<AssetServer>,
+    args: Res<Args>,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] dlss_rr_supported: Option<
+        Res<DlssRayReconstructionSupported>,
+    >,
+) {
     commands
         .spawn(SceneRoot(asset_server.load(
             GltfAssetLabel::Scene(0).from_asset("models/CornellBox/CornellBox.glb"),
@@ -73,11 +91,22 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>, args: Res<Args>
         CameraMainTextureUsages::default().with(TextureUsages::STORAGE_BINDING),
         Msaa::Off,
     ));
+
     if args.pathtracer == Some(true) {
         camera.insert(Pathtracer::default());
     } else {
         camera.insert(SolariLighting::default());
     }
+
+    // Using DLSS Ray Reconstruction for denoising (and cheaper rendering via upscaling) is _highly_ recommended when using Solari
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    if dlss_rr_supported.is_some() {
+        camera.insert(Dlss::<DlssRayReconstructionFeature> {
+            perf_quality_mode: Default::default(),
+            reset: Default::default(),
+            _phantom_data: Default::default(),
+        });
+    }
 }
 
 fn add_raytracing_meshes_on_scene_load(
diff --git a/release-content/release-notes/bevy_solari.md b/release-content/release-notes/bevy_solari.md
index ed80e0a250b29..cfe89f6576927 100644
--- a/release-content/release-notes/bevy_solari.md
+++ b/release-content/release-notes/bevy_solari.md
@@ -1,9 +1,11 @@
 ---
 title: Initial raytraced lighting progress (bevy_solari)
 authors: ["@JMS55", "@SparkyPotato"]
-pull_requests: [19058, 19620, 19790, 20020, 20113, 20156, 20213, 20242, 20259, 20406, 20457, 20580]
+pull_requests: [19058, 19620, 19790, 20020, 20113, 20156, 20213, 20242, 20259, 20406, 20457, 20580, 20596]
 ---
 
+## Overview
+
 (TODO: Embed solari example screenshot here)
 
 In Bevy 0.17, we've made the first steps towards realtime raytraced lighting in the form of the new bevy_solari crate.
@@ -25,7 +27,23 @@ The problem with these methods is that they all have large downsides:
 
 Bevy Solari is intended as a completely alternate, high-end lighting solution for Bevy that uses GPU-accelerated raytracing to fix all of the above problems. Emissive meshes properly cast light and shadows, you can have hundreds of shadow casting lights, quality is much better, it requires no baking time, and it supports _fully_ dynamic scenes!
 
-While Bevy 0.17 adds the bevy_solari crate, it's intended as a long-term project. It is not yet usable by game developers. However, feel free to run the solari example (`cargo run --release --example solari --features bevy_solari` (realtime, no denoising) or `cargo run --release --example solari --features bevy_solari -- --pathtracer` (non-realtime)) to check out the progress we've made, and look forward to more work on Bevy Solari in future releases!
+## Try it out
+
+While Bevy 0.17 adds the bevy_solari crate, it is not yet production ready.
+
+However, feel free to run the solari example to check out the progress we've made. There are two different modes you can try out:
+
+A non-realtime "reference" mode that uses pathtracing: `cargo run --release --example solari --features bevy_solari -- --pathtracer`.
+
+A realtime mode that uses a combination of techniques, and currently supports only diffuse materials: `cargo run --release --example solari --features bevy_solari`.
+
+Additionally, if you have a NVIDIA GPU, you can enable DLSS Ray Reconstruction with the realtime mode for a combination of denoising (Bevy Solari does not otherwise come with a denoiser), lower rendering times, and anti aliasing: `cargo run --release --example solari --features bevy_solari,dlss`.
+
+## How it works
+
+TODO: Showcase the different aspects/steps of Solari (direct initial+temporal+spatial, indirect initial+temporal+spatial, world cache, DLSS RR)
+
+Look forward to more work on Bevy Solari in future releases!
 
 (TODO: Embed bevy_solari logo here, or somewhere else that looks good)
 
