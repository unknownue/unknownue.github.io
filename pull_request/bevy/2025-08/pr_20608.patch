diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
index 87e2b43199d63..61165f2760418 100644
--- a/crates/bevy_gltf/src/loader/mod.rs
+++ b/crates/bevy_gltf/src/loader/mod.rs
@@ -1539,10 +1539,19 @@ fn load_node(
                     // > the accessors of the original primitive.
                     mesh_entity.insert(MeshMorphWeights::new(weights).unwrap());
                 }
-                mesh_entity.insert(Aabb::from_min_max(
-                    Vec3::from_slice(&bounds.min),
-                    Vec3::from_slice(&bounds.max),
-                ));
+
+                let mut bounds_min = Vec3::from_slice(&bounds.min);
+                let mut bounds_max = Vec3::from_slice(&bounds.max);
+
+                if convert_coordinates {
+                    let converted_min = bounds_min.convert_coordinates();
+                    let converted_max = bounds_max.convert_coordinates();
+
+                    bounds_min = converted_min.min(converted_max);
+                    bounds_max = converted_min.max(converted_max);
+                }
+
+                mesh_entity.insert(Aabb::from_min_max(bounds_min, bounds_max));
 
                 if let Some(extras) = primitive.extras() {
                     mesh_entity.insert(GltfExtras {
diff --git a/examples/testbed/3d.rs b/examples/testbed/3d.rs
index 0a897b85b036d..bfa2fbf648591 100644
--- a/examples/testbed/3d.rs
+++ b/examples/testbed/3d.rs
@@ -16,8 +16,17 @@ fn main() {
         .add_systems(OnEnter(Scene::Gltf), gltf::setup)
         .add_systems(OnEnter(Scene::Animation), animation::setup)
         .add_systems(OnEnter(Scene::Gizmos), gizmos::setup)
+        .add_systems(
+            OnEnter(Scene::GltfCoordinateConversion),
+            gltf_coordinate_conversion::setup,
+        )
         .add_systems(Update, switch_scene)
-        .add_systems(Update, gizmos::draw_gizmos.run_if(in_state(Scene::Gizmos)));
+        .add_systems(Update, gizmos::draw_gizmos.run_if(in_state(Scene::Gizmos)))
+        .add_systems(
+            Update,
+            gltf_coordinate_conversion::draw_gizmos
+                .run_if(in_state(Scene::GltfCoordinateConversion)),
+        );
 
     #[cfg(feature = "bevy_ci_testing")]
     app.add_systems(Update, helpers::switch_scene_in_ci::<Scene>);
@@ -33,6 +42,7 @@ enum Scene {
     Gltf,
     Animation,
     Gizmos,
+    GltfCoordinateConversion,
 }
 
 impl Next for Scene {
@@ -42,7 +52,8 @@ impl Next for Scene {
             Scene::Bloom => Scene::Gltf,
             Scene::Gltf => Scene::Animation,
             Scene::Animation => Scene::Gizmos,
-            Scene::Gizmos => Scene::Light,
+            Scene::Gizmos => Scene::GltfCoordinateConversion,
+            Scene::GltfCoordinateConversion => Scene::Light,
         }
     }
 }
@@ -340,3 +351,78 @@ mod gizmos {
         }
     }
 }
+
+mod gltf_coordinate_conversion {
+    use bevy::{
+        color::palettes::basic::*, gltf::GltfLoaderSettings, prelude::*, scene::SceneInstanceReady,
+    };
+
+    const CURRENT_SCENE: super::Scene = super::Scene::GltfCoordinateConversion;
+
+    pub fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
+        commands.spawn((
+            Camera3d::default(),
+            Transform::from_xyz(-4.0, 4.0, -5.0).looking_at(Vec3::ZERO, Vec3::Y),
+            DespawnOnExitState(CURRENT_SCENE),
+        ));
+
+        commands.spawn((
+            DirectionalLight {
+                color: BLUE.into(),
+                ..default()
+            },
+            Transform::IDENTITY.looking_to(Dir3::Z, Dir3::Y),
+            DespawnOnExitState(CURRENT_SCENE),
+        ));
+
+        commands.spawn((
+            DirectionalLight {
+                color: RED.into(),
+                ..default()
+            },
+            Transform::IDENTITY.looking_to(Dir3::X, Dir3::Y),
+            DespawnOnExitState(CURRENT_SCENE),
+        ));
+
+        commands.spawn((
+            DirectionalLight {
+                color: GREEN.into(),
+                ..default()
+            },
+            Transform::IDENTITY.looking_to(Dir3::NEG_Y, Dir3::X),
+            DespawnOnExitState(CURRENT_SCENE),
+        ));
+
+        commands
+            .spawn((
+                SceneRoot(asset_server.load_with_settings(
+                    GltfAssetLabel::Scene(0).from_asset("models/Faces/faces.glb"),
+                    |s: &mut GltfLoaderSettings| {
+                        s.use_model_forward_direction = Some(true);
+                    },
+                )),
+                DespawnOnExitState(CURRENT_SCENE),
+            ))
+            .observe(show_aabbs);
+    }
+
+    pub fn show_aabbs(
+        trigger: On<SceneInstanceReady>,
+        mut commands: Commands,
+        children: Query<&Children>,
+        meshes: Query<(), With<Mesh3d>>,
+    ) {
+        for child in children
+            .iter_descendants(trigger.target())
+            .filter(|&e| meshes.contains(e))
+        {
+            commands.entity(child).insert(ShowAabbGizmo {
+                color: Some(BLACK.into()),
+            });
+        }
+    }
+
+    pub fn draw_gizmos(mut gizmos: Gizmos) {
+        gizmos.axes(Transform::IDENTITY, 1.0);
+    }
+}
