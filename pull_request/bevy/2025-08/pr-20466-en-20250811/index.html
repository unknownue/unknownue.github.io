<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20466 Update Game of Life compute example to include a uniform buffer variable
        
    </title><meta content="#20466 Update Game of Life compute example to include a uniform buffer variable" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-08/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-08-11</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-08/pr-20466-zh-cn-20250811>中文</a></div></div><div class=pr-content><h2 id=analysis-of-pr-20466-update-game-of-life-compute-example-to-include-a-uniform-buffer-variable>Analysis of PR #20466: Update Game of Life compute example to include a uniform buffer variable</h2><h3 id=basic-information>Basic Information</h3><ul><li><strong>Title</strong>: Update Game of Life compute example to include a uniform buffer variable<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20466<li><strong>Author</strong>: dontgetfoundout<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Examples, S-Ready-For-Final-Review, X-Contentious<li><strong>Created</strong>: 2025-08-09T02:25:52Z<li><strong>Merged</strong>: 2025-08-11T23:11:40Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h3 id=description-translation>Description Translation</h3><p>The original description is in English and is preserved exactly as-is:<h1 id=objective>Objective</h1><p>It is currently a little unclear how to use uniform buffers in compute shaders. The other examples of uniform buffers in the Bevy examples and codebase either are built on Materials or use <code>DynamicUniformBuffer</code>s created from a <code>ViewNode</code>. Neither of these are a great fit for use in a compute shader.<h2 id=solution>Solution</h2><p>Update the compute shader example to pass a uniform buffer to the shader that determines the color for alive cells.<h2 id=discussion-topics>Discussion Topics</h2><ul><li>Is this the right way to pass this data to the shader?<li>Should we be encouraging use of uniform buffers in compute shaders at all? Some in the community prefer the ergonomics of storage buffers in most (all?) compute shader cases. Do we want to push users to use storage buffers instead?<li>I took the idea to use color as the input from IceSentry on Discord, but this did require me to change the texture format to support non-red colors. Does this undermine the goals of the shader example? Is this the wrong texture format?</ul><h2 id=testing>Testing</h2><ul><li>Did you test these changes? If so, how? <ul><li>The changes were manually validated with a number of different <code>LinearRgba</code> values for <code>alive_color</code></ul><li>Are there any parts that need more testing?<li>How can other people (reviewers) test your changes? Is there anything specific they need to know? <ul><li><code>cargo run --example compute_shader_game_of_life</code><li>Color can be set using <code>alive_color</code> property on <code>GameOfLifeUniforms</code></ul><li>If relevant, what platforms did you test these changes on, and are there any important ones you can’t test? <ul><li>Manually validated on Windows and WASM (WebGPU) targets <ul><li>WASM WebGL2 doesn’t appear to support textures in compute shaders</ul></ul></ul><hr><h2 id=showcase>Showcase</h2><img alt=image height=939 src=https://github.com/user-attachments/assets/9a535617-a179-4f20-b686-596899f11d18 width=1602><h3 id=the-story-of-this-pull-request>The Story of This Pull Request</h3><h4 id=the-problem-and-context>The Problem and Context</h4><p>The existing Bevy compute shader examples lacked a clear demonstration of how to use uniform buffers in compute shaders. Existing implementations either relied on Material systems or DynamicUniformBuffers tied to ViewNodes, neither of which are suitable for pure compute shader workflows. This gap made it difficult for developers to understand how to pass uniform data directly to compute shaders, a common requirement for GPU computation tasks.<h4 id=the-solution-approach>The Solution Approach</h4><p>The solution introduces a uniform buffer to pass configuration data (specifically alive cell color) to the Game of Life compute shader. This required:<ol><li>Changing texture formats to support RGBA color data<li>Adding a uniform buffer binding to the shader<li>Creating corresponding Rust structs and buffer management<li>Maintaining backward compatibility by storing cell state in the alpha channel</ol><p>The author considered alternative approaches like storage buffers but chose uniforms as they’re simpler for small, frequently updated data. The color parameter was added to demonstrate practical usage while maintaining the simulation’s core logic.<h4 id=the-implementation>The Implementation</h4><p>The implementation modifies both the shader code and Rust example. The shader now uses RGBA textures instead of single-channel textures, storing cell state in the alpha channel while using RGB for display color. A new uniform buffer struct holds the alive color configuration.<p>In the Rust code:<ol><li>Texture format changed from R32Float to Rgba32Float<li>Added GameOfLifeUniforms resource with alive_color field<li>Created uniform buffer binding in the layout<li>Updated bind groups to include the uniform buffer<li>Added buffer upload logic to the prepare system</ol><h4 id=technical-insights>Technical Insights</h4><p>Key technical aspects:<ul><li><strong>Texture Format Change</strong>: Required to support color data (RGBA32Float instead of R32Float)<li><strong>State Preservation</strong>: Cell state maintained in alpha channel to avoid breaking simulation logic<li><strong>Uniform Buffer Usage</strong>: Demonstrates buffer creation, writing, and binding<li><strong>Resource Extraction</strong>: Uses ExtractResourcePlugin for uniform data<li><strong>Cross-Platform Considerations</strong>: Tested on Windows and WebGPU (WASM)</ul><p>The uniform buffer approach is optimal for small, frequently updated data (&LT4KB). For larger datasets, storage buffers would be more appropriate, as acknowledged in the code comments.<h4 id=the-impact>The Impact</h4><p>These changes:<ol><li>Provide a clear reference for uniform buffer usage in compute shaders<li>Demonstrate proper resource extraction and buffer management<li>Maintain backward compatibility with existing simulation logic<li>Improve visual customization through color parameters<li>Validate WebGPU compatibility for the pattern</ol><p>The solution balances educational value with practical implementation, though it intentionally leaves open questions about alternative buffer types to encourage community discussion.<h3 id=visual-representation>Visual Representation</h3><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[GameOfLifeUniforms] -->|Extracted to| B(Render World)
</span><span>    B -->|Processed in| C(Prepare System)
</span><span>    C -->|Creates| D(Uniform Buffer)
</span><span>    D -->|Bound as| E(Compute Shader Binding)
</span><span>    F(Input Texture) -->|Read by| E
</span><span>    E -->|Writes to| G(Output Texture)
</span></code></pre><h3 id=key-files-changed>Key Files Changed</h3><h4 id=1-assets-shaders-game-of-life-wgsl>1. <code>assets/shaders/game_of_life.wgsl</code></h4><p><strong>Changes</strong>: Added uniform buffer support and modified texture formats<br> <strong>Purpose</strong>: Enable color configuration and maintain cell state in alpha channel<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>@group(0) @binding(0) var input: texture_storage_2d&LTr32float, read>;
</span><span>@group(0) @binding(1) var output: texture_storage_2d&LTr32float, write>;
</span><span>
</span><span>fn is_alive(location: vec2&LTi32>, offset_x: i32, offset_y: i32) -> i32 {
</span><span>    let value: vec4&LTf32> = textureLoad(input, location + vec2&LTi32>(offset_x, offset_y));
</span><span>    return i32(value.x);
</span><span>}
</span><span>
</span><span>// After:
</span><span>@group(0) @binding(0) var input: texture_storage_2d&LTrgba32float, read>;
</span><span>@group(0) @binding(1) var output: texture_storage_2d&LTrgba32float, write>;
</span><span>@group(0) @binding(2) var&LTuniform> config: GameOfLifeUniforms;
</span><span>
</span><span>struct GameOfLifeUniforms {
</span><span>    alive_color: vec4&LTf32>,
</span><span>}
</span><span>
</span><span>fn is_alive(location: vec2&LTi32>, offset_x: i32, offset_y: i32) -> i32 {
</span><span>    let value: vec4&LTf32> = textureLoad(input, location + vec2&LTi32>(offset_x, offset_y));
</span><span>    return i32(value.a);
</span><span>}
</span></code></pre><h4 id=2-examples-shader-compute-shader-game-of-life-rs>2. <code>examples/shader/compute_shader_game_of_life.rs</code></h4><p><strong>Changes</strong>: Added uniform buffer handling and updated texture formats<br> <strong>Purpose</strong>: Create and manage uniform buffer resources<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let mut</span><span> image </span><span style=color:#ed9366>= </span><span>Image</span><span style=color:#ed9366>::</span><span>new_target_texture(</span><span style=color:#ff8f40>SIZE</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>SIZE</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span>TextureFormat</span><span style=color:#ed9366>::</span><span>R32Float)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let mut</span><span> image </span><span style=color:#ed9366>= </span><span>Image</span><span style=color:#ed9366>::</span><span>new_target_texture(</span><span style=color:#ff8f40>SIZE</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>SIZE</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span>TextureFormat</span><span style=color:#ed9366>::</span><span>Rgba32Float)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Added resource:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> ExtractResource</span><span style=color:#61676ccc>,</span><span> ShaderType)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>GameOfLifeUniforms </span><span>{
</span><span>    alive_color</span><span style=color:#61676ccc>:</span><span> LinearRgba,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// In prepare_bind_group:
</span><span style=color:#fa6e32>let mut</span><span> uniform_buffer </span><span style=color:#ed9366>= </span><span>UniformBuffer</span><span style=color:#ed9366>::</span><span>from(game_of_life_uniforms</span><span style=color:#ed9366>.</span><span style=color:#f07171>into_inner</span><span>())</span><span style=color:#61676ccc>;
</span><span>uniform_buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>render_device</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>queue)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Updated bind group layout:
</span><span style=color:#ed9366>&</span><span>BindGroupLayoutEntries</span><span style=color:#ed9366>::</span><span>sequential(
</span><span>    ShaderStages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COMPUTE</span><span style=color:#61676ccc>,
</span><span>    (
</span><span>        </span><span style=color:#f07171>texture_storage_2d</span><span>(TextureFormat</span><span style=color:#ed9366>::</span><span>Rgba32Float</span><span style=color:#61676ccc>, </span><span>StorageTextureAccess</span><span style=color:#ed9366>::</span><span>ReadOnly)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#f07171>texture_storage_2d</span><span>(TextureFormat</span><span style=color:#ed9366>::</span><span>Rgba32Float</span><span style=color:#61676ccc>, </span><span>StorageTextureAccess</span><span style=color:#ed9366>::</span><span>WriteOnly)</span><span style=color:#61676ccc>,
</span><span>        uniform_buffer</span><span style=color:#ed9366>::</span><span>&LTGameOfLifeUniforms>(</span><span style=color:#ff8f40>false</span><span>)</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>,
</span></code></pre><h3 id=further-reading>Further Reading</h3><ol><li><a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/wgsl/#uniform-buffer target=_blank>WGSL Uniform Buffer Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/rendering/ target=_blank>Bevy Render Pipeline Guide</a><li><a rel="noopener nofollow noreferrer" href=https://webgpufundamentals.org/webgpu/lessons/webgpu-uniforms.html target=_blank>WebGPU Buffer Usage Best Practices</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/gpuweb/gpuweb/wiki/Buffer-Usage target=_blank>Comparison of Uniform vs Storage Buffers</a></ol><h3 id=full-code-diff>Full Code Diff</h3><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/assets/shaders/game_of_life.wgsl b/assets/shaders/game_of_life.wgsl
</span><span>index 0eb5e32e6ec56..7ad264fc33f7a 100644
</span><span style=color:#c594c5>--- a/assets/shaders/game_of_life.wgsl
</span><span style=color:#c594c5>+++ b/assets/shaders/game_of_life.wgsl
</span><span style=color:#c594c5>@@ -4,9 +4,15 @@
</span><span> // Two textures are needed for the game of life as each pixel of step N depends on the state of its
</span><span> // neighbors at step N-1.
</span><span> 
</span><span style=color:#f07171>-@group(0) @binding(0) var input: texture_storage_2d&LTr32float, read>;
</span><span style=color:#86b300>+@group(0) @binding(0) var input: texture_storage_2d&LTrgba32float, read>;
</span><span> 
</span><span style=color:#f07171>-@group(0) @binding(1) var output: texture_storage_2d&LTr32float, write>;
</span><span style=color:#86b300>+@group(0) @binding(1) var output: texture_storage_2d&LTrgba32float, write>;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+@group(0) @binding(2) var&LTuniform> config: GameOfLifeUniforms;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+struct GameOfLifeUniforms {
</span><span style=color:#86b300>+    alive_color: vec4&LTf32>,
</span><span style=color:#86b300>+}
</span><span> 
</span><span> fn hash(value: u32) -> u32 {
</span><span>     var state = value;
</span><span style=color:#c594c5>@@ -29,14 +35,15 @@ </span><span style=color:#399ee6>fn init(@builtin(global_invocation_id) invocation_id: vec3&LTu32>, @builtin(num_wo
</span><span> 
</span><span>     let randomNumber = randomFloat((invocation_id.y << 16u) | invocation_id.x);
</span><span>     let alive = randomNumber > 0.9;
</span><span style=color:#f07171>-    let color = vec4&LTf32>(f32(alive));
</span><span style=color:#86b300>+    // Use alpha channel to keep track of cell's state
</span><span style=color:#86b300>+    let color = vec4(config.alive_color.rgb, f32(alive));
</span><span> 
</span><span>     textureStore(output, location, color);
</span><span> }
</span><span> 
</span><span> fn is_alive(location: vec2&LTi32>, offset_x: i32, offset_y: i32) -> i32 {
</span><span>     let value: vec4&LTf32> = textureLoad(input, location + vec2&LTi32>(offset_x, offset_y));
</span><span style=color:#f07171>-    return i32(value.x);
</span><span style=color:#86b300>+    return i32(value.a);
</span><span> }
</span><span> 
</span><span> fn count_alive(location: vec2&LTi32>) -> i32 {
</span><span style=color:#c594c5>@@ -65,7 +72,7 @@ </span><span style=color:#399ee6>fn update(@builtin(global_invocation_id) invocation_id: vec3&LTu32>) {
</span><span>     } else {
</span><span>         alive = false;
</span><span>     }
</span><span style=color:#f07171>-    let color = vec4&LTf32>(f32(alive));
</span><span style=color:#86b300>+    let color = vec4(config.alive_color.rgb, f32(alive));
</span><span> 
</span><span>     textureStore(output, location, color);
</span><span> }
</span><span>diff --git a/examples/shader/compute_shader_game_of_life.rs b/examples/shader/compute_shader_game_of_life.rs
</span><span>index a11767f06ff0d..fb157e3091f2c 100644
</span><span style=color:#c594c5>--- a/examples/shader/compute_shader_game_of_life.rs
</span><span style=color:#c594c5>+++ b/examples/shader/compute_shader_game_of_life.rs
</span><span style=color:#c594c5>@@ -9,8 +9,11 @@ </span><span style=color:#399ee6>use bevy::{
</span><span>         extract_resource::{ExtractResource, ExtractResourcePlugin},
</span><span>         render_asset::{RenderAssetUsages, RenderAssets},
</span><span>         render_graph::{self, RenderGraph, RenderLabel},
</span><span style=color:#f07171>-        render_resource::{binding_types::texture_storage_2d, *},
</span><span style=color:#f07171>-        renderer::{RenderContext, RenderDevice},
</span><span style=color:#86b300>+        render_resource::{
</span><span style=color:#86b300>+            binding_types::{texture_storage_2d, uniform_buffer},
</span><span style=color:#86b300>+            *,
</span><span style=color:#86b300>+        },
</span><span style=color:#86b300>+        renderer::{RenderContext, RenderDevice, RenderQueue},
</span><span>         texture::GpuImage,
</span><span>         Render, RenderApp, RenderStartup, RenderSystems,
</span><span>     },
</span><span style=color:#c594c5>@@ -51,7 +54,7 @@ </span><span style=color:#399ee6>fn main() {
</span><span> }
</span><span> 
</span><span> fn setup(mut commands: Commands, mut images: ResMut&LTAssets&LTImage>>) {
</span><span style=color:#f07171>-    let mut image = Image::new_target_texture(SIZE.0, SIZE.1, TextureFormat::R32Float);
</span><span style=color:#86b300>+    let mut image = Image::new_target_texture(SIZE.0, SIZE.1, TextureFormat::Rgba32Float);
</span><span>     image.asset_usage = RenderAssetUsages::RENDER_WORLD;
</span><span>     image.texture_descriptor.usage =
</span><span>         TextureUsages::COPY_DST | TextureUsages::STORAGE_BINDING | TextureUsages::TEXTURE_BINDING;
</span><span style=color:#c594c5>@@ -72,6 +75,10 @@ </span><span style=color:#399ee6>fn setup(mut commands: Commands, mut images: ResMut&LTAssets&LTImage>>) {
</span><span>         texture_a: image0,
</span><span>         texture_b: image1,
</span><span>     });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    commands.insert_resource(GameOfLifeUniforms {
</span><span style=color:#86b300>+        alive_color: LinearRgba::RED,
</span><span style=color:#86b300>+    });
</span><span> }
</span><span> 
</span><span> // Switch texture to display every frame to show the one that was written to most recently.
</span><span style=color:#c594c5>@@ -92,7 +99,10 @@ </span><span style=color:#399ee6>impl Plugin for GameOfLifeComputePlugin {
</span><span>     fn build(&self, app: &mut App) {
</span><span>         // Extract the game of life image resource from the main world into the render world
</span><span>         // for operation on by the compute shader and display on the sprite.
</span><span style=color:#f07171>-        app.add_plugins(ExtractResourcePlugin::&LTGameOfLifeImages>::default());
</span><span style=color:#86b300>+        app.add_plugins((
</span><span style=color:#86b300>+            ExtractResourcePlugin::&LTGameOfLifeImages>::default(),
</span><span style=color:#86b300>+            ExtractResourcePlugin::&LTGameOfLifeUniforms>::default(),
</span><span style=color:#86b300>+        ));
</span><span>         let render_app = app.sub_app_mut(RenderApp);
</span><span>         render_app
</span><span>             .add_systems(RenderStartup, init_game_of_life_pipeline)
</span><span style=color:#c594c5>@@ -113,6 +123,11 @@ </span><span style=color:#399ee6>struct GameOfLifeImages {
</span><span>     texture_b: Handle&LTImage>,
</span><span> }
</span><span> 
</span><span style=color:#86b300>+#[derive(Resource, Clone, ExtractResource, ShaderType)]
</span><span style=color:#86b300>+struct GameOfLifeUniforms {
</span><span style=color:#86b300>+    alive_color: LinearRgba,
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span> #[derive(Resource)]
</span><span> struct GameOfLifeImageBindGroups([BindGroup; 2]);
</span><span> 
</span><span style=color:#c594c5>@@ -121,19 +136,35 @@ </span><span style=color:#399ee6>fn prepare_bind_group(
</span><span>     pipeline: Res&LTGameOfLifePipeline>,
</span><span>     gpu_images: Res&LTRenderAssets&LTGpuImage>>,
</span><span>     game_of_life_images: Res&LTGameOfLifeImages>,
</span><span style=color:#86b300>+    game_of_life_uniforms: Res&LTGameOfLifeUniforms>,
</span><span>     render_device: Res&LTRenderDevice>,
</span><span style=color:#86b300>+    queue: Res&LTRenderQueue>,
</span><span> ) {
</span><span>     let view_a = gpu_images.get(&game_of_life_images.texture_a).unwrap();
</span><span>     let view_b = gpu_images.get(&game_of_life_images.texture_b).unwrap();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // Uniform buffer is used here to demonstrate how to set up a uniform in a compute shader
</span><span style=color:#86b300>+    // Alternatives such as storage buffers or push constants may be more suitable for your use case
</span><span style=color:#86b300>+    let mut uniform_buffer = UniformBuffer::from(game_of_life_uniforms.into_inner());
</span><span style=color:#86b300>+    uniform_buffer.write_buffer(&render_device, &queue);
</span><span style=color:#86b300>+
</span><span>     let bind_group_0 = render_device.create_bind_group(
</span><span>         None,
</span><span>         &pipeline.texture_bind_group_layout,
</span><span style=color:#f07171>-        &BindGroupEntries::sequential((&view_a.texture_view, &view_b.texture_view)),
</span><span style=color:#86b300>+        &BindGroupEntries::sequential((
</span><span style=color:#86b300>+            &view_a.texture_view,
</span><span style=color:#86b300>+            &view_b.texture_view,
</span><span style=color:#86b300>+            &uniform_buffer,
</span><span style=color:#86b300>+        )),
</span><span>     );
</span><span>     let bind_group_1 = render_device.create_bind_group(
</span><span>         None,
</span><span>         &pipeline.texture_bind_group_layout,
</span><span style=color:#f07171>-        &BindGroupEntries::sequential((&view_b.texture_view, &view_a.texture_view)),
</span><span style=color:#86b300>+        &BindGroupEntries::sequential((
</span><span style=color:#86b300>+            &view_b.texture_view,
</span><span style=color:#86b300>+            &view_a.texture_view,
</span><span style=color:#86b300>+            &uniform_buffer,
</span><span style=color:#86b300>+        )),
</span><span>     );
</span><span>     commands.insert_resource(GameOfLifeImageBindGroups([bind_group_0, bind_group_1]));
</span><span> }
</span><span style=color:#c594c5>@@ -156,8 +187,9 @@ </span><span style=color:#399ee6>fn init_game_of_life_pipeline(
</span><span>         &BindGroupLayoutEntries::sequential(
</span><span>             ShaderStages::COMPUTE,
</span><span>             (
</span><span style=color:#f07171>-                texture_storage_2d(TextureFormat::R32Float, StorageTextureAccess::ReadOnly),
</span><span style=color:#f07171>-                texture_storage_2d(TextureFormat::R32Float, StorageTextureAccess::WriteOnly),
</span><span style=color:#86b300>+                texture_storage_2d(TextureFormat::Rgba32Float, StorageTextureAccess::ReadOnly),
</span><span style=color:#86b300>+                texture_storage_2d(TextureFormat::Rgba32Float, StorageTextureAccess::WriteOnly),
</span><span style=color:#86b300>+                uniform_buffer::&LTGameOfLifeUniforms>(false),
</span><span>             ),
</span><span>         ),
</span><span>     );
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-08/pr_20466.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>