<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20599 Move calculate_bounds_2d back to bevy_sprite
        
    </title><meta content="#20599 Move calculate_bounds_2d back to bevy_sprite" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-08/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-08-16</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-08/pr-20599-zh-cn-20250816>中文</a></div></div><div class=pr-content><h2 id=move-calculate-bounds-2d-back-to-bevy-sprite>Move calculate_bounds_2d back to bevy_sprite</h2><h3 id=basic-information>Basic Information</h3><ul><li><strong>Title</strong>: Move calculate_bounds_2d back to bevy_sprite<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20599<li><strong>Author</strong>: atlv24<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-08-16T02:03:23Z<li><strong>Merged</strong>: 2025-08-16T04:58:16Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h3 id=description-translation>Description Translation</h3><h1 id=objective>Objective</h1><ul><li>Revert an unnecessary system move from #20587<li>bevy_mesh is already depended on transiently by bevy_camera so its not adding deps</ul><h2 id=solution>Solution</h2><ul><li>put it back</ul><h2 id=testing>Testing</h2><ul><li>cargo check –examples</ul><h3 id=the-story-of-this-pull-request>The Story of This Pull Request</h3><p>This PR addresses an unnecessary relocation of the <code>calculate_bounds_2d</code> system that occurred in PR #20587. The original move placed this visibility calculation system in <code>bevy_sprite_render</code>, but this location wasn’t optimal for the system’s dependencies and responsibilities.<p>The core issue was that moving <code>calculate_bounds_2d</code> to <code>bevy_sprite_render</code> created an artificial separation between sprite functionality and visibility calculations. The <code>bevy_sprite</code> module already contained related sprite handling logic, making it the more natural home for this system. Additionally, the dependency on <code>bevy_mesh</code> wasn’t actually introducing new transitive dependencies since <code>bevy_camera</code> already depended on <code>bevy_mesh</code> through its visibility systems.<p>The solution was straightforward: revert the system’s location back to <code>bevy_sprite</code>. This required adding <code>bevy_mesh</code> as a dependency to <code>bevy_sprite</code>’s Cargo.toml, but since the dependency chain already existed through <code>bevy_camera</code>, this didn’t introduce new dependency overhead. The system registration was moved from <code>SpriteRenderingPlugin</code> to <code>SpritePlugin</code>, maintaining its placement in the <code>VisibilitySystems::CalculateBounds</code> system set.<p>The implementation preserves all functionality of <code>calculate_bounds_2d</code>, which calculates axis-aligned bounding boxes (AABBs) for 2D entities. It handles both mesh-based entities (via <code>Mesh2d</code> components) and sprite-based entities (via <code>Sprite</code> components), accounting for custom sizes, texture atlases, and anchor points. The system efficiently updates AABBs only when necessary by using change detection filters:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Only recalculate when Sprite or Anchor change
</span><span>sprites_to_recalculate_aabb</span><span style=color:#61676ccc>: </span><span>Query<
</span><span>    (Entity, </span><span style=color:#ed9366>&</span><span>Sprite, </span><span style=color:#ed9366>&</span><span>Anchor),
</span><span>    (
</span><span>        Or<(Without&LTAabb>, Changed&LTSprite>, Changed&LTAnchor>)>,
</span><span>        Without&LTNoFrustumCulling>,
</span><span>    ),
</span><span>>
</span></code></pre><p>The comprehensive test suite was also moved intact, verifying correct AABB calculation for various sprite configurations including:<ul><li>Initial AABB creation for image sprites<li>AABB updates when sprite properties change<li>Correct AABB calculation for sprites with custom rectangles and anchor points</ul><p>The impact of this change is improved code organization and maintainability. By colocating the visibility calculation with related sprite logic, we reduce cross-module dependencies and make the system easier to locate and modify. The dependency graph remains efficient since we’re leveraging existing transient dependencies rather than introducing new ones.<h3 id=visual-representation>Visual Representation</h3><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[bevy_sprite] --> B[calculate_bounds_2d]
</span><span>    B --> C[VisibilitySystems]
</span><span>    C --> D[bevy_camera]
</span><span>    D --> E[bevy_mesh]
</span><span>    A --> F[Sprite systems]
</span></code></pre><h3 id=key-files-changed>Key Files Changed</h3><ol><li><p><code>crates/bevy_sprite/Cargo.toml</code> (+1/-0)<br> Added <code>bevy_mesh</code> dependency to support AABB calculations:</p> <pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span style=color:#399ee6>bevy_mesh </span><span>= { </span><span style=color:#399ee6>path </span><span>= </span><span style=color:#86b300>"../bevy_mesh"</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>version </span><span>= </span><span style=color:#86b300>"0.17.0-dev" </span><span>}
</span></code></pre><li><p><code>crates/bevy_sprite/src/lib.rs</code> (+215/-1)<br> Moved system implementation and tests from render module:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// System registration in SpritePlugin
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>    PostUpdate</span><span style=color:#61676ccc>,
</span><span>    calculate_bounds_2d</span><span style=color:#ed9366>.</span><span style=color:#f07171>in_set</span><span>(VisibilitySystems</span><span style=color:#ed9366>::</span><span>CalculateBounds)</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Full system implementation
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>calculate_bounds_2d</span><span>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#ff8f40>meshes</span><span style=color:#61676ccc>: </span><span>Res&LTAssets&LTMesh>>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... other dependencies
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Handles mesh entities
</span><span>    </span><span style=color:#fa6e32>for </span><span>(entity</span><span style=color:#61676ccc>,</span><span> mesh_handle) </span><span style=color:#ed9366>in &</span><span>meshes_without_aabb {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(mesh) </span><span style=color:#ed9366>=</span><span> meshes</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>mesh_handle</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>            </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(aabb) </span><span style=color:#ed9366>=</span><span> mesh</span><span style=color:#ed9366>.</span><span style=color:#f07171>compute_aabb</span><span>()
</span><span>        {
</span><span>            commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_insert</span><span>(aabb)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Handles sprite entities
</span><span>    </span><span style=color:#fa6e32>for </span><span>(entity</span><span style=color:#61676ccc>,</span><span> sprite</span><span style=color:#61676ccc>,</span><span> anchor) </span><span style=color:#ed9366>in &</span><span>sprites_to_recalculate_aabb {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(size) </span><span style=color:#ed9366>= </span><span style=color:#abb0b6;font-style:italic>/* size calculation logic */ </span><span>{
</span><span>            </span><span style=color:#fa6e32>let</span><span> aabb </span><span style=color:#ed9366>=</span><span> Aabb {
</span><span>                center</span><span style=color:#61676ccc>: </span><span>(</span><span style=color:#ed9366>-</span><span>anchor</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_vec</span><span>() </span><span style=color:#ed9366>*</span><span> size)</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>,
</span><span>                half_extents</span><span style=color:#61676ccc>: </span><span>(</span><span style=color:#ff8f40>0.5 </span><span style=color:#ed9366>*</span><span> size)</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>,
</span><span>            }</span><span style=color:#61676ccc>;
</span><span>            commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>(entity)</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_insert</span><span>(aabb)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><li><p><code>crates/bevy_sprite_render/src/lib.rs</code> (+7/-221)<br> Removed system and tests from rendering module:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>    PostUpdate</span><span style=color:#61676ccc>,
</span><span>    (
</span><span>        calculate_bounds_2d</span><span style=color:#ed9366>.</span><span style=color:#f07171>in_set</span><span>(VisibilitySystems</span><span style=color:#ed9366>::</span><span>CalculateBounds)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... other systems
</span><span>    )
</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(
</span><span>    PostUpdate</span><span style=color:#61676ccc>,
</span><span>    (
</span><span>        compute_slices_on_asset_event</span><span style=color:#ed9366>.</span><span style=color:#f07171>before</span><span>(AssetEventSystems)</span><span style=color:#61676ccc>,
</span><span>        compute_slices_on_sprite_change</span><span style=color:#61676ccc>,
</span><span>    )
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>in_set</span><span>(SpriteSystems</span><span style=color:#ed9366>::</span><span>ComputeSlices)</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Entire calculate_bounds_2d implementation and tests removed
</span></code></pre></ol><h3 id=further-reading>Further Reading</h3><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/getting-started/ecs/#system-sets target=_blank>Bevy ECS System Sets</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/blob/main/crates/bevy_camera/src/visibility.rs target=_blank>Bevy Visibility Systems</a><li><a rel="noopener nofollow noreferrer" href=https://developer.nvidia.com/blog/thinking-parallel-part-i-collision-detection-gpu/ target=_blank>Axis-Aligned Bounding Boxes</a></ul><h3 id=full-code-diff>Full Code Diff</h3><details><summary>View full diff</summary> <pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_sprite/Cargo.toml b/crates/bevy_sprite/Cargo.toml
</span><span>index d0ea9b6e51578..8339230d6f4c6 100644
</span><span style=color:#c594c5>--- a/crates/bevy_sprite/Cargo.toml
</span><span style=color:#c594c5>+++ b/crates/bevy_sprite/Cargo.toml
</span><span style=color:#c594c5>@@ -19,6 +19,7 @@ </span><span style=color:#399ee6>bevy_color = { path = "../bevy_color", version = "0.17.0-dev" }
</span><span> bevy_ecs = { path = "../bevy_ecs", version = "0.17.0-dev" }
</span><span> bevy_image = { path = "../bevy_image", version = "0.17.0-dev" }
</span><span> bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
</span><span style=color:#86b300>+bevy_mesh = { path = "../bevy_mesh", version = "0.17.0-dev" }
</span><span> bevy_math = { path = "../bevy_math", version = "0.17.0-dev" }
</span><span> bevy_picking = { path = "../bevy_picking", version = "0.17.0-dev", optional = true }
</span><span> bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
</span><span>diff --git a/crates/bevy_sprite/src/lib.rs b/crates/bevy_sprite/src/lib.rs
</span><span>index 500ebdf778a3f..5f5a2de77c415 100644
</span><span style=color:#c594c5>--- a/crates/bevy_sprite/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_sprite/src/lib.rs
</span><span style=color:#c594c5>@@ -32,6 +32,12 @@ </span><span style=color:#399ee6>pub mod prelude {
</span><span>     };
</span><span> }
</span><span> 
</span><span style=color:#86b300>+use bevy_asset::Assets;
</span><span style=color:#86b300>+use bevy_camera::{
</span><span style=color:#86b300>+    primitives::{Aabb, MeshAabb},
</span><span style=color:#86b300>+    visibility::{NoFrustumCulling, VisibilitySystems},
</span><span style=color:#86b300>+};
</span><span style=color:#86b300>+use bevy_mesh::{Mesh, Mesh2d};
</span><span> #[cfg(feature = "bevy_sprite_picking_backend")]
</span><span> pub use picking_backend::*;
</span><span> pub use sprite::*;
</span><span style=color:#c594c5>@@ -39,7 +45,7 @@ </span><span style=color:#399ee6>pub use texture_slice::*;
</span><span> 
</span><span> use bevy_app::prelude::*;
</span><span> use bevy_ecs::prelude::*;
</span><span style=color:#f07171>-use bevy_image::TextureAtlasPlugin;
</span><span style=color:#86b300>+use bevy_image::{Image, TextureAtlasLayout, TextureAtlasPlugin};
</span><span> 
</span><span> /// Adds support for 2D sprites.
</span><span> #[derive(Default)]
</span><span style=color:#c594c5>@@ -61,8 +67,216 @@ </span><span style=color:#399ee6>impl Plugin for SpritePlugin {
</span><span>         if !app.is_plugin_added::&LTTextureAtlasPlugin>() {
</span><span>             app.add_plugins(TextureAtlasPlugin);
</span><span>         }
</span><span style=color:#86b300>+        app.add_systems(
</span><span style=color:#86b300>+            PostUpdate,
</span><span style=color:#86b300>+            calculate_bounds_2d.in_set(VisibilitySystems::CalculateBounds),
</span><span style=color:#86b300>+        );
</span><span> 
</span><span>         #[cfg(feature = "bevy_sprite_picking_backend")]
</span><span>         app.add_plugins(SpritePickingPlugin);
</span><span>     }
</span><span> }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+/// System calculating and inserting an [`Aabb`] component to entities with either:
</span><span style=color:#86b300>+/// - a `Mesh2d` component,
</span><span style=color:#86b300>+/// - a `Sprite` and `Handle&LTImage>` components,
</span><span style=color:#86b300>+///   and without a [`NoFrustumCulling`] component.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// Used in system set [`VisibilitySystems::CalculateBounds`].
</span><span style=color:#86b300>+pub fn calculate_bounds_2d(
</span><span style=color:#86b300>+    mut commands: Commands,
</span><span style=color:#86b300>+    meshes: Res&LTAssets&LTMesh>>,
</span><span style=color:#86b300>+    images: Res&LTAssets&LTImage>>,
</span><span style=color:#86b300>+    atlases: Res&LTAssets&LTTextureAtlasLayout>>,
</span><span style=color:#86b300>+    meshes_without_aabb: Query<(Entity, &Mesh2d), (Without&LTAabb>, Without&LTNoFrustumCulling>)>,
</span><span style=color:#86b300>+    sprites_to_recalculate_aabb: Query<
</span><span style=color:#86b300>+        (Entity, &Sprite, &Anchor),
</span><span style=color:#86b300>+        (
</span><span style=color:#86b300>+            Or<(Without&LTAabb>, Changed&LTSprite>, Changed&LTAnchor>)>,
</span><span style=color:#86b300>+            Without&LTNoFrustumCulling>,
</span><span style=color:#86b300>+        ),
</span><span style=color:#86b300>+    >,
</span><span style=color:#86b300>+) {
</span><span style=color:#86b300>+    for (entity, mesh_handle) in &meshes_without_aabb {
</span><span style=color:#86b300>+        if let Some(mesh) = meshes.get(&mesh_handle.0)
</span><span style=color:#86b300>+            && let Some(aabb) = mesh.compute_aabb()
</span><span style=color:#86b300>+        {
</span><span style=color:#86b300>+            commands.entity(entity).try_insert(aabb);
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    for (entity, sprite, anchor) in &sprites_to_recalculate_aabb {
</span><span style=color:#86b300>+        if let Some(size) = sprite
</span><span style=color:#86b300>+            .custom_size
</span><span style=color:#86b300>+            .or_else(|| sprite.rect.map(|rect| rect.size()))
</span><span style=color:#86b300>+            .or_else(|| match &sprite.texture_atlas {
</span><span style=color:#86b300>+                // We default to the texture size for regular sprites
</span><span style=color:#86b300>+                None => images.get(&sprite.image).map(Image::size_f32),
</span><span style=color:#86b300>+                // We default to the drawn rect for atlas sprites
</span><span style=color:#86b300>+                Some(atlas) => atlas
</span><span style=color:#86b300>+                    .texture_rect(&atlases)
</span><span style=color:#86b300>+                    .map(|rect| rect.size().as_vec2()),
</span><span style=color:#86b300>+            })
</span><span style=color:#86b300>+        {
</span><span style=color:#86b300>+            let aabb = Aabb {
</span><span style=color:#86b300>+                center: (-anchor.as_vec() * size).extend(0.0).into(),
</span><span style=color:#86b300>+                half_extents: (0.5 * size).extend(0.0).into(),
</span><span style=color:#86b300>+            };
</span><span style=color:#86b300>+            commands.entity(entity).try_insert(aabb);
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#[cfg(test)]
</span><span style=color:#86b300>+mod test {
</span><span style=color:#86b300>+    use super::*;
</span><span style=color:#86b300>+    use bevy_math::{Rect, Vec2, Vec3A};
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn calculate_bounds_2d_create_aabb_for_image_sprite_entity() {
</span><span style=color:#86b300>+        // Setup app
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add resources and get handle to image
</span><span style=color:#86b300>+        let mut image_assets = Assets::&LTImage>::default();
</span><span style=color:#86b300>+        let image_handle = image_assets.add(Image::default());
</span><span style=color:#86b300>+        app.insert_resource(image_assets);
</span><span style=color:#86b300>+        let mesh_assets = Assets::&LTMesh>::default();
</span><span style=color:#86b300>+        app.insert_resource(mesh_assets);
</span><span style=color:#86b300>+        let texture_atlas_assets = Assets::&LTTextureAtlasLayout>::default();
</span><span style=color:#86b300>+        app.insert_resource(texture_atlas_assets);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add system
</span><span style=color:#86b300>+        app.add_systems(Update, calculate_bounds_2d);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add entities
</span><span style=color:#86b300>+        let entity = app.world_mut().spawn(Sprite::from_image(image_handle)).id();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Verify that the entity does not have an AABB
</span><span style=color:#86b300>+        assert!(!app
</span><span style=color:#86b300>+            .world()
</span><span style=color:#86b300>+            .get_entity(entity)
</span><span style=color:#86b300>+            .expect("Could not find entity")
</span><span style=color:#86b300>+            .contains::&LTAabb>());
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Run system
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Verify the AABB exists
</span><span style=color:#86b300>+        assert!(app
</span><span style=color:#86b300>+            .world()
</span><span style=color:#86b300>+            .get_entity(entity)
</span><span style=color:#86b300>+            .expect("Could not find entity")
</span><span style=color:#86b300>+            .contains::&LTAabb>());
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn calculate_bounds_2d_update_aabb_when_sprite_custom_size_changes_to_some() {
</span><span style=color:#86b300>+        // Setup app
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add resources and get handle to image
</span><span style=color:#86b300>+        let mut image_assets = Assets::&LTImage>::default();
</span><span style=color:#86b300>+        let image_handle = image_assets.add(Image::default());
</span><span style=color:#86b300>+        app.insert_resource(image_assets);
</span><span style=color:#86b300>+        let mesh_assets = Assets::&LTMesh>::default();
</span><span style=color:#86b300>+        app.insert_resource(mesh_assets);
</span><span style=color:#86b300>+        let texture_atlas_assets = Assets::&LTTextureAtlasLayout>::default();
</span><span style=color:#86b300>+        app.insert_resource(texture_atlas_assets);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add system
</span><span style=color:#86b300>+        app.add_systems(Update, calculate_bounds_2d);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add entities
</span><span style=color:#86b300>+        let entity = app
</span><span style=color:#86b300>+            .world_mut()
</span><span style=color:#86b300>+            .spawn(Sprite {
</span><span style=color:#86b300>+                custom_size: Some(Vec2::ZERO),
</span><span style=color:#86b300>+                image: image_handle,
</span><span style=color:#86b300>+                ..Sprite::default()
</span><span style=color:#86b300>+            })
</span><span style=color:#86b300>+            .id();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Create initial AABB
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Get the initial AABB
</span><span style=color:#86b300>+        let first_aabb = *app
</span><span style=color:#86b300>+            .world()
</span><span style=color:#86b300>+            .get_entity(entity)
</span><span style=color:#86b300>+            .expect("Could not find entity")
</span><span style=color:#86b300>+            .get::&LTAabb>()
</span><span style=color:#86b300>+            .expect("Could not find initial AABB");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Change `custom_size` of sprite
</span><span style=color:#86b300>+        let mut binding = app
</span><span style=color:#86b300>+            .world_mut()
</span><span style=color:#86b300>+            .get_entity_mut(entity)
</span><span style=color:#86b300>+            .expect("Could not find entity");
</span><span style=color:#86b300>+        let mut sprite = binding
</span><span style=color:#86b300>+            .get_mut::&LTSprite>()
</span><span style=color:#86b300>+            .expect("Could not find sprite component of entity");
</span><span style=color:#86b300>+        sprite.custom_size = Some(Vec2::ONE);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Re-run the `calculate_bounds_2d` system to get the new AABB
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Get the re-calculated AABB
</span><span style=color:#86b300>+        let second_aabb = *app
</span><span style=color:#86b300>+            .world()
</span><span style=color:#86b300>+            .get_entity(entity)
</span><span style=color:#86b300>+            .expect("Could not find entity")
</span><span style=color:#86b300>+            .get::&LTAabb>()
</span><span style=color:#86b300>+            .expect("Could not find second AABB");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Check that the AABBs are not equal
</span><span style=color:#86b300>+        assert_ne!(first_aabb, second_aabb);
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn calculate_bounds_2d_correct_aabb_for_sprite_with_custom_rect() {
</span><span style=color:#86b300>+        // Setup app
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add resources and get handle to image
</span><span style=color:#86b300>+        let mut image_assets = Assets::&LTImage>::default();
</span><span style=color:#86b300>+        let image_handle = image_assets.add(Image::default());
</span><span style=color:#86b300>+        app.insert_resource(image_assets);
</span><span style=color:#86b300>+        let mesh_assets = Assets::&LTMesh>::default();
</span><span style=color:#86b300>+        app.insert_resource(mesh_assets);
</span><span style=color:#86b300>+        let texture_atlas_assets = Assets::&LTTextureAtlasLayout>::default();
</span><span style=color:#86b300>+        app.insert_resource(texture_atlas_assets);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add system
</span><span style=color:#86b300>+        app.add_systems(Update, calculate_bounds_2d);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Add entities
</span><span style=color:#86b300>+        let entity = app
</span><span style=color:#86b300>+            .world_mut()
</span><span style=color:#86b300>+            .spawn((
</span><span style=color:#86b300>+                Sprite {
</span><span style=color:#86b300>+                    rect: Some(Rect::new(0., 0., 0.5, 1.)),
</span><span style=color:#86b300>+                    image: image_handle,
</span><span style=color:#86b300>+                    ..Sprite::default()
</span><span style=color:#86b300>+                },
</span><span style=color:#86b300>+                Anchor::TOP_RIGHT,
</span><span style=color:#86b300>+            ))
</span><span style=color:#86b300>+            .id();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Create AABB
</span><span style=color:#86b300>+        app.update();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Get the AABB
</span><span style=color:#86b300>+        let aabb = *app
</span><span style=color:#86b300>+            .world_mut()
</span><span style=color:#86b300>+            .get_entity(entity)
</span><span style=color:#86b300>+            .expect("Could not find entity")
</span><span style=color:#86b300>+            .get::&LTAabb>()
</span><span style=color:#86b300>+            .expect("Could not find AABB");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Verify that the AABB is at the expected position
</span><span style=color:#86b300>+        assert_eq!(aabb.center, Vec3A::new(-0.25, -0.5, 0.));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Verify that the AABB has the expected size
</span><span style=color:#86b300>+        assert_eq!(aabb.half_extents, Vec3A::new(0.25, 0.5, 0.));
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span>diff --git a/crates/bevy_sprite_render/src/lib.rs b/crates/bevy_sprite_render/src/lib.rs
</span><span>index d1a119cebd2a4..5819a5da63766 100644
</span><span style=color:#c594c5>--- a/crates/bevy_sprite_render/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_sprite_render/src/lib.rs
</span><span style=color:#c594c5>@@ -23,10 +23,6 @@ </span><span style=color:#399ee6>pub mod prelude {
</span><span>     pub use crate::{ColorMaterial, MeshMaterial2d};
</span><span> }
</span><span> 
</span><span style=color:#f07171>-use bevy_camera::{
</span><span style=color:#f07171>-    primitives::{Aabb, MeshAabb as _},
</span><span style=color:#f07171>-    visibility::{NoFrustumCulling, VisibilitySystems},
</span><span style=color:#f07171>-};
</span><span> use bevy_shader::load_shader_library;
</span><span> pub use mesh2d::*;
</span><span> pub use render::*;
</span><span style=color:#c594c5>@@ -34,17 +30,17 @@ </span><span style=color:#399ee6>pub(crate) use texture_slice::*;
</span><span> pub use tilemap_chunk::*;
</span><span> 
</span><span> use bevy_app::prelude::*;
</span><span style=color:#f07171>-use bevy_asset::{embedded_asset, AssetEventSystems, Assets};
</span><span style=color:#86b300>+use bevy_asset::{embedded_asset, AssetEventSystems};
</span><span> use bevy_core_pipeline::core_2d::{AlphaMask2d, Opaque2d, Transparent2d};
</span><span> use bevy_ecs::prelude::*;
</span><span> use bevy_image::{prelude::*, TextureAtlasPlugin};
</span><span style=color:#f07171>-use bevy_mesh::{Mesh, Mesh2d};
</span><span style=color:#86b300>+use bevy_mesh::Mesh2d;
</span><span> use bevy_render::{
</span><span>     batching::sort_binned_render_phase, render_phase::AddRenderCommand,
</span><span>     render_resource::SpecializedRenderPipelines, sync_world::SyncToRenderWorld, ExtractSchedule,
</span><span>     Render, RenderApp, RenderStartup, RenderSystems,
</span><span> };
</span><span style=color:#f07171>-use bevy_sprite::{Anchor, Sprite};
</span><span style=color:#86b300>+use bevy_sprite::Sprite;
</span><span> 
</span><span> /// Adds support for 2D sprite rendering.
</span><span> #[derive(Default)]
</span><span style=color:#c594c5>@@ -80,13 +76,10 @@ </span><span style=color:#399ee6>impl Plugin for SpriteRenderingPlugin {
</span><span>         .add_systems(
</span><span>             PostUpdate,
</span><span>             (
</span><span style=color:#f07171>-                calculate_bounds_2d.in_set(VisibilitySystems::CalculateBounds),
</span><span style=color:#f07171>-                (
</span><span style=color:#f07171>-                    compute_slices_on_asset_event.before(AssetEventSystems),
</span><span style=color:#f07171>-                    compute_slices_on_sprite_change,
</span><span style=color:#f07171>-                )
</span><span style=color:#f07171>-                    .in_set(SpriteSystems::ComputeSlices),
</span><span style=color:#f07171>-            ),
</span><span style=color:#86b300>+                compute_slices_on_asset_event.before(AssetEventSystems),
</span><span style=color:#86b300>+                compute_slices_on_sprite_change,
</span><span style=color:#86b300>+            )
</span><span style=color:#86b300>+                .in_set(SpriteSystems::ComputeSlices),
</span><span>         );
</span><span> 
</span><span>         app.register_required_components::&LTSprite, SyncToRenderWorld>();
</span><span style=color:#c594c5>@@ -124,210 +117,3 @@ </span><span style=color:#399ee6>impl Plugin for SpriteRenderingPlugin {
</span><span>         };
</span><span>     }
</span><span> }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-/// System calculating and inserting an [`Aabb`] component to entities with either:
</span><span style=color:#f07171>-/// - a `Mesh2d` component,
</span><span style=color:#f07171>-/// - a `Sprite` and `Handle&LTImage>` components,
</span><span style=color:#f07171>-///   and without a [`NoFrustumCulling`] component.
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// Used in system set [`VisibilitySystems::CalculateBounds`].
</span><span style=color:#f07171>-pub fn calculate_bounds_2d(
</span><span style=color:#f07171>-    mut commands: Commands,
</span><span style=color:#f07171>-    meshes: Res&LTAssets&LTMesh>>,
</span><span style=color:#f07171>-    images: Res&LTAssets&LTImage>>,
</span><span style=color:#f07171>-    atlases: Res&LTAssets&LTTextureAtlasLayout>>,
</span><span style=color:#f07171>-    meshes_without_aabb: Query<(Entity, &Mesh2d), (Without&LTAabb>, Without&LTNoFrustumCulling>)>,
</span><span style=color:#f07171>-    sprites_to_recalculate_aabb: Query<
</span><span style=color:#f07171>-        (Entity, &Sprite, &Anchor),
</span><span style=color:#f07171>-        (
</span><span style=color:#f07171>-            Or<(Without&LTAabb>, Changed&LTSprite>, Changed&LTAnchor>)>,
</span><span style=color:#f07171>-            Without&LTNoFrustumCulling>,
</span><span style=color:#f07171>-        ),
</span><span style=color:#f07171>-    >,
</span><span style=color:#f07171>-) {
</span><span style=color:#f07171>-    for (entity, mesh_handle) in &meshes_without_aabb {
</span><span style=color:#f07171>-        if let Some(mesh) = meshes.get(&mesh_handle.0)
</span><span style=color:#f07171>-            && let Some(aabb) = mesh.compute_aabb()
</span><span style=color:#f07171>-        {
</span><span style=color:#f07171>-            commands.entity(entity).try_insert(aabb);
</span><span style=color:#f07171>-        }
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-    for (entity, sprite, anchor) in &sprites_to_recalculate_aabb {
</span><span style=color:#f07171>-        if let Some(size) = sprite
</span><span style=color:#f07171>-            .custom_size
</span><span style=color:#f07171>-            .or_else(|| sprite.rect.map(|rect| rect.size()))
</span><span style=color:#f07171>-            .or_else(|| match &sprite.texture_atlas {
</span><span style=color:#f07171>-                // We default to the texture size for regular sprites
</span><span style=color:#f07171>-                None => images.get(&sprite.image).map(Image::size_f32),
</span><span style=color:#f07171>-                // We default to the drawn rect for atlas sprites
</span><span style=color:#f07171>-                Some(atlas) => atlas
</span><span style=color:#f07171>-                    .texture_rect(&atlases)
</span><span style=color:#f07171>-                    .map(|rect| rect.size().as_vec2()),
</span><span style=color:#f07171>-            })
</span><span style=color:#f07171>-        {
</span><span style=color:#f07171>-            let aabb = Aabb {
</span><span style=color:#f07171>-                center: (-anchor.as_vec() * size).extend(0.0).into(),
</span><span style=color:#f07171>-                half_extents: (0.5 * size).extend(0.0).into(),
</span><span style=color:#f07171>-            };
</span><span style=color:#f07171>-            commands.entity(entity).try_insert(aabb);
</span><span style=color:#f07171>-        }
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-#[cfg(test)]
</span><span style=color:#f07171>-mod test {
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    use bevy_math::{Rect, Vec2, Vec3A};
</span><span style=color:#f07171>-    use bevy_utils::default;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    use super::*;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    #[test]
</span><span style=color:#f07171>-    fn calculate_bounds_2d_create_aabb_for_image_sprite_entity() {
</span><span style=color:#f07171>-        // Setup app
</span><span style=color:#f07171>-        let mut app = App::new();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add resources and get handle to image
</span><span style=color:#f07171>-        let mut image_assets = Assets::&LTImage>::default();
</span><span style=color:#f07171>-        let image_handle = image_assets.add(Image::default());
</span><span style=color:#f07171>-        app.insert_resource(image_assets);
</span><span style=color:#f07171>-        let mesh_assets = Assets::&LTMesh>::default();
</span><span style=color:#f07171>-        app.insert_resource(mesh_assets);
</span><span style=color:#f07171>-        let texture_atlas_assets = Assets::&LTTextureAtlasLayout>::default();
</span><span style=color:#f07171>-        app.insert_resource(texture_atlas_assets);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add system
</span><span style=color:#f07171>-        app.add_systems(Update, calculate_bounds_2d);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add entities
</span><span style=color:#f07171>-        let entity = app.world_mut().spawn(Sprite::from_image(image_handle)).id();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Verify that the entity does not have an AABB
</span><span style=color:#f07171>-        assert!(!app
</span><span style=color:#f07171>-            .world()
</span><span style=color:#f07171>-            .get_entity(entity)
</span><span style=color:#f07171>-            .expect("Could not find entity")
</span><span style=color:#f07171>-            .contains::&LTAabb>());
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Run system
</span><span style=color:#f07171>-        app.update();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Verify the AABB exists
</span><span style=color:#f07171>-        assert!(app
</span><span style=color:#f07171>-            .world()
</span><span style=color:#f07171>-            .get_entity(entity)
</span><span style=color:#f07171>-            .expect("Could not find entity")
</span><span style=color:#f07171>-            .contains::&LTAabb>());
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    #[test]
</span><span style=color:#f07171>-    fn calculate_bounds_2d_update_aabb_when_sprite_custom_size_changes_to_some() {
</span><span style=color:#f07171>-        // Setup app
</span><span style=color:#f07171>-        let mut app = App::new();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add resources and get handle to image
</span><span style=color:#f07171>-        let mut image_assets = Assets::&LTImage>::default();
</span><span style=color:#f07171>-        let image_handle = image_assets.add(Image::default());
</span><span style=color:#f07171>-        app.insert_resource(image_assets);
</span><span style=color:#f07171>-        let mesh_assets = Assets::&LTMesh>::default();
</span><span style=color:#f07171>-        app.insert_resource(mesh_assets);
</span><span style=color:#f07171>-        let texture_atlas_assets = Assets::&LTTextureAtlasLayout>::default();
</span><span style=color:#f07171>-        app.insert_resource(texture_atlas_assets);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add system
</span><span style=color:#f07171>-        app.add_systems(Update, calculate_bounds_2d);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add entities
</span><span style=color:#f07171>-        let entity = app
</span><span style=color:#f07171>-            .world_mut()
</span><span style=color:#f07171>-            .spawn(Sprite {
</span><span style=color:#f07171>-                custom_size: Some(Vec2::ZERO),
</span><span style=color:#f07171>-                image: image_handle,
</span><span style=color:#f07171>-                ..default()
</span><span style=color:#f07171>-            })
</span><span style=color:#f07171>-            .id();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Create initial AABB
</span><span style=color:#f07171>-        app.update();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Get the initial AABB
</span><span style=color:#f07171>-        let first_aabb = *app
</span><span style=color:#f07171>-            .world()
</span><span style=color:#f07171>-            .get_entity(entity)
</span><span style=color:#f07171>-            .expect("Could not find entity")
</span><span style=color:#f07171>-            .get::&LTAabb>()
</span><span style=color:#f07171>-            .expect("Could not find initial AABB");
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Change `custom_size` of sprite
</span><span style=color:#f07171>-        let mut binding = app
</span><span style=color:#f07171>-            .world_mut()
</span><span style=color:#f07171>-            .get_entity_mut(entity)
</span><span style=color:#f07171>-            .expect("Could not find entity");
</span><span style=color:#f07171>-        let mut sprite = binding
</span><span style=color:#f07171>-            .get_mut::&LTSprite>()
</span><span style=color:#f07171>-            .expect("Could not find sprite component of entity");
</span><span style=color:#f07171>-        sprite.custom_size = Some(Vec2::ONE);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Re-run the `calculate_bounds_2d` system to get the new AABB
</span><span style=color:#f07171>-        app.update();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Get the re-calculated AABB
</span><span style=color:#f07171>-        let second_aabb = *app
</span><span style=color:#f07171>-            .world()
</span><span style=color:#f07171>-            .get_entity(entity)
</span><span style=color:#f07171>-            .expect("Could not find entity")
</span><span style=color:#f07171>-            .get::&LTAabb>()
</span><span style=color:#f07171>-            .expect("Could not find second AABB");
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Check that the AABBs are not equal
</span><span style=color:#f07171>-        assert_ne!(first_aabb, second_aabb);
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    #[test]
</span><span style=color:#f07171>-    fn calculate_bounds_2d_correct_aabb_for_sprite_with_custom_rect() {
</span><span style=color:#f07171>-        // Setup app
</span><span style=color:#f07171>-        let mut app = App::new();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add resources and get handle to image
</span><span style=color:#f07171>-        let mut image_assets = Assets::&LTImage>::default();
</span><span style=color:#f07171>-        let image_handle = image_assets.add(Image::default());
</span><span style=color:#f07171>-        app.insert_resource(image_assets);
</span><span style=color:#f07171>-        let mesh_assets = Assets::&LTMesh>::default();
</span><span style=color:#f07171>-        app.insert_resource(mesh_assets);
</span><span style=color:#f07171>-        let texture_atlas_assets = Assets::&LTTextureAtlasLayout>::default();
</span><span style=color:#f07171>-        app.insert_resource(texture_atlas_assets);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add system
</span><span style=color:#f07171>-        app.add_systems(Update, calculate_bounds_2d);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Add entities
</span><span style=color:#f07171>-        let entity = app
</span><span style=color:#f07171>-            .world_mut()
</span><span style=color:#f07171>-            .spawn((
</span><span style=color:#f07171>-                Sprite {
</span><span style=color:#f07171>-                    rect: Some(Rect::new(0., 0., 0.5, 1.)),
</span><span style=color:#f07171>-                    image: image_handle,
</span><span style=color:#f07171>-                    ..default()
</span><span style=color:#f07171>-                },
</span><span style=color:#f07171>-                Anchor::TOP_RIGHT,
</span><span style=color:#f07171>-            ))
</span><span style=color:#f07171>-            .id();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Create AABB
</span><span style=color:#f07171>-        app.update();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Get the AABB
</span><span style=color:#f07171>-        let aabb = *app
</span><span style=color:#f07171>-            .world_mut()
</span><span style=color:#f07171>-            .get_entity(entity)
</span><span style=color:#f07171>-            .expect("Could not find entity")
</span><span style=color:#f07171>-            .get::&LTAabb>()
</span><span style=color:#f07171>-            .expect("Could not find AABB");
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Verify that the AABB is at the expected position
</span><span style=color:#f07171>-        assert_eq!(aabb.center, Vec3A::new(-0.25, -0.5, 0.));
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        // Verify that the AABB has the expected size
</span><span style=color:#f07171>-        assert_eq!(aabb.half_extents, Vec3A::new(0.25, 0.5, 0.));
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-}
</span></code></pre></details></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-08/pr_20599.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>