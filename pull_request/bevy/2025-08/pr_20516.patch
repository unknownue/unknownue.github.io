diff --git a/crates/bevy_animation/src/gltf_curves.rs b/crates/bevy_animation/src/gltf_curves.rs
index 593ca04d2e025..1493f604b6ca7 100644
--- a/crates/bevy_animation/src/gltf_curves.rs
+++ b/crates/bevy_animation/src/gltf_curves.rs
@@ -353,7 +353,7 @@ impl<T> WideCubicKeyframeCurve<T> {
         let values: Vec<T> = values.into_iter().collect();
         let divisor = times.len() * 3;
 
-        if values.len() % divisor != 0 {
+        if !values.len().is_multiple_of(divisor) {
             return Err(WideKeyframeCurveError::LengthMismatch {
                 values_given: values.len(),
                 divisor,
diff --git a/crates/bevy_anti_aliasing/src/taa/mod.rs b/crates/bevy_anti_aliasing/src/taa/mod.rs
index fa477daf42472..0103d3a6ca4cc 100644
--- a/crates/bevy_anti_aliasing/src/taa/mod.rs
+++ b/crates/bevy_anti_aliasing/src/taa/mod.rs
@@ -439,7 +439,7 @@ fn prepare_taa_history_textures(
             texture_descriptor.label = Some("taa_history_2_texture");
             let history_2_texture = texture_cache.get(&render_device, texture_descriptor);
 
-            let textures = if frame_count.0 % 2 == 0 {
+            let textures = if frame_count.0.is_multiple_of(2) {
                 TemporalAntiAliasHistoryTextures {
                     write: history_1_texture,
                     read: history_2_texture,
diff --git a/crates/bevy_image/src/basis.rs b/crates/bevy_image/src/basis.rs
index 396129e678634..c88edb1fdc7bc 100644
--- a/crates/bevy_image/src/basis.rs
+++ b/crates/bevy_image/src/basis.rs
@@ -45,7 +45,7 @@ pub fn basis_buffer_to_image(
 
     let image_count = transcoder.image_count(buffer);
     let texture_type = transcoder.basis_texture_type(buffer);
-    if texture_type == BasisTextureType::TextureTypeCubemapArray && image_count % 6 != 0 {
+    if texture_type == BasisTextureType::TextureTypeCubemapArray && !image_count.is_multiple_of(6) {
         return Err(TextureError::InvalidData(format!(
             "Basis file with cube map array texture with non-modulo 6 number of images: {image_count}",
         )));
diff --git a/crates/bevy_mesh/src/mesh.rs b/crates/bevy_mesh/src/mesh.rs
index ea82c8a7445ae..4d85f568ffd2e 100644
--- a/crates/bevy_mesh/src/mesh.rs
+++ b/crates/bevy_mesh/src/mesh.rs
@@ -606,7 +606,7 @@ impl Mesh {
             match topology {
                 PrimitiveTopology::TriangleList => {
                     // Early return if the index count doesn't match
-                    if indices.len() % 3 != 0 {
+                    if !indices.len().is_multiple_of(3) {
                         return Err(MeshWindingInvertError::AbruptIndicesEnd);
                     }
                     for chunk in indices.chunks_mut(3) {
@@ -620,7 +620,7 @@ impl Mesh {
                 }
                 PrimitiveTopology::LineList => {
                     // Early return if the index count doesn't match
-                    if indices.len() % 2 != 0 {
+                    if !indices.len().is_multiple_of(2) {
                         return Err(MeshWindingInvertError::AbruptIndicesEnd);
                     }
                     indices.reverse();
diff --git a/crates/bevy_mesh/src/primitives/dim2.rs b/crates/bevy_mesh/src/primitives/dim2.rs
index 172cb152074d8..19af10afcf80b 100644
--- a/crates/bevy_mesh/src/primitives/dim2.rs
+++ b/crates/bevy_mesh/src/primitives/dim2.rs
@@ -1111,7 +1111,7 @@ impl MeshBuilder for Capsule2dMeshBuilder {
 
         // If the vertex count is even, offset starting angle of top semicircle by half a step
         // to position the vertices evenly.
-        let start_angle = if vertex_count % 2 == 0 {
+        let start_angle = if vertex_count.is_multiple_of(2) {
             step / 2.0
         } else {
             0.0
diff --git a/crates/bevy_pbr/src/meshlet/persistent_buffer.rs b/crates/bevy_pbr/src/meshlet/persistent_buffer.rs
index e8f4669227a0b..bae7b670b7de2 100644
--- a/crates/bevy_pbr/src/meshlet/persistent_buffer.rs
+++ b/crates/bevy_pbr/src/meshlet/persistent_buffer.rs
@@ -39,7 +39,7 @@ impl<T: PersistentGpuBufferable> PersistentGpuBuffer<T> {
     /// Queue an item of type T to be added to the buffer, returning the byte range within the buffer that it will be located at.
     pub fn queue_write(&mut self, data: T, metadata: T::Metadata) -> Range<BufferAddress> {
         let data_size = data.size_in_bytes() as u64;
-        debug_assert!(data_size % COPY_BUFFER_ALIGNMENT == 0);
+        debug_assert!(data_size.is_multiple_of(COPY_BUFFER_ALIGNMENT));
         if let Ok(buffer_slice) = self.allocation_planner.allocate_range(data_size) {
             self.write_queue
                 .push((data, metadata, buffer_slice.clone()));
diff --git a/crates/bevy_pbr/src/render/morph.rs b/crates/bevy_pbr/src/render/morph.rs
index b2dc90af02294..75ddb03414682 100644
--- a/crates/bevy_pbr/src/render/morph.rs
+++ b/crates/bevy_pbr/src/render/morph.rs
@@ -75,7 +75,7 @@ pub fn prepare_morphs(
 }
 
 const fn can_align(step: usize, target: usize) -> bool {
-    step % target == 0 || target % step == 0
+    step.is_multiple_of(target) || target.is_multiple_of(step)
 }
 
 const WGPU_MIN_ALIGN: usize = 256;
diff --git a/crates/bevy_render/src/render_resource/bind_group_entries.rs b/crates/bevy_render/src/render_resource/bind_group_entries.rs
index 847bb46f498af..274aa111434f6 100644
--- a/crates/bevy_render/src/render_resource/bind_group_entries.rs
+++ b/crates/bevy_render/src/render_resource/bind_group_entries.rs
@@ -244,6 +244,12 @@ pub struct DynamicBindGroupEntries<'b> {
     entries: Vec<BindGroupEntry<'b>>,
 }
 
+impl<'b> Default for DynamicBindGroupEntries<'b> {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
 impl<'b> DynamicBindGroupEntries<'b> {
     pub fn sequential<const N: usize>(entries: impl IntoBindingArray<'b, N>) -> Self {
         Self {
diff --git a/crates/bevy_tasks/src/task_pool.rs b/crates/bevy_tasks/src/task_pool.rs
index 25255a1e5d1d3..eb6f8502b3d80 100644
--- a/crates/bevy_tasks/src/task_pool.rs
+++ b/crates/bevy_tasks/src/task_pool.rs
@@ -384,12 +384,12 @@ impl TaskPool {
             unsafe { mem::transmute(external_executor) };
         // SAFETY: As above, all futures must complete in this function so we can change the lifetime
         let scope_executor: &'env ThreadExecutor<'env> = unsafe { mem::transmute(scope_executor) };
-        let spawned: ConcurrentQueue<FallibleTask<Result<T, Box<(dyn core::any::Any + Send)>>>> =
+        let spawned: ConcurrentQueue<FallibleTask<Result<T, Box<dyn core::any::Any + Send>>>> =
             ConcurrentQueue::unbounded();
         // shadow the variable so that the owned value cannot be used for the rest of the function
         // SAFETY: As above, all futures must complete in this function so we can change the lifetime
         let spawned: &'env ConcurrentQueue<
-            FallibleTask<Result<T, Box<(dyn core::any::Any + Send)>>>,
+            FallibleTask<Result<T, Box<dyn core::any::Any + Send>>>,
         > = unsafe { mem::transmute(&spawned) };
 
         let scope = Scope {
@@ -628,7 +628,7 @@ pub struct Scope<'scope, 'env: 'scope, T> {
     executor: &'scope crate::executor::Executor<'scope>,
     external_executor: &'scope ThreadExecutor<'scope>,
     scope_executor: &'scope ThreadExecutor<'scope>,
-    spawned: &'scope ConcurrentQueue<FallibleTask<Result<T, Box<(dyn core::any::Any + Send)>>>>,
+    spawned: &'scope ConcurrentQueue<FallibleTask<Result<T, Box<dyn core::any::Any + Send>>>>,
     // make `Scope` invariant over 'scope and 'env
     scope: PhantomData<&'scope mut &'scope ()>,
     env: PhantomData<&'env mut &'env ()>,
diff --git a/examples/app/headless.rs b/examples/app/headless.rs
index 94f01eaddcb8c..5c42f041e915b 100644
--- a/examples/app/headless.rs
+++ b/examples/app/headless.rs
@@ -50,7 +50,7 @@ fn hello_world_system() {
 }
 
 fn counter(mut state: Local<CounterState>) {
-    if state.count % 60 == 0 {
+    if state.count.is_multiple_of(60) {
         println!("{}", state.count);
     }
     state.count += 1;
diff --git a/examples/async_tasks/async_compute.rs b/examples/async_tasks/async_compute.rs
index fffb55ced1ace..908ae6e4c41a8 100644
--- a/examples/async_tasks/async_compute.rs
+++ b/examples/async_tasks/async_compute.rs
@@ -123,7 +123,7 @@ fn handle_tasks(
 /// This system is only used to setup light and camera for the environment
 fn setup_env(mut commands: Commands) {
     // Used to center camera on spawned cubes
-    let offset = if NUM_CUBES % 2 == 0 {
+    let offset = if NUM_CUBES.is_multiple_of(2) {
         (NUM_CUBES / 2) as f32 - 0.5
     } else {
         (NUM_CUBES / 2) as f32
diff --git a/examples/ecs/nondeterministic_system_order.rs b/examples/ecs/nondeterministic_system_order.rs
index e5e13ffdb302a..b034aaee4101d 100644
--- a/examples/ecs/nondeterministic_system_order.rs
+++ b/examples/ecs/nondeterministic_system_order.rs
@@ -89,7 +89,7 @@ fn doubles_b(mut b: ResMut<B>) {
 fn reads_b(b: Res<B>) {
     // This invariant is always true,
     // because we've fixed the system order so doubling always occurs after adding.
-    assert!((b.0 % 2 == 0) || (b.0 == usize::MAX));
+    assert!((b.0.is_multiple_of(2)) || (b.0 == usize::MAX));
 }
 
 fn reads_a_and_b(a: Res<A>, b: Res<B>) {
