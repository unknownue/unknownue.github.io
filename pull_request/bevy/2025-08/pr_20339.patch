diff --git a/crates/bevy_core_widgets/Cargo.toml b/crates/bevy_core_widgets/Cargo.toml
index 01da19ae7c0d2..29a8e1c6248a8 100644
--- a/crates/bevy_core_widgets/Cargo.toml
+++ b/crates/bevy_core_widgets/Cargo.toml
@@ -18,6 +18,7 @@ bevy_input_focus = { path = "../bevy_input_focus", version = "0.17.0-dev" }
 bevy_log = { path = "../bevy_log", version = "0.17.0-dev" }
 bevy_math = { path = "../bevy_math", version = "0.17.0-dev" }
 bevy_picking = { path = "../bevy_picking", version = "0.17.0-dev" }
+bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
 bevy_ui = { path = "../bevy_ui", version = "0.17.0-dev" }
 
 # other
diff --git a/crates/bevy_core_widgets/src/callback.rs b/crates/bevy_core_widgets/src/callback.rs
index 37905e221cfcf..d27fb21220af3 100644
--- a/crates/bevy_core_widgets/src/callback.rs
+++ b/crates/bevy_core_widgets/src/callback.rs
@@ -1,5 +1,6 @@
 use bevy_ecs::system::{Commands, SystemId, SystemInput};
 use bevy_ecs::world::{DeferredWorld, World};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 
 /// A callback defines how we want to be notified when a widget changes state. Unlike an event
 /// or observer, callbacks are intended for "point-to-point" communication that cuts across the
@@ -27,7 +28,8 @@ use bevy_ecs::world::{DeferredWorld, World};
 /// // Later, when we want to execute the callback:
 /// app.world_mut().commands().notify(&callback);
 /// ```
-#[derive(Default, Debug)]
+#[derive(Default, Debug, Reflect)]
+#[reflect(Default)]
 pub enum Callback<I: SystemInput = ()> {
     /// Invoke a one-shot system
     System(SystemId<I>),
diff --git a/crates/bevy_core_widgets/src/core_radio.rs b/crates/bevy_core_widgets/src/core_radio.rs
index 0aeebe9825cf0..4cea61e717517 100644
--- a/crates/bevy_core_widgets/src/core_radio.rs
+++ b/crates/bevy_core_widgets/src/core_radio.rs
@@ -8,12 +8,14 @@ use bevy_ecs::{
     component::Component,
     observer::On,
     query::With,
+    reflect::ReflectComponent,
     system::{Commands, Query},
 };
 use bevy_input::keyboard::{KeyCode, KeyboardInput};
 use bevy_input::ButtonState;
 use bevy_input_focus::FocusedInput;
 use bevy_picking::events::{Click, Pointer};
+use bevy_reflect::Reflect;
 use bevy_ui::{Checkable, Checked, InteractionDisabled};
 
 use crate::{Activate, Callback, Notify};
@@ -48,6 +50,8 @@ pub struct CoreRadioGroup {
 /// See <https://www.w3.org/WAI/ARIA/apg/patterns/radio>/
 #[derive(Component, Debug)]
 #[require(AccessibilityNode(accesskit::Node::new(Role::RadioButton)), Checkable)]
+#[derive(Reflect)]
+#[reflect(Component)]
 pub struct CoreRadio;
 
 fn radio_group_on_key_input(
diff --git a/crates/bevy_core_widgets/src/core_scrollbar.rs b/crates/bevy_core_widgets/src/core_scrollbar.rs
index d997f565cefd1..9065617413256 100644
--- a/crates/bevy_core_widgets/src/core_scrollbar.rs
+++ b/crates/bevy_core_widgets/src/core_scrollbar.rs
@@ -5,17 +5,20 @@ use bevy_ecs::{
     hierarchy::{ChildOf, Children},
     observer::On,
     query::{With, Without},
+    reflect::ReflectComponent,
     system::{Query, Res},
 };
 use bevy_math::Vec2;
 use bevy_picking::events::{Cancel, Drag, DragEnd, DragStart, Pointer, Press};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{
     ComputedNode, ComputedNodeTarget, Node, ScrollPosition, UiGlobalTransform, UiScale, Val,
 };
 
 /// Used to select the orientation of a scrollbar, slider, or other oriented control.
 // TODO: Move this to a more central place.
-#[derive(Debug, Default, Clone, Copy, PartialEq)]
+#[derive(Debug, Default, Clone, Copy, PartialEq, Reflect)]
+#[reflect(PartialEq, Clone, Default)]
 pub enum ControlOrientation {
     /// Horizontal orientation (stretching from left to right)
     Horizontal,
@@ -45,7 +48,8 @@ pub enum ControlOrientation {
 /// The application is free to position the scrollbars relative to the scrolling container however
 /// it wants: it can overlay them on top of the scrolling content, or use a grid layout to displace
 /// the content to make room for the scrollbars.
-#[derive(Component, Debug)]
+#[derive(Component, Debug, Reflect)]
+#[reflect(Component)]
 pub struct CoreScrollbar {
     /// Entity being scrolled.
     pub target: Entity,
@@ -62,6 +66,8 @@ pub struct CoreScrollbar {
 /// the scrollbar). This should be a child of the scrollbar entity.
 #[derive(Component, Debug)]
 #[require(CoreScrollbarDragState)]
+#[derive(Reflect)]
+#[reflect(Component)]
 pub struct CoreScrollbarThumb;
 
 impl CoreScrollbar {
@@ -83,7 +89,8 @@ impl CoreScrollbar {
 
 /// Component used to manage the state of a scrollbar during dragging. This component is
 /// inserted on the thumb entity.
-#[derive(Component, Default)]
+#[derive(Component, Default, Reflect)]
+#[reflect(Component, Default)]
 pub struct CoreScrollbarDragState {
     /// Whether the scrollbar is currently being dragged.
     pub dragging: bool,
diff --git a/crates/bevy_core_widgets/src/core_slider.rs b/crates/bevy_core_widgets/src/core_slider.rs
index 34151a4d4b41f..64570c2ed1963 100644
--- a/crates/bevy_core_widgets/src/core_slider.rs
+++ b/crates/bevy_core_widgets/src/core_slider.rs
@@ -13,6 +13,7 @@ use bevy_ecs::{
     component::Component,
     observer::On,
     query::With,
+    reflect::ReflectComponent,
     system::{Commands, Query},
 };
 use bevy_input::keyboard::{KeyCode, KeyboardInput};
@@ -21,12 +22,14 @@ use bevy_input_focus::FocusedInput;
 use bevy_log::warn_once;
 use bevy_math::ops;
 use bevy_picking::events::{Drag, DragEnd, DragStart, Pointer, Press};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{ComputedNode, ComputedNodeTarget, InteractionDisabled, UiGlobalTransform, UiScale};
 
 use crate::{Callback, Notify, ValueChange};
 
 /// Defines how the slider should behave when you click on the track (not the thumb).
-#[derive(Debug, Default, PartialEq, Clone, Copy)]
+#[derive(Debug, Default, PartialEq, Clone, Copy, Reflect)]
+#[reflect(Clone, PartialEq, Default)]
 pub enum TrackClick {
     /// Clicking on the track lets you drag to edit the value, just like clicking on the thumb.
     #[default]
@@ -181,6 +184,8 @@ impl Default for SliderRange {
 /// shortcuts. Defaults to 1.0.
 #[derive(Component, Debug, PartialEq, Clone)]
 #[component(immutable)]
+#[derive(Reflect)]
+#[reflect(Component)]
 pub struct SliderStep(pub f32);
 
 impl Default for SliderStep {
@@ -198,7 +203,8 @@ impl Default for SliderStep {
 /// The value in this component represents the number of decimal places of desired precision, so a
 /// value of 2 would round to the nearest 1/100th. A value of -3 would round to the nearest
 /// thousand.
-#[derive(Component, Debug, Default, Clone, Copy)]
+#[derive(Component, Debug, Default, Clone, Copy, Reflect)]
+#[reflect(Component, Default)]
 pub struct SliderPrecision(pub i32);
 
 impl SliderPrecision {
@@ -209,7 +215,8 @@ impl SliderPrecision {
 }
 
 /// Component used to manage the state of a slider during dragging.
-#[derive(Component, Default)]
+#[derive(Component, Default, Reflect)]
+#[reflect(Component)]
 pub struct CoreSliderDragState {
     /// Whether the slider is currently being dragged.
     pub dragging: bool,
diff --git a/crates/bevy_feathers/src/alpha_pattern.rs b/crates/bevy_feathers/src/alpha_pattern.rs
index 5401006a49176..767aaf08f51c2 100644
--- a/crates/bevy_feathers/src/alpha_pattern.rs
+++ b/crates/bevy_feathers/src/alpha_pattern.rs
@@ -4,11 +4,12 @@ use bevy_ecs::{
     component::Component,
     lifecycle::Add,
     observer::On,
+    reflect::ReflectComponent,
     resource::Resource,
     system::{Query, Res},
     world::FromWorld,
 };
-use bevy_reflect::TypePath;
+use bevy_reflect::{prelude::ReflectDefault, Reflect, TypePath};
 use bevy_render::render_resource::{AsBindGroup, ShaderRef};
 use bevy_ui_render::ui_material::{MaterialNode, UiMaterial};
 
@@ -34,7 +35,8 @@ impl FromWorld for AlphaPatternResource {
 }
 
 /// Marker that tells us we want to fill in the [`MaterialNode`] with the alpha material.
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Default)]
 pub(crate) struct AlphaPattern;
 
 /// Observer to fill in the material handle (since we don't have access to the materials asset
diff --git a/crates/bevy_feathers/src/controls/button.rs b/crates/bevy_feathers/src/controls/button.rs
index 3566639993764..68af828d93818 100644
--- a/crates/bevy_feathers/src/controls/button.rs
+++ b/crates/bevy_feathers/src/controls/button.rs
@@ -7,12 +7,14 @@ use bevy_ecs::{
     hierarchy::{ChildOf, Children},
     lifecycle::RemovedComponents,
     query::{Added, Changed, Has, Or},
+    reflect::ReflectComponent,
     schedule::IntoScheduleConfigs,
     spawn::{SpawnRelated, SpawnableList},
     system::{Commands, In, Query},
 };
 use bevy_input_focus::tab_navigation::TabIndex;
 use bevy_picking::{hover::Hovered, PickingSystems};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{AlignItems, InteractionDisabled, JustifyContent, Node, Pressed, UiRect, Val};
 
 use crate::{
@@ -27,7 +29,8 @@ use crate::{
 
 /// Color variants for buttons. This also functions as a component used by the dynamic styling
 /// system to identify which entities are buttons.
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 pub enum ButtonVariant {
     /// The standard button appearance
     #[default]
diff --git a/crates/bevy_feathers/src/controls/checkbox.rs b/crates/bevy_feathers/src/controls/checkbox.rs
index 549a3737e5d5f..328098eeb2578 100644
--- a/crates/bevy_feathers/src/controls/checkbox.rs
+++ b/crates/bevy_feathers/src/controls/checkbox.rs
@@ -8,6 +8,7 @@ use bevy_ecs::{
     hierarchy::{ChildOf, Children},
     lifecycle::RemovedComponents,
     query::{Added, Changed, Has, Or, With},
+    reflect::ReflectComponent,
     schedule::IntoScheduleConfigs,
     spawn::{Spawn, SpawnRelated, SpawnableList},
     system::{Commands, In, Query},
@@ -15,6 +16,7 @@ use bevy_ecs::{
 use bevy_input_focus::tab_navigation::TabIndex;
 use bevy_math::Rot2;
 use bevy_picking::{hover::Hovered, PickingSystems};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_render::view::Visibility;
 use bevy_ui::{
     AlignItems, BorderRadius, Checked, Display, FlexDirection, InteractionDisabled, JustifyContent,
@@ -38,15 +40,18 @@ pub struct CheckboxProps {
 }
 
 /// Marker for the checkbox frame (contains both checkbox and label)
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct CheckboxFrame;
 
 /// Marker for the checkbox outline
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct CheckboxOutline;
 
 /// Marker for the checkbox check mark
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct CheckboxMark;
 
 /// Template function to spawn a checkbox.
diff --git a/crates/bevy_feathers/src/controls/color_swatch.rs b/crates/bevy_feathers/src/controls/color_swatch.rs
index b43497805f6cd..972f13b7878f5 100644
--- a/crates/bevy_feathers/src/controls/color_swatch.rs
+++ b/crates/bevy_feathers/src/controls/color_swatch.rs
@@ -1,6 +1,9 @@
 use bevy_asset::Handle;
 use bevy_color::Alpha;
-use bevy_ecs::{bundle::Bundle, children, component::Component, spawn::SpawnRelated};
+use bevy_ecs::{
+    bundle::Bundle, children, component::Component, reflect::ReflectComponent, spawn::SpawnRelated,
+};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{BackgroundColor, BorderRadius, Node, PositionType, Val};
 use bevy_ui_render::ui_material::MaterialNode;
 
@@ -11,13 +14,15 @@ use crate::{
 };
 
 /// Marker identifying a color swatch.
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 pub struct ColorSwatch;
 
 /// Marker identifying the color swatch foreground, the piece that actually displays the color
 /// in front of the alpha pattern. This exists so that users can reach in and change the color
 /// dynamically.
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 pub struct ColorSwatchFg;
 
 /// Template function to spawn a color swatch.
diff --git a/crates/bevy_feathers/src/controls/radio.rs b/crates/bevy_feathers/src/controls/radio.rs
index aa5afa5efb426..0b13069158919 100644
--- a/crates/bevy_feathers/src/controls/radio.rs
+++ b/crates/bevy_feathers/src/controls/radio.rs
@@ -8,12 +8,14 @@ use bevy_ecs::{
     hierarchy::{ChildOf, Children},
     lifecycle::RemovedComponents,
     query::{Added, Changed, Has, Or, With},
+    reflect::ReflectComponent,
     schedule::IntoScheduleConfigs,
     spawn::{Spawn, SpawnRelated, SpawnableList},
     system::{Commands, Query},
 };
 use bevy_input_focus::tab_navigation::TabIndex;
 use bevy_picking::{hover::Hovered, PickingSystems};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_render::view::Visibility;
 use bevy_ui::{
     AlignItems, BorderRadius, Checked, Display, FlexDirection, InteractionDisabled, JustifyContent,
@@ -30,11 +32,13 @@ use crate::{
 };
 
 /// Marker for the radio outline
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct RadioOutline;
 
 /// Marker for the radio check mark
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct RadioMark;
 
 /// Template function to spawn a radio.
diff --git a/crates/bevy_feathers/src/controls/slider.rs b/crates/bevy_feathers/src/controls/slider.rs
index 49a7a4c0cc633..fcea771806cd9 100644
--- a/crates/bevy_feathers/src/controls/slider.rs
+++ b/crates/bevy_feathers/src/controls/slider.rs
@@ -11,12 +11,14 @@ use bevy_ecs::{
     hierarchy::Children,
     lifecycle::RemovedComponents,
     query::{Added, Changed, Has, Or, Spawned, With},
+    reflect::ReflectComponent,
     schedule::IntoScheduleConfigs,
     spawn::SpawnRelated,
     system::{In, Query, Res},
 };
 use bevy_input_focus::tab_navigation::TabIndex;
 use bevy_picking::PickingSystems;
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{
     widget::Text, AlignItems, BackgroundGradient, ColorStop, Display, FlexDirection, Gradient,
     InteractionDisabled, InterpolationColorSpace, JustifyContent, LinearGradient, Node, UiRect,
@@ -58,10 +60,13 @@ impl Default for SliderProps {
 
 #[derive(Component, Default, Clone)]
 #[require(CoreSlider)]
+#[derive(Reflect)]
+#[reflect(Component, Clone, Default)]
 struct SliderStyle;
 
 /// Marker for the text
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct SliderValueText;
 
 /// Spawn a new slider widget.
diff --git a/crates/bevy_feathers/src/controls/toggle_switch.rs b/crates/bevy_feathers/src/controls/toggle_switch.rs
index 58b6b474244db..46872d97b0e8b 100644
--- a/crates/bevy_feathers/src/controls/toggle_switch.rs
+++ b/crates/bevy_feathers/src/controls/toggle_switch.rs
@@ -10,6 +10,7 @@ use bevy_ecs::{
     hierarchy::Children,
     lifecycle::RemovedComponents,
     query::{Added, Changed, Has, Or, With},
+    reflect::ReflectComponent,
     schedule::IntoScheduleConfigs,
     spawn::SpawnRelated,
     system::{Commands, In, Query},
@@ -17,6 +18,7 @@ use bevy_ecs::{
 };
 use bevy_input_focus::tab_navigation::TabIndex;
 use bevy_picking::{hover::Hovered, PickingSystems};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{BorderRadius, Checked, InteractionDisabled, Node, PositionType, UiRect, Val};
 
 use crate::{
@@ -34,11 +36,13 @@ pub struct ToggleSwitchProps {
 }
 
 /// Marker for the toggle switch outline
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct ToggleSwitchOutline;
 
 /// Marker for the toggle switch slide
-#[derive(Component, Default, Clone)]
+#[derive(Component, Default, Clone, Reflect)]
+#[reflect(Component, Clone, Default)]
 struct ToggleSwitchSlide;
 
 /// Template function to spawn a toggle switch.
diff --git a/crates/bevy_feathers/src/cursor.rs b/crates/bevy_feathers/src/cursor.rs
index 837b4c114b46f..c61d57cc5f3de 100644
--- a/crates/bevy_feathers/src/cursor.rs
+++ b/crates/bevy_feathers/src/cursor.rs
@@ -5,7 +5,7 @@ use bevy_ecs::{
     entity::Entity,
     hierarchy::ChildOf,
     query::{With, Without},
-    reflect::ReflectComponent,
+    reflect::{ReflectComponent, ReflectResource},
     resource::Resource,
     schedule::IntoScheduleConfigs,
     system::{Commands, Query, Res},
@@ -19,7 +19,8 @@ use bevy_winit::cursor::CustomCursor;
 
 /// A resource that specifies the cursor icon to be used when the mouse is not hovering over
 /// any other entity. This is used to set the default cursor icon for the window.
-#[derive(Resource, Debug, Clone, Default)]
+#[derive(Resource, Debug, Clone, Default, Reflect)]
+#[reflect(Resource, Debug, Default)]
 pub struct DefaultCursor(pub EntityCursor);
 
 /// A component that specifies the cursor shape to be used when the pointer hovers over an entity.
diff --git a/crates/bevy_feathers/src/font_styles.rs b/crates/bevy_feathers/src/font_styles.rs
index 6de064dd39248..f09a4af3ed916 100644
--- a/crates/bevy_feathers/src/font_styles.rs
+++ b/crates/bevy_feathers/src/font_styles.rs
@@ -5,15 +5,18 @@ use bevy_ecs::{
     component::Component,
     lifecycle::Insert,
     observer::On,
+    reflect::ReflectComponent,
     system::{Commands, Query, Res},
 };
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_text::{Font, TextFont};
 
 use crate::handle_or_path::HandleOrPath;
 
 /// A component which, when inserted on an entity, will load the given font and propagate it
 /// downward to any child text entity that has the [`ThemedText`](crate::theme::ThemedText) marker.
-#[derive(Component, Default, Clone, Debug)]
+#[derive(Component, Default, Clone, Debug, Reflect)]
+#[reflect(Component, Default)]
 pub struct InheritableFont {
     /// The font handle or path.
     pub font: HandleOrPath<Font>,
diff --git a/crates/bevy_feathers/src/handle_or_path.rs b/crates/bevy_feathers/src/handle_or_path.rs
index 178d2b13e876e..d6330b38d5d41 100644
--- a/crates/bevy_feathers/src/handle_or_path.rs
+++ b/crates/bevy_feathers/src/handle_or_path.rs
@@ -1,11 +1,12 @@
 //! Provides a way to specify assets either by handle or by path.
 use bevy_asset::{Asset, Handle};
+use bevy_reflect::Reflect;
 
 /// Enum that represents a reference to an asset as either a [`Handle`] or a [`String`] path.
 ///
 /// This is useful for when you want to specify an asset, but don't always have convenient
 /// access to an asset server reference.
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Reflect)]
 pub enum HandleOrPath<T: Asset> {
     /// Specify the asset reference as a handle.
     Handle(Handle<T>),
diff --git a/crates/bevy_feathers/src/theme.rs b/crates/bevy_feathers/src/theme.rs
index 9969b54846667..1bb8f08e61825 100644
--- a/crates/bevy_feathers/src/theme.rs
+++ b/crates/bevy_feathers/src/theme.rs
@@ -7,16 +7,19 @@ use bevy_ecs::{
     lifecycle::Insert,
     observer::On,
     query::Changed,
+    reflect::{ReflectComponent, ReflectResource},
     resource::Resource,
     system::{Commands, Query, Res},
 };
 use bevy_log::warn_once;
 use bevy_platform::collections::HashMap;
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_text::TextColor;
 use bevy_ui::{BackgroundColor, BorderColor};
 
 /// A collection of properties that make up a theme.
-#[derive(Default, Clone)]
+#[derive(Default, Clone, Reflect, Debug)]
+#[reflect(Default, Debug)]
 pub struct ThemeProps {
     /// Map of design tokens to colors.
     pub color: HashMap<String, Color>,
@@ -24,7 +27,8 @@ pub struct ThemeProps {
 }
 
 /// The currently selected user interface theme. Overwriting this resource changes the theme.
-#[derive(Resource, Default)]
+#[derive(Resource, Default, Reflect, Debug)]
+#[reflect(Resource, Default, Debug)]
 pub struct UiTheme(pub ThemeProps);
 
 impl UiTheme {
@@ -52,6 +56,8 @@ impl UiTheme {
 #[derive(Component, Clone, Copy)]
 #[require(BackgroundColor)]
 #[component(immutable)]
+#[derive(Reflect)]
+#[reflect(Component, Clone)]
 pub struct ThemeBackgroundColor(pub &'static str);
 
 /// Component which causes the border color of an entity to be set based on a theme color.
@@ -59,16 +65,21 @@ pub struct ThemeBackgroundColor(pub &'static str);
 #[derive(Component, Clone, Copy)]
 #[require(BorderColor)]
 #[component(immutable)]
+#[derive(Reflect)]
+#[reflect(Component, Clone)]
 pub struct ThemeBorderColor(pub &'static str);
 
 /// Component which causes the inherited text color of an entity to be set based on a theme color.
 #[derive(Component, Clone, Copy)]
 #[component(immutable)]
+#[derive(Reflect)]
+#[reflect(Component, Clone)]
 pub struct ThemeFontColor(pub &'static str);
 
 /// A marker component that is used to indicate that the text entity wants to opt-in to using
 /// inherited text styles.
-#[derive(Component)]
+#[derive(Component, Reflect)]
+#[reflect(Component)]
 pub struct ThemedText;
 
 pub(crate) fn update_theme(
