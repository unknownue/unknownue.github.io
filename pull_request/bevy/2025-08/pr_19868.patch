diff --git a/crates/bevy_anti_aliasing/src/contrast_adaptive_sharpening/node.rs b/crates/bevy_anti_aliasing/src/contrast_adaptive_sharpening/node.rs
index 663d481e887bd..070b57099707e 100644
--- a/crates/bevy_anti_aliasing/src/contrast_adaptive_sharpening/node.rs
+++ b/crates/bevy_anti_aliasing/src/contrast_adaptive_sharpening/node.rs
@@ -98,6 +98,7 @@ impl Node for CasNode {
             label: Some("contrast_adaptive_sharpening"),
             color_attachments: &[Some(RenderPassColorAttachment {
                 view: destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations::default(),
             })],
diff --git a/crates/bevy_anti_aliasing/src/fxaa/node.rs b/crates/bevy_anti_aliasing/src/fxaa/node.rs
index a58f21d9a7746..8881607cba4e4 100644
--- a/crates/bevy_anti_aliasing/src/fxaa/node.rs
+++ b/crates/bevy_anti_aliasing/src/fxaa/node.rs
@@ -64,6 +64,7 @@ impl ViewNode for FxaaNode {
             label: Some("fxaa_pass"),
             color_attachments: &[Some(RenderPassColorAttachment {
                 view: destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations::default(),
             })],
diff --git a/crates/bevy_anti_aliasing/src/smaa/mod.rs b/crates/bevy_anti_aliasing/src/smaa/mod.rs
index 33a916e489a96..cafab566a0732 100644
--- a/crates/bevy_anti_aliasing/src/smaa/mod.rs
+++ b/crates/bevy_anti_aliasing/src/smaa/mod.rs
@@ -896,6 +896,7 @@ fn perform_edge_detection(
         label: Some("SMAA edge detection pass"),
         color_attachments: &[Some(RenderPassColorAttachment {
             view: &smaa_textures.edge_detection_color_texture.default_view,
+            depth_slice: None,
             resolve_target: None,
             ops: default(),
         })],
@@ -951,6 +952,7 @@ fn perform_blending_weight_calculation(
         label: Some("SMAA blending weight calculation pass"),
         color_attachments: &[Some(RenderPassColorAttachment {
             view: &smaa_textures.blend_texture.default_view,
+            depth_slice: None,
             resolve_target: None,
             ops: default(),
         })],
@@ -1007,6 +1009,7 @@ fn perform_neighborhood_blending(
         label: Some("SMAA neighborhood blending pass"),
         color_attachments: &[Some(RenderPassColorAttachment {
             view: destination,
+            depth_slice: None,
             resolve_target: None,
             ops: default(),
         })],
diff --git a/crates/bevy_anti_aliasing/src/taa/mod.rs b/crates/bevy_anti_aliasing/src/taa/mod.rs
index f182108f1082a..658e31aa586f6 100644
--- a/crates/bevy_anti_aliasing/src/taa/mod.rs
+++ b/crates/bevy_anti_aliasing/src/taa/mod.rs
@@ -202,11 +202,13 @@ impl ViewNode for TemporalAntiAliasNode {
                 color_attachments: &[
                     Some(RenderPassColorAttachment {
                         view: view_target.destination,
+                        depth_slice: None,
                         resolve_target: None,
                         ops: Operations::default(),
                     }),
                     Some(RenderPassColorAttachment {
                         view: &taa_history_textures.write.default_view,
+                        depth_slice: None,
                         resolve_target: None,
                         ops: Operations::default(),
                     }),
diff --git a/crates/bevy_camera/Cargo.toml b/crates/bevy_camera/Cargo.toml
index 6ed3998a82165..d6cbd46667fef 100644
--- a/crates/bevy_camera/Cargo.toml
+++ b/crates/bevy_camera/Cargo.toml
@@ -26,7 +26,7 @@ bevy_color = { path = "../bevy_color", version = "0.17.0-dev", features = [
 bevy_window = { path = "../bevy_window", version = "0.17.0-dev" }
 
 # other
-wgpu-types = { version = "25", default-features = false }
+wgpu-types = { version = "26", default-features = false }
 serde = { version = "1", default-features = false, features = ["derive"] }
 thiserror = { version = "2", default-features = false }
 downcast-rs = { version = "2", default-features = false, features = ["std"] }
diff --git a/crates/bevy_color/Cargo.toml b/crates/bevy_color/Cargo.toml
index 22ade1270900b..81a9795d580e8 100644
--- a/crates/bevy_color/Cargo.toml
+++ b/crates/bevy_color/Cargo.toml
@@ -20,7 +20,7 @@ serde = { version = "1.0", features = [
 ], default-features = false, optional = true }
 thiserror = { version = "2", default-features = false }
 derive_more = { version = "2", default-features = false, features = ["from"] }
-wgpu-types = { version = "25", default-features = false, optional = true }
+wgpu-types = { version = "26", default-features = false, optional = true }
 encase = { version = "0.10", default-features = false, optional = true }
 
 [features]
diff --git a/crates/bevy_core_pipeline/src/bloom/mod.rs b/crates/bevy_core_pipeline/src/bloom/mod.rs
index 0308ebe72e508..09112794026ba 100644
--- a/crates/bevy_core_pipeline/src/bloom/mod.rs
+++ b/crates/bevy_core_pipeline/src/bloom/mod.rs
@@ -186,6 +186,7 @@ impl ViewNode for BloomNode {
                         label: Some("bloom_downsampling_first_pass"),
                         color_attachments: &[Some(RenderPassColorAttachment {
                             view,
+                            depth_slice: None,
                             resolve_target: None,
                             ops: Operations::default(),
                         })],
@@ -210,6 +211,7 @@ impl ViewNode for BloomNode {
                         label: Some("bloom_downsampling_pass"),
                         color_attachments: &[Some(RenderPassColorAttachment {
                             view,
+                            depth_slice: None,
                             resolve_target: None,
                             ops: Operations::default(),
                         })],
@@ -234,6 +236,7 @@ impl ViewNode for BloomNode {
                         label: Some("bloom_upsampling_pass"),
                         color_attachments: &[Some(RenderPassColorAttachment {
                             view,
+                            depth_slice: None,
                             resolve_target: None,
                             ops: Operations {
                                 load: LoadOp::Load,
diff --git a/crates/bevy_core_pipeline/src/deferred/node.rs b/crates/bevy_core_pipeline/src/deferred/node.rs
index ab87fccee6e89..a8e1b7ab8ed2a 100644
--- a/crates/bevy_core_pipeline/src/deferred/node.rs
+++ b/crates/bevy_core_pipeline/src/deferred/node.rs
@@ -176,6 +176,7 @@ fn run_deferred_prepass<'w>(
                                 load: bevy_render::render_resource::LoadOp::Load,
                                 store: StoreOp::Store,
                             },
+                            depth_slice: None,
                         }
                     }
                     #[cfg(any(
diff --git a/crates/bevy_core_pipeline/src/dof/mod.rs b/crates/bevy_core_pipeline/src/dof/mod.rs
index 0bd5c79365d12..0e65c4d0a4dfa 100644
--- a/crates/bevy_core_pipeline/src/dof/mod.rs
+++ b/crates/bevy_core_pipeline/src/dof/mod.rs
@@ -409,6 +409,7 @@ impl ViewNode for DepthOfFieldNode {
             let mut color_attachments: SmallVec<[_; 2]> = SmallVec::new();
             color_attachments.push(Some(RenderPassColorAttachment {
                 view: postprocess.destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations {
                     load: LoadOp::Clear(default()),
@@ -429,6 +430,7 @@ impl ViewNode for DepthOfFieldNode {
                 };
                 color_attachments.push(Some(RenderPassColorAttachment {
                     view: &auxiliary_dof_texture.default_view,
+                    depth_slice: None,
                     resolve_target: None,
                     ops: Operations {
                         load: LoadOp::Clear(default()),
diff --git a/crates/bevy_core_pipeline/src/motion_blur/node.rs b/crates/bevy_core_pipeline/src/motion_blur/node.rs
index ade5f50d77466..5fb8eeebcdc02 100644
--- a/crates/bevy_core_pipeline/src/motion_blur/node.rs
+++ b/crates/bevy_core_pipeline/src/motion_blur/node.rs
@@ -84,6 +84,7 @@ impl ViewNode for MotionBlurNode {
             label: Some("motion_blur_pass"),
             color_attachments: &[Some(RenderPassColorAttachment {
                 view: post_process.destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations::default(),
             })],
diff --git a/crates/bevy_core_pipeline/src/msaa_writeback.rs b/crates/bevy_core_pipeline/src/msaa_writeback.rs
index 151660876aeb0..4b63de7dad131 100644
--- a/crates/bevy_core_pipeline/src/msaa_writeback.rs
+++ b/crates/bevy_core_pipeline/src/msaa_writeback.rs
@@ -87,6 +87,7 @@ impl ViewNode for MsaaWritebackNode {
             color_attachments: &[Some(RenderPassColorAttachment {
                 // If MSAA is enabled, then the sampled texture will always exist
                 view: target.sampled_main_texture_view().unwrap(),
+                depth_slice: None,
                 resolve_target: Some(post_process.destination),
                 ops: Operations {
                     load: LoadOp::Clear(LinearRgba::BLACK.into()),
diff --git a/crates/bevy_core_pipeline/src/post_process/mod.rs b/crates/bevy_core_pipeline/src/post_process/mod.rs
index 6d9a7669f2221..72eac853a7d86 100644
--- a/crates/bevy_core_pipeline/src/post_process/mod.rs
+++ b/crates/bevy_core_pipeline/src/post_process/mod.rs
@@ -379,6 +379,7 @@ impl ViewNode for PostProcessingNode {
             label: Some("postprocessing pass"),
             color_attachments: &[Some(RenderPassColorAttachment {
                 view: post_process.destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations::default(),
             })],
diff --git a/crates/bevy_core_pipeline/src/tonemapping/node.rs b/crates/bevy_core_pipeline/src/tonemapping/node.rs
index 0f8f6edc49eb2..58dd673264d18 100644
--- a/crates/bevy_core_pipeline/src/tonemapping/node.rs
+++ b/crates/bevy_core_pipeline/src/tonemapping/node.rs
@@ -117,6 +117,7 @@ impl ViewNode for TonemappingNode {
             label: Some("tonemapping_pass"),
             color_attachments: &[Some(RenderPassColorAttachment {
                 view: destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations {
                     load: LoadOp::Clear(Default::default()), // TODO shouldn't need to be cleared
diff --git a/crates/bevy_image/Cargo.toml b/crates/bevy_image/Cargo.toml
index 3d33720eadfa9..4069136e2b907 100644
--- a/crates/bevy_image/Cargo.toml
+++ b/crates/bevy_image/Cargo.toml
@@ -70,7 +70,7 @@ image = { version = "0.25.2", default-features = false }
 # misc
 bitflags = { version = "2.3", features = ["serde"] }
 bytemuck = { version = "1.5" }
-wgpu-types = { version = "25", default-features = false }
+wgpu-types = { version = "26", default-features = false }
 serde = { version = "1", features = ["derive"] }
 thiserror = { version = "2", default-features = false }
 futures-lite = "2.0.1"
diff --git a/crates/bevy_mesh/Cargo.toml b/crates/bevy_mesh/Cargo.toml
index 0f37ac11417a9..026e96f5cebf6 100644
--- a/crates/bevy_mesh/Cargo.toml
+++ b/crates/bevy_mesh/Cargo.toml
@@ -26,7 +26,7 @@ bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev", default-fea
 # other
 bitflags = { version = "2.3", features = ["serde"] }
 bytemuck = { version = "1.5" }
-wgpu-types = { version = "25", default-features = false }
+wgpu-types = { version = "26", default-features = false }
 serde = { version = "1", default-features = false, features = [
   "derive",
 ], optional = true }
diff --git a/crates/bevy_pbr/src/light_probe/downsample.wgsl b/crates/bevy_pbr/src/light_probe/downsample.wgsl
index 57a0615c87c1d..e28c9b2f1ab72 100644
--- a/crates/bevy_pbr/src/light_probe/downsample.wgsl
+++ b/crates/bevy_pbr/src/light_probe/downsample.wgsl
@@ -50,22 +50,16 @@ var<workgroup> spd_intermediate_a: array<array<f32, 16>, 16>;
 @workgroup_size(256, 1, 1)
 fn downsample_first(
     @builtin(workgroup_id) workgroup_id: vec3u,
-    @builtin(local_invocation_index) local_invocation_index: u32,
-#ifdef SUBGROUP_SUPPORT
-    @builtin(subgroup_invocation_id) subgroup_invocation_id: u32,
-#endif
+    @builtin(local_invocation_index) local_invocation_index: u32
 ) {
-#ifndef SUBGROUP_SUPPORT
-    let subgroup_invocation_id = 0u;
-#endif
 
     let sub_xy = remap_for_wave_reduction(local_invocation_index % 64u);
     let x = sub_xy.x + 8u * ((local_invocation_index >> 6u) % 2u);
     let y = sub_xy.y + 8u * (local_invocation_index >> 7u);
 
-    spd_downsample_mips_0_1(x, y, workgroup_id.xy, local_invocation_index, constants.mips, workgroup_id.z, subgroup_invocation_id);
+    spd_downsample_mips_0_1(x, y, workgroup_id.xy, local_invocation_index, constants.mips, workgroup_id.z);
 
-    spd_downsample_next_four(x, y, workgroup_id.xy, local_invocation_index, 2u, constants.mips, workgroup_id.z, subgroup_invocation_id);
+    spd_downsample_next_four(x, y, workgroup_id.xy, local_invocation_index, 2u, constants.mips, workgroup_id.z);
 }
 
 // TODO: Once wgpu supports globallycoherent buffers, make it actually a single pass
@@ -74,24 +68,17 @@ fn downsample_first(
 fn downsample_second(
     @builtin(workgroup_id) workgroup_id: vec3u,
     @builtin(local_invocation_index) local_invocation_index: u32,
-#ifdef SUBGROUP_SUPPORT
-    @builtin(subgroup_invocation_id) subgroup_invocation_id: u32,
-#endif
 ) {
-#ifndef SUBGROUP_SUPPORT
-    let subgroup_invocation_id = 0u;
-#endif
-
     let sub_xy = remap_for_wave_reduction(local_invocation_index % 64u);
     let x = sub_xy.x + 8u * ((local_invocation_index >> 6u) % 2u);
     let y = sub_xy.y + 8u * (local_invocation_index >> 7u);
 
     spd_downsample_mips_6_7(x, y, constants.mips, workgroup_id.z);
 
-    spd_downsample_next_four(x, y, vec2(0u), local_invocation_index, 8u, constants.mips, workgroup_id.z, subgroup_invocation_id);
+    spd_downsample_next_four(x, y, vec2(0u), local_invocation_index, 8u, constants.mips, workgroup_id.z);
 }
 
-fn spd_downsample_mips_0_1(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, mips: u32, slice: u32, subgroup_invocation_id: u32) {
+fn spd_downsample_mips_0_1(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, mips: u32, slice: u32) {
     var v: array<vec4f, 4>;
 
     var tex = (workgroup_id * 64u) + vec2(x * 2u, y * 2u);
@@ -117,10 +104,10 @@ fn spd_downsample_mips_0_1(x: u32, y: u32, workgroup_id: vec2u, local_invocation
     if mips <= 1u { return; }
 
 #ifdef SUBGROUP_SUPPORT
-    v[0] = spd_reduce_quad(v[0], subgroup_invocation_id);
-    v[1] = spd_reduce_quad(v[1], subgroup_invocation_id);
-    v[2] = spd_reduce_quad(v[2], subgroup_invocation_id);
-    v[3] = spd_reduce_quad(v[3], subgroup_invocation_id);
+    v[0] = spd_reduce_quad(v[0]);
+    v[1] = spd_reduce_quad(v[1]);
+    v[2] = spd_reduce_quad(v[2]);
+    v[3] = spd_reduce_quad(v[3]);
 
     if local_invocation_index % 4u == 0u {
         spd_store((workgroup_id * 16u) + vec2(x / 2u, y / 2u), v[0], 1u, slice);
@@ -160,28 +147,28 @@ fn spd_downsample_mips_0_1(x: u32, y: u32, workgroup_id: vec2u, local_invocation
 #endif
 }
 
-fn spd_downsample_next_four(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, mips: u32, slice: u32, subgroup_invocation_id: u32) {
+fn spd_downsample_next_four(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, mips: u32, slice: u32) {
     if mips <= base_mip { return; }
     workgroupBarrier();
-    spd_downsample_mip_2(x, y, workgroup_id, local_invocation_index, base_mip, slice, subgroup_invocation_id);
+    spd_downsample_mip_2(x, y, workgroup_id, local_invocation_index, base_mip, slice);
 
     if mips <= base_mip + 1u { return; }
     workgroupBarrier();
-    spd_downsample_mip_3(x, y, workgroup_id, local_invocation_index, base_mip + 1u, slice, subgroup_invocation_id);
+    spd_downsample_mip_3(x, y, workgroup_id, local_invocation_index, base_mip + 1u, slice);
 
     if mips <= base_mip + 2u { return; }
     workgroupBarrier();
-    spd_downsample_mip_4(x, y, workgroup_id, local_invocation_index, base_mip + 2u, slice, subgroup_invocation_id);
+    spd_downsample_mip_4(x, y, workgroup_id, local_invocation_index, base_mip + 2u, slice);
 
     if mips <= base_mip + 3u { return; }
     workgroupBarrier();
-    spd_downsample_mip_5(x, y, workgroup_id, local_invocation_index, base_mip + 3u, slice, subgroup_invocation_id);
+    spd_downsample_mip_5(x, y, workgroup_id, local_invocation_index, base_mip + 3u, slice);
 }
 
-fn spd_downsample_mip_2(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+fn spd_downsample_mip_2(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32) {
 #ifdef SUBGROUP_SUPPORT
     var v = spd_load_intermediate(x, y);
-    v = spd_reduce_quad(v, subgroup_invocation_id);
+    v = spd_reduce_quad(v);
     if local_invocation_index % 4u == 0u {
         spd_store((workgroup_id * 8u) + vec2(x / 2u, y / 2u), v, base_mip, slice);
         spd_store_intermediate(x + (y / 2u) % 2u, y, v);
@@ -200,11 +187,11 @@ fn spd_downsample_mip_2(x: u32, y: u32, workgroup_id: vec2u, local_invocation_in
 #endif
 }
 
-fn spd_downsample_mip_3(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+fn spd_downsample_mip_3(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32) {
 #ifdef SUBGROUP_SUPPORT
     if local_invocation_index < 64u {
         var v = spd_load_intermediate(x * 2u + y % 2u, y * 2u);
-        v = spd_reduce_quad(v, subgroup_invocation_id);
+        v = spd_reduce_quad(v);
         if local_invocation_index % 4u == 0u {
             spd_store((workgroup_id * 4u) + vec2(x / 2u, y / 2u), v, base_mip, slice);
             spd_store_intermediate(x * 2u + y / 2u, y * 2u, v);
@@ -224,11 +211,11 @@ fn spd_downsample_mip_3(x: u32, y: u32, workgroup_id: vec2u, local_invocation_in
 #endif
 }
 
-fn spd_downsample_mip_4(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+fn spd_downsample_mip_4(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32) {
 #ifdef SUBGROUP_SUPPORT
     if local_invocation_index < 16u {
         var v = spd_load_intermediate(x * 4u + y, y * 4u);
-        v = spd_reduce_quad(v, subgroup_invocation_id);
+        v = spd_reduce_quad(v);
         if local_invocation_index % 4u == 0u {
             spd_store((workgroup_id * 2u) + vec2(x / 2u, y / 2u), v, base_mip, slice);
             spd_store_intermediate(x / 2u + y, 0u, v);
@@ -248,11 +235,11 @@ fn spd_downsample_mip_4(x: u32, y: u32, workgroup_id: vec2u, local_invocation_in
 #endif
 }
 
-fn spd_downsample_mip_5(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+fn spd_downsample_mip_5(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32) {
 #ifdef SUBGROUP_SUPPORT
     if local_invocation_index < 4u {
         var v = spd_load_intermediate(local_invocation_index, 0u);
-        v = spd_reduce_quad(v, subgroup_invocation_id);
+        v = spd_reduce_quad(v);
         if local_invocation_index % 4u == 0u {
             spd_store(workgroup_id, v, base_mip, slice);
         }
@@ -436,20 +423,12 @@ fn spd_reduce_4(v0: vec4f, v1: vec4f, v2: vec4f, v3: vec4f) -> vec4f {
 }
 
 #ifdef SUBGROUP_SUPPORT
-fn spd_reduce_quad(v: vec4f, subgroup_invocation_id: u32) -> vec4f {
-    let quad = subgroup_invocation_id & (~0x3u);
+fn spd_reduce_quad(v: vec4f) -> vec4f {
     let v0 = v;
-    let v1 = subgroupBroadcast(v, quad | 1u);
-    let v2 = subgroupBroadcast(v, quad | 2u);
-    let v3 = subgroupBroadcast(v, quad | 3u);
+    let v1 = quadSwapX(v);
+    let v2 = quadSwapY(v);
+    let v3 = quadSwapDiagonal(v);
     return spd_reduce_4(v0, v1, v2, v3);
-
-    // TODO: Use subgroup quad operations once wgpu supports them
-    // let v0 = v;
-    // let v1 = quadSwapX(v);
-    // let v2 = quadSwapY(v);
-    // let v3 = quadSwapDiagonal(v);
-    // return spd_reduce_4(v0, v1, v2, v3);
 }
 #endif
 
diff --git a/crates/bevy_pbr/src/meshlet/visibility_buffer_raster_node.rs b/crates/bevy_pbr/src/meshlet/visibility_buffer_raster_node.rs
index 160097fc50070..10104e10eefd9 100644
--- a/crates/bevy_pbr/src/meshlet/visibility_buffer_raster_node.rs
+++ b/crates/bevy_pbr/src/meshlet/visibility_buffer_raster_node.rs
@@ -595,6 +595,7 @@ fn raster_pass(
         }),
         color_attachments: &[Some(RenderPassColorAttachment {
             view: dummy_render_target,
+            depth_slice: None,
             resolve_target: None,
             ops: Operations {
                 load: LoadOp::Clear(LinearRgba::BLACK.into()),
diff --git a/crates/bevy_pbr/src/ssr/mod.rs b/crates/bevy_pbr/src/ssr/mod.rs
index a30f315269ecd..12e7b77f4d34d 100644
--- a/crates/bevy_pbr/src/ssr/mod.rs
+++ b/crates/bevy_pbr/src/ssr/mod.rs
@@ -302,6 +302,7 @@ impl ViewNode for ScreenSpaceReflectionsNode {
             label: Some("SSR pass"),
             color_attachments: &[Some(RenderPassColorAttachment {
                 view: postprocess.destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations::default(),
             })],
diff --git a/crates/bevy_pbr/src/volumetric_fog/render.rs b/crates/bevy_pbr/src/volumetric_fog/render.rs
index a49e9b62a4f78..abd886018b009 100644
--- a/crates/bevy_pbr/src/volumetric_fog/render.rs
+++ b/crates/bevy_pbr/src/volumetric_fog/render.rs
@@ -431,6 +431,7 @@ impl ViewNode for VolumetricFogNode {
                 label: Some("volumetric lighting pass"),
                 color_attachments: &[Some(RenderPassColorAttachment {
                     view: view_target.main_texture_view(),
+                    depth_slice: None,
                     resolve_target: None,
                     ops: Operations {
                         load: LoadOp::Load,
diff --git a/crates/bevy_reflect/Cargo.toml b/crates/bevy_reflect/Cargo.toml
index 8e2d4d0f38c4b..e2fa168b0785c 100644
--- a/crates/bevy_reflect/Cargo.toml
+++ b/crates/bevy_reflect/Cargo.toml
@@ -109,7 +109,7 @@ uuid = { version = "1.13.1", default-features = false, optional = true, features
   "serde",
 ] }
 variadics_please = "1.1"
-wgpu-types = { version = "25", features = [
+wgpu-types = { version = "26", features = [
   "serde",
 ], optional = true, default-features = false }
 
diff --git a/crates/bevy_render/Cargo.toml b/crates/bevy_render/Cargo.toml
index 6c19e48296284..c17d9c26a8dbc 100644
--- a/crates/bevy_render/Cargo.toml
+++ b/crates/bevy_render/Cargo.toml
@@ -91,7 +91,7 @@ codespan-reporting = "0.12.0"
 # It is enabled for now to avoid having to do a significant overhaul of the renderer just for wasm.
 # When the 'atomics' feature is enabled `fragile-send-sync-non-atomic` does nothing
 # and Bevy instead wraps `wgpu` types to verify they are not used off their origin thread.
-wgpu = { version = "25", default-features = false, features = [
+wgpu = { version = "26", default-features = false, features = [
   "wgsl",
   "dx12",
   "metal",
@@ -100,7 +100,7 @@ wgpu = { version = "25", default-features = false, features = [
   "naga-ir",
   "fragile-send-sync-non-atomic-wasm",
 ] }
-naga = { version = "25", features = ["wgsl-in"] }
+naga = { version = "26", features = ["wgsl-in"] }
 bytemuck = { version = "1.5", features = ["derive", "must_cast"] }
 downcast-rs = { version = "2", default-features = false, features = ["std"] }
 thiserror = { version = "2", default-features = false }
diff --git a/crates/bevy_render/src/batching/gpu_preprocessing.rs b/crates/bevy_render/src/batching/gpu_preprocessing.rs
index 2fb0172b219da..c8a0f1817e65c 100644
--- a/crates/bevy_render/src/batching/gpu_preprocessing.rs
+++ b/crates/bevy_render/src/batching/gpu_preprocessing.rs
@@ -1122,10 +1122,10 @@ impl FromWorld for GpuPreprocessingSupport {
             // `max_compute_*` limits to zero, so we arbitrarily pick one as a canary.
             device.limits().max_compute_workgroup_storage_size != 0;
 
-        let downlevel_support = adapter.get_downlevel_capabilities().flags.contains(
-            DownlevelFlags::COMPUTE_SHADERS |
-            DownlevelFlags::VERTEX_AND_INSTANCE_INDEX_RESPECTS_RESPECTIVE_FIRST_VALUE_IN_INDIRECT_DRAW
-        );
+        let downlevel_support = adapter
+            .get_downlevel_capabilities()
+            .flags
+            .contains(DownlevelFlags::COMPUTE_SHADERS);
 
         let max_supported_mode = if device.limits().max_compute_workgroup_size_x == 0
             || is_non_supported_android_device(adapter)
diff --git a/crates/bevy_render/src/diagnostic/tracy_gpu.rs b/crates/bevy_render/src/diagnostic/tracy_gpu.rs
index 7a66db4ea6da4..c429c0ee245af 100644
--- a/crates/bevy_render/src/diagnostic/tracy_gpu.rs
+++ b/crates/bevy_render/src/diagnostic/tracy_gpu.rs
@@ -56,7 +56,7 @@ fn initial_timestamp(device: &RenderDevice, queue: &RenderQueue) -> i64 {
     // Workaround for https://github.com/gfx-rs/wgpu/issues/6406
     // TODO when that bug is fixed, merge these encoders together again
     let mut copy_encoder = device.create_command_encoder(&CommandEncoderDescriptor::default());
-    copy_encoder.copy_buffer_to_buffer(&resolve_buffer, 0, &map_buffer, 0, QUERY_SIZE as _);
+    copy_encoder.copy_buffer_to_buffer(&resolve_buffer, 0, &map_buffer, 0, Some(QUERY_SIZE as _));
     queue.submit([timestamp_encoder.finish(), copy_encoder.finish()]);
 
     map_buffer.slice(..).map_async(MapMode::Read, |_| ());
diff --git a/crates/bevy_render/src/lib.rs b/crates/bevy_render/src/lib.rs
index 994bc35bb3e1e..5c55bd7193b5f 100644
--- a/crates/bevy_render/src/lib.rs
+++ b/crates/bevy_render/src/lib.rs
@@ -360,6 +360,7 @@ impl Plugin for RenderPlugin {
                         let instance = wgpu::Instance::new(&wgpu::InstanceDescriptor {
                             backends,
                             flags: settings.instance_flags,
+                            memory_budget_thresholds: settings.instance_memory_budget_thresholds,
                             backend_options: wgpu::BackendOptions {
                                 gl: wgpu::GlBackendOptions {
                                     gles_minor_version: settings.gles3_minor_version,
diff --git a/crates/bevy_render/src/render_graph/camera_driver_node.rs b/crates/bevy_render/src/render_graph/camera_driver_node.rs
index d18c7d11333eb..714ceec18adf5 100644
--- a/crates/bevy_render/src/render_graph/camera_driver_node.rs
+++ b/crates/bevy_render/src/render_graph/camera_driver_node.rs
@@ -77,6 +77,7 @@ impl Node for CameraDriverNode {
                 label: Some("no_camera_clear_pass"),
                 color_attachments: &[Some(RenderPassColorAttachment {
                     view: swap_chain_texture,
+                    depth_slice: None,
                     resolve_target: None,
                     ops: Operations {
                         load: LoadOp::Clear(clear_color_global.to_linear().into()),
diff --git a/crates/bevy_render/src/render_phase/mod.rs b/crates/bevy_render/src/render_phase/mod.rs
index c58318f654578..fb9433d804e2b 100644
--- a/crates/bevy_render/src/render_phase/mod.rs
+++ b/crates/bevy_render/src/render_phase/mod.rs
@@ -67,12 +67,12 @@ use bevy_ecs::{
     prelude::*,
     system::{lifetimeless::SRes, SystemParamItem},
 };
+use bevy_render::renderer::RenderAdapterInfo;
+pub use bevy_render_macros::ShaderLabel;
 use core::{fmt::Debug, hash::Hash, iter, marker::PhantomData, ops::Range, slice::SliceIndex};
 use smallvec::SmallVec;
 use tracing::warn;
 
-pub use bevy_render_macros::ShaderLabel;
-
 define_label!(
     #[diagnostic::on_unimplemented(
         note = "consider annotating `{Self}` with `#[derive(ShaderLabel)]`"
@@ -658,9 +658,12 @@ where
         let mut draw_functions = draw_functions.write();
 
         let render_device = world.resource::<RenderDevice>();
+        let render_adapter_info = world.resource::<RenderAdapterInfo>();
         let multi_draw_indirect_count_supported = render_device
             .features()
-            .contains(Features::MULTI_DRAW_INDIRECT_COUNT);
+            .contains(Features::MULTI_DRAW_INDIRECT_COUNT)
+            // TODO: https://github.com/gfx-rs/wgpu/issues/7974
+            && !matches!(render_adapter_info.backend, wgpu::Backend::Dx12);
 
         match self.batch_sets {
             BinnedRenderPhaseBatchSets::DynamicUniforms(ref batch_sets) => {
diff --git a/crates/bevy_render/src/render_resource/mod.rs b/crates/bevy_render/src/render_resource/mod.rs
index 30d1821a9abec..d87e6df3149ec 100644
--- a/crates/bevy_render/src/render_resource/mod.rs
+++ b/crates/bevy_render/src/render_resource/mod.rs
@@ -61,7 +61,7 @@ pub use wgpu::{
     TexelCopyBufferInfo, TexelCopyBufferLayout, TexelCopyTextureInfo, TextureAspect,
     TextureDescriptor, TextureDimension, TextureFormat, TextureFormatFeatureFlags,
     TextureFormatFeatures, TextureSampleType, TextureUsages, TextureView as WgpuTextureView,
-    TextureViewDescriptor, TextureViewDimension, Tlas, TlasInstance, TlasPackage, VertexAttribute,
+    TextureViewDescriptor, TextureViewDimension, Tlas, TlasInstance, VertexAttribute,
     VertexBufferLayout as RawVertexBufferLayout, VertexFormat, VertexState as RawVertexState,
     VertexStepMode, COPY_BUFFER_ALIGNMENT,
 };
diff --git a/crates/bevy_render/src/renderer/graph_runner.rs b/crates/bevy_render/src/renderer/graph_runner.rs
index 39f05ca6a85c6..ff2e421982dc7 100644
--- a/crates/bevy_render/src/renderer/graph_runner.rs
+++ b/crates/bevy_render/src/renderer/graph_runner.rs
@@ -68,8 +68,6 @@ impl RenderGraphRunner {
         render_device: RenderDevice,
         mut diagnostics_recorder: Option<DiagnosticsRecorder>,
         queue: &wgpu::Queue,
-        #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
-        adapter: &wgpu::Adapter,
         world: &World,
         finalizer: impl FnOnce(&mut wgpu::CommandEncoder),
     ) -> Result<Option<DiagnosticsRecorder>, RenderGraphRunnerError> {
@@ -77,12 +75,7 @@ impl RenderGraphRunner {
             recorder.begin_frame();
         }
 
-        let mut render_context = RenderContext::new(
-            render_device,
-            #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
-            adapter.get_info(),
-            diagnostics_recorder,
-        );
+        let mut render_context = RenderContext::new(render_device, diagnostics_recorder);
         Self::run_graph(graph, None, &mut render_context, world, &[], None)?;
         finalizer(render_context.command_encoder());
 
diff --git a/crates/bevy_render/src/renderer/mod.rs b/crates/bevy_render/src/renderer/mod.rs
index 5bcc62188d883..d0ccd526e1235 100644
--- a/crates/bevy_render/src/renderer/mod.rs
+++ b/crates/bevy_render/src/renderer/mod.rs
@@ -37,16 +37,12 @@ pub fn render_system(world: &mut World, state: &mut SystemState<Query<Entity, Wi
     let graph = world.resource::<RenderGraph>();
     let render_device = world.resource::<RenderDevice>();
     let render_queue = world.resource::<RenderQueue>();
-    #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
-    let render_adapter = world.resource::<RenderAdapter>();
 
     let res = RenderGraphRunner::run(
         graph,
         render_device.clone(), // TODO: is this clone really necessary?
         diagnostics_recorder,
         &render_queue.0,
-        #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
-        &render_adapter.0,
         world,
         |encoder| {
             crate::view::screenshot::submit_screenshot_commands(world, encoder);
@@ -343,6 +339,15 @@ pub async fn initialize_renderer(
             max_non_sampler_bindings: limits
                 .max_non_sampler_bindings
                 .min(constrained_limits.max_non_sampler_bindings),
+            max_blas_primitive_count: limits
+                .max_blas_primitive_count
+                .min(constrained_limits.max_blas_primitive_count),
+            max_blas_geometry_count: limits
+                .max_blas_geometry_count
+                .min(constrained_limits.max_blas_geometry_count),
+            max_tlas_instance_count: limits
+                .max_tlas_instance_count
+                .min(constrained_limits.max_tlas_instance_count),
             max_color_attachments: limits
                 .max_color_attachments
                 .min(constrained_limits.max_color_attachments),
@@ -355,6 +360,7 @@ pub async fn initialize_renderer(
             max_subgroup_size: limits
                 .max_subgroup_size
                 .min(constrained_limits.max_subgroup_size),
+            max_acceleration_structures_per_shader_stage: 0,
         };
     }
 
@@ -387,8 +393,6 @@ pub struct RenderContext<'w> {
     render_device: RenderDevice,
     command_encoder: Option<CommandEncoder>,
     command_buffer_queue: Vec<QueuedCommandBuffer<'w>>,
-    #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
-    force_serial: bool,
     diagnostics_recorder: Option<Arc<DiagnosticsRecorder>>,
 }
 
@@ -396,30 +400,12 @@ impl<'w> RenderContext<'w> {
     /// Creates a new [`RenderContext`] from a [`RenderDevice`].
     pub fn new(
         render_device: RenderDevice,
-        #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
-        adapter_info: AdapterInfo,
         diagnostics_recorder: Option<DiagnosticsRecorder>,
     ) -> Self {
-        // HACK: Parallel command encoding is currently bugged on AMD + Windows/Linux + Vulkan
-        #[cfg(any(target_os = "windows", target_os = "linux"))]
-        let force_serial =
-            adapter_info.driver.contains("AMD") && adapter_info.backend == wgpu::Backend::Vulkan;
-        #[cfg(not(any(
-            target_os = "windows",
-            target_os = "linux",
-            all(target_arch = "wasm32", target_feature = "atomics")
-        )))]
-        let force_serial = {
-            drop(adapter_info);
-            false
-        };
-
         Self {
             render_device,
             command_encoder: None,
             command_buffer_queue: Vec::new(),
-            #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
-            force_serial,
             diagnostics_recorder: diagnostics_recorder.map(Arc::new),
         }
     }
@@ -522,14 +508,9 @@ impl<'w> RenderContext<'w> {
                         }
                         QueuedCommandBuffer::Task(command_buffer_generation_task) => {
                             let render_device = self.render_device.clone();
-                            if self.force_serial {
-                                command_buffers
-                                    .push((i, command_buffer_generation_task(render_device)));
-                            } else {
-                                task_pool.spawn(async move {
-                                    (i, command_buffer_generation_task(render_device))
-                                });
-                            }
+                            task_pool.spawn(async move {
+                                (i, command_buffer_generation_task(render_device))
+                            });
                         }
                     }
                 }
diff --git a/crates/bevy_render/src/settings.rs b/crates/bevy_render/src/settings.rs
index d4456953af6ce..411a21ceeb0bc 100644
--- a/crates/bevy_render/src/settings.rs
+++ b/crates/bevy_render/src/settings.rs
@@ -3,11 +3,11 @@ use crate::renderer::{
 };
 use alloc::borrow::Cow;
 
-use wgpu::DxcShaderModel;
 pub use wgpu::{
     Backends, Dx12Compiler, Features as WgpuFeatures, Gles3MinorVersion, InstanceFlags,
     Limits as WgpuLimits, MemoryHints, PowerPreference,
 };
+use wgpu::{DxcShaderModel, MemoryBudgetThresholds};
 
 /// Configures the priority used when automatically configuring the features/limits of `wgpu`.
 #[derive(Clone)]
@@ -53,6 +53,8 @@ pub struct WgpuSettings {
     pub instance_flags: InstanceFlags,
     /// This hints to the WGPU device about the preferred memory allocation strategy.
     pub memory_hints: MemoryHints,
+    /// The thresholds for device memory budget.
+    pub instance_memory_budget_thresholds: MemoryBudgetThresholds,
     /// If true, will force wgpu to use a software renderer, if available.
     pub force_fallback_adapter: bool,
     /// The name of the adapter to use.
@@ -107,15 +109,10 @@ impl Default for WgpuSettings {
                 Dx12Compiler::StaticDxc
             } else {
                 let dxc = "dxcompiler.dll";
-                let dxil = "dxil.dll";
 
-                if cfg!(target_os = "windows")
-                    && std::fs::metadata(dxc).is_ok()
-                    && std::fs::metadata(dxil).is_ok()
-                {
+                if cfg!(target_os = "windows") && std::fs::metadata(dxc).is_ok() {
                     Dx12Compiler::DynamicDxc {
                         dxc_path: String::from(dxc),
-                        dxil_path: String::from(dxil),
                         max_shader_model: DxcShaderModel::V6_7,
                     }
                 } else {
@@ -140,6 +137,7 @@ impl Default for WgpuSettings {
             gles3_minor_version,
             instance_flags,
             memory_hints: MemoryHints::default(),
+            instance_memory_budget_thresholds: MemoryBudgetThresholds::default(),
             force_fallback_adapter: false,
             adapter_name: None,
         }
diff --git a/crates/bevy_render/src/texture/texture_attachment.rs b/crates/bevy_render/src/texture/texture_attachment.rs
index ac3854227ff31..17ae6ea6c957f 100644
--- a/crates/bevy_render/src/texture/texture_attachment.rs
+++ b/crates/bevy_render/src/texture/texture_attachment.rs
@@ -40,6 +40,7 @@ impl ColorAttachment {
 
             RenderPassColorAttachment {
                 view: &resolve_target.default_view,
+                depth_slice: None,
                 resolve_target: Some(&self.texture.default_view),
                 ops: Operations {
                     load: match (self.clear_color, first_call) {
@@ -63,6 +64,7 @@ impl ColorAttachment {
 
         RenderPassColorAttachment {
             view: &self.texture.default_view,
+            depth_slice: None,
             resolve_target: None,
             ops: Operations {
                 load: match (self.clear_color, first_call) {
@@ -146,6 +148,7 @@ impl OutputColorAttachment {
 
         RenderPassColorAttachment {
             view: &self.view,
+            depth_slice: None,
             resolve_target: None,
             ops: Operations {
                 load: match (clear_color, first_call) {
diff --git a/crates/bevy_render/src/view/window/screenshot.rs b/crates/bevy_render/src/view/window/screenshot.rs
index 986f6927e5d12..a3ac1d47e0dea 100644
--- a/crates/bevy_render/src/view/window/screenshot.rs
+++ b/crates/bevy_render/src/view/window/screenshot.rs
@@ -595,6 +595,7 @@ fn render_screenshot(
                 label: Some("screenshot_to_screen_pass"),
                 color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                     view: texture_view,
+                    depth_slice: None,
                     resolve_target: None,
                     ops: wgpu::Operations {
                         load: wgpu::LoadOp::Load,
diff --git a/crates/bevy_shader/Cargo.toml b/crates/bevy_shader/Cargo.toml
index d89bc0ec77734..f5df411739f35 100644
--- a/crates/bevy_shader/Cargo.toml
+++ b/crates/bevy_shader/Cargo.toml
@@ -16,8 +16,8 @@ bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
 bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev" }
 
 # other
-wgpu-types = { version = "25", default-features = false }
-naga = { version = "25", features = ["wgsl-in"] }
+wgpu-types = { version = "26", default-features = false }
+naga = { version = "26", features = ["wgsl-in"] }
 serde = { version = "1", features = ["derive"] }
 thiserror = { version = "2", default-features = false }
 wesl = { version = "0.1.2", optional = true }
@@ -26,12 +26,12 @@ tracing = { version = "0.1", default-features = false, features = ["std"] }
 
 [target.'cfg(not(target_arch = "wasm32"))'.dependencies]
 # Omit the `glsl` feature in non-WebAssembly by default.
-naga_oil = { version = "0.18", default-features = false, features = [
+naga_oil = { version = "0.19", default-features = false, features = [
   "test_shader",
 ] }
 
 [target.'cfg(target_arch = "wasm32")'.dependencies]
-naga_oil = { version = "0.18" }
+naga_oil = { version = "0.19" }
 
 [features]
 shader_format_glsl = ["naga/glsl-in", "naga/wgsl-out", "naga_oil/glsl"]
diff --git a/crates/bevy_shader/src/shader_cache.rs b/crates/bevy_shader/src/shader_cache.rs
index 89926c856ce0b..5974209cb522e 100644
--- a/crates/bevy_shader/src/shader_cache.rs
+++ b/crates/bevy_shader/src/shader_cache.rs
@@ -506,6 +506,10 @@ fn get_capabilities(features: Features, downlevel: DownlevelFlags) -> Capabiliti
         Capabilities::DUAL_SOURCE_BLENDING,
         features.contains(Features::DUAL_SOURCE_BLENDING),
     );
+    capabilities.set(
+        Capabilities::CLIP_DISTANCE,
+        features.contains(Features::CLIP_DISTANCES),
+    );
     capabilities.set(
         Capabilities::CUBE_ARRAY_TEXTURES,
         downlevel.contains(DownlevelFlags::CUBE_ARRAY_TEXTURES),
diff --git a/crates/bevy_solari/src/scene/binder.rs b/crates/bevy_solari/src/scene/binder.rs
index 81923592cde18..124d5d05dc2fc 100644
--- a/crates/bevy_solari/src/scene/binder.rs
+++ b/crates/bevy_solari/src/scene/binder.rs
@@ -71,14 +71,14 @@ pub fn prepare_raytracing_scene_bindings(
     let mut textures = CachedBindingArray::new();
     let mut samplers = Vec::new();
     let mut materials = StorageBufferList::<GpuMaterial>::default();
-    let mut tlas = TlasPackage::new(render_device.wgpu_device().create_tlas(
-        &CreateTlasDescriptor {
+    let mut tlas = render_device
+        .wgpu_device()
+        .create_tlas(&CreateTlasDescriptor {
             label: Some("tlas"),
             flags: AccelerationStructureFlags::PREFER_FAST_TRACE,
             update_mode: AccelerationStructureUpdateMode::Build,
             max_instances: instances_query.iter().len() as u32,
-        },
-    ));
+        });
     let mut transforms = StorageBufferList::<Mat4>::default();
     let mut geometry_ids = StorageBufferList::<GpuInstanceGeometryIds>::default();
     let mut material_ids = StorageBufferList::<u32>::default();
diff --git a/crates/bevy_winit/Cargo.toml b/crates/bevy_winit/Cargo.toml
index 0ca907be8e1b0..69e9ffb3c7cc7 100644
--- a/crates/bevy_winit/Cargo.toml
+++ b/crates/bevy_winit/Cargo.toml
@@ -56,7 +56,7 @@ approx = { version = "0.5", default-features = false }
 cfg-if = "1.0"
 raw-window-handle = "0.6"
 bytemuck = { version = "1.5", optional = true }
-wgpu-types = { version = "25", optional = true }
+wgpu-types = { version = "26", optional = true }
 accesskit = "0.21"
 tracing = { version = "0.1", default-features = false, features = ["std"] }
 
diff --git a/examples/shader/custom_post_processing.rs b/examples/shader/custom_post_processing.rs
index 4cd925be01d82..806a84378535f 100644
--- a/examples/shader/custom_post_processing.rs
+++ b/examples/shader/custom_post_processing.rs
@@ -197,6 +197,7 @@ impl ViewNode for PostProcessNode {
                 // We need to specify the post process destination view here
                 // to make sure we write to the appropriate texture.
                 view: post_process.destination,
+                depth_slice: None,
                 resolve_target: None,
                 ops: Operations::default(),
             })],
