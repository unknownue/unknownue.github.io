<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20406 Solari radiance cache
        
    </title><meta content="#20406 Solari radiance cache" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-08/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-08-09</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-08/pr-20406-zh-cn-20250809>中文</a></div></div><div class=pr-content><h1 id=solari-radiance-cache>Solari Radiance Cache</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari radiance cache<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20406<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, D-Complex<li><strong>Created</strong>: 2025-08-04T02:49:54Z<li><strong>Merged</strong>: 2025-08-09T22:53:03Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Make GI pass cheaper<li>Improve GI quality after disocclusions<li>Have multibounce GI instead of the current single bounce</ul><h2 id=solution>Solution</h2><ul><li>Add a persistent world cache based on spatial hashing<li>Each hash key is a combination of position, normal, and cell size, where the cell size is based on the distance from the camera</ul><ol><li>Each entry/cell in the cache has a “life” counter. It starts at 30, and the first pass each frame decrements each entry by 1. When it reaches 0, the entry is deallocated.<li>Passes 2-4 compact and write a list of the active cells (life != 0) in the cache via parallel prefix sum<li>Pass 5 samples lighting for each cache cell (direct via light sampling, indirect via BRDF sampling and querying the cache at hit points)<li>Pass 6 blends the new radiance into the existing cell’s radiance. Unlike ReSTIR/RIS we are <em>not</em> storing a single light sample/path. We are instead storing radiance.<li>The ReSTIR GI pass is basically the same, except at the sample point, instead of sampling direct lighting via another raytrace, it instead queries the world cache. Querying a cache cell resets its life to 30.</ol><h2 id=issues>Issues</h2><ul><li>Querying an empty cache cell initializes the position/normal used for sampling lighting for the cell to the values used in the query. This means that each cache entry has a fixed sample point to represent the entire volume, which can sometimes lead to problems if the chosen sample point poorly represents the volume.<li>When transitioning LODs, cells start out as empty rather than initializing themselves via querying adjacent LOD levels. Not a huge problem in practice though, at least in the cornell box I was hard pressed to notice this as ReSTIR GI temporal reservoirs hide the issue. Yay for two level caching!<li>I’m not entirely sure that cache entries will ever die in larger worlds. The cache can keep itself alive since cells can query each other (resetting their life to 30) when updating cells. Probably need to think about how to handle larger scenes.<li>Worse stability in larger scenes like bistro. The jacobian leads to temporal bright spots with ReSTIR GI more often than not using the cache, and the cache itself can be very unstable. Might need some form of ReSTIR in the cache, like https://wangningbei.github.io/2023/ReSTIR_files/paper_ReSTIRGI.pdf. (EDIT: Added RIS which helps a ton. ReSTIR might be desirable for better responsiveness though)<li>Lots more tweaking of hashing stuff possible.<li>Like the rest of Solari, I haven’t done any testing of dynamic content yet. Gotta get static content working first :)<li>The pipeline setup code for Solari has gotten super messy. Ideas on how to fix it are welcome.</ul><hr><h2 id=showcase>Showcase</h2><img alt=image height=1500 src=https://github.com/user-attachments/assets/5d143dc0-10de-427c-901c-e02ce1d145ab width=2564><img alt=image height=1500 src=https://github.com/user-attachments/assets/94dff25e-c858-4c27-8466-15bc8be1c405 width=2564><img alt=image height=1500 src=https://github.com/user-attachments/assets/178d10e7-2391-4a79-816e-b633da7e2b42 width=2564><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=problem-and-context>Problem and Context</h3><p>The Solari real-time global illumination system faced performance challenges with its GI pass and limitations with single-bounce lighting. The existing ReSTIR GI implementation required expensive direct lighting ray traces at each sample point. Additionally, the system only supported single-bounce indirect lighting, limiting lighting realism. The goals were to reduce GI pass cost, improve quality during disocclusions, and enable multibounce GI.<h3 id=solution-approach>Solution Approach</h3><p>The solution introduces a persistent radiance cache using spatial hashing. Cache entries are keyed by position, normal, and adaptive cell size based on camera distance. The cache lifecycle management involves:<ol><li>Life counters that decrement each frame and deallocate stale entries<li>Compaction passes that identify active cells<li>Lighting sampling passes that compute direct/indirect radiance<li>Blending passes that integrate new samples into the cache</ol><p>The ReSTIR GI pass was modified to query this cache instead of performing direct lighting ray traces. RIS (Resampled Importance Sampling) was added to improve stability in complex scenes.<h3 id=implementation-details>Implementation Details</h3><p>The implementation added several key components:<ul><li>A spatial hash grid with 2²⁰ entries<li>Life management with automatic entry expiration<li>Radiance storage with temporal blending<li>Multibounce support through recursive cache queries</ul><p>The cache uses quantized positions and normals for hashing:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn quantize_position(world_position: vec3&LTf32>, view_position: vec3&LTf32>) -> vec3&LTf32> {
</span><span>    let base_size = WORLD_CACHE_POSITION_BASE_CELL_SIZE;
</span><span>    let d = distance(view_position, world_position);
</span><span>    let step = max((d * base_size) / 7.0, base_size);
</span><span>    let quantization_factor = exp2(floor(log2(step)));
</span><span>    return floor(world_position / quantization_factor + 0.0001);
</span><span>}
</span></code></pre><p>Cache queries reset cell lifetimes and initialize empty cells:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>if existing_checksum == checksum {
</span><span>    atomicStore(&world_cache_life[key], WORLD_CACHE_CELL_LIFETIME);
</span><span>    return world_cache_radiance[key].rgb;
</span><span>} else if existing_checksum == WORLD_CACHE_EMPTY_CELL {
</span><span>    atomicStore(&world_cache_life[key], WORLD_CACHE_CELL_LIFETIME);
</span><span>    world_cache_geometry_data[key].world_position = world_position;
</span><span>    world_cache_geometry_data[key].world_normal = world_normal;
</span><span>    return vec3(0.0);
</span><span>}
</span></code></pre><p>The lighting sampling pass uses RIS for better stability:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn sample_random_light_ris(world_position: vec3&LTf32>, world_normal: vec3&LTf32>, workgroup_id: vec2&LTu32>, rng: ptr&LTfunction, u32>) -> vec3&LTf32> {
</span><span>    // RIS implementation with 32 samples
</span><span>    // ...
</span><span>}
</span></code></pre><h3 id=technical-insights>Technical Insights</h3><p>The cache uses several innovative techniques:<ul><li><strong>Adaptive cell sizing</strong>: Cell size increases with distance from camera (LOD)<li><strong>Temporal blending</strong>: New samples are integrated using moving average<li><strong>Multibounce support</strong>: Secondary rays query the cache recursively<li><strong>Life management</strong>: Unused entries expire after 30 frames</ul><p>The implementation faces challenges with:<ul><li>Representative sample points for cache cells<li>LOD transition artifacts<li>Cache immortality in large scenes<li>Stability in complex scenes like bistro</ul><h3 id=impact>Impact</h3><p>The radiance cache provides:<ul><li><strong>Performance gains</strong>: GI pass avoids expensive direct lighting traces<li><strong>Quality improvements</strong>: Better disocclusion handling and multibounce GI<li><strong>Memory efficiency</strong>: Automatic expiration of unused cache entries<li><strong>Foundation for future work</strong>: Basis for more advanced caching techniques</ul><p>The solution demonstrates how spatial hashing and temporal caching can significantly enhance real-time GI systems while maintaining interactive frame rates.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Decay Cache Life] --> B[Compact Cache - Single Block]
</span><span>    B --> C[Compact Cache - Blocks]
</span><span>    C --> D[Write Active Cells]
</span><span>    D --> E[Sample Radiance]
</span><span>    E --> F[Blend Samples]
</span><span>    F --> G[Presample Light Tiles]
</span><span>    G --> H[ReSTIR DI Passes]
</span><span>    H --> I[ReSTIR GI Passes]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-node-rs-197-39><code>crates/bevy_solari/src/realtime/node.rs</code> (+197/-39)</h3><p>Added compute pipelines for cache management passes and integrated them into the rendering graph. Modified existing pipelines to include push constants.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Added new pipeline creation
</span><span>decay_world_cache_pipeline</span><span style=color:#61676ccc>: </span><span style=color:#f07171>create_pipeline</span><span>(
</span><span>    </span><span style=color:#86b300>"solari_lighting_decay_world_cache_pipeline"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"decay_world_cache"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#f07171>load_embedded_asset!</span><span>(world</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"world_cache_compact.wgsl"</span><span>)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ed9366>&</span><span>bind_group_layout_world_cache_active_cells_dispatch)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#f07171>vec!</span><span>[</span><span style=color:#86b300>"WORLD_CACHE_NON_ATOMIC_LIFE_BUFFER"</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()]</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>,
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-query-wgsl-114-0><code>crates/bevy_solari/src/realtime/world_cache_query.wgsl</code> (+114/-0)</h3><p>Defined cache structures, hash functions, and query logic. Implemented spatial hashing with position/normal quantization.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn compute_key(world_position: vec3&LTu32>, world_normal: vec3&LTu32>) -> u32 {
</span><span>    var key = pcg_hash(world_position.x);
</span><span>    key = pcg_hash(key + world_position.y);
</span><span>    key = pcg_hash(key + world_position.z);
</span><span>    key = pcg_hash(key + world_normal.x);
</span><span>    key = pcg_hash(key + world_normal.y);
</span><span>    key = pcg_hash(key + world_normal.z);
</span><span>    return wrap_key(key);
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-update-wgsl-98-0><code>crates/bevy_solari/src/realtime/world_cache_update.wgsl</code> (+98/-0)</h3><p>Implemented radiance sampling and blending. Added multibounce support through secondary rays.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>@compute @workgroup_size(1024, 1, 1)
</span><span>fn blend_new_samples(@builtin(global_invocation_id) active_cell_id: vec3&LTu32>) {
</span><span>    if active_cell_id.x < world_cache_active_cells_count {
</span><span>        let cell_index = world_cache_active_cell_indices[active_cell_id.x];
</span><span>        let old_radiance = world_cache_radiance[cell_index];
</span><span>        let new_radiance = world_cache_active_cells_new_radiance[active_cell_id.x];
</span><span>        let sample_count = min(old_radiance.a + 1.0, WORLD_CACHE_MAX_TEMPORAL_SAMPLES);
</span><span>        let blended_radiance = mix(old_radiance.rgb, new_radiance, 1.0 / sample_count);
</span><span>        world_cache_radiance[cell_index] = vec4(blended_radiance, sample_count);
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-prepare-rs-93-0><code>crates/bevy_solari/src/realtime/prepare.rs</code> (+93/-0)</h3><p>Created buffers for cache storage and management. Added buffers for checksums, life counters, radiance, and active cells.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> world_cache_checksums </span><span style=color:#ed9366>=</span><span> render_device</span><span style=color:#ed9366>.</span><span style=color:#f07171>create_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>BufferDescriptor {
</span><span>    label</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#86b300>"solari_lighting_world_cache_checksums"</span><span>)</span><span style=color:#61676ccc>,
</span><span>    size</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>WORLD_CACHE_SIZE </span><span style=color:#ed9366>* </span><span>size_of</span><span style=color:#ed9366>::</span><span><</span><span style=color:#fa6e32>u32</span><span>>() </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u64</span><span style=color:#61676ccc>,
</span><span>    usage</span><span style=color:#61676ccc>: </span><span>BufferUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>STORAGE</span><span style=color:#61676ccc>,
</span><span>    mapped_at_creation</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-compact-wgsl-70-0><code>crates/bevy_solari/src/realtime/world_cache_compact.wgsl</code> (+70/-0)</h3><p>Implemented cache decay and compaction using parallel prefix sum. Handles active cell list generation.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>@compute @workgroup_size(1024, 1, 1)
</span><span>fn decay_world_cache(@builtin(global_invocation_id) global_id: vec3&LTu32>) {
</span><span>    var life = world_cache_life[global_id.x];
</span><span>    if life > 0u {
</span><span>        life -= 1u;
</span><span>        world_cache_life[global_id.x] = life;
</span><span>        if life == 0u {
</span><span>            world_cache_checksums[global_id.x] = WORLD_CACHE_EMPTY_CELL;
</span><span>            world_cache_radiance[global_id.x] = vec4(0.0);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://wangningbei.github.io/2023/ReSTIR_files/paper_ReSTIRGI.pdf target=_blank>ReSTIR GI Paper</a> - Advanced caching techniques<li>Spatial Hashing Techniques - For understanding the underlying data structure<li>Temporal Filtering Methods - For radiance blending approaches<li>Parallel Prefix Sum Algorithms - For compaction implementation details</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-08/pr_20406.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>