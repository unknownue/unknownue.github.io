diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index 3f3e75c37f700..bf520223af5b8 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -1086,6 +1086,13 @@ impl<'w, 's> Commands<'w, 's> {
     /// Sends a global [`Event`] without any targets.
     ///
     /// This will run any [`Observer`] of the given [`Event`] that isn't scoped to specific targets.
+    ///
+    /// If the entity that this command targets does not exist when the command is applied,
+    /// the command will fail, possibly causing it to panic based on the default [error handler](crate::error) set.
+    ///
+    /// To queue this command with a specific handler, use [`EntityCommands::queue_handled`]
+    /// with [`entity_command::trigger(event)`](entity_command::trigger).
+    /// [`EntityCommands::queue_silenced`] may also be used to ignore the error completely.
     #[track_caller]
     pub fn trigger(&mut self, event: impl Event) {
         self.queue(command::trigger(event));
@@ -1094,6 +1101,13 @@ impl<'w, 's> Commands<'w, 's> {
     /// Sends an [`EntityEvent`] for the given targets.
     ///
     /// This will run any [`Observer`] of the given [`EntityEvent`] watching those targets.
+    ///
+    /// If the entity that this command targets does not exist when the command is applied,
+    /// the command will fail, possibly causing it to panic based on the default [error handler](crate::error) set.
+    ///
+    /// To queue this command with a specific handler, use [`EntityCommands::queue_handled`]
+    /// with [`entity_command::trigger(event)`](entity_command::trigger).
+    /// [`EntityCommands::queue_silenced`] may also be used to ignore the error completely.
     #[track_caller]
     pub fn trigger_targets(
         &mut self,
@@ -1994,6 +2008,12 @@ impl<'a> EntityCommands<'a> {
     /// Sends an [`EntityEvent`] targeting the entity.
     ///
     /// This will run any [`Observer`] of the given [`EntityEvent`] watching this entity.
+    ///
+    /// If the entity that this command targets does not exist when the command is applied,
+    /// the command will fail, possibly causing it to panic based on the default error handler set.
+    /// To queue this command with a handler, use [`EntityCommands::queue_handled`]
+    /// with [`entity_command::trigger(event)`](entity_command::trigger).
+    /// [`EntityCommands::queue_silenced`] may also be used to ignore the error completely.
     #[track_caller]
     pub fn trigger(&mut self, event: impl EntityEvent) -> &mut Self {
         self.queue(entity_command::trigger(event))
diff --git a/crates/bevy_ecs/src/world/error.rs b/crates/bevy_ecs/src/world/error.rs
index 03574331f2329..49a904e201005 100644
--- a/crates/bevy_ecs/src/world/error.rs
+++ b/crates/bevy_ecs/src/world/error.rs
@@ -50,7 +50,11 @@ pub enum EntityComponentError {
 #[derive(thiserror::Error, Debug, Clone, Copy, PartialEq, Eq)]
 pub enum EntityMutableFetchError {
     /// The entity with the given ID does not exist.
-    #[error(transparent)]
+    #[error(
+        "{0}\n
+    If you were attempting to apply a command to this entity,
+    and want to handle this error gracefully, consider using `EntityCommands::queue_handled` or `queue_silenced`."
+    )]
     EntityDoesNotExist(#[from] EntityDoesNotExistError),
     /// The entity with the given ID was requested mutably more than once.
     #[error("The entity with ID {0} was requested mutably more than once")]
@@ -70,3 +74,50 @@ pub enum ResourceFetchError {
     #[error("Cannot get access to the resource with ID {0:?} in the world as it conflicts with an on going operation.")]
     NoResourceAccess(ComponentId),
 }
+
+#[cfg(test)]
+mod tests {
+    use crate::{
+        prelude::*,
+        system::{entity_command::trigger, RunSystemOnce},
+    };
+
+    // Inspired by https://github.com/bevyengine/bevy/issues/19623
+    #[test]
+    fn fixing_panicking_entity_commands() {
+        #[derive(EntityEvent)]
+        struct Kill;
+
+        #[derive(EntityEvent)]
+        struct FollowupEvent;
+
+        fn despawn(trigger: On<Kill>, mut commands: Commands) {
+            commands.entity(trigger.target()).despawn();
+        }
+
+        fn followup(on: On<Kill>, mut commands: Commands) {
+            // When using a simple .trigger() here, this panics because the entity has already been despawned.
+            // Instead, we need to use `.queue_handled` or `.queue_silenced` to avoid the panic.
+            commands
+                .entity(on.target())
+                .queue_silenced(trigger(FollowupEvent));
+        }
+
+        let mut world = World::new();
+        // This test would pass if the order of these statements were swapped,
+        // even with panicking entity commands
+        world.add_observer(followup);
+        world.add_observer(despawn);
+
+        // Create an entity to test these observers with
+        world.spawn_empty();
+
+        // Trigger a kill event on the entity
+        fn kill_everything(mut commands: Commands, query: Query<Entity>) {
+            for id in query.iter() {
+                commands.entity(id).trigger(Kill);
+            }
+        }
+        world.run_system_once(kill_everything).unwrap();
+    }
+}
