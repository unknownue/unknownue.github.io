diff --git a/crates/bevy_anti_aliasing/src/fxaa/mod.rs b/crates/bevy_anti_aliasing/src/fxaa/mod.rs
index 7bb71d1f1e88b..69b26ffa8abc7 100644
--- a/crates/bevy_anti_aliasing/src/fxaa/mod.rs
+++ b/crates/bevy_anti_aliasing/src/fxaa/mod.rs
@@ -50,7 +50,7 @@ impl Sensitivity {
 }
 
 /// A component for enabling Fast Approximate Anti-Aliasing (FXAA)
-/// for a [`bevy_render::camera::Camera`].
+/// for a [`bevy_camera::Camera`].
 #[derive(Reflect, Component, Clone, ExtractComponent)]
 #[reflect(Component, Default, Clone)]
 #[extract_component_filter(With<Camera>)]
diff --git a/crates/bevy_anti_aliasing/src/smaa/mod.rs b/crates/bevy_anti_aliasing/src/smaa/mod.rs
index cf875252ad06e..3a65f6ce6c593 100644
--- a/crates/bevy_anti_aliasing/src/smaa/mod.rs
+++ b/crates/bevy_anti_aliasing/src/smaa/mod.rs
@@ -11,7 +11,7 @@
 //! which have made SMAA less popular when advanced photorealistic rendering
 //! features are used in recent years.
 //!
-//! To use SMAA, add [`Smaa`] to a [`bevy_render::camera::Camera`]. In a
+//! To use SMAA, add [`Smaa`] to a [`bevy_camera::Camera`]. In a
 //! pinch, you can simply use the default settings (via the [`Default`] trait)
 //! for a high-quality, high-performance appearance. When using SMAA, you will
 //! likely want set [`bevy_render::view::Msaa`] to [`bevy_render::view::Msaa::Off`]
@@ -83,7 +83,7 @@ use bevy_utils::prelude::default;
 pub struct SmaaPlugin;
 
 /// A component for enabling Subpixel Morphological Anti-Aliasing (SMAA)
-/// for a [`bevy_render::camera::Camera`].
+/// for a [`bevy_camera::Camera`].
 #[derive(Clone, Copy, Default, Component, Reflect, ExtractComponent)]
 #[reflect(Component, Default, Clone)]
 #[doc(alias = "SubpixelMorphologicalAntiAliasing")]
diff --git a/crates/bevy_anti_aliasing/src/taa/mod.rs b/crates/bevy_anti_aliasing/src/taa/mod.rs
index 570a182aa9748..fa477daf42472 100644
--- a/crates/bevy_anti_aliasing/src/taa/mod.rs
+++ b/crates/bevy_anti_aliasing/src/taa/mod.rs
@@ -108,7 +108,7 @@ impl Plugin for TemporalAntiAliasPlugin {
 ///
 /// Any camera with this component must also disable [`Msaa`] by setting it to [`Msaa::Off`].
 ///
-/// [Currently](https://github.com/bevyengine/bevy/issues/8423), TAA cannot be used with [`bevy_render::camera::OrthographicProjection`].
+/// [Currently](https://github.com/bevyengine/bevy/issues/8423), TAA cannot be used with [`bevy_camera::OrthographicProjection`].
 ///
 /// TAA also does not work well with alpha-blended meshes, as it requires depth writing to determine motion.
 ///
diff --git a/crates/bevy_core_pipeline/src/dof/mod.rs b/crates/bevy_core_pipeline/src/dof/mod.rs
index 5d2678f4f3125..7f6a84beccae6 100644
--- a/crates/bevy_core_pipeline/src/dof/mod.rs
+++ b/crates/bevy_core_pipeline/src/dof/mod.rs
@@ -491,7 +491,7 @@ impl DepthOfField {
     /// [`PhysicalCameraParameters`].
     ///
     /// By passing the same [`PhysicalCameraParameters`] object to this function
-    /// and to [`bevy_render::camera::Exposure::from_physical_camera`], matching
+    /// and to [`bevy_camera::Exposure::from_physical_camera`], matching
     /// results for both the exposure and depth of field effects can be
     /// obtained.
     ///
diff --git a/crates/bevy_core_pipeline/src/msaa_writeback.rs b/crates/bevy_core_pipeline/src/msaa_writeback.rs
index f1a833047fbb1..15f5a03c5ac6b 100644
--- a/crates/bevy_core_pipeline/src/msaa_writeback.rs
+++ b/crates/bevy_core_pipeline/src/msaa_writeback.rs
@@ -17,7 +17,7 @@ use bevy_render::{
 };
 
 /// This enables "msaa writeback" support for the `core_2d` and `core_3d` pipelines, which can be enabled on cameras
-/// using [`bevy_render::camera::Camera::msaa_writeback`]. See the docs on that field for more information.
+/// using [`bevy_camera::Camera::msaa_writeback`]. See the docs on that field for more information.
 pub struct MsaaWritebackPlugin;
 
 impl Plugin for MsaaWritebackPlugin {
diff --git a/crates/bevy_core_pipeline/src/prepass/mod.rs b/crates/bevy_core_pipeline/src/prepass/mod.rs
index 880e2b6892163..89b09c88b3f09 100644
--- a/crates/bevy_core_pipeline/src/prepass/mod.rs
+++ b/crates/bevy_core_pipeline/src/prepass/mod.rs
@@ -3,7 +3,7 @@
 //!
 //! The prepass only runs for opaque meshes or meshes with an alpha mask. Transparent meshes are ignored.
 //!
-//! To enable the prepass, you need to add a prepass component to a [`crate::prelude::Camera3d`].
+//! To enable the prepass, you need to add a prepass component to a [`bevy_camera::Camera3d`].
 //!
 //! [`DepthPrepass`]
 //! [`NormalPrepass`]
@@ -52,23 +52,23 @@ use bevy_render::{
 pub const NORMAL_PREPASS_FORMAT: TextureFormat = TextureFormat::Rgb10a2Unorm;
 pub const MOTION_VECTOR_PREPASS_FORMAT: TextureFormat = TextureFormat::Rg16Float;
 
-/// If added to a [`crate::prelude::Camera3d`] then depth values will be copied to a separate texture available to the main pass.
+/// If added to a [`bevy_camera::Camera3d`] then depth values will be copied to a separate texture available to the main pass.
 #[derive(Component, Default, Reflect, Clone)]
 #[reflect(Component, Default, Clone)]
 pub struct DepthPrepass;
 
-/// If added to a [`crate::prelude::Camera3d`] then vertex world normals will be copied to a separate texture available to the main pass.
+/// If added to a [`bevy_camera::Camera3d`] then vertex world normals will be copied to a separate texture available to the main pass.
 /// Normals will have normal map textures already applied.
 #[derive(Component, Default, Reflect, Clone)]
 #[reflect(Component, Default, Clone)]
 pub struct NormalPrepass;
 
-/// If added to a [`crate::prelude::Camera3d`] then screen space motion vectors will be copied to a separate texture available to the main pass.
+/// If added to a [`bevy_camera::Camera3d`] then screen space motion vectors will be copied to a separate texture available to the main pass.
 #[derive(Component, Default, Reflect, Clone)]
 #[reflect(Component, Default, Clone)]
 pub struct MotionVectorPrepass;
 
-/// If added to a [`crate::prelude::Camera3d`] then deferred materials will be rendered to the deferred gbuffer texture and will be available to subsequent passes.
+/// If added to a [`bevy_camera::Camera3d`] then deferred materials will be rendered to the deferred gbuffer texture and will be available to subsequent passes.
 /// Note the default deferred lighting plugin also requires `DepthPrepass` to work correctly.
 #[derive(Component, Default, Reflect)]
 #[reflect(Component, Default)]
diff --git a/crates/bevy_mesh/src/components.rs b/crates/bevy_mesh/src/components.rs
index cff5eab7e477f..b175be5f86903 100644
--- a/crates/bevy_mesh/src/components.rs
+++ b/crates/bevy_mesh/src/components.rs
@@ -18,9 +18,9 @@ use derive_more::derive::From;
 /// # Example
 ///
 /// ```ignore
-/// # use bevy_sprite::{ColorMaterial, Mesh2d, MeshMaterial2d};
+/// # use bevy_sprite::{ColorMaterial, MeshMaterial2d};
 /// # use bevy_ecs::prelude::*;
-/// # use bevy_render::mesh::Mesh;
+/// # use bevy_mesh::{Mesh, Mesh2d};
 /// # use bevy_color::palettes::basic::RED;
 /// # use bevy_asset::Assets;
 /// # use bevy_math::primitives::Circle;
@@ -72,7 +72,7 @@ impl AsAssetId for Mesh2d {
 /// ```ignore
 /// # use bevy_pbr::{Material, MeshMaterial3d, StandardMaterial};
 /// # use bevy_ecs::prelude::*;
-/// # use bevy_render::mesh::{Mesh, Mesh3d};
+/// # use bevy_mesh::{Mesh, Mesh3d};
 /// # use bevy_color::palettes::basic::RED;
 /// # use bevy_asset::Assets;
 /// # use bevy_math::primitives::Capsule3d;
diff --git a/crates/bevy_pbr/src/light_probe/environment_map.rs b/crates/bevy_pbr/src/light_probe/environment_map.rs
index b7b5a104da460..bd1ba1aeeb663 100644
--- a/crates/bevy_pbr/src/light_probe/environment_map.rs
+++ b/crates/bevy_pbr/src/light_probe/environment_map.rs
@@ -11,11 +11,11 @@
 //! 1. If attached to a view, they represent the objects located a very far
 //!    distance from the view, in a similar manner to a skybox. Essentially, these
 //!    *view environment maps* represent a higher-quality replacement for
-//!    [`AmbientLight`](crate::AmbientLight) for outdoor scenes. The indirect light from such
+//!    [`AmbientLight`](bevy_light::AmbientLight) for outdoor scenes. The indirect light from such
 //!    environment maps are added to every point of the scene, including
 //!    interior enclosed areas.
 //!
-//! 2. If attached to a [`crate::LightProbe`], environment maps represent the immediate
+//! 2. If attached to a [`bevy_light::LightProbe`], environment maps represent the immediate
 //!    surroundings of a specific location in the scene. These types of
 //!    environment maps are known as *reflection probes*.
 //!
diff --git a/crates/bevy_pbr/src/lightmap/mod.rs b/crates/bevy_pbr/src/lightmap/mod.rs
index 57fa05e158eaa..f4adb94738c48 100644
--- a/crates/bevy_pbr/src/lightmap/mod.rs
+++ b/crates/bevy_pbr/src/lightmap/mod.rs
@@ -26,7 +26,7 @@
 //! set the `uv_rect` field on [`Lightmap`] appropriately.
 //!
 //! [The Lightmapper]: https://github.com/Naxela/The_Lightmapper
-//! [`Mesh3d`]: bevy_render::mesh::Mesh3d
+//! [`Mesh3d`]: bevy_mesh::Mesh3d
 //! [`MeshMaterial3d<StandardMaterial>`]: crate::StandardMaterial
 //! [`StandardMaterial`]: crate::StandardMaterial
 //! [`bevy-baked-gi`]: https://github.com/pcwalton/bevy-baked-gi
@@ -79,9 +79,9 @@ pub struct LightmapPlugin;
 /// A component that applies baked indirect diffuse global illumination from a
 /// lightmap.
 ///
-/// When assigned to an entity that contains a [`Mesh3d`](bevy_render::mesh::Mesh3d) and a
+/// When assigned to an entity that contains a [`Mesh3d`](bevy_mesh::Mesh3d) and a
 /// [`MeshMaterial3d<StandardMaterial>`](crate::StandardMaterial), if the mesh
-/// has a second UV layer ([`ATTRIBUTE_UV_1`](bevy_render::mesh::Mesh::ATTRIBUTE_UV_1)),
+/// has a second UV layer ([`ATTRIBUTE_UV_1`](bevy_mesh::Mesh::ATTRIBUTE_UV_1)),
 /// then the lightmap will render using those UVs.
 #[derive(Component, Clone, Reflect)]
 #[reflect(Component, Default, Clone)]
diff --git a/crates/bevy_pbr/src/material.rs b/crates/bevy_pbr/src/material.rs
index 4b246bd06e2b2..059c37db0cb83 100644
--- a/crates/bevy_pbr/src/material.rs
+++ b/crates/bevy_pbr/src/material.rs
@@ -81,7 +81,9 @@ pub const MATERIAL_BIND_GROUP_INDEX: usize = 3;
 /// # use bevy_ecs::prelude::*;
 /// # use bevy_image::Image;
 /// # use bevy_reflect::TypePath;
-/// # use bevy_render::{mesh::{Mesh, Mesh3d}, render_resource::{AsBindGroup, ShaderRef}};
+/// # use bevy_mesh::{Mesh, Mesh3d};
+/// # use bevy_render::render_resource::AsBindGroup;
+/// # use bevy_shader::ShaderRef;
 /// # use bevy_color::LinearRgba;
 /// # use bevy_color::palettes::basic::RED;
 /// # use bevy_asset::{Handle, AssetServer, Assets, Asset};
diff --git a/crates/bevy_pbr/src/mesh_material.rs b/crates/bevy_pbr/src/mesh_material.rs
index 027f2073ec179..46520ccdb5d83 100644
--- a/crates/bevy_pbr/src/mesh_material.rs
+++ b/crates/bevy_pbr/src/mesh_material.rs
@@ -9,14 +9,14 @@ use derive_more::derive::From;
 ///
 /// See [`Material`] for general information about 3D materials and how to implement your own materials.
 ///
-/// [`Mesh3d`]: bevy_render::mesh::Mesh3d
+/// [`Mesh3d`]: bevy_mesh::Mesh3d
 ///
 /// # Example
 ///
 /// ```
 /// # use bevy_pbr::{Material, MeshMaterial3d, StandardMaterial};
 /// # use bevy_ecs::prelude::*;
-/// # use bevy_render::mesh::{Mesh, Mesh3d};
+/// # use bevy_mesh::{Mesh, Mesh3d};
 /// # use bevy_color::palettes::basic::RED;
 /// # use bevy_asset::Assets;
 /// # use bevy_math::primitives::Capsule3d;
diff --git a/crates/bevy_pbr/src/meshlet/asset.rs b/crates/bevy_pbr/src/meshlet/asset.rs
index 584ea345e3ecf..2f70c3276dffe 100644
--- a/crates/bevy_pbr/src/meshlet/asset.rs
+++ b/crates/bevy_pbr/src/meshlet/asset.rs
@@ -21,7 +21,7 @@ pub const MESHLET_MESH_ASSET_VERSION: u64 = 2;
 
 /// A mesh that has been pre-processed into multiple small clusters of triangles called meshlets.
 ///
-/// A [`bevy_render::mesh::Mesh`] can be converted to a [`MeshletMesh`] using `MeshletMesh::from_mesh` when the `meshlet_processor` cargo feature is enabled.
+/// A [`bevy_mesh::Mesh`] can be converted to a [`MeshletMesh`] using `MeshletMesh::from_mesh` when the `meshlet_processor` cargo feature is enabled.
 /// The conversion step is very slow, and is meant to be ran once ahead of time, and not during runtime. This type of mesh is not suitable for
 /// dynamically generated geometry.
 ///
diff --git a/crates/bevy_pbr/src/meshlet/mod.rs b/crates/bevy_pbr/src/meshlet/mod.rs
index 7b46d729e64a4..13ec1444c8f0a 100644
--- a/crates/bevy_pbr/src/meshlet/mod.rs
+++ b/crates/bevy_pbr/src/meshlet/mod.rs
@@ -256,7 +256,7 @@ fn check_meshlet_features(render_device: Res<RenderDevice>) {
     }
 }
 
-/// The meshlet mesh equivalent of [`bevy_render::mesh::Mesh3d`].
+/// The meshlet mesh equivalent of [`bevy_mesh::Mesh3d`].
 #[derive(Component, Clone, Debug, Default, Deref, DerefMut, Reflect, PartialEq, Eq, From)]
 #[reflect(Component, Default, Clone, PartialEq)]
 #[require(Transform, PreviousGlobalTransform, Visibility, VisibilityClass)]
diff --git a/crates/bevy_pbr/src/pbr_material.rs b/crates/bevy_pbr/src/pbr_material.rs
index d8dd90a6e18fb..9c988bf1ed0fe 100644
--- a/crates/bevy_pbr/src/pbr_material.rs
+++ b/crates/bevy_pbr/src/pbr_material.rs
@@ -11,8 +11,8 @@ use crate::{deferred::DEFAULT_PBR_DEFERRED_LIGHTING_PASS_ID, *};
 /// An enum to define which UV attribute to use for a texture.
 ///
 /// It is used for every texture in the [`StandardMaterial`].
-/// It only supports two UV attributes, [`bevy_render::mesh::Mesh::ATTRIBUTE_UV_0`] and
-/// [`bevy_render::mesh::Mesh::ATTRIBUTE_UV_1`].
+/// It only supports two UV attributes, [`bevy_mesh::Mesh::ATTRIBUTE_UV_0`] and
+/// [`bevy_mesh::Mesh::ATTRIBUTE_UV_1`].
 /// The default is [`UvChannel::Uv0`].
 #[derive(Reflect, Default, Debug, Clone, PartialEq, Eq)]
 #[reflect(Default, Debug, Clone, PartialEq)]
@@ -247,10 +247,10 @@ pub struct StandardMaterial {
     /// Specular transmission is implemented as a relatively expensive screen-space effect that allows occluded objects to be seen through the material,
     /// with distortion and blur effects.
     ///
-    /// - [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) can be used to enable transmissive objects
+    /// - [`Camera3d::screen_space_specular_transmission_steps`](bevy_camera::Camera3d::screen_space_specular_transmission_steps) can be used to enable transmissive objects
     ///   to be seen through other transmissive objects, at the cost of additional draw calls and texture copies; (Use with caution!)
     ///   - If a simplified approximation of specular transmission using only environment map lighting is sufficient, consider setting
-    ///     [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) to `0`.
+    ///     [`Camera3d::screen_space_specular_transmission_steps`](bevy_camera::Camera3d::screen_space_specular_transmission_steps) to `0`.
     /// - If purely diffuse light transmission is needed, (i.e. “translucency”) consider using [`StandardMaterial::diffuse_transmission`] instead,
     ///   for a much less expensive effect.
     /// - Specular transmission is rendered before alpha blending, so any material with [`AlphaMode::Blend`], [`AlphaMode::Premultiplied`], [`AlphaMode::Add`] or [`AlphaMode::Multiply`]
@@ -382,8 +382,8 @@ pub struct StandardMaterial {
     /// If your material has a normal map, but still renders as a flat surface,
     /// make sure your meshes have their tangents set.
     ///
-    /// [`Mesh::generate_tangents`]: bevy_render::mesh::Mesh::generate_tangents
-    /// [`Mesh::with_generated_tangents`]: bevy_render::mesh::Mesh::with_generated_tangents
+    /// [`Mesh::generate_tangents`]: bevy_mesh::Mesh::generate_tangents
+    /// [`Mesh::with_generated_tangents`]: bevy_mesh::Mesh::with_generated_tangents
     ///
     /// # Usage
     ///
@@ -644,7 +644,7 @@ pub struct StandardMaterial {
     ///
     /// Your 3D editing software should manage all of that.
     ///
-    /// [`Mesh`]: bevy_render::mesh::Mesh
+    /// [`Mesh`]: bevy_mesh::Mesh
     // TODO: include this in reflection somehow (maybe via remote types like serde https://serde.rs/remote-derive.html)
     #[reflect(ignore, clone)]
     pub cull_mode: Option<Face>,
diff --git a/crates/bevy_pbr/src/render/mesh_bindings.rs b/crates/bevy_pbr/src/render/mesh_bindings.rs
index cd7eb34b1a500..a80cdf547ac83 100644
--- a/crates/bevy_pbr/src/render/mesh_bindings.rs
+++ b/crates/bevy_pbr/src/render/mesh_bindings.rs
@@ -178,7 +178,7 @@ pub struct MeshLayouts {
 
     /// Also includes the uniform and [`MorphAttributes`] for morph targets.
     ///
-    /// [`MorphAttributes`]: bevy_render::mesh::morph::MorphAttributes
+    /// [`MorphAttributes`]: bevy_mesh::morph::MorphAttributes
     pub morphed: BindGroupLayout,
 
     /// Like [`MeshLayouts::morphed`], but includes a slot for the previous
@@ -188,7 +188,7 @@ pub struct MeshLayouts {
     /// Also includes both uniforms for skinning and morph targets, also the
     /// morph target [`MorphAttributes`] binding.
     ///
-    /// [`MorphAttributes`]: bevy_render::mesh::morph::MorphAttributes
+    /// [`MorphAttributes`]: bevy_mesh::morph::MorphAttributes
     pub morphed_skinned: BindGroupLayout,
 
     /// Like [`MeshLayouts::morphed_skinned`], but includes slots for the
@@ -200,7 +200,7 @@ pub struct MeshLayouts {
 impl MeshLayouts {
     /// Prepare the layouts used by the default bevy [`Mesh`].
     ///
-    /// [`Mesh`]: bevy_render::prelude::Mesh
+    /// [`Mesh`]: bevy_mesh::Mesh
     pub fn new(render_device: &RenderDevice, render_adapter: &RenderAdapter) -> Self {
         MeshLayouts {
             model_only: Self::model_only_layout(render_device),
diff --git a/crates/bevy_pbr/src/ssr/mod.rs b/crates/bevy_pbr/src/ssr/mod.rs
index e3fd27435314f..f39cf417c2492 100644
--- a/crates/bevy_pbr/src/ssr/mod.rs
+++ b/crates/bevy_pbr/src/ssr/mod.rs
@@ -71,7 +71,7 @@ pub struct ScreenSpaceReflectionsPlugin;
 /// As with all screen-space techniques, SSR can only reflect objects on screen.
 /// When objects leave the camera, they will disappear from reflections.
 /// An alternative that doesn't suffer from this problem is the combination of
-/// a [`LightProbe`](crate::LightProbe) and [`EnvironmentMapLight`]. The advantage of SSR is
+/// a [`LightProbe`](bevy_light::LightProbe) and [`EnvironmentMapLight`]. The advantage of SSR is
 /// that it can reflect all objects, not just static ones.
 ///
 /// SSR is an approximation technique and produces artifacts in some situations.
diff --git a/crates/bevy_pbr/src/volumetric_fog/mod.rs b/crates/bevy_pbr/src/volumetric_fog/mod.rs
index 42e3ac219ed35..c9ad4717f6993 100644
--- a/crates/bevy_pbr/src/volumetric_fog/mod.rs
+++ b/crates/bevy_pbr/src/volumetric_fog/mod.rs
@@ -6,14 +6,14 @@
 //! for light beams from directional lights to shine through, creating what is
 //! known as *light shafts* or *god rays*.
 //!
-//! To add volumetric fog to a scene, add [`crate::VolumetricFog`] to the
-//! camera, and add [`crate::VolumetricLight`] to directional lights that you wish to
-//! be volumetric. [`crate::VolumetricFog`] feature numerous settings that
+//! To add volumetric fog to a scene, add [`bevy_light::VolumetricFog`] to the
+//! camera, and add [`bevy_light::VolumetricLight`] to directional lights that you wish to
+//! be volumetric. [`bevy_light::VolumetricFog`] feature numerous settings that
 //! allow you to define the accuracy of the simulation, as well as the look of
 //! the fog. Currently, only interaction with directional lights that have
 //! shadow maps is supported. Note that the overhead of the effect scales
 //! directly with the number of directional lights in use, so apply
-//! [`crate::VolumetricLight`] sparingly for the best results.
+//! [`bevy_light::VolumetricLight`] sparingly for the best results.
 //!
 //! The overall algorithm, which is implemented as a postprocessing effect, is a
 //! combination of the techniques described in [Scratchapixel] and [this blog
diff --git a/crates/bevy_remote/src/lib.rs b/crates/bevy_remote/src/lib.rs
index e57c05083d89a..68169469df7de 100644
--- a/crates/bevy_remote/src/lib.rs
+++ b/crates/bevy_remote/src/lib.rs
@@ -203,7 +203,7 @@
 //! ```json
 //! {
 //!      "components": {
-//!        "bevy_core_pipeline::core_3d::camera_3d::Camera3d": {
+//!        "bevy_camera::Camera3d": {
 //!          "depth_load_op": {
 //!            "Clear": 0.0
 //!          },
@@ -213,7 +213,7 @@
 //!        },
 //!        "bevy_core_pipeline::tonemapping::DebandDither": "Enabled",
 //!        "bevy_core_pipeline::tonemapping::Tonemapping": "TonyMcMapface",
-//!        "bevy_pbr::cluster::ClusterConfig": {
+//!        "bevy_light::cluster::ClusterConfig": {
 //!          "FixedZ": {
 //!         "dynamic_resizing": true,
 //!            "total": 4096,
@@ -224,7 +224,7 @@
 //!            "z_slices": 24
 //!          }
 //!        },
-//!        "bevy_render::camera::camera::Camera": {
+//!        "bevy_camera::Camera": {
 //!          "clear_color": "Default",
 //!          "is_active": true,
 //!          "msaa_writeback": true,
@@ -235,7 +235,7 @@
 //!          },
 //!       "viewport": null
 //!        },
-//!        "bevy_render::camera::projection::Projection": {
+//!        "bevy_camera::Projection": {
 //!          "Perspective": {
 //!            "aspect_ratio": 1.7777777910232544,
 //!            "far": 1000.0,
@@ -243,14 +243,14 @@
 //!            "near": 0.10000000149011612
 //!          }
 //!        },
-//!        "bevy_render::primitives::Frustum": {},
+//!        "bevy_camera::primitives::Frustum": {},
 //!     "bevy_render::sync_world::RenderEntity": 4294967291,
 //!        "bevy_render::sync_world::SyncToRenderWorld": {},
 //!        "bevy_render::view::Msaa": "Sample4",
-//!        "bevy_render::view::visibility::InheritedVisibility": true,
-//!        "bevy_render::view::visibility::ViewVisibility": false,
-//!        "bevy_render::view::visibility::Visibility": "Inherited",
-//!        "bevy_render::view::visibility::VisibleEntities": {},
+//!        "bevy_camera::visibility::InheritedVisibility": true,
+//!        "bevy_camera::visibility::ViewVisibility": false,
+//!        "bevy_camera::visibility::Visibility": "Inherited",
+//!        "bevy_camera::visibility::VisibleEntities": {},
 //!        "bevy_transform::components::global_transform::GlobalTransform": [
 //!          0.9635179042816162,
 //!          -3.725290298461914e-9,
diff --git a/crates/bevy_render/src/camera.rs b/crates/bevy_render/src/camera.rs
index d827447cf9a4d..05633ab48c833 100644
--- a/crates/bevy_render/src/camera.rs
+++ b/crates/bevy_render/src/camera.rs
@@ -273,8 +273,8 @@ impl NormalizedRenderTargetExt for NormalizedRenderTarget {
 /// [`Res<Assets<Image>>`](Assets<Image>) -- For cameras that render to an image, this resource is used to
 /// inspect information about the render target. This system will not access any other image assets.
 ///
-/// [`OrthographicProjection`]: crate::camera::OrthographicProjection
-/// [`PerspectiveProjection`]: crate::camera::PerspectiveProjection
+/// [`OrthographicProjection`]: bevy_camera::OrthographicProjection
+/// [`PerspectiveProjection`]: bevy_camera::PerspectiveProjection
 pub fn camera_system(
     mut window_resized_events: EventReader<WindowResized>,
     mut window_created_events: EventReader<WindowCreated>,
@@ -638,7 +638,7 @@ pub fn sort_cameras(
 ///
 /// Do not use with [`OrthographicProjection`].
 ///
-/// [`OrthographicProjection`]: crate::camera::OrthographicProjection
+/// [`OrthographicProjection`]: bevy_camera::OrthographicProjection
 #[derive(Component, Clone, Default, Reflect)]
 #[reflect(Default, Component, Clone)]
 pub struct TemporalJitter {
diff --git a/crates/bevy_render/src/experimental/occlusion_culling/mod.rs b/crates/bevy_render/src/experimental/occlusion_culling/mod.rs
index 77fcb4b5b205e..ff76b332a404f 100644
--- a/crates/bevy_render/src/experimental/occlusion_culling/mod.rs
+++ b/crates/bevy_render/src/experimental/occlusion_culling/mod.rs
@@ -6,10 +6,9 @@
 use bevy_app::{App, Plugin};
 use bevy_ecs::{component::Component, entity::Entity, prelude::ReflectComponent};
 use bevy_reflect::{prelude::ReflectDefault, Reflect};
+use bevy_shader::load_shader_library;
 
-use crate::{
-    extract_component::ExtractComponent, load_shader_library, render_resource::TextureView,
-};
+use crate::{extract_component::ExtractComponent, render_resource::TextureView};
 
 /// Enables GPU occlusion culling.
 ///
diff --git a/crates/bevy_render/src/globals.rs b/crates/bevy_render/src/globals.rs
index b8d6810a8bb43..9b643d5ea4c87 100644
--- a/crates/bevy_render/src/globals.rs
+++ b/crates/bevy_render/src/globals.rs
@@ -1,6 +1,5 @@
 use crate::{
     extract_resource::ExtractResource,
-    load_shader_library,
     render_resource::{ShaderType, UniformBuffer},
     renderer::{RenderDevice, RenderQueue},
     Extract, ExtractSchedule, Render, RenderApp, RenderSystems,
@@ -9,6 +8,7 @@ use bevy_app::{App, Plugin};
 use bevy_diagnostic::FrameCount;
 use bevy_ecs::prelude::*;
 use bevy_reflect::prelude::*;
+use bevy_shader::load_shader_library;
 use bevy_time::Time;
 
 pub struct GlobalsPlugin;
diff --git a/crates/bevy_render/src/renderer/render_device.rs b/crates/bevy_render/src/renderer/render_device.rs
index c965a9fb14424..87ea98d900a5b 100644
--- a/crates/bevy_render/src/renderer/render_device.rs
+++ b/crates/bevy_render/src/renderer/render_device.rs
@@ -96,7 +96,7 @@ impl RenderDevice {
 
     /// Creates and validates a [`ShaderModule`](wgpu::ShaderModule) from either SPIR-V or WGSL source code.
     ///
-    /// See [`ValidateShader`](bevy_render::render_resource::ValidateShader) for more information on the tradeoffs involved with shader validation.
+    /// See [`ValidateShader`](bevy_shader::ValidateShader) for more information on the tradeoffs involved with shader validation.
     #[inline]
     pub fn create_and_validate_shader_module(
         &self,
diff --git a/crates/bevy_render/src/texture/manual_texture_view.rs b/crates/bevy_render/src/texture/manual_texture_view.rs
index b291463c29c75..1f0659a1fdc22 100644
--- a/crates/bevy_render/src/texture/manual_texture_view.rs
+++ b/crates/bevy_render/src/texture/manual_texture_view.rs
@@ -8,7 +8,7 @@ use wgpu::TextureFormat;
 
 use crate::render_resource::TextureView;
 
-/// A manually managed [`TextureView`] for use as a [`crate::camera::RenderTarget`].
+/// A manually managed [`TextureView`] for use as a [`bevy_camera::RenderTarget`].
 #[derive(Debug, Clone, Component)]
 pub struct ManualTextureView {
     pub texture_view: TextureView,
@@ -26,7 +26,7 @@ impl ManualTextureView {
     }
 }
 
-/// Stores manually managed [`ManualTextureView`]s for use as a [`crate::camera::RenderTarget`].
+/// Stores manually managed [`ManualTextureView`]s for use as a [`bevy_camera::RenderTarget`].
 #[derive(Default, Clone, Resource, ExtractResource)]
 pub struct ManualTextureViews(HashMap<ManualTextureViewHandle, ManualTextureView>);
 
diff --git a/crates/bevy_render/src/view/mod.rs b/crates/bevy_render/src/view/mod.rs
index 6b5851cad9000..04482066f6d4b 100644
--- a/crates/bevy_render/src/view/mod.rs
+++ b/crates/bevy_render/src/view/mod.rs
@@ -13,7 +13,6 @@ use crate::{
     camera::{ExtractedCamera, MipBias, NormalizedRenderTargetExt as _, TemporalJitter},
     experimental::occlusion_culling::OcclusionCulling,
     extract_component::ExtractComponentPlugin,
-    load_shader_library,
     render_asset::RenderAssets,
     render_phase::ViewRangefinder3d,
     render_resource::{DynamicUniformBuffer, ShaderType, Texture, TextureView},
@@ -35,6 +34,7 @@ use bevy_math::{mat3, vec2, vec3, Mat3, Mat4, UVec4, Vec2, Vec3, Vec4, Vec4Swizz
 use bevy_platform::collections::{hash_map::Entry, HashMap};
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
 use bevy_render_macros::ExtractComponent;
+use bevy_shader::load_shader_library;
 use bevy_transform::components::GlobalTransform;
 use core::{
     ops::Range,
@@ -142,7 +142,7 @@ impl Plugin for ViewPlugin {
 }
 
 /// Component for configuring the number of samples for [Multi-Sample Anti-Aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing)
-/// for a [`Camera`](crate::camera::Camera).
+/// for a [`Camera`](bevy_camera::Camera).
 ///
 /// Defaults to 4 samples. A higher number of samples results in smoother edges.
 ///
@@ -314,7 +314,7 @@ impl ExtractedView {
 /// Configures filmic color grading parameters to adjust the image appearance.
 ///
 /// Color grading is applied just before tonemapping for a given
-/// [`Camera`](crate::camera::Camera) entity, with the sole exception of the
+/// [`Camera`](bevy_camera::Camera) entity, with the sole exception of the
 /// `post_saturation` value in [`ColorGradingGlobal`], which is applied after
 /// tonemapping.
 #[derive(Component, Reflect, Debug, Default, Clone)]
diff --git a/crates/bevy_sprite/src/mesh2d/material.rs b/crates/bevy_sprite/src/mesh2d/material.rs
index 43e0bead7a3b0..9a1954688f4d5 100644
--- a/crates/bevy_sprite/src/mesh2d/material.rs
+++ b/crates/bevy_sprite/src/mesh2d/material.rs
@@ -70,7 +70,9 @@ pub const MATERIAL_2D_BIND_GROUP_INDEX: usize = 2;
 /// # use bevy_ecs::prelude::*;
 /// # use bevy_image::Image;
 /// # use bevy_reflect::TypePath;
-/// # use bevy_render::{mesh::{Mesh, Mesh2d}, render_resource::{AsBindGroup, ShaderRef}};
+/// # use bevy_mesh::{Mesh, Mesh2d};
+/// # use bevy_render::render_resource::AsBindGroup;
+/// # use bevy_shader::ShaderRef;
 /// # use bevy_color::LinearRgba;
 /// # use bevy_color::palettes::basic::RED;
 /// # use bevy_asset::{Handle, AssetServer, Assets, Asset};
@@ -172,7 +174,7 @@ pub trait Material2d: AsBindGroup + Asset + Clone + Sized {
 /// ```
 /// # use bevy_sprite::{ColorMaterial, MeshMaterial2d};
 /// # use bevy_ecs::prelude::*;
-/// # use bevy_render::mesh::{Mesh, Mesh2d};
+/// # use bevy_mesh::{Mesh, Mesh2d};
 /// # use bevy_color::palettes::basic::RED;
 /// # use bevy_asset::Assets;
 /// # use bevy_math::primitives::Circle;
diff --git a/crates/bevy_text/src/text2d.rs b/crates/bevy_text/src/text2d.rs
index 0ddce86eed720..69573e3eb5deb 100644
--- a/crates/bevy_text/src/text2d.rs
+++ b/crates/bevy_text/src/text2d.rs
@@ -347,7 +347,7 @@ pub fn scale_value(value: f32, factor: f32) -> f32 {
 /// System calculating and inserting an [`Aabb`] component to entities with some
 /// [`TextLayoutInfo`] and [`Anchor`] components, and without a [`NoFrustumCulling`] component.
 ///
-/// Used in system set [`VisibilitySystems::CalculateBounds`](bevy_render::view::VisibilitySystems::CalculateBounds).
+/// Used in system set [`VisibilitySystems::CalculateBounds`](bevy_camera::visibility::VisibilitySystems::CalculateBounds).
 pub fn calculate_bounds_text2d(
     mut commands: Commands,
     mut text_to_update_aabb: Query<
diff --git a/crates/bevy_ui/src/ui_node.rs b/crates/bevy_ui/src/ui_node.rs
index 41dcd7030fd51..7c55265691233 100644
--- a/crates/bevy_ui/src/ui_node.rs
+++ b/crates/bevy_ui/src/ui_node.rs
@@ -2747,8 +2747,7 @@ impl UiTargetCamera {
 /// ```
 /// # use bevy_ui::prelude::*;
 /// # use bevy_ecs::prelude::Commands;
-/// # use bevy_camera::{Camera, RenderTarget};
-/// # use bevy_core_pipeline::prelude::Camera2d;
+/// # use bevy_camera::{Camera, Camera2d, RenderTarget};
 /// # use bevy_window::{Window, WindowRef};
 ///
 /// fn spawn_camera(mut commands: Commands) {
diff --git a/examples/3d/meshlet.rs b/examples/3d/meshlet.rs
index 633e2090d95a6..cff5113475724 100644
--- a/examples/3d/meshlet.rs
+++ b/examples/3d/meshlet.rs
@@ -74,7 +74,7 @@ fn setup(
         Transform::from_rotation(Quat::from_euler(EulerRot::ZYX, 0.0, PI * -0.15, PI * -0.15)),
     ));
 
-    // A custom file format storing a [`bevy_render::mesh::Mesh`]
+    // A custom file format storing a [`bevy_mesh::Mesh`]
     // that has been converted to a [`bevy_pbr::meshlet::MeshletMesh`]
     // using [`bevy_pbr::meshlet::MeshletMesh::from_mesh`], which is
     // a function only available when the `meshlet_processor` cargo feature is enabled.
