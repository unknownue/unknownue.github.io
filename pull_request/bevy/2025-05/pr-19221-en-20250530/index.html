<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #19221 Fix #19219 by moving observer triggers out of resource_scope
        
    </title><meta content="#19221 Fix #19219 by moving observer triggers out of resource_scope" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-05/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-05-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-05/pr-19221-zh-cn-20250530>中文</a></div></div><div class=pr-content><h1 id=fix-19219-by-moving-observer-triggers-out-of-resource-scope>Fix #19219 by moving observer triggers out of resource_scope</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix #19219 by moving observer triggers out of resource_scope<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/19221<li><strong>Author</strong>: mbrea-c<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-ECS, S-Ready-For-Final-Review, D-Modest<li><strong>Created</strong>: 2025-05-15T21:37:21Z<li><strong>Merged</strong>: 2025-05-30T19:54:07Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Fixes #19219<h2 id=solution>Solution</h2><p>Instead of calling <code>world.commands().trigger</code> and <code>world.commands().trigger_targets</code> whenever each scene is spawned, save the <code>instance_id</code> and optional parent entity to perform all such calls at the end. This prevents the potential flush of the world command queue that can happen if <code>add_child</code> is called from causing the crash.<h2 id=testing>Testing</h2><ul><li>Did you test these changes? If so, how? <ul><li>Verified that I can no longer reproduce the bug with the instructions at #19219.<li>Ran <code>bevy_scene</code> tests<li>Visually verified that the following examples still run as expected <code>many_foxes</code>, <code>scene</code> . (should I test any more?)</ul><li>Are there any parts that need more testing? <ul><li>Pending to run <code>cargo test</code> at the root to test that all examples still build; I will update the PR when that’s done</ul><li>How can other people (reviewers) test your changes? Is there anything specific they need to know? <ul><li>Run bevy as usual</ul><li>If relevant, what platforms did you test these changes on, and are there any important ones you can’t test? <ul><li>N/a (tested on Linux/wayland but it shouldn’t be relevant)</ul></ul><hr><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a specific crash (#19219) that occurred when spawning scenes in Bevy’s ECS framework. The root cause was improper timing of event triggers relative to Bevy’s command queue processing. When spawning scenes, the original implementation immediately triggered <code>SceneInstanceReady</code> events using <code>world.commands().trigger()</code>. This approach risked prematurely flushing the command queue while the <code>SceneSpawner</code> resource was still in a mutable borrow scope.<p>The critical insight is that command queue flushes can trigger systems that might attempt to access the same <code>SceneSpawner</code> resource, creating a conflict since Rust’s borrow checker prevents simultaneous mutable and immutable access. This was particularly problematic when scene spawning involved parenting operations, as <code>add_child</code> commands could indirectly cause early command queue flushes.<p>The solution modifies the event triggering mechanism to batch and defer notifications. Rather than firing events immediately during scene processing, we now:<ol><li>Collect instance IDs and parent entities in a new <code>instances_ready</code> vector<li>Process these pending events after all scene operations complete<li>Trigger events outside the critical resource borrow section</ol><p>This approach maintains the same functional behavior while eliminating the resource access conflict. By moving event triggers outside the mutable borrow of <code>SceneSpawner</code>, we ensure the command queue flushes occur when the resource is no longer borrowed, preventing the crash.<p>The implementation adds a new <code>Vec</code> field to <code>SceneSpawner</code> to accumulate pending events:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>SceneSpawner </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...existing fields...
</span><span>    instances_ready</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(InstanceId, </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity>)>,
</span><span>}
</span></code></pre><p>During scene spawning operations, instead of directly triggering events, we push event data to this buffer:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (problematic):
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>commands</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(SceneInstanceReady { instance_id })</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After (safe):
</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>instances_ready</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((instance_id</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>None</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><p>A new method <code>trigger_scene_ready_events</code> processes the accumulated events after scene operations complete:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>trigger_scene_ready_events</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) {
</span><span>    </span><span style=color:#fa6e32>for </span><span>(instance_id</span><span style=color:#61676ccc>,</span><span> parent) </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>instances_ready</span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>(</span><span style=color:#ed9366>..</span><span>) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(parent) </span><span style=color:#ed9366>=</span><span> parent {
</span><span>            world</span><span style=color:#ed9366>.</span><span style=color:#f07171>commands</span><span>()
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_targets</span><span>(SceneInstanceReady { instance_id }</span><span style=color:#61676ccc>,</span><span> parent)</span><span style=color:#61676ccc>;
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            world</span><span style=color:#ed9366>.</span><span style=color:#f07171>commands</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(SceneInstanceReady { instance_id })</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Finally, we call this new method in the main system after all other processing:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>scene_spawner_system</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) {
</span><span>    world</span><span style=color:#ed9366>.</span><span style=color:#f07171>resource_scope</span><span>(|</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>scene_spawner</span><span style=color:#61676ccc>: </span><span>Mut&LTSceneSpawner>| {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...existing scene processing...
</span><span>        scene_spawner</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_scene_ready_events</span><span>(world)</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This solution demonstrates a valuable pattern for ECS development: when dealing with systems that generate events or commands while holding resources, batch and defer side effects until after resource scopes conclude. The changes preserve all existing functionality while eliminating the crash risk, with minimal performance impact since we’re simply moving existing operations rather than adding significant new computation.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Scene Spawning Starts] --> B[Process Scene Instances]
</span><span>    B --> C{Parent Exists?}
</span><span>    C -->|Yes| D[Store in instances_ready with parent]
</span><span>    C -->|No| E[Store in instances_ready without parent]
</span><span>    D --> F[All Scenes Processed]
</span><span>    E --> F
</span><span>    F --> G[Trigger SceneInstanceReady Events]
</span><span>    G --> H[Scene Spawning Completes]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-scene-src-scene-spawner-rs><code>crates/bevy_scene/src/scene_spawner.rs</code></h3><p><strong>Purpose</strong>: Fixes crash by deferring event triggers until after scene processing completes.<p><strong>Key changes</strong>:<ol><li>Added new buffer field to accumulate pending events<li>Replaced immediate event triggers with buffer storage<li>Added method to process buffered events<li>Integrated event triggering at end of system</ol><p><strong>Code snippets</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>if</span><span> parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>    world</span><span style=color:#ed9366>.</span><span style=color:#f07171>commands</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(SceneInstanceReady { instance_id })</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>if</span><span> parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>instances_ready</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((instance_id</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>None</span><span>))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// New method added:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>trigger_scene_ready_events</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) {
</span><span>    </span><span style=color:#fa6e32>for </span><span>(instance_id</span><span style=color:#61676ccc>,</span><span> parent) </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>instances_ready</span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>(</span><span style=color:#ed9366>..</span><span>) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(parent) </span><span style=color:#ed9366>=</span><span> parent {
</span><span>            world</span><span style=color:#ed9366>.</span><span style=color:#f07171>commands</span><span>()
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_targets</span><span>(SceneInstanceReady { instance_id }</span><span style=color:#61676ccc>,</span><span> parent)</span><span style=color:#61676ccc>;
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            world</span><span style=color:#ed9366>.</span><span style=color:#f07171>commands</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(SceneInstanceReady { instance_id })</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// System integration:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>scene_spawner_system</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) {
</span><span>    world</span><span style=color:#ed9366>.</span><span style=color:#f07171>resource_scope</span><span>(|</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>scene_spawner</span><span style=color:#61676ccc>: </span><span>Mut&LTSceneSpawner>| {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...existing code...
</span><span>        scene_spawner</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_scene_ready_events</span><span>(world)</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/getting-started/ecs/#system-ordering target=_blank>Bevy ECS System Ordering Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/getting-started/commands/ target=_blank>Bevy Commands and Deferred Operations</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html target=_blank>Rust Borrow Checker and Resource Scoping</a></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-05/pr_19221.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>