<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22572 Improve time complexity of get_component_mut
        
    </title><meta content="#22572 Improve time complexity of get_component_mut" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-22</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22572-zh-cn-20260122>中文</a></div></div><div class=pr-content><h1 id=improve-time-complexity-of-get-component-mut>Improve time complexity of get_component_mut</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Improve time complexity of get_component_mut<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22572<li><strong>Author</strong>: kumaryash6352<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Performance, S-Ready-For-Final-Review, X-Uncontroversial, D-Modest<li><strong>Created</strong>: 2026-01-17T20:08:41Z<li><strong>Merged</strong>: 2026-01-22T19:44:23Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Addresses #22483.</ul><h2 id=solution>Solution</h2><p>Add a bloom filter to <code>has_conflicts</code> as a pre-check to see if we need to check a given access against every other access or not. If the access doesn’t hit any component or resource a previous access does, we know we don’t need to check it element-by-element. Well-formed calls to get_components_mut should then be linear in time taken to check for conflicts, as they would always pass the pre-check.<p>The filter used is exported in the <code>bevy_utils</code> API as it is not specific to components or resources.<h2 id=testing>Testing</h2><p>Tested via <code>cargo test</code>, where the get_component_mut tests pass or panic as expected.<p>The get_component_mut benchmarks show >=20% improvements at as little as 5 components compared to the existing fallback for smaller sets. The larger, 32 component benchmark added shows massive improvements. In general, the new pre-check filter means we’re only about 4-5x slower than not checking at all.<pre style=color:#61676c;background-color:#fafafa><code><span>ecs::world::world_get::world_query_get_components_mut/10_components_50000_entities
</span><span>                        time:   [6.5252 ms 6.5314 ms 6.5388 ms]
</span><span>                        change: [−34.225% −33.954% −33.747%] (p = 0.00 < 0.05)
</span><span>                        Performance has improved.
</span><span>[...]
</span><span>ecs::world::world_get::world_query_get_components_mut/32_components
</span><span>                        time:   [21.608 ms 21.696 ms 21.828 ms]
</span><span>                        change: [−92.284% −92.236% −92.186%] (p = 0.00 < 0.05)
</span><span>                        Performance has improved.
</span></code></pre><table><thead><tr><th>bench<th>mean (prev, with fallback threshold)<th>mean (post, always complex)<th>delta<tbody><tr><td>2_components<td>770.73 us<td>925.90 us<td>+19.62%<tr><td>unchecked_2_components<td>288.66 us<td>288.71 us<td>-0.84%<tr><td>5_components<td>2.960 ms<td>2.286 ms<td>-22.77%<tr><td>unchecked_5_components<td>505.45 us<td>521.56 us<td>+2.14%<tr><td>10_components<td>9.889 ms<td>6.531 ms<td>-33.95%<tr><td>unchecked_10_components<td>1.452 ms<td>1.538 ms<td>+5.48%<tr><td>32_components<td>279.44 ms<td>21.696 ms<td>-92.24%<tr><td>unchecked_32_components<td>4.460 ms<td>4.458 ms<td>-0.05%</table><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>This PR addresses a performance issue in Bevy’s ECS (Entity Component System) when checking for access conflicts in queries with many components. Specifically, the problem was with the <code>has_conflicts</code> function that validates whether a query can safely access multiple components without data races.<p>The original implementation had a quadratic time complexity (O(n²)) where <code>n</code> is the number of accessed components. For each component access, the function compared it against all previous accesses to check for conflicts. While this worked fine for small queries, performance degraded significantly as the number of components increased. The benchmark shows that with 32 components, the conflict checking took 279.44 ms, which is substantial overhead for a safety check.<p>The existing code already attempted to optimize small queries by caching accesses in a fixed-size array, but this optimization only applied to queries with 16 or fewer components. For larger queries, it fell back to the quadratic pairwise comparison.<h3 id=the-solution-approach>The Solution Approach</h3><p>The developer implemented a bloom filter as a pre-check mechanism to avoid unnecessary pairwise comparisons. The key insight is that most well-formed queries access distinct components, so we can quickly determine if two accesses might conflict without comparing every pair.<p>A bloom filter is a probabilistic data structure that tests whether an element is a member of a set. It can return false positives (saying an element is in the set when it isn’t) but never false negatives. In this context, we use it to track which components/resources have been accessed. When checking a new access, if the bloom filter indicates no overlap with previous accesses, we can skip the expensive pairwise check.<p>The implementation maintains two separate paths:<ol><li>For small queries (≤4 components), it uses the existing pairwise comparison for simplicity<li>For larger queries, it uses the bloom filter pre-check, falling back to pairwise comparison only when the filter indicates a potential conflict</ol><p>The threshold of 4 components was determined through benchmarking to balance the overhead of maintaining the bloom filter against the cost of the quadratic check.<h3 id=the-implementation>The Implementation</h3><p>The core change is in <code>crates/bevy_ecs/src/query/access_iter.rs</code>, where the <code>has_conflicts</code> function was refactored into three parts:<ol><li><code>has_conflicts</code>: The main entry point that decides which strategy to use<li><code>has_conflicts_small</code>: For queries with ≤4 components, using pairwise comparison<li><code>has_conflicts_large</code>: For larger queries, using the bloom filter approach</ol><p>Here’s the key part of the bloom filter implementation:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>has_conflicts_large</span><span><</span><span style=color:#fa6e32>'a</span><span>, Q</span><span style=color:#61676ccc>:</span><span> QueryData>(
</span><span>    </span><span style=color:#ff8f40>state</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a Q</span><span style=color:#ed9366>::</span><span>State,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), AccessConflictError<</span><span style=color:#fa6e32>'a</span><span>>> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// use a bloom filter as a linear time check if we need to run the longer, exact check
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> filter </span><span style=color:#ed9366>= </span><span>BloomFilter</span><span style=color:#ed9366>::</span><span>&LT8, 2></span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for </span><span>(i</span><span style=color:#61676ccc>,</span><span> access) </span><span style=color:#ed9366>in </span><span>Q</span><span style=color:#ed9366>::</span><span>iter_access(state)</span><span style=color:#ed9366>.</span><span style=color:#f07171>enumerate</span><span>() {
</span><span>        </span><span style=color:#fa6e32>let</span><span> needs_check </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> access {
</span><span>            EcsAccessType</span><span style=color:#ed9366>::</span><span>Component(EcsAccessLevel</span><span style=color:#ed9366>::</span><span>Read(component_id))
</span><span>            </span><span style=color:#ed9366>| </span><span>EcsAccessType</span><span style=color:#ed9366>::</span><span>Component(EcsAccessLevel</span><span style=color:#ed9366>::</span><span>Write(component_id)) </span><span style=color:#ed9366>=> </span><span>{
</span><span>                filter</span><span style=color:#ed9366>.</span><span style=color:#f07171>check_insert</span><span>(</span><span style=color:#ed9366>&</span><span>component_id</span><span style=color:#ed9366>.</span><span style=color:#f07171>index</span><span>())
</span><span>            }
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// ... other access types handled similarly
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if</span><span> needs_check {
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// we MIGHT have a conflict, fallback to slow check
</span><span>            </span><span style=color:#fa6e32>for </span><span>(j</span><span style=color:#61676ccc>,</span><span> access_other) </span><span style=color:#ed9366>in </span><span>Q</span><span style=color:#ed9366>::</span><span>iter_access(state)</span><span style=color:#ed9366>.</span><span style=color:#f07171>enumerate</span><span>() {
</span><span>                </span><span style=color:#fa6e32>if</span><span> i </span><span style=color:#ed9366>==</span><span> j {
</span><span>                    </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>                </span><span style=color:#fa6e32>if</span><span> access</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_compatible</span><span>(access_other)</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_err</span><span>() {
</span><span>                    </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(AccessConflictError(access</span><span style=color:#61676ccc>,</span><span> access_other))</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>}
</span></code></pre><p>The bloom filter itself was implemented in a new file <code>crates/bevy_utils/src/bloom_filter.rs</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Clone</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Debug)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>BloomFilter</span><span><</span><span style=color:#fa6e32>const</span><span> N</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>, </span><span style=color:#fa6e32>const</span><span> K</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span> = 2> {
</span><span>    bits</span><span style=color:#61676ccc>:</span><span> [</span><span style=color:#fa6e32>u64</span><span>; N],
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>const</span><span> N</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>, </span><span style=color:#fa6e32>const</span><span> K</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>> </span><span style=color:#399ee6>BloomFilter</span><span>&LTN, K> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>check_insert</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>item</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>impl Hash) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>        </span><span style=color:#fa6e32>let</span><span> res </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(item)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>res {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(item)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        res
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>check_insert</code> method is particularly useful for this use case: it checks if an item is in the filter, inserts it if not, and returns whether it was already present.<h3 id=technical-insights>Technical Insights</h3><p>The implementation demonstrates several important engineering considerations:<ol><li><p><strong>Algorithmic Optimization</strong>: By reducing the average-case complexity from O(n²) to O(n) for well-formed queries, the solution provides dramatic performance improvements for large component counts.</p><li><p><strong>Threshold Tuning</strong>: The <code>USE_FILTER_THRESHOLD</code> constant (set to 4) represents a carefully chosen trade-off. For very small queries, the overhead of maintaining the bloom filter outweighs its benefits. This threshold was determined through benchmarking.</p><li><p><strong>Probabilistic Data Structures</strong>: The use of a bloom filter is appropriate here because:</p> <ul><li>False positives are acceptable (they just trigger the slower verification)<li>False negatives would be unsafe (missed conflicts), which bloom filters don’t produce<li>Memory usage is predictable and small (8 u64s = 64 bytes)</ul><li><p><strong>Code Organization</strong>: The solution cleanly separates concerns:</p> <ul><li>Bloom filter implementation is generic and reusable<li>Conflict checking logic is split into small and large query paths<li>The existing test suite was extended to validate both paths</ul></ol><h3 id=the-impact>The Impact</h3><p>The performance improvements are substantial:<ul><li><strong>32 components</strong>: 92.24% faster (279.44 ms → 21.696 ms)<li><strong>10 components</strong>: 33.95% faster<li><strong>5 components</strong>: 22.77% faster</ul><p>The benchmarks show that with the bloom filter, conflict checking is only 4-5x slower than the unchecked version, compared to being orders of magnitude slower for large component counts in the original implementation.<p>The changes are minimal and focused:<ol><li>Added a generic bloom filter to <code>bevy_utils</code><li>Modified the conflict checking algorithm to use it as a pre-filter<li>Extended benchmarks to validate the improvement<li>Added <code>Hash</code> implementation to necessary types to support hashing</ol><p>This solution maintains all safety guarantees while dramatically improving performance for common use cases with many components.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[has_conflicts function] --> B{Query size ≤ 4?}
</span><span>    B -->|Yes| C[has_conflicts_small&LTbr/>Pairwise comparison]
</span><span>    B -->|No| D[has_conflicts_large&LTbr/>Bloom filter pre-check]
</span><span>    D --> E{Bloom filter indicates&LTbr/>potential conflict?}
</span><span>    E -->|Yes| F[Fallback to pairwise check]
</span><span>    E -->|No| G[Skip expensive check]
</span><span>    C --> H[Return result]
</span><span>    F --> H
</span><span>    G --> H
</span><span>    
</span><span>    I[BloomFilter struct] --> J[Used by has_conflicts_large]
</span><span>    K[Access struct] --> L[Implements Hash for bloom filter]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-crates-bevy-ecs-src-query-access-iter-rs-324-50>1. <code>crates/bevy_ecs/src/query/access_iter.rs</code> (+324/-50)</h3><p>This file contains the core logic change. The <code>has_conflicts</code> function was refactored to use two strategies based on query size.<p><strong>Key change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Single algorithm with fixed threshold
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>MAX_SIZE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>16</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// ... code that checks all pairs for size > MAX_SIZE
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Two specialized functions
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>USE_FILTER_THRESHOLD</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>has_conflicts</span><span>&LTQ</span><span style=color:#61676ccc>:</span><span> QueryData>(</span><span style=color:#ff8f40>components</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Components) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), QueryAccessError> {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(state) </span><span style=color:#ed9366>= </span><span>Q</span><span style=color:#ed9366>::</span><span>get_state(components) </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(QueryAccessError</span><span style=color:#ed9366>::</span><span>ComponentNotRegistered)</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> result </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(size) </span><span style=color:#ed9366>= </span><span>Q</span><span style=color:#ed9366>::</span><span>iter_access(</span><span style=color:#ed9366>&</span><span>state)</span><span style=color:#ed9366>.</span><span style=color:#f07171>size_hint</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1
</span><span>        </span><span style=color:#ed9366>&&</span><span> size </span><span style=color:#ed9366><= </span><span style=color:#ff8f40>USE_FILTER_THRESHOLD
</span><span>    {
</span><span>        has_conflicts_small</span><span style=color:#ed9366>::</span><span>&LTQ>(</span><span style=color:#ed9366>&</span><span>state)
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        has_conflicts_large</span><span style=color:#ed9366>::</span><span>&LTQ>(</span><span style=color:#ed9366>&</span><span>state)
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... error handling
</span><span>}
</span></code></pre><h3 id=2-crates-bevy-utils-src-bloom-filter-rs-80-0>2. <code>crates/bevy_utils/src/bloom_filter.rs</code> (+80/-0)</h3><p>A new generic bloom filter implementation that’s reusable across the codebase.<p><strong>Key implementation:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>BloomFilter</span><span><</span><span style=color:#fa6e32>const</span><span> N</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>, </span><span style=color:#fa6e32>const</span><span> K</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span> = 2> {
</span><span>    bits</span><span style=color:#61676ccc>:</span><span> [</span><span style=color:#fa6e32>u64</span><span>; N],
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>const</span><span> N</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>, </span><span style=color:#fa6e32>const</span><span> K</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>> </span><span style=color:#399ee6>BloomFilter</span><span>&LTN, K> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>check_insert</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>item</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>impl Hash) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>        </span><span style=color:#fa6e32>let</span><span> res </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(item)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>res {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(item)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        res
</span><span>    }
</span><span>}
</span></code></pre><h3 id=3-benches-benches-bevy-ecs-world-world-get-rs-77-0>3. <code>benches/benches/bevy_ecs/world/world_get.rs</code> (+77/-0)</h3><p>Added a new benchmark for 32 components to demonstrate the performance improvement.<p><strong>Key addition:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>query_get_components_mut_32</span><span>(</span><span style=color:#ff8f40>criterion</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Criterion) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Benchmark setup for 32 components
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    group</span><span style=color:#ed9366>.</span><span style=color:#f07171>bench_function</span><span>(</span><span style=color:#86b300>"32_components"</span><span style=color:#61676ccc>, </span><span>|</span><span style=color:#ff8f40>bencher</span><span>| {
</span><span>        bencher</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>(|| {
</span><span>            </span><span style=color:#fa6e32>for</span><span> entity </span><span style=color:#ed9366>in &</span><span>entities {
</span><span>                </span><span style=color:#f07171>assert!</span><span>(query
</span><span>                    </span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> world</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>entity)
</span><span>                    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()
</span><span>                    </span><span style=color:#ed9366>.</span><span>get_components_mut</span><span style=color:#ed9366>::</span><span>&LTRefC32>()
</span><span>                    </span><span style=color:#ed9366>.</span><span style=color:#f07171>is_ok</span><span>())</span><span style=color:#61676ccc>;
</span><span>            }
</span><span>        })</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=4-crates-bevy-ecs-src-query-access-rs-1-1>4. <code>crates/bevy_ecs/src/query/access.rs</code> (+1/-1)</h3><p>Added <code>Hash</code> trait to <code>Access</code> struct to support hashing for the bloom filter.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Eq</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Access </span><span>{ </span><span style=color:#abb0b6;font-style:italic>/* ... */ </span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Eq</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Default</span><span style=color:#61676ccc>,</span><span> Hash)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Access </span><span>{ </span><span style=color:#abb0b6;font-style:italic>/* ... */ </span><span>}
</span></code></pre><h3 id=5-crates-bevy-utils-src-lib-rs-2-0>5. <code>crates/bevy_utils/src/lib.rs</code> (+2/-0)</h3><p>Exported the new bloom filter module.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>mod </span><span style=color:#399ee6>bloom_filter</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>pub use </span><span>bloom_filter</span><span style=color:#ed9366>::*</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bloom Filters</strong>: <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Bloom_filter target=_blank>Wikipedia article on Bloom filters</a> provides a good overview of the probabilistic data structure used in this PR.</p><li><p><strong>Bevy ECS Documentation</strong>: <a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/books/the-introduction/3-pipeline/3.1-ecs target=_blank>Bevy’s ECS documentation</a> explains the entity-component-system architecture that this optimization improves.</p><li><p><strong>Time Complexity Analysis</strong>: <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Big_O_notation target=_blank>Big O notation</a> is essential for understanding the performance characteristics discussed in this PR.</p><li><p><strong>Rust Hash Traits</strong>: <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/std/hash/index.html target=_blank>Rust’s std::hash module documentation</a> explains how hashing works in Rust, which is used by the bloom filter.</p><li><p><strong>Original Issue</strong>: <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/22483 target=_blank>GitHub Issue #22483</a> provides context about the performance problem this PR solves.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22572.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>