<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22326 Add render diagnostic functions for reading from a buffer
        
    </title><meta content="#22326 Add render diagnostic functions for reading from a buffer" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-07</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22326-zh-cn-20260107>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=add-render-diagnostic-functions-for-reading-from-a-buffer>Add render diagnostic functions for reading from a buffer</h2><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add render diagnostic functions for reading from a buffer<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22326<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, A-Diagnostics, M-Release-Note, X-Uncontroversial<li><strong>Created</strong>: 2025-12-31T18:06:58Z<li><strong>Merged</strong>: 2026-01-07T06:19:25Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>See release note file.<p>Tested locally on a modified copy of Solari.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a specific limitation in Bevy’s render diagnostics system. Prior to this change, developers could measure GPU execution times and track performance metrics, but there was no straightforward way to read custom numerical data from GPU buffers and expose it through the diagnostic system. This capability is particularly useful for monitoring GPU-computed values like particle counts, simulation metrics, or custom rendering statistics that are computed on the GPU and stored in buffers.<p>The core problem was architectural: GPU buffers typically can’t be directly read by the CPU without explicit synchronization and data transfer operations. The existing diagnostics system was designed around timing measurements using timestamp queries, but lacked the infrastructure to handle buffer reads.<p>The solution approach extends the existing <code>RecordDiagnostics</code> trait with two new methods: <code>record_f32</code> and <code>record_u32</code>. These methods accept a buffer slice containing a single 32-bit value and orchestrate its transfer from GPU to CPU memory, then expose it through Bevy’s diagnostic system. The implementation follows a pattern consistent with Bevy’s existing render diagnostics, using the same async mapping approach already established for timestamp queries.<p>From an implementation perspective, the changes are relatively contained but require careful handling of GPU-CPU synchronization. When a developer calls <code>record_f32</code> or <code>record_u32</code>, the system creates a staging buffer with <code>MAP_READ</code> usage, copies the data from the source buffer using <code>copy_buffer_to_buffer</code>, and schedules the buffer to be mapped after command submission. The actual value extraction happens when the frame completes and the buffer becomes available for CPU reading.<p>The key technical insight is that this leverages the same deferred processing mechanism already used for timestamp queries. The <code>FrameData</code> struct now maintains a <code>value_buffers</code> vector that stores buffers awaiting CPU readback, alongside their diagnostic names and type information. When the frame completes, these buffers are processed alongside the timestamp queries, converting the raw bytes to the appropriate numeric type (f32 or u32) and then to f64 for consistency with the existing diagnostic system.<p>There are important constraints documented in the API: the buffer slice must be exactly 4 bytes, and the source buffer must have <code>BufferUsages::COPY_SRC</code>. These requirements ensure correctness and prevent runtime errors. The assertions in the code provide clear error messages when these conditions aren’t met.<p>The impact of this change is straightforward: it enables render graph nodes and GPU compute shaders to expose computed metrics through Bevy’s existing diagnostic infrastructure. This is particularly valuable for debugging and performance monitoring of GPU-driven systems where critical data lives in GPU memory. The integration with the existing diagnostic path system means these values appear alongside other render diagnostics with paths like “render/my_diagnostics/foo”, maintaining consistency with Bevy’s diagnostic conventions.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[GPU Compute Shader] --> B[Write to GPU Buffer]
</span><span>    B --> C[BufferSlice 4 bytes]
</span><span>    C --> D[record_f32/record_u32 call]
</span><span>    D --> E[Create Staging Buffer]
</span><span>    E --> F[Copy via CommandEncoder]
</span><span>    F --> G[Map Buffer for Reading]
</span><span>    G --> H[FrameData.value_buffers]
</span><span>    H --> I[Frame Completion]
</span><span>    I --> J[Read Mapped Buffer]
</span><span>    J --> K[Convert to f64]
</span><span>    K --> L[RenderDiagnostic]
</span><span>    L --> M[Bevy Diagnostic System]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><strong><code>crates/bevy_render/src/diagnostic/internal.rs</code></strong> (+101/-2) <ul><li>Added <code>record_f32</code> and <code>record_u32</code> methods to <code>DiagnosticsRecorder</code> implementation<li>Added <code>record_value</code> method to <code>FrameData</code> for handling buffer copy and mapping<li>Extended <code>FrameData</code> struct to store pending value buffers<li>Added processing logic for value buffers during frame completion</ul></ol><p>Key code additions:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// New methods in DiagnosticsRecorder implementation
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>record_f32</span><span>&LTN>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>command_encoder</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> CommandEncoder, </span><span style=color:#ff8f40>buffer</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>BufferSlice, </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>:</span><span> N)
</span><span style=color:#fa6e32>where
</span><span>    N</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTCow<</span><span style=color:#fa6e32>'static</span><span>, </span><span style=color:#fa6e32>str</span><span>>>,
</span><span>{
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(
</span><span>        buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>()</span><span style=color:#61676ccc>,
</span><span>        BufferSize</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>4</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#86b300>"DiagnosticsRecorder::record_f32 buffer slice must be 4 bytes long"
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... validation and call to record_value
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// New field in FrameData struct
</span><span>value_buffers</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Buffer, Cow<</span><span style=color:#fa6e32>'static</span><span>, </span><span style=color:#fa6e32>str</span><span>>, </span><span style=color:#fa6e32>bool</span><span>)></span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// New method in FrameData implementation
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>record_value</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>command_encoder</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> CommandEncoder,
</span><span>    </span><span style=color:#ff8f40>buffer</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>BufferSlice,
</span><span>    </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>: </span><span>Cow<</span><span style=color:#fa6e32>'static</span><span>, </span><span style=color:#fa6e32>str</span><span>>,
</span><span>    </span><span style=color:#ff8f40>is_f32</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Create staging buffer, copy data, and map it
</span><span>    </span><span style=color:#fa6e32>let</span><span> dest_buffer </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>device</span><span style=color:#ed9366>.</span><span style=color:#f07171>create_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>BufferDescriptor {
</span><span>        label</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"render_diagnostic_</span><span style=color:#ff8f40>{name}</span><span style=color:#86b300>"</span><span>))</span><span style=color:#61676ccc>,
</span><span>        size</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>,
</span><span>        usage</span><span style=color:#61676ccc>: </span><span>BufferUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>COPY_DST </span><span style=color:#ed9366>| </span><span>BufferUsages</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAP_READ</span><span style=color:#61676ccc>,
</span><span>        mapped_at_creation</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>
</span><span>    command_encoder</span><span style=color:#ed9366>.</span><span style=color:#f07171>copy_buffer_to_buffer</span><span>(
</span><span>        buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>buffer</span><span>()</span><span style=color:#61676ccc>,
</span><span>        buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>offset</span><span>()</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>&</span><span>dest_buffer</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>
</span><span>    command_encoder</span><span style=color:#ed9366>.</span><span style=color:#f07171>map_buffer_on_submit</span><span>(</span><span style=color:#ed9366>&</span><span>dest_buffer</span><span style=color:#61676ccc>, </span><span>MapMode</span><span style=color:#ed9366>::</span><span>Read</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>..</span><span style=color:#61676ccc>, </span><span>|_| {})</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>value_buffers</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((dest_buffer</span><span style=color:#61676ccc>,</span><span> name</span><span style=color:#61676ccc>,</span><span> is_f32))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=2><li><strong><code>crates/bevy_render/src/diagnostic/mod.rs</code></strong> (+33/-0) <ul><li>Added <code>record_f32</code> and <code>record_u32</code> to the <code>RecordDiagnostics</code> trait<li>Implemented these methods for <code>Option&LTArc&LTT>></code> wrapper<li>Updated documentation with usage instructions</ul></ol><p>Key code additions:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Reads a f32 from the specified buffer and uploads it as a diagnostic.
</span><span style=color:#abb0b6;font-style:italic>///
</span><span style=color:#abb0b6;font-style:italic>/// The provided buffer slice must be 4 bytes long, and the buffer must have [`wgpu::BufferUsages::COPY_SRC`];
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>record_f32</span><span>&LTN>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>command_encoder</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> CommandEncoder, </span><span style=color:#ff8f40>buffer</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>BufferSlice, </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>:</span><span> N)
</span><span style=color:#fa6e32>where
</span><span>    N</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTCow<</span><span style=color:#fa6e32>'static</span><span>, </span><span style=color:#fa6e32>str</span><span>>>;
</span><span>
</span><span>impl&LTT</span><span style=color:#61676ccc>:</span><span> RecordDiagnostics> RecordDiagnostics </span><span style=color:#fa6e32>for </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTArc&LTT>> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>record_f32</span><span>&LTN>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>command_encoder</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> CommandEncoder, </span><span style=color:#ff8f40>buffer</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>BufferSlice, </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>:</span><span> N)
</span><span>    </span><span style=color:#fa6e32>where
</span><span>        N</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTCow<</span><span style=color:#fa6e32>'static</span><span>, </span><span style=color:#fa6e32>str</span><span>>>,
</span><span>    {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(recorder) </span><span style=color:#ed9366>= &</span><span style=color:#55b4d4;font-style:italic>self </span><span>{
</span><span>            recorder</span><span style=color:#ed9366>.</span><span style=color:#f07171>record_f32</span><span>(command_encoder</span><span style=color:#61676ccc>,</span><span> buffer</span><span style=color:#61676ccc>,</span><span> name)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... similar for record_u32
</span><span>}
</span></code></pre><ol start=3><li><strong><code>release-content/release-notes/render_diagnostics_additions.md</code></strong> (+35/-0) <ul><li>Created new release note documenting the feature<li>Provided example usage in a <code>ViewNode</code> implementation</ul></ol><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/#buffer-mapping target=_blank>WebGPU Buffer Mapping</a> - WebGPU specification on buffer mapping operations<li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy/latest/bevy/render/diagnostic/index.html target=_blank>Bevy Render Diagnostics Documentation</a> - Existing Bevy render diagnostics system<li><a rel="noopener nofollow noreferrer" href=https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps target=_blank>GPU Timestamp Queries</a> - Background on GPU timestamp queries (similar async pattern)<li><a rel="noopener nofollow noreferrer" href=https://docs.rs/wgpu/latest/wgpu/struct.BufferUsages.html target=_blank>wgpu Buffer Usage Flags</a> - Documentation on buffer usage constraints</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22326.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>