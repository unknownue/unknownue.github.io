<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22372 Fix Area Light Specular Over-Brightness
        
    </title><meta content="#22372 Fix Area Light Specular Over-Brightness" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-06</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-01/pr-22372-en-20260106>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=xiu-fu-qu-yu-guang-yuan-gao-guang-guo-liang-wen-ti>修复区域光源高光过亮问题</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Fix Area Light Specular Over-Brightness<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/22372<li><strong>作者</strong>: aevyrie<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: C-Bug, A-Rendering, S-Ready-For-Final-Review, X-Uncontroversial, M-Deliberate-Rendering-Change, C-Refinement<li><strong>创建时间</strong>: 2026-01-04T07:09:49Z<li><strong>合并时间</strong>: 2026-01-06T01:54:06Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h3 id=mu-biao>目标</h3><ul><li>修复我们在区域（点）光源实现中的高光过亮问题。<li>关闭 https://github.com/bevyengine/bevy/issues/13327</ul><h3 id=jie-jue-fang-an>解决方案</h3><ul><li>应用修改后的（<code>a_prime</code>）高光粗糙度代替<em>基础</em>粗糙度。这允许高光根据 Karis 2013 正确随距离展宽和衰减。<li>这种方法唯一的缺点是光滑材料上的高光反射会被过度衰减。这是 Karis 2013 的一个已知问题，解决方案是实现更流行的解决方案，如线性变换余弦（Linearly Transformed Cosines）来更正确地处理区域光源。<li>与此同时，我应用了一个修正，在基础粗糙度和修改后的区域光源粗糙度之间进行插值，以保留光泽材料的锐利度和亮度。这是根据参考渲染进行调整的。</ul><h3 id=ce-shi>测试</h3><h4 id=can-kao-blender>参考（Blender）</h4><img alt=image height=900 src=https://github.com/user-attachments/assets/34e1b3a5-5595-4049-93ae-55918c7aabb4 width=1600><h4 id=xiu-gai-qian>修改前</h4><img alt=image height=864 src=https://github.com/user-attachments/assets/493f01e8-d6cd-411f-9e6c-daed31954d48 width=1392><h4 id=xiu-gai-hou>修改后</h4><img alt=image height=864 src=https://github.com/user-attachments/assets/1f1010fa-d3ba-42d7-9991-5ee1dd63f668 width=1392><h4 id=rui-li-can-kao-blender>锐利参考（Blender）</h4><img alt=image height=900 src=https://github.com/user-attachments/assets/c837b66f-f42b-4bc1-9480-caff3e9ea4ce width=1600><h4 id=rui-li-xiu-gai-qian>锐利修改前</h4><img alt=image height=864 src=https://github.com/user-attachments/assets/77507d7c-9cff-4ca2-9d96-5f7aa1fb24d1 width=1392><h4 id=rui-li-xiu-gai-hou>锐利修改后</h4><img alt=image height=864 src=https://github.com/user-attachments/assets/dbced8e0-d725-4cba-a368-7ccf979a5c79 width=1392><hr><h2 id=zhan-shi>展示</h2><img alt=image height=684 src=https://github.com/user-attachments/assets/520b0f56-3e1d-4289-9c86-2105539b89de width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/11faccfc-248f-4790-a915-48ff710c7cca width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/7799be03-f70d-4970-8917-a026e7d7d032 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/a6418770-6a5f-431b-aad0-ef9f0c9b4bfc width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/844cd2e3-969e-4914-8745-10584dc1cc47 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/3596a07e-2938-435c-8948-b4ed27408b74 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/0e38ce4f-ee4e-478c-89c9-0b79835220e7 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/bbd0e915-1afc-42ca-b44a-82547f21f0c5 width=1072><img alt=image height=864 src=https://github.com/user-attachments/assets/9863f227-e8a8-4eb8-9c95-d3b102b223a9 width=1392><img alt=image height=864 src=https://github.com/user-attachments/assets/41177b31-f05b-4e05-8ece-1d6a0210cb6b width=1392><h2 id=zhe-ge-prde-gu-shi>这个PR的故事</h2><h3 id=wen-ti-he-bei-jing>问题和背景</h3><p>这个PR解决了一个物理渲染中的技术问题：在Bevy引擎中，区域光源（表现为点光源）的高光反射会过度明亮，这在物理上是不正确的。问题源自于实现区域光源高光计算时没有正确应用距离相关的粗糙度调整。<p>在物理渲染中，区域光源比点光源更复杂，因为光源有实际大小。当光源有一定半径时，高光反射会随着距离增加而展宽和衰减。原始的代码实现没有正确处理这种效果，导致高光保持过于集中和明亮，即使光源距离表面很远。<p>技术约束在于需要在实时渲染的框架内实现物理正确的结果。原始的Karis 2013方法虽然改进了一部分问题，但在光滑材质上会导致高光过度衰减，使其看起来比应有情况更粗糙和暗淡。<h3 id=jie-jue-fang-an-fang-fa>解决方案方法</h3><p>开发者采用了Karis 2013论文中的核心概念，但进行了改进。核心思路是：区域光源的高光粗糙度应该随着光源大小和距离的增加而增加。这通过计算修改后的粗糙度<code>a_prime</code>来实现：<pre style=color:#61676c;background-color:#fafafa><code><span>a_prime = saturate(a + light_radius / (2.0 * distance))
</span></code></pre><p>然而，直接应用这个公式会导致光滑材质上的高光变得太暗。因此开发者添加了一个修正函数<code>specular_fix_remap</code>，在基础粗糙度<code>a</code>和修改后的粗糙度<code>a_prime</code>之间进行插值。这个插值基于一个经过手动调整的曲线，以匹配参考渲染结果。<h3 id=shi-xian-xi-jie>实现细节</h3><p>主要的修改集中在<code>pbr_lighting.wgsl</code>文件中。最关键的改变是<code>compute_specular_layer_values_for_point_light</code>函数的重构。原本这个函数返回高光强度和光照方向，现在改为返回光照方向和修改后的粗糙度。<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 修改前：返回L在`xyz`分量，高光强度在`w`分量
</span><span>fn compute_specular_layer_values_for_point_light(
</span><span>    input: ptr&LTfunction, LightingInput>,
</span><span>    layer: u32,
</span><span>    V: vec3&LTf32>,
</span><span>    light_to_frag: vec3&LTf32>,
</span><span>    light_position_radius: f32,
</span><span>) -> vec4&LTf32> {
</span><span>    // ... 旧代码 ...
</span><span>    let intensity = normalizationFactor * normalizationFactor;
</span><span>    return vec4(L, intensity);
</span><span>}
</span><span>
</span><span>// 修改后：返回L在`xyz`分量，修改后的粗糙度在`w`分量
</span><span>fn compute_specular_layer_values_for_point_light(
</span><span>    input: ptr&LTfunction, LightingInput>,
</span><span>    layer: u32,
</span><span>    V: vec3&LTf32>,
</span><span>    light_to_frag: vec3&LTf32>,
</span><span>    light_radius: f32,
</span><span>    distance: f32,
</span><span>) -> vec4&LTf32> {
</span><span>    // ... 新代码 ...
</span><span>    let a_prime = saturate(a + light_radius / (2.0 * distance));
</span><span>    return vec4(L, a_prime);
</span><span>}
</span></code></pre><p>高光强度现在在调用函数中计算：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>let normalizationFactor = a / a_prime;
</span><span>let specular_intensity = normalizationFactor * normalizationFactor;
</span></code></pre><p>对于光滑材质的修正通过新的<code>specular_fix_remap</code>函数实现：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn specular_fix_remap(a: f32) -> f32 {
</span><span>    let inv_a_sq = (1.0 - a) * (1.0 - a);
</span><span>    return 1.0 - inv_a_sq * inv_a_sq;
</span><span>}
</span></code></pre><p>这个函数为光滑材质（粗糙度接近0）返回接近1的值，为粗糙材质（粗糙度接近1）返回接近0的值。然后在<code>point_light</code>函数中：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>let brdf_roughness = mix(a, a_prime, specular_fix_remap(a));
</span></code></pre><p>这个修改后的粗糙度被传递给高光计算函数，而不是直接使用<code>a_prime</code>。<h3 id=ji-shu-dong-cha>技术洞察</h3><p>这个PR展示了实时渲染中一个常见的工程权衡：物理正确性与视觉质量的平衡。Karis 2013方法在物理上是更正确的，但会导致视觉上不理想的结果（光滑材质的高光过度衰减）。开发者通过添加一个经验性的修正函数来平衡这个问题。<p>另一个重要的技术细节是增加了区域光源的立体角衰减（solid-angle attenuation）。这是对物理的进一步改进，考虑了光源大小对可见性的影响：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>if light_radius > 0.0 {
</span><span>    let solid_angle = light_radius * light_radius / (distance * distance);
</span><span>    specular_light *= saturate(specular_derived_input.NdotL / max(specular_derived_input.NdotL + solid_angle, 1e-4));
</span><span>}
</span></code></pre><p>这个修正确保了当光源较大或距离较近时，高光会更均匀地分布在表面上。<h3 id=ying-xiang>影响</h3><p>这些修改显著改善了区域光源的视觉质量。对比渲染图显示：<ol><li>高光现在正确地随着距离增加而展宽和衰减<li>光滑材质上的高光保持了适当的锐利度和亮度<li>整体效果更接近Blender等离线渲染器的参考结果</ol><p>代码结构上的改进包括：<ul><li>更清晰的责任分离：<code>compute_specular_layer_values_for_point_light</code>现在只计算几何信息，不计算强度<li>更灵活的接口：高光计算函数现在接受明确的粗糙度参数，而不是从输入结构中读取<li>更好的可维护性：修正逻辑集中在一个函数中，便于未来调整</ul><p>这个解决方案被标记为临时性的，开发者明确指出理想的解决方案是切换到线性变换余弦（Linearly Transformed Cosines）方法，这在实时渲染社区中是处理区域光源的流行选择。<h2 id=shi-jue-biao-shi>视觉表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[点光源计算] --> B[compute_specular_layer_values_for_point_light]
</span><span>    B --> C{光源半径>0?}
</span><span>    C -->|是| D[计算a_prime = a + radius/(2*distance)]
</span><span>    C -->|否| E[使用基础粗糙度a]
</span><span>    D --> F[specular_fix_remap(a)]
</span><span>    F --> G[mix(a, a_prime, remap_value)]
</span><span>    G --> H[计算高光强度 = (a/a_prime)²]
</span><span>    E --> I[高光强度=1]
</span><span>    H --> J[应用立体角衰减]
</span><span>    I --> K[最终高光计算]
</span><span>    J --> K
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><h3 id=crates-bevy-pbr-src-render-pbr-lighting-wgsl-74-27><code>crates/bevy_pbr/src/render/pbr_lighting.wgsl</code> (+74/-27)</h3><p>这个WGSL着色器文件包含了所有物理渲染光照计算的实现。主要修改包括：<ol><li><strong>函数签名变更</strong> - <code>compute_specular_layer_values_for_point_light</code>现在返回修改后的粗糙度而不是高光强度：</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 修改前注释：
</span><span>// Returns L in the `xyz` components and the specular intensity in the `w` component.
</span><span>
</span><span>// 修改后注释：
</span><span>// Returns L in the `xyz` components and the modified roughness in the `w` component.
</span></code></pre><ol start=2><li><strong>新的修正函数</strong> - 添加了<code>specular_fix_remap</code>函数来处理光滑材质的高光过度衰减问题：</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 这是对 Karis 2013 区域光源方法的修改，用于修复光滑材质上的高光反射
</span><span>// 看起来太粗糙和暗淡的问题。我们通过一个经过参考渲染调整的lerp因子
</span><span>// 在基础粗糙度和Karis2013粗糙度之间进行插值。目标是保留光滑材质上
</span><span>// 的锐利高光，同时不使粗糙材质上的高光过曝。
</span><span>fn specular_fix_remap(a: f32) -> f32 {
</span><span>    let inv_a_sq = (1.0 - a) * (1.0 - a);
</span><span>    return 1.0 - inv_a_sq * inv_a_sq;
</span><span>}
</span></code></pre><ol start=3><li><strong>立体角衰减计算</strong> - 为区域光源添加了物理更正确的衰减：</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Sphere area light visibility (solid-angle attenuation)
</span><span>let light_radius = (*light).position_radius.w;
</span><span>if light_radius > 0.0 {
</span><span>    let solid_angle = light_radius * light_radius / (distance * distance);
</span><span>    specular_light *= saturate(specular_derived_input.NdotL / max(specular_derived_input.NdotL + solid_angle, 1e-4));
</span><span>}
</span></code></pre><ol start=4><li><strong>参数传递变更</strong> - 所有高光计算函数现在都接受显式的粗糙度参数：</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 修改前：
</span><span>fn specular(
</span><span>    input: ptr&LTfunction, LightingInput>,
</span><span>    derived_input: ptr&LTfunction, DerivedLightingInput>,
</span><span>    specular_intensity: f32,
</span><span>) -> vec3&LTf32> {
</span><span>    // 从输入结构中读取粗糙度
</span><span>    let roughness = (*input).layers[LAYER_BASE].roughness;
</span><span>    // ...
</span><span>}
</span><span>
</span><span>// 修改后：
</span><span>fn specular(
</span><span>    input: ptr&LTfunction, LightingInput>,
</span><span>    derived_input: ptr&LTfunction, DerivedLightingInput>,
</span><span>    roughness: f32,  // 显式传递粗糙度
</span><span>    specular_intensity: f32,
</span><span>) -> vec3&LTf32> {
</span><span>    // 直接使用传递的粗糙度参数
</span><span>    // ...
</span><span>}
</span></code></pre><p>这些修改共同解决了区域光源高光过亮的问题，同时保持了代码的可维护性和未来的可扩展性。<h2 id=jin-yi-bu-yue-du>进一步阅读</h2><ol><li><p><strong>Karis 2013</strong> - “Real Shading in Unreal Engine 4” (https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)</p> <ul><li>这篇论文是虚幻引擎4中PBR实现的基础，特别是其中关于区域光源处理的部分。</ul><li><p><strong>Linearly Transformed Cosines (LTC)</strong> - “Polygonal-Light Shading with Linearly Transformed Cosines” by Eric Heitz et al.</p> <ul><li>处理多边形光源的更先进方法，被作者提及为理想的长期解决方案。</ul><li><p><strong>Filament PBR文档</strong> - https://google.github.io/filament/Filament.html</p> <ul><li>Google的Filament渲染引擎文档，提供了PBR理论和实现的全面概述。</ul><li><p><strong>Physically Based Rendering: From Theory to Implementation</strong> - 第14章讨论了光源和反射模型</p> <ul><li>深入了解物理渲染中的光源建模和BRDF实现。</ul><li><p><strong>Bevy渲染架构</strong> - https://bevyengine.org/learn/book/rendering/</p> <ul><li>理解Bevy引擎渲染系统如何组织，有助于理解这些修改在更大上下文中的位置。</ul></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22372.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>