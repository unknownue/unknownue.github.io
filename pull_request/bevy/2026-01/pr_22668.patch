diff --git a/crates/bevy_anti_alias/src/dlss/node.rs b/crates/bevy_anti_alias/src/dlss/node.rs
index b73ac14b2b3fe..913f4ffc5d034 100644
--- a/crates/bevy_anti_alias/src/dlss/node.rs
+++ b/crates/bevy_anti_alias/src/dlss/node.rs
@@ -72,18 +72,15 @@ impl ViewNode for DlssNode<DlssSuperResolutionFeature> {
 
         let diagnostics = render_context.diagnostic_recorder();
         let command_encoder = render_context.command_encoder();
-        let mut dlss_context = dlss_context.context.lock().unwrap();
-
-        command_encoder.push_debug_group("dlss_super_resolution");
         let time_span = diagnostics.time_span(command_encoder, "dlss_super_resolution");
 
+        let mut dlss_context = dlss_context.context.lock().unwrap();
         let dlss_command_buffer = dlss_context
             .render(render_parameters, command_encoder, &adapter)
             .expect("Failed to render DLSS Super Resolution");
 
-        time_span.end(command_encoder);
-        command_encoder.pop_debug_group();
         render_context.add_command_buffer(dlss_command_buffer);
+        time_span.end(render_context.command_encoder());
 
         Ok(())
     }
@@ -149,19 +146,15 @@ impl ViewNode for DlssNode<DlssRayReconstructionFeature> {
 
         let diagnostics = render_context.diagnostic_recorder();
         let command_encoder = render_context.command_encoder();
-        let mut dlss_context = dlss_context.context.lock().unwrap();
-
-        command_encoder.push_debug_group("dlss_ray_reconstruction");
         let time_span = diagnostics.time_span(command_encoder, "dlss_ray_reconstruction");
 
+        let mut dlss_context = dlss_context.context.lock().unwrap();
         let dlss_command_buffer = dlss_context
             .render(render_parameters, command_encoder, &adapter)
             .expect("Failed to render DLSS Ray Reconstruction");
 
-        time_span.end(command_encoder);
-        command_encoder.pop_debug_group();
-
         render_context.add_command_buffer(dlss_command_buffer);
+        time_span.end(render_context.command_encoder());
 
         Ok(())
     }
diff --git a/crates/bevy_render/src/diagnostic/mod.rs b/crates/bevy_render/src/diagnostic/mod.rs
index 4eb31d39d6685..8fd41e5d2a265 100644
--- a/crates/bevy_render/src/diagnostic/mod.rs
+++ b/crates/bevy_render/src/diagnostic/mod.rs
@@ -46,7 +46,7 @@ use crate::renderer::{RenderDevice, RenderQueue};
 ///     ```ignore
 ///     let time_span = diagnostics.time_span(render_context.command_encoder(), "shadows");
 ///     ```
-///  3. End the span, providing the same encoder.
+///  3. End the span, providing the encoder (or the same render/compute pass).
 ///     ```ignore
 ///     time_span.end(render_context.command_encoder());
 ///     ```
@@ -151,7 +151,7 @@ pub struct TimeSpanGuard<'a, R: ?Sized, E> {
 }
 
 impl<R: RecordDiagnostics + ?Sized, E: WriteTimestamp> TimeSpanGuard<'_, R, E> {
-    /// End the span. You have to provide the same encoder which was used to begin the span.
+    /// End the span.
     pub fn end(self, encoder: &mut E) {
         self.recorder.end_time_span(encoder);
         core::mem::forget(self);
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 06b3b8389f524..fde58d542f5e3 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -601,7 +601,7 @@ fn update_performance_text(
         "Specular indirect",
         "render/solari_lighting/specular_indirect_lighting/elapsed_gpu",
     );
-    text.push_str(&format!("{:17}     TODO\n", "DLSS-RR"));
+    (add_diagnostic)("DLSS-RR", "render/dlss_ray_reconstruction/elapsed_gpu");
     text.push_str(&format!("{:17}  {total:.2} ms\n", "Total"));
 
     if let Some(world_cache_active_cells_count) = diagnostics
