<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22372 Fix Area Light Specular Over-Brightness
        
    </title><meta content="#22372 Fix Area Light Specular Over-Brightness" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-06</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22372-zh-cn-20260106>中文</a></div></div><div class=pr-content><h1 id=fix-area-light-specular-over-brightness>Fix Area Light Specular Over-Brightness</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix Area Light Specular Over-Brightness<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22372<li><strong>Author</strong>: aevyrie<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, S-Ready-For-Final-Review, X-Uncontroversial, M-Deliberate-Rendering-Change, C-Refinement<li><strong>Created</strong>: 2026-01-04T07:09:49Z<li><strong>Merged</strong>: 2026-01-06T01:54:06Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>Objective</strong><ul><li>Fix the over bright specular in our area (point) light implementation.<li>Close https://github.com/bevyengine/bevy/issues/13327</ul><p><strong>Solution</strong><ul><li>Apply the modified (<code>a_prime</code>) specular roughness instead of the <em>base</em> roughness. This allows specular to correctly broaden and fade with distance per Karis 2013.<li>The only downside of this approach is that specular reflections on smooth materials are over-attenuated. This is a known issue of Karis 2013, and the solution is to implement a popular solution like Linearly Transformed Cosines to handle area lights more correctly.<li>In the meantime, I’ve applied a correction that lerps between the base roughness and the modified area light roughness, to retain sharpness and brightness for glossy materials. This was tuned from the reference renders.</ul><p><strong>Testing</strong><p><strong>Reference (Blender)</strong></p><img alt=image height=900 src=https://github.com/user-attachments/assets/34e1b3a5-5595-4049-93ae-55918c7aabb4 width=1600><p><strong>Before</strong></p><img alt=image height=864 src=https://github.com/user-attachments/assets/493f01e8-d6cd-411f-9e6c-daed31954d48 width=1392><p><strong>After</strong></p><img alt=image height=864 src=https://github.com/user-attachments/assets/1f1010fa-d3ba-42d7-9991-5ee1dd63f668 width=1392><p><strong>Sharp Reference (Blender)</strong></p><img alt=image height=900 src=https://github.com/user-attachments/assets/c837b66f-f42b-4bc1-9480-caff3e9ea4ce width=1600><p><strong>Sharp Before</strong></p><img alt=image height=864 src=https://github.com/user-attachments/assets/77507d7c-9cff-4ca2-9d96-5f7aa1fb24d1 width=1392><p><strong>Sharp After</strong></p><img alt=image height=864 src=https://github.com/user-attachments/assets/dbced8e0-d725-4cba-a368-7ccf979a5c79 width=1392><hr><p><strong>Showcase</strong></p><img alt=image height=684 src=https://github.com/user-attachments/assets/520b0f56-3e1d-4289-9c86-2105539b89de width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/11faccfc-248f-4790-a915-48ff710c7cca width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/7799be03-f70d-4970-8917-a026e7d7d032 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/a6418770-6a5f-431b-aad0-ef9f0c9b4bfc width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/844cd2e3-969e-4914-8745-10584dc1cc47 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/3596a07e-2938-435c-8948-b4ed27408b74 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/0e38ce4f-ee4e-478c-89c9-0b79835220e7 width=1072><img alt=image height=684 src=https://github.com/user-attachments/assets/bbd0e915-1afc-42ca-b44a-82547f21f0c5 width=1072><img alt=image height=864 src=https://github.com/user-attachments/assets/9863f227-e8a8-4eb8-9c95-d3b102b223a9 width=1392><img alt=image height=864 src=https://github.com/user-attachments/assets/41177b31-f05b-4e05-8ece-1d6a0210cb6b width=1392><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a specific rendering artifact in Bevy’s physically-based rendering (PBR) pipeline where area lights (implemented as point lights with non-zero radius) produced specular highlights that were too bright and didn’t fade correctly with distance. The issue was tracked in GitHub issue #13327 and stemmed from an incorrect implementation of area light specular handling.<p>The problem was in how Bevy handled roughness calculations for area lights. In PBR rendering, when dealing with point lights that have a physical size (radius > 0), you can’t treat them as perfect infinitesimal points. The light’s physical size affects how specular reflections appear - larger light sources should produce broader, softer specular highlights that change appearance based on distance.<p>The existing implementation was calculating a specular intensity value directly, but this approach didn’t properly account for how roughness should change based on the light’s size and distance. According to the Karis 2013 paper (“Real Shading in Unreal Engine 4”), the correct approach is to modify the material’s roughness value based on the light’s radius and distance from the surface, creating what’s called <code>a_prime</code> (modified roughness).<p>The key technical insight here is that for area lights, the perceived roughness increases with both the light’s physical size and its distance from the surface. The formula <code>a_prime = saturate(a + light_radius / (2.0 * distance))</code> captures this relationship, where <code>a</code> is the base material roughness, <code>light_radius</code> is the light’s physical radius, and <code>distance</code> is the distance from the surface to the light.<p>However, directly applying this Karis 2013 approach has a known limitation: it over-attenuates specular reflections on smooth materials (low roughness). To work around this while maintaining physical accuracy for rough materials, the PR introduces a clever interpolation. Instead of using <code>a_prime</code> directly for all materials, it lerps between the base roughness <code>a</code> and <code>a_prime</code> using a remapping function:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>specular_fix_remap</span><span>(</span><span style=color:#ff8f40>a</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> inv_a_sq </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>-</span><span> a) </span><span style=color:#ed9366>* </span><span>(</span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>-</span><span> a)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>-</span><span> inv_a_sq </span><span style=color:#ed9366>*</span><span> inv_a_sq</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This function produces a lerp factor that approaches 1.0 for smooth materials (low roughness) and 0.0 for rough materials. The result is that smooth materials retain their sharp, bright specular highlights while rough materials correctly use the physically-based <code>a_prime</code> value. This remapping function was empirically tuned by comparing against reference renders from Blender.<p>Another important change is the addition of solid-angle attenuation for sphere area lights. When a light has physical size, its apparent brightness decreases as you move farther away, even beyond simple inverse-square falloff. The solid angle the light subtends affects visibility, and this is now accounted for with: <code>specular_light *= saturate(NdotL / max(NdotL + solid_angle, 1e-4))</code> where <code>solid_angle = light_radius * light_radius / (distance * distance)</code>.<p>The implementation required restructuring several parts of the lighting calculation. The <code>compute_specular_layer_values_for_point_light</code> function was changed to return the modified roughness (<code>a_prime</code>) in its <code>w</code> component instead of the specular intensity. This change cascaded through the codebase, requiring updates to how specular intensity is calculated and how roughness values are passed to the various specular BRDF functions (<code>specular</code>, <code>specular_clearcoat</code>, and <code>specular_anisotropy</code>).<p>The PR also fixes an architectural issue where NdotL (the cosine of the angle between surface normal and light direction) was being applied inconsistently. Previously, it was multiplied at the end of the lighting calculation. Now, diffuse and specular components track their own NdotL values separately, which is necessary because area lights can have different light directions for diffuse and specular calculations.<p>From an engineering perspective, this PR demonstrates a common pattern in graphics programming: implementing a physically-based solution (Karis 2013), identifying its practical limitations (over-attenuation on smooth materials), and applying an empirically-tuned correction that preserves the benefits while mitigating the downsides. The author explicitly acknowledges that a more complete solution would be to implement Linearly Transformed Cosines (LTC), a popular technique for accurate area light rendering, but provides this intermediate fix that significantly improves visual quality without requiring a major rendering system overhaul.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    subgraph "PBR Lighting System"
</span><span>        A[point_light function] --> B[compute_specular_layer_values_for_point_light]
</span><span>        A --> C[diffuse calculation]
</span><span>        B --> D["returns L_spec and a_prime"]
</span><span>        D --> E[derive_lighting_input]
</span><span>        E --> F[specular calculation]
</span><span>        D --> G["calculate specular_intensity = (a / a_prime)²"]
</span><span>        D --> H["calculate brdf_roughness = mix(a, a_prime, specular_fix_remap(a))"]
</span><span>        H --> F
</span><span>        G --> F
</span><span>        F --> I["apply solid-angle attenuation"]
</span><span>        I --> J[combine with diffuse]
</span><span>        C --> J
</span><span>        J --> K[apply light color and attenuation]
</span><span>    end
</span><span>    
</span><span>    subgraph "Clearcoat Layer"
</span><span>        L[clearcoat specular calculation] --> M[similar pipeline with clearcoat roughness]
</span><span>        M --> N["clearcoat solid-angle attenuation"]
</span><span>    end
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><p><strong>crates/bevy_pbr/src/render/pbr_lighting.wgsl</strong> (+74/-27)<p>This is the main shader file where all the lighting calculations happen. The changes are extensive but focused on fixing the area light specular calculation.<p>Key changes:<ol><li><strong>Modified function signature and return value</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Returns L in the `xyz` components and the specular intensity in the `w` component.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>compute_specular_layer_values_for_point_light</span><span>(
</span><span>    </span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span>ptr&LTfunction, LightingInput>,
</span><span>    </span><span style=color:#ff8f40>layer</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    </span><span style=color:#ff8f40>V</span><span style=color:#61676ccc>: </span><span>vec3<</span><span style=color:#fa6e32>f32</span><span>>,
</span><span>    </span><span style=color:#ff8f40>light_to_frag</span><span style=color:#61676ccc>: </span><span>vec3<</span><span style=color:#fa6e32>f32</span><span>>,
</span><span>    </span><span style=color:#ff8f40>light_position_radius</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>vec4<</span><span style=color:#fa6e32>f32</span><span>>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Returns L in the `xyz` components and the modified roughness in the `w` component.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>compute_specular_layer_values_for_point_light</span><span>(
</span><span>    </span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span>ptr&LTfunction, LightingInput>,
</span><span>    </span><span style=color:#ff8f40>layer</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    </span><span style=color:#ff8f40>V</span><span style=color:#61676ccc>: </span><span>vec3<</span><span style=color:#fa6e32>f32</span><span>>,
</span><span>    </span><span style=color:#ff8f40>light_to_frag</span><span style=color:#61676ccc>: </span><span>vec3<</span><span style=color:#fa6e32>f32</span><span>>,
</span><span>    </span><span style=color:#ff8f40>light_radius</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    </span><span style=color:#ff8f40>distance</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>vec4<</span><span style=color:#fa6e32>f32</span><span>>
</span></code></pre><ol start=2><li><strong>Changed roughness calculation</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (old intensity calculation):
</span><span style=color:#fa6e32>let</span><span> normalizationFactor </span><span style=color:#ed9366>=</span><span> a </span><span style=color:#ed9366>/ </span><span style=color:#f07171>saturate</span><span>(a </span><span style=color:#ed9366>+ </span><span>(light_position_radius </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>0.5 </span><span style=color:#ed9366>*</span><span> LspecLengthInverse))</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> intensity </span><span style=color:#ed9366>=</span><span> normalizationFactor </span><span style=color:#ed9366>*</span><span> normalizationFactor</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After (Karis 2013 a_prime calculation):
</span><span style=color:#fa6e32>let</span><span> a_prime </span><span style=color:#ed9366>= </span><span style=color:#f07171>saturate</span><span>(a </span><span style=color:#ed9366>+</span><span> light_radius </span><span style=color:#ed9366>/ </span><span>(</span><span style=color:#ff8f40>2.0 </span><span style=color:#ed9366>*</span><span> distance))</span><span style=color:#61676ccc>;
</span></code></pre><ol start=3><li><strong>Added specular fix remapping function</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>specular_fix_remap</span><span>(</span><span style=color:#ff8f40>a</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> inv_a_sq </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>-</span><span> a) </span><span style=color:#ed9366>* </span><span>(</span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>-</span><span> a)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>-</span><span> inv_a_sq </span><span style=color:#ed9366>*</span><span> inv_a_sq</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=4><li><strong>Updated specular function signatures to accept explicit roughness parameter</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>specular</span><span>(
</span><span>    </span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span>ptr&LTfunction, LightingInput>,
</span><span>    </span><span style=color:#ff8f40>derived_input</span><span style=color:#61676ccc>: </span><span>ptr&LTfunction, DerivedLightingInput>,
</span><span>    </span><span style=color:#ff8f40>specular_intensity</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>vec3<</span><span style=color:#fa6e32>f32</span><span>>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>specular</span><span>(
</span><span>    </span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span>ptr&LTfunction, LightingInput>,
</span><span>    </span><span style=color:#ff8f40>derived_input</span><span style=color:#61676ccc>: </span><span>ptr&LTfunction, DerivedLightingInput>,
</span><span>    </span><span style=color:#ff8f40>roughness</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    </span><span style=color:#ff8f40>specular_intensity</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>vec3<</span><span style=color:#fa6e32>f32</span><span>>
</span></code></pre><ol start=5><li><strong>Added solid-angle attenuation for sphere lights</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Sphere area light visibility (solid-angle attenuation)
</span><span style=color:#fa6e32>let</span><span> light_radius </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#ed9366>*</span><span>light)</span><span style=color:#ed9366>.</span><span>position_radius</span><span style=color:#ed9366>.</span><span>w</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>if</span><span> light_radius </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>0.0 </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> solid_angle </span><span style=color:#ed9366>=</span><span> light_radius </span><span style=color:#ed9366>*</span><span> light_radius </span><span style=color:#ed9366>/ </span><span>(distance </span><span style=color:#ed9366>*</span><span> distance)</span><span style=color:#61676ccc>;
</span><span>    specular_light </span><span style=color:#ed9366>*= </span><span style=color:#f07171>saturate</span><span>(specular_derived_input</span><span style=color:#ed9366>.</span><span>NdotL </span><span style=color:#ed9366>/ </span><span style=color:#f07171>max</span><span>(specular_derived_input</span><span style=color:#ed9366>.</span><span>NdotL </span><span style=color:#ed9366>+</span><span> solid_angle</span><span style=color:#61676ccc>,</span><span> 1e</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>4</span><span>))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=6><li><strong>Fixed NdotL handling in final color calculation</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (combined at the end):
</span><span style=color:#fa6e32>return</span><span> color </span><span style=color:#ed9366>* </span><span>(</span><span style=color:#ed9366>*</span><span>light)</span><span style=color:#ed9366>.</span><span>color_inverse_square_range</span><span style=color:#ed9366>.</span><span>rgb </span><span style=color:#ed9366>*
</span><span>    (rangeAttenuation </span><span style=color:#ed9366>*</span><span> derived_input</span><span style=color:#ed9366>.</span><span>NdotL) </span><span style=color:#ed9366>*</span><span> texture_sample</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After (separate NdotL for diffuse and specular):
</span><span style=color:#fa6e32>return</span><span> color_times_NdotL </span><span style=color:#ed9366>* </span><span>(</span><span style=color:#ed9366>*</span><span>light)</span><span style=color:#ed9366>.</span><span>color_inverse_square_range</span><span style=color:#ed9366>.</span><span>rgb </span><span style=color:#ed9366>*
</span><span>    rangeAttenuation </span><span style=color:#ed9366>*</span><span> texture_sample</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Karis 2013 - “Real Shading in Unreal Engine 4”</strong>: The original paper that introduces the <code>a_prime</code> concept for area lights. Available at: https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf</p><li><p><strong>Filament PBR Documentation</strong>: Comprehensive documentation on physically-based rendering concepts, including area lights. Available at: https://google.github.io/filament/Filament.html</p><li><p><strong>Linearly Transformed Cosines (LTC)</strong>: The more advanced technique mentioned as a future improvement. Original paper: “Real-Time Polygonal-Light Shading with Linearly Transformed Cosines” by Eric Heitz et al.</p><li><p><strong>Bevy PBR Rendering Documentation</strong>: For understanding how Bevy implements PBR rendering. Available in the Bevy repository at: https://github.com/bevyengine/bevy/tree/main/crates/bevy_pbr</p><li><p><strong>Physically Based Rendering: From Theory to Implementation</strong>: The classic textbook that covers fundamental PBR concepts, including light transport and BRDFs.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22372.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>