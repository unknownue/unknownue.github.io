<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22394 Text pipeline update buffer spans refactor
        
    </title><meta content="#22394 Text pipeline update buffer spans refactor" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-06</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22394-zh-cn-20260106>中文</a></div></div><div class=pr-content><h1 id=text-pipeline-update-buffer-spans-refactor>Text pipeline update buffer spans refactor</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Text pipeline update buffer spans refactor<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22394<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Code-Quality, S-Ready-For-Final-Review, A-Text, D-Straightforward<li><strong>Created</strong>: 2026-01-05T20:17:36Z<li><strong>Merged</strong>: 2026-01-06T20:14:00Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p><code>TextPipeline::update_buffer</code> uses a trick to cache the spans buffer’s capacity. It’s awkwardly implemented though, with the buffer recovery code repeated twice.<h2 id=solution>Solution</h2><p>Rework the function to remove the duplication of the spans buffer recovery code.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This pull request addresses a code quality issue in Bevy’s text rendering system, specifically in the <code>TextPipeline::update_buffer</code> method. The problem centered around an optimization technique that was correctly implemented but had redundant code that made maintenance more difficult than necessary.<p>The <code>update_buffer</code> method processes text spans for rendering using the cosmic-text library. It maintains a buffer called <code>spans_buffer</code> that stores span information between calls. To avoid unnecessary allocations, the implementation uses a capacity-preserving trick: after processing spans, it clears the buffer but maintains its allocated capacity by replacing it with a vector of dummy values. This optimization is sound, but the implementation had a structural flaw.<p>The original code handled buffer recovery in two separate places. When a font wasn’t found during processing, it would clear and recover the buffer before returning an error. When processing completed successfully, it would perform the same buffer recovery operation at the end of the function. This duplication created maintenance risk because any change to the buffer recovery logic would need to be made in two places.<p>The solution refactors the method to eliminate this duplication. The key insight was to wrap the main processing logic in a block that returns a <code>Result</code>, then handle buffer recovery once after that block completes, regardless of whether it succeeded or failed. This approach uses Rust’s error propagation mechanism to handle the early return case cleanly.<p>Here’s how the refactoring works technically. The original early error return looked like this:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(font) </span><span style=color:#ed9366>=</span><span> fonts</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// process font
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Return early if a font is not loaded yet.
</span><span>    spans</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>spans_buffer </span><span style=color:#ed9366>=</span><span> spans
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>into_iter</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(
</span><span>            |_| </span><span style=color:#61676ccc>-> </span><span>(
</span><span>                </span><span style=color:#fa6e32>usize</span><span>,
</span><span>                </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>,
</span><span>                </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> TextFont,
</span><span>                FontFaceInfo,
</span><span>                LineHeight,
</span><span>            ) { </span><span style=color:#f07171>unreachable!</span><span>() }</span><span style=color:#61676ccc>,
</span><span>        )
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(TextError</span><span style=color:#ed9366>::</span><span>NoSuchFont)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The refactored version simplifies this to:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> font </span><span style=color:#ed9366>=</span><span> fonts</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(TextError</span><span style=color:#ed9366>::</span><span>NoSuchFont)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre><p>The <code>?</code> operator propagates the error, but now the error occurs inside a block whose result is captured. After the block completes (whether with success or error), the buffer recovery code runs exactly once:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Recover the spans buffer.
</span><span>spans</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>spans_buffer </span><span style=color:#ed9366>=</span><span> spans
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>into_iter</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(
</span><span>        |_| </span><span style=color:#61676ccc>-> </span><span>(
</span><span>            </span><span style=color:#fa6e32>usize</span><span>,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> TextFont,
</span><span>            FontFaceInfo,
</span><span>            LineHeight,
</span><span>        ) { </span><span style=color:#f07171>unreachable!</span><span>() }</span><span style=color:#61676ccc>,
</span><span>    )
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>result
</span></code></pre><p>This pattern ensures that the buffer recovery logic has a single source of truth while preserving the optimization of maintaining buffer capacity between calls. The refactoring reduces the line count from 93 to 80 (a net reduction of 13 lines) while making the code more maintainable.<p>The changes don’t affect functionality or performance—they’re purely structural improvements. The buffer capacity optimization remains intact, and all text rendering behavior stays the same. This is a classic example of refactoring for maintainability: identifying duplicated logic, extracting it to a single location, and simplifying control flow.<p>From an engineering perspective, this refactoring demonstrates good use of Rust’s error handling patterns. The <code>?</code> operator allows for clean error propagation without nested conditionals, and wrapping the main logic in a block provides a clear boundary for when the buffer recovery should occur. This approach could be applied to similar patterns in other parts of the codebase where cleanup or recovery logic needs to run regardless of success or failure.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[update_buffer function] --> B[Original: Duplicate buffer recovery]
</span><span>    B --> C[Case 1: Early error return]
</span><span>    B --> D[Case 2: Success completion]
</span><span>    
</span><span>    A --> E[Refactored: Single buffer recovery]
</span><span>    E --> F[Processing block]
</span><span>    F --> G[Success: Ok(())]
</span><span>    F --> H[Error: Err(TextError)]
</span><span>    G --> I[Recover buffer once]
</span><span>    H --> I
</span><span>    I --> J[Return result]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-text-src-pipeline-rs-80-93><code>crates/bevy_text/src/pipeline.rs</code> (+80/-93)</h3><p>This file contains the <code>TextPipeline</code> implementation, which handles text layout and rendering using the cosmic-text library. The changes focus on the <code>update_buffer</code> method, which processes text spans and prepares them for rendering.<p>The key modification reorganizes the method to eliminate duplicated buffer recovery code. Before the change, the method had two separate sections that handled clearing and preserving the capacity of the <code>spans_buffer</code>. After the change, this logic appears only once at the end of the method.<p><strong>Key code changes:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Error handling with duplicated buffer recovery
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(font) </span><span style=color:#ed9366>=</span><span> fonts</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// process font
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Return early if a font is not loaded yet.
</span><span>    spans</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>spans_buffer </span><span style=color:#ed9366>=</span><span> spans
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>into_iter</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(
</span><span>            |_| </span><span style=color:#61676ccc>-> </span><span>(
</span><span>                </span><span style=color:#fa6e32>usize</span><span>,
</span><span>                </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>,
</span><span>                </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> TextFont,
</span><span>                FontFaceInfo,
</span><span>                LineHeight,
</span><span>            ) { </span><span style=color:#f07171>unreachable!</span><span>() }</span><span style=color:#61676ccc>,
</span><span>        )
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(TextError</span><span style=color:#ed9366>::</span><span>NoSuchFont)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// ... later in the function ...
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Buffer recovery code duplicated here for successful completion
</span><span>spans</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>spans_buffer </span><span style=color:#ed9366>=</span><span> spans
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>into_iter</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(
</span><span>        |_| </span><span style=color:#61676ccc>-> </span><span>(
</span><span>            </span><span style=color:#fa6e32>usize</span><span>,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> TextFont,
</span><span>            FontFaceInfo,
</span><span>            LineHeight,
</span><span>        ) { </span><span style=color:#f07171>unreachable!</span><span>() }</span><span style=color:#61676ccc>,
</span><span>    )
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// After: Single buffer recovery point
</span><span style=color:#fa6e32>let</span><span> result </span><span style=color:#ed9366>= </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// All processing logic, including error propagation with ?
</span><span>    </span><span style=color:#fa6e32>let</span><span> font </span><span style=color:#ed9366>=</span><span> fonts</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(TextError</span><span style=color:#ed9366>::</span><span>NoSuchFont)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... rest of processing
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Buffer recovery happens once, regardless of success or error
</span><span>spans</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>spans_buffer </span><span style=color:#ed9366>=</span><span> spans
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>into_iter</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(
</span><span>        |_| </span><span style=color:#61676ccc>-> </span><span>(
</span><span>            </span><span style=color:#fa6e32>usize</span><span>,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> TextFont,
</span><span>            FontFaceInfo,
</span><span>            LineHeight,
</span><span>        ) { </span><span style=color:#f07171>unreachable!</span><span>() }</span><span style=color:#61676ccc>,
</span><span>    )
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>result
</span></code></pre><p>The refactoring wraps the core processing logic in a block that captures its result, then performs buffer recovery once after the block completes. This ensures the recovery code runs whether the block succeeds or returns early due to an error.<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Rust Error Handling</strong>: The Rust Book’s chapter on error handling (https://doc.rust-lang.org/book/ch09-00-error-handling.html) explains the <code>Result</code> type and the <code>?</code> operator used in this refactoring.</p><li><p><strong>cosmic-text</strong>: The text layout library used by Bevy (https://github.com/pop-os/cosmic-text). Understanding this library helps contextualize the span processing in the <code>update_buffer</code> method.</p><li><p><strong>Code Refactoring Patterns</strong>: Martin Fowler’s “Refactoring: Improving the Design of Existing Code” covers common patterns for improving code structure, including eliminating duplicate code.</p><li><p><strong>Bevy Text Rendering</strong>: The Bevy engine’s documentation on text rendering (https://bevy-cheatbook.github.io/features/text.html) provides context for how text rendering works in the engine.</p><li><p><strong>RAII and Cleanup Patterns</strong>: While Rust uses RAII (Resource Acquisition Is Initialization) for most cleanup, this PR shows an alternative pattern for cases where cleanup must happen regardless of success or failure paths.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22394.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>