<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #18670 Remote entity reservation v9
        
    </title><meta content="#18670 Remote entity reservation v9" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-23</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-01/pr-18670-en-20260123>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><p>Remote entity reservation v9<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Remote entity reservation v9<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/18670<li><strong>Author</strong>: ElliottjPierce<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-ECS, M-Migration-Guide, X-Controversial, S-Needs-SME<li><strong>Created</strong>: 2025-04-01T19:41:01Z<li><strong>Merged</strong>: 2026-01-23T02:53:26Z<li><strong>Merged By</strong>: cart</ul><h2 id=description-translation>Description Translation</h2><p>解决 #18003<h1 id=objective>Objective</h1><p>这是相同目标的第9个版本。对于作为实体的资产，我们需要能够从任何线程预留实体。理想情况下，这可以在不依赖异步上下文、阻塞或等待的情况下完成。这些妥协中的任何一个都可能损害资产性能或破坏资产系统完全非阻塞的特性。<p>作为额外好处，这个PR使分配实体只需要 <code>&Entities</code> 而不是 <code>&mut</code>。<code>Entities::flush</code> 现在完全是可选的，意味着 <code>Entities</code> 的所有方法都不依赖于刷新，并且有保护措施防止对实体进行两次刷新。<p>（如果你好奇，v9实际上是从v8分支出来的。v8专注于 #18577（从不刷新实体），但这个版本仍然包含刷新。）<blockquote><p>这里有一份<a rel="noopener nofollow noreferrer" href=https://hackmd.io/@bevy/Bkjgqvcblx target=_blank>文档</a>也提供了一些背景信息。如果你没有关注这个问题，我强烈建议在深入研究代码之前先阅读它。</blockquote><h2 id=solution>Solution</h2><p>在组织上，我将底层的 <code>EntityAllocator</code> 从 <code>Entities</code> 中分离出来。这使得现在更容易阅读，等等，因为它更复杂了。<p>基本问题是我们需要能够从任何线程在任何时间分配一个实体。我们还需要能够释放一个实体。所以在分配器层面，有3个操作：<code>free</code>、<code>alloc</code>（当你知道 <code>free</code> 没有被调用时）和 <code>remote_alloc</code>（可以在任何时候调用）。这些操作都不能要求可变访问。<p>最大的挑战是有一个 <code>free</code> 实体列表等待被重用。这个列表需要在没有可变访问的情况下完全正常工作，需要可调整大小，并且需要在内存中固定。我最终使用了类似于 <a rel="noopener nofollow noreferrer" href=https://docs.rs/orx-split-vec/latest/orx_split_vec/ target=_blank><code>SplitVec</code></a> 的策略。这个依赖需要 <code>std</code>，并且提前知道最大容量让我们简化了实现，所以我在这里自己实现了。<h2 id=testing>Testing</h2><p>目前没有新的测试。可能值得在某个时候使用 <a rel="noopener nofollow noreferrer" href=https://docs.rs/loom/latest/loom/ target=_blank>loom</a>，但这需要一个额外的依赖、测试特定的 loom 特性标志，并对多个 crate 进行这种处理，特别是 bevy_platform。<h2 id=future-work>Future work</h2><p>#18577 仍然是一个好的最终目标。最终（就像 @maniwani 所说的那样会发生），我决定一次性完成所有这些既太有挑战性，也会增加太多复杂性。然而，v9 使得“从不刷新“在未来变得更容易接近得多。我遇到的最大问题是很多地方持有对实体 <code>Archetype</code> 的引用（但现在实体可能没有原型），并且到处检查原型可能实际上比刷新性能更差。也许。<p>现在 <code>alloc</code> 可以在没有可变访问的情况下调用，<code>free</code>（等）可以在不需要先 <code>flush</code> 的情况下调用，我们也可以潜在地加速许多不同的过程。<h2 id=costs>Costs</h2><details><summary>基准测试</summary> <pre class=language-txt data-lang=txt style=color:#61676c;background-color:#fafafa><code class=language-txt data-lang=txt><span>group                                           main_baseline                           remote_reservation_v9_baseline
</span><span>-----                                           -------------                           ------------------------------
</span><span>add_remove/sparse_set                           1.06   625.2±42.08µs        ? ?/sec     1.00   591.8±24.97µs        ? ?/sec
</span><span>add_remove/table                                1.00   883.9±66.56µs        ? ?/sec     1.06   941.1±34.62µs        ? ?/sec
</span><span>add_remove_very_big/table                       1.08     37.7±2.55ms        ? ?/sec     1.00     34.9±0.76ms        ? ?/sec
</span><span>added_archetypes/archetype_count/1000           1.13  688.8±175.58µs        ? ?/sec     1.00  608.6±137.61µs        ? ?/sec
</span><span>added_archetypes/archetype_count/200            1.13    72.7±18.97µs        ? ?/sec     1.00    64.2±20.78µs        ? ?/sec
</span><span>added_archetypes/archetype_count/2000           1.11  1086.7±290.33µs        ? ?/sec    1.00  977.2±118.15µs        ? ?/sec
</span><span>added_archetypes/archetype_count/5000           1.09      2.7±0.29ms        ? ?/sec     1.00      2.5±0.27ms        ? ?/sec
</span><span>despawn_world/10_entities                       1.00   695.6±13.85ns        ? ?/sec     1.09   760.4±40.01ns        ? ?/sec
</span><span>despawn_world/1_entities                        1.00   182.0±24.14ns        ? ?/sec     1.56   284.3±50.46ns        ? ?/sec
</span><span>despawn_world_recursive/10000_entities          1.00  1668.8±95.30µs        ? ?/sec     1.13  1878.0±111.75µs        ? ?/sec
</span><span>despawn_world_recursive/10_entities             1.00      2.3±0.04µs        ? ?/sec     1.05      2.4±0.09µs        ? ?/sec
</span><span>despawn_world_recursive/1_entities              1.00   382.2±36.07ns        ? ?/sec     1.41   539.1±60.46ns        ? ?/sec
</span><span>empty_archetypes/iter/10000                     1.07     12.8±1.61µs        ? ?/sec     1.00     12.0±0.49µs        ? ?/sec
</span><span>empty_archetypes/par_for_each/100               1.06      9.2±1.04µs        ? ?/sec     1.00      8.7±0.35µs        ? ?/sec
</span><span>empty_archetypes/par_for_each/1000              1.12     12.8±0.87µs        ? ?/sec     1.00     11.5±0.36µs        ? ?/sec
</span><span>empty_archetypes/par_for_each/10000             1.19     25.4±0.98µs        ? ?/sec     1.00     21.3±0.41µs        ? ?/sec
</span><span>empty_archetypes/par_for_each/2000              1.16     13.6±1.17µs        ? ?/sec     1.00     11.7±0.44µs        ? ?/sec
</span><span>empty_archetypes/par_for_each/500               1.08     11.1±0.70µs        ? ?/sec     1.00     10.3±0.28µs        ? ?/sec
</span><span>empty_commands/0_entities                       1.00      3.9±0.06ns        ? ?/sec     1.40      5.4±0.06ns        ? ?/sec
</span><span>entity_hash/entity_set_lookup_miss_gen/10000    1.00     41.6±6.26µs 229.0 MElem/sec    1.05     43.9±5.74µs 217.1 MElem/sec
</span><span>entity_hash/entity_set_lookup_miss_id/10000     1.25     44.5±5.30µs 214.2 MElem/sec    1.00     35.7±5.03µs 266.8 MElem/sec
</span><span>event_propagation/four_event_types              1.13   606.5±27.06µs        ? ?/sec     1.00    535.9±5.38µs        ? ?/sec
</span><span>event_propagation/single_event_type             1.12   870.3±27.20µs        ? ?/sec     1.00   776.4±18.86µs        ? ?/sec
</span><span>fake_commands/2000_commands                     1.00     12.1±0.08µs        ? ?/sec     1.28     15.4±0.25µs        ? ?/sec
</span><span>fake_commands/4000_commands                     1.00     24.2±0.26µs        ? ?/sec     1.28     30.9±0.38µs        ? ?/sec
</span><span>fake_commands/6000_commands                     1.00     36.3±0.50µs        ? ?/sec     1.27     46.2±0.48µs        ? ?/sec
</span><span>fake_commands/8000_commands                     1.00     48.3±0.15µs        ? ?/sec     1.28     61.6±0.87µs        ? ?/sec
</span><span>insert_simple/base                              1.29   403.9±79.33µs        ? ?/sec     1.00   312.1±56.57µs        ? ?/sec
</span><span>insert_simple/unbatched                         2.41  1021.5±234.06µs        ? ?/sec    1.00   423.2±17.00µs        ? ?/sec
</span><span>iter_fragmented/base                            1.00    346.6±8.58ns        ? ?/sec     1.40    485.0±9.30ns        ? ?/sec
</span><span>iter_fragmented/foreach                         1.07    141.4±6.76ns        ? ?/sec     1.00    132.4±3.85ns        ? ?/sec
</span><span>iter_fragmented_sparse/base                     1.19      7.9±0.16ns        ? ?/sec     1.00      6.6±0.09ns        ? ?/sec
</span><span>iter_simple/foreach_wide                        2.76     46.4±0.46µs        ? ?/sec     1.00     16.8±0.18µs        ? ?/sec
</span><span>iter_simple/foreach_wide_sparse_set             1.00    80.9±13.81µs        ? ?/sec     1.12    90.3±29.10µs        ? ?/sec
</span><span>observe/trigger_simple                          1.00    450.3±9.25µs        ? ?/sec     1.08    488.5±9.99µs        ? ?/sec
</span><span>query_get/50000_entities_table                  1.00    138.8±0.67µs        ? ?/sec     1.05    145.9±1.23µs        ? ?/sec
</span><span>query_get_many_5/50000_calls_sparse             1.06   607.3±14.47µs        ? ?/sec     1.00   570.5±42.57µs        ? ?/sec
</span><span>sized_commands_0_bytes/2000_commands            1.00     10.6±1.20µs        ? ?/sec     1.26     13.3±0.18µs        ? ?/sec
</span><span>sized_commands_0_bytes/4000_commands            1.00     20.6±0.33µs        ? ?/sec     1.29     26.5±0.42µs        ? ?/sec
</span><span>sized_commands_0_bytes/6000_commands            1.00     30.8±0.26µs        ? ?/sec     1.29     39.9±0.61µs        ? ?/sec
</span><span>sized_commands_0_bytes/8000_commands            1.00     41.4±0.77µs        ? ?/sec     1.28     53.1±0.65µs        ? ?/sec
</span><span>sized_commands_12_bytes/2000_commands           1.00     11.6±0.29µs        ? ?/sec     1.23     14.2±0.32µs        ? ?/sec
</span><span>sized_commands_12_bytes/4000_commands           1.00     22.8±3.30µs        ? ?/sec     1.24     28.3±0.30µs        ? ?/sec
</span><span>sized_commands_12_bytes/6000_commands           1.00     33.6±0.20µs        ? ?/sec     1.27     42.8±0.63µs        ? ?/sec
</span><span>sized_commands_12_bytes/8000_commands           1.00     48.8±6.10µs        ? ?/sec     1.22     59.7±0.76µs        ? ?/sec
</span><span>sized_commands_512_bytes/2000_commands          1.00     46.3±1.28µs        ? ?/sec     1.06     48.9±1.73µs        ? ?/sec
</span><span>sized_commands_512_bytes/4000_commands          1.00     90.5±2.06µs        ? ?/sec     1.08     97.4±3.33µs        ? ?/sec
</span><span>spawn_commands/2000_entities                    1.00   155.4±11.61µs        ? ?/sec     1.22   189.5±15.70µs        ? ?/sec
</span><span>spawn_commands/4000_entities                    1.00   303.7±15.69µs        ? ?/sec     1.22   371.1±18.58µs        ? ?/sec
</span><span>spawn_commands/6000_entities                    1.00   463.3±31.95µs        ? ?/sec     1.20   554.8±12.55µs        ? ?/sec
</span><span>spawn_commands/8000_entities                    1.00   619.7±44.57µs        ? ?/sec     1.19   734.9±16.71µs        ? ?/sec
</span><span>spawn_world/1000_entities                       1.06     41.5±2.97µs        ? ?/sec     1.00     39.1±2.94µs        ? ?/sec
</span><span>spawn_world/100_entities                        1.20      4.8±2.29µs        ? ?/sec     1.00      4.0±0.69µs        ? ?/sec
</span><span>spawn_world/10_entities                         1.15   461.9±80.36ns        ? ?/sec     1.00   400.5±26.17ns        ? ?/sec
</span><span>spawn_world/1_entities                          1.05     41.4±6.35ns        ? ?/sec     1.00     39.4±3.02ns        ? ?/sec
</span><span>world_get/50000_entities_sparse                 1.00    167.1±4.23µs        ? ?/sec     1.07    178.8±2.44µs        ? ?/sec
</span><span>world_query_get/50000_entities_sparse_wide      1.00    125.0±0.31µs        ? ?/sec     1.08   135.7±78.30µs        ? ?/sec
</span><span>world_query_iter/50000_entities_sparse          1.00     38.7±0.08µs        ? ?/sec     1.18     45.6±0.60µs        ? ?/sec
</span></code></pre></details><p><strong>解释基准测试：</strong><p>在大多数地方，v9与main相当甚至更快。一些显著的例外是“sized_commands“和“fake_commands“部分，但那里的回归纯粹是由于<code>Entities::flush</code>变慢了，但我们在其他地方弥补了这一点。这些命令实际上什么都不做，所以这不适用于实际用例。这些基准测试只是用来压力测试<code>CommandQueue</code>的。<p>v9导致显著且实际应用回归的唯一地方是“spawn_commands“，v9比main慢大约15%。这可以在以后改变，因为现在<code>alloc</code>不需要可变访问。考虑到“spawn_world“在v9上比main快大约20%，我期望我们可以将这15%的回归改为15%的改进。对于那些需要非常快spawn命令的用户来说，他们已经在使用某种形式的批量生成或直接世界访问了。<p>其他回归似乎要么是最小的、不现实的、将来容易纠正的，或者是错误的。我敢说“错误“，因为来回运行它们有时会产生不同的结果。我使用的是M2 Max，所以可能有些东西从性能核心跳转到效率核心之类的。（我期待标准化的基准测试硬件。）<p><strong>胜利：</strong> 我担心，如果没有“从不刷新“，这将是一个全面的回归，但我欣慰地发现情况并非如此。一些非常常见的操作，例如“insert_simple/unbatched“，在这个分支上比main快得多。基本上，在main上，<code>alloc</code>也会立即为实体添加<code>EntityMeta</code>，但在这个分支上，我们只在<code>set</code>中这样做。这似乎改善了时间缓存局部性，并导致了大约220%的改进。“added_arhcetype“也看到了20%-80%的改进，等等。“iter_simple/foreach_wide“也看到了270%的改进。<p>我认为在实践中，v9在实际调度中的表现会优于main。而且我认为向“从不刷新“迈进（即使只是针对少数操作，如<code>Commands::spawn</code>）将进一步提高性能。<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个PR的核心目标是解决实体分配器的一个重要限制：无法从任何线程在任何时间安全地分配实体。这是实现“资产即实体“功能的关键要求，其中资产加载可能发生在后台线程，但需要预留实体ID用于最终实体创建。<h3 id=wen-ti-bei-jing>问题背景</h3><p>Bevy的实体分配器最初设计时，假设实体分配总是在主线程或至少持有世界可变引用的情况下进行。这对于传统的游戏循环是足够的，但对于异步资产加载场景就产生了问题。当一个资产在后台线程加载时，它可能需要预留一个实体ID，但当前的设计要求必须有世界的可变访问权限（<code>&mut World</code>）或至少是<code>&mut Entities</code>。<p>issue #18003 描述了这个问题：为了支持“资产即实体“功能，需要能够从任何线程预留实体，而不阻塞或等待主线程。这需要重新设计实体分配器的并发模型。<h3 id=jie-jue-fang-an-jia-gou>解决方案架构</h3><p>作者采用了一个分层的方法来解决这个问题：<ol><li><p><strong>分离关注点</strong>：将<code>EntityAllocator</code>从<code>Entities</code>中分离出来，创建一个专门的<code>remote_allocator</code>模块。这使得代码更容易理解和维护。</p><li><p><strong>三种分配模式</strong>：</p> <ul><li><code>alloc()</code>：当知道没有并发的<code>free()</code>操作时使用（需要<code>&self</code>）<li><code>remote_alloc()</code>：可以在任何时候调用，处理并发访问（需要<code>&self</code>）<li><code>free()</code>：释放实体（需要<code>&mut self</code>）</ul><li><p><strong>内存布局优化</strong>：使用分块缓冲区（chunked buffer）设计，类似于<code>SplitVec</code>，但进行了定制以支持并发访问和内存固定。</p></ol><h3 id=ji-shu-shi-xian-xi-jie>技术实现细节</h3><p>新的分配器实现位于<code>crates/bevy_ecs/src/entity/remote_allocator.rs</code>中，核心设计包括几个关键组件：<p><strong>1. 分块缓冲区（FreeBuffer）</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>FreeBuffer</span><span>([Chunk; </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>NUM_CHUNKS as </span><span style=color:#fa6e32>usize</span><span>])</span><span style=color:#61676ccc>;
</span></code></pre><p>这个结构将空闲实体列表分割成多个块（chunk），每个块的大小是2的幂。第一个块大小为512，后续每个块大小翻倍。这种设计允许缓冲区动态增长而不需要重新分配整个缓冲区，同时保持内存地址固定，这对于并发访问至关重要。<p><strong>2. 空闲列表状态管理（FreeCount）</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>FreeCount</span><span>(AtomicU64)</span><span style=color:#61676ccc>;
</span></code></pre><p>这是一个高度优化的结构，在单个<code>AtomicU64</code>中编码了三个信息：<ul><li>33位：空闲列表长度（使用特殊的编码方式表示有符号33位整数）<li>1位：是否禁用长度（用于防止远程分配与释放操作冲突）<li>30位：生成计数器（用于区分相同长度的不同状态）</ul><p>这种紧凑的编码使得状态更新可以通过单次原子操作完成，提高了并发性能。<p><strong>3. 并发控制策略</strong> 远程分配（<code>remote_alloc()</code>）使用了一个精心设计的循环来安全地处理并发访问：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>remote_alloc</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity> {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> state </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>len</span><span style=color:#ed9366>.</span><span style=color:#f07171>state</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>Acquire)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>loop </span><span>{
</span><span>        </span><span style=color:#fa6e32>if</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_disabled</span><span>() {
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// 等待释放操作完成
</span><span>            </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        
</span><span>        </span><span style=color:#fa6e32>let</span><span> len </span><span style=color:#ed9366>=</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>length</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> index </span><span style=color:#ed9366>=</span><span> len</span><span style=color:#ed9366>.</span><span style=color:#f07171>checked_sub</span><span>(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> entity </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(index) }</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#fa6e32>let</span><span> ideal_state </span><span style=color:#ed9366>=</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>pop</span><span>(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>match </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>len</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_set_state</span><span>(state</span><span style=color:#61676ccc>,</span><span> ideal_state</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Relaxed</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Acquire) {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(entity)</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(new_state) </span><span style=color:#ed9366>=></span><span> state </span><span style=color:#ed9366>=</span><span> new_state</span><span style=color:#61676ccc>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>这个实现使用<code>compare_exchange</code>循环来确保在读取实体和更新状态之间没有发生冲突的<code>free()</code>操作。<p><strong>4. 内存顺序保证</strong> 代码中大量使用了<code>Ordering</code>参数来确保正确的内存顺序：<ul><li><code>Acquire</code>：确保读取最新的<code>free()</code>操作结果<li><code>Release</code>：确保<code>free()</code>操作对其他线程可见<li><code>Relaxed</code>：在已知没有数据竞争的情况下使用，以提高性能</ul><h3 id=xing-neng-quan-heng>性能权衡</h3><p>根据基准测试结果，这个实现带来了显著的性能改进，特别是在某些操作上：<ol><li><p><strong>显著改进的操作</strong>：</p> <ul><li><code>insert_simple/unbatched</code>：改进约220%<li><code>iter_simple/foreach_wide</code>：改进约270%<li>多个“added_archetypes“测试：改进20-80%</ul><li><p><strong>轻微回归的操作</strong>：</p> <ul><li><code>spawn_commands</code>：回归约15%，但这主要是由于<code>Entities::flush</code>变慢<li>一些命令相关的基准测试显示回归，但这些测试是人为的压力测试，不代表真实使用场景</ul></ol><p>作者指出，在<code>spawn_commands</code>上的回归是未来可以优化的，因为现在<code>alloc()</code>不再需要可变访问，有潜力将其转变为性能改进。<h3 id=jia-gou-ying-xiang>架构影响</h3><p>这个PR为未来的优化奠定了基础：<ol><li><strong>减少刷新需求</strong>：<code>Entities::flush</code>现在是可选的，为最终实现“从不刷新“（#18577）铺平了道路。<li><strong>更灵活的实体分配</strong>：现在可以从任何线程分配实体，支持异步资产加载。<li><strong>更安全的API</strong>：防止了双重刷实体，并提供了更好的错误检测。</ol><h3 id=gong-cheng-jue-ce>工程决策</h3><p>作者提到几个重要的工程决策：<ol><li><strong>没有完全实现“从不刷新“</strong>：虽然这是最终目标，但作者决定分阶段实现，因为一次性完成会增加太多复杂性。<li><strong>自定义实现而非使用现有库</strong>：作者参考了<code>SplitVec</code>的设计，但实现了自己的版本以避免<code>std</code>依赖，并针对特定用例优化。<li><strong>使用生成计数器而非版本向量</strong>：30位的生成计数器对于实际使用足够了，虽然理论上可能回绕，但在实践中几乎不可能发生。</ol><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    subgraph "远程分配器模块"
</span><span>        A[RemoteAllocator]
</span><span>        B[Allocator]
</span><span>        C[SharedAllocator]
</span><span>        
</span><span>        subgraph "共享组件"
</span><span>            D[FreeList]
</span><span>            E[FreshAllocator]
</span><span>        end
</span><span>        
</span><span>        subgraph "空闲列表"
</span><span>            F[FreeBuffer]
</span><span>            G[FreeCount]
</span><span>        end
</span><span>        
</span><span>        subgraph "分块缓冲区"
</span><span>            H[Chunk 0]
</span><span>            I[Chunk 1]
</span><span>            J[Chunk N]
</span><span>        end
</span><span>    end
</span><span>    
</span><span>    subgraph "原有ECS"
</span><span>        K[EntityAllocator]
</span><span>        L[Entities]
</span><span>        M[World]
</span><span>    end
</span><span>    
</span><span>    A --> C
</span><span>    B --> C
</span><span>    C --> D
</span><span>    C --> E
</span><span>    D --> F
</span><span>    D --> G
</span><span>    F --> H
</span><span>    F --> I
</span><span>    F --> J
</span><span>    K --> B
</span><span>    L --> K
</span><span>    M --> L
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-crates-bevy-ecs-src-entity-mod-rs>1. <code>crates/bevy_ecs/src/entity/mod.rs</code></h3><p>这个文件是修改的入口点，主要做了两件事：<ul><li>引入了新的<code>remote_allocator</code>模块<li>重构了<code>EntityAllocator</code>，将其实现委托给新的分配器</ul><p><strong>关键变化：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>EntityAllocator </span><span>{
</span><span>    free</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTEntity>,
</span><span>    free_len</span><span style=color:#61676ccc>:</span><span> AtomicUsize,
</span><span>    next_index</span><span style=color:#61676ccc>:</span><span> AtomicU32,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>EntityAllocator </span><span>{
</span><span>    inner</span><span style=color:#61676ccc>: </span><span>remote_allocator</span><span style=color:#ed9366>::</span><span>Allocator,
</span><span>}
</span></code></pre><p><strong>方法委托示例：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>alloc</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Entity {
</span><span>    </span><span style=color:#fa6e32>let</span><span> index </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self
</span><span>        </span><span style=color:#ed9366>.</span><span>free_len
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>fetch_sub</span><span>(</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Relaxed)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>wrapping_sub</span><span>(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>free</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>copied</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or_else</span><span>(|| {
</span><span>        </span><span style=color:#fa6e32>let</span><span> index </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>next_index</span><span style=color:#ed9366>.</span><span style=color:#f07171>fetch_add</span><span>(</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Relaxed)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> index </span><span style=color:#ed9366>= </span><span>NonMaxU32</span><span style=color:#ed9366>::</span><span>new(index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"too many entities"</span><span>)</span><span style=color:#61676ccc>;
</span><span>        Entity</span><span style=color:#ed9366>::</span><span>from_index(EntityIndex</span><span style=color:#ed9366>::</span><span>new(index))
</span><span>    })
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>alloc</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Entity {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>inner</span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc</span><span>()
</span><span>}
</span></code></pre><h3 id=2-crates-bevy-ecs-src-entity-remote-allocator-rs-xin-wen-jian>2. <code>crates/bevy_ecs/src/entity/remote_allocator.rs</code> (新文件)</h3><p>这是实现的核心，包含所有新的并发分配器逻辑。<p><strong>主要组件：</strong><ol><li><strong>Slot</strong>：存储实体的单元，类似于<code>MaybeUninit&LTEntity></code><li><strong>Chunk</strong>：固定大小的内存块，包含多个<code>Slot</code><li><strong>FreeBuffer</strong>：分块缓冲区，管理所有<code>Chunk</code><li><strong>FreeCount</strong>：原子状态管理，编码长度、禁用标志和生成计数器<li><strong>FreeList</strong>：空闲实体列表，组合<code>FreeBuffer</code>和<code>FreeCount</code><li><strong>SharedAllocator</strong>：共享的核心分配器，组合<code>FreeList</code>和<code>FreshAllocator</code><li><strong>Allocator</strong>：主要的分配器接口，持有<code>SharedAllocator</code>的<code>Arc</code><li><strong>RemoteAllocator</strong>：远程分配器，可安全克隆，用于异步上下文</ol><p><strong>核心算法示例 - 远程分配：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>remote_alloc</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity> {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> state </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>len</span><span style=color:#ed9366>.</span><span style=color:#f07171>state</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>Acquire)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>loop </span><span>{
</span><span>        </span><span style=color:#fa6e32>if</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_disabled</span><span>() {
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// 等待释放操作完成
</span><span>            </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        
</span><span>        </span><span style=color:#fa6e32>let</span><span> len </span><span style=color:#ed9366>=</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>length</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> index </span><span style=color:#ed9366>=</span><span> len</span><span style=color:#ed9366>.</span><span style=color:#f07171>checked_sub</span><span>(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> entity </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(index) }</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#fa6e32>let</span><span> ideal_state </span><span style=color:#ed9366>=</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>pop</span><span>(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>match </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>len</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_set_state</span><span>(state</span><span style=color:#61676ccc>,</span><span> ideal_state</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Relaxed</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Acquire) {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(entity)</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(new_state) </span><span style=color:#ed9366>=></span><span> state </span><span style=color:#ed9366>=</span><span> new_state</span><span style=color:#61676ccc>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy实体系统文档</strong>：https://bevy-cheatbook.github.io/programming/entities.html<li><strong>并发数据结构设计</strong>：<em>The Art of Multiprocessor Programming</em> by Maurice Herlihy and Nir Shavit<li><strong>原子操作和内存顺序</strong>：Rust官方文档中的<a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/nomicon/atomics.html target=_blank>原子操作章节</a><li><strong>SplitVec设计理念</strong>：https://docs.rs/orx-split-vec/latest/orx_split_vec/<li><strong>无锁编程模式</strong>：https://preshing.com/20120612/an-introduction-to-lock-free-programming/<li><strong>Bevy资产系统</strong>：https://bevy-cheatbook.github.io/features/assets.html</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_18670.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>