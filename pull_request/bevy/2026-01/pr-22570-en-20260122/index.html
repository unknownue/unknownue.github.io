<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22570 Solari: Better path termination heuristic
        
    </title><meta content="#22570 Solari: Better path termination heuristic" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-22</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22570-zh-cn-20260122>中文</a></div></div><div class=pr-content><h1 id=solari-better-path-termination-heuristic>Solari: Better path termination heuristic</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari: Better path termination heuristic<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22570<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, S-Ready-For-Final-Review<li><strong>Created</strong>: 2026-01-17T18:22:38Z<li><strong>Merged</strong>: 2026-01-22T18:07:20Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>I was using a path termination heuristic designed for a radiance cache, but solari uses an irradiance cache. Whoops.<p>This new heuristic is inspired by RTXGI, and prevents the world cache from showing up in reflections properly.<p>To test, move the camera close to a mirror surface.<hr><p>Also contains some bugfixes for bugs introduced in #22468.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The PR addresses a fundamental mismatch in Bevy’s Solari global illumination system. The developer discovered that the path termination heuristic being used was originally designed for a radiance cache, but Solari implements an irradiance cache. This mismatch caused visible artifacts where the world cache would incorrectly appear in reflections, particularly noticeable when viewing mirror surfaces up close.<p>The core issue centered around how the system decides when to terminate a ray path in the world cache versus continuing to trace it. The original approach used a heuristic from research on radiance caches, which wasn’t appropriate for the irradiance cache implementation in Solari. This led to premature termination of rays, causing the world cache data to show up where it shouldn’t, breaking the visual correctness of reflections.<p>The solution implements a new termination heuristic inspired by NVIDIA’s RTXGI (Real-Time Global Illumination) system. The key insight is to base termination decisions on both the length of the ray and the accumulated spread of the path. The new approach uses two conditions that must both be true before terminating in the world cache:<ol><li>The ray must be longer than the diagonal of a world cache cell<li>The path spread must be larger than the square of the world cache cell size</ol><p>This dual-condition approach ensures that rays terminate in the world cache only when they’ve traveled far enough and become diffuse enough, preventing the world cache from appearing in sharp reflections.<p>The implementation required several coordinated changes across the codebase. In <code>specular_gi.wgsl</code>, the developer replaced the old termination logic with the new RTXGI-inspired heuristic. A new <code>path_spread_heuristic</code> function was added to calculate how much a ray spreads based on its length and the roughness of the surface it hits. This function uses the formula <code>distance² × 0.5 × (α² / (1 - α²))</code> where α is the roughness, which models how quickly a ray diverges based on surface roughness.<p>During implementation, the developer also fixed a bug introduced in a previous PR (#22468) related to how light contributions were calculated in the world cache update system. The bug was in the RIS (Resampled Importance Sampling) implementation where the target function and selected sample weren’t using consistent calculations - one used radiance multiplied by cosine, while the other used just radiance. This was corrected to ensure both calculations use the same cosine-weighted contribution.<p>Additionally, some cleanup was performed in <code>pathtracer.wgsl</code> where an unused <code>previous_normal</code> variable was removed, and an unused import was removed from <code>specular_gi.wgsl</code>.<p>The changes demonstrate an important principle in graphics programming: choosing the right algorithm for the specific data structure being used. While both radiance and irradiance caches serve similar high-level purposes, their different internal representations require different termination heuristics. The fix also shows the value of borrowing proven techniques from established industry solutions like RTXGI when appropriate.<p>From a performance perspective, the new heuristic is slightly more computationally expensive per bounce due to the additional calculations for path spread, but this is offset by more accurate termination decisions that prevent unnecessary ray tracing. The visual improvement is significant - mirror surfaces now show correct reflections without contamination from the world cache data.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[specular_gi.wgsl&LTbr/>Path Termination Logic] --> B{Termination Decision}
</span><span>    B -->|Old Heuristic| C[Premature Termination&LTbr/>World Cache in Reflections]
</span><span>    B -->|New Heuristic| D[Correct Termination&LTbr/>Clean Reflections]
</span><span>    
</span><span>    E[world_cache_update.wgsl&LTbr/>RIS Sampling] --> F{Consistency Check}
</span><span>    F -->|Before| G[Inconsistent Calculations]
</span><span>    F -->|After| H[Consistent Cosine-Weighting]
</span><span>    
</span><span>    I[pathtracer.wgsl] --> J[Cleanup: Remove&LTbr/>unused variables]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-specular-gi-wgsl-21-18><code>crates/bevy_solari/src/realtime/specular_gi.wgsl</code> (+21/-18)</h3><p>This file contains the main changes to the path termination heuristic and related calculations.<p><strong>Key Changes:</strong><ol><li>Replaced the old path termination heuristic with a new RTXGI-inspired one<li>Added <code>path_spread_heuristic</code> function to calculate ray spread based on distance and roughness<li>Removed unused import and old termination threshold constant</ol><p><strong>Before:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>const TERMINATE_IN_WORLD_CACHE_THRESHOLD: f32 = 0.03;
</span><span>
</span><span>// Old heuristic calculation
</span><span>let cos_theta = saturate(dot(wo, surface.world_normal));
</span><span>var a0 = dot(wo_unnormalized, wo_unnormalized) / (4.0 * PI * cos_theta);
</span><span>a0 *= TERMINATE_IN_WORLD_CACHE_THRESHOLD;
</span><span>
</span><span>radiance = trace_glossy_path(global_id.xy, surface, wi, pdf, a0, &rng) / pdf;
</span><span>
</span><span>// In trace_glossy_path:
</span><span>path_spread += sqrt((ray.t * ray.t) / (p_bounce * wo_tangent.z));
</span><span>
</span><span>if path_spread * path_spread > a0 * get_cell_size(ray_hit.world_position, view.world_position) {
</span><span>    // Terminate in world cache
</span><span>}
</span></code></pre><p><strong>After:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// New termination conditions
</span><span>let world_cache_cell_size = get_cell_size(ray_hit.world_position, view.world_position);
</span><span>let ray_longer_than_cell = ray.t > sqrt(3.0) * world_cache_cell_size;
</span><span>let path_spread_large_enough = path_spread > world_cache_cell_size * world_cache_cell_size;
</span><span>
</span><span>if ray_longer_than_cell && path_spread_large_enough {
</span><span>    // Terminate in world cache
</span><span>}
</span><span>
</span><span>// New path spread heuristic function
</span><span>fn path_spread_heuristic(ray_t: f32, roughness: f32) -> f32 {
</span><span>    let alpha_squared = min(roughness * roughness, 0.99);
</span><span>    let distance_squared = ray_t * ray_t;
</span><span>    return distance_squared * 0.5 * (alpha_squared / (1.0 - alpha_squared));
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-update-wgsl-3-2><code>crates/bevy_solari/src/realtime/world_cache_update.wgsl</code> (+3/-2)</h3><p>This file fixes a bug in the RIS (Resampled Importance Sampling) implementation.<p><strong>Key Changes:</strong> Fixed inconsistent calculations between target function evaluation and sample selection in RIS.<p><strong>Before:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>let target_function = luminance(light_contribution.radiance * saturate(dot(light_contribution.wi, world_normal)));
</span><span>// ...
</span><span>selected_sample_radiance = light_contribution.radiance;
</span></code></pre><p><strong>After:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>let contribution = light_contribution.radiance * saturate(dot(light_contribution.wi, world_normal));
</span><span>let target_function = luminance(contribution);
</span><span>// ...
</span><span>selected_sample_radiance = contribution;
</span></code></pre><h3 id=crates-bevy-solari-src-pathtracer-pathtracer-wgsl-0-2><code>crates/bevy_solari/src/pathtracer/pathtracer.wgsl</code> (+0/-2)</h3><p>This file contains minor cleanup by removing an unused variable.<p><strong>Key Changes:</strong> Removed the unused <code>previous_normal</code> variable that was declared but never used in the path tracing loop.<p><strong>Before:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>var previous_normal = vec3(0.0);
</span><span>// ...
</span><span>previous_normal = ray_hit.world_normal;
</span></code></pre><p><strong>After:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Variable removed entirely
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>RTXGI Documentation</strong>: NVIDIA’s documentation on Real-Time Global Illumination provides context for the termination heuristic used in this PR<li><strong>“Real-Time Path Tracing and Denoising in Tom Clancy’s The Division 2”</strong>: The paper referenced in the comments (mueller21realtime.pdf) discusses advanced path termination techniques<li><strong>Bevy’s Solari Documentation</strong>: For understanding how the irradiance cache system works within Bevy’s rendering architecture<li><strong>WGSL Shader Language Specification</strong>: Useful for understanding the WebGPU Shading Language changes made in this PR<li><strong>Global Illumination Compendium</strong>: A comprehensive reference for various GI techniques including irradiance caching</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22570.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>