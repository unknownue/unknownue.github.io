<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22668 Fix timestamp queries for DLSS
        
    </title><meta content="#22668 Fix timestamp queries for DLSS" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-24</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-01/pr-22668-en-20260124>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=fix-timestamp-queries-for-dlss>Fix timestamp queries for DLSS</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Fix timestamp queries for DLSS<li><strong>PR 链接</strong>: https://github.com/bevyengine/bevy/pull/22668<li><strong>作者</strong>: JMS55<li><strong>状态</strong>: 已合并 (MERGED)<li><strong>标签</strong>: C-Bug, A-Rendering, S-Ready-For-Final-Review<li><strong>创建时间</strong>: 2026-01-23T16:55:58Z<li><strong>合并时间</strong>: 2026-01-24T19:47:40Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi-description-translation>描述翻译 (Description Translation)</h2><p>时间戳查询（timestamp queries）对于DLSS从未正常工作，因为我最初编写代码时设置错了。这次修复了它（并在Solari示例中添加了DLSS-RR的时间显示）。<p>核心问题是我们需要在DLSS执行之前将时间戳起点（timestamp start）放在命令缓冲区（command buffer）上，然后在DLSS执行之后立即将时间戳终点（timestamp end）放在命令缓冲区上。<p>调试组（Debug groups）必须被移除，因为我无法在不同的命令编码器（command encoders）之间使用它们。<h2 id=ben-prde-ji-shu-fen-xi-the-story-of-this-pull-request>本PR的技术分析 (The Story of This Pull Request)</h2><p>这是一个关于修复GPU性能分析（GPU profiling）中特定测量错误的PR。问题本身很具体，但修复过程揭示了关于现代图形API命令提交和时间点记录的一些重要细节。<p><strong>问题和背景</strong> 在Bevy引擎中，<code>TimeSpan</code> 是一个诊断工具，用于通过GPU时间戳查询（GPU timestamp queries）来测量渲染操作（render operations）在GPU上的执行时间。这对于性能分析和优化至关重要。NVIDIA的DLSS（深度学习超级采样，Deep Learning Super Sampling）功能被集成到Bevy中作为一个后期处理节点（post-processing node）。然而，自集成以来，用于测量DLSS自身执行时间的时间戳查询一直未能产生有效数据，其测量值始终为<code>TODO</code>或零。这导致开发者无法准确评估DLSS对渲染性能的实际影响，无论是积极（加速）还是消极（开销）。根本原因在于时间戳记录的起止点（<code>time_span.start</code> 和 <code>.end</code>）被错误地放置在了与DLSS实际执行所在的不同命令缓冲区（或命令编码器）上。此外，为了调试目的而包裹DLSS操作的调试组也成为了一个障碍。<p><strong>解决方案和实现</strong> 修复方案的核心思路非常直接：确保时间戳记录的起止操作（<code>write_timestamp</code>）被编码到与DLSS渲染调用相同的命令编码器（command encoder）序列中。具体实现涉及对<code>DlssNode</code>中两个特性（<code>DlssSuperResolutionFeature</code> 和 <code>DlssRayReconstructionFeature</code>）的<code>run</code>方法进行重构。<p>在修改前的代码中，执行顺序存在逻辑错误：<ol><li>获取主命令编码器（<code>command_encoder</code>）。<li>开始一个调试组（<code>push_debug_group</code>）。<li>开始时间跨度记录（<code>diagnostics.time_span</code>），这会在提供的编码器上写入第一个时间戳。<li>（<strong>关键点</strong>）然后获取DLSS上下文的锁并调用<code>dlss_context.render(...)</code>。这个DLSS库的<code>render</code>方法通常会返回一个<strong>新的、独立的命令缓冲区</strong>（<code>dlss_command_buffer</code>），其中包含了执行DLSS所需的所有GPU指令。<li>紧接着，代码尝试在<strong>主命令编码器</strong>（<code>command_encoder</code>）上结束时间跨度（<code>time_span.end</code>）并弹出调试组。<li>最后，将DLSS返回的命令缓冲区添加到渲染上下文中。</ol><p>问题在于：第3步的时间戳起点写入了主编码器，第5步的终点也写入了主编码器，但实际要测量的DLSS工作（第4步）却发生在一个完全独立的命令缓冲区里。GPU驱动程序在调度这些命令缓冲区时没有顺序保证，因此这两个时间戳无法准确地围住（bracket）DLSS的执行时间，导致测量失效或混乱。<p>修复后的代码调整了顺序并移除了干扰项：<ol><li>获取主命令编码器。<li>立即开始时间跨度记录（<code>diagnostics.time_span</code>）。此时第一个时间戳被写入主编码器。<li>获取DLSS上下文锁并执行<code>dlss_context.render(...)</code>，得到DLSS的命令缓冲区。<li>将DLSS命令缓冲区添加到渲染上下文。<li><strong>关键修改</strong>：调用 <code>time_span.end(render_context.command_encoder())</code>。这里使用了 <code>render_context.command_encoder()</code> 来获取<strong>当前活动的命令编码器</strong>。在添加了DLSS的命令缓冲区之后，<code>render_context</code> 的内部状态管理确保我们获得了一个可以正确排序的编码器，用于写入结束时间戳。这个结束时间戳与DLSS工作的关联性比之前更强。<li>移除了<code>push_debug_group</code>和<code>pop_debug_group</code>调用。根据PR描述，这是因为调试组无法跨不同的命令编码器工作。保留它们可能会破坏调试信息或引起错误。移除它们简化了代码并消除了一个潜在的故障点。</ol><p>同时，为了反映这个修复，文档（<code>diagnostic/mod.rs</code>）中关于 <code>TimeSpanGuard::end</code> 方法的注释从要求提供“相同的编码器（same encoder）”更新为更通用的“编码器（或相同的渲染/计算通道）（encoder (or the same render/compute pass)）”，这更准确地描述了其实际使用方式，不再强制要求必须是同一个对象实例，而是关注于逻辑上的正确关联。<p>最后，为了验证修复，<code>solari.rs</code>示例被更新，将<code>"DLSS-RR"</code>行的显示从硬编码的<code>TODO</code>改为实际查询诊断系统获取<code>"render/dlss_ray_reconstruction/elapsed_gpu"</code>数据。这使得示例能够真实展示DLSS光线重建（Ray Reconstruction）的性能耗时。<p><strong>技术洞察和影响</strong> 这个修复凸显了在基于现代图形API（如Vulkan、DirectX 12）的引擎中，进行精确GPU性能测量的一个微妙之处：时间戳必须与被测量的工作单元（work unit）提交到<strong>相同的命令列表/缓冲区/编码器</strong>，或者这些命令列表之间必须有明确的、可被GPU查询的依赖关系（如信号量），才能保证测量逻辑的正确性。Bevy的渲染图（Render Graph）抽象允许插入像DLSS这样的外部库节点，这些节点可能管理着自己的命令提交。在这种情况下，诊断工具需要与节点的命令提交生命周期紧密配合。<p>移除调试组是一个实用的妥协，在功能（准确的性能数据）和调试便利性之间选择了前者。这种权衡在性能关键路径上很常见。<p>此PR的影响很明确：它使得DLSS超分辨率和光线重建功能的GPU时间性能测量变得准确可用。这对于游戏开发者优化渲染管线、评估DLSS在不同场景下的性能收益（或开销）至关重要。修复虽小，但对于依赖此类数据进行性能分析和决策的开发者来说，价值重大。<h2 id=ke-shi-hua-biao-shi-visual-representation>可视化表示 (Visual Representation)</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>sequenceDiagram
</span><span>    participant Main as 主命令编码器&LTbr/>(Main Command Encoder)
</span><span>    participant DLSS as DLSS命令缓冲区&LTbr/>(DLSS Command Buffer)
</span><span>    participant Diagnostics as 诊断记录器&LTbr/>(Diagnostic Recorder)
</span><span>
</span><span>    Note over Main,Diagnostics: 修改前 (Before Fix)
</span><span>    Main->>Diagnostics: 1. time_span.start() (Timestamp A)
</span><span>    Main->>Main: 2. push_debug_group
</span><span>    Main-->>DLSS: 3. dlss_context.render() (生成独立缓冲区)
</span><span>    Main->>Diagnostics: 4. time_span.end() (Timestamp B)
</span><span>    Main->>Main: 5. pop_debug_group
</span><span>    Note over Main,DLSS: 问题：时间戳A和B在主编码器，&LTbr/>但DLSS工作在不同缓冲区，测量无效。
</span><span>
</span><span>    Note over Main,Diagnostics: 修改后 (After Fix)
</span><span>    Main->>Diagnostics: 1. time_span.start() (Timestamp A)
</span><span>    Main-->>DLSS: 2. dlss_context.render() (生成独立缓冲区)
</span><span>    Main->>Main: 3. render_context.add_command_buffer()
</span><span>    Main->>Diagnostics: 4. time_span.end() (Timestamp B)
</span><span>    Note over Main,DLSS: 修复：时间戳A在主编码器，&LTbr/>时间戳B在与DLSS工作关联的编码器上，&LTbr/>测量逻辑正确。
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai-key-files-changed>关键文件更改 (Key Files Changed)</h2><ol><li><code>crates/bevy_anti_alias/src/dlss/node.rs</code> (+4/-11) <ul><li><strong>修改内容与原因</strong>：重构了DLSS超分辨率（Super Resolution）和光线重建（Ray Reconstruction）节点的<code>run</code>方法。核心修改是调整了时间戳记录（<code>TimeSpan</code>）和DLSS渲染调用（<code>dlss_context.render</code>）的顺序，并移除了调试组。这确保了时间戳被正确地记录在相关的命令编码器上，从而能够准确测量DLSS的执行时间。<li><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前（以超分辨率为例）:
</span><span style=color:#abb0b6;font-style:italic>// let mut dlss_context = dlss_context.context.lock().unwrap(); // (位置靠后)
</span><span style=color:#abb0b6;font-style:italic>// command_encoder.push_debug_group("dlss_super_resolution");
</span><span style=color:#abb0b6;font-style:italic>// let time_span = diagnostics.time_span(command_encoder, "dlss_super_resolution");
</span><span style=color:#abb0b6;font-style:italic>// ... dlss_context.render(...) ...
</span><span style=color:#abb0b6;font-style:italic>// time_span.end(command_encoder);
</span><span style=color:#abb0b6;font-style:italic>// command_encoder.pop_debug_group();
</span><span style=color:#abb0b6;font-style:italic>// render_context.add_command_buffer(dlss_command_buffer);
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后:
</span><span style=color:#fa6e32>let</span><span> diagnostics </span><span style=color:#ed9366>=</span><span> render_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>diagnostic_recorder</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> command_encoder </span><span style=color:#ed9366>=</span><span> render_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>command_encoder</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// 调试组被移除
</span><span style=color:#fa6e32>let</span><span> time_span </span><span style=color:#ed9366>=</span><span> diagnostics</span><span style=color:#ed9366>.</span><span style=color:#f07171>time_span</span><span>(command_encoder</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"dlss_super_resolution"</span><span>)</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 时间戳起点提前
</span><span>
</span><span style=color:#fa6e32>let mut</span><span> dlss_context </span><span style=color:#ed9366>=</span><span> dlss_context</span><span style=color:#ed9366>.</span><span>context</span><span style=color:#ed9366>.</span><span style=color:#f07171>lock</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 锁在时间戳起点后获取
</span><span style=color:#fa6e32>let</span><span> dlss_command_buffer </span><span style=color:#ed9366>=</span><span> dlss_context
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>render</span><span>(render_parameters</span><span style=color:#61676ccc>,</span><span> command_encoder</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>adapter)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"Failed to render DLSS Super Resolution"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>render_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_command_buffer</span><span>(dlss_command_buffer)</span><span style=color:#61676ccc>;
</span><span>time_span</span><span style=color:#ed9366>.</span><span style=color:#f07171>end</span><span>(render_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>command_encoder</span><span>())</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 使用新的command_encoder()方法获取编码器
</span></code></pre></ul><li><code>crates/bevy_render/src/diagnostic/mod.rs</code> (+2/-2) <ul><li><strong>修改内容与原因</strong>：更新了 <code>TimeSpanGuard::end</code> 方法的文档注释，使其要求更宽松，与实际修复后的使用方式保持一致。这反映了对API使用方式的更精确理解。<li><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前:
</span><span style=color:#abb0b6;font-style:italic>/// End the span. You have to provide the same encoder which was used to begin the span.
</span><span style=color:#abb0b6;font-style:italic>// 修改后:
</span><span style=color:#abb0b6;font-style:italic>/// End the span.
</span><span style=color:#abb0b6;font-style:italic>// (在函数上方的示例中，相关描述也从“provide the same encoder”改为“providing the encoder (or the same render/compute pass)”)
</span></code></pre></ul><li><code>examples/3d/solari.rs</code> (+1/-1) <ul><li><strong>修改内容与原因</strong>：更新了性能统计文本的生成逻辑，将DLSS-RR（光线重建）的时间显示从硬编码的<code>TODO</code>替换为实际从诊断系统查询的键值。这用于演示和验证修复是否生效。<li><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前:
</span><span style=color:#abb0b6;font-style:italic>// text.push_str(&format!("{:17}     TODO\n", "DLSS-RR"));
</span><span style=color:#abb0b6;font-style:italic>// 修改后:
</span><span>(add_diagnostic)(</span><span style=color:#86b300>"DLSS-RR"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"render/dlss_ray_reconstruction/elapsed_gpu"</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre></ul></ol><h2 id=yan-shen-yue-du-further-reading>延伸阅读 (Further Reading)</h2><ol><li><strong>GPU 时间戳查询（GPU Timestamp Queries）</strong>：了解GPU如何提供高精度计时功能，用于性能分析。这是图形编程中基准测试（benchmarking）的基础。 <ul><li>Vulkan 规范: <code>VkQueryType::VK_QUERY_TYPE_TIMESTAMP</code><li>DirectX 12: <code>ID3D12GraphicsCommandList::EndQuery</code> (with <code>D3D12_QUERY_TYPE_TIMESTAMP</code>)</ul><li><strong>NVIDIA DLSS SDK 文档</strong>：理解DLSS（深度学习超级采样）和DLSS Ray Reconstruction（光线重建）的工作原理及其与渲染管线的集成方式。<li><strong>Bevy 渲染图（Render Graph）</strong>：学习Bevy引擎如何组织和执行渲染任务，其中<code>ViewNode</code>是构建渲染图节点的关键trait。这有助于理解本PR中修改的<code>DlssNode</code>所处的上下文。 <ul><li>Bevy 官方手册: <a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/advanced-topics/rendering/render-graphs/ target=_blank>Render Graphs</a> (需查找对应版本)</ul><li><strong>命令缓冲区与编码器（Command Buffers and Encoders）</strong>：学习现代图形API（Vulkan/DirectX 12/Metal）中命令提交的模型，理解为什么命令列表之间的同步和依赖对性能测量至关重要。</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22668.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>