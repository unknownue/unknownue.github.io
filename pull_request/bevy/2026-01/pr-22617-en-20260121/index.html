<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22617 Solari: Improve spatial sample finding
        
    </title><meta content="#22617 Solari: Improve spatial sample finding" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-21</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22617-zh-cn-20260121>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari: Improve spatial sample finding<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22617<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-Rendering, S-Ready-For-Final-Review, C-Refinement<li><strong>Created</strong>: 2026-01-21T03:12:32Z<li><strong>Merged</strong>: 2026-01-21T19:11:12Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Pink is visualizing pixels without a valid spatial sample (for ReSTIR GI).<p>Before: <img alt=image height=1875 src=https://github.com/user-attachments/assets/0d336bd8-a20d-420c-97d8-50e3bb1309ab width=3206><p>After: <img alt=image height=1875 src=https://github.com/user-attachments/assets/50352242-b658-4a47-a5b8-1b061388a8de width=3206><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a specific optimization problem in the Bevy engine’s Solari real-time rendering system, specifically within the ReSTIR (Reservoir-based Spatio-Temporal Importance Resampling) implementation for both direct illumination (DI) and global illumination (GI). The core issue was that the spatial sample finding algorithm had a fixed search radius, which wasn’t adapting effectively to different geometric situations.<p>In the original implementation, the <code>load_spatial_reservoir</code> function attempted to find valid neighboring pixels for sample reuse by randomly sampling within a fixed radius defined by <code>SPATIAL_REUSE_RADIUS_PIXELS</code>. When a sampled neighbor was rejected due to geometric dissimilarity (different depth, world position, or surface normal), the algorithm would simply continue searching with the same radius. This approach wasted search iterations on potentially invalid regions and could lead to more pink pixels in the visualization, indicating failed spatial sample reuse.<p>The solution implements an adaptive radius reduction strategy. When a sampled neighbor is found to be dissimilar, the search radius is halved for subsequent iterations within the same search loop. This creates a more efficient search pattern: if the initial random sample in the larger radius fails, the algorithm progressively focuses on closer pixels, which are more likely to share similar geometric properties.<p>The technical implementation required modifying both the DI and GI shaders identically. The key changes were:<ol><li>Introducing a local <code>search_radius</code> variable initialized to the global constant <code>SPATIAL_REUSE_RADIUS_PIXELS</code><li>Modifying the <code>get_neighbor_pixel_id</code> function to accept this radius as a parameter<li>Adding radius halving logic (<code>search_radius /= 2.0</code>) when <code>pixel_dissimilar</code> returns true</ol><p>This adaptive approach makes intuitive sense from a geometric perspective. Surfaces with discontinuities (edges, depth boundaries) often have dissimilar neighbors at larger distances but may have similar neighbors at closer proximity. By reducing the search radius after each failure, the algorithm becomes more likely to find valid samples near the original pixel, especially in complex geometric regions.<p>The visual results confirm the improvement. The “after” image shows significantly fewer pink pixels, particularly noticeable in areas with complex geometry or depth variations. This translates directly to better sample reuse, reduced noise, and potentially improved performance since fewer pixels need to fall back to more expensive sampling methods.<p>From an engineering perspective, this change demonstrates a common optimization pattern in real-time graphics: adapting sampling strategies based on local conditions. The implementation is minimal, focused, and maintains backward compatibility while significantly improving the algorithm’s effectiveness.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[load_spatial_reservoir function] --> B[Initialize search_radius]
</span><span>    B --> C[Loop up to 5 times]
</span><span>    C --> D[get_neighbor_pixel_id with current radius]
</span><span>    D --> E{Check pixel_dissimilar}
</span><span>    E -->|Yes| F[Reduce search_radius by half]
</span><span>    F --> C
</span><span>    E -->|No| G[Return valid neighbor]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><p><strong>1. <code>crates/bevy_solari/src/realtime/restir_di.wgsl</code> (+5/-3)</strong><p>This file contains the direct illumination implementation of ReSTIR. The changes implement adaptive spatial search radius for DI.<p>Key modification in <code>load_spatial_reservoir</code> function:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>fn load_spatial_reservoir(pixel_id: vec2&LTu32>, depth: f32, world_position: vec3&LTf32>, world_normal: vec3&LTf32>, rng: ptr&LTfunction, u32>) -> NeighborInfo {
</span><span>    for (var i = 0u; i < 5u; i++) {
</span><span>        let spatial_pixel_id = get_neighbor_pixel_id(pixel_id, rng);
</span><span>        // ...
</span><span>        if pixel_dissimilar(depth, world_position, spatial_surface.world_position, world_normal, spatial_surface.world_normal, view) {
</span><span>            continue;
</span><span>        }
</span><span>        // ...
</span><span>    }
</span><span>    // ...
</span><span>}
</span><span>
</span><span>// After:
</span><span>fn load_spatial_reservoir(pixel_id: vec2&LTu32>, depth: f32, world_position: vec3&LTf32>, world_normal: vec3&LTf32>, rng: ptr&LTfunction, u32>) -> NeighborInfo {
</span><span>    var search_radius = SPATIAL_REUSE_RADIUS_PIXELS;  // New variable
</span><span>    for (var i = 0u; i < 5u; i++) {
</span><span>        let spatial_pixel_id = get_neighbor_pixel_id(pixel_id, search_radius, rng);  // Pass radius
</span><span>        // ...
</span><span>        if pixel_dissimilar(depth, world_position, spatial_surface.world_position, world_normal, spatial_surface.world_normal, view) {
</span><span>            search_radius /= 2.0;  // Adaptive reduction
</span><span>            continue;
</span><span>        }
</span><span>        // ...
</span><span>    }
</span><span>    // ...
</span><span>}
</span></code></pre><p>Corresponding change to <code>get_neighbor_pixel_id</code>:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>fn get_neighbor_pixel_id(center_pixel_id: vec2&LTu32>, rng: ptr&LTfunction, u32>) -> vec2&LTu32> {
</span><span>    var spatial_id = vec2&LTf32>(center_pixel_id) + sample_disk(SPATIAL_REUSE_RADIUS_PIXELS, rng);
</span><span>    // ...
</span><span>}
</span><span>
</span><span>// After:
</span><span>fn get_neighbor_pixel_id(center_pixel_id: vec2&LTu32>, search_radius: f32, rng: ptr&LTfunction, u32>) -> vec2&LTu32> {
</span><span>    var spatial_id = vec2&LTf32>(center_pixel_id) + sample_disk(search_radius, rng);  // Use parameter
</span><span>    // ...
</span><span>}
</span></code></pre><p><strong>2. <code>crates/bevy_solari/src/realtime/restir_gi.wgsl</code> (+5/-3)</strong><p>This file contains the global illumination implementation of ReSTIR. The changes are identical to those in the DI shader, ensuring consistent behavior across both illumination types.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// The exact same modifications as shown above for restir_di.wgsl
</span><span>// were applied to restir_gi.wgsl
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>ReSTIR Paper</strong>: “Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting” by Bitterli et al. (2020) - The foundational paper for the ReSTIR algorithm<li><strong>WGSL Specification</strong>: https://www.w3.org/TR/WGSL/ - WebGPU Shading Language documentation<li><strong>Bevy Rendering Architecture</strong>: Bevy’s rendering engine documentation for understanding how shaders integrate with the ECS system<li><strong>Importance Sampling in Real-Time Rendering</strong>: General concepts of Monte Carlo methods and importance sampling as applied to real-time graphics</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22617.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>