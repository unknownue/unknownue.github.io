<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22241 Directional navigation uses edge to edge distance not center to center
        
    </title><meta content="#22241 Directional navigation uses edge to edge distance not center to center" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-01</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22241-zh-cn-20260101>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=directional-navigation-uses-edge-to-edge-distance-not-center-to-center>Directional navigation uses edge to edge distance not center to center</h2><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Directional navigation uses edge to edge distance not center to center<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22241<li><strong>Author</strong>: apekros<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-UI, S-Ready-For-Final-Review, D-Straightforward<li><strong>Created</strong>: 2025-12-23T00:56:54Z<li><strong>Merged</strong>: 2025-12-31T23:17:47Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>The PR description is already in English.<h1 id=the-story-of-this-pull-request>The Story of This Pull Request</h1><h2 id=the-problem-and-context>The Problem and Context</h2><p>The issue surfaced in Bevy’s UI directional navigation system, where navigation between focusable elements was calculated using center-to-center distance. This approach led to counterintuitive behavior in common UI layouts. As illustrated in the diagram, when navigating from a left-aligned rectangle eastward, the system would incorrectly choose the bottom rectangle whose center was closer, even though the wider top rectangle was clearly the intended target because its edge was physically closer.<p>The core problem was mathematical: using Euclidean distance between rectangle centers doesn’t reflect how users perceive spatial relationships in UI navigation. Users naturally look for the nearest element edge when navigating directionally, not the nearest center point. This became particularly problematic with elements of varying sizes where a larger element might have its center further away but its edge significantly closer.<h2 id=the-solution-approach>The Solution Approach</h2><p>The developer implemented a straightforward but effective fix: switching from center-to-center distance to edge-to-edge distance calculation. This required calculating the shortest distance between the bounding rectangles of two elements rather than just the distance between their center points.<p>The implementation maintains a separation of concerns: while distance calculation uses edge-to-edge measurements, alignment scoring (which determines how directly an element lies in the navigation direction) continues to use center-to-center vectors. This preserves the directional preference aspect of the algorithm while fixing the distance measurement.<h2 id=the-implementation>The Implementation</h2><p>The key change occurs in the <code>score_candidate</code> function within <code>directional_navigation.rs</code>. Previously, the function calculated simple Euclidean distance between centers:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before the change
</span><span style=color:#fa6e32>let</span><span> to_candidate </span><span style=color:#ed9366>=</span><span> candidate_pos </span><span style=color:#ed9366>-</span><span> origin_pos</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> distance </span><span style=color:#ed9366>=</span><span> to_candidate</span><span style=color:#ed9366>.</span><span style=color:#f07171>length</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p>After the change, the implementation constructs <code>Rect</code> objects from both elements and computes the minimal edge-to-edge distance:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// After the change
</span><span style=color:#fa6e32>let</span><span> origin_rect </span><span style=color:#ed9366>= </span><span>Rect</span><span style=color:#ed9366>::</span><span>from_center_size(origin_pos</span><span style=color:#61676ccc>,</span><span> origin_size)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> candidate_rect </span><span style=color:#ed9366>= </span><span>Rect</span><span style=color:#ed9366>::</span><span>from_center_size(candidate_pos</span><span style=color:#61676ccc>,</span><span> candidate_size)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> dx </span><span style=color:#ed9366>= </span><span>(candidate_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>-</span><span> origin_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>x)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(origin_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>-</span><span> candidate_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>x)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> dy </span><span style=color:#ed9366>= </span><span>(candidate_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>-</span><span> origin_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>y)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(origin_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>-</span><span> candidate_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>y)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> distance </span><span style=color:#ed9366>= </span><span>(dx </span><span style=color:#ed9366>*</span><span> dx </span><span style=color:#ed9366>+</span><span> dy </span><span style=color:#ed9366>*</span><span> dy)</span><span style=color:#ed9366>.</span><span style=color:#f07171>sqrt</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p>The edge-to-edge distance calculation handles three cases:<ol><li>Non-overlapping rectangles in the given dimension (positive distance)<li>Overlapping rectangles (distance becomes 0 in that dimension)<li>The max(0.0) ensures no negative distances</ol><p>The alignment scoring continues to use center-to-center vectors to maintain directional accuracy:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Alignment scoring unchanged
</span><span style=color:#fa6e32>let</span><span> center_distance </span><span style=color:#ed9366>=</span><span> to_candidate</span><span style=color:#ed9366>.</span><span style=color:#f07171>length</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> alignment </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if</span><span> center_distance </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>0.0 </span><span>{
</span><span>    to_candidate</span><span style=color:#ed9366>.</span><span style=color:#f07171>normalize</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>dot</span><span>(dir)</span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#ff8f40>1.0
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=technical-insights>Technical Insights</h2><p>The edge-to-edge distance calculation uses axis-aligned bounding boxes, which is appropriate for UI elements that are typically axis-aligned rectangles. The formula <code>dx = max(candidate.min.x - origin.max.x, origin.min.x - candidate.max.x, 0)</code> efficiently computes the horizontal separation: if rectangles don’t overlap horizontally, it’s the positive gap; if they overlap, it’s 0.<p>This approach aligns with common UI navigation patterns in other frameworks and operating systems. The decision to keep alignment scoring based on center vectors is practical because alignment should consider the overall direction to the element’s center rather than to its nearest edge.<h2 id=the-impact>The Impact</h2><p>This fix makes directional navigation behave more intuitively, especially in layouts with elements of different sizes. The test case added demonstrates the specific scenario: navigating east from a left rectangle should now correctly choose the wider top rectangle instead of the bottom one, even though the bottom rectangle’s center is closer.<p>The change is minimal and focused, affecting only the distance calculation while preserving the rest of the navigation algorithm. This reduces the risk of regressions and maintains backward compatibility for cases where the previous behavior was already correct.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Directional Navigation System] --> B{Calculate Candidate Score}
</span><span>    B --> C[Edge-to-Edge Distance]
</span><span>    B --> D[Center-to-Center Alignment]
</span><span>    C --> E[Combined Score]
</span><span>    D --> E
</span><span>    E --> F[Select Best Candidate]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-input-focus-src-directional-navigation-rs-53-4><code>crates/bevy_input_focus/src/directional_navigation.rs</code> (+53/-4)</h3><p>This file contains the core directional navigation logic for Bevy’s UI system. The changes fix the distance calculation algorithm to use edge-to-edge measurements instead of center-to-center.<p><strong>Key modifications:</strong><ol><li><p><strong>Imports update</strong>: Added <code>Rect</code> import from <code>bevy_math</code></p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>use </span><span>bevy_math</span><span style=color:#ed9366>::</span><span>{CompassOctant</span><span style=color:#61676ccc>,</span><span> Dir2</span><span style=color:#61676ccc>,</span><span> Vec2}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>use </span><span>bevy_math</span><span style=color:#ed9366>::</span><span>{CompassOctant</span><span style=color:#61676ccc>,</span><span> Dir2</span><span style=color:#61676ccc>,</span><span> Rect</span><span style=color:#61676ccc>,</span><span> Vec2}</span><span style=color:#61676ccc>;
</span></code></pre><li><p><strong>Distance calculation logic</strong>: Replaced center-to-center distance with edge-to-edge distance</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> to_candidate </span><span style=color:#ed9366>=</span><span> candidate_pos </span><span style=color:#ed9366>-</span><span> origin_pos</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> distance </span><span style=color:#ed9366>=</span><span> to_candidate</span><span style=color:#ed9366>.</span><span style=color:#f07171>length</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> origin_rect </span><span style=color:#ed9366>= </span><span>Rect</span><span style=color:#ed9366>::</span><span>from_center_size(origin_pos</span><span style=color:#61676ccc>,</span><span> origin_size)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> candidate_rect </span><span style=color:#ed9366>= </span><span>Rect</span><span style=color:#ed9366>::</span><span>from_center_size(candidate_pos</span><span style=color:#61676ccc>,</span><span> candidate_size)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> dx </span><span style=color:#ed9366>= </span><span>(candidate_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>-</span><span> origin_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>x)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(origin_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>-</span><span> candidate_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>x)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> dy </span><span style=color:#ed9366>= </span><span>(candidate_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>-</span><span> origin_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>y)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(origin_rect</span><span style=color:#ed9366>.</span><span>min</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>-</span><span> candidate_rect</span><span style=color:#ed9366>.</span><span>max</span><span style=color:#ed9366>.</span><span>y)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>max</span><span>(</span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> distance </span><span style=color:#ed9366>= </span><span>(dx </span><span style=color:#ed9366>*</span><span> dx </span><span style=color:#ed9366>+</span><span> dy </span><span style=color:#ed9366>*</span><span> dy)</span><span style=color:#ed9366>.</span><span style=color:#f07171>sqrt</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><li><p><strong>Test addition</strong>: Added comprehensive test for the edge distance scenario</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>test_edge_distance_vs_center_distance</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test setup with three rectangles matching the diagrammed scenario
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Verifies that navigation chooses the wider top rectangle, not the bottom one
</span><span>}
</span></code></pre></ol><p>The changes directly address the bug while maintaining the existing API and behavior for correct cases.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy UI Navigation Documentation</strong>: For understanding the broader navigation system<li><strong>Rectangle Distance Algorithms</strong>: Research on minimal distance between axis-aligned rectangles<li><strong>Accessibility Guidelines</strong>: WCAG recommendations for keyboard navigation in UI systems<li><strong>Spatial Data Structures</strong>: K-d trees and spatial hashing for efficient nearest-neighbor searches in UI navigation</ol><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_input_focus/src/directional_navigation.rs b/crates/bevy_input_focus/src/directional_navigation.rs
</span><span>index 79dc20680084a..39dfef80060f0 100644
</span><span style=color:#c594c5>--- a/crates/bevy_input_focus/src/directional_navigation.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_input_focus/src/directional_navigation.rs
</span><span style=color:#c594c5>@@ -66,7 +66,7 @@ </span><span style=color:#399ee6>use bevy_ecs::{
</span><span>     prelude::*,
</span><span>     system::SystemParam,
</span><span> };
</span><span style=color:#f07171>-use bevy_math::{CompassOctant, Dir2, Vec2};
</span><span style=color:#86b300>+use bevy_math::{CompassOctant, Dir2, Rect, Vec2};
</span><span> use bevy_ui::{ComputedNode, ComputedUiTargetCamera, UiGlobalTransform};
</span><span> use thiserror::Error;
</span><span> 
</span><span style=color:#c594c5>@@ -658,7 +658,6 @@ </span><span style=color:#399ee6>fn score_candidate(
</span><span>     // Get direction in mathematical coordinates, then flip Y for UI coordinates
</span><span>     let dir = Dir2::from(octant).as_vec2() * Vec2::new(1.0, -1.0);
</span><span>     let to_candidate = candidate_pos - origin_pos;
</span><span style=color:#f07171>-    let distance = to_candidate.length();
</span><span> 
</span><span>     // Check direction first
</span><span>     // Convert UI coordinates (Y+ = down) to mathematical coordinates (Y+ = up) by flipping Y
</span><span style=color:#c594c5>@@ -681,6 +680,17 @@ </span><span style=color:#399ee6>fn score_candidate(
</span><span>         return f32::INFINITY;
</span><span>     }
</span><span> 
</span><span style=color:#86b300>+    // Calculate distance between rectangle edges, not centers
</span><span style=color:#86b300>+    let origin_rect = Rect::from_center_size(origin_pos, origin_size);
</span><span style=color:#86b300>+    let candidate_rect = Rect::from_center_size(candidate_pos, candidate_size);
</span><span style=color:#86b300>+    let dx = (candidate_rect.min.x - origin_rect.max.x)
</span><span style=color:#86b300>+        .max(origin_rect.min.x - candidate_rect.max.x)
</span><span style=color:#86b300>+        .max(0.0);
</span><span style=color:#86b300>+    let dy = (candidate_rect.min.y - origin_rect.max.y)
</span><span style=color:#86b300>+        .max(origin_rect.min.y - candidate_rect.max.y)
</span><span style=color:#86b300>+        .max(0.0);
</span><span style=color:#86b300>+    let distance = (dx * dx + dy * dy).sqrt();
</span><span style=color:#86b300>+
</span><span>     // Check max distance
</span><span>     if let Some(max_dist) = config.max_search_distance {
</span><span>         if distance > max_dist {
</span><span style=color:#c594c5>@@ -688,8 +698,9 @@ </span><span style=color:#399ee6>fn score_candidate(
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    // Calculate alignment score
</span><span style=color:#f07171>-    let alignment = if distance > 0.0 {
</span><span style=color:#86b300>+    // Calculate alignment score using center-to-center direction
</span><span style=color:#86b300>+    let center_distance = to_candidate.length();
</span><span style=color:#86b300>+    let alignment = if center_distance > 0.0 {
</span><span>         to_candidate.normalize().dot(dir).max(0.0)
</span><span>     } else {
</span><span>         1.0
</span><span style=color:#c594c5>@@ -1203,4 +1214,42 @@ </span><span style=color:#399ee6>mod tests {
</span><span>             Some(node_c)
</span><span>         );
</span><span>     }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn test_edge_distance_vs_center_distance() {
</span><span style=color:#86b300>+        let mut nav_map = DirectionalNavigationMap::default();
</span><span style=color:#86b300>+        let config = AutoNavigationConfig::default();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let left = Entity::from_bits(1);
</span><span style=color:#86b300>+        let wide_top = Entity::from_bits(2);
</span><span style=color:#86b300>+        let bottom = Entity::from_bits(3);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let left_node = FocusableArea {
</span><span style=color:#86b300>+            entity: left,
</span><span style=color:#86b300>+            position: Vec2::new(100.0, 200.0),
</span><span style=color:#86b300>+            size: Vec2::new(100.0, 100.0),
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let wide_top_node = FocusableArea {
</span><span style=color:#86b300>+            entity: wide_top,
</span><span style=color:#86b300>+            position: Vec2::new(350.0, 150.0),
</span><span style=color:#86b300>+            size: Vec2::new(300.0, 80.0),
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let bottom_node = FocusableArea {
</span><span style=color:#86b300>+            entity: bottom,
</span><span style=color:#86b300>+            position: Vec2::new(270.0, 300.0),
</span><span style=color:#86b300>+            size: Vec2::new(100.0, 80.0),
</span><span style=color:#86b300>+        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let nodes = vec![left_node, wide_top_node, bottom_node];
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        auto_generate_navigation_edges(&mut nav_map, &nodes, &config);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        assert_eq!(
</span><span style=color:#86b300>+            nav_map.get_neighbor(left, CompassOctant::East),
</span><span style=color:#86b300>+            Some(wide_top),
</span><span style=color:#86b300>+            "Should navigate to wide_top not bottom, even though bottom's center is closer."
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+    }
</span><span> }
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22241.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>