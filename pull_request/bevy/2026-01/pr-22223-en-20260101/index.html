<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22223 Add command line option to choose a starting scene in the `testbed_*' examples
        
    </title><meta content="#22223 Add command line option to choose a starting scene in the `testbed_*' examples" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-01</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22223-zh-cn-20260101>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add command line option to choose a starting scene in the `testbed_*’ examples<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22223<li><strong>Author</strong>: panpanpro888<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: S-Ready-For-Final-Review, C-Testing<li><strong>Created</strong>: 2025-12-21T18:17:17Z<li><strong>Merged</strong>: 2025-12-31T23:23:39Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Fixes #22218</ul><h2 id=solution>Solution</h2><ul><li>Use <code>argh</code> to check if you passed a scene name, and if you did, start on that one instead of the default</ul><h2 id=testing>Testing</h2><ul><li>Tested on my local machine, I don’t see a reason why it would change between different machines and/or platforms</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The Bevy testbed examples are useful tools for developers to understand and experiment with different rendering features and scenes. However, before this PR, there was a limitation in how these examples were used. Each testbed example (2D, 3D, and UI) would always start with a default scene, and users had to manually cycle through scenes using keyboard input during runtime to reach specific scenes they wanted to test or examine.<p>This was inconvenient for several reasons. First, developers working on specific features needed to manually navigate to the relevant scene every time they ran the example. Second, automated testing or demonstration workflows couldn’t easily start at a particular scene without simulating user input. The issue #22218 specifically addressed this limitation by requesting a command-line interface to specify which scene to start with.<p>The solution implemented in this PR is straightforward and consistent with Bevy’s existing command-line parsing approach. Bevy already uses the <code>argh</code> crate for command-line argument parsing in other parts of the codebase, so the author chose to leverage this existing dependency rather than introducing a new one. This maintains consistency and minimizes dependencies.<p>The implementation follows a clear pattern across all three testbed examples (2D, 3D, and UI). Each example file receives the same set of modifications. First, an <code>Args</code> struct is defined using <code>argh</code>’s <code>FromArgs</code> derive macro to parse command-line arguments. This struct contains a single optional positional argument for the scene name.<p>The core of the change involves restructuring how the application’s initial state is set. Previously, each example would unconditionally call <code>app.init_state::&LTScene>()</code> during app construction, which initializes the state to the <code>Scene</code> enum’s default variant. The new approach parses command-line arguments first, then conditionally sets the initial state based on whether a scene was specified.<p>Here’s the key logic:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>match</span><span> args</span><span style=color:#ed9366>.</span><span>scene {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>None </span><span style=color:#ed9366>=></span><span> app</span><span style=color:#ed9366>.</span><span>init_state</span><span style=color:#ed9366>::</span><span>&LTScene>()</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(scene) </span><span style=color:#ed9366>=></span><span> app</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert_state</span><span>(scene)</span><span style=color:#61676ccc>,
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>When no scene argument is provided, the behavior remains unchanged - <code>init_state</code> sets the default scene. When a scene is specified, <code>insert_state</code> sets that specific scene as the initial state. This maintains backward compatibility while adding the new functionality.<p>A critical technical component is the implementation of <code>std::str::FromStr</code> for each <code>Scene</code> enum. This allows <code>argh</code> to parse string arguments into the corresponding enum variants. The implementation handles case-insensitive matching by converting both the input string and the formatted enum variant to lowercase. It also validates the input by cycling through all possible scenes using the existing <code>Next</code> trait implementation. If the input doesn’t match any scene after a full cycle, it returns an error.<p>The <code>FromStr</code> implementation uses a clever approach that leverages the existing <code>Next</code> trait to iterate through all possible scenes. This ensures that the implementation automatically stays in sync if new scenes are added to the enum. The implementation starts from the default scene and iterates through each next scene until it either finds a match or completes a full cycle back to the default.<p>This PR demonstrates good software engineering practices. It solves a real usability problem with minimal code changes. The solution is consistent across all three affected examples, making maintenance easier. It leverages existing Bevy patterns and dependencies rather than introducing new ones. The implementation is robust, handling edge cases like invalid scene names with appropriate error messages.<p>The changes have clear practical benefits. Developers can now run specific test scenes directly from the command line, which streamlines development and testing workflows. For example, a developer working on bloom effects in 3D rendering can now run <code>cargo run --example testbed_3d -- bloom</code> to immediately start with the bloom scene rather than manually navigating to it.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Command Line Arguments] --> B[argh Parser]
</span><span>    B --> C{Scene Provided?}
</span><span>    C -->|Yes| D[Parse Scene String]
</span><span>    C -->|No| E[Use Default Scene]
</span><span>    D --> F[Validate Scene Name]
</span><span>    F -->|Valid| G[Set Initial State to Specified Scene]
</span><span>    F -->|Invalid| H[Error: Invalid Scene Name]
</span><span>    E --> I[Set Initial State to Default Scene]
</span><span>    G --> J[App Runs with Specified Scene]
</span><span>    I --> J
</span><span>    H --> K[Exit with Error Message]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=examples-testbed-2d-rs-30-1><code>examples/testbed/2d.rs</code> (+30/-1)</h3><p><strong>Changes</strong>: Added command-line argument parsing to allow specifying which 2D test scene to start with.<p><strong>Key Code Snippets</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (partial):
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> app </span><span style=color:#ed9366>= </span><span>App</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>((DefaultPlugins</span><span style=color:#61676ccc>,</span><span>))
</span><span>        </span><span style=color:#ed9366>.</span><span>init_state</span><span style=color:#ed9366>::</span><span>&LTScene>()  </span><span style=color:#abb0b6;font-style:italic>// Always initialize to default scene
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... other setup
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After (partial):
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(FromArgs)]
</span><span style=color:#abb0b6;font-style:italic>/// 2d testbed
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Args </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>argh</span><span>(positional)]
</span><span>    scene</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTScene>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> args</span><span style=color:#61676ccc>:</span><span> Args </span><span style=color:#ed9366>= </span><span>argh</span><span style=color:#ed9366>::</span><span>from_env()</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// Parse command-line arguments
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> app </span><span style=color:#ed9366>= </span><span>App</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>((DefaultPlugins</span><span style=color:#61676ccc>,</span><span>))
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Removed init_state from here
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Conditional state initialization
</span><span>    </span><span style=color:#fa6e32>match</span><span> args</span><span style=color:#ed9366>.</span><span>scene {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>None </span><span style=color:#ed9366>=></span><span> app</span><span style=color:#ed9366>.</span><span>init_state</span><span style=color:#ed9366>::</span><span>&LTScene>()</span><span style=color:#61676ccc>,      </span><span style=color:#abb0b6;font-style:italic>// Default behavior
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(scene) </span><span style=color:#ed9366>=></span><span> app</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert_state</span><span>(scene)</span><span style=color:#61676ccc>, </span><span style=color:#abb0b6;font-style:italic>// Use specified scene
</span><span>    }</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=examples-testbed-3d-rs-30-1><code>examples/testbed/3d.rs</code> (+30/-1)</h3><p><strong>Changes</strong>: Added identical command-line argument parsing for 3D test scenes.<p><strong>Key Code Snippets</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Scene parsing implementation (identical pattern to 2D.rs):
</span><span style=color:#fa6e32>impl </span><span>std</span><span style=color:#ed9366>::</span><span>str</span><span style=color:#ed9366>::</span><span>FromStr </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Scene </span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Err </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>from_str</span><span>(</span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span>std</span><span style=color:#ed9366>::</span><span>result</span><span style=color:#ed9366>::</span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span>, </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#55b4d4;font-style:italic>Err</span><span>> {
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> isit </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>while</span><span> s</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_lowercase</span><span>() </span><span style=color:#ed9366>!= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{isit:?}</span><span style=color:#86b300>"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_lowercase</span><span>() {
</span><span>            isit </span><span style=color:#ed9366>=</span><span> isit</span><span style=color:#ed9366>.</span><span style=color:#f07171>next</span><span>()</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#fa6e32>if</span><span> isit </span><span style=color:#ed9366>== </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>default() {
</span><span>                </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(</span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"Invalid Scene name: </span><span style=color:#ff8f40>{s}</span><span style=color:#86b300>"</span><span>))</span><span style=color:#61676ccc>;
</span><span>            }
</span><span>        }
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(isit)
</span><span>    }
</span><span>}
</span></code></pre><h3 id=examples-testbed-ui-rs-30-1><code>examples/testbed/ui.rs</code> (+30/-1)</h3><p><strong>Changes</strong>: Added identical command-line argument parsing for UI test scenes.<p><strong>Key Code Snippets</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// The same pattern is applied consistently:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(FromArgs)]
</span><span style=color:#abb0b6;font-style:italic>/// ui testbed
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Args </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>argh</span><span>(positional)]
</span><span>    scene</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTScene>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> args</span><span style=color:#61676ccc>:</span><span> Args </span><span style=color:#ed9366>= </span><span>argh</span><span style=color:#ed9366>::</span><span>from_env()</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... app setup without init_state
</span><span>    
</span><span>    </span><span style=color:#fa6e32>match</span><span> args</span><span style=color:#ed9366>.</span><span>scene {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>None </span><span style=color:#ed9366>=></span><span> app</span><span style=color:#ed9366>.</span><span>init_state</span><span style=color:#ed9366>::</span><span>&LTScene>()</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(scene) </span><span style=color:#ed9366>=></span><span> app</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert_state</span><span>(scene)</span><span style=color:#61676ccc>,
</span><span>    }</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy States Documentation</strong>: Understanding Bevy’s state management system is crucial for working with scenes. The official Bevy documentation covers states in detail: https://bevyengine.org/learn/book/next/programming/states/</p><li><p><strong>argh Crate</strong>: The command-line argument parser used in this PR. Documentation available at: https://docs.rs/argh</p><li><p><strong>FromStr Trait</strong>: Rust’s standard library trait for parsing strings. Official documentation: https://doc.rust-lang.org/std/str/trait.FromStr.html</p><li><p><strong>Bevy Testbed Examples</strong>: To understand the context of these changes, examine the existing testbed examples in the Bevy repository to see how different scenes are implemented and structured.</p></ol><h1 id=full-code-diff>Full Code Diff</h1><p>diff –git a/examples/testbed/2d.rs b/examples/testbed/2d.rs index 1751e0f152a2f..d535147704425 100644 — a/examples/testbed/2d.rs +++ b/examples/testbed/2d.rs @@ -4,13 +4,22 @@<p>mod helpers;<p>+use argh::FromArgs; use bevy::prelude::*; use helpers::Next;<p>+#[derive(FromArgs)] +/// 2d testbed +pub struct Args {<ul><li>#[argh(positional)]<li>scene: Option<scene>, +} <li></li> <p>fn main() {</p> <ul><li>let args: Args = argh::from_env();<li>let mut app = App::new(); app.add_plugins((DefaultPlugins,))</ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   .init_state::&LTScene>()
</span><span>   .add_systems(OnEnter(Scene::Shapes), shapes::setup)
</span><span>   .add_systems(OnEnter(Scene::Bloom), bloom::setup)
</span><span>   .add_systems(OnEnter(Scene::Text), text::setup)
</span></code></pre></ul> <p>@@ -20,6 +29,11 @@ fn main() { .add_systems(Update, switch_scene) .add_systems(Update, gizmos::draw_gizmos.run_if(in_state(Scene::Gizmos)));</p> <ul><li>match args.scene {<li><pre style=color:#61676c;background-color:#fafafa><code><span>   None => app.init_state::&LTScene>(),
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   Some(scene) => app.insert_state(scene),
</span></code></pre><li>};<li>#[cfg(feature = “bevy_ci_testing”)] app.add_systems(Update, helpers::switch_scene_in_ci::<scene>); <p>@@ -37,6 +51,21 @@ enum Scene { Gizmos, }</p> <p>+impl std::str::FromStr for Scene {</p> <ul><li>type Err = String;<li><li>fn from_str(s: &str) -> std::result::Result&LTSelf, Self::Err> {<li><pre style=color:#61676c;background-color:#fafafa><code><span>   let mut isit = Self::default();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   while s.to_lowercase() != format!("{isit:?}").to_lowercase() {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       isit = isit.next();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       if isit == Self::default() {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           return Err(format!("Invalid Scene name: {s}"));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   Ok(isit)
</span></code></pre><li>} +}<li></ul> <p>impl Next for Scene { fn next(&self) -> Self { match self { diff –git a/examples/testbed/3d.rs b/examples/testbed/3d.rs index 64183894865e0..da94d773e2da8 100644 — a/examples/testbed/3d.rs +++ b/examples/testbed/3d.rs @@ -4,13 +4,22 @@</p> <p>mod helpers;</p> <p>+use argh::FromArgs; use bevy::prelude::*; use helpers::Next;</p> <p>+#[derive(FromArgs)] +/// 3d testbed +pub struct Args {</p> <ul><li>#[argh(positional)]<li>scene: Option<scene>, +} <li></li> <p>fn main() {</p> <ul><li>let args: Args = argh::from_env();<li>let mut app = App::new(); app.add_plugins((DefaultPlugins,))</ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   .init_state::&LTScene>()
</span><span>   .add_systems(OnEnter(Scene::Light), light::setup)
</span><span>   .add_systems(OnEnter(Scene::Bloom), bloom::setup)
</span><span>   .add_systems(OnEnter(Scene::Gltf), gltf::setup)
</span></code></pre></ul> <p>@@ -28,6 +37,11 @@ fn main() { .run_if(in_state(Scene::GltfCoordinateConversion)), );</p> <ul><li>match args.scene {<li><pre style=color:#61676c;background-color:#fafafa><code><span>   None => app.init_state::&LTScene>(),
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   Some(scene) => app.insert_state(scene),
</span></code></pre><li>};<li>#[cfg(feature = “bevy_ci_testing”)] app.add_systems(Update, helpers::switch_scene_in_ci::<scene>); <p>@@ -45,6 +59,21 @@ enum Scene { GltfCoordinateConversion, }</p> <p>+impl std::str::FromStr for Scene {</p> <ul><li>type Err = String;<li><li>fn from_str(s: &str) -> std::result::Result&LTSelf, Self::Err> {<li><pre style=color:#61676c;background-color:#fafafa><code><span>   let mut isit = Self::default();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   while s.to_lowercase() != format!("{isit:?}").to_lowercase() {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       isit = isit.next();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       if isit == Self::default() {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           return Err(format!("Invalid Scene name: {s}"));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   Ok(isit)
</span></code></pre><li>} +}<li></ul> <p>impl Next for Scene { fn next(&self) -> Self { match self { diff –git a/examples/testbed/ui.rs b/examples/testbed/ui.rs index edba5ce0803bc..3776d0814e549 100644 — a/examples/testbed/ui.rs +++ b/examples/testbed/ui.rs @@ -4,10 +4,20 @@</p> <p>mod helpers;</p> <p>+use argh::FromArgs; use bevy::prelude::*; use helpers::Next;</p> <p>+#[derive(FromArgs)] +/// ui testbed +pub struct Args {</p> <ul><li>#[argh(positional)]<li>scene: Option<scene>, +} <li></li> <p>fn main() {</p> <ul><li>let args: Args = argh::from_env();<li>let mut app = App::new(); app.add_plugins(DefaultPlugins.set(WindowPlugin { primary_window: Some(Window { @@ -19,7 +29,6 @@ fn main() { }), ..Default::default() }))</ul> <ul><li>.init_state::<scene>() .add_systems(OnEnter(Scene::Image), image::setup) .add_systems(OnEnter(Scene::Text), text::setup) .add_systems(OnEnter(Scene::Grid), grid::setup) @@ -35,6 +44,11 @@ fn main() { .add_systems(OnEnter(Scene::ViewportCoords), viewport_coords::setup) .add_systems(Update, switch_scene); <ul><li>match args.scene {<li><pre style=color:#61676c;background-color:#fafafa><code><span>   None => app.init_state::&LTScene>(),
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   Some(scene) => app.insert_state(scene),
</span></code></pre><li>};<li>#[cfg(feature = “bevy_ui_debug”)] { app.add_systems(OnEnter(Scene::DebugOutlines), debug_outlines::setup); @@ -68,6 +82,21 @@ enum Scene { ViewportCoords, }</ul> <p>+impl std::str::FromStr for Scene {</p> <ul><li>type Err = String;<li><li>fn from_str(s: &str) -> Result&LTSelf, Self::Err> {<li><pre style=color:#61676c;background-color:#fafafa><code><span>   let mut isit = Self::default();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   while s.to_lowercase() != format!("{isit:?}").to_lowercase() {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       isit = isit.next();
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       if isit == Self::default() {
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>           return Err(format!("Invalid Scene name: {s}"));
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>       }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   }
</span></code></pre><li><pre style=color:#61676c;background-color:#fafafa><code><span>   Ok(isit)
</span></code></pre><li>} +}<li></ul> <p>impl Next for Scene { fn next(&self) -> Self { match self {</p>    <div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22223.patch id=patch-info style=display:none></div>  <div class=bottom-spacer></div> 