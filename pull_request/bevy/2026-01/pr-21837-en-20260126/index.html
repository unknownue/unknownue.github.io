<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21837 Improve frustum culling of skinned meshes through per-joint bounds
        
    </title><meta content="#21837 Improve frustum culling of skinned meshes through per-joint bounds" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-26</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-21837-zh-cn-20260126>中文</a></div></div><div class=pr-content><h1 id=improve-frustum-culling-of-skinned-meshes-through-per-joint-bounds>Improve frustum culling of skinned meshes through per-joint bounds</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Improve frustum culling of skinned meshes through per-joint bounds<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21837<li><strong>Author</strong>: greeble-dev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, C-Feature, A-Rendering, S-Ready-For-Final-Review, A-Animation, M-Release-Note<li><strong>Created</strong>: 2025-11-14T11:57:46Z<li><strong>Merged</strong>: 2026-01-26T04:53:29Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>Objective</strong><p>Mostly fix #4971 by adding a new option for updating skinned mesh <code>Aabb</code> components from joint transforms.<p>https://github.com/user-attachments/assets/c25b31fa-142d-462b-9a1d-012ea928f839<p>This fixes cases where vertex positions are only modified through skinning. It doesn’t fix other cases like morph targets and vertex shaders.<p>The PR kind of upstreams <a rel="noopener nofollow noreferrer" href=https://github.com/greeble-dev/bevy_mod_skinned_aabb target=_blank><code>bevy_mod_skinned_aabb</code></a>, but with some changes to make it simpler and more reliable.<p><strong>Dependencies</strong><ul><li>(MERGED) #21732 (or something similar) is desirable to make the new option work with <code>RenderAssetUsages::RENDER_WORLD</code>-only meshes. <ul><li>This PR is authored as if 21732 has landed. But if that doesn’t happen then I can adjust this PR to note the limitation.</ul><li>(Optional) #21845 adds an option related to skinned mesh bounds. <ul><li>Either PR can land first - the second will need to be updated.</ul></ul><p><strong>Background</strong><p>If a main world entity has a <code>Mesh3d</code> component then it’s automatically assigned an <code>Aabb</code> component. This is done by <code>bevy_camera</code> or <code>bevy_gltf</code>. The <code>Aabb</code> is used by <code>bevy_camera</code> for frustum culling. It can also be used by <code>bevy_picking</code> as an optimization, and by third party crates.<p>But there’s a problem - the <code>Aabb</code> can be wrong if something changes the mesh’s vertex positions after the <code>Aabb</code> is calculated. This can be done by vertex shaders - notably skinning and morph targets - or by mutating the <code>Mesh</code> asset (#4294).<p>For the skinning case, the most common solution has been to disable frustum culling via the <code>NoFrustumCulling</code> component. This is simple, and might even be the most efficient approach for apps where meshes tend to stay on-screen. But it’s annoying to implement, bad for apps where meshes are often off-screen, and it only fixes frustum culling - it doesn’t help other systems that use the <code>Aabb</code>.<p><strong>Solution</strong><p>This PR adds a reliable and reasonably efficient method of updating the <code>Aabb</code> of a skinned mesh from its animated joint transforms. See the “How does it work” section for more detail.<p>The glTF loader can add skinned bounds automatically if a new <code>GltfSkinnedMeshBoundsPolicy</code> option is enabled in <code>GltfPlugin</code> or <code>GltfLoaderSettings</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>(DefaultPlugins</span><span style=color:#ed9366>.</span><span style=color:#f07171>set</span><span>(GltfPlugin {
</span><span>    skinned_mesh_bounds_policy</span><span style=color:#61676ccc>: </span><span>GltfSkinnedMeshBoundsPolicy</span><span style=color:#ed9366>::</span><span>Dynamic</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>}))
</span></code></pre><p><em>The new glTF loader option is enabled by default</em>. I think this is the right choice for several reasons:<ul><li>Bugs caused by skinned mesh culling have been a regular pain for both new and experienced users. Now the most common case Just Works(tm).<li>The CPU cost is modest (see later section), and sophisticated users can opt-out.<li>GPU limited apps might see a performance increase if the user was previously disabling culling.</ul><p>Non-glTF cases require some manual steps. The user must ask <code>Mesh</code> to generate the skinned bounds, and then add the <code>DynamicSkinnedMeshBounds</code> marker component to their mesh entity.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>mesh</span><span style=color:#ed9366>.</span><span style=color:#f07171>generate_skinned_mesh_bounds</span><span>()</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> mesh_asset </span><span style=color:#ed9366>=</span><span> mesh_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>add</span><span>(mesh)</span><span style=color:#61676ccc>;
</span><span>entity</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>((Mesh3d(mesh_asset)</span><span style=color:#61676ccc>,</span><span> DynamicSkinnedMeshBounds))</span><span style=color:#61676ccc>;
</span></code></pre><p>See the <code>custom_skinned_mesh</code> example for real code.<p><strong>Bonus Features</strong><p><strong><code>GltfSkinnedMeshBoundsPolicy::NoFrustumCulling</code></strong><p>This is a convenience for users who prefer the <code>NoFrustumCulling</code> workaround, but want to avoid the hassle of adding it after a glTF scene has been spawned.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>(DefaultPlugins</span><span style=color:#ed9366>.</span><span style=color:#f07171>set</span><span>(GltfPlugin {
</span><span>    skinned_mesh_bounds_policy</span><span style=color:#61676ccc>: </span><span>GltfSkinnedMeshBoundsPolicy</span><span style=color:#ed9366>::</span><span>NoFrustumCulling</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>}))
</span></code></pre><p>PR #21845 is also adding an option related to skinned mesh bounds. I’m fine if that PR lands first - I’ll update this PR to include the option.<p><strong>Gizmos</strong><p><code>bevy_gizmos::SkinnedMeshBoundsGizmoPlugin</code> can draw the per-joint AABBs.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>toggle_skinned_mesh_bounds</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>config</span><span style=color:#61676ccc>: </span><span>ResMut&LTGizmoConfigStore>) {
</span><span>    config</span><span style=color:#ed9366>.</span><span>config_mut</span><span style=color:#ed9366>::</span><span>&LTSkinnedMeshBoundsGizmoConfigGroup>()</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1.</span><span>draw_all </span><span style=color:#ed9366>^= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The name is debatable. It’s not technically drawing the bounds of the skinned mesh - it’s drawing the per-joint bounds that contribute to the bounds of the skinned mesh.<p><strong>Testing</strong><pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> test_skinned_mesh_bounds
</span><span>
</span><span style=color:#abb0b6;font-style:italic># Press `B` to show mesh bounds, 'J' to show joint bounds.
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> scene_viewer</span><span style=color:#ff8f40> --features </span><span style=color:#86b300>"free_camera"</span><span style=color:#ed9366> -- </span><span style=color:#86b300>"assets/models/animated/Fox.glb"
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> scene_viewer</span><span style=color:#ff8f40> --features </span><span style=color:#86b300>"free_camera"</span><span style=color:#ed9366> -- </span><span style=color:#86b300>"assets/models/SimpleSkin/SimpleSkin.gltf"
</span><span>
</span><span style=color:#abb0b6;font-style:italic># More complicated mesh downloaded from https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/RecursiveSkeletons
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> scene_viewer</span><span style=color:#ff8f40> --features </span><span style=color:#86b300>"free_camera"</span><span style=color:#ed9366> -- </span><span style=color:#86b300>"RecursiveSkeletons.glb"
</span><span>
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> custom_skinned_mesh
</span></code></pre><p>I also hacked <code>custom_skinned_mesh</code> to simulate awkward cases like rotated and off-screen entities.<p><strong>How Does It Work?</strong><details><summary>Click to expand</summary> <p><strong>Summary</strong></p> <p><code>Mesh::generated_skinned_mesh_bounds</code> calculates an AABB for each joint in the mesh - the AABB encloses all the vertices skinned to that joint. Then every frame, <code>bevy_camera::update_skinned_mesh_bounds</code> uses the current joint transforms to calculate an <code>Aabb</code> that encloses all the joint AABBs.</p> <p>This approach is reliable, in that the final <code>Aabb</code> will always enclose the skinned vertices. But it can be larger than necessary. In practice it’s tight enough to be useful, and rarely more than 50% bigger.</p> <p>This approach works even with non-rigid transforms and soft skinning. If there’s any doubt then I can add more detail.</p> <p><strong>Awkward Bits</strong></p> <p>The solution is not as simple and efficient as it could be.</p> <p><strong>Problem 1: Joint transforms are world-space, <code>Aabb</code> is entity-space.</strong></p> <ul><li>Ideally we’d use the world-space joint transforms to calculate a world-space <code>Aabb</code>, but that’s not possible.<li>The obvious solution is to transform the joints to entity-space, so the <code>Aabb</code> is directly calculated in entity-space. <ul><li>But that means an extra matrix multiply per joint.</ul><li>This PR calculates the <code>Aabb</code> in world-space and then transforms it to entity-space. <ul><li>That avoids a matrix multiply per-joint, but can increase the size of the <code>Aabb</code>.</ul></ul> <p><strong>Problem 2: Joint AABBs are in a surprising(?) space.</strong></p> <ul><li>When creating joint AABBs from a mesh, the intuitive solution would be to calculate them in joint-space. <ul><li>Then the update just has to transform them by the world-space joint transform.</ul><li>But to calculate them in joint-space we need both the bind pose vertex positions and the bind pose joint transforms. <ul><li>These two parts are in separate assets - <code>Mesh</code> and <code>SkinnedMeshInverseBindposes</code> - and those assets can be mixed and matched.<li>So we’d need to calculate a <code>SkinnedMeshBoundsAsset</code> for each combination of <code>Mesh</code> and <code>SkinnedMeshInverseBindposes</code>.<li>(<code>bevy_mod_skinned_aabb</code> uses this approach - it’s slow and fragile.)</ul><li>This PR calculates joint AABBs in <em>mesh-space</em> (or more strictly speaking: bind pose space). <ul><li>That can be done with just the <code>Mesh</code> asset.</ul><li>One downside is that the update needs an extra matrix multiply so we can go from mesh-space to world-space. <ul><li>However, this might become a performance advantage if frustum culling changes - see the “Future Options” section.</ul><li>Another minor downside is that mesh-space AABBs (red in the screenshot below) tend to be bigger than joint-space AABBs (green), since joints with one long axis might be at an awkward angle in mesh-space.</ul> <img alt=image height=759 src=https://github.com/user-attachments/assets/a02a28c3-8882-412c-9be1-64109b767da7 width=1085> <p><strong>Future Options</strong></p> <p>For frustum culling there’s a cheeky way to optimize and simplify skinned bounds - put frustum culling in the renderer and calculate a world-space AABB during <code>extract_skins</code>. The joint transform will be already loaded and in the right space, so we can avoid an entity lookup and matrix multiply. I estimate this would make skinned bounds 3x faster.</p> <p>Another option is to change main world frustum culling to use a world-space AABB. So there would be a new <code>GlobalAabb</code> component that gets updated each frame from <code>Aabb</code> and the entity transform (which is basically the same as transform propagation and the relationship between <code>Transform</code> and <code>GlobalTransform</code>). This has some advantages and disadvantages but I won’t get into them here - I think putting frustum culling into the renderer is a better option.</p> <p>(Note that putting frustum culling into the renderer doesn’t mean removing the current main world visibility system - it just means the main world system would be separate opt-in system)</p></details><p><strong>Performance</strong><details><summary>Click to expand</summary> <p><strong>Initialization</strong></p> <p>Creating the skinned bounds asset for <code>Fox.glb</code> (576 verts, 22 skinned joints) takes <strong>0.03ms</strong>. Loading the whole glTF takes 8.7ms, so this is a <strong>&LT1% increase</strong>.</p> <p><strong>Per-Frame</strong></p> <p>The <code>many_foxes</code> example has 1000 skinned meshes, each with 22 skinned joints. Updating the skinned bounds takes <strong>0.086ms</strong>. This is a throughput of roughly 250,000 joints per millisecond, using two threads.</p> <img alt=image height=861 src=https://github.com/user-attachments/assets/c27165ae-dc6c-4f6b-bbfb-4e211ab0263c width=2404> <p>The whole animation update takes 3.67ms (where “animation update” = advancing players + graph evaluation + transform propagation). So we can kinda sorta claim that this PR increases the cost of skinned animation by roughly <strong>3%</strong>. But that’s very hand-wavey and situation dependent.</p> <p>This was tested on an AMD Ryzen 7900 but with <code>TaskPoolOptions::with_num_threads(6)</code> to simulate a lower spec CPU. Comparing against a few other threading options:</p> <ul><li>Non-parallel: <strong>0.141ms</strong>.<li>6 threads (2 compute threads): <strong>0.086ms</strong>.<li>24 threads (15 compute threads): <strong>0.051ms</strong>.</ul> <p>So the parallel iterator is better but quickly hits diminishing returns as the number of threads increases.</p> <p><strong>Future Options</strong></p> <p>The “How Does It Work” section mentions moving skinned mesh bounds into the renderer’s skin extraction. Based on some microbenchmarks, I estimate this would reduce non-parallel <code>many_foxes</code> from 0.141ms to 0.049ms, so roughly 3x faster. Requiring AVX2 (to enable broadcast loads) or pre-splatting (to fake broadcast loads for SSE) would knock off another 25%. And fancier SIMD approaches could do better again.</p> <p>There’s also approaches that trade reliability for performance. For character rigs, an effective optimization is to fold face and finger joints into a single bound on the head and hand joints. This can reduce the number of joints required by 50-80%.</p></details><p><strong>FAQ</strong><details><summary>Click to expand</summary> <p><strong>Why can’t it be automatically added to any mesh? Then the glTF importer and custom mesh generators wouldn’t need special logic.</strong></p> <p><code>bevy_mod_skinned_aabb</code> took the automatic approach, and I don’t think the outcome was good. It needs some surprisingly fiddly and fragile logic to decide when an entity has the right combination of assets in the right loaded state. And it can never work with <code>RenderAssetUsages::RENDER_WORLD</code>.</p> <p>So this PR takes a more modest and manual approach. I think there’s plenty of scope to generalise and automate as the asset pipeline matures. If the glTF importer becomes a purer glTF -> BSN transform, then adding skinned bounds could be a general scene/asset transform that’s shared with other importers and custom mesh generators.</p> <p><strong>Why is the data in <code>Mesh</code>? Shouldn’t it go in <code>SkinnedMesh</code> or <code>SkinnedMeshInverseBindposes</code>?</strong></p> <p>That might seem intuitive, but it wouldn’t work in practice - the data is derived from <code>Mesh</code> alone. <code>SkinnedMesh</code> doesn’t work because it’s per mesh instance, so the data would be duplicated. <code>SkinnedMeshInverseBindposes</code> doesn’t work because it can be shared between multiple meshes.</p> <p>The names are a bit misleading - <code>Mesh</code> does contain some skinning data, while <code>SkinnedMesh</code> and <code>SkinnedMeshInverseBindposes</code> are more like joint bindings one step removed from the vertex data.</p> <p><strong>Why not put the bounds on the joint entities?</strong></p> <p>This is surprisingly tricky in practice because multiple meshes can be bound to the same joint entity. So there would need to be logic that tracks the bindings and updates the bounds as meshes are added and removed.</p> <p><strong>Why is the <code>DynamicSkinnedMeshBounds</code> component required?</strong></p> <p>It’s an optimisation for users who want to opt out. It might also be useful for future expansion, like adding options to approximate the bounds with an AABB attached to a single joint.</p> <p><strong>Why are the update system and <code>DynamicSkinnedMeshBounds</code> component in <code>bevy_camera</code>? Shouldn’t they be in <code>bevy_mesh</code>?</strong></p> <p><code>bevy_camera</code> is the owner and main user of <code>Aabb</code>, and already has some mesh related logic (<code>calculate_bounds</code> automatically adds an <code>Aabb</code> to mesh entities). So putting it in <code>bevy_camera</code> is consistent with the current structure. I’d agree that it’s a little awkward though and could change in future.</p></details><p><strong>What Do Other Engines Do?</strong><details><summary>Click to expand</summary> <ul><li><strong>Unreal</strong>: Automatically uses <a rel="noopener nofollow noreferrer" href=https://dev.epicgames.com/documentation/en-us/unreal-engine/physics-asset-editor-in-unreal-engine target=_blank>collision shapes</a> attached to joints, which is similar to this PR in practice but fragile and inefficient. Also supports various fixed bounds options.<li><strong>Unity</strong>: Fixed bounds attached to the root bone. Automatically calculated from animation poses or specified manually (<a rel="noopener nofollow noreferrer" href=https://docs.unity3d.com/6000.4/Documentation/Manual/troubleshooting-skinned-mesh-renderer-visibility.html target=_blank>documentation</a>).<li><strong>Godot</strong>: Appears to use roughly the same method as this PR, although I didn’t 100% confirm. See <a rel="noopener nofollow noreferrer" href=https://github.com/godotengine/godot/blob/fafc07335bdecacd96b548c4119fbe1f47ee5866/servers/rendering/renderer_rd/storage_rd/mesh_storage.cpp#L650 target=_blank><code>MeshStorage::mesh_get_aabb</code></a> and <a rel="noopener nofollow noreferrer" href=https://github.com/godotengine/godot/blob/235a32ad11f40ecba26d6d9ceea8ab245c13adb0/servers/rendering/renderer_scene_cull.cpp#L1991 target=_blank><code>RendererSceneCull::_update_instance_aabb</code></a>.<li><strong>O3DE</strong>: Fixed bounds attached to root bone, plus option to approximate the AABB from joint origins and a fudge factor.<li><strong>Northlight</strong> (Remedy, Alan Wake 2): Specifically for vegetation, calculates bounds from joint extents on GPU (<a rel="noopener nofollow noreferrer" href=https://gdcvault.com/play/1034310/Large-Scale-GPU-Based-Skinning target=_blank>source</a>, slide 48)</ul> <p>An approach that’s been proposed several times for Bevy is copying Unity’s “fixed AABB from animation poses”. I think this is more complicated and less reliable than many people expect. More complicated because linking animations to meshes can often be difficult. Less reliable because it doesn’t account for ragdolls and procedural animation. But it could still be viable for for simple cases like a single self-contained glTF with basic animation.</p></details><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>In Bevy, entities with <code>Mesh3d</code> components automatically receive <code>Aabb</code> components for frustum culling. This system works well for static meshes, but fails for skinned meshes where vertex positions change each frame due to skeletal animation. The <code>Aabb</code> is calculated once from the bind pose and never updated, causing meshes to disappear at certain camera angles when they should remain visible. This was a persistent issue documented in #4971, affecting both new and experienced users.<p>The existing workaround involved manually adding a <code>NoFrustumCulling</code> component to skinned mesh entities. While simple, this approach had significant downsides: it required manual setup, performed poorly when meshes were off-screen, and only addressed frustum culling while leaving other <code>Aabb</code>-dependent systems (like picking optimizations) with incorrect data.<h3 id=the-solution-approach>The Solution Approach</h3><p>The solution implements per-joint bounding volume calculations that update each frame with animated joint transforms. The approach calculates an AABB for each joint that encloses all vertices skinned to that joint, stored in mesh-space (bind pose space). Each frame, these joint AABBs are transformed to world space using current joint transforms, merged into a single world-space AABB, then transformed back to entity space for the <code>Aabb</code> component.<p>This design prioritizes reliability over perfect tightness - the calculated AABB always encloses the skinned mesh, though it may be slightly larger than necessary. The implementation avoids complex dependency tracking by calculating bounds from the <code>Mesh</code> asset alone, making it robust against asset combinations.<h3 id=the-implementation>The Implementation</h3><p>The core implementation spans multiple modules:<p><strong>1. Skinned Mesh Bounds Data Structure (<code>bevy_mesh/src/skinning.rs</code>)</strong> The <code>SkinnedMeshBounds</code> struct stores joint AABBs in mesh-space, avoiding dependencies on <code>SkinnedMeshInverseBindposes</code>. This allows bounds calculation using only the <code>Mesh</code> asset:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>SkinnedMeshBounds </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>aabbs</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTJointAabb>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>aabb_index_to_joint_index</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTJointIndex>,
</span><span>}
</span></code></pre><p>The <code>JointAabb</code> type is optimized for transformation operations using center/half_size representation. The <code>from_mesh()</code> method processes vertex positions and joint influences to build the bounds:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>from_mesh</span><span>(</span><span style=color:#ff8f40>mesh</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Mesh) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTSkinnedMeshBounds, SkinnedMeshBoundsError> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> vertex_positions </span><span style=color:#ed9366>= </span><span style=color:#f07171>expect_attribute_float32x3</span><span>(mesh</span><span style=color:#61676ccc>, </span><span>Mesh</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_POSITION</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> vertex_influences </span><span style=color:#ed9366>= </span><span>InfluenceIterator</span><span style=color:#ed9366>::</span><span>new(mesh)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... accumulate AABBs per joint
</span><span>}
</span></code></pre><p><strong>2. Mesh Integration (<code>bevy_mesh/src/mesh.rs</code>)</strong> The <code>Mesh</code> struct gains storage for skinned bounds and convenience methods:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>generate_skinned_mesh_bounds</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), SkinnedMeshBoundsError> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>skinned_mesh_bounds </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(SkinnedMeshBounds</span><span style=color:#ed9366>::</span><span>from_mesh(</span><span style=color:#55b4d4;font-style:italic>self</span><span>)</span><span style=color:#ed9366>?</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>skinned_mesh_bounds</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>SkinnedMeshBounds> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>skinned_mesh_bounds</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>()
</span><span>}
</span></code></pre><p><strong>3. Update System (<code>bevy_camera/src/visibility/mod.rs</code>)</strong> A new <code>DynamicSkinnedMeshBounds</code> component marks skinned meshes for dynamic updates. The <code>update_skinned_mesh_bounds</code> system processes these entities each frame:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>update_skinned_mesh_bounds</span><span>(
</span><span>    </span><span style=color:#ff8f40>inverse_bindposes_assets</span><span style=color:#61676ccc>: </span><span>Res&LTAssets&LTSkinnedMeshInverseBindposes>>,
</span><span>    </span><span style=color:#ff8f40>mesh_assets</span><span style=color:#61676ccc>: </span><span>Res&LTAssets&LTMesh>>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>mesh_entities</span><span style=color:#61676ccc>: </span><span>Query<
</span><span>        (</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Aabb, </span><span style=color:#ed9366>&</span><span>Mesh3d, </span><span style=color:#ed9366>&</span><span>SkinnedMesh, </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>GlobalTransform>),
</span><span>        With&LTDynamicSkinnedMeshBounds>,
</span><span>    >,
</span><span>    </span><span style=color:#ff8f40>joint_entities</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span>GlobalTransform>,
</span><span>) {
</span><span>    mesh_entities
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>par_iter_mut</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>for_each</span><span>(|(</span><span style=color:#ff8f40>mut aabb</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>mesh</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>skinned_mesh</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>world_from_entity</span><span>)| {
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// ... calculate and update Aabb
</span><span>        })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The system uses parallel iteration for performance, with each entity’s bounds updated independently.<p><strong>4. Transformation Algorithm</strong> The key transformation function uses the Arvo algorithm for efficient AABB transformation:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>transform_aabb</span><span>(</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>:</span><span> JointAabb, </span><span style=color:#ff8f40>transform</span><span style=color:#61676ccc>:</span><span> Affine3A) </span><span style=color:#61676ccc>-></span><span> Aabb3d {
</span><span>    </span><span style=color:#fa6e32>let</span><span> mx </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span>matrix3</span><span style=color:#ed9366>.</span><span>x_axis</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> my </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span>matrix3</span><span style=color:#ed9366>.</span><span>y_axis</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> mz </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span>matrix3</span><span style=color:#ed9366>.</span><span>z_axis</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> mt </span><span style=color:#ed9366>=</span><span> transform</span><span style=color:#ed9366>.</span><span>translation</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> cx </span><span style=color:#ed9366>= </span><span>Vec3A</span><span style=color:#ed9366>::</span><span>splat(input</span><span style=color:#ed9366>.</span><span>center</span><span style=color:#ed9366>.</span><span>x)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> cy </span><span style=color:#ed9366>= </span><span>Vec3A</span><span style=color:#ed9366>::</span><span>splat(input</span><span style=color:#ed9366>.</span><span>center</span><span style=color:#ed9366>.</span><span>y)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> cz </span><span style=color:#ed9366>= </span><span>Vec3A</span><span style=color:#ed9366>::</span><span>splat(input</span><span style=color:#ed9366>.</span><span>center</span><span style=color:#ed9366>.</span><span>z)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> sx </span><span style=color:#ed9366>= </span><span>Vec3A</span><span style=color:#ed9366>::</span><span>splat(input</span><span style=color:#ed9366>.</span><span>half_size</span><span style=color:#ed9366>.</span><span>x)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> sy </span><span style=color:#ed9366>= </span><span>Vec3A</span><span style=color:#ed9366>::</span><span>splat(input</span><span style=color:#ed9366>.</span><span>half_size</span><span style=color:#ed9366>.</span><span>y)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> sz </span><span style=color:#ed9366>= </span><span>Vec3A</span><span style=color:#ed9366>::</span><span>splat(input</span><span style=color:#ed9366>.</span><span>half_size</span><span style=color:#ed9366>.</span><span>z)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> tc </span><span style=color:#ed9366>= </span><span>(mx </span><span style=color:#ed9366>*</span><span> cx) </span><span style=color:#ed9366>+ </span><span>(my </span><span style=color:#ed9366>*</span><span> cy) </span><span style=color:#ed9366>+ </span><span>(mz </span><span style=color:#ed9366>*</span><span> cz) </span><span style=color:#ed9366>+</span><span> mt</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> ts </span><span style=color:#ed9366>= </span><span>(mx</span><span style=color:#ed9366>.</span><span style=color:#f07171>abs</span><span>() </span><span style=color:#ed9366>*</span><span> sx) </span><span style=color:#ed9366>+ </span><span>(my</span><span style=color:#ed9366>.</span><span style=color:#f07171>abs</span><span>() </span><span style=color:#ed9366>*</span><span> sy) </span><span style=color:#ed9366>+ </span><span>(mz</span><span style=color:#ed9366>.</span><span style=color:#f07171>abs</span><span>() </span><span style=color:#ed9366>*</span><span> sz)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    Aabb3d { min</span><span style=color:#61676ccc>:</span><span> tc </span><span style=color:#ed9366>-</span><span> ts</span><span style=color:#61676ccc>,</span><span> max</span><span style=color:#61676ccc>:</span><span> tc </span><span style=color:#ed9366>+</span><span> ts }
</span><span>}
</span></code></pre><p>This avoids transforming all eight corners of the AABB while guaranteeing the transformed box encloses the original.<p><strong>5. glTF Integration (<code>crates/bevy_gltf/src/lib.rs</code>, <code>loader/mod.rs</code>)</strong> A new <code>GltfSkinnedMeshBoundsPolicy</code> enum provides configuration options. The default <code>Dynamic</code> policy automatically generates skinned bounds and adds <code>DynamicSkinnedMeshBounds</code> to skinned mesh entities:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>GltfSkinnedMeshBoundsPolicy </span><span>{
</span><span>    BindPose</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>default</span><span>]
</span><span>    Dynamic</span><span style=color:#61676ccc>,
</span><span>    NoFrustumCulling</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>**6. Debug Visualization (`crates/</div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_21837.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>