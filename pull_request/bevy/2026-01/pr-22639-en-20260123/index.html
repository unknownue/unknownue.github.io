<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22639 Improve realism of entity benches by warming up the entity allocator
        
    </title><meta content="#22639 Improve realism of entity benches by warming up the entity allocator" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-23</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22639-zh-cn-20260123>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Improve realism of entity benches by warming up the entity allocator<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Improve realism of entity benches by warming up the entity allocator<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22639<li><strong>Author</strong>: ElliottjPierce<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Benchmarks, D-Straightforward, S-Needs-Review<li><strong>Created</strong>: 2026-01-22T02:46:25Z<li><strong>Merged</strong>: 2026-01-23T02:23:17Z<li><strong>Merged By</strong>: cart</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>As per <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/18670#issuecomment-3776301267 target=_blank>this</a> comment on #18670, this PR attempts to make entity related benchmarks more realistic by warming up the entity allocator. This helps test the freelist in the entity allocator.<h2 id=solution>Solution</h2><p>This PR introduces a new <code>WorldBuilder</code> type that starts with <code>World::new</code>, allows configuration options for warming up the world via the builder pattern, and then builds the warmed up, realistic world. For now, the only available “warm up” is for entities, but we could also add functionality in the future to cache bundle info, pre-create tables, etc to make our benchmarks more realistic. That is, more closely match the performance of a running app, rather than an app at startup.<p>The current implementation for entity warmups allocates some entities and frees them in a random order. It also spawns the highest allocated entity index to prepare <code>Entities</code>’s location storage, etc. This involves using <code>rng</code> (deterministically), but without this, the entities are allocated in a linear index order (0, 1, 2, …), which is unrealistic and extremely cache friendly (so it probably makes an impact in performance not desirable for a benchmark).<p>The major downsides here are that the benches take a little longer to run now and that startup/caching time is no longer benchmarked. That is for example, that benchmarking despawning only one entity used to tell us some information about performance of allocating the free list (amongst other one time actions). Now, that information is lost since the world is already warmed up. In practice, for N values of entities, it used to be the case that a higher N showed the performance of the operation, and a lower N showed the performance of the operation + any registration/caching costs. Now, the different N values only tell us more about how well the CPU accommodates a batch of the operation.<p>Currently in Bevy, making a change might make the <code>...1_entity</code> benches much worse but the <code>...1000_entities</code> much much better because the change added some new caching. The inverse is also common. With this PR, that will no longer be the case, at least for entities and whatever else we add to the <code>WorldBuilder</code> in the future. And that change may or may not be desirable.<h2 id=testing>Testing</h2><p>Ran a sampling of the benchmarks.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This pull request addresses a fundamental issue with Bevy’s ECS benchmarks: they weren’t testing realistic runtime conditions. When benchmarks used <code>World::new()</code> or <code>World::default()</code> to create a fresh world, they were measuring startup behavior with a “cold” entity allocator, not the performance characteristics of a running application where entities have been allocated and freed in non-sequential patterns.<p>The problem originated from how entity IDs are allocated. In a fresh world, entities get sequential IDs (0, 1, 2, …), which is extremely cache-friendly and doesn’t exercise the entity allocator’s freelist mechanism. In real applications, entities are created and destroyed in arbitrary orders, leaving gaps that get reused through the freelist. This creates fragmentation that affects memory layout and cache performance.<p>The solution introduces a <code>WorldBuilder</code> utility specifically for benchmarks. Instead of starting with a cold world, benchmarks can now use this builder to create a “hot” world with a warmed-up entity allocator. The implementation follows a straightforward pattern:<ol><li>Allocate a batch of entities (default: 10,000)<li>Spawn and immediately despawn the highest-index entity to prepare the <code>Entities</code> storage<li>Shuffle the entity IDs using a deterministic RNG<li>Free them in random order to create realistic freelist fragmentation</ol><p>This approach ensures that subsequent entity allocations in the benchmark won’t get sequential IDs but will instead draw from a fragmented freelist, better simulating real-world conditions.<p>The technical implementation centers around a new <code>WorldBuilder</code> struct in <code>main.rs</code>. It uses the builder pattern to configure warm-up operations, starting with the most important one: <code>warm_up_entity_allocator()</code>. This method handles the allocation/freeing cycle and uses <code>SmallRng</code> with a fixed seed for deterministic benchmarks.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>warm_up_entity_allocator</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// allocate
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> entities </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>reserve_exact</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>max_expected_entities </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#61676ccc>;
</span><span>    entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc_many</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>max_expected_entities)</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Spawn the high index to warm up `Entities`.
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(high_index) </span><span style=color:#ed9366>=</span><span> entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_mut</span><span>() </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// There were no expected entities.
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_empty_at</span><span>(</span><span style=color:#ed9366>*</span><span>high_index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ed9366>*</span><span>high_index </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_despawn_no_free</span><span>(</span><span style=color:#ed9366>*</span><span>high_index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// free
</span><span>    entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>shuffle</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>rng)</span><span style=color:#61676ccc>;
</span><span>    entities
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>(</span><span style=color:#ed9366>..</span><span>)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>for_each</span><span>(|</span><span style=color:#ff8f40>e</span><span>| </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>free</span><span>(e))</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self
</span><span>}
</span></code></pre><p>The PR updates five benchmark files to use this new <code>WorldBuilder</code>:<ul><li><code>commands.rs</code>: For command spawning and insertion benchmarks<li><code>spawn.rs</code>: For entity spawning benchmarks<li><code>despawn.rs</code>: For entity despawning benchmarks<li><code>despawn_recursive.rs</code>: For recursive despawning benchmarks</ul><p>Each benchmark now follows the same pattern: create the world using <code>WorldBuilder</code>, configure it with the expected entity count, warm up the entity allocator, and then run the benchmark operations.<p>There are important trade-offs with this approach. Benchmarks now take longer to run due to the warm-up phase, and they no longer measure startup costs like first-time component registration or table creation. This changes how benchmark results should be interpreted - previously, low entity counts could show startup costs while high counts showed batch operation performance. Now, all entity counts primarily measure batch operation performance on a pre-warmed system.<p>The PR author notes that this might not always be desirable, as it obscures the impact of caching mechanisms. A change that improves caching might show up as worse performance in 1-entity benchmarks but better in 1000-entity benchmarks with the old approach. With this change, that distinction disappears.<p>The implementation includes careful engineering decisions:<ol><li><strong>Deterministic RNG</strong>: Uses a fixed seed (<code>2039482342342</code>) to ensure benchmark reproducibility<li><strong>Configurable entity count</strong>: The <code>with_max_expected_entities()</code> method lets benchmarks tailor the warm-up to their specific needs<li><strong>High-index preparation</strong>: Spawning and despawning the highest entity ensures <code>Entities</code> storage is properly sized<li><strong>Randomized freeing order</strong>: The shuffle operation creates realistic freelist fragmentation patterns</ol><p>This change represents a shift in benchmarking philosophy - from measuring startup performance to measuring steady-state runtime performance. It provides more realistic data for optimization decisions in production scenarios while sacrificing some visibility into initialization costs.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Benchmark Setup] --> B[WorldBuilder::new()]
</span><span>    B --> C[.with_max_expected_entities()]
</span><span>    C --> D[.warm_up_entity_allocator()]
</span><span>    D --> E[Allocate Entities]
</span><span>    E --> F[Spawn/Despawn Highest Entity]
</span><span>    F --> G[Shuffle Entity IDs]
</span><span>    G --> H[Free in Random Order]
</span><span>    H --> I[.build()]
</span><span>    I --> J[Benchmark Operations]
</span><span>    J --> K[Spawn/Despawn/Query/etc]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=benches-benches-bevy-ecs-main-rs-77-0><code>benches/benches/bevy_ecs/main.rs</code> (+77/-0)</h3><p>Added a new <code>world_builder</code> module that provides the <code>WorldBuilder</code> struct for creating pre-warmed worlds. This is the core infrastructure that enables realistic benchmarking.<p><strong>Key code:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>WorldBuilder </span><span>{
</span><span>    world</span><span style=color:#61676ccc>:</span><span> World,
</span><span>    rng</span><span style=color:#61676ccc>:</span><span> SmallRng,
</span><span>    max_expected_entities</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>WorldBuilder </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>new</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#fa6e32>Self </span><span>{
</span><span>            world</span><span style=color:#61676ccc>: </span><span>World</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>,
</span><span>            rng</span><span style=color:#61676ccc>: </span><span>SmallRng</span><span style=color:#ed9366>::</span><span>seed_from_u64(</span><span style=color:#ff8f40>2039482342342</span><span>)</span><span style=color:#61676ccc>,
</span><span>            max_expected_entities</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>10_000</span><span style=color:#61676ccc>,
</span><span>        }
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>warm_up_entity_allocator</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Implementation as shown above
</span><span>    }
</span><span>}
</span></code></pre><h3 id=benches-benches-bevy-ecs-world-commands-rs-19-5><code>benches/benches/bevy_ecs/world/commands.rs</code> (+19/-5)</h3><p>Updated command-related benchmarks to use <code>WorldBuilder</code> instead of <code>World::default()</code>. This affects spawn commands, non-empty spawn commands, and insert commands.<p><strong>Key change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>WorldBuilder</span><span style=color:#ed9366>::</span><span>new()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_max_expected_entities</span><span>(entity_count)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>warm_up_entity_allocator</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=benches-benches-bevy-ecs-world-spawn-rs-11-3><code>benches/benches/bevy_ecs/world/spawn.rs</code> (+11/-3)</h3><p>Updated entity spawning benchmarks. Also fixed a type conversion issue where <code>batch_count</code> (a <code>u32</code>) was passed directly to <code>std::iter::repeat_n()</code> which expects <code>usize</code>.<p><strong>Key change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_batch</span><span>(std</span><span style=color:#ed9366>::</span><span>iter</span><span style=color:#ed9366>::</span><span>repeat_n(
</span><span>    (A(Mat4</span><span style=color:#ed9366>::</span><span>default())</span><span style=color:#61676ccc>,</span><span> B(Vec4</span><span style=color:#ed9366>::</span><span>default()))</span><span style=color:#61676ccc>,
</span><span>    batch_count</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// u32, potentially causing issues
</span><span>))</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_batch</span><span>(std</span><span style=color:#ed9366>::</span><span>iter</span><span style=color:#ed9366>::</span><span>repeat_n(
</span><span>    (A(Mat4</span><span style=color:#ed9366>::</span><span>default())</span><span style=color:#61676ccc>,</span><span> B(Vec4</span><span style=color:#ed9366>::</span><span>default()))</span><span style=color:#61676ccc>,
</span><span>    batch_count </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>usize</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// Explicit conversion
</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=benches-benches-bevy-ecs-world-despawn-rs-6-1><code>benches/benches/bevy_ecs/world/despawn.rs</code> (+6/-1)</h3><p>Updated entity despawning benchmarks to use the warmed-up world.<h3 id=benches-benches-bevy-ecs-world-despawn-recursive-rs-6-1><code>benches/benches/bevy_ecs/world/despawn_recursive.rs</code> (+6/-1)</h3><p>Updated recursive despawning benchmarks with the same pattern.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy ECS Architecture</strong>: Understanding Bevy’s Entity Component System architecture helps contextualize why entity allocation patterns matter<li><strong>Memory Fragmentation</strong>: Research on how memory fragmentation affects cache performance and allocation strategies<li><strong>Deterministic Benchmarking</strong>: Techniques for creating reproducible benchmarks, especially important for CI/CD pipelines<li><strong>Builder Pattern</strong>: The builder pattern used in <code>WorldBuilder</code> is a common Rust idiom for complex object construction<li><strong>Freelist Allocators</strong>: How freelist-based allocators work and their performance characteristics compared to sequential allocators</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22639.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>