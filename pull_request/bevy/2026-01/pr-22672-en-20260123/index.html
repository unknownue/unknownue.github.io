<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22672 Fix spawn batch bug
        
    </title><meta content="#22672 Fix spawn batch bug" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-23</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22672-zh-cn-20260123>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=fix-spawn-batch-bug>Fix spawn batch bug</h2><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix spawn batch bug<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22672<li><strong>Author</strong>: ElliottjPierce<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-ECS, P-Crash, S-Needs-Review<li><strong>Created</strong>: 2026-01-23T21:13:22Z<li><strong>Merged</strong>: 2026-01-23T23:04:37Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>#18670 introduced a small but fatal issue with batch spawning. Previous tests did not catch this bug because they tested <code>alloc</code> and <code>alloc_many</code> separately.<h2 id=solution>Solution</h2><ul><li>Fix an off by one math mistake in <code>FreeBufferIterator::next</code>.<li>Fix the part where you need to <code>ptr.add(index)</code> if you want the element at <code>index</code>. Whoops.<li>Add a test to catch these issues next time</ul><h2 id=testing>Testing</h2><ul><li>CI<li>One new test<li>This was originally found <a rel="noopener nofollow noreferrer" href=https://discord.com/channels/691052431525675048/749335865876021248/1464359124950319114 target=_blank>here</a>, and the reproduction crashes on main but is fine on this branch.</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a critical bug in Bevy’s ECS entity allocation system that was introduced in PR #18670. The bug specifically affected batch entity spawning (using <code>alloc_many</code>) and could lead to crashes or undefined behavior due to memory access issues.<p>The problem originated from two distinct but related issues in the entity allocation code. First, there was an off-by-one error in the <code>FreeBufferIterator::next</code> method that could cause incorrect iteration logic. Second, and more critically, the <code>Chunk::entity_slice</code> method was incorrectly computing pointer offsets when accessing entities within a chunk, completely ignoring the index parameter that was passed to it.<p>These bugs were particularly insidious because they only manifested when using <code>alloc_many</code> for batch entity allocation. The existing test suite had gaps - it tested individual allocation (<code>alloc</code>) and batch allocation (<code>alloc_many</code>) separately, but didn’t have comprehensive tests that validated the interaction between these two allocation methods, especially when entities were freed and reallocated.<p>The fix involved two key changes. In <code>Chunk::entity_slice</code>, the method now correctly adds the index offset to the base pointer before creating a slice, ensuring that it returns entities starting from the specified index rather than always from the beginning of the chunk. In <code>FreeBufferIterator::next</code>, the logic was corrected to properly handle the case where there are no remaining indices to iterate through, preventing potential out-of-bounds access.<p>To prevent regression, a new test called <code>allocation_order_correctness</code> was added. This test deliberately creates a scenario where entities are allocated, freed, and then reallocated using a mix of individual and batch allocation methods. The test verifies that the reallocation order matches expectations, which would have caught this bug if it had been present during the original implementation.<p>The bug was discovered through community reporting on Discord, where a user encountered crashes when using batch spawning. This highlights the value of real-world testing and community feedback in identifying edge cases that might not be covered by existing unit tests.<p>From an engineering perspective, this PR demonstrates several important lessons. First, it shows how subtle pointer arithmetic errors can have significant consequences in systems programming. Second, it illustrates the importance of comprehensive testing that covers not just individual components but also their interactions. Third, it underscores the need for careful review when modifying low-level memory management code, especially in performance-critical systems like game engines.<p>The fixes are minimal but crucial - changing just a few lines of code resolves a potential crash scenario. The addition of the test case provides a safety net for future changes to the entity allocation system, ensuring that similar bugs won’t slip through undetected.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Entity Allocator] --> B[alloc]
</span><span>    A --> C[alloc_many]
</span><span>    A --> D[free]
</span><span>    
</span><span>    B --> E[Individual Allocation]
</span><span>    C --> F[Batch Allocation]
</span><span>    
</span><span>    E --> G[Chunk Management]
</span><span>    F --> G
</span><span>    
</span><span>    G --> H[Pointer Arithmetic Bug]
</span><span>    G --> I[Iterator Logic Bug]
</span><span>    
</span><span>    H --> J[Crash/Undefined Behavior]
</span><span>    I --> J
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-entity-remote-allocator-rs-33-2><code>crates/bevy_ecs/src/entity/remote_allocator.rs</code> (+33/-2)</h3><p>This file contains the core entity allocation logic for Bevy’s ECS system. The changes fix critical bugs in the entity chunk management and iteration code.<p><strong>Key modifications:</strong><ol><li><strong>Fixed pointer offset calculation in <code>Chunk::entity_slice</code>:</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>unsafe </span><span>{ core</span><span style=color:#ed9366>::</span><span>slice</span><span style=color:#ed9366>::</span><span>from_raw_parts(head</span><span style=color:#61676ccc>,</span><span> len) }
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>unsafe </span><span>{ core</span><span style=color:#ed9366>::</span><span>slice</span><span style=color:#ed9366>::</span><span>from_raw_parts(head</span><span style=color:#ed9366>.</span><span style=color:#f07171>add</span><span>(index </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#61676ccc>,</span><span> len) }
</span></code></pre><p>This fix ensures that when accessing entities within a chunk, the method correctly offsets the pointer by the specified index. Previously, it was always returning a slice starting from the beginning of the chunk, regardless of the index parameter.<ol start=2><li><strong>Fixed iteration logic in <code>FreeBufferIterator::next</code>:</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Key change in the method:
</span><span style=color:#fa6e32>if</span><span> still_need </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0 </span><span>{
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>}
</span><span style=color:#fa6e32>let</span><span> next_index </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>future_buffer_indices</span><span style=color:#ed9366>.</span><span>start</span><span style=color:#61676ccc>;
</span></code></pre><p>The iterator now correctly checks if there are remaining indices to process and returns <code>None</code> when exhausted. This prevents potential out-of-bounds access and ensures proper iteration termination.<ol start=3><li><strong>Added comprehensive test case:</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>allocation_order_correctness</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> allocator </span><span style=color:#ed9366>= </span><span>Allocator</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test sequence that would trigger the bug:
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 1. Allocate 4 entities
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 2. Free all of them
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 3. Reallocate using mix of individual and batch allocation
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 4. Verify reallocation order matches expectations
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... test implementation ...
</span><span>}
</span></code></pre><p>This new test validates that entity allocation order remains correct even when mixing individual and batch allocation methods, which was the scenario that exposed the original bug.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy ECS Documentation</strong>: The official Bevy ECS documentation provides comprehensive information about entity allocation and management patterns.<li><strong>Rust Unsafe Code Guidelines</strong>: Understanding Rust’s unsafe code practices is crucial when working with low-level memory management like in this PR.<li><strong>Entity Component System Architecture</strong>: General patterns and best practices for ECS implementations in game engines.<li><strong>Pointer Arithmetic in Systems Programming</strong>: Resources on safe pointer manipulation techniques in systems programming languages.<li><strong>Test-Driven Development for Game Engines</strong>: Approaches to designing comprehensive test suites for complex systems like game engines.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22672.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>