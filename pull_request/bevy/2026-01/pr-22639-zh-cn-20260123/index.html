<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22639 Improve realism of entity benches by warming up the entity allocator
        
    </title><meta content="#22639 Improve realism of entity benches by warming up the entity allocator" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-23</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-01/pr-22639-en-20260123>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Improve realism of entity benches by warming up the entity allocator<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22639<li><strong>Author</strong>: ElliottjPierce<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Benchmarks, D-Straightforward, S-Needs-Review<li><strong>Created</strong>: 2026-01-22T02:46:25Z<li><strong>Merged</strong>: 2026-01-23T02:23:17Z<li><strong>Merged By</strong>: cart</ul><h2 id=description-translation>Description Translation</h2><p>根据 #18670 中的<a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/18670#issuecomment-3776301267 target=_blank>评论</a>，该PR尝试通过预热实体分配器（entity allocator）使实体相关的基准测试更加真实。这有助于测试实体分配器中的空闲列表（freelist）。<h2 id=jie-jue-fang-an>解决方案</h2><p>该PR引入了一个新的 <code>WorldBuilder</code> 类型，该类型从 <code>World::new</code> 开始，通过构建器模式（builder pattern）提供预热世界的配置选项，然后构建预热后的真实世界。目前，唯一的“预热“功能是针对实体的，但未来我们也可以添加功能来缓存bundle信息、预创建表等，使基准测试更加真实。即，更接近运行中应用的性能，而不是启动时应用的性能。<p>当前的实体预热实现分配一些实体并以随机顺序释放它们。它还会生成最高分配的实体索引以准备 <code>Entities</code> 的位置存储等。这涉及使用 <code>rng</code>（确定性地），但如果没有这个，实体会按线性索引顺序（0, 1, 2, …）分配，这是不现实的且对缓存极其友好（因此可能对基准测试不期望的性能产生影响）。<p>这里的主要缺点是基准测试现在需要稍长一点的时间来运行，并且启动/缓存时间不再被基准测试。例如，以前只基准测试反生成（despawn）一个实体可以告诉我们一些关于分配空闲列表（以及其他一次性操作）性能的信息。现在，这些信息丢失了，因为世界已经被预热。实际上，对于实体的N个值，过去的情况是：较高的N显示操作的性能，较低的N显示操作 + 任何注册/缓存成本。现在，不同的N值只更多地告诉我们CPU如何处理一批操作。<p>目前在Bevy中，进行更改可能会使 <code>...1_entity</code> 基准测试变得更差，但使 <code>...1000_entities</code> 基准测试变得更好，因为该更改添加了一些新的缓存。反之亦然。通过此PR，这种情况将不再发生，至少对于实体以及未来我们添加到 <code>WorldBuilder</code> 的任何其他内容是如此。这种变化可能理想，也可能不理想。<h2 id=ce-shi>测试</h2><p>运行了部分基准测试的抽样。<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=wen-ti-yu-bei-jing>问题与背景</h3><p>在Bevy引擎中，基准测试（benchmark）对于评估性能改进至关重要。然而，现有的实体相关基准测试存在一个关键问题：它们使用的是“冷“世界（cold world），即通过 <code>World::new</code> 或 <code>World::default</code> 创建的全新世界。在这种冷世界中，实体分配器是全新的，实体ID按顺序分配（0, 1, 2, …），空闲列表（freelist）为空，<code>Entities</code> 存储也没有预分配。<p>这种设置虽然能测量启动成本和初始分配性能，但不能反映运行中应用的典型状态。在一个长时间运行的应用中，实体会被频繁创建和销毁，导致实体分配器中的空闲列表被填充，实体ID变得分散，<code>Entities</code> 存储也会被扩展以容纳更高的实体索引。这些因素都会影响实体操作的性能，尤其是内存访问模式和缓存效率。<p>正如PR描述中提到的，先前的一个PR（#18670）的评论指出了这个问题，并建议预热实体分配器以获得更真实的基准测试结果。<h3 id=jie-jue-fang-an-fang-fa>解决方案方法</h3><p>开发者采用了构建器模式（builder pattern）来创建一个灵活的 <code>WorldBuilder</code>，专门用于生成预热后的世界。这种方法有几个优点：<ol><li><strong>可配置性</strong>：可以针对不同的基准测试需求配置不同的预热选项（目前只有实体预热，但设计上支持扩展）。<li><strong>隔离性</strong>：预热逻辑集中在 <code>WorldBuilder</code> 中，不污染生产代码。<li><strong>可控性</strong>：使用确定性的随机数生成器（RNG），确保基准测试结果可重现。</ol><p>核心思路是：在基准测试开始前，先分配一定数量的实体，然后以随机顺序释放它们，从而填充实体分配器的空闲列表，并预分配 <code>Entities</code> 的存储空间。<h3 id=ju-ti-shi-xian>具体实现</h3><p>在 <code>benches/benches/bevy_ecs/main.rs</code> 中新增了 <code>world_builder</code> 模块，包含 <code>WorldBuilder</code> 结构体：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>WorldBuilder </span><span>{
</span><span>    world</span><span style=color:#61676ccc>:</span><span> World,
</span><span>    rng</span><span style=color:#61676ccc>:</span><span> SmallRng,
</span><span>    max_expected_entities</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span></code></pre><p><code>WorldBuilder</code> 提供以下方法：<ul><li><code>new()</code>：初始化构建器，使用固定的种子创建随机数生成器，默认最大预期实体数为10,000。<li><code>with_max_expected_entities()</code>：设置最大预期实体数。<li><code>warm_up_entity_allocator()</code>：执行实体预热的核心逻辑。<li><code>build()</code>：返回预热后的世界。</ul><p>预热逻辑的关键步骤：<ol><li>分配 <code>max_expected_entities</code> 个实体ID，但不实际创建这些实体（使用 <code>alloc_many</code>）。<li>生成最高索引的实体并立即反生成它（使用 <code>spawn_empty_at</code> 和 <code>try_despawn_no_free</code>），以预分配 <code>Entities</code> 的存储。<li>将分配的实体ID列表随机打乱，然后按随机顺序释放它们，填充空闲列表。</ol><p>这种方法模拟了实体分配器在长期运行后的状态：空闲列表包含各种索引的实体ID，且 <code>Entities</code> 存储已经扩展以容纳可能的最大实体索引。<h3 id=ji-shu-xi-jie-yu-quan-heng>技术细节与权衡</h3><p><strong>随机化的重要性</strong>：如果不使用随机顺序释放实体，实体ID会按顺序释放回空闲列表，这仍然会导致不现实的缓存友好行为。随机打乱确保了实体分配模式更接近真实场景。<p><strong>性能权衡</strong>：<ul><li><strong>优点</strong>：基准测试现在能更准确地反映运行中应用的性能，特别是涉及实体分配、反生成和重用的情况。<li><strong>缺点</strong>： <ol><li>基准测试运行时间增加，因为需要预热阶段。<li>启动和一次性成本（如组件注册、表创建）不再被测量。这可能导致某些优化（如缓存改进）在基准测试中无法被观察到。</ol></ul><p><strong>设计决策</strong>：<ol><li><strong>单独的构建器</strong>：而不是修改 <code>World::new</code> 或添加 <code>World::warmed_up()</code> 方法，因为预热是有成本的，不应影响生产代码。<li><strong>确定性RNG</strong>：使用固定种子的 <code>SmallRng</code> 确保基准测试可重现。<li><strong>可扩展设计</strong>：<code>WorldBuilder</code> 可以未来添加其他预热选项，如缓存bundle信息、预创建表等。</ol><h3 id=dui-ji-zhun-ce-shi-de-ying-xiang>对基准测试的影响</h3><p>修改了五个基准测试文件：<ul><li><code>commands.rs</code>：命令（commands）相关的基准测试。<li><code>despawn.rs</code>：反生成实体的基准测试。<li><code>despawn_recursive.rs</code>：递归反生成的基准测试。<li><code>spawn.rs</code>：生成实体的基准测试。</ul><p>每个文件都做了类似的修改：将 <code>World::default()</code> 替换为 <code>WorldBuilder</code> 链式调用，根据测试的实体数量设置 <code>max_expected_entities</code> 并调用 <code>warm_up_entity_allocator()</code>。<p>例如，在 <code>spawn.rs</code> 中：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>WorldBuilder</span><span style=color:#ed9366>::</span><span>new()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_max_expected_entities</span><span>(entity_count)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>warm_up_entity_allocator</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p>这种改变确保了这些基准测试现在测量的是在已经运行一段时间、实体分配器已经预热的状态下的性能，而不是冷启动状态下的性能。<h3 id=qian-zai-ying-xiang-yu-wei-lai-fang-xiang>潜在影响与未来方向</h3><p>这个变化显著改变了基准测试的测量重点。开发者需要意识到：<ul><li>以前 <code>1_entity</code> 基准测试可能测量的是操作成本+启动成本，现在只测量操作成本。<li>不同实体数量的基准测试现在更纯粹地反映批量操作的性能，而不是混合了缓存/启动成本。</ul><p>未来可以考虑：<ol><li>添加更多预热选项，如组件注册缓存、表预创建等。<li>提供不同的 <code>WorldBuilder</code> 预设，针对不同类型的基准测试（如启动性能 vs 运行时性能）。<li>考虑是否需要在某些基准测试中保留冷世界测试，以继续测量启动成本。</ol><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Benchmark Tests] --> B{Need Warm World?}
</span><span>    B -->|Yes| C[Use WorldBuilder]
</span><span>    B -->|No| D[Use World::new]
</span><span>    
</span><span>    C --> E[WorldBuilder::new]
</span><span>    E --> F[.with_max_expected_entities()]
</span><span>    F --> G[.warm_up_entity_allocator()]
</span><span>    G --> H[.build()]
</span><span>    H --> I[Warmed World]
</span><span>    
</span><span>    D --> J[Cold World]
</span><span>    
</span><span>    I --> K[Run Benchmark]
</span><span>    J --> K
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-benches-benches-bevy-ecs-main-rs-77-0>1. <code>benches/benches/bevy_ecs/main.rs</code> (+77/-0)</h3><p><strong>变化说明</strong>：新增了 <code>WorldBuilder</code> 模块，提供了创建预热世界的构建器。<p><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>WorldBuilder </span><span>{
</span><span>    world</span><span style=color:#61676ccc>:</span><span> World,
</span><span>    rng</span><span style=color:#61676ccc>:</span><span> SmallRng,
</span><span>    max_expected_entities</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>WorldBuilder </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>new</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 初始化，使用固定种子确保可重现性
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>with_max_expected_entities</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>max_expected_entities</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>max_expected_entities </span><span style=color:#ed9366>=</span><span> max_expected_entities</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>warm_up_entity_allocator</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 分配实体
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> entities </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>        entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>reserve_exact</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>max_expected_entities </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#61676ccc>;
</span><span>        entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>extend</span><span>(
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator</span><span>()
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>alloc_many</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>max_expected_entities)</span><span style=color:#61676ccc>,
</span><span>        )</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 预热 Entities 存储
</span><span>        </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(high_index) </span><span style=color:#ed9366>=</span><span> entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_mut</span><span>() </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#61676ccc>;
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_empty_at</span><span>(</span><span style=color:#ed9366>*</span><span>high_index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#ed9366>*</span><span>high_index </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_despawn_no_free</span><span>(</span><span style=color:#ed9366>*</span><span>high_index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 随机释放实体以填充空闲列表
</span><span>        entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>shuffle</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>rng)</span><span style=color:#61676ccc>;
</span><span>        entities
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>(</span><span style=color:#ed9366>..</span><span>)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>for_each</span><span>(|</span><span style=color:#ff8f40>e</span><span>| </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_allocator_mut</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>free</span><span>(e))</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>build</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> World {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>world
</span><span>    }
</span><span>}
</span></code></pre><h3 id=2-benches-benches-bevy-ecs-world-commands-rs-19-5>2. <code>benches/benches/bevy_ecs/world/commands.rs</code> (+19/-5)</h3><p><strong>变化说明</strong>：将命令相关的基准测试从使用 <code>World::default()</code> 改为使用 <code>WorldBuilder</code>。<p><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>WorldBuilder</span><span style=color:#ed9366>::</span><span>new()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_max_expected_entities</span><span>(entity_count)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>warm_up_entity_allocator</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=3-benches-benches-bevy-ecs-world-spawn-rs-11-3>3. <code>benches/benches/bevy_ecs/world/spawn.rs</code> (+11/-3)</h3><p><strong>变化说明</strong>：将生成实体相关的基准测试从使用 <code>World::default()</code> 改为使用 <code>WorldBuilder</code>。<p><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>WorldBuilder</span><span style=color:#ed9366>::</span><span>new()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_max_expected_entities</span><span>(entity_count)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>warm_up_entity_allocator</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=4-benches-benches-bevy-ecs-world-despawn-rs-6-1>4. <code>benches/benches/bevy_ecs/world/despawn.rs</code> (+6/-1)</h3><p><strong>变化说明</strong>：将反生成实体相关的基准测试从使用 <code>World::default()</code> 改为使用 <code>WorldBuilder</code>。<p><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>WorldBuilder</span><span style=color:#ed9366>::</span><span>new()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_max_expected_entities</span><span>(entity_count)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>warm_up_entity_allocator</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=5-benches-benches-bevy-ecs-world-despawn-recursive-rs-6-1>5. <code>benches/benches/bevy_ecs/world/despawn_recursive.rs</code> (+6/-1)</h3><p><strong>变化说明</strong>：将递归反生成相关的基准测试从使用 <code>World::default()</code> 改为使用 <code>WorldBuilder</code>。<p><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>World</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span style=color:#fa6e32>let mut</span><span> world </span><span style=color:#ed9366>= </span><span>WorldBuilder</span><span style=color:#ed9366>::</span><span>new()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_max_expected_entities</span><span>(entity_count)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>warm_up_entity_allocator</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>build</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy ECS 架构</strong>：了解 Bevy 的实体组件系统如何工作，特别是实体分配器和空闲列表的实现。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/ecs/ target=_blank>Bevy ECS 文档</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/tree/main/crates/bevy_ecs target=_blank>Bevy GitHub 仓库中的 ECS 模块</a></ul><li><p><strong>基准测试最佳实践</strong>：如何设计有效的基准测试，特别是微基准测试（microbenchmarks）。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://bheisler.github.io/criterion.rs/book/ target=_blank>Criterion.rs 文档</a><li><a rel="noopener nofollow noreferrer" href=https://www.brendangregg.com/systems-performance-2nd-edition-book.html target=_blank>《Systems Performance: Enterprise and the Cloud》</a> 中的基准测试章节</ul><li><p><strong>内存分配模式与性能</strong>：理解不同的内存分配模式如何影响性能，特别是缓存友好性（cache-friendliness）。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://people.freebsd.org/~lstewart/articles/cpumemory.pdf target=_blank>《What Every Programmer Should Know About Memory》</a><li><a rel="noopener nofollow noreferrer" href=https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips target=_blank>CPU 缓存的工作原理</a></ul><li><p><strong>构建器模式</strong>：深入学习构建器模式及其在 Rust 中的实现。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch05-03-method-syntax.html#the-builder-pattern target=_blank>《Rust 程序设计语言》中的构建器模式示例</a><li><a rel="noopener nofollow noreferrer" href=https://rust-unofficial.github.io/patterns/patterns/creational/builder.html target=_blank>Rust Design Patterns: Builder Pattern</a></ul></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22639.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>