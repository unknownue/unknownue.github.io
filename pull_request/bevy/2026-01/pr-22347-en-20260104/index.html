<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22347 Misc solari cleanup
        
    </title><meta content="#22347 Misc solari cleanup" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-04</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2026-01/pr-22347-zh-cn-20260103>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Misc solari cleanup<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22347<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-Rendering, C-Code-Quality, S-Ready-For-Final-Review<li><strong>Created</strong>: 2026-01-02T03:51:20Z<li><strong>Merged</strong>: 2026-01-03T23:02:12Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Small cleanup PR to prep for a future PR (no functional changes).<p>Easiest to review if you hide whitespace changes in the diff.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR represents a straightforward code cleanup effort in Bevy’s Solari rendering module. The developer was preparing the codebase for future changes by addressing several minor inconsistencies and improving code clarity. While the changes don’t modify functionality, they demonstrate good engineering practices around code maintenance and preparation.<p>The work focuses on two main areas: improving variable naming consistency in shader code and simplifying resource management in the Rust code. These changes make the code easier to read and maintain, which is particularly important for complex rendering systems where subtle bugs can have significant visual impact.<p>In the shader files, the developer noticed inconsistent naming patterns for ray tracing results. The <code>trace_ray</code> function was returning results stored in variables with different names across different shaders (<code>ray_hit</code> in some places, inconsistent usage in others). This was standardized to use <code>ray</code> for the initial ray query result, then <code>ray_hit</code> for the resolved hit information. This naming convention better reflects the data flow: first you get a ray intersection query result, then you resolve it to get detailed hit information.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>let ray_hit = trace_ray(ray_origin, ray_direction, ray_t_min, RAY_T_MAX, RAY_FLAG_NONE);
</span><span>if ray_hit.kind != RAY_QUERY_INTERSECTION_NONE {
</span><span>    let ray_hit = resolve_ray_hit_full(ray_hit);
</span><span>
</span><span>// After:
</span><span>let ray = trace_ray(ray_origin, ray_direction, ray_t_min, RAY_T_MAX, RAY_FLAG_NONE);
</span><span>if ray.kind != RAY_QUERY_INTERSECTION_NONE {
</span><span>    let ray_hit = resolve_ray_hit_full(ray);
</span></code></pre><p>This change appears in three different shader files (<code>pathtracer.wgsl</code>, <code>restir_gi.wgsl</code>, and <code>world_cache_update.wgsl</code>), showing the developer systematically applied the same improvement across the codebase. Consistency in shader code is especially valuable because shaders are often modified by multiple developers and can be difficult to debug due to their parallel execution model.<p>In the Rust code, the developer simplified the management of Direct Illumination (DI) reservoir textures. Previously, these resources were stored as tuples containing both a <code>Texture</code> and its <code>TextureView</code>. The code was changed to store only the <code>TextureView</code>, which is what’s actually needed for binding in rendering operations. This reduces memory usage slightly and simplifies the code by eliminating unnecessary texture handles.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_a</span><span style=color:#61676ccc>: </span><span>(Texture</span><span style=color:#61676ccc>,</span><span> TextureView)</span><span style=color:#61676ccc>,
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_b</span><span style=color:#61676ccc>: </span><span>(Texture</span><span style=color:#61676ccc>,</span><span> TextureView)</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_a</span><span style=color:#61676ccc>:</span><span> TextureView</span><span style=color:#61676ccc>,
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_b</span><span style=color:#61676ccc>:</span><span> TextureView</span><span style=color:#61676ccc>,
</span></code></pre><p>The corresponding creation code was also simplified by chaining the texture creation and view creation operations:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> tex </span><span style=color:#ed9366>=</span><span> render_device</span><span style=color:#ed9366>.</span><span style=color:#f07171>create_texture</span><span>(</span><span style=color:#ed9366>&</span><span>TextureDescriptor { </span><span style=color:#ed9366>... </span><span>})</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> view </span><span style=color:#ed9366>=</span><span> tex</span><span style=color:#ed9366>.</span><span style=color:#f07171>create_view</span><span>(</span><span style=color:#ed9366>&</span><span>TextureViewDescriptor</span><span style=color:#ed9366>::</span><span>default())</span><span style=color:#61676ccc>;
</span><span>(tex</span><span style=color:#61676ccc>,</span><span> view)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>render_device
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>create_texture</span><span>(</span><span style=color:#ed9366>&</span><span>TextureDescriptor { </span><span style=color:#ed9366>... </span><span>})
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>create_view</span><span>(</span><span style=color:#ed9366>&</span><span>TextureViewDescriptor</span><span style=color:#ed9366>::</span><span>default())
</span></code></pre><p>This pattern is more idiomatic in Bevy’s rendering code and reduces the scope of intermediate variables. The texture object still exists but is now managed internally by the render device rather than being explicitly stored.<p>The PR also includes a minor bug fix in the <code>world_cache_update.wgsl</code> shader. The calculation for blended luminance delta was changed from <code>luminance(blended_radiance) - luminance(old_radiance.rgb)</code> to <code>luminance(blended_radiance - old_radiance.rgb)</code>. While this might seem like a subtle difference, it’s mathematically significant. The original code computed the difference of luminances, while the new code computes the luminance of the difference. The latter is more correct for tracking how much the radiance value itself has changed, rather than how much the perceived brightness has changed.<p>Another clean-up change in <code>world_cache_compact.wgsl</code> improves code clarity by calculating the active cell count once and reusing it, rather than computing it twice with the same expression. This follows the DRY (Don’t Repeat Yourself) principle and makes the intent clearer.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>world_cache_active_cells_count = compacted_index + u32(cell_active);
</span><span>world_cache_active_cells_dispatch = vec3((world_cache_active_cells_count + 63u) / 64u, 1u, 1u);
</span><span>
</span><span>// After:
</span><span>let active_cell_count = compacted_index + u32(cell_active);
</span><span>world_cache_active_cells_count = active_cell_count;
</span><span>world_cache_active_cells_dispatch = vec3((active_cell_count + 63u) / 64u, 1u, 1u);
</span></code></pre><p>Finally, the shader functions in <code>world_cache_update.wgsl</code> were refactored to use early returns for boundary checks, which is a common pattern in GPU programming to minimize divergent execution within warp/wavefront. By returning early when <code>active_cell_id.x >= world_cache_active_cells_count</code>, threads that don’t have work to do exit quickly, potentially improving performance on some GPU architectures.<p>These changes collectively represent good software engineering practices: improving naming consistency, simplifying data structures, fixing subtle bugs, and optimizing control flow patterns. While individually small, these improvements make the codebase more maintainable and prepare it for future, more substantial changes.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[prepare.rs] --> B[Resource Management]
</span><span>    C[node.rs] --> D[TextureView Binding]
</span><span>    E[pathtracer.wgsl] --> F[Shader Naming Consistency]
</span><span>    G[restir_gi.wgsl] --> F
</span><span>    H[world_cache_update.wgsl] --> F
</span><span>    H --> I[Early Return Pattern]
</span><span>    H --> J[Luminance Calculation Fix]
</span><span>    K[world_cache_compact.wgsl] --> L[DRY Principle]
</span><span>    
</span><span>    B --> M[Simplified DI Reservoir Storage]
</span><span>    D --> M
</span><span>    F --> N[Standardized ray/ray_hit Variables]
</span><span>    I --> O[Potential Performance Improvement]
</span><span>    J --> P[Bug Fix]
</span><span>    L --> Q[Code Clarity]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-prepare-rs><code>crates/bevy_solari/src/realtime/prepare.rs</code></h3><p><strong>What changed:</strong> Simplified the storage of DI reservoir resources from tuples <code>(Texture, TextureView)</code> to just <code>TextureView</code>.<p><strong>Why:</strong> The <code>Texture</code> handles weren’t being used elsewhere in the code, so storing only the <code>TextureView</code> reduces memory usage and simplifies the API.<p><strong>Code snippet:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_a</span><span style=color:#61676ccc>: </span><span>(Texture</span><span style=color:#61676ccc>,</span><span> TextureView)</span><span style=color:#61676ccc>,
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_b</span><span style=color:#61676ccc>: </span><span>(Texture</span><span style=color:#61676ccc>,</span><span> TextureView)</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_a</span><span style=color:#61676ccc>:</span><span> TextureView</span><span style=color:#61676ccc>,
</span><span style=color:#fa6e32>pub</span><span> di_reservoirs_b</span><span style=color:#61676ccc>:</span><span> TextureView</span><span style=color:#61676ccc>,
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-node-rs><code>crates/bevy_solari/src/realtime/node.rs</code></h3><p><strong>What changed:</strong> Updated texture binding to use the simplified <code>TextureView</code> fields.<p><strong>Why:</strong> The corresponding fields in <code>prepare.rs</code> were changed from tuples to single values, so the binding code needed to be updated accordingly.<p><strong>Code snippet:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#ed9366>&</span><span>s</span><span style=color:#ed9366>.</span><span>di_reservoirs_a</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span style=color:#ed9366>&</span><span>s</span><span style=color:#ed9366>.</span><span>di_reservoirs_b</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#ed9366>&</span><span>s</span><span style=color:#ed9366>.</span><span>di_reservoirs_a</span><span style=color:#61676ccc>,
</span><span style=color:#ed9366>&</span><span>s</span><span style=color:#ed9366>.</span><span>di_reservoirs_b</span><span style=color:#61676ccc>,
</span></code></pre><h3 id=crates-bevy-solari-src-pathtracer-pathtracer-wgsl><code>crates/bevy_solari/src/pathtracer/pathtracer.wgsl</code></h3><p><strong>What changed:</strong> Standardized variable naming for ray tracing results.<p><strong>Why:</strong> Improves consistency across shader files and clarifies the distinction between raw ray query results and resolved hit information.<p><strong>Code snippet:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>let ray_hit = trace_ray(ray_origin, ray_direction, ray_t_min, RAY_T_MAX, RAY_FLAG_NONE);
</span><span>if ray_hit.kind != RAY_QUERY_INTERSECTION_NONE {
</span><span>    let ray_hit = resolve_ray_hit_full(ray_hit);
</span><span>
</span><span>// After:
</span><span>let ray = trace_ray(ray_origin, ray_direction, ray_t_min, RAY_T_MAX, RAY_FLAG_NONE);
</span><span>if ray.kind != RAY_QUERY_INTERSECTION_NONE {
</span><span>    let ray_hit = resolve_ray_hit_full(ray);
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-update-wgsl><code>crates/bevy_solari/src/realtime/world_cache_update.wgsl</code></h3><p><strong>What changed:</strong> Multiple improvements including early return patterns, fixed luminance calculation, and consistent ray variable naming.<p><strong>Why:</strong> Early returns can improve GPU performance by reducing thread divergence. The luminance calculation fix addresses a potential mathematical error. Consistent naming improves code readability.<p><strong>Code snippet (luminance fix):</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>let blended_luminance_delta = mix(luminance_delta, luminance(blended_radiance) - luminance(old_radiance.rgb), 1.0 / 8.0);
</span><span>
</span><span>// After:
</span><span>let blended_luminance_delta = mix(luminance_delta, luminance(blended_radiance - old_radiance.rgb), 1.0 / 8.0);
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-compact-wgsl><code>crates/bevy_solari/src/realtime/world_cache_compact.wgsl</code></h3><p><strong>What changed:</strong> Applied DRY principle by calculating active cell count once instead of twice.<p><strong>Why:</strong> Improves code clarity and eliminates redundant calculations.<p><strong>Code snippet:</strong><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>world_cache_active_cells_count = compacted_index + u32(cell_active);
</span><span>world_cache_active_cells_dispatch = vec3((world_cache_active_cells_count + 63u) / 64u, 1u, 1u);
</span><span>
</span><span>// After:
</span><span>let active_cell_count = compacted_index + u32(cell_active);
</span><span>world_cache_active_cells_count = active_cell_count;
</span><span>world_cache_active_cells_dispatch = vec3((active_cell_count + 63u) / 64u, 1u, 1u);
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>WGSL Specification</strong>: For understanding WebGPU Shading Language syntax and best practices.<li><strong>Bevy Rendering Architecture</strong>: The Bevy engine’s rendering architecture documentation for context on how resources are managed.<li><strong>ReSTIR GI Algorithm</strong>: Papers on Resampled Importance Sampling for real-time global illumination to understand the context of these changes.<li><strong>GPU Programming Best Practices</strong>: Resources on optimizing shader code for modern GPU architectures, particularly around thread divergence and memory access patterns.<li><strong>Code Review Guidelines for GPU Code</strong>: Best practices for reviewing shader code, given its parallel execution model and debugging challenges.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22347.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>