<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22314 Parallel GPU buffer writes
        
    </title><meta content="#22314 Parallel GPU buffer writes" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2026-01/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2026-01-05</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2026-01/pr-22314-en-20260105>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=parallel-gpu-buffer-writes>Parallel GPU buffer writes</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Parallel GPU buffer writes<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/22314<li><strong>作者</strong>: aevyrie<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review<li><strong>创建时间</strong>: 2025-12-30T05:22:13Z<li><strong>合并时间</strong>: 2026-01-05T02:56:13Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h3 id=mu-biao>目标</h3><ul><li>经过一系列优化使渲染和postupdate更加并行化后，<code>write_batched_instance_buffers</code>经常成为最大的span之一，但线程利用率非常低，在1个4ms帧中耗时4ms。这使其成为提高吞吐量的理想目标。请注意，此截图不包含一些可见性系统优化：</ul><img alt=image height=718 src=https://github.com/user-attachments/assets/bbd6762b-5145-48f8-a427-5da3cb11a04a width=650><h3 id=jie-jue-fang-an>解决方案</h3><ul><li>为将缓冲区写入GPU的任务创建任务。这对于<code>current_input_buffer</code>和<code>previous_input_buffer</code>特别有帮助，这两个缓冲区耗时大致相同，且是写入时间最长的缓冲区 - 将它们移至任务中实际上将系统花费的时间减半。</ul><img alt=image height=251 src=https://github.com/user-attachments/assets/0a086e7a-1d3c-4c17-9d66-eff94196943d width=588><ul><li>在250k bevymark_3d压力测试中，这为系统节省了1.7ms，帧时间节省了2.8ms</ul><p>帧时间 <img alt=image height=376 src=https://github.com/user-attachments/assets/a4c106ac-7668-4f8a-970f-71cbb8be851c width=620><p>系统 <img alt=image height=744 src=https://github.com/user-attachments/assets/5c42227d-8ee5-4b84-bc1a-c04768356255 width=1384><h3 id=ce-shi>测试</h3><ul><li><code>cargo rer bevymark_3d --features=debug,trace_tracy -- --benchmark --waves 250 --per-wave 1000</code></ul><h2 id=ben-ci-prde-ji-shu-fen-xi>本次PR的技术分析</h2><h3 id=wen-ti-bei-jing-he-xing-neng-ping-jing>问题背景和性能瓶颈</h3><p>在Bevy渲染流水线的性能优化过程中，开发团队已经实施了一系列并行化改进，使得渲染和postupdate阶段的并行度得到提升。然而，在性能分析中发现了<code>write_batched_instance_buffers</code>系统存在明显的性能瓶颈。该系统负责将实例缓冲区数据写入GPU，但在之前的实现中是顺序执行的，导致即使在其他部分已经并行化的情况下，这个系统仍然消耗大量时间且线程利用率低。<p>从性能分析截图可以看出，在4ms的帧时间内，<code>write_batched_instance_buffers</code>占据了大约4ms的时间，这意味着它实际上是单线程执行的，没有充分利用现代CPU的多核心架构。这种情况在GPU渲染中特别值得关注，因为CPU和GPU之间的数据传输往往是性能关键路径。<h3 id=jie-jue-fang-an-ren-wu-bing-xing-hua>解决方案：任务并行化</h3><p>开发者选择了使用Bevy的任务系统来并行化GPU缓冲区写入操作。核心思路是将原本顺序执行的缓冲区写入操作分解为多个独立任务，这些任务可以并行执行，从而充分利用多核CPU的计算能力。<p>解决方案的关键技术点包括：<ol><li>使用<code>ComputeTaskPool::get().scope</code>创建任务作用域<li>为每个主要的缓冲区写入操作创建独立的任务<li>为每个任务添加追踪span以便性能分析<li>确保资源在任务间正确共享</ol><h3 id=shi-xian-xi-jie>实现细节</h3><p>在<code>write_batched_instance_buffers</code>函数中，主要进行了以下改造：<p>首先，从同步模式转变为异步任务模式：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前：顺序执行
</span><span>current_input_buffer</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>render_device</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>render_queue)</span><span style=color:#61676ccc>;
</span><span>previous_input_buffer</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>render_device</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>render_queue)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后：任务并行化
</span><span>ComputeTaskPool</span><span style=color:#ed9366>::</span><span>get()</span><span style=color:#ed9366>.</span><span style=color:#f07171>scope</span><span>(|</span><span style=color:#ff8f40>scope</span><span>| {
</span><span>    scope</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async {
</span><span>        </span><span style=color:#fa6e32>let</span><span> _span </span><span style=color:#ed9366>= </span><span>tracing</span><span style=color:#ed9366>::</span><span>info_span</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"write_current_input_buffers"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>entered</span><span>()</span><span style=color:#61676ccc>;
</span><span>        current_input_buffer</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(render_device</span><span style=color:#61676ccc>,</span><span> render_queue)</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    scope</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async {
</span><span>        </span><span style=color:#fa6e32>let</span><span> _span </span><span style=color:#ed9366>= </span><span>tracing</span><span style=color:#ed9366>::</span><span>info_span</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"write_previous_input_buffers"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>entered</span><span>()</span><span style=color:#61676ccc>;
</span><span>        previous_input_buffer</span><span style=color:#ed9366>.</span><span>buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(render_device</span><span style=color:#61676ccc>,</span><span> render_queue)</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 更多任务
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p>这里有几个重要的技术细节：<ol><li><p><strong>资源预处理</strong>：将<code>render_device</code>和<code>render_queue</code>从<code>Res</code>资源中解引用并获取引用，避免在每个任务中重复解引用：</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> render_device </span><span style=color:#ed9366>= &*</span><span>render_device</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> render_queue </span><span style=color:#ed9366>= &*</span><span>render_queue</span><span style=color:#61676ccc>;
</span></code></pre><li><p><strong>嵌套任务结构</strong>：对于多级嵌套的缓冲区结构，开发者创建了相应层级的任务。例如，对于每个<code>phase_instance_buffers</code>，都创建了一个单独的任务来写入其数据缓冲区和间接参数缓冲区。</p><li><p><strong>条件写入的保留</strong>：在<code>PreprocessWorkItemBuffers::Indirect</code>分支中，条件写入逻辑（如<code>if !late_indexed.is_empty()</code>）被完整保留，确保只有在缓冲区非空时才执行写入操作。</p></ol><p>同样地，<code>write_indirect_parameters_buffers</code>函数也进行了类似的并行化改造，为每个缓冲区的不同部分（数据、CPU元数据、GPU元数据、批处理集）创建了独立的任务。<h3 id=ji-shu-tiao-zhan-he-kao-liang>技术挑战和考量</h3><p>在实现并行化时，开发者需要处理几个技术挑战：<ol><li><p><strong>借用检查器</strong>：由于多个任务需要访问相同的资源，开发者需要确保所有任务都只持有共享资源的不可变引用。通过提前获取资源引用并传递给任务，避免了借用冲突。</p><li><p><strong>任务粒度</strong>：任务划分需要平衡并行度和任务开销。过细的任务划分会增加任务调度开销，而过粗的任务划分则无法充分利用多核。从实现看，开发者选择了按照缓冲区类型和阶段来划分任务，这是一个合理的权衡。</p><li><p><strong>性能追踪</strong>：每个任务都添加了追踪span，这在调试和性能分析中非常有用，可以帮助识别哪个具体任务成为新的瓶颈。</p></ol><h3 id=xing-neng-ti-sheng-he-ying-xiang>性能提升和影响</h3><p>根据PR描述中的性能数据，这个优化带来了显著的性能提升：<ol><li><strong>系统时间减少</strong>：<code>write_batched_instance_buffers</code>系统本身的时间减少了1.7ms<li><strong>帧时间减少</strong>：整体帧时间减少了2.8ms<li><strong>线程利用率提升</strong>：从单线程顺序执行转变为多任务并行执行</ol><p>特别值得注意的是，<code>current_input_buffer</code>和<code>previous_input_buffer</code>的写入时间大致相同，将它们并行化后，理论上可以将这两个操作的执行时间从<code>t1 + t2</code>减少到<code>max(t1, t2)</code>，这正是实现中提到的“时间减半“效果。<h3 id=jia-gou-ying-xiang-he-kuo-zhan-xing>架构影响和扩展性</h3><p>这个修改对Bevy的渲染架构有几个积极影响：<ol><li><p><strong>更好的可扩展性</strong>：随着场景复杂度的增加和缓冲区数量的增长，并行化方案能够更好地利用更多CPU核心。</p><li><p><strong>为未来优化奠定基础</strong>：这种任务并行化的模式可以应用到其他类似的GPU数据上传操作中。</p><li><p><strong>与现有系统的兼容性</strong>：修改保持了原有API的兼容性，不需要改变其他系统如何使用这些缓冲区。</p></ol><h3 id=qian-zai-feng-xian-he-zhu-yi-shi-xiang>潜在风险和注意事项</h3><p>虽然这个优化带来了显著的性能提升，但也有一些需要注意的地方：<ol><li><strong>任务调度开销</strong>：对于非常小的缓冲区，创建任务的成本可能超过并行执行带来的收益。<li><strong>内存一致性</strong>：并行写入操作需要确保GPU能够正确接收所有数据，但Bevy的底层图形API抽象已经处理了这些同步问题。<li><strong>调试复杂性</strong>：并行执行使得调试更加复杂，但添加的追踪span有助于缓解这个问题。</ol><h2 id=ke-shi-hua-biao-shi>可视化表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[write_batched_instance_buffers系统] --> B[ComputeTaskPool任务作用域]
</span><span>    
</span><span>    B --> C[任务1: write_current_input_buffers]
</span><span>    B --> D[任务2: write_previous_input_buffers]
</span><span>    B --> E[遍历phase_instance_buffers]
</span><span>    
</span><span>    E --> F[每个phase的任务]
</span><span>    F --> F1[数据缓冲区写入]
</span><span>    F --> F2[延迟索引间接参数缓冲区写入]
</span><span>    F --> F3[延迟非索引间接参数缓冲区写入]
</span><span>    
</span><span>    E --> G[遍历work_item_buffers]
</span><span>    G --> H[每个work_item的任务]
</span><span>    H --> H1[直接缓冲区写入]
</span><span>    H --> H2[间接缓冲区写入]
</span><span>    H2 --> H2a[索引缓冲区写入]
</span><span>    H2 --> H2b[非索引缓冲区写入]
</span><span>    H2 --> H2c[GPU遮挡剔除缓冲区写入]
</span><span>    
</span><span>    style A fill:#e1f5fe
</span><span>    style C fill:#f3e5f5
</span><span>    style D fill:#f3e5f5
</span><span>    style F1 fill:#e8f5e8
</span><span>    style H1 fill:#fff3e0
</span></code></pre><h2 id=guan-jian-wen-jian-xiu-gai>关键文件修改</h2><h3 id=crates-bevy-render-src-batching-gpu-preprocessing-rs><code>crates/bevy_render/src/batching/gpu_preprocessing.rs</code></h3><p><strong>修改说明</strong>: 将GPU缓冲区写入操作从顺序执行改为并行任务执行，显著提高了多核CPU利用率。<p><strong>主要修改</strong>:<ol><li>引入<code>bevy_tasks::ComputeTaskPool</code>用于创建并行任务<li>重构<code>write_batched_instance_buffers</code>函数，使用任务作用域并行执行缓冲区写入<li>重构<code>write_indirect_parameters_buffers</code>函数，同样实现并行化<li>为每个任务添加追踪span以便性能分析</ol><p><strong>代码示例 - 修改前的关键部分</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 顺序执行缓冲区写入
</span><span>current_input_buffer
</span><span>    </span><span style=color:#ed9366>.</span><span>buffer
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>render_device</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>render_queue)</span><span style=color:#61676ccc>;
</span><span>previous_input_buffer
</span><span>    </span><span style=color:#ed9366>.</span><span>buffer
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>render_device</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>render_queue)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>for</span><span> phase_instance_buffers </span><span style=color:#ed9366>in</span><span> phase_instance_buffers</span><span style=color:#ed9366>.</span><span style=color:#f07171>values_mut</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 顺序处理每个phase
</span><span>    data_buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(</span><span style=color:#ed9366>&</span><span>render_device)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 更多顺序写入
</span><span>}
</span></code></pre><p><strong>代码示例 - 修改后的关键部分</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 并行执行缓冲区写入
</span><span style=color:#fa6e32>let</span><span> render_device </span><span style=color:#ed9366>= &*</span><span>render_device</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> render_queue </span><span style=color:#ed9366>= &*</span><span>render_queue</span><span style=color:#61676ccc>;
</span><span>
</span><span>ComputeTaskPool</span><span style=color:#ed9366>::</span><span>get()</span><span style=color:#ed9366>.</span><span style=color:#f07171>scope</span><span>(|</span><span style=color:#ff8f40>scope</span><span>| {
</span><span>    scope</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async {
</span><span>        </span><span style=color:#fa6e32>let</span><span> _span </span><span style=color:#ed9366>= </span><span>tracing</span><span style=color:#ed9366>::</span><span>info_span</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"write_current_input_buffers"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>entered</span><span>()</span><span style=color:#61676ccc>;
</span><span>        current_input_buffer
</span><span>            </span><span style=color:#ed9366>.</span><span>buffer
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(render_device</span><span style=color:#61676ccc>,</span><span> render_queue)</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    scope</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async {
</span><span>        </span><span style=color:#fa6e32>let</span><span> _span </span><span style=color:#ed9366>= </span><span>tracing</span><span style=color:#ed9366>::</span><span>info_span</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"write_previous_input_buffers"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>entered</span><span>()</span><span style=color:#61676ccc>;
</span><span>        previous_input_buffer
</span><span>            </span><span style=color:#ed9366>.</span><span>buffer
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(render_device</span><span style=color:#61676ccc>,</span><span> render_queue)</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 并行处理每个phase
</span><span>    </span><span style=color:#fa6e32>for</span><span> phase_instance_buffers </span><span style=color:#ed9366>in</span><span> phase_instance_buffers</span><span style=color:#ed9366>.</span><span style=color:#f07171>values_mut</span><span>() {
</span><span>        scope</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async {
</span><span>            </span><span style=color:#fa6e32>let</span><span> _span </span><span style=color:#ed9366>= </span><span>tracing</span><span style=color:#ed9366>::</span><span>info_span</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"write_phase_instance_buffers"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>entered</span><span>()</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// 并行写入
</span><span>            data_buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_buffer</span><span>(render_device)</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>        })</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=jin-yi-bu-yue-du>进一步阅读</h2><ol><li><strong>Bevy任务系统文档</strong>: 了解<code>ComputeTaskPool</code>和其他任务原语的使用<li><strong>GPU缓冲区管理</strong>: 理解现代图形API中的缓冲区上传最佳实践<li><strong>并行编程模式</strong>: 学习任务并行化和数据并行化的不同方法<li><strong>性能分析技术</strong>: 如何使用tracing等工具识别和解决性能瓶颈</ol><h1 id=wan-zheng-dai-ma-chai-yi>完整代码差异</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_render/src/batching/gpu_preprocessing.rs b/crates/bevy_render/src/batching/gpu_preprocessing.rs
</span><span>index 21780b222797d..71ba6a82872d8 100644
</span><span style=color:#c594c5>--- a/crates/bevy_render/src/batching/gpu_preprocessing.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_render/src/batching/gpu_preprocessing.rs
</span><span style=color:#c594c5>@@ -15,6 +15,7 @@ </span><span style=color:#399ee6>use bevy_ecs::{
</span><span> use bevy_encase_derive::ShaderType;
</span><span> use bevy_math::UVec4;
</span><span> use bevy_platform::collections::{hash_map::Entry, HashMap, HashSet};
</span><span style=color:#86b300>+use bevy_tasks::ComputeTaskPool;
</span><span> use bevy_utils::{default, TypeIdMap};
</span><span> use bytemuck::{Pod, Zeroable};
</span><span> use encase::{internal::WriteInto, ShaderSize};
</span><span style=color:#c594c5>@@ -2017,56 +2018,74 @@ </span><span style=color:#399ee6>pub fn write_batched_instance_buffers&LTGFBD>(
</span><span>         phase_instance_buffers,
</span><span>     } = gpu_array_buffer.into_inner();
</span><span> 
</span><span style=color:#f07171>-    current_input_buffer
</span><span style=color:#f07171>-        .buffer
</span><span style=color:#f07171>-        .write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-    previous_input_buffer
</span><span style=color:#f07171>-        .buffer
</span><span style=color:#f07171>-        .write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    for phase_instance_buffers in phase_instance_buffers.values_mut() {
</span><span style=color:#f07171>-        let UntypedPhaseBatchedInstanceBuffers {
</span><span style=color:#f07171>-            ref mut data_buffer,
</span><span style=color:#f07171>-            ref mut work_item_buffers,
</span><span style=color:#f07171>-            ref mut late_indexed_indirect_parameters_buffer,
</span><span style=color:#f07171>-            ref mut late_non_indexed_indirect_parameters_buffer,
</span><span style=color:#f07171>-        } = *phase_instance_buffers;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        data_buffer.write_buffer(&render_device);
</span><span style=color:#f07171>-        late_indexed_indirect_parameters_buffer.write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-        late_non_indexed_indirect_parameters_buffer.write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        for phase_work_item_buffers in work_item_buffers.values_mut() {
</span><span style=color:#f07171>-            match *phase_work_item_buffers {
</span><span style=color:#f07171>-                PreprocessWorkItemBuffers::Direct(ref mut buffer_vec) => {
</span><span style=color:#f07171>-                    buffer_vec.write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-                }
</span><span style=color:#f07171>-                PreprocessWorkItemBuffers::Indirect {
</span><span style=color:#f07171>-                    ref mut indexed,
</span><span style=color:#f07171>-                    ref mut non_indexed,
</span><span style=color:#f07171>-                    ref mut gpu_occlusion_culling,
</span><span style=color:#f07171>-                } => {
</span><span style=color:#f07171>-                    indexed.write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-                    non_indexed.write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                    if let Some(GpuOcclusionCullingWorkItemBuffers {
</span><span style=color:#f07171>-                        ref mut late_indexed,
</span><span style=color:#f07171>-                        ref mut late_non_indexed,
</span><span style=color:#f07171>-                        late_indirect_parameters_indexed_offset: _,
</span><span style=color:#f07171>-                        late_indirect_parameters_non_indexed_offset: _,
</span><span style=color:#f07171>-                    }) = *gpu_occlusion_culling
</span><span style=color:#f07171>-                    {
</span><span style=color:#f07171>-                        if !late_indexed.is_empty() {
</span><span style=color:#f07171>-                            late_indexed.write_buffer(&render_device);
</span><span style=color:#86b300>+    let render_device = &*render_device;
</span><span style=color:#86b300>+    let render_queue = &*render_queue;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    ComputeTaskPool::get().scope(|scope| {
</span><span style=color:#86b300>+        scope.spawn(async {
</span><span style=color:#86b300>+            let _span = tracing::info_span!("write_current_input_buffers").entered();
</span><span style=color:#86b300>+            current_input_buffer
</span><span style=color:#86b300>+                .buffer
</span><span style=color:#86b300>+                .write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+        scope.spawn(async {
</span><span style=color:#86b300>+            let _span = tracing::info_span!("write_previous_input_buffers").entered();
</span><span style=color:#86b300>+            previous_input_buffer
</span><span style=color:#86b300>+                .buffer
</span><span style=color:#86b300>+                .write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        for phase_instance_buffers in phase_instance_buffers.values_mut() {
</span><span style=color:#86b300>+            let UntypedPhaseBatchedInstanceBuffers {
</span><span style=color:#86b300>+                ref mut data_buffer,
</span><span style=color:#86b300>+                ref mut work_item_buffers,
</span><span style=color:#86b300>+                ref mut late_indexed_indirect_parameters_buffer,
</span><span style=color:#86b300>+                ref mut late_non_indexed_indirect_parameters_buffer,
</span><span style=color:#86b300>+            } = *phase_instance_buffers;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("write_phase_instance_buffers").entered();
</span><span style=color:#86b300>+                data_buffer.write_buffer(render_device);
</span><span style=color:#86b300>+                late_indexed_indirect_parameters_buffer.write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+                late_non_indexed_indirect_parameters_buffer
</span><span style=color:#86b300>+                    .write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            for phase_work_item_buffers in work_item_buffers.values_mut() {
</span><span style=color:#86b300>+                scope.spawn(async {
</span><span style=color:#86b300>+                    let _span = tracing::info_span!("write_work_item_buffers").entered();
</span><span style=color:#86b300>+                    match *phase_work_item_buffers {
</span><span style=color:#86b300>+                        PreprocessWorkItemBuffers::Direct(ref mut buffer_vec) => {
</span><span style=color:#86b300>+                            buffer_vec.write_buffer(render_device, render_queue);
</span><span>                         }
</span><span style=color:#f07171>-                        if !late_non_indexed.is_empty() {
</span><span style=color:#f07171>-                            late_non_indexed.write_buffer(&render_device);
</span><span style=color:#86b300>+                        PreprocessWorkItemBuffers::Indirect {
</span><span style=color:#86b300>+                            ref mut indexed,
</span><span style=color:#86b300>+                            ref mut non_indexed,
</span><span style=color:#86b300>+                            ref mut gpu_occlusion_culling,
</span><span style=color:#86b300>+                        } => {
</span><span style=color:#86b300>+                            indexed.write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+                            non_indexed.write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                            if let Some(GpuOcclusionCullingWorkItemBuffers {
</span><span style=color:#86b300>+                                ref mut late_indexed,
</span><span style=color:#86b300>+                                ref mut late_non_indexed,
</span><span style=color:#86b300>+                                late_indirect_parameters_indexed_offset: _,
</span><span style=color:#86b300>+                                late_indirect_parameters_non_indexed_offset: _,
</span><span style=color:#86b300>+                            }) = *gpu_occlusion_culling
</span><span style=color:#86b300>+                            {
</span><span style=color:#86b300>+                                if !late_indexed.is_empty() {
</span><span style=color:#86b300>+                                    late_indexed.write_buffer(render_device);
</span><span style=color:#86b300>+                                }
</span><span style=color:#86b300>+                                if !late_non_indexed.is_empty() {
</span><span style=color:#86b300>+                                    late_non_indexed.write_buffer(render_device);
</span><span style=color:#86b300>+                                }
</span><span style=color:#86b300>+                            }
</span><span>                         }
</span><span>                     }
</span><span style=color:#f07171>-                }
</span><span style=color:#86b300>+                });
</span><span>             }
</span><span>         }
</span><span style=color:#f07171>-    }
</span><span style=color:#86b300>+    });
</span><span> }
</span><span> 
</span><span> pub fn clear_indirect_parameters_buffers(
</span><span style=color:#c594c5>@@ -2082,43 +2101,71 @@ </span><span style=color:#399ee6>pub fn write_indirect_parameters_buffers(
</span><span>     render_queue: Res&LTRenderQueue>,
</span><span>     mut indirect_parameters_buffers: ResMut&LTIndirectParametersBuffers>,
</span><span> ) {
</span><span style=color:#f07171>-    for phase_indirect_parameters_buffers in indirect_parameters_buffers.values_mut() {
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .indexed
</span><span style=color:#f07171>-            .data
</span><span style=color:#f07171>-            .write_buffer(&render_device);
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .non_indexed
</span><span style=color:#f07171>-            .data
</span><span style=color:#f07171>-            .write_buffer(&render_device);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .indexed
</span><span style=color:#f07171>-            .cpu_metadata
</span><span style=color:#f07171>-            .write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .non_indexed
</span><span style=color:#f07171>-            .cpu_metadata
</span><span style=color:#f07171>-            .write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .non_indexed
</span><span style=color:#f07171>-            .gpu_metadata
</span><span style=color:#f07171>-            .write_buffer(&render_device);
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .indexed
</span><span style=color:#f07171>-            .gpu_metadata
</span><span style=color:#f07171>-            .write_buffer(&render_device);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .indexed
</span><span style=color:#f07171>-            .batch_sets
</span><span style=color:#f07171>-            .write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-        phase_indirect_parameters_buffers
</span><span style=color:#f07171>-            .non_indexed
</span><span style=color:#f07171>-            .batch_sets
</span><span style=color:#f07171>-            .write_buffer(&render_device, &render_queue);
</span><span style=color:#f07171>-    }
</span><span style=color:#86b300>+    let render_device = &*render_device;
</span><span style=color:#86b300>+    let render_queue = &*render_queue;
</span><span style=color:#86b300>+    ComputeTaskPool::get().scope(|scope| {
</span><span style=color:#86b300>+        for phase_indirect_parameters_buffers in indirect_parameters_buffers.values_mut() {
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("indexed_data").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .indexed
</span><span style=color:#86b300>+                    .data
</span><span style=color:#86b300>+                    .write_buffer(render_device);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("non_indexed_data").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .non_indexed
</span><span style=color:#86b300>+                    .data
</span><span style=color:#86b300>+                    .write_buffer(render_device);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("indexed_cpu_metadata").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .indexed
</span><span style=color:#86b300>+                    .cpu_metadata
</span><span style=color:#86b300>+                    .write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("non_indexed_cpu_metadata").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .non_indexed
</span><span style=color:#86b300>+                    .cpu_metadata
</span><span style=color:#86b300>+                    .write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("non_indexed_gpu_metadata").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .non_indexed
</span><span style=color:#86b300>+                    .gpu_metadata
</span><span style=color:#86b300>+                    .write_buffer(render_device);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("indexed_gpu_metadata").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .indexed
</span><span style=color:#86b300>+                    .gpu_metadata
</span><span style=color:#86b300>+                    .write_buffer(render_device);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("indexed_batch_sets").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .indexed
</span><span style=color:#86b300>+                    .batch_sets
</span><span style=color:#86b300>+                    .write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+            scope.spawn(async {
</span><span style=color:#86b300>+                let _span = tracing::info_span!("non_indexed_batch_sets").entered();
</span><span style=color:#86b300>+                phase_indirect_parameters_buffers
</span><span style=color:#86b300>+                    .non_indexed
</span><span style=color:#86b300>+                    .batch_sets
</span><span style=color:#86b300>+                    .write_buffer(render_device, render_queue);
</span><span style=color:#86b300>+            });
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    });
</span><span> }
</span><span> 
</span><span> #[cfg(test)]
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2026-01/pr_22314.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>