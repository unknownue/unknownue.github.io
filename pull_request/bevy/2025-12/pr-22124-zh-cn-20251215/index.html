<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22124
        
    </title><meta content=#22124 property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-15</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-12/pr-22124-en-20251215>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><p>Fix: Clears directional navigation map between rebuilds<h2 id=basic-information>Basic Information</h2><ul><li><strong>标题（Title）</strong>: Fix: Clears directional navigation map between rebuilds<li><strong>PR链接（PR Link）</strong>: https://github.com/bevyengine/bevy/pull/22124<li><strong>作者（Author）</strong>: kfc35<li><strong>状态（Status）</strong>: 已合并（MERGED）<li><strong>标签（Labels）</strong>: C-Bug, A-UI, S-Ready-For-Final-Review, D-Straightforward<li><strong>创建时间（Created）</strong>: 2025-12-15T07:14:29Z<li><strong>合并时间（Merged）</strong>: 2025-12-15T21:12:20Z<li><strong>合并者（Merged By）</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>目标（Objective）</strong><ul><li>关闭 #21949</ul><p><strong>解决方案（Solution）</strong><ul><li>按照 #21949 中的建议实现了解决方案。方向性导航地图（Directional Navigation Map）不会清除可能连接到已移除节点（Nodes）的任何旧边（edges），因此我们在重建地图之间清除了该地图。</ul><p>（如果更优的解决方案是找出哪些节点被移除，然后调用 <code>map.remove_multiple</code>，您可以随时拒绝此PR）<p><strong>测试（Testing）</strong><ul><li>您是否测试了这些更改？如果是，如何测试的？ 我没有测试此更改，但问题报告者测试了（通过向后移植到较旧版本的Bevy）。然而，这个修复很直接，并且本身就能说明问题。如果您希望以某种方式进行自动化测试，欢迎提供一些类似测试的指引。</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个PR解决了一个在Bevy UI导航系统中存在的bug。具体问题是，当UI节点被动态添加或移除时，方向性导航地图（Directional Navigation Map）会保留旧的边，这些边指向已经不存在的节点，导致导航行为异常。<h3 id=the-problem-and-context>The Problem and Context</h3><p>在Bevy中，UI元素之间的键盘导航（例如使用方向键或Tab键）是通过一个方向性导航地图来管理的。这个地图存储了节点之间的连接关系，指示按下某个方向键时焦点应该如何移动。该地图由系统<code>auto_rebuild_ui_navigation_graph</code>定期重建，以反映UI节点的当前状态。<p>然而，在重建过程中，地图并没有被完全清空。这意味着，如果一个节点在两次重建之间被移除了，那么地图中可能仍然保留着指向该被移除节点的边。当用户尝试导航时，系统可能会尝试将焦点移动到一个不存在的节点，从而导致错误或意外行为。<p>问题 #21949 报告了这种行为，并提供了一个最小可复现示例。该问题在UI节点被动态移除时触发。<h3 id=the-solution-approach>The Solution Approach</h3><p>修复方案非常直接：在每次重建导航地图之前，先清空现有的地图。这样就能确保地图中不会包含任何指向已移除节点的旧边。这种方法简单有效，因为它不需要跟踪哪些节点被移除了，而是直接重置地图并基于当前所有存在的节点重新生成边。<p>另一种更精细的解决方案是只移除与被删除节点相关的边，而不是清空整个地图。这可以通过在重建时计算被移除的节点集合并调用<code>map.remove_multiple</code>来实现。然而，考虑到UI节点变化频率通常不高，且重建地图的成本相对较低，清空整个地图的方法在实现上更简单，不易出错，并且性能影响可以接受。因此，PR作者选择了这种简单直接的解决方案。<h3 id=the-implementation>The Implementation</h3><p>实现只需在<code>auto_rebuild_ui_navigation_graph</code>函数中添加一行代码：<code>directional_nav_map.clear();</code>。这个函数负责自动重建UI导航图。添加的位置是在收集当前所有节点之后，但在调用<code>auto_generate_navigation_edges</code>生成新边之前。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 在重建之间清空旧的导航地图，以确保任何被移除实体的边都被清除
</span><span>directional_nav_map</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>auto_generate_navigation_edges</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> directional_nav_map</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>nodes</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>config)</span><span style=color:#61676ccc>;
</span></code></pre><p>这行代码调用了<code>DirectionalNavigationMap</code>的<code>clear</code>方法，该方法会移除地图中的所有条目。然后，<code>auto_generate_navigation_edges</code>会根据当前存在的节点重新填充地图。<h3 id=technical-insights>Technical Insights</h3><p>这个修复涉及到的核心概念是“方向性导航地图”（Directional Navigation Map）。在Bevy中，这是一个存储了节点之间方向性连接的映射。每个节点可以有上、下、左、右四个方向的邻居。地图的键是源节点，值是一个映射，将方向（<code>Direction</code>）映射到目标节点。<p>当UI节点被移除时，与其相关的所有边都应该从地图中移除。否则，地图中就会包含“悬空引用”。清空整个地图是一种确保一致性的简单方法。<p>从性能角度看，清空地图的复杂度是O(n)，其中n是地图中的条目数。而生成新边的复杂度取决于当前节点的数量及其布局。由于UI节点数量通常不会很大，这种开销是可以接受的。如果未来需要优化，可以考虑增量更新，但当前的解决方案已经足够。<h3 id=the-impact>The Impact</h3><p>这个修复直接解决了UI导航中因节点移除而导致的bug。用户在使用方向键或Tab键导航动态变化的UI时，将不再遇到焦点跳转到不存在节点的问题。这提高了UI导航的可靠性和用户体验。<p>从代码维护的角度看，这个修复非常简单，易于理解，并且降低了地图状态不一致的风险。它遵循了“保持简单”的原则，用最少的代码解决了问题。<p>一个值得注意的技术点是，这个修复假设<code>auto_rebuild_ui_navigation_graph</code>系统会足够频繁地运行，以确保地图及时更新。如果UI节点在两次重建之间被移除和添加，那么在这个短暂窗口内地图可能仍包含旧边。但在实践中，这个窗口非常小，通常不会导致问题。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[UI节点变化: 添加/移除] --> B[系统 auto_rebuild_ui_navigation_graph 运行]
</span><span>    B --> C{方向性导航地图是否已清空?}
</span><span>    C -- 否 --> D[地图保留旧边，可能导致错误]
</span><span>    C -- 是 --> E[地图被清空]
</span><span>    E --> F[基于当前节点重新生成边]
</span><span>    F --> G[导航行为正确]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-input-focus-src-directional-navigation-rs-2-0><code>crates/bevy_input_focus/src/directional_navigation.rs</code> (+2/-0)</h3><p>这是本次PR中唯一修改的文件。更改位于<code>auto_rebuild_ui_navigation_graph</code>函数中，该函数负责自动重建UI导航图。<p><strong>修改内容：</strong> 在函数中，首先收集当前所有的节点（<code>nodes</code>），然后添加了一行代码来清空方向性导航地图，最后调用<code>auto_generate_navigation_edges</code>基于当前节点生成新的边。<p><strong>代码片段：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前（原代码）:
</span><span style=color:#fa6e32>let</span><span> nodes</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, </span><span style=color:#ed9366>&</span><span>Node, </span><span style=color:#ed9366>&</span><span>GlobalTransform, </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>CalculatedClip>)> </span><span style=color:#ed9366>=</span><span> query
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter_map</span><span>(|(</span><span style=color:#ff8f40>entity</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>node</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>global_transform</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>clip</span><span>)| {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 过滤逻辑...
</span><span>    })
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#f07171>auto_generate_navigation_edges</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> directional_nav_map</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>nodes</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>config)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后:
</span><span style=color:#fa6e32>let</span><span> nodes</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, </span><span style=color:#ed9366>&</span><span>Node, </span><span style=color:#ed9366>&</span><span>GlobalTransform, </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>CalculatedClip>)> </span><span style=color:#ed9366>=</span><span> query
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter_map</span><span>(|(</span><span style=color:#ff8f40>entity</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>node</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>global_transform</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>clip</span><span>)| {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 过滤逻辑...
</span><span>    })
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// clear the old nav map between rebuilds to ensure any removed entities' edges are pruned
</span><span>directional_nav_map</span><span style=color:#ed9366>.</span><span style=color:#f07171>clear</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>auto_generate_navigation_edges</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> directional_nav_map</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>nodes</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>config)</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>为什么这个修改很重要？</strong> 这行添加的<code>clear()</code>调用确保了在生成新边之前，旧的地图被完全清空。这样，任何指向已移除节点的边都会被删除，从而避免了悬空引用。这是解决报告问题的直接方法。<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy UI导航系统文档</strong>: 了解Bevy中UI导航的基本概念和API。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/ target=_blank>Bevy UI Book</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/tree/main/crates/bevy_input_focus target=_blank>Bevy Input Focus 模块源码</a></ul><li><p><strong>方向性导航地图（DirectionalNavigationMap）</strong>: 理解该数据结构的实现和使用。</p> <ul><li>查看 <code>crates/bevy_input_focus/src/directional_navigation.rs</code> 中的 <code>DirectionalNavigationMap</code> 定义。</ul><li><p><strong>ECS（Entity Component System）模式</strong>: Bevy使用ECS架构，理解实体、组件和系统如何交互对于理解UI导航更新机制很重要。</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/getting-started/ecs/ target=_blank>Bevy ECS 介绍</a></ul><li><p><strong>增量更新 vs 全量重建</strong>: 在软件工程中，当状态变化时，是增量更新还是全量重建是一个常见的权衡。这个PR选择了全量重建，因为它更简单，但了解增量更新的模式也是有益的。</p> <ul><li>相关设计模式：观察者模式（Observer）、事件溯源（Event Sourcing）。</ul></ol><h1 id=full-code-diff>Full Code Diff</h1><p>diff –git a/crates/bevy_input_focus/src/directional_navigation.rs b/crates/bevy_input_focus/src/directional_navigation.rs index ed34e84bcc067..b4ce6ff319e5b 100644 — a/crates/bevy_input_focus/src/directional_navigation.rs +++ b/crates/bevy_input_focus/src/directional_navigation.rs @@ -773,6 +773,8 @@ fn auto_rebuild_ui_navigation_graph( }) .collect();<ul><li>// clear the old nav map between rebuilds to ensure any removed entities’ edges are pruned<li>directional_nav_map.clear(); auto_generate_navigation_edges(&mut directional_nav_map, &nodes, &config); }</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22124.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>