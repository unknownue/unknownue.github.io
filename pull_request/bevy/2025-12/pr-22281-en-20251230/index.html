<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22281 Optimize transform propagation for dynamic scenes
        
    </title><meta content="#22281 Optimize transform propagation for dynamic scenes" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22281-zh-cn-20251230>中文</a></div></div><div class=pr-content><h1 id=optimize-transform-propagation-for-dynamic-scenes>Optimize transform propagation for dynamic scenes</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Optimize transform propagation for dynamic scenes<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22281<li><strong>Author</strong>: aevyrie<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Performance, S-Ready-For-Final-Review, A-Transform, X-Uncontroversial, D-Straightforward<li><strong>Created</strong>: 2025-12-26T21:18:20Z<li><strong>Merged</strong>: 2025-12-30T01:31:57Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Follow up from previous transform optimization (#18589), make the <code>mark_dirty_trees</code> system more intelligent - don’t run this expensive static scene optimization for dynamic scenes.<li>Using a threshold was mentioned as a follow up in that PR, and we also want this threshold to be user-configurable.<li>This was not implemented previously because the optimizations were still large improvements even in dynamic scenes thanks to the improved parallelism #17840</ul><h2 id=solution>Solution</h2><ul><li>Don’t run static scene optimization (dirty tree tracking) for very dynamic scenes - defined here as scenes where more than 30% of objects have their <code>Transform</code> updated.<li>This is configurable with a percentage threshold, or it can be unconditionally enabled or disabled when setting to <code>0.0</code> or <code>1.0</code> to avoid the cost of computing the threshold.<li>For dynamic scenes, this makes transform prop much faster, twice as fast in the stress tests shown here.</ul><h2 id=testing>Testing</h2><p>transform_hierarchy stress tests, all of these cases spawn about a quarter million entities:<ul><li><p>humanoids_active - dynamic scene that should be faster than <code>main</code>: <img alt=image height=395 src=https://github.com/user-attachments/assets/bf3d6b93-aa09-4440-b8ac-18af7e46a00f width=609></p><li><p>humanoids_inactive - static scene that should be unchanged from <code>main</code>: <img alt=image height=377 src=https://github.com/user-attachments/assets/a0306109-600b-4cdd-a217-5cc15e269bca width=631></p><li><p>humanoids_mixed - half dynamic scene that should be faster than <code>main</code> <img alt=image height=372 src=https://github.com/user-attachments/assets/2751ece2-d4b9-4daa-af24-fe379eaf75b2 width=604></p><li><p>large_tree - dynamic scene (50% of entities are moved) we expect to see improvements <img alt=image height=371 src=https://github.com/user-attachments/assets/c6b08abe-eb1d-44fb-be36-457f9d5ba78e width=665></p></ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a performance optimization problem in Bevy’s transform system. The core issue is that previous optimizations for static scenes introduced overhead that becomes counterproductive in dynamic scenes where many entities move each frame.<p>The transform system in Bevy uses a hierarchy where parent transforms affect their children. When a transform changes, the system needs to propagate these changes through the hierarchy. Previous work (#18589) introduced an optimization that tracks “dirty trees” - marking entire subtrees as unchanged when their transforms haven’t been modified, allowing the system to skip expensive propagation work for static portions of the scene.<p>However, this optimization has a cost: the system needs to track which entities have changed and propagate dirty flags up the hierarchy. In highly dynamic scenes where many entities move each frame, this tracking work can exceed the benefits of skipping static subtrees. The PR author notes that this wasn’t implemented earlier because parallelization improvements (#17840) still provided benefits even in dynamic scenes.<p>The solution introduces a configurable threshold system. The new <code>StaticTransformOptimizations</code> resource tracks whether static scene optimization should be enabled based on the percentage of moving entities. By default, if more than 30% of entities have their <code>Transform</code> updated, the system disables the dirty tree tracking entirely.<p>The implementation works by having the <code>mark_dirty_trees</code> system count how many entities have changed transforms each frame and compare this to the total number of entities with transforms. If the percentage exceeds the threshold, the system skips the dirty tree marking entirely:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> n_dyn </span><span style=color:#ed9366>=</span><span> changed_transforms</span><span style=color:#ed9366>.</span><span style=color:#f07171>count</span><span>() </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> total </span><span style=color:#ed9366>=</span><span> transforms</span><span style=color:#ed9366>.</span><span style=color:#f07171>count</span><span>() </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>if</span><span> n_dyn </span><span style=color:#ed9366>/</span><span> total </span><span style=color:#ed9366>></span><span> threshold {
</span><span>    static_optimizations</span><span style=color:#ed9366>.</span><span>enabled </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This check happens early in the system, so when optimization is disabled, the system returns immediately without performing any dirty tree marking work.<p>The <code>propagate_parent_transforms</code> system then checks the <code>enabled</code> flag and skips processing for entities that aren’t marked as dirty when optimization is enabled:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if</span><span> static_optimizations</span><span style=color:#ed9366>.</span><span>enabled </span><span style=color:#ed9366>&& !</span><span>transform_tree</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_changed</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Early exit if the subtree is static and the optimization is enabled.
</span><span>    </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The threshold is user-configurable, with special cases for 0.0 (always disabled) and 1.0 (always enabled) to avoid the overhead of computing percentages.<p>The performance impact is significant for dynamic scenes. In stress tests with ~250,000 entities, dynamic scenes show approximately 2x speed improvement for transform propagation. Static scenes remain unchanged, as the optimization continues to work for them.<p>One important design decision is that the threshold comparison uses a simple percentage of moving entities rather than a more complex heuristic. This keeps the implementation straightforward and predictable. The 30% default was likely chosen through empirical testing as a reasonable balance point.<p>The changes are minimal and focused. The main modifications are:<ol><li>Adding the <code>StaticTransformOptimizations</code> resource<li>Modifying <code>mark_dirty_trees</code> to conditionally run based on the threshold<li>Modifying <code>propagate_parent_transforms</code> to respect the optimization state<li>Updating tests and examples to initialize the new resource</ol><p>This approach demonstrates a common performance optimization pattern: adding conditional logic to skip expensive operations when they’re not beneficial. The key insight is recognizing that optimizations designed for one workload (static scenes) can become overhead for different workloads (dynamic scenes), and the solution is to dynamically detect which workload you’re dealing with.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[TransformPlugin] --> B[Initializes StaticTransformOptimizations]
</span><span>    B --> C[mark_dirty_trees system]
</span><span>    C --> D{Check threshold&LTbr/>% of moving entities}
</span><span>    D -->|Below threshold| E[Run dirty tree marking]
</span><span>    D -->|Above threshold| F[Skip dirty tree marking]
</span><span>    E --> G[propagate_parent_transforms]
</span><span>    F --> G
</span><span>    G --> H{Static optimization enabled?}
</span><span>    H -->|Yes| I[Skip static subtrees]
</span><span>    H -->|No| J[Process all entities]
</span><span>    I --> K[Performance benefit for static scenes]
</span><span>    J --> L[Performance benefit for dynamic scenes]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-transform-src-systems-rs-127-14><code>crates/bevy_transform/src/systems.rs</code> (+127/-14)</h3><p>This file contains the core implementation changes. The main additions are:<ol><li><strong>New <code>StaticTransformOptimizations</code> resource</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Resource</span><span style=color:#61676ccc>,</span><span> Debug)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg_attr</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"bevy_reflect"</span><span style=color:#61676ccc>, </span><span style=color:#f29718>derive</span><span>(bevy_reflect::Reflect))]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>StaticTransformOptimizations </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// If the percentage of moving objects exceeds this value, skip dirty tree marking.
</span><span>    threshold</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Updated every frame by [`mark_dirty_trees`].
</span><span>    enabled</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>}
</span></code></pre><ol start=2><li><strong>Modified <code>mark_dirty_trees</code> system</strong> with threshold checking:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> threshold </span><span style=color:#ed9366>=</span><span> static_optimizations</span><span style=color:#ed9366>.</span><span>threshold</span><span style=color:#ed9366>.</span><span style=color:#f07171>clamp</span><span>(</span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1.0</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>match</span><span> threshold {
</span><span>    </span><span style=color:#ff8f40>0.0 </span><span style=color:#ed9366>=></span><span> static_optimizations</span><span style=color:#ed9366>.</span><span>enabled </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>=></span><span> static_optimizations</span><span style=color:#ed9366>.</span><span>enabled </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>_ => </span><span>{
</span><span>        static_optimizations</span><span style=color:#ed9366>.</span><span>enabled </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> n_dyn </span><span style=color:#ed9366>=</span><span> changed_transforms</span><span style=color:#ed9366>.</span><span style=color:#f07171>count</span><span>() </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> total </span><span style=color:#ed9366>=</span><span> transforms</span><span style=color:#ed9366>.</span><span style=color:#f07171>count</span><span>() </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>f32</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if</span><span> n_dyn </span><span style=color:#ed9366>/</span><span> total </span><span style=color:#ed9366>></span><span> threshold {
</span><span>            static_optimizations</span><span style=color:#ed9366>.</span><span>enabled </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>static_optimizations</span><span style=color:#ed9366>.</span><span>enabled {
</span><span>    </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=3><li><strong>Modified <code>propagate_parent_transforms</code> system</strong> to check the optimization state:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if</span><span> static_optimizations</span><span style=color:#ed9366>.</span><span>enabled </span><span style=color:#ed9366>&& !</span><span>transform_tree</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_changed</span><span>() {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Early exit if the subtree is static and the optimization is enabled.
</span><span>    </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-transform-src-plugins-rs-5-2><code>crates/bevy_transform/src/plugins.rs</code> (+5/-2)</h3><p>The plugin now initializes the <code>StaticTransformOptimizations</code> resource:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>Plugin </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>TransformPlugin </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>build</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>        app</span><span style=color:#ed9366>.</span><span>init_resource</span><span style=color:#ed9366>::</span><span>&LTStaticTransformOptimizations>()
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... rest of plugin setup
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-transform-src-lib-rs-4-1><code>crates/bevy_transform/src/lib.rs</code> (+4/-1)</h3><p>Exports the new <code>StaticTransformOptimizations</code> type from the prelude:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub use </span><span>prelude</span><span style=color:#ed9366>::</span><span>{
</span><span>    StaticTransformOptimizations</span><span style=color:#61676ccc>,</span><span> TransformPlugin</span><span style=color:#61676ccc>,</span><span> TransformPoint</span><span style=color:#61676ccc>,</span><span> TransformSystems</span><span style=color:#61676ccc>,
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ui-src-layout-mod-rs-1-0><code>crates/bevy_ui/src/layout/mod.rs</code> (+1/-0)</h3><p>Adds initialization of <code>StaticTransformOptimizations</code> in UI tests:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>app</span><span style=color:#ed9366>.</span><span>init_resource</span><span style=color:#ed9366>::</span><span>&LTbevy_transform</span><span style=color:#ed9366>::</span><span>StaticTransformOptimizations>()</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=examples-stress-tests-bevymark-rs-1-0-and-examples-stress-tests-many-foxes-rs-1-0><code>examples/stress_tests/bevymark.rs</code> (+1/-0) and <code>examples/stress_tests/many_foxes.rs</code> (+1/-0)</h3><p>These stress tests disable the static optimizations since they represent dynamic scenes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>.</span><span style=color:#f07171>insert_resource</span><span>(StaticTransformOptimizations</span><span style=color:#ed9366>::</span><span>disabled())
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/18589 target=_blank>Original transform optimization PR #18589</a> - The previous optimization that introduced dirty tree tracking<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/17840 target=_blank>Parallelization improvements #17840</a> - Made transform propagation parallel<li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_transform/latest/bevy_transform/ target=_blank>Bevy Transform System Documentation</a> - Official documentation for Bevy’s transform system<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Entity_component_system target=_blank>Entity Component System Pattern</a> - Background on ECS architecture used by Bevy</ol><h1 id=full-code-diff>Full Code Diff</h1><details><summary>Click to expand full diff</summary> <pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_transform/src/lib.rs b/crates/bevy_transform/src/lib.rs
</span><span>index 240d96df5b152..d87d6ba63f037 100644
</span><span style=color:#c594c5>--- a/crates/bevy_transform/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_transform/src/lib.rs
</span><span style=color:#c594c5>@@ -46,9 +46,12 @@ </span><span style=color:#399ee6>pub mod prelude {
</span><span>         commands::BuildChildrenTransformExt,
</span><span>         helper::TransformHelper,
</span><span>         plugins::{TransformPlugin, TransformSystems},
</span><span style=color:#86b300>+        systems::StaticTransformOptimizations,
</span><span>         traits::TransformPoint,
</span><span>     };
</span><span> }
</span><span> 
</span><span> #[cfg(feature = "bevy-support")]
</span><span style=color:#f07171>-pub use prelude::{TransformPlugin, TransformPoint, TransformSystems};
</span><span style=color:#86b300>+pub use prelude::{
</span><span style=color:#86b300>+    StaticTransformOptimizations, TransformPlugin, TransformPoint, TransformSystems,
</span><span style=color:#86b300>+};
</span><span>diff --git a/crates/bevy_transform/src/plugins.rs b/crates/bevy_transform/src/plugins.rs
</span><span>index 49b34674aa30a..3881d93c56a3e 100644
</span><span style=color:#c594c5>--- a/crates/bevy_transform/src/plugins.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_transform/src/plugins.rs
</span><span style=color:#c594c5>@@ -1,4 +1,7 @@
</span><span style=color:#f07171>-use crate::systems::{mark_dirty_trees, propagate_parent_transforms, sync_simple_transforms};
</span><span style=color:#86b300>+use crate::systems::{
</span><span style=color:#86b300>+    mark_dirty_trees, propagate_parent_transforms, sync_simple_transforms,
</span><span style=color:#86b300>+    StaticTransformOptimizations,
</span><span style=color:#86b300>+};
</span><span> use bevy_app::{App, Plugin, PostStartup, PostUpdate};
</span><span> use bevy_ecs::schedule::{IntoScheduleConfigs, SystemSet};
</span><span> 
</span><span style=color:#c594c5>@@ -15,7 +18,7 @@ </span><span style=color:#399ee6>pub struct TransformPlugin;
</span><span> 
</span><span> impl Plugin for TransformPlugin {
</span><span>     fn build(&self, app: &mut App) {
</span><span style=color:#f07171>-        app
</span><span style=color:#86b300>+        app.init_resource::&LTStaticTransformOptimizations>()
</span><span>             // add transform systems to startup so the first update is "correct"
</span><span>             .add_systems(
</span><span>                 PostStartup,
</span><span>diff --git a/crates/bevy_transform/src/systems.rs b/crates/bevy_transform/src/systems.rs
</span><span>index 34366b1b3ce25..1e1ea8eb0217d 100644
</span><span style=color:#c594c5>--- a/crates/bevy_transform/src/systems.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_transform/src/systems.rs
</span><span style=color:#c594c5>@@ -1,5 +1,6 @@
</span><span> use crate::components::{GlobalTransform, Transform, TransformTreeChanged};
</span><span> use bevy_ecs::prelude::*;
</span><span style=color:#86b300>+
</span><span> #[cfg(feature = "std")]
</span><span> pub use parallel::propagate_parent_transforms;
</span><span> #[cfg(not(feature = "std"))]
</span><span style=color:#c594c5>@@ -40,27 +41,108 @@ </span><span style=color:#399ee6>pub fn sync_simple_transforms(
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Optimization for static scenes. Propagates a "dirty bit" up the hierarchy towards ancestors.
</span><span style=color:#f07171>-/// Transform propagation can ignore entire subtrees of the hierarchy if it encounters an entity
</span><span style=color:#f07171>-/// without the dirty bit.
</span><span style=color:#86b300>+/// Configure the behavior of static scene optimizations for [`Transform`] propagation.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// For scenes with many static entities, it is much faster to track trees of unchanged
</span><span style=color:#86b300>+/// [`Transform`]s and skip these during the expensive transform propagation step. If your scene is
</span><span style=color:#86b300>+/// very dynamic, the cost of tracking these trees can exceed the performance benefits. By default,
</span><span style=color:#86b300>+/// static scene optimization is disabled for worlds with more than 30% of its entities moving.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// This resource allows you to configure that threshold at runtime.
</span><span style=color:#86b300>+#[derive(Resource, Debug)]
</span><span style=color:#86b300>+#[cfg_attr(feature = "bevy_reflect", derive(bevy_reflect::Reflect))]
</span><span style=color:#86b300>+pub struct StaticTransformOptimizations {
</span><span style=color:#86b300>+    /// If the percentage of moving objects exceeds this value, skip dirty tree marking.
</span><span style=color:#86b300>+    threshold: f32,
</span><span style=color:#86b300>+    /// Updated every frame by [`mark_dirty_trees`].
</span><span style=color:#86b300>+    enabled: bool,
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+impl StaticTransformOptimizations {
</span><span style=color:#86b300>+    /// If the percentage of moving objects exceeds this threshold, disable static [`Transform`]
</span><span style=color:#86b300>+    /// optimizations. This is done because the scene is so dynamic that the cost of tracking static
</span><span style=color:#86b300>+    /// trees exceeds the performance benefit of skipping propagation for these trees.
</span><span style=color:#86b300>+    ///
</span><span style=color:#86b300>+    /// - Setting this to `0.0` will result in never running static scene tracking.
</span><span style=color:#86b300>+    /// - Setting this to `1.0` will result in always tracking static transform trees.
</span><span style=color:#86b300>+    pub fn from_threshold(threshold: f32) -> Self {
</span><span style=color:#86b300>+        Self {
</span><span style=color:#86b300>+            threshold,
</span><span style=color:#86b300>+            enabled: true,
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    /// Unconditionally disable static scene optimizations.
</span><span style=color:#86b300>+    pub fn disabled() -> Self {
</span><span style=color:#86b300>+        Self {
</span><span style=color:#86b300>+            threshold: 0.0,
</span><span style=color:#86b300>+            enabled: false,
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    /// Unconditionally enable static scene optimizations.
</span><span style=color:#86b300>+    pub fn enabled() -> Self {
</span><span style=color:#86b300>+        Self {
</span><span style=color:#86b300>+            threshold: 1.0,
</span><span style=color:#86b300>+            enabled: true,
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+impl Default for StaticTransformOptimizations {
</span><span style=color:#86b300>+    fn default() -> Self {
</span><span style=color:#86b300>+        Self {
</span><span style=color:#86b300>+            // Scenes with more than 30% moving objects are considered dynamic enough to skip static
</span><span style=color:#86b300>+            // optimizations.
</span><span style=color:#86b300>+            threshold: 0.3,
</span><span style=color:#86b300>+            enabled: true,
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+/// Optimization for static scenes.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// Propagates a "dirty bit" up the hierarchy towards ancestors. Transform propagation can ignore
</span><span style=color:#86b300>+/// entire subtrees of the hierarchy if it encounters an entity without the dirty bit.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// Configure behavior with [`StaticTransformOptimizations`].
</span><span> pub fn mark_dirty_trees(
</span><span>     changed_transforms: Query<
</span><span>         Entity,
</span><span>         Or<(Changed&LTTransform>, Changed&LTChildOf>, Added&LTGlobalTransform>)>,
</span><span>     >,
</span><span>     mut orphaned: RemovedComponents&LTChildOf>,
</span><span style=color:#f07171>-    mut transforms: Query<(Option<&ChildOf>, &mut TransformTreeChanged)>,
</span><span style=color:#86b300>+    mut transforms: Query<&mut TransformTreeChanged>,
</span><span style=color:#86b300>+    parents: Query<&ChildOf>,
</span><span style=color:#86b300>+    mut static_optimizations: ResMut&LTStaticTransformOptimizations>,
</span><span> ) {
</span><span style=color:#86b300>+    let threshold = static_optimizations.threshold.clamp(0.0, 1.0);
</span><span style=color:#86b300>+    match threshold {
</span><span style=color:#86b300>+        0.0 => static_optimizations.enabled = false,
</span><span style=color:#86b300>+        1.0 => static_optimizations.enabled = true,
</span><span style=color:#86b300>+        _ => {
</span><span style=color:#86b300>+            static_optimizations.enabled = true;
</span><span style=color:#86b300>+            let n_dyn = changed_transforms.count() as f32;
</span><span style=color:#86b300>+            let total = transforms.count() as f32;
</span><span style=color:#86b300>+            if n_dyn / total > threshold {
</span><span style=color:#86b300>+                static_optimizations.enabled = false;
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    if !static_optimizations.enabled {
</span><span style=color:#86b300>+        return;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span>     for entity in changed_transforms.iter().chain(orphaned.read()) {
</span><span>         let mut next = entity;
</span><span style=color:#f07171>-        while let Ok((child_of, mut tree)) = transforms.get_mut(next) {
</span><span style=color:#86b300>+        while let Ok(mut tree) = transforms.get_mut(next) {
</span><span>             if tree.is_changed() && !tree.is_added() {
</span><span>                 // If the component was changed, this part of the tree has already been processed.
</span><span>                 // Ignore this if the change was caused by the component being added.
</span><span>                 break;
</span><span>             }
</span><span>             tree.set_changed();
</span><span style=color:#f07171>-            if let Some(parent) = child_of.map(ChildOf::parent) {
</span><span style=color:#86b300>+            if let Ok(parent) = parents.get(next).map(ChildOf::parent) {
</span><span>                 next = parent;
</span><span>             } else {
</span><span>                 break;
</span><span style=color:#c594c5>@@ -250,6 +332,7 @@ </span><span style=color:#399ee6>mod serial {
</span><span> mod parallel {
</span><span>     use crate::prelude::*;
</span><span>     // TODO: this implementation could be used in no_std if there are equivalents of these.
</span><span style=color:#86b300>+    use crate::systems::StaticTransformOptimizations;
</span><span>     use alloc::{sync::Arc, vec::Vec};
</span><span>     use bevy_ecs::{entity::UniqueEntityIter, prelude::*, system::lifetimeless::Read};
</span><span>     use bevy_tasks::{ComputeTaskPool, TaskPool};
</span><span style=color:#c594c5>@@ -269,15 +352,27 @@ </span><span style=color:#399ee6>mod parallel {
</span><span>     pub fn propagate_parent_transforms(
</span><span>         mut queue: Local&LTWorkQueue>,
</span><span>         mut roots: Query<
</span><span style=color:#f07171>-            (Entity, Ref&LTTransform>, &mut GlobalTransform, &Children),
</span><span style=color:#f07171>-            (Without&LTChildOf>, Changed&LTTransformTreeChanged>),
</span><span style=color:#86b300>+            (
</span><span style=color:#86b300>+                Entity,
</span><span style=color:#86b300>+                Ref&LTTransform>,
</span><span style=color:#86b300>+                &mut GlobalTransform,
</span><span style=color:#86b300>+                &Children,
</span><span style=color:#86b300>+                Ref&LTTransformTreeChanged>,
</span><span style=color:#86b300>+            ),
</span><span style=color:#86b300>+            Without&LTChildOf>,
</span><span>         >,
</span><span>         nodes: NodeQuery,
</span><span style=color:#86b300>+        static_optimizations: Res&LTStaticTransformOptimizations>,
</span><span>     ) {
</span><span>         // Process roots in parallel, seeding the work queue
</span><span>         roots.par_iter_mut().for_each_init(
</span><span>             || queue.local_queue.borrow_local_mut(),
</span><span style=color:#f07171>-            |outbox, (parent, transform, mut parent_transform, children)| {
</span><span style=color:#86b300>+            |outbox, (parent, transform, mut parent_transform, children, transform_tree)| {
</span><span style=color:#86b300>+                if static_optimizations.enabled && !transform_tree.is_changed() {
</span><span style=color:#86b300>+                    // Early exit if the subtree is static and the optimization is enabled.
</span><span style=color:#86b300>+                    return;
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+
</span><span>                 *parent_transform = GlobalTransform::from(*transform);
</span><span> 
</span><span>                 // SAFETY: the parent entities passed into this function are taken from iterating
</span><span style=color:#c594c5>@@ -292,6 +387,7 @@ </span><span style=color:#399ee6>mod parallel {
</span><span>                         &nodes,
</span><span>                         outbox,
</span><span>                         &queue,
</span><span style=color:#86b300>+                        &static_optimizations,
</span><span>                         // Need to revisit this single-max-depth by profiling more representative
</span><span>                         // scenes. It's possible that it is actually beneficial to go deep into the
</span><span>                         // hierarchy to build up a good task queue before starting the workers.
</span><span style=color:#c594c5>@@ -323,15 +419,21 @@ </span><span style=color:#399ee6>mod parallel {
</span><span>         let task_pool = ComputeTaskPool::get_or_init(TaskPool::default);
</span><span>         task_pool.scope(|s| {
</span><span>             (1..task_pool.thread_num()) // First worker is run locally instead of the task pool.
</span><span style=color:#f07171>-                .for_each(|_| s.spawn(async { propagation_worker(&queue, &nodes) }));
</span><span style=color:#f07171>-            propagation_worker(&queue, &nodes);
</span><span style=color:#86b300>+                .for_each(|_| {
</span><span style=color:#86b300>+                    s.spawn(async { propagation_worker(&queue, &nodes, &static_optimizations) });
</span><span style=color:#86b300>+                });
</span><span style=color:#86b300>+            propagation_worker(&queue, &nodes, &static_optimizations);
</span><span>         });
</span><span>     }
</span><span> 
</span><span>     /// A parallel worker that will consume processed parent entities from the queue, and push
</span><span>     /// children to the queue once it has propagated their [`GlobalTransform`].
</span><span>     #[inline]
</span><span style=color:#f07171>-    fn propagation_worker(queue: &WorkQueue, nodes: &NodeQuery) {
</span><span style=color:#86b300>+    fn propagation_worker(
</span><span style=color:#86b300>+        queue: &WorkQueue,
</span><span style=color:#86b300>+        nodes: &NodeQuery,
</span><span style=color:#86b300>+        static_optimizations: &StaticTransformOptimizations,
</span><span style=color:#86b300>+    ) {
</span><span>         #[cfg(feature = "std")]
</span><span>         let _span = bevy_log::info_span!("transform propagation worker").entered();
</span><span> 
</span><span style=color:#c594c5>@@ -386,6 +488,7 @@ </span><span style=color:#399ee6>mod parallel {
</span><span>                         nodes,
</span><span>                         &mut outbox,
</span><span>                         queue,
</span><span style=color:#86b300>+                        static_optimizations,
</span><span>                         // Only affects performance. Trees deeper than this will still be fully
</span><span>                         // propagated, but the work will be broken into multiple tasks. This number
</span><span>                         // was chosen to be larger than any reasonable tree depth, while not being
</span><span style=color:#c594c5>@@ -426,6 +529,7 @@ </span><span style=color:#399ee6>mod parallel {
</span><span>         nodes: &NodeQuery,
</span><span>         outbox: &mut Vec&LTEntity>,
</span><span>         queue: &WorkQueue,
</span><span style=color:#86b300>+        static_optimizations: &StaticTransformOptimizations,
</span><span>         max_depth: usize,
</span><span>     ) {
</span><span>         // Create mutable copies of the input variables, used for iterative depth-first traversal.
</span><span style=color:#c594c5>@@ -448,7 +552,10 @@ </span><span style=color:#399ee6>mod parallel {
</span><span>             let mut last_child = None;
</span><span>             let new_children = children_iter.filter_map(
</span><span>                 |(child, (transform, mut global_transform, tree), (children, child_of))| {
</span><span style=color:#f07171>-                    if !tree.is_changed() && !p_global_transform.is_changed() {
</span><span style=color:#86b300>+                    if static_optimizations.enabled
</span><span style=color:#86b300>+                        && !tree.is_changed()
</span><span style=color:#86b300>+                        && !p_global_transform.is_changed()
</span><span style=color:#86b300>+                    {
</span><span>                         // Static scene optimization
</span><span>                         return None;
</span><span>                     }
</span><span style=color:#c594c5>@@ -580,6 +687,7 @@ </span><span style=color:#399ee6>mod test {
</span><span>             )
</span><span>                 .chain(),
</span><span>         );
</span><span style=color:#86b300>+        world.insert_resource(StaticTransformOptimizations::default());
</span><span> 
</span><span>         let mut command_queue = CommandQueue::default();
</span><span>         let mut commands = Commands::new(&mut command_queue, &world);
</span><span style=color:#c594c5>@@ -638,6 +746,7 @@ </span><span style=color:#399ee6>mod test {
</span><span>             )
</span><span>                 .chain(),
</span><span>         );
</span><span style=color:#86b300>+        world.insert_resource(StaticTransformOptimizations::default());
</span><span> 
</span><span>         // Root entity
</span><span>         world.spawn(Transform::from_xyz(1.0, 0.0, 0.0));
</span><span style=color:#c594c5>@@ -675,6 +784,7 @@ </span><span style=color:#399ee6>mod test {
</span><span>             )
</span><span>                 .chain(),
</span><span>         );
</span><span style=color:#86b300>+        world.insert_resource(StaticTransformOptimizations::default());
</span><span> 
</span><span>         // Root entity
</span><span>         let mut queue = CommandQueue::default();
</span><span style=color:#c594c5>@@ -714,6 +824,7 @@ </span><span style=color:#399ee6>mod test {
</span><span>             )
</span><span>                 .chain(),
</span><span>         );
</span><span style=color:#86b300>+        world.insert_resource(StaticTransformOptimizations::default());
</span><span> 
</span><span>         // Add parent entities
</span><span>         let mut children = Vec::new();
</span><span style=color:#c594c5>@@ -793,7 +904,8 @@ </span><span style=color:#399ee6>mod test {
</span><span>                 propagate_parent_transforms,
</span><span>             )
</span><span>                 .chain(),
</span><span style=color:#f07171>-        );
</span><span style=color:#86b300>+        )
</span><span style=color:#86b300>+        .insert_resource(StaticTransformOptimizations::default());
</span><span> 
</span><span>         let translation = vec3(1.0, 0.0, 0.0);
</span><span> 
</span><span style=color:#c594c5>@@ -913,6 +1025,7 @@ </span><span style=color:#399ee6>mod test {
</span><span>             )
</span><span>                 .chain(),
</span><span>         );
</span><span style=color:#86b300>+        world.insert_resource(StaticTransformOptimizations::default());
</span><span> 
</span><span>         // Spawn a `Transform` entity with a local translation of `Vec3::ONE`
</span><span>         let mut spawn_transform_bundle =
</span><span>diff --git a/crates/bevy_ui/src/layout/mod.rs b/crates/bevy_ui/src/layout/mod.rs
</span><span>index 092d45bc285db..e88718a31cd0d 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ui/src/layout/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ui/src/layout/mod.rs
</span><span style=color:#c594c5>@@ -390,6 +390,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         app.init_resource::&LTbevy_text::TextPipeline>();
</span><span>         app.init_resource::&LTbevy_text::CosmicFontSystem>();
</span><span>         app.init_resource::&LTbevy_text::SwashCache>();
</span><span style=color:#86b300>+        app.init_resource::&LTbevy_transform::StaticTransformOptimizations>();
</span><span> 
</span><span>         app.add_systems(
</span><span>             PostUpdate,
</span><span>diff --git a/examples/stress_tests/bevymark.rs b/examples/stress_tests/bevymark.rs
</span><span>index f133a3b2a438c..0ea3ec137d288 100644
</span><span style=color:#c594c5>--- a/examples/stress_tests/bevymark.rs
</span><span style=color:#c594c5>+++ b/examples/stress_tests/bevymark.rs
</span><span style=color:#c594c5>@@ -142,6 +142,7 @@ </span><span style=color:#399ee6>fn main() {
</span><span>             FrameTimeDiagnosticsPlugin::default(),
</span><span>             LogDiagnosticsPlugin::default(),
</span><span>         ))
</span><span style=color:#86b300>+        .insert_resource(StaticTransformOptimizations::disabled())
</span><span>         .insert_resource(WinitSettings::continuous())
</span><span>         .insert_resource(args)
</span><span>         .insert_resource(BevyCounter {
</span><span>diff --git a/examples/stress_tests/many_foxes.rs b/examples/stress_tests/many_foxes.rs
</span><span>index 10d7ece5929c7..ca5a5ddb83fb1 100644
</span><span style=color:#c594c5>--- a/examples/stress_tests/many_foxes.rs
</span><span style=color:#c594c5>+++ b/examples/stress_tests/many_foxes.rs
</span><span style=color:#c594c5>@@ -54,6 +54,7 @@ </span><span style=color:#399ee6>fn main() {
</span><span>             FrameTimeDiagnosticsPlugin::default(),
</span><span>             LogDiagnosticsPlugin::default(),
</span><span>         ))
</span><span style=color:#86b300>+        .insert_resource(StaticTransformOptimizations::disabled())
</span><span>         .insert_resource(WinitSettings::continuous())
</span><span>         .insert_resource(Foxes {
</span><span>             count: args.count,
</span></code></pre></details></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22281.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>