<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #13797 Implement the infrastructure needed to support portals and mirrors.
        
    </title><meta content="#13797 Implement the infrastructure needed to support portals and mirrors." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-09</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-13797-zh-cn-20251209>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Implement the infrastructure needed to support portals and mirrors.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/13797<li><strong>Author</strong>: pcwalton<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Review, A-Math, M-Release-Note<li><strong>Created</strong>: 2024-06-10T18:55:21Z<li><strong>Merged</strong>: 2025-12-09T23:32:50Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Implement the infrastructure needed to support portals and mirrors.<p>Bevy currently supports multiple cameras and rendering to off-screen render targets, so one might naïvely think that the engine has support for portals and mirrors already. However, Bevy is missing two key features that enable portals and mirrors at present:<ol><li><p>Bevy has support for neither custom clip planes nor oblique clip planes. This prevents the construction of proper portals or mirrors, as meshes that intersect the portal plane must be clipped to render properly.</p><li><p>Bevy has no support for cameras that invert the culling mode, so meshes that are reflected across a plane will render inside-out.</p></ol><p>This PR addresses the two issues above:<ol><li><p>This commit introduces a new field on <code>PerspectiveProjection</code>, <code>near_clip_plane</code>, which allows the application to specify a custom near plane. That feature fully enables <a rel="noopener nofollow noreferrer" href=https://terathon.com/lengyel/Lengyel-Oblique.pdf target=_blank>Lengyel oblique clipping</a>, which is the most optimal way to achieve a custom near clipping plane. It allows us to avoid having to support custom clip planes, which are often implemented inefficiently in hardware.</p><li><p>This patch adds a new field on the <code>Camera</code> component, <code>invert_culling</code>. This field causes the Bevy renderer to invert the front face setting when rendering the objects visible from that camera. When coupled with an appropriately-set <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Householder_transformation target=_blank>Householder matrix</a> on the camera, this allows correct rendering of objects reflected across a plane.</p></ol><p>Additionally, this PR adds a new function to <code>bevy_math::mat3</code>, <code>reflection_matrix</code>. This generates the matrix that reflects objects across a plane, suitable for encoding into a <code>Transform</code>. It’s fully documented for ease of use.<p>Finally, a new example, <code>mirror</code>, has been added. This example is a complete instance of a working mirror, combining a camera with a Householder matrix, oblique projection, and inverted culling with a custom material to render an animated mesh and its planar reflection. The camera and mesh may be moved with the mouse, and the off-screen render target that stores the rendered contents of the mirror world is properly resized when the user resizes the window.</p><img alt="Screenshot 2025-12-05 212155" height=1500 src=https://github.com/user-attachments/assets/35652b58-a9a5-415a-bdff-367889a23b9f width=2564><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses two fundamental technical gaps in Bevy’s rendering system that prevented proper implementation of portals and mirrors. While Bevy already supported multiple cameras and off-screen render targets, the missing pieces were custom clipping planes and culling inversion for reflected scenes.<p>The core problem with portals and mirrors is geometry clipping. When you have a portal or mirror surface, any geometry that intersects the plane of that surface needs to be clipped to avoid rendering artifacts. Without custom clip planes, objects would render through the mirror plane, breaking the illusion. The second issue is that reflecting a scene across a plane flips the winding order of polygons, which causes standard backface culling to cull the wrong faces - what should be visible becomes culled, and vice versa.<p>The solution implements two complementary features. First, the <code>PerspectiveProjection</code> struct gains a <code>near_clip_plane</code> field that uses Lengyel’s oblique clipping technique. This approach modifies the projection matrix to use an arbitrary plane as the near clipping plane, which is more efficient than hardware custom clip planes. The implementation in <code>adjust_perspective_matrix_for_clip_plane()</code> follows the mathematical derivation from Lengyel’s paper, adapted for Bevy’s reverse-Z projection system.<p>Second, a new <code>invert_culling</code> field is added to the <code>Camera</code> component. When this flag is true, the rendering pipeline flips the culling mode - materials that would normally cull back faces instead cull front faces, and vice versa. This is implemented by adding an <code>INVERT_CULLING</code> bit to <code>MeshPipelineKey</code>, which is set during view preparation and used during material specialization to swap the cull face.<p>To make these features usable, the PR also adds a <code>reflection_matrix</code> utility function to <code>bevy_math</code>. This generates a Householder transformation matrix that reflects points across a plane, which is essential for setting up the mirror camera’s transform. The implementation follows the standard formula I - 2NNᵀ, where N is the plane normal.<p>The <code>mirror</code> example demonstrates the complete system working together. It creates a scene with a main camera, a mirror surface, and a secondary camera that renders the reflected scene to an off-screen texture. The mirror camera uses a Householder matrix to reflect the main camera’s transform, sets <code>invert_culling</code> to true, and configures an oblique projection plane aligned with the mirror surface. The mirror material uses a custom shader that samples from the off-screen texture at screen-space coordinates, effectively compositing the reflection onto the mirror surface.<p>One important implementation detail is how the system handles window resizing. Since the off-screen render target needs to match the window dimensions, the example includes logic to recreate the render texture when the window size changes and update both the camera target and material texture references.<p>The changes are integrated throughout Bevy’s rendering pipeline. The <code>invert_culling</code> flag propagates from the <code>Camera</code> component through <code>ExtractedView</code> to the mesh pipeline key system. The oblique clipping modifies the projection matrix calculation in both the standard and sub-view camera paths. The system maintains backward compatibility by using default values that preserve existing behavior.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Camera.invert_culling] --> B[ExtractedView]
</span><span>    B --> C[MeshPipelineKey.INVERT_CULLING]
</span><span>    C --> D[Material Specialization]
</span><span>    D --> E[Cull Mode Inversion]
</span><span>    
</span><span>    F[PerspectiveProjection.near_clip_plane] --> G[Projection Matrix Calculation]
</span><span>    G --> H[Oblique Clipping via Lengyel Method]
</span><span>    
</span><span>    I[bevy_math::reflection_matrix] --> J[Mirror Camera Transform]
</span><span>    J --> K[Householder Reflection]
</span><span>    
</span><span>    L[Mirror Example] --> M[Complete Mirror System]
</span><span>    M --> N[Off-screen Render Target]
</span><span>    M --> O[Custom Screen-space Shader]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=examples-3d-mirror-rs-677-0><code>examples/3d/mirror.rs</code> (+677/-0)</h3><p>This new example demonstrates a complete mirror implementation. It shows how to set up a mirror camera with inverted culling and oblique projection, create an off-screen render target, and use a custom material to display the reflection.<p>Key code showing mirror camera setup:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Spawn the mirror camera with inverted culling
</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>    Camera3d</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>,
</span><span>    Camera {
</span><span>        order</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>        target</span><span style=color:#61676ccc>:</span><span> mirror_render_target</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>,
</span><span>        invert_culling</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    mirror_camera_transform</span><span style=color:#61676ccc>,
</span><span>    Projection</span><span style=color:#ed9366>::</span><span>Perspective(mirror_camera_projection)</span><span style=color:#61676ccc>,
</span><span>    MirrorCamera</span><span style=color:#61676ccc>,
</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-camera-src-projection-rs-106-4><code>crates/bevy_camera/src/projection.rs</code> (+106/-4)</h3><p>Adds oblique clipping support to <code>PerspectiveProjection</code>. The <code>near_clip_plane</code> field allows specifying a custom clipping plane, and the <code>adjust_perspective_matrix_for_clip_plane</code> method implements Lengyel’s algorithm.<p>Key code implementing oblique clipping:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>adjust_perspective_matrix_for_clip_plane</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>matrix</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Mat4) {
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>near_clip_plane </span><span style=color:#ed9366>== </span><span style=color:#f07171>vec4</span><span>(</span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1.0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>-</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>near) {
</span><span>        </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let</span><span> c </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>near_clip_plane</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> q_prime </span><span style=color:#ed9366>= </span><span style=color:#f07171>vec4</span><span>(c</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#ed9366>.</span><span style=color:#f07171>signum</span><span>()</span><span style=color:#61676ccc>,</span><span> c</span><span style=color:#ed9366>.</span><span>y</span><span style=color:#ed9366>.</span><span style=color:#f07171>signum</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1.0</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> q </span><span style=color:#ed9366>=</span><span> matrix</span><span style=color:#ed9366>.</span><span style=color:#f07171>inverse</span><span>() </span><span style=color:#ed9366>*</span><span> q_prime</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> a </span><span style=color:#ed9366>= -</span><span>q</span><span style=color:#ed9366>.</span><span>z </span><span style=color:#ed9366>/</span><span> c</span><span style=color:#ed9366>.</span><span style=color:#f07171>dot</span><span>(q)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> m3_prime </span><span style=color:#ed9366>= </span><span>Vec4</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>NEG_Z </span><span style=color:#ed9366>-</span><span> c </span><span style=color:#ed9366>*</span><span> a</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    matrix</span><span style=color:#ed9366>.</span><span>x_axis</span><span style=color:#ed9366>.</span><span>z </span><span style=color:#ed9366>=</span><span> m3_prime</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>;
</span><span>    matrix</span><span style=color:#ed9366>.</span><span>y_axis</span><span style=color:#ed9366>.</span><span>z </span><span style=color:#ed9366>=</span><span> m3_prime</span><span style=color:#ed9366>.</span><span>y</span><span style=color:#61676ccc>;
</span><span>    matrix</span><span style=color:#ed9366>.</span><span>z_axis</span><span style=color:#ed9366>.</span><span>z </span><span style=color:#ed9366>=</span><span> m3_prime</span><span style=color:#ed9366>.</span><span>z</span><span style=color:#61676ccc>;
</span><span>    matrix</span><span style=color:#ed9366>.</span><span>w_axis</span><span style=color:#ed9366>.</span><span>z </span><span style=color:#ed9366>=</span><span> m3_prime</span><span style=color:#ed9366>.</span><span>w</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=assets-shaders-screen-space-texture-material-wgsl-37-0><code>assets/shaders/screen_space_texture_material.wgsl</code> (+37/-0)</h3><p>A custom shader for the mirror material that samples its emissive texture at screen-space coordinates rather than UV coordinates.<p>Key shader code:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>@</span><span>fragment
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fragment</span><span>(</span><span style=color:#ff8f40>in</span><span style=color:#61676ccc>:</span><span> VertexOutput, @builtin(</span><span style=color:#ff8f40>front_facing</span><span>) </span><span style=color:#ff8f40>is_front</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>) </span><span style=color:#61676ccc>-></span><span> FragmentOutput {
</span><span>    var pbr_input </span><span style=color:#ed9366>= </span><span style=color:#f07171>pbr_input_from_standard_material</span><span>(</span><span style=color:#ed9366>in</span><span style=color:#61676ccc>,</span><span> is_front)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Use zero alpha to avoid multiplying the emissive by the view exposure.
</span><span>    pbr_input</span><span style=color:#ed9366>.</span><span>material</span><span style=color:#ed9366>.</span><span>emissive </span><span style=color:#ed9366>= </span><span style=color:#f07171>vec4</span><span>(
</span><span>        textureLoad(emissive_texture</span><span style=color:#61676ccc>, </span><span>vec2<</span><span style=color:#fa6e32>i32</span><span>>(</span><span style=color:#f07171>floor</span><span>(</span><span style=color:#ed9366>in.</span><span>position</span><span style=color:#ed9366>.</span><span>xy))</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#ed9366>.</span><span>rgb</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ff8f40>0.0
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    var out</span><span style=color:#61676ccc>:</span><span> FragmentOutput</span><span style=color:#61676ccc>;
</span><span>    out</span><span style=color:#ed9366>.</span><span>color </span><span style=color:#ed9366>= </span><span style=color:#f07171>apply_pbr_lighting</span><span>(pbr_input)</span><span style=color:#61676ccc>;
</span><span>    out</span><span style=color:#ed9366>.</span><span>color </span><span style=color:#ed9366>= </span><span style=color:#f07171>main_pass_post_lighting_processing</span><span>(pbr_input</span><span style=color:#61676ccc>,</span><span> out</span><span style=color:#ed9366>.</span><span>color)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return</span><span> out</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-math-src-mat3-rs-30-0><code>crates/bevy_math/src/mat3.rs</code> (+30/-0)</h3><p>Adds the <code>reflection_matrix</code> utility function for generating Householder reflection matrices.<p>Key implementation:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>reflection_matrix</span><span>(</span><span style=color:#ff8f40>plane_normal</span><span style=color:#61676ccc>:</span><span> Vec3) </span><span style=color:#61676ccc>-></span><span> Mat3A {
</span><span>    </span><span style=color:#fa6e32>let</span><span> n_nt </span><span style=color:#ed9366>= </span><span>Mat3A</span><span style=color:#ed9366>::</span><span>from_cols(
</span><span>        Vec3A</span><span style=color:#ed9366>::</span><span>from(plane_normal) </span><span style=color:#ed9366>*</span><span> plane_normal</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>,
</span><span>        Vec3A</span><span style=color:#ed9366>::</span><span>from(plane_normal) </span><span style=color:#ed9366>*</span><span> plane_normal</span><span style=color:#ed9366>.</span><span>y</span><span style=color:#61676ccc>,
</span><span>        Vec3A</span><span style=color:#ed9366>::</span><span>from(plane_normal) </span><span style=color:#ed9366>*</span><span> plane_normal</span><span style=color:#ed9366>.</span><span>z</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    Mat3A</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>IDENTITY </span><span style=color:#ed9366>-</span><span> n_nt </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>2.0
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-pbr-material-rs-13-9><code>crates/bevy_pbr/src/pbr_material.rs</code> (+13/-9)</h3><p>Updates material specialization to handle inverted culling based on the <code>MeshPipelineKey::INVERT_CULLING</code> flag.<p>Key logic for culling inversion:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>descriptor</span><span style=color:#ed9366>.</span><span>primitive</span><span style=color:#ed9366>.</span><span>cull_mode </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match </span><span>(
</span><span>    key</span><span style=color:#ed9366>.</span><span>bind_group_data</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(StandardMaterialKey</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>CULL_FRONT</span><span>)</span><span style=color:#61676ccc>,
</span><span>    key</span><span style=color:#ed9366>.</span><span>bind_group_data</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(StandardMaterialKey</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>CULL_BACK</span><span>)</span><span style=color:#61676ccc>,
</span><span>    key</span><span style=color:#ed9366>.</span><span>mesh_key</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(MeshPipelineKey</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>INVERT_CULLING</span><span>)</span><span style=color:#61676ccc>,
</span><span>) {
</span><span>    (</span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span>) </span><span style=color:#ed9366>| </span><span>(</span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span>) </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Face</span><span style=color:#ed9366>::</span><span>Front)</span><span style=color:#61676ccc>,
</span><span>    (</span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span>) </span><span style=color:#ed9366>| </span><span>(</span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>true</span><span>) </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Face</span><span style=color:#ed9366>::</span><span>Back)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>_ => </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://terathon.com/lengyel/Lengyel-Oblique.pdf target=_blank>Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”. Journal of Game Development, 2005</a> - The foundational paper on efficient oblique clipping planes.<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Householder_transformation target=_blank>Householder Transformation on Wikipedia</a> - Mathematical background on reflection matrices.<li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_camera/latest/bevy_camera/ target=_blank>Bevy Camera System Documentation</a> - Understanding Bevy’s camera and projection systems.<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/tree/main/crates/bevy_pbr target=_blank>Bevy PBR Rendering Pipeline</a> - Details on Bevy’s physically-based rendering system and material specialization.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_13797.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>