<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22287 Solari: Fix indirect shadows
        
    </title><meta content="#22287 Solari: Fix indirect shadows" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22287-zh-cn-20251230>中文</a></div></div><div class=pr-content><h1 id=title-solari-fix-indirect-shadows>Title: Solari: Fix indirect shadows</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari: Fix indirect shadows<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22287<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, S-Ready-For-Final-Review, C-Refinement<li><strong>Created</strong>: 2025-12-27T17:48:15Z<li><strong>Merged</strong>: 2025-12-30T01:37:46Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Same series of changes to resampling we did for DI, but now applied to GI.<p>Effectively reverts https://github.com/bevyengine/bevy/pull/21919.<p>The piece I was missing before was that I was applying the visibility test to the reservoir’s radiance, and not the UCW, which was wrong.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This pull request addresses a bug in the Solari global illumination system related to how visibility tests were applied during reservoir resampling. The issue manifested as incorrect indirect shadows, where the visibility test was being applied to the wrong component of the reservoir data structure.<p>The context involves the ReSTIR (Reservoir-based Spatio-Temporal Importance Resampling) GI implementation in Bevy’s Solari system. ReSTIR GI is a real-time global illumination technique that uses reservoir sampling to reuse light paths across space and time. The core challenge is properly handling visibility between sample points when merging reservoirs from different locations.<p>In a previous PR (#21919), changes were made to apply visibility tests during spatial resampling. However, those changes contained a subtle bug: the visibility test was being applied to the reservoir’s radiance rather than the unbiased contribution weight (UCW). This was incorrect because in ReSTIR, the UCW is the component that accumulates the weight of samples, and it’s this weight that needs to be adjusted based on visibility between the current surface and the sample point.<p>The solution approach was to reapply the same pattern used for direct illumination (DI) to global illumination (GI). The key insight was recognizing that the UCW, not the radiance, should be multiplied by the visibility factor. This required restructuring the code to apply the visibility test at the correct point in the resampling pipeline and ensuring it affected the right component.<p>The implementation modifies the <code>spatial_and_shade</code> function in the ReSTIR GI shader. The changes introduce conditional compilation paths for biased vs unbiased resampling. In unbiased resampling mode (more accurate but less stable), the reservoir is stored first, then the UCW is multiplied by the visibility test result. In biased resampling mode (more stable but less accurate), the UCW is multiplied by visibility before storing the reservoir.<p>Additionally, the <code>load_spatial_reservoir</code> function was simplified by removing an incorrect visibility multiplication that was being applied to the spatial reservoir’s radiance. This correction ensures that when loading neighboring reservoirs for spatial reuse, their radiance values remain unchanged - only the weight (UCW) is adjusted based on visibility during the merge operation.<p>The technical insight here is understanding the distinction between biased and unbiased resampling in ReSTIR. Unbiased resampling provides theoretically correct results but can be noisy, while biased resampling trades some accuracy for stability. The visibility test needs to be applied differently in these two modes to maintain their respective guarantees.<p>The impact of this fix is significant for visual quality: indirect shadows now behave correctly, with proper occlusion between surfaces. The fix also aligns the GI implementation with the DI implementation, ensuring consistency across the rendering pipeline. This correction demonstrates the importance of understanding the mathematical foundations of reservoir sampling and the precise role of each component in the data structure.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Spatial Reservoir Loading] --> B[Reservoir Merge]
</span><span>    B --> C{Resampling Mode}
</span><span>    C -->|Unbiased| D[Store Reservoir]
</span><span>    D --> E[Apply Visibility to UCW]
</span><span>    C -->|Biased| F[Apply Visibility to UCW]
</span><span>    F --> G[Store Reservoir]
</span><span>    E --> H[Final Reservoir]
</span><span>    G --> H
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-restir-gi-wgsl-12-5><code>crates/bevy_solari/src/realtime/restir_gi.wgsl</code> (+12/-5)</h3><p>This file contains the WebGPU Shading Language (WGSL) code for the ReSTIR global illumination implementation. The changes fix how visibility tests are applied during reservoir resampling.<p>Key modifications:<ol><li><strong>Restructured spatial_and_shade function</strong>: The function now conditionally applies visibility multiplication based on the resampling mode (biased vs unbiased). This ensures the unbiased contribution weight (UCW) is correctly adjusted for visibility between the current surface and the sample point.</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before (simplified from context):
</span><span>let combined_reservoir = merge_result.merged_reservoir;
</span><span>gi_reservoirs_a[pixel_index] = combined_reservoir;
</span><span>
</span><span>// After:
</span><span>var combined_reservoir = merge_result.merged_reservoir;
</span><span>
</span><span>// More accuracy, less stability
</span><span>#ifndef BIASED_RESAMPLING
</span><span>gi_reservoirs_a[pixel_index] = combined_reservoir;
</span><span>#endif
</span><span>
</span><span>combined_reservoir.unbiased_contribution_weight *= trace_point_visibility(surface.world_position, combined_reservoir.sample_point_world_position);
</span><span>
</span><span>// More stability, less accuracy (shadows extend further out than they should)
</span><span>#ifdef BIASED_RESAMPLING
</span><span>gi_reservoirs_a[pixel_index] = combined_reservoir;
</span><span>#endif
</span></code></pre><ol start=2><li><strong>Fixed load_spatial_reservoir function</strong>: Removed incorrect visibility multiplication that was being applied to the spatial reservoir’s radiance. The visibility test should only affect the UCW during merging, not the radiance of loaded reservoirs.</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>let spatial_pixel_index = spatial_pixel_id.x + spatial_pixel_id.y * u32(view.main_pass_viewport.z);
</span><span>var spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
</span><span>spatial_reservoir.radiance *= trace_point_visibility(world_position, spatial_reservoir.sample_point_world_position);
</span><span>return NeighborInfo(spatial_reservoir, spatial_surface.world_position, spatial_surface.world_normal, spatial_diffuse_brdf);
</span><span>
</span><span>// After:
</span><span>let spatial_pixel_index = spatial_pixel_id.x + spatial_pixel_id.y * u32(view.main_pass_viewport.z);
</span><span>let spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
</span><span>return NeighborInfo(spatial_reservoir, spatial_surface.world_position, spatial_surface.world_normal, spatial_diffuse_brdf);
</span></code></pre><p>These changes ensure that visibility tests are applied consistently and correctly across the ReSTIR GI pipeline, fixing indirect shadow rendering.<h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://research.nvidia.com/publication/2020-07_restir-reservoir-based-spatio-temporal-importance-resampling target=_blank>ReSTIR: Reservoir-based Spatio-Temporal Importance Resampling</a> - The original paper introducing ReSTIR<li><a rel="noopener nofollow noreferrer" href=https://research.nvidia.com/publication/2021-06_restir-gi-path-resampling-real-time-path-tracing target=_blank>ReSTIR GI: Path Resampling for Real-Time Path Tracing</a> - Extension of ReSTIR to global illumination<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/blob/main/crates/bevy_solari/README.md target=_blank>Bevy Solari Documentation</a> - Overview of the Solari rendering system in Bevy<li><a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/WGSL/ target=_blank>WGSL Specification</a> - WebGPU Shading Language reference</ol><h1 id=full-code-diff>Full Code Diff</h1><p>diff –git a/crates/bevy_solari/src/realtime/restir_gi.wgsl b/crates/bevy_solari/src/realtime/restir_gi.wgsl index 88ed44f7e3016..8fc3089da0b33 100644 — a/crates/bevy_solari/src/realtime/restir_gi.wgsl +++ b/crates/bevy_solari/src/realtime/restir_gi.wgsl @@ -67,9 +67,19 @@ fn spatial_and_shade(@builtin(global_invocation_id) global_id: vec3<u32>) { let spatial = load_spatial_reservoir(global_id.xy, depth, surface.world_position, surface.world_normal, &rng); let merge_result = merge_reservoirs(input_reservoir, surface.world_position, surface.world_normal, surface.material.base_color / PI, spatial.reservoir, spatial.world_position, spatial.world_normal, spatial.diffuse_brdf, &rng); <ul><li>let combined_reservoir = merge_result.merged_reservoir;</ul> <ul><li><p>var combined_reservoir = merge_result.merged_reservoir;</p><li><p>// More accuracy, less stability +#ifndef BIASED_RESAMPLING gi_reservoirs_a[pixel_index] = combined_reservoir; +#endif</p><li><li><p>combined_reservoir.unbiased_contribution_weight *= trace_point_visibility(surface.world_position, combined_reservoir.sample_point_world_position);</p><li><li><p>// More stability, less accuracy (shadows extend further out than they should) +#ifdef BIASED_RESAMPLING</p><li><p>gi_reservoirs_a[pixel_index] = combined_reservoir; +#endif</p> <p>let brdf = evaluate_diffuse_brdf(surface.material.base_color, surface.material.metallic);</p></ul> <p>@@ -163,10 +173,7 @@ fn load_spatial_reservoir(pixel_id: vec2<u32>, depth: f32, world_position: vec3< } <pre style=color:#61676c;background-color:#fafafa><code><span>     let spatial_pixel_index = spatial_pixel_id.x + spatial_pixel_id.y * u32(view.main_pass_viewport.z);
</span></code></pre> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   var spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
</span></code></pre><li><li><pre style=color:#61676c;background-color:#fafafa><code><span>   spatial_reservoir.radiance *= trace_point_visibility(world_position, spatial_reservoir.sample_point_world_position);
</span></code></pre><li></ul> <ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   let spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
</span><span>   return NeighborInfo(spatial_reservoir, spatial_surface.world_position, spatial_surface.world_normal, spatial_diffuse_brdf);
</span></code></pre> }</ul>    <div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22287.patch id=patch-info style=display:none></div>  <div class=bottom-spacer></div> 