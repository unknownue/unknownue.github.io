<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22131 GltfExtensionHandler::on_texture: pass Texture references
        
    </title><meta content="#22131 GltfExtensionHandler::on_texture: pass Texture references" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-15</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22131-zh-cn-20251215>中文</a></div></div><div class=pr-content><h1 id=gltfextensionhandler-on-texture-pass-texture-references>GltfExtensionHandler::on_texture: pass Texture references</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: GltfExtensionHandler::on_texture: pass Texture references<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22131<li><strong>Author</strong>: ChristopherBiscardi<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-Assets, S-Ready-For-Final-Review, A-glTF<li><strong>Created</strong>: 2025-12-15T16:53:39Z<li><strong>Merged</strong>: 2025-12-15T21:12:20Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>Objective</strong><p>The extension hooks for <code>on_texture</code> currently pass the extension data and not the glTF object.<p><strong>Solution</strong><p><code>IoTaskPool::scope</code> preserves ordering if the futures are only spawned from the root scope, so we can use that to zip with the texture references for hooks.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This pull request addresses an inconsistency in Bevy’s glTF loading extension system. The <code>GltfExtensionHandler</code> trait provides hooks for different stages of glTF asset loading, but one of these hooks - <code>on_texture</code> - had a different signature than the others. While other hooks receive the actual glTF object reference (like <code>gltf::Node</code>, <code>gltf::Mesh</code>, etc.), the <code>on_texture</code> hook only received the parsed JSON extension data, not the <code>gltf::Texture</code> object itself.<p>The root cause of this inconsistency was a lifetime issue in the asynchronous loading path. When textures are loaded asynchronously, the glTF data (including <code>gltf::Texture</code> references) and the loading tasks need to coexist properly. The original implementation avoided this issue by extracting and cloning just the extension data before spawning async tasks, then passing that cloned data to the extension handlers.<p>The solution leverages a specific property of <code>IoTaskPool::scope</code>: it preserves the order of results when futures are only spawned from the root scope. This allows the implementation to:<ol><li>Spawn async texture loading tasks<li>Collect the results while maintaining their original order<li>Pair each result with its corresponding <code>gltf::Texture</code> reference from the original glTF data using <code>zip(gltf.textures())</code><li>Pass the complete <code>gltf::Texture</code> object to extension handlers instead of just the extension data</ol><p>This change makes the <code>on_texture</code> hook consistent with other hooks in the <code>GltfExtensionHandler</code> trait. Now extension handlers can access the full texture metadata, not just extension-specific data. For example, they can inspect the texture’s source image, sampler settings, or any other properties defined in the glTF specification.<p>The implementation is careful to maintain the same behavior in both synchronous and asynchronous loading paths. In the synchronous path (when images are already loaded), the change is straightforward - just pass the <code>gltf::Texture</code> reference directly. In the asynchronous path, the zipping approach ensures that texture references remain valid and correctly associated with their loaded image data.<p>This fix is particularly important for extensions that need to process texture metadata beyond just extension data. Without access to the full <code>gltf::Texture</code> object, extension handlers were limited in what they could inspect or modify about textures during loading.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[GltfLoader.load_textures] --> B{Synchronous loading?}
</span><span>    B -->|Yes| C[Process immediately]
</span><span>    B -->|No| D[Spawn async tasks via IoTaskPool]
</span><span>    C --> E[Call on_texture with gltf::Texture]
</span><span>    D --> F[Collect ordered results]
</span><span>    F --> G[Zip with gltf.textures]
</span><span>    G --> H[Call on_texture with gltf::Texture]
</span><span>    E --> I[Extension handlers get full texture data]
</span><span>    H --> I
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-gltf-src-loader-extensions-mod-rs-1-8><code>crates/bevy_gltf/src/loader/extensions/mod.rs</code> (+1/-8)</h3><p>This file contains the <code>GltfExtensionHandler</code> trait definition. The change modifies the <code>on_texture</code> method signature to accept a <code>gltf::Texture</code> reference instead of raw extension data.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_texture</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>extension_data</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>serde_json</span><span style=color:#ed9366>::</span><span>Map<</span><span style=color:#55b4d4;font-style:italic>String</span><span>, serde_json</span><span style=color:#ed9366>::</span><span>Value>>,
</span><span>    </span><span style=color:#ff8f40>texture</span><span style=color:#61676ccc>: </span><span>Handle&LTbevy_image</span><span style=color:#ed9366>::</span><span>Image>,
</span><span>) {
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_texture</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>gltf_texture</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Texture, </span><span style=color:#ff8f40>texture</span><span style=color:#61676ccc>: </span><span>Handle&LTbevy_image</span><span style=color:#ed9366>::</span><span>Image>) {}
</span></code></pre><p>The key changes:<ul><li>Removed the <code>extension_data</code> parameter (which was optional JSON data)<li>Added <code>gltf_texture: &gltf::Texture</code> parameter<li>Removed the comment explaining why the glTF object wasn’t passed due to “internal constraints”<li>The method now provides the full texture object, giving extension handlers access to all texture metadata</ul><h3 id=crates-bevy-gltf-src-loader-mod-rs-7-15><code>crates/bevy_gltf/src/loader/mod.rs</code> (+7/-15)</h3><p>This file contains the main glTF loading logic. The changes ensure both synchronous and asynchronous loading paths pass the <code>gltf::Texture</code> object to extension handlers.<p><strong>Synchronous path changes:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>    extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_texture</span><span>(
</span><span>        texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>extensions</span><span>()</span><span style=color:#61676ccc>,
</span><span>        texture_handles</span><span style=color:#ed9366>.</span><span style=color:#f07171>last</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>    extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_texture</span><span>(</span><span style=color:#ed9366>&</span><span>texture</span><span style=color:#61676ccc>,</span><span> texture_handles</span><span style=color:#ed9366>.</span><span style=color:#f07171>last</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><strong>Asynchronous path changes (key logic):</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before the PR, extension data was captured and passed separately:
</span><span style=color:#fa6e32>let</span><span> extension_data </span><span style=color:#ed9366>=</span><span> gltf_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>extensions</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(</span><span style=color:#55b4d4;font-style:italic>ToOwned</span><span style=color:#ed9366>::</span><span>to_owned)</span><span style=color:#61676ccc>;
</span><span>scope</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async </span><span style=color:#fa6e32>move </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> result </span><span style=color:#ed9366>= </span><span style=color:#f07171>load_image</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>    (extension_data</span><span style=color:#61676ccc>,</span><span> result)
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Results were processed with extension data:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>for_each</span><span>(|(</span><span style=color:#ff8f40>extension_data</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>result</span><span>)| </span><span style=color:#fa6e32>match</span><span> result {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>        extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_texture</span><span>(
</span><span>            extension_data</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>()</span><span style=color:#61676ccc>,
</span><span>            texture_handles</span><span style=color:#ed9366>.</span><span style=color:#f07171>last</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>,
</span><span>        )</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After the PR, tasks only return the load result:
</span><span>scope</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async </span><span style=color:#fa6e32>move </span><span>{
</span><span>    </span><span style=color:#f07171>load_image</span><span>(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#ed9366>.</span><span>await  </span><span style=color:#abb0b6;font-style:italic>// No extension data captured
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Results are zipped with original glTF textures:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>zip</span><span>(gltf</span><span style=color:#ed9366>.</span><span style=color:#f07171>textures</span><span>())
</span><span style=color:#ed9366>.</span><span style=color:#f07171>for_each</span><span>(|(</span><span style=color:#ff8f40>result</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>texture</span><span>)| </span><span style=color:#fa6e32>match</span><span> result {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>        extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_texture</span><span>(</span><span style=color:#ed9366>&</span><span>texture</span><span style=color:#61676ccc>,</span><span> texture_handles</span><span style=color:#ed9366>.</span><span style=color:#f07171>last</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p>The critical insight is that <code>IoTaskPool::scope</code> preserves task completion order when tasks are spawned from the root scope. This allows the code to:<ol><li>Spawn tasks in the order of <code>gltf.textures()</code><li>Collect results in the same order<li>Use <code>zip(gltf.textures())</code> to pair each result with its corresponding original texture<li>Pass the complete <code>gltf::Texture</code> object to extension handlers</ol><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/main/specification/2.0#textures target=_blank>glTF 2.0 Specification - Textures</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy/latest/bevy/asset/index.html target=_blank>Bevy Asset System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/ target=_blank>Rust Async Programming</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy/latest/bevy/tasks/struct.IoTaskPool.html target=_blank>IoTaskPool in Bevy</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/main/extensions target=_blank>glTF Extension Mechanism</a></ul><h1 id=full-code-diff>Full Code Diff</h1><details><summary>Click to expand full diff</summary> <pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_gltf/src/loader/extensions/mod.rs b/crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span>index d024f39175c94..370b767f723b1 100644
</span><span style=color:#c594c5>--- a/crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span style=color:#c594c5>@@ -99,18 +99,11 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     }
</span><span> 
</span><span>     /// Called when an individual texture is processed
</span><span style=color:#f07171>-    /// Unlike other hooks, this hook does not receive its glTF
</span><span style=color:#f07171>-    /// object due to internal constraints.
</span><span>     #[expect(
</span><span>         unused,
</span><span>         reason = "default trait implementations do not use the arguments because they are no-ops"
</span><span>     )]
</span><span style=color:#f07171>-    fn on_texture(
</span><span style=color:#f07171>-        &mut self,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Map&LTString, serde_json::Value>>,
</span><span style=color:#f07171>-        texture: Handle&LTbevy_image::Image>,
</span><span style=color:#f07171>-    ) {
</span><span style=color:#f07171>-    }
</span><span style=color:#86b300>+    fn on_texture(&mut self, gltf_texture: &gltf::Texture, texture: Handle&LTbevy_image::Image>) {}
</span><span> 
</span><span>     /// Called when an individual material is processed
</span><span>     #[expect(
</span><span>diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
</span><span>index 68e5eb41dc69d..d18324a3ba9b0 100644
</span><span style=color:#c594c5>--- a/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>@@ -644,10 +644,7 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>                 image.process_loaded_texture(load_context, &mut texture_handles);
</span><span>                 // let extensions handle texture data
</span><span>                 for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                    extension.on_texture(
</span><span style=color:#f07171>-                        texture.extensions(),
</span><span style=color:#f07171>-                        texture_handles.last().unwrap().clone(),
</span><span style=color:#f07171>-                    );
</span><span style=color:#86b300>+                    extension.on_texture(&texture, texture_handles.last().unwrap().clone());
</span><span>                 }
</span><span>             }
</span><span>         } else {
</span><span style=color:#c594c5>@@ -658,9 +655,8 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>                         let asset_path = load_context.path().clone();
</span><span>                         let linear_textures = &linear_textures;
</span><span>                         let buffer_data = &buffer_data;
</span><span style=color:#f07171>-                        let extension_data = gltf_texture.extensions().map(ToOwned::to_owned);
</span><span>                         scope.spawn(async move {
</span><span style=color:#f07171>-                            let result = load_image(
</span><span style=color:#86b300>+                            load_image(
</span><span>                                 gltf_texture,
</span><span>                                 buffer_data,
</span><span>                                 linear_textures,
</span><span style=color:#c594c5>@@ -669,23 +665,19 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>                                 default_sampler,
</span><span>                                 settings,
</span><span>                             )
</span><span style=color:#f07171>-                            .await;
</span><span style=color:#f07171>-                            (extension_data, result)
</span><span style=color:#86b300>+                            .await
</span><span>                         });
</span><span>                     });
</span><span>                 })
</span><span>                 .into_iter()
</span><span style=color:#f07171>-                .for_each(|(extension_data, result)| match result {
</span><span style=color:#86b300>+                // order is preserved if the futures are only spawned from the root scope
</span><span style=color:#86b300>+                .zip(gltf.textures())
</span><span style=color:#86b300>+                .for_each(|(result, texture)| match result {
</span><span>                     Ok(image) => {
</span><span>                         image.process_loaded_texture(load_context, &mut texture_handles);
</span><span>                         // let extensions handle texture data
</span><span style=color:#f07171>-                        // We do this differently here because of the IoTaskPool vs
</span><span style=color:#f07171>-                        // gltf::Texture lifetimes
</span><span>                         for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                            extension.on_texture(
</span><span style=color:#f07171>-                                extension_data.as_ref(),
</span><span style=color:#f07171>-                                texture_handles.last().unwrap().clone(),
</span><span style=color:#f07171>-                            );
</span><span style=color:#86b300>+                            extension.on_texture(&texture, texture_handles.last().unwrap().clone());
</span><span>                         }
</span><span>                     }
</span><span>                     Err(err) => {
</span></code></pre></details></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22131.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>