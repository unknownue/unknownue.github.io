diff --git a/Cargo.toml b/Cargo.toml
index d039936d83779..585c8b6589390 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -3480,6 +3480,18 @@ description = "Illustrates how to access `winit::window::Window`'s `hittest` fun
 category = "UI (User Interface)"
 wasm = false
 
+[[example]]
+name = "vertical_slider"
+path = "examples/ui/vertical_slider.rs"
+doc-scrape-examples = true
+required-features = ["experimental_bevy_ui_widgets"]
+
+[package.metadata.example.vertical_slider]
+name = "Vertical Slider"
+description = "Simple example showing vertical and horizontal slider widgets with snap behavior and value labels"
+category = "UI (User Interface)"
+wasm = true
+
 [[example]]
 name = "font_atlas_debug"
 path = "examples/ui/font_atlas_debug.rs"
diff --git a/crates/bevy_ui_widgets/src/slider.rs b/crates/bevy_ui_widgets/src/slider.rs
index d19e344b29e4e..453aaa12e65ed 100644
--- a/crates/bevy_ui_widgets/src/slider.rs
+++ b/crates/bevy_ui_widgets/src/slider.rs
@@ -264,22 +264,49 @@ pub(crate) fn slider_on_pointer_down(
             return;
         }
 
+        // Detect orientation: vertical if height > width
+        let is_vertical = node.size().y > node.size().x;
+
         // Find thumb size by searching descendants for the first entity with SliderThumb
         let thumb_size = q_children
             .iter_descendants(press.entity)
-            .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
+            .find_map(|child_id| {
+                q_thumb.get(child_id).ok().map(|thumb| {
+                    if is_vertical {
+                        thumb.size().y
+                    } else {
+                        thumb.size().x
+                    }
+                })
+            })
             .unwrap_or(0.0);
 
         // Detect track click.
         let local_pos = transform.try_inverse().unwrap().transform_point2(
             press.pointer_location.position * node_target.scale_factor() / ui_scale.0,
         );
-        let track_width = node.size().x - thumb_size;
+        let track_size = if is_vertical {
+            node.size().y - thumb_size
+        } else {
+            node.size().x - thumb_size
+        };
+
         // Avoid division by zero
-        let click_val = if track_width > 0. {
-            local_pos.x * range.span() / track_width + range.center()
+        let click_val = if track_size > 0. {
+            if is_vertical {
+                // For vertical sliders: bottom-to-top (0 at bottom, max at top)
+                // local_pos.y ranges from -height/2 (top) to +height/2 (bottom)
+                let y_from_bottom = (node.size().y / 2.0) - local_pos.y;
+                let adjusted_y = y_from_bottom - thumb_size / 2.0;
+                adjusted_y * range.span() / track_size + range.start()
+            } else {
+                // For horizontal sliders: convert from center-origin to left-origin
+                let x_from_left = local_pos.x + node.size().x / 2.0;
+                let adjusted_x = x_from_left - thumb_size / 2.0;
+                adjusted_x * range.span() / track_size + range.start()
+            }
         } else {
-            0.
+            range.center()
         };
 
         // Compute new value from click position
@@ -330,7 +357,6 @@ pub(crate) fn slider_on_drag(
     mut event: On<Pointer<Drag>>,
     mut q_slider: Query<
         (
-            &SliderValue,
             &ComputedNode,
             &SliderRange,
             Option<&SliderPrecision>,
@@ -345,23 +371,42 @@ pub(crate) fn slider_on_drag(
     mut commands: Commands,
     ui_scale: Res<UiScale>,
 ) {
-    if let Ok((value, node, range, precision, transform, drag, disabled)) =
-        q_slider.get_mut(event.entity)
+    if let Ok((node, range, precision, transform, drag, disabled)) = q_slider.get_mut(event.entity)
     {
         event.propagate(false);
         if drag.dragging && !disabled {
+            // Detect orientation: vertical if height > width
+            let is_vertical = node.size().y > node.size().x;
+
             let mut distance = event.distance / ui_scale.0;
             distance.y *= -1.;
             let distance = transform.transform_vector2(distance);
+
             // Find thumb size by searching descendants for the first entity with SliderThumb
             let thumb_size = q_children
                 .iter_descendants(event.entity)
-                .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
+                .find_map(|child_id| {
+                    q_thumb.get(child_id).ok().map(|thumb| {
+                        if is_vertical {
+                            thumb.size().y
+                        } else {
+                            thumb.size().x
+                        }
+                    })
+                })
                 .unwrap_or(0.0);
-            let slider_width = ((node.size().x - thumb_size) * node.inverse_scale_factor).max(1.0);
+
+            let slider_size = if is_vertical {
+                ((node.size().y - thumb_size) * node.inverse_scale_factor).max(1.0)
+            } else {
+                ((node.size().x - thumb_size) * node.inverse_scale_factor).max(1.0)
+            };
+
+            let drag_distance = if is_vertical { distance.y } else { distance.x };
+
             let span = range.span();
             let new_value = if span > 0. {
-                drag.offset + (distance.x * span) / slider_width
+                drag.offset + (drag_distance * span) / slider_size
             } else {
                 range.start() + span * 0.5
             };
@@ -371,12 +416,10 @@ pub(crate) fn slider_on_drag(
                     .unwrap_or(new_value),
             );
 
-            if rounded_value != value.0 {
-                commands.trigger(ValueChange {
-                    source: event.entity,
-                    value: rounded_value,
-                });
-            }
+            commands.trigger(ValueChange {
+                source: event.entity,
+                value: rounded_value,
+            });
         }
     }
 }
diff --git a/examples/README.md b/examples/README.md
index 440c54d0c2bdb..c87f765fa3a2c 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -594,6 +594,7 @@ Example | Description
 [UI Texture Slice Flipping and Tiling](../examples/ui/ui_texture_slice_flip_and_tile.rs) | Illustrates how to flip and tile images with 9 Slicing in UI
 [UI Transform](../examples/ui/ui_transform.rs) | An example demonstrating how to translate, rotate and scale UI elements.
 [UI Z-Index](../examples/ui/z_index.rs) | Demonstrates how to control the relative depth (z-position) of UI elements
+[Vertical Slider](../examples/ui/vertical_slider.rs) | Simple example showing vertical and horizontal slider widgets with snap behavior and value labels
 [Viewport Debug](../examples/ui/viewport_debug.rs) | An example for debugging viewport coordinates
 [Viewport Node](../examples/ui/viewport_node.rs) | Demonstrates how to create a viewport node with picking support
 [Virtual Keyboard](../examples/ui/virtual_keyboard.rs) | Example demonstrating a virtual keyboard widget
diff --git a/examples/ui/vertical_slider.rs b/examples/ui/vertical_slider.rs
new file mode 100644
index 0000000000000..66dcccbad229c
--- /dev/null
+++ b/examples/ui/vertical_slider.rs
@@ -0,0 +1,313 @@
+//! Simple example showing vertical and horizontal slider widgets with snap behavior and value labels
+
+use bevy::{
+    input_focus::{
+        tab_navigation::{TabGroup, TabIndex, TabNavigationPlugin},
+        InputDispatchPlugin,
+    },
+    picking::hover::Hovered,
+    prelude::*,
+    ui_widgets::{
+        observe, slider_self_update, CoreSliderDragState, Slider, SliderRange, SliderThumb,
+        SliderValue, TrackClick, UiWidgetsPlugins,
+    },
+};
+
+const SLIDER_TRACK: Color = Color::srgb(0.05, 0.05, 0.05);
+const SLIDER_THUMB: Color = Color::srgb(0.35, 0.75, 0.35);
+
+fn main() {
+    App::new()
+        .add_plugins((
+            DefaultPlugins,
+            UiWidgetsPlugins,
+            InputDispatchPlugin,
+            TabNavigationPlugin,
+        ))
+        .add_systems(Startup, setup)
+        .add_systems(Update, (update_slider_visuals, update_value_labels))
+        .run();
+}
+
+#[derive(Component)]
+struct ValueLabel(Entity);
+
+#[derive(Component)]
+struct DemoSlider;
+
+#[derive(Component)]
+struct DemoSliderThumb;
+
+#[derive(Component)]
+struct VerticalSlider;
+
+fn setup(mut commands: Commands, assets: Res<AssetServer>) {
+    commands.spawn(Camera2d);
+
+    commands
+        .spawn((
+            Node {
+                width: percent(100),
+                height: percent(100),
+                align_items: AlignItems::Center,
+                justify_content: JustifyContent::Center,
+                display: Display::Flex,
+                flex_direction: FlexDirection::Row,
+                column_gap: px(50),
+                ..default()
+            },
+            TabGroup::default(),
+        ))
+        .with_children(|parent| {
+            // Vertical slider
+            parent
+                .spawn(Node {
+                    display: Display::Flex,
+                    flex_direction: FlexDirection::Column,
+                    align_items: AlignItems::Center,
+                    row_gap: px(10),
+                    ..default()
+                })
+                .with_children(|parent| {
+                    parent.spawn((
+                        Text::new("Vertical"),
+                        TextFont {
+                            font: assets.load("fonts/FiraSans-Bold.ttf"),
+                            font_size: 20.0,
+                            ..default()
+                        },
+                        TextColor(Color::srgb(0.9, 0.9, 0.9)),
+                    ));
+
+                    let label_id = parent
+                        .spawn((
+                            Text::new("50"),
+                            TextFont {
+                                font: assets.load("fonts/FiraSans-Bold.ttf"),
+                                font_size: 24.0,
+                                ..default()
+                            },
+                            TextColor(Color::srgb(0.9, 0.9, 0.9)),
+                        ))
+                        .id();
+
+                    parent.spawn((
+                        vertical_slider(),
+                        ValueLabel(label_id),
+                        observe(slider_self_update),
+                    ));
+                });
+
+            // Horizontal slider
+            parent
+                .spawn(Node {
+                    display: Display::Flex,
+                    flex_direction: FlexDirection::Column,
+                    align_items: AlignItems::Center,
+                    row_gap: px(10),
+                    ..default()
+                })
+                .with_children(|parent| {
+                    parent.spawn((
+                        Text::new("Horizontal"),
+                        TextFont {
+                            font: assets.load("fonts/FiraSans-Bold.ttf"),
+                            font_size: 20.0,
+                            ..default()
+                        },
+                        TextColor(Color::srgb(0.9, 0.9, 0.9)),
+                    ));
+
+                    let label_id = parent
+                        .spawn((
+                            Text::new("50"),
+                            TextFont {
+                                font: assets.load("fonts/FiraSans-Bold.ttf"),
+                                font_size: 24.0,
+                                ..default()
+                            },
+                            TextColor(Color::srgb(0.9, 0.9, 0.9)),
+                        ))
+                        .id();
+
+                    parent.spawn((
+                        horizontal_slider(),
+                        ValueLabel(label_id),
+                        observe(slider_self_update),
+                    ));
+                });
+        });
+}
+
+fn vertical_slider() -> impl Bundle {
+    (
+        Node {
+            display: Display::Flex,
+            flex_direction: FlexDirection::Row,
+            justify_content: JustifyContent::Center,
+            align_items: AlignItems::Stretch,
+            column_gap: px(4),
+            width: px(12),
+            height: px(200),
+            ..default()
+        },
+        DemoSlider,
+        VerticalSlider,
+        Hovered::default(),
+        Slider {
+            track_click: TrackClick::Snap,
+        },
+        SliderValue(50.0),
+        SliderRange::new(0.0, 100.0),
+        TabIndex(0),
+        Children::spawn((
+            Spawn((
+                Node {
+                    width: px(6),
+                    border_radius: BorderRadius::all(px(3)),
+                    ..default()
+                },
+                BackgroundColor(SLIDER_TRACK),
+            )),
+            Spawn((
+                Node {
+                    display: Display::Flex,
+                    position_type: PositionType::Absolute,
+                    top: px(12),
+                    bottom: px(0),
+                    left: px(0),
+                    right: px(0),
+                    ..default()
+                },
+                children![(
+                    DemoSliderThumb,
+                    SliderThumb,
+                    Node {
+                        display: Display::Flex,
+                        width: px(12),
+                        height: px(12),
+                        position_type: PositionType::Absolute,
+                        bottom: percent(0),
+                        border_radius: BorderRadius::MAX,
+                        ..default()
+                    },
+                    BackgroundColor(SLIDER_THUMB),
+                )],
+            )),
+        )),
+    )
+}
+
+fn horizontal_slider() -> impl Bundle {
+    (
+        Node {
+            display: Display::Flex,
+            flex_direction: FlexDirection::Column,
+            justify_content: JustifyContent::Center,
+            align_items: AlignItems::Stretch,
+            column_gap: px(4),
+            height: px(12),
+            width: px(200),
+            ..default()
+        },
+        DemoSlider,
+        Hovered::default(),
+        Slider {
+            track_click: TrackClick::Snap,
+        },
+        SliderValue(50.0),
+        SliderRange::new(0.0, 100.0),
+        TabIndex(0),
+        Children::spawn((
+            Spawn((
+                Node {
+                    height: px(6),
+                    border_radius: BorderRadius::all(px(3)),
+                    ..default()
+                },
+                BackgroundColor(SLIDER_TRACK),
+            )),
+            Spawn((
+                Node {
+                    display: Display::Flex,
+                    position_type: PositionType::Absolute,
+                    left: px(0),
+                    right: px(12),
+                    top: px(0),
+                    bottom: px(0),
+                    ..default()
+                },
+                children![(
+                    DemoSliderThumb,
+                    SliderThumb,
+                    Node {
+                        display: Display::Flex,
+                        width: px(12),
+                        height: px(12),
+                        position_type: PositionType::Absolute,
+                        left: percent(0),
+                        border_radius: BorderRadius::MAX,
+                        ..default()
+                    },
+                    BackgroundColor(SLIDER_THUMB),
+                )],
+            )),
+        )),
+    )
+}
+
+fn update_slider_visuals(
+    sliders: Query<
+        (
+            Entity,
+            &SliderValue,
+            &SliderRange,
+            &Hovered,
+            &CoreSliderDragState,
+            Has<VerticalSlider>,
+        ),
+        (
+            Or<(
+                Changed<SliderValue>,
+                Changed<Hovered>,
+                Changed<CoreSliderDragState>,
+            )>,
+            With<DemoSlider>,
+        ),
+    >,
+    children: Query<&Children>,
+    mut thumbs: Query<(&mut Node, &mut BackgroundColor, Has<DemoSliderThumb>), Without<DemoSlider>>,
+) {
+    for (slider_ent, value, range, hovered, drag_state, is_vertical) in sliders.iter() {
+        for child in children.iter_descendants(slider_ent) {
+            if let Ok((mut thumb_node, mut thumb_bg, is_thumb)) = thumbs.get_mut(child)
+                && is_thumb
+            {
+                let position = range.thumb_position(value.0) * 100.0;
+                if is_vertical {
+                    thumb_node.bottom = percent(position);
+                } else {
+                    thumb_node.left = percent(position);
+                }
+
+                let is_active = hovered.0 | drag_state.dragging;
+                thumb_bg.0 = if is_active {
+                    SLIDER_THUMB.lighter(0.3)
+                } else {
+                    SLIDER_THUMB
+                };
+            }
+        }
+    }
+}
+
+fn update_value_labels(
+    sliders: Query<(&SliderValue, &ValueLabel), (Changed<SliderValue>, With<DemoSlider>)>,
+    mut texts: Query<&mut Text>,
+) {
+    for (value, label) in sliders.iter() {
+        if let Ok(mut text) = texts.get_mut(label.0) {
+            **text = format!("{:.0}", value.0);
+        }
+    }
+}
