<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22039 Add support for normal maps, metallic-roughness maps, and emissive maps to clustered decals.
        
    </title><meta content="#22039 Add support for normal maps, metallic-roughness maps, and emissive maps to clustered decals." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-09</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22039-zh-cn-20251209>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add support for normal maps, metallic-roughness maps, and emissive maps to clustered decals.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22039<li><strong>Author</strong>: pcwalton<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, M-Release-Note<li><strong>Created</strong>: 2025-12-05T18:14:03Z<li><strong>Merged</strong>: 2025-12-09T18:40:55Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>This commit expands the number of textures associated with each clustered decal from 1 to 4. The additional 3 textures apply normal maps, metallic-roughness maps, and emissive maps respectively to the surfaces onto which decals are projected.<p>Normal maps are combined using the [<em>Whiteout</em> blending method] from SIGGRAPH 2007. This approach was chosen because, subjectively, it appeared better than the more complex [<em>reoriented normal mapping</em> (RNM)] approach. Additionally, <em>Whiteout</em> normal map blending is commutative and associative, unlike RNM, which is a useful property for our decals, which are currently applied in an unspecified order. (The fact that the order in which our decals are applied is unspecified is unfortunate, but is a long-standing issue and should probably be fixed in a followup.) In particular, commutativity is desirable because otherwise one must specify which normal map is the <em>base</em> normal map and which normal map is the <em>detail</em> normal map, but that’s not a policy decision that Bevy can unconditionally make, as decals aren’t necessary more detailed than the base normal map. (For instance, consider a bullet hole decal embedded in a wall with a subtle rough texture; one might reasonably argue that the base material’s normal map is the detail map and the bullet hole is the base map, even though the bullet hole’s normal map comes from a decal.)<p>Note that, with a custom material shader, it’s possible for application code to use the decal images for arbitrary other purposes. For example, with a custom shader an application might use the metallic-roughness map as a clearcoat map instead if it has no need for a metallic-roughness map on a decal. And, of course, a custom material shader could adopt RNM blending for decals if it wishes.<p>A new example, <code>clustered_decal_maps</code>, has been added. This example demonstrates the new maps by spawning clustered decals with maps randomly over time and projecting them onto a wall.</p><img alt="Screenshot 2025-12-05 095953" height=1500 src=https://github.com/user-attachments/assets/255fca64-2b42-4794-a367-14336d023310 width=2564><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The PR addresses a limitation in Bevy’s clustered decals system, which previously supported only a single base color texture. This constrained the visual complexity that could be achieved with decals. In practice, realistic surface details often require modifying surface normals (for depth and detail), material properties (like metallic and roughness), and even emissive properties (for glowing effects).<p>The core problem was straightforward: clustered decals needed to support more texture types to match the capabilities of modern PBR materials. However, the implementation required careful consideration of several technical aspects. The <code>ClusteredDecal</code> component was redesigned from having a single required <code>image</code> field to having four optional texture handles: <code>base_color_texture</code>, <code>normal_map_texture</code>, <code>metallic_roughness_texture</code>, and <code>emissive_texture</code>. This approach maintains backward compatibility through the <code>Default</code> trait and allows users to specify only the textures they need.<p>A key decision involved normal map blending. The developer considered two approaches: reoriented normal mapping (RNM) and the Whiteout method. RNM, while more sophisticated, is neither commutative nor associative, which presents problems because Bevy’s decals are applied in an unspecified order. The Whiteout method, despite being simpler, offers both commutativity and associativity, making it more suitable for a system where multiple decals can overlap unpredictably. This property ensures consistent results regardless of application order, which is critical when the rendering engine doesn’t guarantee a specific ordering.<p>The implementation required changes across multiple layers of the rendering system. The extract phase in <code>clustered.rs</code> was restructured to handle arrays of optional texture IDs, converting them to indices in the bindless texture array (or <code>-1</code> to indicate no texture). The shader code in <code>clustered.wgsl</code> saw the most significant changes, with the <code>ClusteredDecalIterator</code> expanding from a single <code>texture_index</code> to four separate indices. A new <code>apply_decals</code> function replaced the old <code>apply_decal_base_color</code>, performing comprehensive PBR material modifications.<p>Shader changes were carefully designed to maintain performance. Texture sampling occurs only for slots with valid indices (checked via <code>>= 0</code> conditions). The normal map blending uses the Whiteout formula: <code>Nt = vec3(Nt.xy + Nd.xy, Nt.z * Nd.z)</code>. Metallic and roughness values are blended using the base color’s alpha channel as the blend factor, following the Porter-Duff OVER operator logic. Emissive values are additively combined.<p>The PR also introduced a new example, <code>clustered_decal_maps</code>, which demonstrates the feature by spawning animated decals onto a textured plane. This example not only shows the visual results but also provides a reference implementation for users. The example loads specialized textures from a remote repository, including normal maps and metallic-roughness maps in non-sRGB color space, demonstrating proper asset configuration.<p>From an architectural perspective, this change enhances the clustered decals system to be more feature-complete while maintaining flexibility. The use of optional textures allows for efficient memory usage, and the clear separation of concerns between the Rust systems and WGSL shader code maintains Bevy’s modular design. The implementation also properly handles edge cases, such as ensuring at least one texture exists in the binding array to satisfy WGSL constraints.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[ClusteredDecal Component] --> B{Extract Phase}
</span><span>    B --> C[RenderClusteredDecals]
</span><span>    C --> D[Texture Binding Array]
</span><span>    C --> E[Decal Data Buffer]
</span><span>    D --> F[WGSL Shader]
</span><span>    E --> F
</span><span>    F --> G[apply_decals function]
</span><span>    G --> H[Base Color Blending]
</span><span>    G --> I[Normal Map Blending&LTbr>Whiteout Method]
</span><span>    G --> J[Metallic-Roughness Blending]
</span><span>    G --> K[Emissive Additive]
</span><span>    
</span><span>    subgraph "Texture Types"
</span><span>        L[Base Color]
</span><span>        M[Normal Map]
</span><span>        N[Metallic-Roughness]
</span><span>        O[Emissive]
</span><span>    end
</span><span>    
</span><span>    L --> H
</span><span>    M --> I
</span><span>    N --> J
</span><span>    O --> K
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=examples-3d-clustered-decal-maps-rs-445-0><code>examples/3d/clustered_decal_maps.rs</code> (+445/-0)</h3><p>This new example demonstrates the enhanced decal system by spawning decals with all four texture types onto a plane. The example includes animation systems for decal appearance/disappearance and UI controls for toggling emissive effects.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Key code showing the updated ClusteredDecal usage:
</span><span>ClusteredDecal {
</span><span>    base_color_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(app_textures</span><span style=color:#ed9366>.</span><span>decal_base_color_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>,
</span><span>    normal_map_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(app_textures</span><span style=color:#ed9366>.</span><span>decal_normal_map_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>,
</span><span>    metallic_roughness_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(app_textures</span><span style=color:#ed9366>.</span><span>decal_metallic_roughness_map_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>,
</span><span>    emissive_texture</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>if</span><span> app_status</span><span style=color:#ed9366>.</span><span>emissive_decals {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(app_textures</span><span style=color:#ed9366>.</span><span>decal_emissive_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>None
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>..</span><span>ClusteredDecal</span><span style=color:#ed9366>::</span><span>default()
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-decal-clustered-wgsl-112-30><code>crates/bevy_pbr/src/decal/clustered.wgsl</code> (+112/-30)</h3><p>The shader code was significantly expanded to support multiple texture types and implement the Whiteout normal blending method.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before (simplified):
</span><span>fn apply_decal_base_color(world_position: vec3&LTf32>, frag_coord: vec2&LTf32>, initial_base_color: vec4&LTf32>) -> vec4&LTf32> {
</span><span>    // Only handled base color
</span><span>}
</span><span>
</span><span>// After:
</span><span>fn apply_decals(pbr_input: ptr&LTfunction, PbrInput>) {
</span><span>    // Handles all four texture types
</span><span>    if (iterator.normal_map_texture_index >= 0) {
</span><span>        let Nd = textureSampleLevel(...).rgb * 2.0 - 1.0;
</span><span>        // Whiteout normal map blending
</span><span>        Nt = vec3(Nt.xy + Nd.xy, Nt.z * Nd.z);
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-pbr-src-decal-clustered-rs-117-24><code>crates/bevy_pbr/src/decal/clustered.rs</code> (+117/-24)</h3><p>The extraction system was refactored to handle arrays of optional textures instead of single required textures.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>insert_decal</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>entity</span><span style=color:#61676ccc>:</span><span> Entity, </span><span style=color:#ff8f40>image</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>AssetId&LTImage>, ...)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>insert_decal</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>entity</span><span style=color:#61676ccc>:</span><span> Entity,
</span><span>    </span><span style=color:#ff8f40>images</span><span style=color:#61676ccc>:</span><span> [</span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTAssetId&LTImage>>; IMAGES_PER_DECAL],
</span><span>    ...
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> image_indices </span><span style=color:#ed9366>=</span><span> images</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>maybe_image_id</span><span>| </span><span style=color:#fa6e32>match</span><span> maybe_image_id {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#fa6e32>ref</span><span> image_id) </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_or_insert_image</span><span>(image_id)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>None </span><span style=color:#ed9366>=> -</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-light-src-cluster-mod-rs-52-7><code>crates/bevy_light/src/cluster/mod.rs</code> (+52/-7)</h3><p>The <code>ClusteredDecal</code> component was completely redesigned to support four optional texture fields instead of one required field.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ClusteredDecal </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>image</span><span style=color:#61676ccc>: </span><span>Handle&LTImage>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>tag</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ClusteredDecal </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>base_color_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTHandle&LTImage>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>normal_map_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTHandle&LTImage>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>metallic_roughness_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTHandle&LTImage>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>emissive_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTHandle&LTImage>>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>tag</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span></code></pre><h3 id=cargo-toml-12-0><code>Cargo.toml</code> (+12/-0)</h3><p>Added the new example to the workspace configuration with appropriate feature flags.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://blog.selfshadow.com/publications/blending-in-detail/ target=_blank><em>Blending in Detail</em> article</a> - Comprehensive discussion of normal map blending techniques including Whiteout and RNM methods.<li><a rel="noopener nofollow noreferrer" href=https://dl.acm.org/doi/10.1145/1275808.1276485 target=_blank>SIGGRAPH 2007: Whiteout Normal Blending</a> - Original paper describing the Whiteout blending method.<li><a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/main/specification/2.0#materials target=_blank>glTF Material Specification</a> - Reference for metallic-roughness texture channel conventions (metallic in blue, roughness in green).<li><a rel="noopener nofollow noreferrer" href=https://keithp.com/~keithp/porterduff/ target=_blank>Porter-Duff Compositing Operators</a> - Mathematical foundation for alpha compositing used in base color blending.</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22039.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>