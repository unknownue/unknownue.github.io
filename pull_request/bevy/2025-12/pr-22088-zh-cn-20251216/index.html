<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22088 Refactor window creation logic
        
    </title><meta content="#22088 Refactor window creation logic" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-16</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-12/pr-22088-en-20251216>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Refactor window creation logic<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/22088<li><strong>作者</strong>: kristoff3r<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: C-Bug, A-Windowing, D-Modest, S-Needs-Review<li><strong>创建时间</strong>: 2025-12-11T10:17:09Z<li><strong>合并时间</strong>: 2025-12-16T04:00:33Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h3 id=mu-biao>目标</h3><p>修复 #21948<p>目前我们在 <code>about_to_wait</code> 生命周期方法中告诉 winit 生成新的 <code>Window</code>，但这是不可靠的：如果在我们等待时没有新事件出现，可能需要任意长的时间，或者可能根本没有新事件出现，导致我们永远不会生成窗口。这在从 0 个窗口到 1 个窗口时尤其糟糕，因为许多事件都与现有窗口相关。<h3 id=jie-jue-fang-an>解决方案</h3><p>在 <code>resumed</code> 中检查初始窗口（这也是 winit 示例的做法），在 <code>user_event</code> 中检查新窗口。<p>我在调查这个问题时还做了一些其他改进：<ul><li>将 <code>Added&LTWindow></code> 查询过滤器内联到 <code>CreateWindowParams</code> 中，因为该逻辑与其他过滤器一起使用时没有意义。<li>在插件构建时插入 <code>EventLoopProxyWrapper</code> 资源，而不是在 <code>winit_runner</code> 内部。目前这在实际使用中没有区别，但在这个 PR 的另一个版本中，由于观察者在运行器启动前尝试使用该资源，导致了崩溃。这也是更自然的做法。<li>使 <code>WinitPlugin</code> 不再通用，并移除了 <code>custom_user_event</code> 示例。它提供的功能（能够从外部向 bevy 发送事件）仅适用于一个方向，我不明白为什么需要通过 winit 而不是使用通道的专用插件来实现。<del>如果这个功能对我遗漏的原因有用，那么我很乐意重新添加它。</del> 编辑：winit 在 0.31 版本中移除了自定义用户事件，这让我更加确信这对我们来说也是正确的方向。</ul><h3 id=ce-shi>测试</h3><p>运行不同的示例，观察窗口是否及时生成；按照 #21948 中的描述编辑 <code>multiple_windows</code> 示例，观察窗口是否生成。<h2 id=zhe-ge-prde-ji-shu-gu-shi>这个PR的技术故事</h2><h3 id=wen-ti-he-bei-jing>问题和背景</h3><p>这个PR源于一个窗口创建时机的问题（#21948）。在Bevy的窗口管理系统中，当应用启动或需要创建新窗口时，系统依赖于winit事件循环的特定阶段来触发窗口创建。具体来说，窗口创建逻辑被放在了 <code>about_to_wait</code> 生命周期方法中。<p>这种方法存在一个根本性的问题：<code>about_to_wait</code> 只有在事件循环即将进入等待状态时才会被调用。如果系统已经处于等待状态，或者没有新事件触发循环，窗口创建可能会被无限期延迟。这种情况在从0个窗口启动应用时尤其明显——由于没有现有窗口，许多与窗口相关的事件（如重绘请求）都不会发生，导致 <code>about_to_wait</code> 可能根本不会被调用。<p>从技术角度来看，这个问题暴露了事件驱动架构中的一个时序问题：窗口创建逻辑与事件循环的特定阶段过度耦合，而没有考虑到初始状态和动态窗口创建的实际需求。<h3 id=jie-jue-fang-an-fang-fa>解决方案方法</h3><p>开发者采取了多重策略来解决这个问题：<ol><li><strong>改变窗口创建触发点</strong>：将初始窗口创建移到 <code>resumed</code> 阶段（与winit官方示例保持一致），并将后续窗口创建通过自定义事件触发。<li><strong>简化类型系统</strong>：移除 <code>WinitPlugin</code> 的泛型参数，使用固定的事件类型 <code>WinitUserEvent</code>。<li><strong>资源初始化时机优化</strong>：将 <code>EventLoopProxyWrapper</code> 资源的创建提前到插件构建阶段。<li><strong>查询过滤器内联</strong>：将 <code>Added&LTWindow></code> 查询过滤器硬编码到 <code>CreateWindowParams</code> 类型中，因为其他过滤器在这个上下文中没有意义。</ol><p>这个方案的核心思想是：初始窗口创建应该在应用恢复时立即进行，而后续窗口创建应该通过显式的事件机制触发，而不是依赖事件循环的特定阶段。<h3 id=shi-xian-xi-jie>实现细节</h3><p>实现涉及多个组件的重构。首先，开发者创建了新的 <code>WinitUserEvent</code> 枚举来替代之前的泛型消息类型：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Reflect)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>reflect</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>WinitUserEvent </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Dummy event that just wakes up the winit event loop
</span><span>    WakeUp</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Tell winit that a window needs to be created
</span><span>    WindowAdded</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>这个枚举提供了两种功能：唤醒事件循环和请求创建新窗口。通过统一的事件类型，简化了类型系统的复杂性。<p>在 <code>WinitPlugin</code> 的构建过程中，现在会添加一个观察者来监听窗口添加事件：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(
</span><span>    |</span><span style=color:#ff8f40>_window</span><span style=color:#61676ccc>: </span><span>On&LTAdd, Window></span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>event_loop_proxy</span><span style=color:#61676ccc>: </span><span>Res&LTEventLoopProxyWrapper>| </span><span style=color:#61676ccc>-></span><span> Result {
</span><span>        event_loop_proxy</span><span style=color:#ed9366>.</span><span style=color:#f07171>send_event</span><span>(WinitUserEvent</span><span style=color:#ed9366>::</span><span>WindowAdded)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>这个观察者确保每当有新的 <code>Window</code> 组件被添加到世界中时，就会发送一个 <code>WindowAdded</code> 事件到winit事件循环。<p>窗口创建逻辑现在分散在两个地方。初始窗口在 <code>resumed</code> 回调中创建：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>resumed</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>event_loop</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ActiveEventLoop) {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>lifecycle </span><span style=color:#ed9366>= </span><span>AppLifecycle</span><span style=color:#ed9366>::</span><span>WillResume</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Create the initial window if needed
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> create_window </span><span style=color:#ed9366>= </span><span>SystemState</span><span style=color:#ed9366>::</span><span>&LTCreateWindowParams></span><span style=color:#ed9366>::</span><span>from_world(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>create_windows</span><span>(event_loop</span><span style=color:#61676ccc>,</span><span> create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>()))</span><span style=color:#61676ccc>;
</span><span>    create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>apply</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>后续窗口则在 <code>user_event</code> 回调中响应 <code>WindowAdded</code> 事件：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>user_event</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>event_loop</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ActiveEventLoop, </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>:</span><span> WinitUserEvent) {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>user_event_received </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>match</span><span> event {
</span><span>        WinitUserEvent</span><span style=color:#ed9366>::</span><span>WakeUp </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>redraw_requested </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        WinitUserEvent</span><span style=color:#ed9366>::</span><span>WindowAdded </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#fa6e32>let mut</span><span> create_window </span><span style=color:#ed9366>=
</span><span>                SystemState</span><span style=color:#ed9366>::</span><span>&LTCreateWindowParams></span><span style=color:#ed9366>::</span><span>from_world(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#f07171>create_windows</span><span>(event_loop</span><span style=color:#61676ccc>,</span><span> create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>()))</span><span style=color:#61676ccc>;
</span><span>            create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>apply</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>同时，从 <code>about_to_wait</code> 中移除了窗口创建逻辑，只保留显示器创建逻辑：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>about_to_wait</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>event_loop</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ActiveEventLoop) {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> create_monitor </span><span style=color:#ed9366>= </span><span>SystemState</span><span style=color:#ed9366>::</span><span>&LTCreateMonitorParams></span><span style=color:#ed9366>::</span><span>from_world(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>create_monitors</span><span>(event_loop</span><span style=color:#61676ccc>,</span><span> create_monitor</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>()))</span><span style=color:#61676ccc>;
</span><span>    create_monitor</span><span style=color:#ed9366>.</span><span style=color:#f07171>apply</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 其他逻辑
</span><span>}
</span></code></pre><h3 id=ji-shu-dong-cha>技术洞察</h3><p>这个PR展示了几个重要的软件工程原则：<ol><li><p><strong>事件驱动的正确时序</strong>：将窗口创建从被动的 <code>about_to_wait</code> 阶段移到主动的 <code>resumed</code> 和事件响应阶段，确保了窗口创建的及时性。这种改变体现了对事件循环生命周期的更深入理解。</p><li><p><strong>类型系统简化</strong>：通过移除泛型参数，<code>WinitPlugin</code> 的API变得更加简单和直观。虽然损失了一定的灵活性，但考虑到winit 0.31也将移除自定义用户事件，这个决定具有前瞻性。</p><li><p><strong>资源生命周期管理</strong>：将 <code>EventLoopProxyWrapper</code> 资源的创建提前到插件构建阶段，避免了潜在的竞态条件。这种“尽早初始化“的模式在系统编程中很常见，可以避免复杂的初始化顺序问题。</p><li><p><strong>观察者模式的应用</strong>：使用观察者来监听窗口添加事件，而不是在查询中手动检查，这是一种更声明式和响应式的编程模式。它减少了手动状态管理的复杂性。</p></ol><h3 id=ying-xiang-he-yi-yi>影响和意义</h3><p>这些改变带来了几个实际的改进：<ol><li><strong>解决了窗口创建延迟问题</strong>：应用启动时窗口能够立即创建，而不是等待不确定的事件触发。<li><strong>代码简化</strong>：移除泛型减少了类型系统的复杂性，使代码更容易理解和维护。<li><strong>更好的架构分离</strong>：通过统一的事件类型和清晰的触发机制，窗口创建逻辑与事件循环的耦合度降低。</ol><p>从更广泛的角度看，这个PR展示了如何通过理解底层系统（winit）的行为模式来优化上层框架（Bevy）的设计决策。它强调了在异步事件处理系统中，时序和触发机制的重要性。<h2 id=shi-jue-biao-shi>视觉表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[WinitPlugin构建] --> B[初始化EventLoopProxyWrapper]
</span><span>    B --> C[添加Window添加观察者]
</span><span>    C --> D[应用启动]
</span><span>    D --> E{应用状态}
</span><span>    E -->|resumed| F[创建初始窗口]
</span><span>    E -->|user_event| G{事件类型}
</span><span>    G -->|WindowAdded| H[创建新窗口]
</span><span>    G -->|WakeUp| I[请求重绘]
</span><span>    
</span><span>    J[外部系统] --> K[发送WinitUserEvent]
</span><span>    K --> L[事件循环]
</span><span>    L --> G
</span></code></pre><h2 id=guan-jian-wen-jian-bian-geng>关键文件变更</h2><h3 id=crates-bevy-winit-src-lib-rs-39-15><code>crates/bevy_winit/src/lib.rs</code> (+39/-15)</h3><p>这是变化最大的文件之一，主要进行了以下修改：<p><strong>移除泛型参数</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>WinitPlugin</span><span>&LTM</span><span style=color:#61676ccc>:</span><span> Message = WakeUp> {
</span><span>    marker</span><span style=color:#61676ccc>: </span><span>PhantomData&LTM>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>WinitPlugin </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 移除了泛型参数
</span><span>}
</span></code></pre><p><strong>引入统一事件类型</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Reflect)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>WinitUserEvent </span><span>{
</span><span>    WakeUp</span><span style=color:#61676ccc>,
</span><span>    WindowAdded</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p><strong>资源初始化提前</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 在build方法中:
</span><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert_resource</span><span>(EventLoopProxyWrapper(event_loop</span><span style=color:#ed9366>.</span><span style=color:#f07171>create_proxy</span><span>()))
</span></code></pre><p><strong>添加窗口创建观察者</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(
</span><span>    |</span><span style=color:#ff8f40>_window</span><span style=color:#61676ccc>: </span><span>On&LTAdd, Window></span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>event_loop_proxy</span><span style=color:#61676ccc>: </span><span>Res&LTEventLoopProxyWrapper>| </span><span style=color:#61676ccc>-></span><span> Result {
</span><span>        event_loop_proxy</span><span style=color:#ed9366>.</span><span style=color:#f07171>send_event</span><span>(WinitUserEvent</span><span style=color:#ed9366>::</span><span>WindowAdded)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-winit-src-state-rs-25-25><code>crates/bevy_winit/src/state.rs</code> (+25/-25)</h3><p>这个文件包含了事件循环状态管理的主要逻辑：<p><strong>窗口创建逻辑重构</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 在resumed方法中创建初始窗口:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>resumed</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>event_loop</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ActiveEventLoop) {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>lifecycle </span><span style=color:#ed9366>= </span><span>AppLifecycle</span><span style=color:#ed9366>::</span><span>WillResume</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> create_window </span><span style=color:#ed9366>= </span><span>SystemState</span><span style=color:#ed9366>::</span><span>&LTCreateWindowParams></span><span style=color:#ed9366>::</span><span>from_world(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>create_windows</span><span>(event_loop</span><span style=color:#61676ccc>,</span><span> create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>()))</span><span style=color:#61676ccc>;
</span><span>    create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>apply</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在user_event中处理WindowAdded事件:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>user_event</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>event_loop</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ActiveEventLoop, </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>:</span><span> WinitUserEvent) {
</span><span>    </span><span style=color:#fa6e32>match</span><span> event {
</span><span>        WinitUserEvent</span><span style=color:#ed9366>::</span><span>WindowAdded </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#fa6e32>let mut</span><span> create_window </span><span style=color:#ed9366>=
</span><span>                SystemState</span><span style=color:#ed9366>::</span><span>&LTCreateWindowParams></span><span style=color:#ed9366>::</span><span>from_world(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#f07171>create_windows</span><span>(event_loop</span><span style=color:#61676ccc>,</span><span> create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>()))</span><span style=color:#61676ccc>;
</span><span>            create_window</span><span style=color:#ed9366>.</span><span style=color:#f07171>apply</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 从about_to_wait中移除窗口创建:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>about_to_wait</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>event_loop</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ActiveEventLoop) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 只保留显示器创建逻辑
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> create_monitor </span><span style=color:#ed9366>= </span><span>SystemState</span><span style=color:#ed9366>::</span><span>&LTCreateMonitorParams></span><span style=color:#ed9366>::</span><span>from_world(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>create_monitors</span><span>(event_loop</span><span style=color:#61676ccc>,</span><span> create_monitor</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>()))</span><span style=color:#61676ccc>;
</span><span>    create_monitor</span><span style=color:#ed9366>.</span><span style=color:#f07171>apply</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>world_mut</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 窗口创建逻辑已移除
</span><span>}
</span></code></pre><h3 id=examples-window-custom-user-event-rs-0-113><code>examples/window/custom_user_event.rs</code> (+0/-113)</h3><p>这个示例文件被完全移除，因为相关功能（自定义用户事件）不再被支持。删除的理由是：<ol><li>该功能只支持单向通信<li>可以通过专用插件和通道实现相同功能<li>winit 0.31将移除自定义用户事件支持</ol><h3 id=release-content-migration-guides-winit-user-events-removed-md-26-0><code>release-content/migration-guides/winit_user_events_removed.md</code> (+26/-0)</h3><p>新增的迁移指南，帮助用户从旧版本迁移：<pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span style=color:#abb0b6;background-color:#61676c10;font-weight:700>---
</span><span>title: Winit user events removed
</span><span>pull_requests: [22088]
</span><span style=color:#fa6e32;font-weight:700>---
</span><span>
</span><span>在 Bevy 0.17 及更早版本中，</span><span style=color:#ed9366;background-color:#61676c10>`WinitPlugin`</span><span> 和 </span><span style=color:#ed9366;background-color:#61676c10>`EventLoopProxyWrapper`</span><span> 对 </span><span style=color:#ed9366;background-color:#61676c10>`M: Message`</span><span> 类型是泛型的，可用于唤醒 winit 事件循环，然后转发到 ECS 世界。在 0.18 版本中，对此的支持已被移除，这些类型不再具有泛型。
</span><span>
</span><span>如果你通过事件循环代理使用默认的 </span><span style=color:#ed9366;background-color:#61676c10>`WakeUp`</span><span> 类型，仍然可以通过新的 </span><span style=color:#ed9366;background-color:#61676c10>`WinitUserEvent`</span><span> 类型来实现：
</span><span>
</span><span>// 0.17
</span><span>fn wakeup_system(event_loop_proxy: Res</span><span style=color:#55b4d490><</span><span style=color:#399ee6>EventLoopProxyWrapper</span><span style=color:#f51818><</span><span style=color:#f29718>WakeUp</span><span style=color:#55b4d490>></span><span>>) -> Result {
</span><span>    event_loop_proxy.send_event(WakeUp)?;
</span><span>    Ok(())
</span><span>}
</span><span>
</span><span>// 0.18
</span><span>fn wakeup_system(event_loop_proxy: Res</span><span style=color:#55b4d490><</span><span style=color:#399ee6>EventLoopProxyWrapper</span><span style=color:#55b4d490>></span><span>) -> Result {
</span><span>    event_loop_proxy.send_event(WinitUserEvent::WakeUp)?;
</span><span>    Ok(())
</span><span>}
</span></code></pre><p>如果你使用它从 Bevy 外部向 ECS 世界发送信息，你需要创建自己的通道和转发消息的系统。<pre style=color:#61676c;background-color:#fafafa><code><span>
</span><span>### `Cargo.toml` (+0/-11)
</span><span>移除了对 `custom_user_event` 示例的引用。
</span><span>
</span><span>## 扩展阅读
</span><span>
</span><span>1. **winit事件循环文档**：了解winit事件循环的生命周期和不同阶段的含义
</span><span>   - [winit::event_loop::EventLoop](https://docs.rs/winit/latest/winit/event_loop/struct.EventLoop.html)
</span><span>   - [winit::application::ApplicationHandler](https://docs.rs/winit/latest/winit/application/trait.ApplicationHandler.html)
</span><span>
</span><span>2. **Bevy观察者模式**：了解Bevy中观察者的工作原理和使用场景
</span><span>   - [Bevy ECS Observers](https://bevyengine.org/learn/quick-start/ecs/observers/)
</span><span>
</span><span>3. **事件驱动架构模式**：深入了解事件驱动系统设计原则
</span><span>   - [Event-driven architecture patterns](https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven)
</span><span>
</span><span>4. **winit 0.31变化**：了解winit未来版本中自定义用户事件的移除
</span><span>   - [winit changelog](https://github.com/rust-windowing/winit/blob/main/CHANGELOG.md)
</span><span>
</span><span>5. **系统编程中的资源管理**：了解不同资源初始化时机的权衡
</span><span>   - [Resource Management in Systems Programming](https://rust-unofficial.github.io/patterns/patterns/creational/raii.html)</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22088.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>