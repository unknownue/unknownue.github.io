<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20671 system combinators short circuiting with system failure
        
    </title><meta content="#20671 system combinators short circuiting with system failure" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-14</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-20671-zh-cn-20251214>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: system combinators short circuiting with system failure<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20671<li><strong>Author</strong>: janis-bhm<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-ECS, S-Ready-For-Final-Review, M-Migration-Guide, X-Contentious, D-Straightforward<li><strong>Created</strong>: 2025-08-20T13:32:59Z<li><strong>Merged</strong>: 2025-12-14T23:22:16Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>Objective</strong><p>Fixes https://github.com/bevyengine/bevy/issues/20376:<p>CombinatorSystems short circuit if one of the systems fails to validate, e.g. because it queries a Component that isn’t resident in the world.<p><strong>Solution</strong><p>Instead, we can treat the system failing as the system yielding <code>false</code>, appropriately querying the second system depending on the logical operator.<p><strong>Testing</strong><p>I added a new test that calls the combinators in different configurations with a failing system as both the rhs and lhs of the combinator and counts the invocations of the system and the condition.<hr><h1 id=the-story-of-this-pull-request>The Story of This Pull Request</h1><p>This PR addresses a specific bug in Bevy’s Entity Component System (ECS) where combinator systems would incorrectly short-circuit when one of their constituent systems failed to validate. The issue was particularly problematic because it broke the expected logical operator semantics, leading to inconsistent behavior compared to Rust’s standard boolean operators.<h2 id=the-problem-and-context>The Problem and Context</h2><p>System combinators in Bevy allow developers to combine multiple <code>SystemCondition</code>s using logical operators like <code>and</code>, <code>or</code>, <code>xor</code>, and their negated variants. These combinators are implemented as systems themselves and follow Rust’s short-circuiting behavior for logical operators. However, there was a critical flaw in the implementation: when a system failed to validate (for example, because it queried for a component that doesn’t exist in the world), the entire combinator would fail immediately, preventing the second system from running even when the logical operator semantics required it.<p>Consider this example from the migration guide:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>vacant</span><span>(</span><span style=color:#ed9366>_</span><span>: crate</span><span style=color:#ed9366>::</span><span>system</span><span style=color:#ed9366>::</span><span>Single<</span><span style=color:#ed9366>&</span><span>Vacant>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#ff8f40>true
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_true</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#ff8f40>true
</span><span>}
</span><span>
</span><span style=color:#f07171>assert!</span><span>(world</span><span style=color:#ed9366>.</span><span>query</span><span style=color:#ed9366>::</span><span><</span><span style=color:#ed9366>&</span><span>Vacant>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>(</span><span style=color:#ed9366>&</span><span>world)</span><span style=color:#ed9366>.</span><span style=color:#f07171>next</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>())</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Previously: This would return an error
</span><span style=color:#f07171>assert!</span><span>(world</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_system_once</span><span>(is_true</span><span style=color:#ed9366>.</span><span style=color:#f07171>or</span><span>(vacant))</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_err</span><span>())</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Expected behavior: This should return Ok(true) because `is_true() || false` = true
</span></code></pre><p>The problem stemmed from how the <code>combine</code> method in the <code>Func</code> trait implementation handled errors. When a system returned a <code>RunSystemError::Failed</code>, the <code>?</code> operator would propagate the error immediately, causing the entire combinator to fail. This violated the expected short-circuiting semantics of logical operators.<h2 id=the-solution-approach>The Solution Approach</h2><p>The fix adopts a straightforward approach: treat a system failure as if the system returned <code>false</code> for the purpose of the logical operation. This preserves the expected short-circuiting behavior while ensuring that combinators don’t fail unexpectedly when one system cannot run.<p>The implementation required changes in two key areas:<ol><li>The logical operator implementations in <code>condition.rs</code> needed to handle errors by converting them to <code>false</code> values<li>The <code>CombinatorSystem</code> in <code>combinator.rs</code> needed to handle error reporting correctly while still allowing both systems to attempt validation and execution</ol><h2 id=the-implementation>The Implementation</h2><h3 id=changes-to-logical-operators>Changes to Logical Operators</h3><p>In <code>condition.rs</code>, the PR modifies all six logical operator implementations (<code>And</code>, <code>Nand</code>, <code>Nor</code>, <code>Or</code>, <code>Xor</code>, <code>Xnor</code>) to use <code>.unwrap_or(false)</code> instead of the <code>?</code> operator when evaluating systems. This change ensures that if a system fails, it’s treated as returning <code>false</code> rather than propagating the error:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (in the And implementation):
</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#f07171>a</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>? && </span><span style=color:#f07171>b</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>?</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#f07171>a</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>false</span><span>) </span><span style=color:#ed9366>&& </span><span style=color:#f07171>b</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>false</span><span>))
</span></code></pre><p>This pattern is applied consistently across all six operators. The change is minimal but significant: it preserves the short-circuiting behavior of <code>&&</code> and <code>||</code> while converting errors to <code>false</code> values. For example, in <code>a && b</code>, if <code>a</code> returns an error (treated as <code>false</code>), the expression short-circuits to <code>false</code> without evaluating <code>b</code>. However, in <code>a || b</code>, if <code>a</code> returns an error (treated as <code>false</code>), the combinator still evaluates <code>b</code> to determine the final result.<h3 id=changes-to-combinatorsystem>Changes to CombinatorSystem</h3><p>The more complex changes occur in <code>combinator.rs</code>. The <code>CombinatorSystem</code> struct needed modifications to properly handle error reporting while still allowing both systems to run when appropriate. The key insight is that we need to intercept system errors, pass them to the world’s error handler, and then continue with the combinator logic.<p>The PR introduces a helper function within <code>run_unsafe</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>run_system</span><span>&LTS</span><span style=color:#61676ccc>:</span><span> System>(
</span><span>    </span><span style=color:#ff8f40>system</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> S,
</span><span>    </span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span>SystemIn&LTS>,
</span><span>    </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> PrivateUnsafeWorldCell,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>S</span><span style=color:#ed9366>::</span><span>Out, RunSystemError> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// SAFETY: see comment on `Func::combine` call
</span><span>    </span><span style=color:#fa6e32>match </span><span>(|| </span><span style=color:#fa6e32>unsafe </span><span>{
</span><span>        system</span><span style=color:#ed9366>.</span><span style=color:#f07171>validate_param_unsafe</span><span>(world</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>        system</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_unsafe</span><span>(input</span><span style=color:#61676ccc>,</span><span> world</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)
</span><span>    })() {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(RunSystemError</span><span style=color:#ed9366>::</span><span>Failed(err)) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// let the world's default error handler handle the error if `Failed(_)`
</span><span>            (world</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>default_error_handler</span><span>())(
</span><span>                err</span><span style=color:#61676ccc>,
</span><span>                ErrorContext</span><span style=color:#ed9366>::</span><span>System {
</span><span>                    name</span><span style=color:#61676ccc>:</span><span> system</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#61676ccc>,
</span><span>                    last_run</span><span style=color:#61676ccc>:</span><span> system</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_last_run</span><span>()</span><span style=color:#61676ccc>,
</span><span>                }</span><span style=color:#61676ccc>,
</span><span>            )</span><span style=color:#61676ccc>;
</span><span>
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// Since the error handler takes the error by value, create a new error:
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// The original error has already been handled, including
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// the reason for the failure here isn't important.
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(</span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"System `</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>` failed"</span><span style=color:#61676ccc>,</span><span> system</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())
</span><span>        }
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// `Skipped(_)` and `Ok(_)` are passed through:
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// system skipping is not an error, and isn't passed to the
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// world's error handler by the executors.
</span><span>        result </span><span style=color:#ed9366>@ </span><span>(</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>| </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(RunSystemError</span><span style=color:#ed9366>::</span><span>Skipped(</span><span style=color:#ed9366>_</span><span>))) </span><span style=color:#ed9366>=></span><span> result</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span></code></pre><p>This function wraps system execution with error handling that:<ol><li>Attempts to validate and run the system<li>If it fails with <code>RunSystemError::Failed</code>, passes the error to the world’s default error handler<li>Returns a new generic error message so the combinator knows the system failed<li>Preserves <code>Skipped</code> errors (which aren’t actual failures) and successful results</ol><p>This approach ensures that errors are properly reported while allowing the combinator logic to continue. The function is then used in both closures passed to <code>Func::combine</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>|</span><span>input</span><span style=color:#61676ccc>,</span><span> world</span><span style=color:#ed9366>| </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#f07171>run_system</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>a</span><span style=color:#61676ccc>,</span><span> input</span><span style=color:#61676ccc>,</span><span> world) }</span><span style=color:#61676ccc>,
</span><span>|</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>world</span><span>| </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#f07171>run_system</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>b</span><span style=color:#61676ccc>,</span><span> input</span><span style=color:#61676ccc>,</span><span> world) }</span><span style=color:#61676ccc>,
</span></code></pre><p>Additionally, the <code>validate_param_unsafe</code> method is modified to always return <code>Ok(())</code>, deferring actual validation to the <code>run_unsafe</code> method. This allows both systems to attempt validation even if the first one fails:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>validate_param_unsafe</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>_world</span><span style=color:#61676ccc>:</span><span> UnsafeWorldCell,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), SystemParamValidationError> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Both systems are validated in `Self::run_unsafe`, so that we get the
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// chance to run the second system even if the first one fails to
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// validate.
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>}
</span></code></pre><h3 id=comprehensive-testing>Comprehensive Testing</h3><p>The PR includes an extensive test suite that validates the new behavior. The test creates systems that always succeed (returning <code>true</code> or <code>false</code>) and systems that fail (querying a non-existent component). It then tests all combinator variations with different combinations of successful and failing systems.<p>The test uses a clever approach with prime numbers to track which systems executed:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>const </span><span style=color:#ff8f40>FALSE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>TRUE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>3</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>test_true</span><span>(</span><span style=color:#ff8f40>counter</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Counter) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#ed9366>*</span><span>counter</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>lock</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>() </span><span style=color:#ed9366>*= </span><span style=color:#ff8f40>TRUE</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ff8f40>true
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>test_false</span><span>(</span><span style=color:#ff8f40>counter</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Counter) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#ed9366>*</span><span>counter</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>lock</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>() </span><span style=color:#ed9366>*= </span><span style=color:#ff8f40>FALSE</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ff8f40>false
</span><span>}
</span></code></pre><p>By multiplying the counter by <code>TRUE</code> or <code>FALSE</code> when a system runs, the test can verify both the final result and which systems executed. For example, if only <code>test_true</code> runs, the counter becomes <code>3</code> (1 × 3). If both run, it becomes <code>6</code> (1 × 3 × 2). This allows the test to verify short-circuiting behavior precisely.<h2 id=technical-insights>Technical Insights</h2><p>This PR highlights several important aspects of Bevy’s ECS design:<ol><li><p><strong>Error Handling Strategy</strong>: Bevy uses a dual approach to error handling. Critical errors are passed to a configurable error handler for user-defined handling, while the system execution continues with a degraded but predictable state.</p><li><p><strong>System Validation Timing</strong>: The change to defer validation until execution time (<code>run_unsafe</code>) rather than at scheduling time (<code>validate_param_unsafe</code>) demonstrates a trade-off between early error detection and flexible execution semantics. In this case, the need to support logical operator semantics takes precedence.</p><li><p><strong>Unsafe Code Patterns</strong>: The implementation carefully manages unsafe code by using a private wrapper type (<code>PrivateUnsafeWorldCell</code>) to ensure that world accesses don’t conflict between the two systems in the combinator.</p><li><p><strong>Logical Operator Semantics</strong>: The PR maintains Rust’s standard logical operator semantics, which is crucial for developer intuition and code correctness.</p></ol><h2 id=the-impact>The Impact</h2><p>The primary impact of this change is that system combinators now behave predictably according to standard logical operator semantics. Developers can rely on combinators to work correctly even when some systems might fail to validate.<p>However, there’s an important behavioral change: previously, a failing system in a combinator would cause the entire combinator to fail early. Now, the error is reported through the error handler, but the combinator continues execution according to logical operator rules. This means developers need to audit their error handling code to ensure they’re not relying on the old short-circuit-to-error behavior.<p>The migration guide clearly documents this change and provides examples to help developers understand the new behavior. The guide also includes a helpful reference table mapping combinators to their Rust equivalents.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[System Condition A] -->|and/or/xor/etc| B[Combinator System]
</span><span>    C[System Condition B] -->|and/or/xor/etc| B
</span><span>    B --> D{Evaluate}
</span><span>    D -->|A fails| E[Treat as false]
</span><span>    E --> F[Apply logical operator]
</span><span>    D -->|B fails| G[Treat as false]
</span><span>    G --> F
</span><span>    D -->|Both succeed| H[Use actual values]
</span><span>    H --> F
</span><span>    F --> I[Return result]
</span><span>    
</span><span>    J[Error Handler] -.->|Called if system fails| A
</span><span>    J -.->|Called if system fails| C
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-schedule-condition-rs-254-8><code>crates/bevy_ecs/src/schedule/condition.rs</code> (+254/-8)</h3><p>This file contains the implementations of logical operator combinators for system conditions. The key change is replacing the <code>?</code> operator with <code>.unwrap_or(false)</code> to convert system failures to <code>false</code> values:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (And implementation):
</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#f07171>a</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>? && </span><span style=color:#f07171>b</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>?</span><span>)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#f07171>a</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>false</span><span>) </span><span style=color:#ed9366>&& </span><span style=color:#f07171>b</span><span>(input</span><span style=color:#61676ccc>,</span><span> data)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>false</span><span>))
</span></code></pre><p>This pattern is applied to all six logical operators (<code>And</code>, <code>Nand</code>, <code>Nor</code>, <code>Or</code>, <code>Xor</code>, <code>Xnor</code>). The file also includes extensive new test code to verify the corrected behavior.<h3 id=crates-bevy-ecs-src-system-combinator-rs-44-14><code>crates/bevy_ecs/src/system/combinator.rs</code> (+44/-14)</h3><p>This file contains the <code>CombinatorSystem</code> implementation. The main changes are:<ol><li>Added a helper function <code>run_system</code> that wraps system execution with error handling<li>Modified <code>run_unsafe</code> to use this helper for both systems<li>Changed <code>validate_param_unsafe</code> to always succeed, deferring validation to execution time</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Key addition: error handling wrapper
</span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>run_system</span><span>&LTS</span><span style=color:#61676ccc>:</span><span> System>(
</span><span>    </span><span style=color:#ff8f40>system</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> S,
</span><span>    </span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span>SystemIn&LTS>,
</span><span>    </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> PrivateUnsafeWorldCell,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>S</span><span style=color:#ed9366>::</span><span>Out, RunSystemError> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... validation and execution with error handling
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Modified validation to defer to run_unsafe
</span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>validate_param_unsafe</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>_world</span><span style=color:#61676ccc>:</span><span> UnsafeWorldCell,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), SystemParamValidationError> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>}
</span></code></pre><h3 id=release-content-migration-guides-combinator-system-md-38-0><code>release-content/migration-guides/combinator_system.md</code> (+38/-0)</h3><p>This new migration guide documents the behavioral change and provides examples:<pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span>The </span><span style=color:#ed9366;background-color:#61676c10>`CombinatorSystem`</span><span>s can be used to combine multiple </span><span style=color:#ed9366;background-color:#61676c10>`SystemCondition`</span><span>s with logical operators. Previously, the conditions would short circuit if the system failed to run, for example because it's query could not be filled by the world.
</span><span>
</span><span>Now, the </span><span style=color:#ed9366;background-color:#61676c10>`CombinatorSystem`</span><span>s will work as expected, following the semantics of rust's logical operators.
</span><span>Namely, if a </span><span style=color:#ed9366;background-color:#61676c10>`SystemCondition`</span><span> fails, it will be considered to have returned </span><span style=color:#ed9366;background-color:#61676c10>`false`</span><span> and in combinators that don't short circuit the other condition will now be run.
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy ECS Documentation</strong>: https://bevyengine.org/learn/book/ecs/<li><strong>System Combinators in Bevy</strong>: https://bevyengine.org/learn/book/ecs/system-combinators/<li><strong>Error Handling in Bevy</strong>: https://bevyengine.org/learn/book/error-handling/<li><strong>Rust’s Logical Operator Semantics</strong>: The Rust Reference section on boolean logic<li><strong>Original Issue #20376</strong>: https://github.com/bevyengine/bevy/issues/20376</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_20671.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>