<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22100 Fix wrong termination for asset hash reads.
        
    </title><meta content="#22100 Fix wrong termination for asset hash reads." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-13</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22100-zh-cn-20251213>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix wrong termination for asset hash reads.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22100<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, D-Trivial, A-Assets, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-12-12T20:33:24Z<li><strong>Merged</strong>: 2025-12-13T00:15:34Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><p><strong>Objective</strong><ul><li>#21925 changed the hash computation to read the file piece by piece. Unfortunately, the termination condition is wrong for this loop. We should only exit once the reader has no more bytes (<code>bytes_read == 0</code>), otherwise, the reader might partially fill the buffer, and that may be interpreted as an EOF.<li>I originally did this check, but something was failing due to never terminating the read. Unclear what happened, maybe I got mixed up!</ul><p><strong>Solution</strong><ul><li>Check if there are no bytes left rather than if the buffer is partially filled.</ul><p><strong>Testing</strong><ul><li>Ran the asset tests with –all-features<li>Ran the <code>asset_processor</code> example and it seems to work!</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a specific bug in Bevy’s asset hashing logic. The issue stems from a change made in a previous PR (#21925), which modified how file hashes are computed for assets. Instead of reading entire files into memory, the implementation was updated to process files in chunks for better memory efficiency when handling large assets. However, this change introduced an incorrect termination condition in the reading loop.<p>The core problem was in the loop termination logic within the <code>get_asset_hash</code> function. When reading a file piece by piece, the code needs to determine when it has reached the end of the file (EOF). The original implementation after PR #21925 used the condition <code>if bytes_read < buffer.len()</code> to break the loop. This condition is flawed because it triggers a break whenever the buffer isn’t completely filled, which doesn’t necessarily mean the end of the file has been reached.<p>Consider a scenario where a file is being read and the final chunk of data is smaller than the buffer size. In this case, the condition <code>bytes_read < buffer.len()</code> would correctly identify that we’ve reached EOF. However, the same condition would also trigger a break if the file read operation returned a partial buffer for any other reason before reaching EOF, such as network latency or file system behavior. This would cause the hashing to stop prematurely, resulting in an incorrect hash value being computed for the asset.<p>The correct approach, which is standard for stream reading patterns, is to continue reading until the read operation returns zero bytes. This is the definitive signal that the end of the stream has been reached. The fix changes the termination condition to <code>if bytes_read == 0</code>, ensuring the loop only exits when there are genuinely no more bytes to read.<p>This bug could have significant consequences in a real application. Asset hashes are used for caching, versioning, and change detection. An incorrect hash means the engine might fail to detect that an asset has changed, leading to stale cached data being used. Conversely, it might incorrectly flag unchanged assets as modified, causing unnecessary re-processing and performance degradation.<p>The implementation change is minimal but important. It’s a single-line modification in the <code>meta.rs</code> file within the asset system. The author notes they originally considered this correct approach but encountered issues during testing that led them to use the incorrect condition instead. This highlights a common challenge in asynchronous I/O programming: understanding exactly when a read operation indicates EOF versus just a partial read. The solution follows standard Rust I/O patterns where a read returning <code>Ok(0)</code> indicates EOF.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Asset File] --> B[Asset Reader]
</span><span>    B --> C[Read Buffer&LTbr/>chunk by chunk]
</span><span>    C --> D{Bytes Read?}
</span><span>    D -->|bytes_read > 0| E[Update Hash]
</span><span>    E --> C
</span><span>    D -->|bytes_read == 0| F[EOF Reached&LTbr/>Return Final Hash]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><p><strong>File: <code>crates/bevy_asset/src/meta.rs</code></strong><p>This file contains the asset metadata handling code, including the <code>get_asset_hash</code> function which computes hash values for asset files. The change fixes a logic error in the file reading loop that could cause premature termination of hash computation.<p><strong>Code Change:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_asset/src/meta.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>loop </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> bytes_read </span><span style=color:#ed9366>=</span><span> asset_reader</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> buffer)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    hasher</span><span style=color:#ed9366>.</span><span style=color:#f07171>update</span><span>(</span><span style=color:#ed9366>&</span><span>buffer[</span><span style=color:#ed9366>..</span><span>bytes_read])</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if</span><span> bytes_read </span><span style=color:#ed9366><</span><span> buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// This means we've reached EOF, so we're done consuming asset bytes.
</span><span>        </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>loop </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> bytes_read </span><span style=color:#ed9366>=</span><span> asset_reader</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> buffer)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    hasher</span><span style=color:#ed9366>.</span><span style=color:#f07171>update</span><span>(</span><span style=color:#ed9366>&</span><span>buffer[</span><span style=color:#ed9366>..</span><span>bytes_read])</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if</span><span> bytes_read </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0 </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// This means we've reached EOF, so we're done consuming asset bytes.
</span><span>        </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The change replaces the condition <code>bytes_read < buffer.len()</code> with <code>bytes_read == 0</code>. This ensures the loop continues until the reader returns exactly zero bytes, which is the correct indicator that the end of the file has been reached. The previous condition would break the loop prematurely if the buffer was only partially filled, even if more data was available in the file.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Rust Async I/O Patterns</strong>: The <code>tokio::io::AsyncRead</code> trait documentation provides details on how read operations signal EOF by returning <code>Ok(0)</code>.<li><strong>Bevy Asset System</strong>: The Bevy book’s section on assets explains how the asset system uses hashes for caching and change detection.<li><strong>Stream Processing</strong>: General patterns for processing large files in chunks without loading them entirely into memory.<li><strong>Hash Functions in Rust</strong>: How cryptographic and non-cryptographic hash functions work and their use cases in game engines for asset identification.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22100.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>