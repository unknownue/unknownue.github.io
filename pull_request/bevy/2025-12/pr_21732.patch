diff --git a/crates/bevy_asset/src/render_asset.rs b/crates/bevy_asset/src/render_asset.rs
index 583ee45457895..90855e86e3389 100644
--- a/crates/bevy_asset/src/render_asset.rs
+++ b/crates/bevy_asset/src/render_asset.rs
@@ -4,12 +4,13 @@ use serde::{Deserialize, Serialize};
 bitflags::bitflags! {
     /// Defines where the asset will be used.
     ///
-    /// If an asset is set to the `RENDER_WORLD` but not the `MAIN_WORLD`, the asset will be
-    /// unloaded from the asset server once it's been extracted and prepared in the render world.
+    /// If an asset is set to the `RENDER_WORLD` but not the `MAIN_WORLD`, the asset data (pixel data,
+    /// mesh vertex data, etc) will be removed from the cpu-side asset once it's been extracted and prepared
+    /// in the render world. The asset will remain in the assets collection, but with only metadata.
     ///
-    /// Unloading the asset saves on memory, as for most cases it is no longer necessary to keep
-    /// it in RAM once it's been uploaded to the GPU's VRAM. However, this means you can no longer
-    /// access the asset from the CPU (via the `Assets<T>` resource) once unloaded (without re-loading it).
+    /// Unloading the asset data saves on memory, as for most cases it is no longer necessary to keep
+    /// it in RAM once it's been uploaded to the GPU's VRAM. However, this means you cannot access the
+    /// asset data from the CPU (via the `Assets<T>` resource) once unloaded (without re-loading it).
     ///
     /// If you never need access to the asset from the CPU past the first frame it's loaded on,
     /// or only need very infrequent access, then set this to `RENDER_WORLD`. Otherwise, set this to
diff --git a/crates/bevy_camera/src/primitives.rs b/crates/bevy_camera/src/primitives.rs
index 1f3abe97ed6f3..4b031b895edc6 100644
--- a/crates/bevy_camera/src/primitives.rs
+++ b/crates/bevy_camera/src/primitives.rs
@@ -18,8 +18,13 @@ pub trait MeshAabb {
 
 impl MeshAabb for Mesh {
     fn compute_aabb(&self) -> Option<Aabb> {
-        let Some(VertexAttributeValues::Float32x3(values)) =
-            self.attribute(Mesh::ATTRIBUTE_POSITION)
+        if let Some(aabb) = self.final_aabb {
+            // use precomputed extents
+            return Some(aabb.into());
+        }
+
+        let Ok(VertexAttributeValues::Float32x3(values)) =
+            self.try_attribute(Mesh::ATTRIBUTE_POSITION)
         else {
             return None;
         };
diff --git a/crates/bevy_mesh/src/index.rs b/crates/bevy_mesh/src/index.rs
index 87d81cc3f2fa2..f5fd850562f9a 100644
--- a/crates/bevy_mesh/src/index.rs
+++ b/crates/bevy_mesh/src/index.rs
@@ -6,6 +6,8 @@ use serde::{Deserialize, Serialize};
 use thiserror::Error;
 use wgpu_types::IndexFormat;
 
+use crate::MeshAccessError;
+
 /// A disjunction of four iterators. This is necessary to have a well-formed type for the output
 /// of [`Mesh::triangles`](super::Mesh::triangles), which produces iterators of four different types depending on the
 /// branch taken.
@@ -47,6 +49,8 @@ pub enum MeshWindingInvertError {
     /// * [`PrimitiveTopology::LineList`](super::PrimitiveTopology::LineList), but the indices are not in chunks of 2.
     #[error("Indices weren't in chunks according to topology")]
     AbruptIndicesEnd,
+    #[error("Mesh access error: {0}")]
+    MeshAccessError(#[from] MeshAccessError),
 }
 
 /// An error that occurred while trying to extract a collection of triangles from a [`Mesh`](super::Mesh).
@@ -55,17 +59,13 @@ pub enum MeshTrianglesError {
     #[error("Source mesh does not have primitive topology TriangleList or TriangleStrip")]
     WrongTopology,
 
-    #[error("Source mesh lacks position data")]
-    MissingPositions,
-
     #[error("Source mesh position data is not Float32x3")]
     PositionsFormat,
 
-    #[error("Source mesh lacks face index data")]
-    MissingIndices,
-
     #[error("Face index data references vertices that do not exist")]
     BadIndices,
+    #[error("mesh access error: {0}")]
+    MeshAccessError(#[from] MeshAccessError),
 }
 
 /// An array of indices into the [`VertexAttributeValues`](super::VertexAttributeValues) for a mesh.
diff --git a/crates/bevy_mesh/src/mesh.rs b/crates/bevy_mesh/src/mesh.rs
index 3ff416f89221d..ca224d6e286eb 100644
--- a/crates/bevy_mesh/src/mesh.rs
+++ b/crates/bevy_mesh/src/mesh.rs
@@ -15,7 +15,7 @@ use bevy_asset::Handle;
 use bevy_asset::{Asset, RenderAssetUsages};
 #[cfg(feature = "morph")]
 use bevy_image::Image;
-use bevy_math::{primitives::Triangle3d, *};
+use bevy_math::{bounding::Aabb3d, primitives::Triangle3d, *};
 #[cfg(feature = "serialize")]
 use bevy_platform::collections::HashMap;
 use bevy_reflect::Reflect;
@@ -29,6 +29,110 @@ use wgpu_types::{VertexAttribute, VertexFormat, VertexStepMode};
 pub const INDEX_BUFFER_ASSET_INDEX: u64 = 0;
 pub const VERTEX_ATTRIBUTE_BUFFER_ID: u64 = 10;
 
+/// Error from accessing mesh vertex attributes or indices
+#[derive(Error, Debug, Clone)]
+pub enum MeshAccessError {
+    #[error("The mesh vertex/index data has been extracted to the RenderWorld (via `Mesh::asset_usage`)")]
+    ExtractedToRenderWorld,
+    #[error("The requested mesh data wasn't found in this mesh")]
+    NotFound,
+}
+
+const MESH_EXTRACTED_ERROR: &str = "Mesh has been extracted to RenderWorld. To access vertex attributes, the mesh `asset_usage` must include `MAIN_WORLD`";
+
+// storage for extractable data with access methods which return errors if the
+// contents have already been extracted
+#[derive(Debug, Clone, PartialEq, Reflect, Default)]
+enum MeshExtractableData<T> {
+    Data(T),
+    #[default]
+    NoData,
+    ExtractedToRenderWorld,
+}
+
+impl<T> MeshExtractableData<T> {
+    // get a reference to internal data. returns error if data has been extracted, or if no
+    // data exists
+    fn as_ref(&self) -> Result<&T, MeshAccessError> {
+        match self {
+            MeshExtractableData::Data(data) => Ok(data),
+            MeshExtractableData::NoData => Err(MeshAccessError::NotFound),
+            MeshExtractableData::ExtractedToRenderWorld => {
+                Err(MeshAccessError::ExtractedToRenderWorld)
+            }
+        }
+    }
+
+    // get an optional reference to internal data. returns error if data has been extracted
+    fn as_ref_option(&self) -> Result<Option<&T>, MeshAccessError> {
+        match self {
+            MeshExtractableData::Data(data) => Ok(Some(data)),
+            MeshExtractableData::NoData => Ok(None),
+            MeshExtractableData::ExtractedToRenderWorld => {
+                Err(MeshAccessError::ExtractedToRenderWorld)
+            }
+        }
+    }
+
+    // get a mutable reference to internal data. returns error if data has been extracted,
+    // or if no data exists
+    fn as_mut(&mut self) -> Result<&mut T, MeshAccessError> {
+        match self {
+            MeshExtractableData::Data(data) => Ok(data),
+            MeshExtractableData::NoData => Err(MeshAccessError::NotFound),
+            MeshExtractableData::ExtractedToRenderWorld => {
+                Err(MeshAccessError::ExtractedToRenderWorld)
+            }
+        }
+    }
+
+    // get an optional mutable reference to internal data. returns error if data has been extracted
+    fn as_mut_option(&mut self) -> Result<Option<&mut T>, MeshAccessError> {
+        match self {
+            MeshExtractableData::Data(data) => Ok(Some(data)),
+            MeshExtractableData::NoData => Ok(None),
+            MeshExtractableData::ExtractedToRenderWorld => {
+                Err(MeshAccessError::ExtractedToRenderWorld)
+            }
+        }
+    }
+
+    // extract data and replace self with `ExtractedToRenderWorld`. returns error if
+    // data has been extracted
+    fn extract(&mut self) -> Result<MeshExtractableData<T>, MeshAccessError> {
+        match core::mem::replace(self, MeshExtractableData::ExtractedToRenderWorld) {
+            MeshExtractableData::ExtractedToRenderWorld => {
+                Err(MeshAccessError::ExtractedToRenderWorld)
+            }
+            not_extracted => Ok(not_extracted),
+        }
+    }
+
+    // replace internal data. returns the existing data, or an error if data has been extracted
+    fn replace(
+        &mut self,
+        data: impl Into<MeshExtractableData<T>>,
+    ) -> Result<Option<T>, MeshAccessError> {
+        match core::mem::replace(self, data.into()) {
+            MeshExtractableData::ExtractedToRenderWorld => {
+                *self = MeshExtractableData::ExtractedToRenderWorld;
+                Err(MeshAccessError::ExtractedToRenderWorld)
+            }
+            MeshExtractableData::Data(t) => Ok(Some(t)),
+            MeshExtractableData::NoData => Ok(None),
+        }
+    }
+}
+
+impl<T> From<Option<T>> for MeshExtractableData<T> {
+    fn from(value: Option<T>) -> Self {
+        match value {
+            Some(data) => MeshExtractableData::Data(data),
+            None => MeshExtractableData::NoData,
+        }
+    }
+}
+
 /// A 3D object made out of vertices representing triangles, lines, or points,
 /// with "attribute" values for each vertex.
 ///
@@ -128,12 +232,12 @@ pub struct Mesh {
     /// Uses a [`BTreeMap`] because, unlike `HashMap`, it has a defined iteration order,
     /// which allows easy stable `VertexBuffers` (i.e. same buffer order)
     #[reflect(ignore, clone)]
-    attributes: BTreeMap<MeshVertexAttributeId, MeshAttributeData>,
-    indices: Option<Indices>,
+    attributes: MeshExtractableData<BTreeMap<MeshVertexAttributeId, MeshAttributeData>>,
+    indices: MeshExtractableData<Indices>,
     #[cfg(feature = "morph")]
-    morph_targets: Option<Handle<Image>>,
+    morph_targets: MeshExtractableData<Handle<Image>>,
     #[cfg(feature = "morph")]
-    morph_target_names: Option<Vec<String>>,
+    morph_target_names: MeshExtractableData<Vec<String>>,
     pub asset_usage: RenderAssetUsages,
     /// Whether or not to build a BLAS for use with `bevy_solari` raytracing.
     ///
@@ -150,6 +254,9 @@ pub struct Mesh {
     /// Does nothing if not used with `bevy_solari`, or if the mesh is not compatible
     /// with `bevy_solari` (see `bevy_solari`'s docs).
     pub enable_raytracing: bool,
+    /// Precomputed min and max extents of the mesh position data. Used mainly for constructing `Aabb`s for frustum culling.
+    /// This data will be set if/when a mesh is extracted to the GPU
+    pub final_aabb: Option<Aabb3d>,
 }
 
 impl Mesh {
@@ -233,14 +340,15 @@ impl Mesh {
     pub fn new(primitive_topology: PrimitiveTopology, asset_usage: RenderAssetUsages) -> Self {
         Mesh {
             primitive_topology,
-            attributes: Default::default(),
-            indices: None,
+            attributes: MeshExtractableData::Data(Default::default()),
+            indices: MeshExtractableData::NoData,
             #[cfg(feature = "morph")]
-            morph_targets: None,
+            morph_targets: MeshExtractableData::NoData,
             #[cfg(feature = "morph")]
-            morph_target_names: None,
+            morph_target_names: MeshExtractableData::NoData,
             asset_usage,
             enable_raytracing: true,
+            final_aabb: None,
         }
     }
 
@@ -256,12 +364,33 @@ impl Mesh {
     ///
     /// # Panics
     /// Panics when the format of the values does not match the attribute's format.
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_insert_attribute`]
     #[inline]
     pub fn insert_attribute(
         &mut self,
         attribute: MeshVertexAttribute,
         values: impl Into<VertexAttributeValues>,
     ) {
+        self.try_insert_attribute(attribute, values)
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Sets the data for a vertex attribute (position, normal, etc.). The name will
+    /// often be one of the associated constants such as [`Mesh::ATTRIBUTE_POSITION`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    ///
+    /// # Panics
+    /// Panics when the format of the values does not match the attribute's format.
+    #[inline]
+    pub fn try_insert_attribute(
+        &mut self,
+        attribute: MeshVertexAttribute,
+        values: impl Into<VertexAttributeValues>,
+    ) -> Result<(), MeshAccessError> {
         let values = values.into();
         let values_format = VertexFormat::from(&values);
         if values_format != attribute.format {
@@ -272,7 +401,9 @@ impl Mesh {
         }
 
         self.attributes
+            .as_mut()?
             .insert(attribute.id, MeshAttributeData { attribute, values });
+        Ok(())
     }
 
     /// Consumes the mesh and returns a mesh with data set for a vertex attribute (position, normal, etc.).
@@ -284,6 +415,8 @@ impl Mesh {
     ///
     /// # Panics
     /// Panics when the format of the values does not match the attribute's format.
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_inserted_attribute`]
     #[must_use]
     #[inline]
     pub fn with_inserted_attribute(
@@ -295,83 +428,272 @@ impl Mesh {
         self
     }
 
+    /// Consumes the mesh and returns a mesh with data set for a vertex attribute (position, normal, etc.).
+    /// The name will often be one of the associated constants such as [`Mesh::ATTRIBUTE_POSITION`].
+    ///
+    /// (Alternatively, you can use [`Mesh::insert_attribute`] to mutate an existing mesh in-place)
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_with_inserted_attribute(
+        mut self,
+        attribute: MeshVertexAttribute,
+        values: impl Into<VertexAttributeValues>,
+    ) -> Result<Self, MeshAccessError> {
+        self.try_insert_attribute(attribute, values)?;
+        Ok(self)
+    }
+
     /// Removes the data for a vertex attribute
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_remove_attribute`]
     pub fn remove_attribute(
         &mut self,
         attribute: impl Into<MeshVertexAttributeId>,
     ) -> Option<VertexAttributeValues> {
         self.attributes
+            .as_mut()
+            .expect(MESH_EXTRACTED_ERROR)
             .remove(&attribute.into())
             .map(|data| data.values)
     }
 
+    /// Removes the data for a vertex attribute
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`or
+    /// if the attribute does not exist.
+    pub fn try_remove_attribute(
+        &mut self,
+        attribute: impl Into<MeshVertexAttributeId>,
+    ) -> Result<VertexAttributeValues, MeshAccessError> {
+        Ok(self
+            .attributes
+            .as_mut()?
+            .remove(&attribute.into())
+            .ok_or(MeshAccessError::NotFound)?
+            .values)
+    }
+
     /// Consumes the mesh and returns a mesh without the data for a vertex attribute
     ///
     /// (Alternatively, you can use [`Mesh::remove_attribute`] to mutate an existing mesh in-place)
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_removed_attribute`]
     #[must_use]
     pub fn with_removed_attribute(mut self, attribute: impl Into<MeshVertexAttributeId>) -> Self {
         self.remove_attribute(attribute);
         self
     }
 
+    /// Consumes the mesh and returns a mesh without the data for a vertex attribute
+    ///
+    /// (Alternatively, you can use [`Mesh::remove_attribute`] to mutate an existing mesh in-place)
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`or
+    /// if the attribute does not exist.
+    pub fn try_with_removed_attribute(
+        mut self,
+        attribute: impl Into<MeshVertexAttributeId>,
+    ) -> Result<Self, MeshAccessError> {
+        self.try_remove_attribute(attribute)?;
+        Ok(self)
+    }
+
+    /// Returns a bool indicating if the attribute is present in this mesh's vertex data.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_contains_attribute`]
     #[inline]
     pub fn contains_attribute(&self, id: impl Into<MeshVertexAttributeId>) -> bool {
-        self.attributes.contains_key(&id.into())
+        self.attributes
+            .as_ref()
+            .expect(MESH_EXTRACTED_ERROR)
+            .contains_key(&id.into())
+    }
+
+    /// Returns a bool indicating if the attribute is present in this mesh's vertex data.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_contains_attribute(
+        &self,
+        id: impl Into<MeshVertexAttributeId>,
+    ) -> Result<bool, MeshAccessError> {
+        Ok(self.attributes.as_ref()?.contains_key(&id.into()))
     }
 
     /// Retrieves the data currently set to the vertex attribute with the specified [`MeshVertexAttributeId`].
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_attribute`] or [`Mesh::try_attribute_option`]
     #[inline]
     pub fn attribute(
         &self,
         id: impl Into<MeshVertexAttributeId>,
     ) -> Option<&VertexAttributeValues> {
-        self.attributes.get(&id.into()).map(|data| &data.values)
+        self.try_attribute_option(id).expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Retrieves the data currently set to the vertex attribute with the specified [`MeshVertexAttributeId`].
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`or
+    /// if the attribute does not exist.
+    #[inline]
+    pub fn try_attribute(
+        &self,
+        id: impl Into<MeshVertexAttributeId>,
+    ) -> Result<&VertexAttributeValues, MeshAccessError> {
+        self.try_attribute_option(id)?
+            .ok_or(MeshAccessError::NotFound)
+    }
+
+    /// Retrieves the data currently set to the vertex attribute with the specified [`MeshVertexAttributeId`].
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_attribute_option(
+        &self,
+        id: impl Into<MeshVertexAttributeId>,
+    ) -> Result<Option<&VertexAttributeValues>, MeshAccessError> {
+        Ok(self
+            .attributes
+            .as_ref()?
+            .get(&id.into())
+            .map(|data| &data.values))
     }
 
     /// Retrieves the full data currently set to the vertex attribute with the specified [`MeshVertexAttributeId`].
     #[inline]
-    pub(crate) fn attribute_data(
+    pub(crate) fn try_attribute_data(
         &self,
         id: impl Into<MeshVertexAttributeId>,
-    ) -> Option<&MeshAttributeData> {
-        self.attributes.get(&id.into())
+    ) -> Result<Option<&MeshAttributeData>, MeshAccessError> {
+        Ok(self.attributes.as_ref()?.get(&id.into()))
     }
 
     /// Retrieves the data currently set to the vertex attribute with the specified `name` mutably.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_attribute_mut`]
     #[inline]
     pub fn attribute_mut(
         &mut self,
         id: impl Into<MeshVertexAttributeId>,
     ) -> Option<&mut VertexAttributeValues> {
-        self.attributes
+        self.try_attribute_mut_option(id)
+            .expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Retrieves the data currently set to the vertex attribute with the specified `name` mutably.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`or
+    /// if the attribute does not exist.
+    #[inline]
+    pub fn try_attribute_mut(
+        &mut self,
+        id: impl Into<MeshVertexAttributeId>,
+    ) -> Result<&mut VertexAttributeValues, MeshAccessError> {
+        self.try_attribute_mut_option(id)?
+            .ok_or(MeshAccessError::NotFound)
+    }
+
+    /// Retrieves the data currently set to the vertex attribute with the specified `name` mutably.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_attribute_mut_option(
+        &mut self,
+        id: impl Into<MeshVertexAttributeId>,
+    ) -> Result<Option<&mut VertexAttributeValues>, MeshAccessError> {
+        Ok(self
+            .attributes
+            .as_mut()?
             .get_mut(&id.into())
-            .map(|data| &mut data.values)
+            .map(|data| &mut data.values))
     }
 
     /// Returns an iterator that yields references to the data of each vertex attribute.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_attributes`]
     pub fn attributes(
         &self,
     ) -> impl Iterator<Item = (&MeshVertexAttribute, &VertexAttributeValues)> {
-        self.attributes
+        self.try_attributes().expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Returns an iterator that yields references to the data of each vertex attribute.
+    /// Returns an error if data has been extracted to `RenderWorld`
+    pub fn try_attributes(
+        &self,
+    ) -> Result<impl Iterator<Item = (&MeshVertexAttribute, &VertexAttributeValues)>, MeshAccessError>
+    {
+        Ok(self
+            .attributes
+            .as_ref()?
             .values()
-            .map(|data| (&data.attribute, &data.values))
+            .map(|data| (&data.attribute, &data.values)))
     }
 
     /// Returns an iterator that yields mutable references to the data of each vertex attribute.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_attributes_mut`]
     pub fn attributes_mut(
         &mut self,
     ) -> impl Iterator<Item = (&MeshVertexAttribute, &mut VertexAttributeValues)> {
-        self.attributes
+        self.try_attributes_mut().expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Returns an iterator that yields mutable references to the data of each vertex attribute.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn try_attributes_mut(
+        &mut self,
+    ) -> Result<
+        impl Iterator<Item = (&MeshVertexAttribute, &mut VertexAttributeValues)>,
+        MeshAccessError,
+    > {
+        Ok(self
+            .attributes
+            .as_mut()?
             .values_mut()
-            .map(|data| (&data.attribute, &mut data.values))
+            .map(|data| (&data.attribute, &mut data.values)))
     }
 
     /// Sets the vertex indices of the mesh. They describe how triangles are constructed out of the
     /// vertex attributes and are therefore only useful for the [`PrimitiveTopology`] variants
     /// that use triangles.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_insert_indices`]
     #[inline]
     pub fn insert_indices(&mut self, indices: Indices) {
-        self.indices = Some(indices);
+        self.indices
+            .replace(Some(indices))
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Sets the vertex indices of the mesh. They describe how triangles are constructed out of the
+    /// vertex attributes and are therefore only useful for the [`PrimitiveTopology`] variants
+    /// that use triangles.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_insert_indices(&mut self, indices: Indices) -> Result<(), MeshAccessError> {
+        self.indices.replace(Some(indices))?;
+        Ok(())
     }
 
     /// Consumes the mesh and returns a mesh with the given vertex indices. They describe how triangles
@@ -379,6 +701,10 @@ impl Mesh {
     /// [`PrimitiveTopology`] variants that use triangles.
     ///
     /// (Alternatively, you can use [`Mesh::insert_indices`] to mutate an existing mesh in-place)
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_inserted_indices`]
     #[must_use]
     #[inline]
     pub fn with_inserted_indices(mut self, indices: Indices) -> Self {
@@ -386,42 +712,126 @@ impl Mesh {
         self
     }
 
-    /// Retrieves the vertex `indices` of the mesh.
+    /// Consumes the mesh and returns a mesh with the given vertex indices. They describe how triangles
+    /// are constructed out of the vertex attributes and are therefore only useful for the
+    /// [`PrimitiveTopology`] variants that use triangles.
+    ///
+    /// (Alternatively, you can use [`Mesh::try_insert_indices`] to mutate an existing mesh in-place)
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_with_inserted_indices(mut self, indices: Indices) -> Result<Self, MeshAccessError> {
+        self.try_insert_indices(indices)?;
+        Ok(self)
+    }
+
+    /// Retrieves the vertex `indices` of the mesh, returns None if not found.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_indices`]
     #[inline]
     pub fn indices(&self) -> Option<&Indices> {
+        self.indices.as_ref_option().expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Retrieves the vertex `indices` of the mesh.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`or
+    /// if the attribute does not exist.
+    #[inline]
+    pub fn try_indices(&self) -> Result<&Indices, MeshAccessError> {
         self.indices.as_ref()
     }
 
+    /// Retrieves the vertex `indices` of the mesh, returns None if not found.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_indices_option(&self) -> Result<Option<&Indices>, MeshAccessError> {
+        self.indices.as_ref_option()
+    }
+
     /// Retrieves the vertex `indices` of the mesh mutably.
     #[inline]
     pub fn indices_mut(&mut self) -> Option<&mut Indices> {
+        self.try_indices_mut_option().expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Retrieves the vertex `indices` of the mesh mutably.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_indices_mut(&mut self) -> Result<&mut Indices, MeshAccessError> {
         self.indices.as_mut()
     }
 
+    /// Retrieves the vertex `indices` of the mesh mutably.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_indices_mut_option(&mut self) -> Result<Option<&mut Indices>, MeshAccessError> {
+        self.indices.as_mut_option()
+    }
+
     /// Removes the vertex `indices` from the mesh and returns them.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_remove_indices`]
     #[inline]
     pub fn remove_indices(&mut self) -> Option<Indices> {
-        core::mem::take(&mut self.indices)
+        self.try_remove_indices().expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Removes the vertex `indices` from the mesh and returns them.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    #[inline]
+    pub fn try_remove_indices(&mut self) -> Result<Option<Indices>, MeshAccessError> {
+        self.indices.replace(None)
     }
 
     /// Consumes the mesh and returns a mesh without the vertex `indices` of the mesh.
     ///
     /// (Alternatively, you can use [`Mesh::remove_indices`] to mutate an existing mesh in-place)
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_removed_indices`]
     #[must_use]
     pub fn with_removed_indices(mut self) -> Self {
         self.remove_indices();
         self
     }
 
+    /// Consumes the mesh and returns a mesh without the vertex `indices` of the mesh.
+    ///
+    /// (Alternatively, you can use [`Mesh::try_remove_indices`] to mutate an existing mesh in-place)
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn try_with_removed_indices(mut self) -> Result<Self, MeshAccessError> {
+        self.try_remove_indices()?;
+        Ok(self)
+    }
+
     /// Returns the size of a vertex in bytes.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`.
     pub fn get_vertex_size(&self) -> u64 {
         self.attributes
+            .as_ref()
+            .expect(MESH_EXTRACTED_ERROR)
             .values()
             .map(|data| data.attribute.format.size())
             .sum()
     }
 
     /// Returns the size required for the vertex buffer in bytes.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`.
     pub fn get_vertex_buffer_size(&self) -> usize {
         let vertex_size = self.get_vertex_size() as usize;
         let vertex_count = self.count_vertices();
@@ -430,22 +840,32 @@ impl Mesh {
 
     /// Computes and returns the index data of the mesh as bytes.
     /// This is used to transform the index data into a GPU friendly format.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`.
     pub fn get_index_buffer_bytes(&self) -> Option<&[u8]> {
-        self.indices.as_ref().map(|indices| match &indices {
+        let mesh_indices = self.indices.as_ref_option().expect(MESH_EXTRACTED_ERROR);
+
+        mesh_indices.as_ref().map(|indices| match &indices {
             Indices::U16(indices) => cast_slice(&indices[..]),
             Indices::U32(indices) => cast_slice(&indices[..]),
         })
     }
 
     /// Get this `Mesh`'s [`MeshVertexBufferLayout`], used in `SpecializedMeshPipeline`.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`.
     pub fn get_mesh_vertex_buffer_layout(
         &self,
         mesh_vertex_buffer_layouts: &mut MeshVertexBufferLayouts,
     ) -> MeshVertexBufferLayoutRef {
-        let mut attributes = Vec::with_capacity(self.attributes.len());
-        let mut attribute_ids = Vec::with_capacity(self.attributes.len());
+        let mesh_attributes = self.attributes.as_ref().expect(MESH_EXTRACTED_ERROR);
+
+        let mut attributes = Vec::with_capacity(mesh_attributes.len());
+        let mut attribute_ids = Vec::with_capacity(mesh_attributes.len());
         let mut accumulated_offset = 0;
-        for (index, data) in self.attributes.values().enumerate() {
+        for (index, data) in mesh_attributes.values().enumerate() {
             attribute_ids.push(data.attribute.id);
             attributes.push(VertexAttribute {
                 offset: accumulated_offset,
@@ -469,14 +889,18 @@ impl Mesh {
     /// Counts all vertices of the mesh.
     ///
     /// If the attributes have different vertex counts, the smallest is returned.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`.
     pub fn count_vertices(&self) -> usize {
         let mut vertex_count: Option<usize> = None;
-        for (attribute_id, attribute_data) in &self.attributes {
+        let mesh_attributes = self.attributes.as_ref().expect(MESH_EXTRACTED_ERROR);
+
+        for (attribute_id, attribute_data) in mesh_attributes {
             let attribute_len = attribute_data.values.len();
             if let Some(previous_vertex_count) = vertex_count {
                 if previous_vertex_count != attribute_len {
-                    let name = self
-                        .attributes
+                    let name = mesh_attributes
                         .get(attribute_id)
                         .map(|data| data.attribute.name.to_string())
                         .unwrap_or_else(|| format!("{attribute_id:?}"));
@@ -502,6 +926,9 @@ impl Mesh {
     ///
     /// This is a convenience method which allocates a Vec.
     /// Prefer pre-allocating and using [`Mesh::write_packed_vertex_buffer_data`] when possible.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`.
     pub fn create_packed_vertex_buffer_data(&self) -> Vec<u8> {
         let mut attributes_interleaved_buffer = vec![0; self.get_vertex_buffer_size()];
         self.write_packed_vertex_buffer_data(&mut attributes_interleaved_buffer);
@@ -514,12 +941,17 @@ impl Mesh {
     ///
     /// If the vertex attributes have different lengths, they are all truncated to
     /// the length of the smallest.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`.
     pub fn write_packed_vertex_buffer_data(&self, slice: &mut [u8]) {
+        let mesh_attributes = self.attributes.as_ref().expect(MESH_EXTRACTED_ERROR);
+
         let vertex_size = self.get_vertex_size() as usize;
         let vertex_count = self.count_vertices();
         // bundle into interleaved buffers
         let mut attribute_offset = 0;
-        for attribute_data in self.attributes.values() {
+        for attribute_data in mesh_attributes.values() {
             let attribute_size = attribute_data.attribute.format.size() as usize;
             let attributes_bytes = attribute_data.values.get_bytes();
             for (vertex_index, attribute_bytes) in attributes_bytes
@@ -539,16 +971,32 @@ impl Mesh {
     ///
     /// This can dramatically increase the vertex count, so make sure this is what you want.
     /// Does nothing if no [Indices] are set.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_duplicate_vertices`]
     pub fn duplicate_vertices(&mut self) {
+        self.try_duplicate_vertices().expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Duplicates the vertex attributes so that no vertices are shared.
+    ///
+    /// This can dramatically increase the vertex count, so make sure this is what you want.
+    /// Does nothing if no [Indices] are set.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn try_duplicate_vertices(&mut self) -> Result<(), MeshAccessError> {
         fn duplicate<T: Copy>(values: &[T], indices: impl Iterator<Item = usize>) -> Vec<T> {
             indices.map(|i| values[i]).collect()
         }
 
-        let Some(indices) = self.indices.take() else {
-            return;
+        let Some(indices) = self.indices.replace(None)? else {
+            return Ok(());
         };
 
-        for attributes in self.attributes.values_mut() {
+        let mesh_attributes = self.attributes.as_mut()?;
+
+        for attributes in mesh_attributes.values_mut() {
             let indices = indices.iter();
             #[expect(
                 clippy::match_same_arms,
@@ -585,6 +1033,8 @@ impl Mesh {
                 VertexAttributeValues::Unorm8x4(vec) => *vec = duplicate(vec, indices),
             }
         }
+
+        Ok(())
     }
 
     /// Consumes the mesh and returns a mesh with no shared vertices.
@@ -593,12 +1043,29 @@ impl Mesh {
     /// Does nothing if no [`Indices`] are set.
     ///
     /// (Alternatively, you can use [`Mesh::duplicate_vertices`] to mutate an existing mesh in-place)
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_duplicated_vertices`]
     #[must_use]
     pub fn with_duplicated_vertices(mut self) -> Self {
         self.duplicate_vertices();
         self
     }
 
+    /// Consumes the mesh and returns a mesh with no shared vertices.
+    ///
+    /// This can dramatically increase the vertex count, so make sure this is what you want.
+    /// Does nothing if no [`Indices`] are set.
+    ///
+    /// (Alternatively, you can use [`Mesh::try_duplicate_vertices`] to mutate an existing mesh in-place)
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn try_with_duplicated_vertices(mut self) -> Result<Self, MeshAccessError> {
+        self.try_duplicate_vertices()?;
+        Ok(self)
+    }
+
     /// Inverts the winding of the indices such that all counter-clockwise triangles are now
     /// clockwise and vice versa.
     /// For lines, their start and end indices are flipped.
@@ -640,7 +1107,10 @@ impl Mesh {
                 _ => Err(MeshWindingInvertError::WrongTopology),
             }
         }
-        match &mut self.indices {
+
+        let mesh_indices = self.indices.as_mut_option()?;
+
+        match mesh_indices {
             Some(Indices::U16(vec)) => invert(vec, self.primitive_topology),
             Some(Indices::U32(vec)) => invert(vec, self.primitive_topology),
             None => Ok(()),
@@ -662,15 +1132,28 @@ impl Mesh {
     /// # Panics
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].=
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_compute_normals`]
     pub fn compute_normals(&mut self) {
+        self.try_compute_normals().expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of a mesh.
+    /// If the mesh is indexed, this defaults to smooth normals. Otherwise, it defaults to flat
+    /// normals.
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].=
+    pub fn try_compute_normals(&mut self) -> Result<(), MeshAccessError> {
         assert!(
             matches!(self.primitive_topology, PrimitiveTopology::TriangleList),
             "`compute_normals` can only work on `TriangleList`s"
         );
-        if self.indices().is_none() {
-            self.compute_flat_normals();
+        if self.try_indices_option()?.is_none() {
+            self.try_compute_flat_normals()
         } else {
-            self.compute_smooth_normals();
+            self.try_compute_smooth_normals()
         }
     }
 
@@ -681,13 +1164,30 @@ impl Mesh {
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
     /// Consider calling [`Mesh::duplicate_vertices`] or exporting your mesh with normal
     /// attributes.
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_compute_flat_normals`]
     ///
     /// FIXME: This should handle more cases since this is called as a part of gltf
     /// mesh loading where we can't really blame users for loading meshes that might
     /// not conform to the limitations here!
     pub fn compute_flat_normals(&mut self) {
+        self.try_compute_flat_normals().expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of a mesh.
+    ///
+    /// # Panics
+    /// Panics if [`Indices`] are set or [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Consider calling [`Mesh::duplicate_vertices`] or exporting your mesh with normal
+    /// attributes.
+    ///
+    /// FIXME: This should handle more cases since this is called as a part of gltf
+    /// mesh loading where we can't really blame users for loading meshes that might
+    /// not conform to the limitations here!
+    pub fn try_compute_flat_normals(&mut self) -> Result<(), MeshAccessError> {
         assert!(
-            self.indices().is_none(),
+            self.try_indices_option()?.is_none(),
             "`compute_flat_normals` can't work on indexed geometry. Consider calling either `Mesh::compute_smooth_normals` or `Mesh::duplicate_vertices` followed by `Mesh::compute_flat_normals`."
         );
         assert!(
@@ -696,8 +1196,7 @@ impl Mesh {
         );
 
         let positions = self
-            .attribute(Mesh::ATTRIBUTE_POSITION)
-            .unwrap()
+            .try_attribute(Mesh::ATTRIBUTE_POSITION)?
             .as_float3()
             .expect("`Mesh::ATTRIBUTE_POSITION` vertex attributes should be of type `float3`");
 
@@ -707,7 +1206,7 @@ impl Mesh {
             .flat_map(|normal| [normal; 3])
             .collect();
 
-        self.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
+        self.try_insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals)
     }
 
     /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of an indexed mesh, smoothing normals for shared
@@ -726,8 +1225,31 @@ impl Mesh {
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
     /// Panics if the mesh does not have indices defined.
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_compute_smooth_normals`]
     pub fn compute_smooth_normals(&mut self) {
-        self.compute_custom_smooth_normals(|[a, b, c], positions, normals| {
+        self.try_compute_smooth_normals()
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of an indexed mesh, smoothing normals for shared
+    /// vertices.
+    ///
+    /// This method weights normals by the angles of the corners of connected triangles, thus
+    /// eliminating triangle area and count as factors in the final normal. This does make it
+    /// somewhat slower than [`Mesh::compute_area_weighted_normals`] which does not need to
+    /// greedily normalize each triangle's normal or calculate corner angles.
+    ///
+    /// If you would rather have the computed normals be weighted by triangle area, see
+    /// [`Mesh::compute_area_weighted_normals`] instead. If you need to weight them in some other
+    /// way, see [`Mesh::compute_custom_smooth_normals`].
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Panics if the mesh does not have indices defined.
+    pub fn try_compute_smooth_normals(&mut self) -> Result<(), MeshAccessError> {
+        self.try_compute_custom_smooth_normals(|[a, b, c], positions, normals| {
             let pa = Vec3::from(positions[a]);
             let pb = Vec3::from(positions[b]);
             let pc = Vec3::from(positions[c]);
@@ -761,7 +1283,32 @@ impl Mesh {
             normals[a] += normal * weight_a;
             normals[b] += normal * weight_b;
             normals[c] += normal * weight_c;
-        });
+        })
+    }
+
+    /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of an indexed mesh, smoothing normals for shared
+    /// vertices.
+    ///
+    /// This method weights normals by the area of each triangle containing the vertex. Thus,
+    /// larger triangles will skew the normals of their vertices towards their own normal more
+    /// than smaller triangles will.
+    ///
+    /// This method is actually somewhat faster than [`Mesh::compute_smooth_normals`] because an
+    /// intermediate result of triangle normal calculation is already scaled by the triangle's area.
+    ///
+    /// If you would rather have the computed normals be influenced only by the angles of connected
+    /// edges, see [`Mesh::compute_smooth_normals`] instead. If you need to weight them in some
+    /// other way, see [`Mesh::compute_custom_smooth_normals`].
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Panics if the mesh does not have indices defined.
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_compute_area_weighted_normals`]
+    pub fn compute_area_weighted_normals(&mut self) {
+        self.try_compute_area_weighted_normals()
+            .expect(MESH_EXTRACTED_ERROR);
     }
 
     /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of an indexed mesh, smoothing normals for shared
@@ -782,8 +1329,8 @@ impl Mesh {
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
     /// Panics if the mesh does not have indices defined.
-    pub fn compute_area_weighted_normals(&mut self) {
-        self.compute_custom_smooth_normals(|[a, b, c], positions, normals| {
+    pub fn try_compute_area_weighted_normals(&mut self) -> Result<(), MeshAccessError> {
+        self.try_compute_custom_smooth_normals(|[a, b, c], positions, normals| {
             let normal = Vec3::from(triangle_area_normal(
                 positions[a],
                 positions[b],
@@ -792,7 +1339,7 @@ impl Mesh {
             [a, b, c].into_iter().for_each(|pos| {
                 normals[pos] += normal;
             });
-        });
+        })
     }
 
     /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of an indexed mesh, smoothing normals for shared
@@ -827,6 +1374,8 @@ impl Mesh {
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
     /// Panics if the mesh does not have indices defined.
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_compute_custom_smooth_normals`]
     //
     // FIXME: This should handle more cases since this is called as a part of gltf
     // mesh loading where we can't really blame users for loading meshes that might
@@ -839,27 +1388,75 @@ impl Mesh {
     // - [Mesh::with_computed_area_weighted_normals]
     pub fn compute_custom_smooth_normals(
         &mut self,
-        mut per_triangle: impl FnMut([usize; 3], &[[f32; 3]], &mut [Vec3]),
+        per_triangle: impl FnMut([usize; 3], &[[f32; 3]], &mut [Vec3]),
     ) {
+        self.try_compute_custom_smooth_normals(per_triangle)
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of an indexed mesh, smoothing normals for shared
+    /// vertices.
+    ///
+    /// This method allows you to customize how normals are weighted via the `per_triangle` parameter,
+    /// which must be a function or closure that accepts 3 parameters:
+    /// - The indices of the three vertices of the triangle as a `[usize; 3]`.
+    /// - A reference to the values of the [`Mesh::ATTRIBUTE_POSITION`] of the mesh (`&[[f32; 3]]`).
+    /// - A mutable reference to the sums of all normals so far.
+    ///
+    /// See also the standard methods included in Bevy for calculating smooth normals:
+    /// - [`Mesh::compute_smooth_normals`]
+    /// - [`Mesh::compute_area_weighted_normals`]
+    ///
+    /// An example that would weight each connected triangle's normal equally, thus skewing normals
+    /// towards the planes divided into the most triangles:
+    /// ```
+    /// # use bevy_asset::RenderAssetUsages;
+    /// # use bevy_mesh::{Mesh, PrimitiveTopology, Meshable, MeshBuilder};
+    /// # use bevy_math::{Vec3, primitives::Cuboid};
+    /// # let mut mesh = Cuboid::default().mesh().build();
+    /// mesh.compute_custom_smooth_normals(|[a, b, c], positions, normals| {
+    ///     let normal = Vec3::from(bevy_mesh::triangle_normal(positions[a], positions[b], positions[c]));
+    ///     for idx in [a, b, c] {
+    ///         normals[idx] += normal;
+    ///     }
+    /// });
+    /// ```
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Panics if the mesh does not have indices defined.
+    //
+    // FIXME: This should handle more cases since this is called as a part of gltf
+    // mesh loading where we can't really blame users for loading meshes that might
+    // not conform to the limitations here!
+    //
+    // When fixed, also update "Panics" sections of
+    // - [Mesh::compute_smooth_normals]
+    // - [Mesh::with_computed_smooth_normals]
+    // - [Mesh::compute_area_weighted_normals]
+    // - [Mesh::with_computed_area_weighted_normals]
+    pub fn try_compute_custom_smooth_normals(
+        &mut self,
+        mut per_triangle: impl FnMut([usize; 3], &[[f32; 3]], &mut [Vec3]),
+    ) -> Result<(), MeshAccessError> {
         assert!(
             matches!(self.primitive_topology, PrimitiveTopology::TriangleList),
             "smooth normals can only be computed on `TriangleList`s"
         );
         assert!(
-            self.indices().is_some(),
+            self.try_indices_option()?.is_some(),
             "smooth normals can only be computed on indexed meshes"
         );
 
         let positions = self
-            .attribute(Mesh::ATTRIBUTE_POSITION)
-            .unwrap()
+            .try_attribute(Mesh::ATTRIBUTE_POSITION)?
             .as_float3()
             .expect("`Mesh::ATTRIBUTE_POSITION` vertex attributes should be of type `float3`");
 
         let mut normals = vec![Vec3::ZERO; positions.len()];
 
-        self.indices()
-            .unwrap()
+        self.try_indices()?
             .iter()
             .collect::<Vec<usize>>()
             .chunks_exact(3)
@@ -869,7 +1466,7 @@ impl Mesh {
             *normal = normal.try_normalize().unwrap_or(Vec3::ZERO);
         }
 
-        self.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
+        self.try_insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals)
     }
 
     /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
@@ -881,10 +1478,26 @@ impl Mesh {
     /// # Panics
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_computed_normals`]
     #[must_use]
-    pub fn with_computed_normals(mut self) -> Self {
-        self.compute_normals();
-        self
+    pub fn with_computed_normals(self) -> Self {
+        self.try_with_computed_normals()
+            .expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
+    /// If the mesh is indexed, this defaults to smooth normals. Otherwise, it defaults to flat
+    /// normals.
+    ///
+    /// (Alternatively, you can use [`Mesh::compute_normals`] to mutate an existing mesh in-place)
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    pub fn try_with_computed_normals(mut self) -> Result<Self, MeshAccessError> {
+        self.try_compute_normals()?;
+        Ok(self)
     }
 
     /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
@@ -895,12 +1508,26 @@ impl Mesh {
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
     /// Panics if the mesh has indices defined
-    #[must_use]
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_computed_flat_normals`]
     pub fn with_computed_flat_normals(mut self) -> Self {
         self.compute_flat_normals();
         self
     }
 
+    /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
+    ///
+    /// (Alternatively, you can use [`Mesh::compute_flat_normals`] to mutate an existing mesh in-place)
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Panics if the mesh has indices defined
+    pub fn try_with_computed_flat_normals(mut self) -> Result<Self, MeshAccessError> {
+        self.try_compute_flat_normals()?;
+        Ok(self)
+    }
+
     /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
     ///
     /// (Alternatively, you can use [`Mesh::compute_smooth_normals`] to mutate an existing mesh in-place)
@@ -913,11 +1540,28 @@ impl Mesh {
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
     /// Panics if the mesh does not have indices defined.
-    #[must_use]
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_computed_smooth_normals`]
     pub fn with_computed_smooth_normals(mut self) -> Self {
         self.compute_smooth_normals();
         self
     }
+    /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
+    ///
+    /// (Alternatively, you can use [`Mesh::compute_smooth_normals`] to mutate an existing mesh in-place)
+    ///
+    /// This method weights normals by the angles of triangle corners connected to each vertex. If
+    /// you would rather have the computed normals be weighted by triangle area, see
+    /// [`Mesh::with_computed_area_weighted_normals`] instead.
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Panics if the mesh does not have indices defined.
+    pub fn try_with_computed_smooth_normals(mut self) -> Result<Self, MeshAccessError> {
+        self.try_compute_smooth_normals()?;
+        Ok(self)
+    }
 
     /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
     ///
@@ -932,12 +1576,31 @@ impl Mesh {
     /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
     /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
     /// Panics if the mesh does not have indices defined.
-    #[must_use]
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_computed_area_weighted_normals`]
     pub fn with_computed_area_weighted_normals(mut self) -> Self {
         self.compute_area_weighted_normals();
         self
     }
 
+    /// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
+    ///
+    /// (Alternatively, you can use [`Mesh::compute_area_weighted_normals`] to mutate an existing mesh in-place)
+    ///
+    /// This method weights normals by the area of each triangle containing the vertex. Thus,
+    /// larger triangles will skew the normals of their vertices towards their own normal more
+    /// than smaller triangles will. If you would rather have the computed normals be influenced
+    /// only by the angles of connected edges, see [`Mesh::with_computed_smooth_normals`] instead.
+    ///
+    /// # Panics
+    /// Panics if [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3`.
+    /// Panics if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
+    /// Panics if the mesh does not have indices defined.
+    pub fn try_with_computed_area_weighted_normals(mut self) -> Result<Self, MeshAccessError> {
+        self.try_compute_area_weighted_normals()?;
+        Ok(self)
+    }
+
     /// Generate tangents for the mesh using the `mikktspace` algorithm.
     ///
     /// Sets the [`Mesh::ATTRIBUTE_TANGENT`] attribute if successful.
@@ -945,7 +1608,7 @@ impl Mesh {
     #[cfg(feature = "bevy_mikktspace")]
     pub fn generate_tangents(&mut self) -> Result<(), super::GenerateTangentsError> {
         let tangents = super::generate_tangents_for_mesh(self)?;
-        self.insert_attribute(Mesh::ATTRIBUTE_TANGENT, tangents);
+        self.try_insert_attribute(Mesh::ATTRIBUTE_TANGENT, tangents)?;
         Ok(())
     }
 
@@ -994,8 +1657,8 @@ impl Mesh {
         let index_offset = self.count_vertices();
 
         // Extend attributes of `self` with attributes of `other`.
-        for (attribute, values) in self.attributes_mut() {
-            if let Some(other_values) = other.attribute(attribute.id) {
+        for (attribute, values) in self.try_attributes_mut()? {
+            if let Some(other_values) = other.try_attribute_option(attribute.id)? {
                 #[expect(
                     clippy::match_same_arms,
                     reason = "Although the bindings on some match arms may have different types, each variant has different semantics; thus it's not guaranteed that they will use the same type forever."
@@ -1033,7 +1696,7 @@ impl Mesh {
                         return Err(MeshMergeError::IncompatibleVertexAttributes {
                             self_attribute: *attribute,
                             other_attribute: other
-                                .attribute_data(attribute.id)
+                                .try_attribute_data(attribute.id)?
                                 .map(|data| data.attribute),
                         })
                     }
@@ -1042,7 +1705,9 @@ impl Mesh {
         }
 
         // Extend indices of `self` with indices of `other`.
-        if let (Some(indices), Some(other_indices)) = (self.indices_mut(), other.indices()) {
+        if let (Some(indices), Some(other_indices)) =
+            (self.try_indices_mut_option()?, other.try_indices_option()?)
+        {
             indices.extend(other_indices.iter().map(|i| (i + index_offset) as u32));
         }
         Ok(())
@@ -1051,15 +1716,39 @@ impl Mesh {
     /// Transforms the vertex positions, normals, and tangents of the mesh by the given [`Transform`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_transformed_by`]
     pub fn transformed_by(mut self, transform: Transform) -> Self {
         self.transform_by(transform);
         self
     }
 
+    /// Transforms the vertex positions, normals, and tangents of the mesh by the given [`Transform`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_transformed_by(mut self, transform: Transform) -> Result<Self, MeshAccessError> {
+        self.try_transform_by(transform)?;
+        Ok(self)
+    }
+
     /// Transforms the vertex positions, normals, and tangents of the mesh in place by the given [`Transform`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_transform_by`]
     pub fn transform_by(&mut self, transform: Transform) {
+        self.try_transform_by(transform)
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Transforms the vertex positions, normals, and tangents of the mesh in place by the given [`Transform`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_transform_by(&mut self, transform: Transform) -> Result<(), MeshAccessError> {
         // Needed when transforming normals and tangents
         let scale_recip = 1. / transform.scale;
         debug_assert!(
@@ -1068,7 +1757,7 @@ impl Mesh {
         );
 
         if let Some(VertexAttributeValues::Float32x3(positions)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_POSITION)?
         {
             // Apply scale, rotation, and translation to vertex positions
             positions
@@ -1081,11 +1770,11 @@ impl Mesh {
             && transform.scale.x == transform.scale.y
             && transform.scale.y == transform.scale.z
         {
-            return;
+            return Ok(());
         }
 
         if let Some(VertexAttributeValues::Float32x3(normals)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_NORMAL)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_NORMAL)?
         {
             // Transform normals, taking into account non-uniform scaling and rotation
             normals.iter_mut().for_each(|normal| {
@@ -1096,7 +1785,7 @@ impl Mesh {
         }
 
         if let Some(VertexAttributeValues::Float32x4(tangents)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_TANGENT)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_TANGENT)?
         {
             // Transform tangents, taking into account non-uniform scaling and rotation
             tangents.iter_mut().for_each(|tangent| {
@@ -1107,48 +1796,99 @@ impl Mesh {
                     .to_array();
             });
         }
+
+        Ok(())
     }
 
     /// Translates the vertex positions of the mesh by the given [`Vec3`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_translated_by`]
     pub fn translated_by(mut self, translation: Vec3) -> Self {
         self.translate_by(translation);
         self
     }
 
+    /// Translates the vertex positions of the mesh by the given [`Vec3`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_translated_by(mut self, translation: Vec3) -> Result<Self, MeshAccessError> {
+        self.try_translate_by(translation)?;
+        Ok(self)
+    }
+
     /// Translates the vertex positions of the mesh in place by the given [`Vec3`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_translate_by`]
     pub fn translate_by(&mut self, translation: Vec3) {
+        self.try_translate_by(translation)
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Translates the vertex positions of the mesh in place by the given [`Vec3`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_translate_by(&mut self, translation: Vec3) -> Result<(), MeshAccessError> {
         if translation == Vec3::ZERO {
-            return;
+            return Ok(());
         }
 
         if let Some(VertexAttributeValues::Float32x3(positions)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_POSITION)?
         {
             // Apply translation to vertex positions
             positions
                 .iter_mut()
                 .for_each(|pos| *pos = (Vec3::from_slice(pos) + translation).to_array());
         }
+
+        Ok(())
     }
 
     /// Rotates the vertex positions, normals, and tangents of the mesh by the given [`Quat`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_rotated_by`]
     pub fn rotated_by(mut self, rotation: Quat) -> Self {
-        self.rotate_by(rotation);
+        self.try_rotate_by(rotation).expect(MESH_EXTRACTED_ERROR);
         self
     }
 
+    /// Rotates the vertex positions, normals, and tangents of the mesh by the given [`Quat`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_rotated_by(mut self, rotation: Quat) -> Result<Self, MeshAccessError> {
+        self.try_rotate_by(rotation)?;
+        Ok(self)
+    }
+
     /// Rotates the vertex positions, normals, and tangents of the mesh in place by the given [`Quat`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_rotate_by`]
     pub fn rotate_by(&mut self, rotation: Quat) {
+        self.try_rotate_by(rotation).expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Rotates the vertex positions, normals, and tangents of the mesh in place by the given [`Quat`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_rotate_by(&mut self, rotation: Quat) -> Result<(), MeshAccessError> {
         if let Some(VertexAttributeValues::Float32x3(positions)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_POSITION)?
         {
             // Apply rotation to vertex positions
             positions
@@ -1158,11 +1898,11 @@ impl Mesh {
 
         // No need to transform normals or tangents if rotation is near identity
         if rotation.is_near_identity() {
-            return;
+            return Ok(());
         }
 
         if let Some(VertexAttributeValues::Float32x3(normals)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_NORMAL)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_NORMAL)?
         {
             // Transform normals
             normals.iter_mut().for_each(|normal| {
@@ -1171,7 +1911,7 @@ impl Mesh {
         }
 
         if let Some(VertexAttributeValues::Float32x4(tangents)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_TANGENT)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_TANGENT)?
         {
             // Transform tangents
             tangents.iter_mut().for_each(|tangent| {
@@ -1181,20 +1921,45 @@ impl Mesh {
                     .to_array();
             });
         }
+
+        Ok(())
     }
 
     /// Scales the vertex positions, normals, and tangents of the mesh by the given [`Vec3`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_scaled_by`]
     pub fn scaled_by(mut self, scale: Vec3) -> Self {
         self.scale_by(scale);
         self
     }
 
+    /// Scales the vertex positions, normals, and tangents of the mesh by the given [`Vec3`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_scaled_by(mut self, scale: Vec3) -> Result<Self, MeshAccessError> {
+        self.try_scale_by(scale)?;
+        Ok(self)
+    }
+
     /// Scales the vertex positions, normals, and tangents of the mesh in place by the given [`Vec3`].
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_scale_by`]
     pub fn scale_by(&mut self, scale: Vec3) {
+        self.try_scale_by(scale).expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Scales the vertex positions, normals, and tangents of the mesh in place by the given [`Vec3`].
+    ///
+    /// `Aabb` of entities with modified mesh are not updated automatically.
+    pub fn try_scale_by(&mut self, scale: Vec3) -> Result<(), MeshAccessError> {
         // Needed when transforming normals and tangents
         let scale_recip = 1. / scale;
         debug_assert!(
@@ -1203,7 +1968,7 @@ impl Mesh {
         );
 
         if let Some(VertexAttributeValues::Float32x3(positions)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_POSITION)?
         {
             // Apply scale to vertex positions
             positions
@@ -1213,11 +1978,11 @@ impl Mesh {
 
         // No need to transform normals or tangents if scale is uniform
         if scale.x == scale.y && scale.y == scale.z {
-            return;
+            return Ok(());
         }
 
         if let Some(VertexAttributeValues::Float32x3(normals)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_NORMAL)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_NORMAL)?
         {
             // Transform normals, taking into account non-uniform scaling
             normals.iter_mut().for_each(|normal| {
@@ -1226,7 +1991,7 @@ impl Mesh {
         }
 
         if let Some(VertexAttributeValues::Float32x4(tangents)) =
-            self.attribute_mut(Mesh::ATTRIBUTE_TANGENT)
+            self.try_attribute_mut_option(Mesh::ATTRIBUTE_TANGENT)?
         {
             // Transform tangents, taking into account non-uniform scaling
             tangents.iter_mut().for_each(|tangent| {
@@ -1238,15 +2003,25 @@ impl Mesh {
                     .to_array();
             });
         }
+
+        Ok(())
     }
 
     /// Normalize joint weights so they sum to 1.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_normalize_joint_weights`]
     pub fn normalize_joint_weights(&mut self) {
-        if let Some(joints) = self.attribute_mut(Self::ATTRIBUTE_JOINT_WEIGHT) {
-            let VertexAttributeValues::Float32x4(joints) = joints else {
-                panic!("unexpected joint weight format");
-            };
+        self.try_normalize_joint_weights()
+            .expect(MESH_EXTRACTED_ERROR);
+    }
 
+    /// Normalize joint weights so they sum to 1.
+    pub fn try_normalize_joint_weights(&mut self) -> Result<(), MeshAccessError> {
+        if let Some(VertexAttributeValues::Float32x4(joints)) =
+            self.try_attribute_mut_option(Self::ATTRIBUTE_JOINT_WEIGHT)?
+        {
             for weights in joints.iter_mut() {
                 // force negative weights to zero
                 weights.iter_mut().for_each(|w| *w = w.max(0.0));
@@ -1263,6 +2038,8 @@ impl Mesh {
                 }
             }
         }
+
+        Ok(())
     }
 
     /// Get a list of this Mesh's [triangles] as an iterator if possible.
@@ -1275,17 +2052,13 @@ impl Mesh {
     /// [primitive topology]: PrimitiveTopology
     /// [triangles]: Triangle3d
     pub fn triangles(&self) -> Result<impl Iterator<Item = Triangle3d> + '_, MeshTrianglesError> {
-        let Some(position_data) = self.attribute(Mesh::ATTRIBUTE_POSITION) else {
-            return Err(MeshTrianglesError::MissingPositions);
-        };
+        let position_data = self.try_attribute(Mesh::ATTRIBUTE_POSITION)?;
 
         let Some(vertices) = position_data.as_float3() else {
             return Err(MeshTrianglesError::PositionsFormat);
         };
 
-        let Some(indices) = self.indices() else {
-            return Err(MeshTrianglesError::MissingIndices);
-        };
+        let indices = self.try_indices()?;
 
         match self.primitive_topology {
             PrimitiveTopology::TriangleList => {
@@ -1362,23 +2135,105 @@ impl Mesh {
             })
         }
     }
+
+    /// Extracts the mesh vertex, index and morph target data for GPU upload.
+    /// This function is called internally in render world extraction, it is
+    /// unlikely to be useful outside of that context.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn take_gpu_data(&mut self) -> Result<Self, MeshAccessError> {
+        let attributes = self.attributes.extract()?;
+        let indices = self.indices.extract()?;
+        #[cfg(feature = "morph")]
+        let morph_targets = self.morph_targets.extract()?;
+        #[cfg(feature = "morph")]
+        let morph_target_names = self.morph_target_names.extract()?;
+
+        // store the aabb extents as they cannot be computed after extraction
+        if let Some(MeshAttributeData {
+            values: VertexAttributeValues::Float32x3(position_values),
+            ..
+        }) = attributes
+            .as_ref_option()?
+            .and_then(|attrs| attrs.get(&Self::ATTRIBUTE_POSITION.id))
+            && !position_values.is_empty()
+        {
+            let mut iter = position_values.iter().map(|p| Vec3::from_slice(p));
+            let mut min = iter.next().unwrap();
+            let mut max = min;
+            for v in iter {
+                min = Vec3::min(min, v);
+                max = Vec3::max(max, v);
+            }
+            self.final_aabb = Some(Aabb3d::new(min, max));
+        }
+
+        Ok(Self {
+            attributes,
+            indices,
+            #[cfg(feature = "morph")]
+            morph_targets,
+            #[cfg(feature = "morph")]
+            morph_target_names,
+            ..self.clone()
+        })
+    }
 }
 
 #[cfg(feature = "morph")]
 impl Mesh {
     /// Whether this mesh has morph targets.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_has_morph_targets`]
     pub fn has_morph_targets(&self) -> bool {
-        self.morph_targets.is_some()
+        self.try_has_morph_targets().expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Whether this mesh has morph targets.
+    pub fn try_has_morph_targets(&self) -> Result<bool, MeshAccessError> {
+        Ok(self.morph_targets.as_ref_option()?.is_some())
     }
 
     /// Set [morph targets] image for this mesh. This requires a "morph target image". See [`MorphTargetImage`](crate::morph::MorphTargetImage) for info.
     ///
     /// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_set_morph_targets`]
     pub fn set_morph_targets(&mut self, morph_targets: Handle<Image>) {
-        self.morph_targets = Some(morph_targets);
+        self.try_set_morph_targets(morph_targets)
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Set [morph targets] image for this mesh. This requires a "morph target image". See [`MorphTargetImage`](crate::morph::MorphTargetImage) for info.
+    ///
+    /// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation
+    pub fn try_set_morph_targets(
+        &mut self,
+        morph_targets: Handle<Image>,
+    ) -> Result<(), MeshAccessError> {
+        self.morph_targets.replace(Some(morph_targets))?;
+        Ok(())
     }
 
+    /// Retrieve the morph targets for this mesh, or None if there are no morph targets.
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_morph_targets`]
     pub fn morph_targets(&self) -> Option<&Handle<Image>> {
+        self.morph_targets
+            .as_ref_option()
+            .expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Retrieve the morph targets for this mesh, or None if there are no morph targets.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`or
+    /// if the morph targets do not exist.
+    pub fn try_morph_targets(&self) -> Result<&Handle<Image>, MeshAccessError> {
         self.morph_targets.as_ref()
     }
 
@@ -1389,30 +2244,100 @@ impl Mesh {
     /// (Alternatively, you can use [`Mesh::set_morph_targets`] to mutate an existing mesh in-place)
     ///
     /// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_with_morph_targets`]
     #[must_use]
     pub fn with_morph_targets(mut self, morph_targets: Handle<Image>) -> Self {
         self.set_morph_targets(morph_targets);
         self
     }
 
+    /// Consumes the mesh and returns a mesh with the given [morph targets].
+    ///
+    /// This requires a "morph target image". See [`MorphTargetImage`](crate::morph::MorphTargetImage) for info.
+    ///
+    /// (Alternatively, you can use [`Mesh::set_morph_targets`] to mutate an existing mesh in-place)
+    ///
+    /// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn try_with_morph_targets(
+        mut self,
+        morph_targets: Handle<Image>,
+    ) -> Result<Self, MeshAccessError> {
+        self.try_set_morph_targets(morph_targets)?;
+        Ok(self)
+    }
+
     /// Sets the names of each morph target. This should correspond to the order of the morph targets in `set_morph_targets`.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_set_morph_target_names`]
     pub fn set_morph_target_names(&mut self, names: Vec<String>) {
-        self.morph_target_names = Some(names);
+        self.try_set_morph_target_names(names)
+            .expect(MESH_EXTRACTED_ERROR);
+    }
+
+    /// Sets the names of each morph target. This should correspond to the order of the morph targets in `set_morph_targets`.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn try_set_morph_target_names(
+        &mut self,
+        names: Vec<String>,
+    ) -> Result<(), MeshAccessError> {
+        self.morph_target_names.replace(Some(names))?;
+        Ok(())
     }
 
     /// Consumes the mesh and returns a mesh with morph target names.
     /// Names should correspond to the order of the morph targets in `set_morph_targets`.
     ///
     /// (Alternatively, you can use [`Mesh::set_morph_target_names`] to mutate an existing mesh in-place)
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_set_morph_target_names`]
     #[must_use]
-    pub fn with_morph_target_names(mut self, names: Vec<String>) -> Self {
-        self.set_morph_target_names(names);
-        self
+    pub fn with_morph_target_names(self, names: Vec<String>) -> Self {
+        self.try_with_morph_target_names(names)
+            .expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Consumes the mesh and returns a mesh with morph target names.
+    /// Names should correspond to the order of the morph targets in `set_morph_targets`.
+    ///
+    /// (Alternatively, you can use [`Mesh::set_morph_target_names`] to mutate an existing mesh in-place)
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`.
+    pub fn try_with_morph_target_names(
+        mut self,
+        names: Vec<String>,
+    ) -> Result<Self, MeshAccessError> {
+        self.try_set_morph_target_names(names)?;
+        Ok(self)
     }
 
     /// Gets a list of all morph target names, if they exist.
+    ///
+    /// # Panics
+    /// Panics when the mesh data has already been extracted to `RenderWorld`. To handle
+    /// this as an error use [`Mesh::try_morph_target_names`]
     pub fn morph_target_names(&self) -> Option<&[String]> {
-        self.morph_target_names.as_deref()
+        self.try_morph_target_names().expect(MESH_EXTRACTED_ERROR)
+    }
+
+    /// Gets a list of all morph target names, if they exist.
+    ///
+    /// Returns an error if the mesh data has been extracted to `RenderWorld`or
+    /// if the morph targets do not exist.
+    pub fn try_morph_target_names(&self) -> Result<Option<&[String]>, MeshAccessError> {
+        Ok(self
+            .morph_target_names
+            .as_ref_option()?
+            .map(core::ops::Deref::deref))
     }
 }
 
@@ -1465,11 +2390,14 @@ pub struct SerializedMesh {
 #[cfg(feature = "serialize")]
 impl SerializedMesh {
     /// Create a [`SerializedMesh`] from a [`Mesh`]. See the documentation for [`SerializedMesh`] for caveats.
-    pub fn from_mesh(mesh: Mesh) -> Self {
+    pub fn from_mesh(mut mesh: Mesh) -> Self {
         Self {
             primitive_topology: mesh.primitive_topology,
             attributes: mesh
                 .attributes
+                .replace(None)
+                .expect(MESH_EXTRACTED_ERROR)
+                .unwrap()
                 .into_iter()
                 .map(|(id, data)| {
                     (
@@ -1478,7 +2406,7 @@ impl SerializedMesh {
                     )
                 })
                 .collect(),
-            indices: mesh.indices,
+            indices: mesh.indices.replace(None).expect(MESH_EXTRACTED_ERROR),
         }
     }
 
@@ -1542,7 +2470,7 @@ impl MeshDeserializer {
     /// See the documentation for [`SerializedMesh`] for caveats.
     pub fn deserialize(&self, serialized_mesh: SerializedMesh) -> Mesh {
         Mesh {
-            attributes:
+            attributes: MeshExtractableData::Data(
                 serialized_mesh
                 .attributes
                 .into_iter()
@@ -1559,8 +2487,8 @@ impl MeshDeserializer {
                     };
                     Some((id, data))
                 })
-                .collect(),
-            indices: serialized_mesh.indices,
+                .collect()),
+            indices: serialized_mesh.indices.into(),
             ..Mesh::new(serialized_mesh.primitive_topology, RenderAssetUsages::default())
         }
     }
@@ -1583,6 +2511,8 @@ pub enum MeshMergeError {
         self_primitive_topology: PrimitiveTopology,
         other_primitive_topology: PrimitiveTopology,
     },
+    #[error("Mesh access error: {0}")]
+    MeshAccessError(#[from] MeshAccessError),
 }
 
 #[cfg(test)]
diff --git a/crates/bevy_mesh/src/mikktspace.rs b/crates/bevy_mesh/src/mikktspace.rs
index 6c7b2a1cb653a..36b24353c7c13 100644
--- a/crates/bevy_mesh/src/mikktspace.rs
+++ b/crates/bevy_mesh/src/mikktspace.rs
@@ -1,3 +1,5 @@
+use crate::MeshAccessError;
+
 use super::{Indices, Mesh, VertexAttributeValues};
 use thiserror::Error;
 use wgpu_types::{PrimitiveTopology, VertexFormat};
@@ -70,6 +72,8 @@ pub enum GenerateTangentsError {
     InvalidVertexAttributeFormat(&'static str, VertexFormat),
     #[error("mesh not suitable for tangent generation")]
     MikktspaceError(#[from] bevy_mikktspace::GenerateTangentSpaceError),
+    #[error("Mesh access error: {0}")]
+    MeshAccessError(#[from] MeshAccessError),
 }
 
 pub(crate) fn generate_tangents_for_mesh(
@@ -80,7 +84,7 @@ pub(crate) fn generate_tangents_for_mesh(
         other => return Err(GenerateTangentsError::UnsupportedTopology(other)),
     };
 
-    let positions = mesh.attribute(Mesh::ATTRIBUTE_POSITION).ok_or(
+    let positions = mesh.try_attribute_option(Mesh::ATTRIBUTE_POSITION)?.ok_or(
         GenerateTangentsError::MissingVertexAttribute(Mesh::ATTRIBUTE_POSITION.name),
     )?;
     let VertexAttributeValues::Float32x3(positions) = positions else {
@@ -89,7 +93,7 @@ pub(crate) fn generate_tangents_for_mesh(
             VertexFormat::Float32x3,
         ));
     };
-    let normals = mesh.attribute(Mesh::ATTRIBUTE_NORMAL).ok_or(
+    let normals = mesh.try_attribute_option(Mesh::ATTRIBUTE_NORMAL)?.ok_or(
         GenerateTangentsError::MissingVertexAttribute(Mesh::ATTRIBUTE_NORMAL.name),
     )?;
     let VertexAttributeValues::Float32x3(normals) = normals else {
@@ -98,7 +102,7 @@ pub(crate) fn generate_tangents_for_mesh(
             VertexFormat::Float32x3,
         ));
     };
-    let uvs = mesh.attribute(Mesh::ATTRIBUTE_UV_0).ok_or(
+    let uvs = mesh.try_attribute_option(Mesh::ATTRIBUTE_UV_0)?.ok_or(
         GenerateTangentsError::MissingVertexAttribute(Mesh::ATTRIBUTE_UV_0.name),
     )?;
     let VertexAttributeValues::Float32x2(uvs) = uvs else {
@@ -111,7 +115,7 @@ pub(crate) fn generate_tangents_for_mesh(
     let len = positions.len();
     let tangents = vec![[0., 0., 0., 0.]; len];
     let mut mikktspace_mesh = MikktspaceGeometryHelper {
-        indices: mesh.indices(),
+        indices: mesh.try_indices_option()?,
         positions,
         normals,
         uvs,
diff --git a/crates/bevy_pbr/src/render/mesh.rs b/crates/bevy_pbr/src/render/mesh.rs
index 6e4b3b8aebd8d..914791095a96c 100644
--- a/crates/bevy_pbr/src/render/mesh.rs
+++ b/crates/bevy_pbr/src/render/mesh.rs
@@ -1877,6 +1877,7 @@ pub fn build_dummy_white_gpu_image(
         sampler,
         size: image.texture_descriptor.size,
         mip_level_count: image.texture_descriptor.mip_level_count,
+        had_data: true,
     }
 }
 
diff --git a/crates/bevy_render/src/mesh/mod.rs b/crates/bevy_render/src/mesh/mod.rs
index 2c2f84a0a9e66..fb849cd51b3aa 100644
--- a/crates/bevy_render/src/mesh/mod.rs
+++ b/crates/bevy_render/src/mesh/mod.rs
@@ -1,6 +1,8 @@
 pub mod allocator;
 use crate::{
-    render_asset::{PrepareAssetError, RenderAsset, RenderAssetPlugin, RenderAssets},
+    render_asset::{
+        AssetExtractionError, PrepareAssetError, RenderAsset, RenderAssetPlugin, RenderAssets,
+    },
     texture::GpuImage,
     RenderApp,
 };
@@ -131,6 +133,15 @@ impl RenderAsset for RenderMesh {
         mesh.asset_usage
     }
 
+    fn take_gpu_data(
+        source: &mut Self::SourceAsset,
+        _previous_gpu_asset: Option<&Self>,
+    ) -> Result<Self::SourceAsset, AssetExtractionError> {
+        source
+            .take_gpu_data()
+            .map_err(|_| AssetExtractionError::AlreadyExtracted)
+    }
+
     fn byte_len(mesh: &Self::SourceAsset) -> Option<usize> {
         let mut vertex_size = 0;
         for attribute_data in mesh.attributes() {
diff --git a/crates/bevy_render/src/render_asset.rs b/crates/bevy_render/src/render_asset.rs
index 894ad7b65269a..8790f32fbfaa4 100644
--- a/crates/bevy_render/src/render_asset.rs
+++ b/crates/bevy_render/src/render_asset.rs
@@ -28,6 +28,15 @@ pub enum PrepareAssetError<E: Send + Sync + 'static> {
 #[derive(SystemSet, Clone, PartialEq, Eq, Debug, Hash)]
 pub struct AssetExtractionSystems;
 
+/// Error returned when an asset due for extraction has already been extracted
+#[derive(Debug, Error)]
+pub enum AssetExtractionError {
+    #[error("The asset has already been extracted")]
+    AlreadyExtracted,
+    #[error("The asset type does not support extraction. To clone the asset to the renderworld, use `RenderAssetUsages::default()`")]
+    NoExtractionImplementation,
+}
+
 /// Describes how an asset gets extracted and prepared for rendering.
 ///
 /// In the [`ExtractSchedule`] step the [`RenderAsset::SourceAsset`] is transferred
@@ -82,6 +91,18 @@ pub trait RenderAsset: Send + Sync + 'static + Sized {
         _param: &mut SystemParamItem<Self::Param>,
     ) {
     }
+
+    /// Make a copy of the asset to be moved to the `RenderWorld` / gpu. Heavy internal data (pixels, vertex attributes)
+    /// should be moved into the copy, leaving this asset with only metadata.
+    /// An error may be returned to indicate that the asset has already been extracted, and should not
+    /// have been modified on the CPU side (as it cannot be transferred to GPU again).
+    /// The previous GPU asset is also provided, which can be used to check if the modification is valid.
+    fn take_gpu_data(
+        _source: &mut Self::SourceAsset,
+        _previous_gpu_asset: Option<&Self>,
+    ) -> Result<Self::SourceAsset, AssetExtractionError> {
+        Err(AssetExtractionError::NoExtractionImplementation)
+    }
 }
 
 /// This plugin extracts the changed assets from the "app world" into the "render world"
@@ -220,6 +241,7 @@ struct CachedExtractRenderAssetSystemState<A: RenderAsset> {
     state: SystemState<(
         MessageReader<'static, 'static, AssetEvent<A::SourceAsset>>,
         ResMut<'static, Assets<A::SourceAsset>>,
+        Option<Res<'static, RenderAssets<A>>>,
     )>,
 }
 
@@ -239,7 +261,7 @@ pub(crate) fn extract_render_asset<A: RenderAsset>(
 ) {
     main_world.resource_scope(
         |world, mut cached_state: Mut<CachedExtractRenderAssetSystemState<A>>| {
-            let (mut events, mut assets) = cached_state.state.get_mut(world);
+            let (mut events, mut assets, maybe_render_assets) = cached_state.state.get_mut(world);
 
             let mut needs_extracting = <HashSet<_>>::default();
             let mut removed = <HashSet<_>>::default();
@@ -280,9 +302,17 @@ pub(crate) fn extract_render_asset<A: RenderAsset>(
                     let asset_usage = A::asset_usage(asset);
                     if asset_usage.contains(RenderAssetUsages::RENDER_WORLD) {
                         if asset_usage == RenderAssetUsages::RENDER_WORLD {
-                            if let Some(asset) = assets.remove(id) {
-                                extracted_assets.push((id, asset));
-                                added.insert(id);
+                            if let Some(asset) = assets.get_mut_untracked(id) {
+                                let previous_asset = maybe_render_assets.as_ref().and_then(|render_assets| render_assets.get(id));
+                                match A::take_gpu_data(asset, previous_asset) {
+                                    Ok(gpu_data_asset) => {
+                                        extracted_assets.push((id, gpu_data_asset));
+                                        added.insert(id);
+                                    }
+                                    Err(e) => {
+                                        error!("{} with RenderAssetUsages == RENDER_WORLD cannot be extracted: {e}", core::any::type_name::<A>());
+                                    }
+                                };
                             }
                         } else {
                             extracted_assets.push((id, asset.clone()));
diff --git a/crates/bevy_render/src/storage.rs b/crates/bevy_render/src/storage.rs
index d7c208f001bf3..0362add4ed959 100644
--- a/crates/bevy_render/src/storage.rs
+++ b/crates/bevy_render/src/storage.rs
@@ -1,5 +1,5 @@
 use crate::{
-    render_asset::{PrepareAssetError, RenderAsset, RenderAssetPlugin},
+    render_asset::{AssetExtractionError, PrepareAssetError, RenderAsset, RenderAssetPlugin},
     render_resource::{Buffer, BufferUsages},
     renderer::RenderDevice,
 };
@@ -101,6 +101,7 @@ where
 /// A storage buffer that is prepared as a [`RenderAsset`] and uploaded to the GPU.
 pub struct GpuShaderStorageBuffer {
     pub buffer: Buffer,
+    pub had_data: bool,
 }
 
 impl RenderAsset for GpuShaderStorageBuffer {
@@ -111,6 +112,22 @@ impl RenderAsset for GpuShaderStorageBuffer {
         source_asset.asset_usage
     }
 
+    fn take_gpu_data(
+        source: &mut Self::SourceAsset,
+        previous_gpu_asset: Option<&Self>,
+    ) -> Result<Self::SourceAsset, AssetExtractionError> {
+        let data = source.data.take();
+
+        let valid_upload = data.is_some() || previous_gpu_asset.is_none_or(|prev| !prev.had_data);
+
+        valid_upload
+            .then(|| Self::SourceAsset {
+                data,
+                ..source.clone()
+            })
+            .ok_or(AssetExtractionError::AlreadyExtracted)
+    }
+
     fn prepare_asset(
         source_asset: Self::SourceAsset,
         _: AssetId<Self::SourceAsset>,
@@ -124,11 +141,17 @@ impl RenderAsset for GpuShaderStorageBuffer {
                     contents: &data,
                     usage: source_asset.buffer_description.usage,
                 });
-                Ok(GpuShaderStorageBuffer { buffer })
+                Ok(GpuShaderStorageBuffer {
+                    buffer,
+                    had_data: true,
+                })
             }
             None => {
                 let buffer = render_device.create_buffer(&source_asset.buffer_description);
-                Ok(GpuShaderStorageBuffer { buffer })
+                Ok(GpuShaderStorageBuffer {
+                    buffer,
+                    had_data: false,
+                })
             }
         }
     }
diff --git a/crates/bevy_render/src/texture/fallback_image.rs b/crates/bevy_render/src/texture/fallback_image.rs
index 095f27eecec69..69e09a5b3cb9b 100644
--- a/crates/bevy_render/src/texture/fallback_image.rs
+++ b/crates/bevy_render/src/texture/fallback_image.rs
@@ -138,6 +138,7 @@ fn fallback_image_new(
         sampler,
         size: image.texture_descriptor.size,
         mip_level_count: image.texture_descriptor.mip_level_count,
+        had_data: true,
     }
 }
 
diff --git a/crates/bevy_render/src/texture/gpu_image.rs b/crates/bevy_render/src/texture/gpu_image.rs
index 622ffd16fb156..6fc8f0981fba1 100644
--- a/crates/bevy_render/src/texture/gpu_image.rs
+++ b/crates/bevy_render/src/texture/gpu_image.rs
@@ -1,5 +1,5 @@
 use crate::{
-    render_asset::{PrepareAssetError, RenderAsset},
+    render_asset::{AssetExtractionError, PrepareAssetError, RenderAsset},
     render_resource::{DefaultImageSampler, Sampler, Texture, TextureView},
     renderer::{RenderDevice, RenderQueue},
 };
@@ -20,6 +20,7 @@ pub struct GpuImage {
     pub sampler: Sampler,
     pub size: Extent3d,
     pub mip_level_count: u32,
+    pub had_data: bool,
 }
 
 impl RenderAsset for GpuImage {
@@ -35,6 +36,24 @@ impl RenderAsset for GpuImage {
         image.asset_usage
     }
 
+    fn take_gpu_data(
+        source: &mut Self::SourceAsset,
+        previous_gpu_asset: Option<&Self>,
+    ) -> Result<Self::SourceAsset, AssetExtractionError> {
+        let data = source.data.take();
+
+        // check if this image originally had data and no longer does, that implies it
+        // has already been extracted
+        let valid_upload = data.is_some() || previous_gpu_asset.is_none_or(|prev| !prev.had_data);
+
+        valid_upload
+            .then(|| Self::SourceAsset {
+                data,
+                ..source.clone()
+            })
+            .ok_or(AssetExtractionError::AlreadyExtracted)
+    }
+
     #[inline]
     fn byte_len(image: &Self::SourceAsset) -> Option<usize> {
         image.data.as_ref().map(Vec::len)
@@ -47,6 +66,7 @@ impl RenderAsset for GpuImage {
         (render_device, render_queue, default_sampler): &mut SystemParamItem<Self::Param>,
         previous_asset: Option<&Self>,
     ) -> Result<Self, PrepareAssetError<Self::SourceAsset>> {
+        let had_data = image.data.is_some();
         let texture = if let Some(ref data) = image.data {
             render_device.create_texture_with_data(
                 render_queue,
@@ -110,6 +130,7 @@ impl RenderAsset for GpuImage {
             sampler,
             size: image.texture_descriptor.size,
             mip_level_count: image.texture_descriptor.mip_level_count,
+            had_data,
         })
     }
 }
