<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21732 为仅用于渲染世界的资产保留无数据的资产对象
        
    </title><meta content="#21732 为仅用于渲染世界的资产保留无数据的资产对象" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-14</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-12/pr-21732-en-20251214>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=retain-asset-without-data-for-render-world-only-assets>Retain asset without data for RENDER_WORLD-only assets</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>标题</strong>: 为仅用于渲染世界的资产保留无数据的资产对象<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/21732<li><strong>作者</strong>: robtfm<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: C-Bug, A-Rendering, A-Assets, S-Ready-For-Final-Review<li><strong>创建时间</strong>: 2025-11-03T13:47:36Z<li><strong>合并时间</strong>: 2025-12-14T23:22:16Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h3 id=mu-biao>目标</h3><p>当使用 <code>RenderAssetUsages::RENDER_WORLD</code> 且不含 <code>RenderAssetUsages::MAIN_WORLD</code> 的 <code>RenderAssets</code> 被提取时，这些资产会从资产集合中移除。这会导致一些问题：<ul><li>依赖这些资产的系统（例如使用网格的拾取功能）会因“找不到资产“的错误而失败，这种错误信息不够直观。<li>通过路径第二次加载资产会导致资产从存储中重新加载、重新提取并重新传输到GPU，替换现有的资产。<li>资产状态信息丢失，我们无法通过 <code>AssetServer::get_handle</code> 判断资产是否已加载。<li>资产的元数据（例如图片尺寸）不再可用。</ul><h3 id=jie-jue-fang-an>解决方案</h3><h4 id=ti-qu-guo-cheng>提取过程：</h4><ul><li>在 <code>RenderAsset</code> trait 中添加 <code>take_gpu_data</code> 方法。使用它来提取资产数据以供传输，并在集合中留下空的资产对象。默认实现只是克隆资产。<li>如果数据已被提取，则记录错误（之前是panic，现改为记录错误）。</ul><h4 id=mesh-rendermesh>Mesh/RenderMesh：</h4><ul><li>将 <code>Mesh::attributes</code> 和 <code>Mesh::indices</code> 改为可选类型<li>在提取时取走它们<li>如果数据已被提取，则通过 <code>expect</code> 操作访问或修改顶点数据或索引。在提取后访问顶点数据始终是代码错误。通过返回错误信息 <code>Mesh has been extracted to RenderWorld. To access vertex attributes, the mesh must have RenderAssetUsages::MAIN_WORLD</code> 修复了问题 #19737<li>提供 <code>try_xxx</code> 操作，允许用户在需要时优雅地处理访问错误（本PR中未使用，但为未来提供）<li>在提取GPU数据时计算网格的 <code>Aabb</code> 并存储结果。这使得提取后的网格仍能使用视锥体剔除（否则使用提取后网格的多个副本会因 <code>compute_aabb</code> 依赖顶点位置而panic）。这里有一个权衡：用户可能不需要Aabb，但我们仍然计算它。但考虑到用户几乎总是需要它，并且只计算一次（对于提取的网格）比替代方案更便宜——替代方案是保留位置数据并在每次将网格用于新实体时重新计算 <code>Aabb</code>。</ul><h4 id=image-gpuimage>Image/GpuImage：</h4><p>图片稍微复杂一些，因为对于渲染目标/GPU写入的纹理，数据可以故意为 <code>None</code>，我们只需要一个未初始化的GPU端纹理。<ul><li>在提取时取走 <code>Image::data</code><li>在生成的 <code>GpuImage</code> 中记录最初是否有数据<li>在后续没有数据的修改中，如果之前有数据则panic</ul><p>边缘情况/问题：当与 <code>RenderAssetBytesPerFrameLimiter</code> 一起使用时，如果由于带宽限制仍在排队等待上传，则可能没有先前的GPU资产。这可能导致带有初始数据的修改后的图片跳过 <code>had_data</code> 检查，导致空白纹理。我认为这种情况足够罕见，不是真正的问题，如果资产及时传输，用户仍会遇到panic，并且在遇到问题时问题/解决方案应该是清晰的。<h4 id=shaderstoragebuffer-gpushaderstoragebuffer>ShaderStorageBuffer/GpuShaderStorageBuffer</h4><p>遵循与Image/GpuImage相同的模式：<ul><li>在提取时取走 <code>ShaderStorageBuffer::data</code><li>在生成的 <code>GpuShaderStorageBuffer</code> 中记录最初是否有数据<li>在后续没有数据的修改中，如果之前有数据则panic</ul><p>我们没有这里的队列问题，因为 <code>GpuShaderStorageBuffer</code> 没有实现 <code>byte_len</code>，所以我们不会将它们排队。<h4 id=qi-ta-renderassets>其他RenderAssets</h4><p>我没有修改其他 <code>RenderAsset</code> 类型（<code>GpuAutoExposureCompensationCurve</code>、<code>GpuLineGizmo</code>、<code>RenderWireframeMaterial</code>、<code>PreparedMaterial</code>、<code>PreparedMaterial2d</code>、<code>PreparedUiMaterial</code>），基于以下假设：这些资产的用途（usages）未公开，因此我们不应调用 <code>take_gpu_data</code>。默认实现会panic并显示消息，指导用户在需要时实现该方法。<h3 id=ce-shi>测试</h3><p>仅在我的工作项目中进行了测试。如果需要，我可以添加一些明确的测试。<h2 id=ci-pull-requestde-ji-shu-fen-xi>此Pull Request的技术分析</h2><h3 id=wen-ti-he-bei-jing>问题和背景</h3><p>Bevy引擎的渲染系统有一个关键优化：当资产（如网格、纹理）只需要在渲染世界（RENDER_WORLD）中使用而不需要主世界（MAIN_WORLD）访问时，系统会在资产提取到GPU后从CPU内存中移除这些资产的数据。这个设计旨在减少内存使用，因为一旦数据上传到GPU的VRAM，通常就不再需要保留CPU副本。<p>然而，这个优化带来了几个实际问题：<ol><li><strong>资产访问失败</strong>：某些系统（如网格拾取）仍需要访问已提取的资产，导致“资产未找到“的错误。<li><strong>重复加载</strong>：如果通过路径再次请求同一个资产，系统会从存储重新加载，导致不必要的I/O和GPU传输。<li><strong>状态信息丢失</strong>：无法通过<code>AssetServer</code>查询资产是否已加载。<li><strong>元数据丢失</strong>：图片尺寸等元数据不再可用。</ol><p>问题根源在于资产提取过程完全移除了资产对象，而不是仅仅移除其大数据部分。这破坏了资产系统的完整性，使得本应是内部优化的功能对外部系统产生了负面影响。<h3 id=jie-jue-fang-an-1>解决方案</h3><p>核心思路是修改资产提取机制：不是完全移除资产，而是提取资产的GPU数据部分，留下一个“空壳“资产对象在资产集合中。这个空壳资产保留元数据和状态信息，但不再包含可能占用大量内存的实际数据（如顶点数据、像素数据）。<p>这个方案通过向<code>RenderAsset</code> trait添加<code>take_gpu_data</code>方法来实现。该方法负责：<ul><li>从源资产中提取GPU数据<li>返回一个包含这些数据的新资产对象（用于传输到GPU）<li>修改原资产，将其标记为“已提取“，但保留在资产集合中</ul><h3 id=ju-ti-shi-xian>具体实现</h3><h4 id=renderasset-traitkuo-zhan>RenderAsset trait扩展</h4><p>首先在<code>RenderAsset</code> trait中添加了新的方法：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>    </span><span style=color:#ff8f40>_source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>    </span><span style=color:#ff8f40>_previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>NoExtractionImplementation)
</span><span>}
</span></code></pre><p>这个方法返回<code>Result</code>类型，允许在资产已被提取时返回错误。默认实现返回错误，指示该资产类型不支持提取。支持提取的资产类型需要实现这个方法。<h4 id=meshde-gai-zao>Mesh的改造</h4><p>Mesh的改造最为复杂，因为网格数据包含多个部分：顶点属性、索引，以及可选的变形目标。<p><strong>数据结构变化</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：直接存储数据
</span><span>attributes</span><span style=color:#61676ccc>: </span><span>BTreeMap&LTMeshVertexAttributeId, MeshAttributeData></span><span style=color:#61676ccc>,
</span><span>indices</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTIndices></span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：使用可提取的数据包装器
</span><span>attributes</span><span style=color:#61676ccc>: </span><span>MeshExtractableData&LTBTreeMap&LTMeshVertexAttributeId, MeshAttributeData>></span><span style=color:#61676ccc>,
</span><span>indices</span><span style=color:#61676ccc>: </span><span>MeshExtractableData&LTIndices></span><span style=color:#61676ccc>,
</span></code></pre><p><code>MeshExtractableData</code>枚举有三个状态：<ul><li><code>Data(T)</code>：包含实际数据<li><code>NoData</code>：没有数据（本来就是空的）<li><code>ExtractedToRenderWorld</code>：数据已被提取到渲染世界</ul><p><strong>新增错误处理</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Error</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>MeshAccessError </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>error</span><span>(</span><span style=color:#86b300>"The mesh vertex/index data has been extracted to the RenderWorld (via `Mesh::asset_usage`)"</span><span>)]
</span><span>    ExtractedToRenderWorld</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>error</span><span>(</span><span style=color:#86b300>"The requested mesh data wasn't found in this mesh"</span><span>)]
</span><span>    NotFound</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p><strong>双重API设计</strong>： 对于每个可能访问已提取数据的操作，都提供了两个版本：<ul><li><code>attribute()</code>：在数据被提取时panic<li><code>try_attribute()</code>：返回<code>Result</code>，允许错误处理</ul><p>例如：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>attribute</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>id</span><span style=color:#61676ccc>:</span><span> impl </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTMeshVertexAttributeId>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>VertexAttributeValues> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_attribute_option</span><span>(id)</span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#ff8f40>MESH_EXTRACTED_ERROR</span><span>)
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>try_attribute</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>id</span><span style=color:#61676ccc>:</span><span> impl </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTMeshVertexAttributeId>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#ed9366>&</span><span>VertexAttributeValues, MeshAccessError> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_attribute_option</span><span>(id)</span><span style=color:#ed9366>?
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(MeshAccessError</span><span style=color:#ed9366>::</span><span>NotFound)
</span><span>}
</span></code></pre><p><strong>AABB预计算</strong>： 在提取网格数据时，预先计算并存储边界框（AABB）：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(MeshAttributeData {
</span><span>    values</span><span style=color:#61676ccc>: </span><span>VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Float32x3(position_values)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>..
</span><span>}) </span><span style=color:#ed9366>=</span><span> attributes
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref_option</span><span>()</span><span style=color:#ed9366>?
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>and_then</span><span>(|</span><span style=color:#ff8f40>attrs</span><span>| attrs</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_POSITION</span><span style=color:#ed9366>.</span><span>id))
</span><span>    </span><span style=color:#ed9366>&& !</span><span>position_values</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>()
</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 计算min和max
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>final_aabb </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Aabb3d</span><span style=color:#ed9366>::</span><span>new(min</span><span style=color:#61676ccc>,</span><span> max))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这是一个权衡：不是所有用户都需要AABB，但计算一次比保留顶点数据并在每次使用时重新计算更高效。<h4 id=imagehe-shaderstoragebufferde-shi-xian>Image和ShaderStorageBuffer的实现</h4><p>Image和ShaderStorageBuffer遵循类似的模式，但需要考虑一个特殊情况：渲染目标或GPU写入的纹理可能本来就没有CPU端数据。<p>实现关键：<ul><li>在<code>take_gpu_data</code>中检查是否有数据<li>在GPU资产中记录<code>had_data</code>标志<li>后续修改时，如果尝试将“有数据“的资产改为“无数据“，则panic</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>    </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>    </span><span style=color:#ff8f40>previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> data </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>()</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 检查此图片原本是否有数据而现在没有了，这暗示它已经被提取过
</span><span>    </span><span style=color:#fa6e32>let</span><span> valid_upload </span><span style=color:#ed9366>=</span><span> data</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() </span><span style=color:#ed9366>||</span><span> previous_gpu_asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none_or</span><span>(|</span><span style=color:#ff8f40>prev</span><span>| </span><span style=color:#ed9366>!</span><span>prev</span><span style=color:#ed9366>.</span><span>had_data)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    valid_upload
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>then</span><span>(|| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset {
</span><span>            data</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>..</span><span>source</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()
</span><span>        })
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>AlreadyExtracted)
</span><span>}
</span></code></pre><h4 id=ti-qu-xi-tong-de-xiu-gai>提取系统的修改</h4><p>提取系统现在调用<code>take_gpu_data</code>而不是直接移除资产：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(asset) </span><span style=color:#ed9366>=</span><span> assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut_untracked</span><span>(id) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> previous_asset </span><span style=color:#ed9366>=</span><span> maybe_render_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>and_then</span><span>(|</span><span style=color:#ff8f40>render_assets</span><span>| render_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(id))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>match </span><span>A</span><span style=color:#ed9366>::</span><span>take_gpu_data(asset</span><span style=color:#61676ccc>,</span><span> previous_asset) {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(gpu_data_asset) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            extracted_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((id</span><span style=color:#61676ccc>,</span><span> gpu_data_asset))</span><span style=color:#61676ccc>;
</span><span>            added</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(id)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(e) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#f07171>error!</span><span>(</span><span style=color:#86b300>"{} with RenderAssetUsages == RENDER_WORLD cannot be extracted: {e}"</span><span style=color:#61676ccc>, 
</span><span>                   core</span><span style=color:#ed9366>::</span><span>any</span><span style=color:#ed9366>::</span><span>type_name</span><span style=color:#ed9366>::</span><span>&LTA>())</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=ji-shu-dong-cha>技术洞察</h3><h4 id=she-ji-mo-shi>设计模式</h4><p>这个PR引入了一个清晰的状态管理模式：<ol><li><strong>数据存在</strong>：资产包含完整数据，可以自由访问<li><strong>数据被提取</strong>：数据已传输到GPU，CPU端只保留元数据和预计算的衍生数据（如AABB）<li><strong>数据不存在</strong>：资产原本就没有数据</ol><p>通过<code>MeshExtractableData</code>枚举清晰地表示这些状态，避免了使用<code>Option</code>可能导致的歧义。<h4 id=cuo-wu-chu-li-ce-lue>错误处理策略</h4><p>提供了两套API：<ol><li><strong>快速失败API</strong>（如<code>attribute()</code>）：在数据被提取时panic，适合在开发阶段快速发现问题<li><strong>优雅处理API</strong>（如<code>try_attribute()</code>）：返回<code>Result</code>，适合需要处理提取情况的代码</ol><p>这种设计平衡了开发便利性和运行时健壮性。<h4 id=xing-neng-quan-heng>性能权衡</h4><p>预计算AABB是一个典型的空间换时间优化：<ul><li><strong>优点</strong>：提取后的网格仍可用于视锥体剔除，无需保留顶点数据<li><strong>缺点</strong>：不是所有用户都需要AABB，但仍需计算和存储</ul><p>考虑到视锥体剔除在渲染中的普遍性，这个权衡是合理的。<h3 id=ying-xiang>影响</h3><h4 id=xiu-fu-de-wen-ti>修复的问题</h4><ol><li><strong>资产拾取系统</strong>：现在可以正常工作，因为资产对象仍然存在<li><strong>重复加载</strong>：避免，因为资产句柄仍然指向同一个资产对象<li><strong>状态查询</strong>：通过<code>AssetServer</code>可以正确查询资产状态<li><strong>元数据访问</strong>：图片尺寸等元数据仍然可用</ol><h4 id=xiang-hou-jian-rong-xing>向后兼容性</h4><p>大多数现有代码无需修改，因为：<ul><li>修改主要影响内部提取机制<li>公共API保持兼容，只是新增了<code>try_</code>变体<li>对于已提取资产的访问现在会提供清晰的错误信息，而不是“资产未找到“</ul><h4 id=kai-fa-zhe-ti-yan-gai-shan>开发者体验改善</h4><ul><li>更清晰的错误信息帮助开发者理解问题本质<li><code>try_</code>API为需要处理提取情况的代码提供了优雅的处理方式<li>文档更新解释了<code>RenderAssetUsages</code>的实际含义和行为变化</ul><h2 id=zu-jian-guan-xi-tu>组件关系图</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[RenderAsset Trait] --> B[新增take_gpu_data方法]
</span><span>    B --> C[Mesh实现]
</span><span>    B --> D[Image实现]
</span><span>    B --> E[ShaderStorageBuffer实现]
</span><span>    
</span><span>    C --> F[MeshExtractableData包装器]
</span><span>    F --> G[顶点属性attributes]
</span><span>    F --> H[索引数据indices]
</span><span>    F --> I[变形目标数据]
</span><span>    
</span><span>    C --> J[预计算AABB]
</span><span>    C --> K[双重API设计]
</span><span>    K --> L[快速失败API]
</span><span>    K --> M[优雅处理API]
</span><span>    
</span><span>    D --> N[had_data标志]
</span><span>    D --> O[数据存在性检查]
</span><span>    
</span><span>    E --> P[had_data标志]
</span><span>    E --> Q[数据存在性检查]
</span><span>    
</span><span>    R[资产提取系统] --> S[调用take_gpu_data]
</span><span>    S --> T[保留空壳资产]
</span><span>    S --> U[传输数据到GPU]
</span></code></pre><h2 id=guan-jian-wen-jian-bian-geng>关键文件变更</h2><h3 id=1-crates-bevy-mesh-src-mesh-rs-1032-102>1. <code>crates/bevy_mesh/src/mesh.rs</code> (+1032/-102)</h3><p><strong>变更描述</strong>：这是本次PR中变更最复杂的文件，重构了Mesh的数据结构以支持数据提取，并添加了相关的错误处理和API。<p><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 新的数据结构
</span><span style=color:#fa6e32>enum </span><span style=color:#399ee6>MeshExtractableData</span><span>&LTT> {
</span><span>    Data(T)</span><span style=color:#61676ccc>,
</span><span>    NoData</span><span style=color:#61676ccc>,
</span><span>    ExtractedToRenderWorld</span><span style=color:#61676ccc>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在Mesh结构体中的使用
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Mesh </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 之前：attributes: BTreeMap&LTMeshVertexAttributeId, MeshAttributeData>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 之后：
</span><span>    attributes</span><span style=color:#61676ccc>: </span><span>MeshExtractableData&LTBTreeMap&LTMeshVertexAttributeId, MeshAttributeData>>,
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 新增：预计算的AABB
</span><span>    </span><span style=color:#fa6e32>pub </span><span>final_aabb</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTAabb3d>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 数据提取方法
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>take_gpu_data</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span>, MeshAccessError> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> attributes </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>attributes</span><span style=color:#ed9366>.</span><span style=color:#f07171>extract</span><span>()</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> indices </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>indices</span><span style=color:#ed9366>.</span><span style=color:#f07171>extract</span><span>()</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 预计算AABB
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(MeshAttributeData {
</span><span>        values</span><span style=color:#61676ccc>: </span><span>VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Float32x3(position_values)</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>..
</span><span>    }) </span><span style=color:#ed9366>=</span><span> attributes
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref_option</span><span>()</span><span style=color:#ed9366>?
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>and_then</span><span>(|</span><span style=color:#ff8f40>attrs</span><span>| attrs</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_POSITION</span><span style=color:#ed9366>.</span><span>id))
</span><span>        </span><span style=color:#ed9366>&& !</span><span>position_values</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>()
</span><span>    {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 计算min和max...
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>final_aabb </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Aabb3d</span><span style=color:#ed9366>::</span><span>new(min</span><span style=color:#61676ccc>,</span><span> max))</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#fa6e32>Self </span><span>{
</span><span>        attributes</span><span style=color:#61676ccc>,
</span><span>        indices</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...其他字段
</span><span>    })
</span><span>}
</span></code></pre><p><strong>与PR目的的关系</strong>：这是实现网格数据提取的核心，通过<code>MeshExtractableData</code>管理数据状态，通过<code>take_gpu_data</code>方法提取数据并预计算AABB。<h3 id=2-crates-bevy-render-src-render-asset-rs-34-4>2. <code>crates/bevy_render/src/render_asset.rs</code> (+34/-4)</h3><p><strong>变更描述</strong>：扩展了<code>RenderAsset</code> trait，添加了<code>take_gpu_data</code>方法和相关的错误类型，修改了资产提取系统以使用新方法。<p><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 新增错误类型
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Error)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>AssetExtractionError </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>error</span><span>(</span><span style=color:#86b300>"The asset has already been extracted"</span><span>)]
</span><span>    AlreadyExtracted</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>error</span><span>(</span><span style=color:#86b300>"The asset type does not support extraction. To clone the asset to the renderworld, use `RenderAssetUsages::default()`"</span><span>)]
</span><span>    NoExtractionImplementation</span><span style=color:#61676ccc>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// RenderAsset trait扩展
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>RenderAsset</span><span>: Send + Sync + 'static + Sized {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 现有方法
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>        </span><span style=color:#ff8f40>_source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>        </span><span style=color:#ff8f40>_previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>    ) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>NoExtractionImplementation)
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 提取系统修改
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(asset) </span><span style=color:#ed9366>=</span><span> assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut_untracked</span><span>(id) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> previous_asset </span><span style=color:#ed9366>=</span><span> maybe_render_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>and_then</span><span>(|</span><span style=color:#ff8f40>render_assets</span><span>| render_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(id))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>match </span><span>A</span><span style=color:#ed9366>::</span><span>take_gpu_data(asset</span><span style=color:#61676ccc>,</span><span> previous_asset) {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(gpu_data_asset) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            extracted_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((id</span><span style=color:#61676ccc>,</span><span> gpu_data_asset))</span><span style=color:#61676ccc>;
</span><span>            added</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(id)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(e) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#f07171>error!</span><span>(</span><span style=color:#86b300>"{} with RenderAssetUsages == RENDER_WORLD cannot be extracted: {e}"</span><span style=color:#61676ccc>, 
</span><span>                   core</span><span style=color:#ed9366>::</span><span>any</span><span style=color:#ed9366>::</span><span>type_name</span><span style=color:#ed9366>::</span><span>&LTA>())</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><strong>与PR目的的关系</strong>：提供了资产提取的通用机制，使得不同类型的资产可以自定义数据提取逻辑。<h3 id=3-crates-bevy-render-src-storage-rs-26-3>3. <code>crates/bevy_render/src/storage.rs</code> (+26/-3)</h3><p><strong>变更描述</strong>：为<code>ShaderStorageBuffer</code>实现了<code>take_gpu_data</code>方法，添加了<code>had_data</code>标志来跟踪数据存在性。<p><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// GpuShaderStorageBuffer结构体扩展
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>GpuShaderStorageBuffer </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>buffer</span><span style=color:#61676ccc>:</span><span> Buffer,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>had_data</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>, </span><span style=color:#abb0b6;font-style:italic>// 新增字段
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// take_gpu_data实现
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>    </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>    </span><span style=color:#ff8f40>previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> data </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>()</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let</span><span> valid_upload </span><span style=color:#ed9366>=</span><span> data</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() </span><span style=color:#ed9366>||</span><span> previous_gpu_asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none_or</span><span>(|</span><span style=color:#ff8f40>prev</span><span>| </span><span style=color:#ed9366>!</span><span>prev</span><span style=color:#ed9366>.</span><span>had_data)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    valid_upload
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>then</span><span>(|| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset {
</span><span>            data</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>..</span><span>source</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()
</span><span>        })
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>AlreadyExtracted)
</span><span>}
</span></code></pre><p><strong>与PR目的的关系</strong>：为ShaderStorageBuffer实现了数据提取逻辑，确保在数据已被提取时正确处理后续修改。<h3 id=4-crates-bevy-render-src-texture-gpu-image-rs-22-1>4. <code>crates/bevy_render/src/texture/gpu_image.rs</code> (+22/-1)</h3><p><strong>变更描述</strong>：为<code>Image</code>实现了<code>take_gpu_data</code>方法，添加了<code>had_data</code>标志。<p><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// GpuImage结构体扩展
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>GpuImage </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 现有字段
</span><span>    </span><span style=color:#fa6e32>pub </span><span>had_data</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>, </span><span style=color:#abb0b6;font-style:italic>// 新增字段
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// take_gpu_data实现（与ShaderStorageBuffer类似）
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>    </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>    </span><span style=color:#ff8f40>previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> data </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>()</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let</span><span> valid_upload </span><span style=color:#ed9366>=</span><span> data</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() </span><span style=color:#ed9366>||</span><span> previous_gpu_asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none_or</span><span>(|</span><span style=color:#ff8f40>prev</span><span>| </span><span style=color:#ed9366>!</span><span>prev</span><span style=color:#ed9366>.</span><span>had_data)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    valid_upload
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>then</span><span>(|| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset {
</span><span>            data</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>..</span><span>source</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()
</span><span>        })
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>AlreadyExtracted)
</span><span>}
</span></code></pre><p><strong>与PR目的的关系</strong>：为Image类型实现了数据提取，处理了渲染目标等特殊情况。<h3 id=5-crates-bevy-render-src-mesh-mod-rs-12-1>5. <code>crates/bevy_render/src/mesh/mod.rs</code> (+12/-1)</h3><p><strong>变更描述</strong>：为<code>RenderMesh</code>实现了<code>take_gpu_data</code>方法，委托给<code>Mesh::take_gpu_data</code>。<p><strong>关键代码片段</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>RenderAsset </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>RenderMesh </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 其他实现
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>        </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>        </span><span style=color:#ff8f40>_previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>    ) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>        source
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>take_gpu_data</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>map_err</span><span>(|_| AssetExtractionError</span><span style=color:#ed9366>::</span><span>AlreadyExtracted)
</span><span>    }
</span><span>}
</span></code></pre><p><strong>与PR目的的关系</strong>：连接了RenderAsset系统和Mesh的数据提取实现。<h2 id=jin-yi-bu-yue-du-jian-yi>进一步阅读建议</h2><ol><li><strong>Bevy资产系统文档</strong>：了解Bevy中资产管理系统的基本概念和工作原理<li><strong>渲染管线架构</strong>：理解Bevy中主世界（MAIN_WORLD）和渲染世界（RENDER_WORLD）的分离设计<li><strong>状态模式（State Pattern）</strong>：<code>MeshExtractableData</code>是状态模式的一个典型应用<li><strong>错误处理最佳实践</strong>：学习Rust中错误处理的不同策略，包括快速失败和优雅恢复<li><strong>空间换时间优化</strong>：了解预计算AABB这类优化的权衡考虑<li><strong>Bevy PR #19737</strong>：本次PR修复的具体问题，了解原始问题的上下文</ol><h1 id=full-code-diff>Full Code Diff</h1><p>（已在“关键文件变更“部分包含主要代码差异）</div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_21732.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>