<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22003 Add debug_group to render graph
        
    </title><meta content="#22003 Add debug_group to render graph" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-02</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-12/pr-22003-en-20251202>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><p>Add debug_group to render graph<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add debug_group to render graph<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22003<li><strong>Author</strong>: IceSentry<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, D-Modest, S-Needs-Review<li><strong>Created</strong>: 2025-12-02T05:42:55Z<li><strong>Merged</strong>: 2025-12-02T17:58:12Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><h3 id=mu-biao-objective>目标（Objective）</h3><ul><li>调试包含多个摄像头的应用可能会非常麻烦，因为一眼很难看出哪个渲染通道（pass）属于哪个摄像头。<li>wgpu 暴露了一个功能，可以设置 debug_group，用于在成组的渲染通道和绘制命令周围添加标签。</ul><h3 id=jie-jue-fang-an-solution>解决方案（Solution）</h3><ul><li>向渲染图（render graph）暴露 debug_group 功能。 <ul><li>每个子图（sub graph）现在都可以指定一个 debug group。</ul><li>为每个摄像头添加一个新的调试组标签，包含摄像头序号（order）和实体ID。<li>我还将新的 debug_group 添加到了 tracy span 中，以便更轻松地查看哪个 span 与哪个摄像头相关联。</ul><h3 id=ce-shi-testing>测试（Testing）</h3><ul><li>我测试了 <code>3d_scene</code> 和 <code>split_screen</code> 示例。</ul><hr><h3 id=xiao-guo-zhan-shi-showcase>效果展示（Showcase）</h3><p>这是之前的样子： <img alt=ngfx-ui_cH0BZAQWh9 height=98 src=https://github.com/user-attachments/assets/ef8cdb59-f402-45cd-b2f9-90d315e8e411 width=1626><p>这是在 Nvidia NSight 中应用了新的调试组标签后 <code>split_screen</code> 示例的样子。可以清楚地看到每个摄像头都被明确标识。 <img alt=ngfx-ui_t4L2AheYS3 height=125 src=https://github.com/user-attachments/assets/980c4c7f-c933-44b8-8bfb-34406221bf06 width=1933><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p><strong>问题与背景</strong>：在开发使用多摄像头的图形应用时，调试渲染流程是一个常见的痛点。例如，在分屏（split screen）或画中画等场景中，多个摄像头会触发各自的渲染子图。当我们在 GPU 性能分析工具（如 Nvidia NSight Graphics 或 RenderDoc）中查看渲染命令队列时，各个摄像头产生的渲染通道（pass）和绘制（draw）命令会混杂在一起，缺乏明确的归属标识。这使得开发者难以快速定位某个特定摄像头的性能瓶颈或渲染错误。虽然 Bevy 的渲染图本身有结构，但这个结构信息并没有向下传递到 wgpu 的命令编码器（command encoder）层面，因此无法在 GPU 调试工具中显示。<p><strong>解决方案思路</strong>：现代图形 API（如 Vulkan/Metal/D3D12）及其抽象（如 wgpu）普遍支持调试组（debug group）或事件标记（event marker）功能。这允许开发者在命令缓冲区中插入带文本标签的范围，这些范围会在性能分析工具中高亮显示。这个 PR 的核心思路就是将 wgpu 的 <code>push_debug_group</code> 和 <code>pop_debug_group</code> 功能集成到 Bevy 渲染图的执行流程中。通过为每个执行的子图（特别是摄像头驱动的子图）附加一个可读的标签，就能在工具中清晰地划分出不同摄像头的渲染工作。<p><strong>实现细节</strong>：这个功能的实现涉及渲染图数据结构和执行流程的多个层面。首先，需要在渲染图执行的上下文信息中增加一个字段来携带调试组标签。这体现在 <code>RunSubGraph</code> 结构体中新增的 <code>debug_group: Option&LTString></code> 字段。这个结构体用于在节点（Node）执行过程中请求运行一个子图。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// crates/bevy_render/src/render_graph/context.rs
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>RunSubGraph </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>sub_graph</span><span style=color:#61676ccc>:</span><span> InternedRenderSubGraph,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>inputs</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTSlotValue>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>view_entity</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>debug_group</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>, </span><span style=color:#abb0b6;font-style:italic>// 新增字段
</span><span>}
</span></code></pre><p>相应地，<code>RenderGraphContext::run_sub_graph</code> 方法的签名也进行了更新，增加了一个 <code>debug_group</code> 参数，使得节点在调用时可以传入标签。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>run_sub_graph</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>:</span><span> impl RenderSubGraph,
</span><span>    </span><span style=color:#ff8f40>inputs</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTSlotValue>,
</span><span>    </span><span style=color:#ff8f40>view_entity</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity>,
</span><span>    </span><span style=color:#ff8f40>debug_group</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>, </span><span style=color:#abb0b6;font-style:italic>// 新增参数
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), RunSubGraphError>
</span></code></pre><p>最关键的执行逻辑位于 <code>RenderGraphRunner::run_graph</code> 函数中。这个函数负责实际遍历和执行一个（子）图的所有节点。在这里，函数签名也增加了 <code>debug_group</code> 参数。在执行图的开头和结尾，分别调用了 wgpu 的 <code>push_debug_group</code> 和 <code>pop_debug_group</code> 方法，从而将标签范围应用到该图执行期间发出的所有 GPU 命令上。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// crates/bevy_render/src/renderer/graph_runner.rs
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(debug_group) </span><span style=color:#ed9366>=</span><span> debug_group</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>() {
</span><span>    render_context
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>command_encoder</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>push_debug_group</span><span>(debug_group)</span><span style=color:#61676ccc>;
</span><span>}
</span><span style=color:#abb0b6;font-style:italic>// ... 执行图的所有节点逻辑 ...
</span><span style=color:#fa6e32>if</span><span> debug_group</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() {
</span><span>    render_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>command_encoder</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>pop_debug_group</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>为了让调试信息更有用，需要为特定的子图生成有意义的标签。<code>CameraDriverNode</code> 是驱动每个摄像头渲染的核心节点。它在为每个摄像头运行其专属的渲染子图时，现在会构造一个格式为 <code>"Camera {order} ({entity})"</code> 的字符串作为 <code>debug_group</code> 传入。这使得在分析工具中，每个摄像头的渲染块都能被清晰地标记上其序号和实体 ID。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// crates/bevy_render/src/render_graph/camera_driver_node.rs
</span><span>graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_sub_graph</span><span>(
</span><span>    camera</span><span style=color:#ed9366>.</span><span>render_graph</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(sorted_camera</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#f07171>format!</span><span>(
</span><span>        </span><span style=color:#86b300>"Camera </span><span style=color:#ff8f40>{}</span><span style=color:#86b300> (</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>)"</span><span style=color:#61676ccc>,
</span><span>        sorted_camera</span><span style=color:#ed9366>.</span><span>order</span><span style=color:#61676ccc>,</span><span> sorted_camera</span><span style=color:#ed9366>.</span><span>entity
</span><span>    ))</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre><p>这个改动是向后兼容的。对于其他不关心调试组的子图调用点，例如 <code>RunGraphOnViewNode</code> 和 <code>RunUiSubgraphOnUiViewNode</code>，只需要传入 <code>None</code> 即可，保持了 API 的简洁性。<p><strong>技术考量与扩展性</strong>：这个实现巧妙地利用了现有的 <code>Option&LTString></code> 类型，使功能成为可选项，避免了在不使用时的开销。同时，它将标签信息也添加到了可选的 <code>tracy</code> 性能分析 span 中，为 CPU 端的性能分析也提供了更强的上下文关联性。整个设计是非侵入式的，它为渲染图系统增加了一个强大的调试功能，而不会影响正常的渲染逻辑。未来，其他需要独立标识的渲染子图也可以方便地利用这个机制。<p><strong>影响</strong>：这个 PR 显著改善了 Bevy 应用在多摄像头场景下的可调试性。开发者现在可以使用行业标准的 GPU 调试工具直观地观察不同摄像头的渲染负载和耗时，极大地提升了定位渲染问题和进行性能优化的效率。它实现了一个小而精的功能，解决了开发中的实际痛点。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    subgraph “Render Graph Execution”
</span><span>        A[CameraDriverNode.run] --> B[调用 graph.run_sub_graph]
</span><span>        B --> C[传递 Camera Label]
</span><span>    end
</span><span>
</span><span>    subgraph “Graph Runner”
</span><span>        D[run_graph 函数] --> E{debug_group?}
</span><span>        E -->|Some| F[command_encoder.push_debug_group]
</span><span>        E -->|None| G[跳过]
</span><span>        F --> H[执行子图节点]
</span><span>        G --> H
</span><span>        H --> I[command_encoder.pop_debug_group]
</span><span>    end
</span><span>
</span><span>    subgraph “GPU Profiler (e.g., NSight)”
</span><span>        J[显示标记的渲染命令块]
</span><span>    end
</span><span>
</span><span>    C --> D
</span><span>    F --> J
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><p><strong><code>crates/bevy_render/src/renderer/graph_runner.rs</code> (+20/-3)</strong></p> <ul><li><strong>修改描述与目的</strong>：这是渲染图运行器的核心。修改了 <code>run_graph</code> 函数的签名和逻辑，使其能够接收并在执行前后调用 <code>push_debug_group</code> 和 <code>pop_debug_group</code>。这是将标签实际应用到 GPU 命令流的关键位置。<li><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改了函数签名，增加了 debug_group 参数
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>run_graph</span><span>(
</span><span>    </span><span style=color:#ff8f40>graph</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>RenderGraph,
</span><span>    </span><span style=color:#ff8f40>sub_graph</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTInternedRenderSubGraph>,
</span><span>    </span><span style=color:#ff8f40>render_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> RenderContext,
</span><span>    </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World,
</span><span>    </span><span style=color:#ff8f40>inputs</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[SlotValue],
</span><span>    </span><span style=color:#ff8f40>view_entity</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity>,
</span><span>    </span><span style=color:#ff8f40>debug_group</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>, </span><span style=color:#abb0b6;font-style:italic>// 新增
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), RenderGraphRunnerError>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在执行开始时，如果有标签就压入调试组
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(debug_group) </span><span style=color:#ed9366>=</span><span> debug_group</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>() {
</span><span>    render_context
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>command_encoder</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>push_debug_group</span><span>(debug_group)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在处理 RunSubGraph 命令时，递归调用 run_graph 并传递其 debug_group
</span><span style=color:#55b4d4;font-style:italic>Err</span><span>(RenderGraphRunnerError</span><span style=color:#ed9366>::</span><span>SubGraph(
</span><span>        run_sub_graph</span><span style=color:#ed9366>.</span><span>sub_graph</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>run_graph(
</span><span>            sub_graph</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(run_sub_graph</span><span style=color:#ed9366>.</span><span>sub_graph)</span><span style=color:#61676ccc>,
</span><span>            render_context</span><span style=color:#61676ccc>,
</span><span>            world</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>&</span><span>run_sub_graph</span><span style=color:#ed9366>.</span><span>inputs</span><span style=color:#61676ccc>,
</span><span>            run_sub_graph</span><span style=color:#ed9366>.</span><span>view_entity</span><span style=color:#61676ccc>,
</span><span>            run_sub_graph</span><span style=color:#ed9366>.</span><span>debug_group</span><span style=color:#61676ccc>, </span><span style=color:#abb0b6;font-style:italic>// 传递下去
</span><span>        )</span><span style=color:#ed9366>?</span><span>)</span><span style=color:#61676ccc>,
</span><span>    ))
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在执行结束时，弹出调试组
</span><span style=color:#fa6e32>if</span><span> debug_group</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() {
</span><span>    render_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>command_encoder</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>pop_debug_group</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre></ul><li><p><strong><code>crates/bevy_render/src/render_graph/camera_driver_node.rs</code> (+9/-1)</strong></p> <ul><li><strong>修改描述与目的</strong>：为每个摄像头渲染时生成有意义的调试标签（包含摄像头序号和实体ID），并传递给 <code>run_sub_graph</code> 调用。这是为具体用例（摄像头）提供标签的核心节点。<li><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改了 run_sub_graph 调用，添加了第四个参数：调试组标签
</span><span>graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_sub_graph</span><span>(
</span><span>    camera</span><span style=color:#ed9366>.</span><span>render_graph</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(sorted_camera</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#f07171>format!</span><span>( </span><span style=color:#abb0b6;font-style:italic>// 新增：构造标签
</span><span>        </span><span style=color:#86b300>"Camera </span><span style=color:#ff8f40>{}</span><span style=color:#86b300> (</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>)"</span><span style=color:#61676ccc>,
</span><span>        sorted_camera</span><span style=color:#ed9366>.</span><span>order</span><span style=color:#61676ccc>,</span><span> sorted_camera</span><span style=color:#ed9366>.</span><span>entity
</span><span>    ))</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre></ul><li><p><strong><code>crates/bevy_render/src/render_graph/context.rs</code> (+3/-0)</strong></p> <ul><li><strong>修改描述与目的</strong>：在 <code>RunSubGraph</code> 指令结构体和 <code>run_sub_graph</code> 方法签名中添加 <code>debug_group</code> 字段/参数，使得调试标签信息可以在渲染图节点间传递。<li><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>RunSubGraph </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 其他字段
</span><span>    </span><span style=color:#fa6e32>pub </span><span>debug_group</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>, </span><span style=color:#abb0b6;font-style:italic>// 新增字段
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>run_sub_graph</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>:</span><span> impl RenderSubGraph,
</span><span>    </span><span style=color:#ff8f40>inputs</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTSlotValue>,
</span><span>    </span><span style=color:#ff8f40>view_entity</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity>,
</span><span>    </span><span style=color:#ff8f40>debug_group</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>, </span><span style=color:#abb0b6;font-style:italic>// 新增参数
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), RunSubGraphError>
</span></code></pre></ul><li><p><strong><code>crates/bevy_render/src/render_graph/node.rs</code> (+1/-1)</strong></p> <ul><li><strong>修改描述与目的</strong>：更新 <code>RunGraphOnViewNode</code> 节点的 <code>run</code> 方法，以符合新的 <code>run_sub_graph</code> API（传入 <code>None</code> 作为 <code>debug_group</code>）。这是一个保持 API 兼容性的必要修改。<li><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前：
</span><span>graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_sub_graph</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>sub_graph</span><span style=color:#61676ccc>, </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>view_entity</span><span>()))</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// 修改后：
</span><span>graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_sub_graph</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>sub_graph</span><span style=color:#61676ccc>, </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>view_entity</span><span>())</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>None</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre></ul><li><p><strong><code>crates/bevy_ui_render/src/lib.rs</code> (+1/-1)</strong></p> <ul><li><strong>修改描述与目的</strong>：与 <code>node.rs</code> 中的修改类似，更新 UI 渲染子图的运行节点 <code>RunUiSubgraphOnUiViewNode</code>，以适应 API 变化。<li><strong>关键代码</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前：
</span><span>graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_sub_graph</span><span>(SubGraphUi</span><span style=color:#61676ccc>, </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(ui_camera_view</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>))</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// 修改后：
</span><span>graph</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_sub_graph</span><span>(SubGraphUi</span><span style=color:#61676ccc>, </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(ui_camera_view</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>None</span><span>)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre></ul></ol><h2 id=further-reading>Further Reading</h2><ol><li><strong>wgpu Documentation on Debugging</strong>: <a rel="noopener nofollow noreferrer" href=https://docs.rs/wgpu/latest/wgpu/struct.CommandEncoder.html#method.push_debug_group target=_blank>The <code>wgpu::CommandEncoder::push_debug_group</code> method</a> 提供了该功能的底层 API 细节。<li><strong>NVIDIA Nsight Graphics Documentation</strong>: <a rel="noopener nofollow noreferrer" href=https://docs.nvidia.com/nsight-graphics/UserGuide/index.html target=_blank>关于“工具接口”和“API 调试”的部分</a> 详细解释了如何在像 Nsight 这样的工具中利用调试组信息。<li><strong>Bevy Render Graph Documentation</strong>: Bevy 官方文档中关于 <a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/advanced-topics/render-graph/ target=_blank>渲染图</a> 的部分，有助于理解这个 PR 所修改的系统的基本架构和概念。</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22003.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>