<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22074 Skip picking for UI nodes if there is no pointer
        
    </title><meta content="#22074 Skip picking for UI nodes if there is no pointer" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-09</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22074-zh-cn-20251209>中文</a></div></div><div class=pr-content><h1 id=skip-picking-for-ui-nodes-if-there-is-no-pointer>Skip picking for UI nodes if there is no pointer</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Skip picking for UI nodes if there is no pointer<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22074<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-UI, A-Pointers, S-Needs-Review<li><strong>Created</strong>: 2025-12-09T10:46:06Z<li><strong>Merged</strong>: 2025-12-09T11:52:11Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p><code>ui_picking</code> always iterates through all the uinodes even if no hits are possible because there’s no pointer above the current camera.<h2 id=solution>Solution</h2><p>Early continue if no pointers are found on the current camera.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This pull request addresses a performance optimization in Bevy’s UI picking system. The problem is straightforward but has meaningful performance implications, particularly in scenes with many UI nodes.<p>At its core, the issue is that <code>ui_picking</code>, the system responsible for determining which UI elements are under the mouse pointer or touch input, was running unnecessary work. Before this change, the system would iterate through all UI nodes for every camera in the scene, regardless of whether there was actually any pointer input over that camera. For cameras without pointer input, this meant performing expensive calculations and bounds checks on every UI node, which is wasted CPU cycles.<p>The fix is a classic early-return pattern. The system now checks if there are any pointers associated with the current camera before proceeding with the expensive UI node iteration. If there are no pointers for a given camera, the system immediately continues to the next camera, skipping all the work that would have been performed on that camera’s UI nodes.<p>Looking at the implementation details, the original code had a subtle bug or oversight in how it handled the pointer data structure. The <code>pointer_pos_by_camera</code> hashmap stores pointer positions keyed by camera entity. The original code retrieved this data with <code>let pointers_on_this_cam = pointer_pos_by_camera.get(&camera_entity);</code> but then proceeded to iterate through UI nodes even when <code>pointers_on_this_cam</code> was <code>None</code>.<p>The fix does two things:<ol><li>It adds an early continue when no pointers are found for the current camera<li>It simplifies the pointer iteration by removing unnecessary flat-mapping</ol><p>The original code used <code>.flat_map(|h| h.iter())</code> to iterate over the pointer data, which was redundant because <code>pointers_on_this_cam</code> is already a hashmap when it exists (not a nested structure). The corrected code simply iterates over <code>pointers_on_this_cam.iter()</code> directly.<p>From an engineering perspective, this is a good example of optimizing for the common case. In many applications, especially games, there might be multiple cameras (for minimaps, split-screen multiplayer, etc.), but only one camera typically receives pointer input at any given time. This optimization ensures that UI picking work is only done where it’s actually needed.<p>The performance impact depends on the specific scene composition. For scenes with many cameras and many UI nodes, this could provide significant savings. Even in simpler scenes, it’s a clean optimization that follows the principle of “don’t do work you don’t need to do.”<p>The implementation is minimal and focused, which is exactly what you want in a performance optimization. It doesn’t change any APIs, doesn’t introduce new complexity, and simply makes the existing code more efficient by adding a sensible early exit condition.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[ui_picking system runs] --> B{Check camera pointer}
</span><span>    B -->|No pointers| C[Skip UI iteration for camera]
</span><span>    B -->|Has pointers| D[Iterate through UI nodes]
</span><span>    D --> E[Check each UI node for pointer intersection]
</span><span>    E --> F[Update picking results]
</span><span>    C --> G[Continue to next camera]
</span><span>    F --> G
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ui-src-picking-backend-rs-4-3><code>crates/bevy_ui/src/picking_backend.rs</code> (+4/-3)</h3><p>This is the only file modified in this PR. It contains the core UI picking system that determines which UI elements are under pointer input.<p><strong>Key Changes:</strong><ol><li><strong>Early continue when no pointers are found</strong>: Added a check to skip UI node iteration for cameras without pointer input<li><strong>Simplified pointer iteration</strong>: Removed unnecessary flat-mapping when iterating over pointer data</ol><p><strong>Code Changes:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (lines 174-176):
</span><span style=color:#fa6e32>let</span><span> pointers_on_this_cam </span><span style=color:#ed9366>=</span><span> pointer_pos_by_camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>camera_entity)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Reverse the iterator to traverse the tree from closest nodes to furthest
</span><span style=color:#fa6e32>for</span><span> node_entity </span><span style=color:#ed9366>in</span><span> uinodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>() {
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Before (lines 203-204):
</span><span style=color:#fa6e32>for </span><span>(pointer_id</span><span style=color:#61676ccc>,</span><span> cursor_position) </span><span style=color:#ed9366>in</span><span> pointers_on_this_cam</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>flat_map</span><span>(|</span><span style=color:#ff8f40>h</span><span>| h</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>())
</span><span>{
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// After (lines 174-177):
</span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(pointers_on_this_cam) </span><span style=color:#ed9366>=</span><span> pointer_pos_by_camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>camera_entity) </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Reverse the iterator to traverse the tree from closest nodes to furthest
</span><span style=color:#fa6e32>for</span><span> node_entity </span><span style=color:#ed9366>in</span><span> uinodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>() {
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After (line 205):
</span><span style=color:#fa6e32>for </span><span>(pointer_id</span><span style=color:#61676ccc>,</span><span> cursor_position) </span><span style=color:#ed9366>in</span><span> pointers_on_this_cam</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span></code></pre><p><strong>Analysis:</strong> The change adds a pattern matching guard that extracts the pointer data from the Option returned by <code>get()</code>. If there’s no pointer data for the camera (i.e., the result is <code>None</code>), the system continues to the next camera immediately, skipping all UI node processing for that camera.<p>Additionally, the pointer iteration is simplified. Since we now know <code>pointers_on_this_cam</code> is definitely <code>Some(hashmap)</code> when we reach the iteration (otherwise we would have continued), we can iterate directly over the hashmap without the flat_map that was handling the Option case.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy ECS Optimization Patterns</strong>: This PR demonstrates the importance of early returns in ECS systems to avoid unnecessary work<li><strong>Option Pattern Matching in Rust</strong>: The use of <code>let Some(value) = option else { continue; }</code> is a common Rust idiom for handling optional values<li><strong>UI Picking Algorithms</strong>: For more on how UI picking systems work, see resources on hit testing and bounding volume hierarchies<li><strong>Bevy Input System</strong>: Understanding how Bevy handles pointer input and camera association provides context for why this optimization is effective<li><strong>Performance Profiling in Games</strong>: This is a good example of the type of optimization that becomes visible when profiling frame times and identifying hotspots</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22074.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>