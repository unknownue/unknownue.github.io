<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22307 Always present window at least once
        
    </title><meta content="#22307 Always present window at least once" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22307-zh-cn-20251230>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Always present window at least once<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Always present window at least once<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22307<li><strong>Author</strong>: tychedelia<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, A-Windowing, S-Ready-For-Final-Review, P-Regression<li><strong>Created</strong>: 2025-12-29T21:45:47Z<li><strong>Merged</strong>: 2025-12-30T02:05:58Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Closes #22306. In theory we could cfg gate this for just wayland but doesn’t seem harmful to do as a general case so nbd imo.<p>Don’t have access to wayland right now so can’t test but the docs <a rel="noopener nofollow noreferrer" href=https://wayland.app/protocols/xdg-shell#xdg_surface target=_blank>here</a> and <a rel="noopener nofollow noreferrer" href=https://wayland-book.com/surfaces-in-depth/lifecycle.html target=_blank>here</a> seem to confirm this is the right fix.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a Wayland-specific window initialization issue that manifested as windows not appearing on screen. The problem occurred because Bevy’s render system was conditionally presenting windows only when there was a camera view targeting that window that required presentation. On Wayland, however, windows have a strict lifecycle requirement: they must commit a buffer at least once before they become visible. Without this initial buffer commit, windows remain invisible even though the application logic is otherwise functional.<p>The issue was identified as a regression, likely introduced when the presentation logic was refactored to be more efficient by only presenting windows when necessary. While this optimization worked for most platforms, it broke Wayland’s strict surface lifecycle requirements.<p>The developer’s investigation led to the Wayland protocol documentation for xdg_surface, which specifies that a surface must have a buffer attached and committed before it can be shown. This requirement is fundamental to Wayland’s design - surfaces start in a “pending” state and only become visible after an initial commit. The fix needed to ensure that every window, regardless of camera state, gets presented at least once during initialization.<p>Instead of implementing a platform-specific conditional compilation guard, the developer chose a simpler, more robust approach: adding a flag to track whether each window has been presented at least once. This approach has minimal overhead and works universally across all platforms. While technically only required for Wayland, forcing an initial presentation on all platforms doesn’t cause issues and simplifies the codebase by avoiding platform-specific logic.<p>The implementation adds a <code>needs_initial_present</code> boolean field to the <code>ExtractedWindow</code> struct, initialized to <code>true</code> when windows are created. In the render system’s presentation logic, the code now checks this flag alongside the existing condition that checks if any camera view targeting the window needs presentation. If either condition is true, the window gets presented, and the flag is cleared.<p>This change required restructuring the render system’s loop. Previously, the system iterated over camera views and presented their target windows. Now, it iterates over windows directly and checks if any associated camera view needs presentation OR if the window itself needs its initial presentation. This restructuring is actually cleaner because it centralizes window presentation logic and avoids the previous pattern of potentially presenting the same window multiple times in a single frame when multiple cameras target it.<p>The fix demonstrates an important principle in cross-platform graphics programming: different windowing systems have different initialization and lifecycle requirements. What appears as an optimization on one platform (skipping unnecessary presentations) can be a hard requirement violation on another. The solution shows pragmatic engineering - instead of over-engineering with platform-specific code, implement a simple universal solution that satisfies the strictest platform’s requirements without harming others.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Window Creation] --> B[ExtractedWindow with needs_initial_present=true]
</span><span>    B --> C{Render System Frame}
</span><span>    C --> D[Iterate over Windows]
</span><span>    D --> E{View needs present OR needs_initial_present?}
</span><span>    E -->|Yes| F[Present Window]
</span><span>    F --> G[Set needs_initial_present=false]
</span><span>    E -->|No| H[Skip Presentation]
</span><span>    G --> C
</span><span>    H --> C
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-crates-bevy-render-src-view-window-mod-rs-6-0>1. <code>crates/bevy_render/src/view/window/mod.rs</code> (+6/-0)</h3><p>This file defines the <code>ExtractedWindow</code> struct that holds window data for rendering. The change adds a new field to track whether a window needs its initial presentation.<p><strong>Key modification:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (struct definition excerpt):
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ExtractedWindow </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>size_changed</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>present_mode_changed</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>alpha_mode</span><span style=color:#61676ccc>:</span><span> CompositeAlphaMode,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ExtractedWindow </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>size_changed</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>present_mode_changed</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>alpha_mode</span><span style=color:#61676ccc>:</span><span> CompositeAlphaMode,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Whether this window needs an initial buffer commit.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>///
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// On Wayland, windows must present at least once before they are shown.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// See &LThttps://wayland.app/protocols/xdg-shell#xdg_surface>
</span><span>    </span><span style=color:#fa6e32>pub </span><span>needs_initial_present</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>}
</span></code></pre><p><strong>In the extract_windows function:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>ExtractedWindow {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing fields
</span><span>    alpha_mode</span><span style=color:#61676ccc>:</span><span> window</span><span style=color:#ed9366>.</span><span>composite_alpha_mode</span><span style=color:#61676ccc>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>ExtractedWindow {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing fields
</span><span>    alpha_mode</span><span style=color:#61676ccc>:</span><span> window</span><span style=color:#ed9366>.</span><span>composite_alpha_mode</span><span style=color:#61676ccc>,
</span><span>    needs_initial_present</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>This change initializes every new window with the flag set to <code>true</code>, ensuring it will be presented at least once during its lifecycle.<h3 id=2-crates-bevy-render-src-renderer-mod-rs-10-7>2. <code>crates/bevy_render/src/renderer/mod.rs</code> (+10/-7)</h3><p>This file contains the main render system logic. The change modifies how windows are presented by adding the check for the initial presentation flag and restructuring the loop for clarity.<p><strong>Key modification in render_system function:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before presentation logic:
</span><span style=color:#fa6e32>for </span><span>(view_target</span><span style=color:#61676ccc>,</span><span> camera) </span><span style=color:#ed9366>in</span><span> views</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(NormalizedRenderTarget</span><span style=color:#ed9366>::</span><span>Window(window)) </span><span style=color:#ed9366>=</span><span> camera</span><span style=color:#ed9366>.</span><span>target
</span><span>        </span><span style=color:#ed9366>&&</span><span> view_target</span><span style=color:#ed9366>.</span><span style=color:#f07171>needs_present</span><span>()
</span><span>    {
</span><span>        </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(window) </span><span style=color:#ed9366>=</span><span> windows</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span>window</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>()) </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        window</span><span style=color:#ed9366>.</span><span style=color:#f07171>present</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After presentation logic:
</span><span style=color:#fa6e32>for</span><span> window </span><span style=color:#ed9366>in</span><span> windows</span><span style=color:#ed9366>.</span><span style=color:#f07171>values_mut</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> view_needs_present </span><span style=color:#ed9366>=</span><span> views</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>any</span><span>(|(</span><span style=color:#ff8f40>view_target</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>camera</span><span>)| {
</span><span>        </span><span style=color:#f07171>matches!</span><span>(
</span><span>            camera</span><span style=color:#ed9366>.</span><span>target</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(NormalizedRenderTarget</span><span style=color:#ed9366>::</span><span>Window(w)) </span><span style=color:#fa6e32>if</span><span> w</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>() </span><span style=color:#ed9366>==</span><span> window</span><span style=color:#ed9366>.</span><span>entity
</span><span>        ) </span><span style=color:#ed9366>&&</span><span> view_target</span><span style=color:#ed9366>.</span><span style=color:#f07171>needs_present</span><span>()
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>if</span><span> view_needs_present </span><span style=color:#ed9366>||</span><span> window</span><span style=color:#ed9366>.</span><span>needs_initial_present {
</span><span>        window</span><span style=color:#ed9366>.</span><span style=color:#f07171>present</span><span>()</span><span style=color:#61676ccc>;
</span><span>        window</span><span style=color:#ed9366>.</span><span>needs_initial_present </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The restructured logic now:<ol><li>Iterates over windows directly instead of camera views<li>Checks if any camera view targeting this window needs presentation<li>Also checks if the window itself needs its initial presentation<li>Presents the window if either condition is true<li>Clears the <code>needs_initial_present</code> flag after the first presentation</ol><p>This approach is more efficient when multiple cameras target the same window and ensures the Wayland requirement is met regardless of camera state.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Wayland Protocol Documentation</strong>: The <a rel="noopener nofollow noreferrer" href=https://wayland.app/protocols/xdg-shell#xdg_surface target=_blank>xdg-shell protocol</a> specifies the surface lifecycle requirements that necessitated this fix.<li><strong>Wayland Book - Surfaces in Depth</strong>: The <a rel="noopener nofollow noreferrer" href=https://wayland-book.com/surfaces-in-depth/lifecycle.html target=_blank>Wayland Book chapter on surfaces</a> provides detailed explanations of surface states and buffer management.<li><strong>Bevy Rendering Architecture</strong>: Understanding Bevy’s ECS-based renderer architecture helps contextualize how window presentation integrates with the overall rendering pipeline.<li><strong>Cross-Platform Windowing Challenges</strong>: Resources on differences between X11, Wayland, Windows, and macOS windowing systems can help understand why platform-specific requirements emerge.<li><strong>GPU Presentation Models</strong>: Learning about different presentation modes (V-Sync, immediate, mailbox) and how they interact with windowing systems provides background on why presentation logic needs careful handling.</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22307.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>