diff --git a/crates/bevy_anti_alias/Cargo.toml b/crates/bevy_anti_alias/Cargo.toml
index 8fbcf88fdc23e..54d69899e4847 100644
--- a/crates/bevy_anti_alias/Cargo.toml
+++ b/crates/bevy_anti_alias/Cargo.toml
@@ -34,7 +34,7 @@ bevy_diagnostic = { path = "../bevy_diagnostic", version = "0.18.0-dev" }
 
 # other
 tracing = { version = "0.1", default-features = false, features = ["std"] }
-dlss_wgpu = { version = "1", optional = true }
+dlss_wgpu = { version = "2", optional = true }
 uuid = { version = "1", optional = true }
 
 [lints]
diff --git a/crates/bevy_camera/Cargo.toml b/crates/bevy_camera/Cargo.toml
index b8a1332dcd06b..6b310b65d69a0 100644
--- a/crates/bevy_camera/Cargo.toml
+++ b/crates/bevy_camera/Cargo.toml
@@ -28,7 +28,7 @@ bevy_color = { path = "../bevy_color", version = "0.18.0-dev", features = [
 bevy_window = { path = "../bevy_window", version = "0.18.0-dev" }
 
 # other
-wgpu-types = { version = "26", default-features = false }
+wgpu-types = { version = "27", default-features = false }
 serde = { version = "1", default-features = false, features = ["derive"] }
 thiserror = { version = "2", default-features = false }
 downcast-rs = { version = "2", default-features = false, features = ["std"] }
diff --git a/crates/bevy_color/Cargo.toml b/crates/bevy_color/Cargo.toml
index 056cdeb2f57b7..07b4d17292b17 100644
--- a/crates/bevy_color/Cargo.toml
+++ b/crates/bevy_color/Cargo.toml
@@ -20,7 +20,7 @@ serde = { version = "1.0", features = [
 ], default-features = false, optional = true }
 thiserror = { version = "2", default-features = false }
 derive_more = { version = "2", default-features = false, features = ["from"] }
-wgpu-types = { version = "26", default-features = false, optional = true }
+wgpu-types = { version = "27", default-features = false, optional = true }
 encase = { version = "0.12", default-features = false, optional = true }
 
 [features]
diff --git a/crates/bevy_image/Cargo.toml b/crates/bevy_image/Cargo.toml
index f608023fe984b..008772a5179d6 100644
--- a/crates/bevy_image/Cargo.toml
+++ b/crates/bevy_image/Cargo.toml
@@ -70,7 +70,7 @@ image = { version = "0.25.2", default-features = false }
 # misc
 bitflags = { version = "2.3", features = ["serde"] }
 bytemuck = { version = "1.5" }
-wgpu-types = { version = "26", default-features = false }
+wgpu-types = { version = "27", default-features = false }
 serde = { version = "1", features = ["derive"] }
 thiserror = { version = "2", default-features = false }
 futures-lite = "2.0.1"
diff --git a/crates/bevy_mesh/Cargo.toml b/crates/bevy_mesh/Cargo.toml
index eaa0dc2c574f0..c8e48307dc204 100644
--- a/crates/bevy_mesh/Cargo.toml
+++ b/crates/bevy_mesh/Cargo.toml
@@ -27,7 +27,7 @@ bevy_platform = { path = "../bevy_platform", version = "0.18.0-dev", default-fea
 # other
 bitflags = { version = "2.3", features = ["serde"] }
 bytemuck = { version = "1.5" }
-wgpu-types = { version = "26", default-features = false }
+wgpu-types = { version = "27", default-features = false }
 serde = { version = "1", default-features = false, features = [
   "derive",
 ], optional = true }
diff --git a/crates/bevy_reflect/Cargo.toml b/crates/bevy_reflect/Cargo.toml
index 5d5dfe1bc3249..46682e56c0c3e 100644
--- a/crates/bevy_reflect/Cargo.toml
+++ b/crates/bevy_reflect/Cargo.toml
@@ -125,7 +125,7 @@ uuid = { version = "1.13.1", default-features = false, optional = true, features
   "serde",
 ] }
 variadics_please = "1.1"
-wgpu-types = { version = "26", features = [
+wgpu-types = { version = "27", features = [
   "serde",
 ], optional = true, default-features = false }
 
diff --git a/crates/bevy_render/Cargo.toml b/crates/bevy_render/Cargo.toml
index 6edeec51654c0..69cdc5cd93c81 100644
--- a/crates/bevy_render/Cargo.toml
+++ b/crates/bevy_render/Cargo.toml
@@ -85,7 +85,7 @@ image = { version = "0.25.2", default-features = false }
 # It is enabled for now to avoid having to do a significant overhaul of the renderer just for wasm.
 # When the 'atomics' feature is enabled `fragile-send-sync-non-atomic` does nothing
 # and Bevy instead wraps `wgpu` types to verify they are not used off their origin thread.
-wgpu = { version = "26", default-features = false, features = [
+wgpu = { version = "27", default-features = false, features = [
   "wgsl",
   "dx12",
   "metal",
@@ -93,7 +93,7 @@ wgpu = { version = "26", default-features = false, features = [
   "naga-ir",
   "fragile-send-sync-non-atomic-wasm",
 ] }
-naga = { version = "26", features = ["wgsl-in"] }
+naga = { version = "27", features = ["wgsl-in"] }
 bytemuck = { version = "1.5", features = ["derive", "must_cast"] }
 downcast-rs = { version = "2", default-features = false, features = ["std"] }
 thiserror = { version = "2", default-features = false }
diff --git a/crates/bevy_render/src/batching/gpu_preprocessing.rs b/crates/bevy_render/src/batching/gpu_preprocessing.rs
index 02e3292f47a22..21780b222797d 100644
--- a/crates/bevy_render/src/batching/gpu_preprocessing.rs
+++ b/crates/bevy_render/src/batching/gpu_preprocessing.rs
@@ -1109,11 +1109,9 @@ impl FromWorld for GpuPreprocessingSupport {
                 || crate::get_mali_driver_version(adapter_info).is_some_and(|version| version < 48)
         }
 
-        let culling_feature_support = device.features().contains(
-            Features::INDIRECT_FIRST_INSTANCE
-                | Features::MULTI_DRAW_INDIRECT
-                | Features::PUSH_CONSTANTS,
-        );
+        let culling_feature_support = device
+            .features()
+            .contains(Features::INDIRECT_FIRST_INSTANCE | Features::PUSH_CONSTANTS);
         // Depth downsampling for occlusion culling requires 12 textures
         let limit_support = device.limits().max_storage_textures_per_shader_stage >= 12 &&
             // Even if the adapter supports compute, we might be simulating a lack of
diff --git a/crates/bevy_render/src/diagnostic/tracy_gpu.rs b/crates/bevy_render/src/diagnostic/tracy_gpu.rs
index c429c0ee245af..488e41581190a 100644
--- a/crates/bevy_render/src/diagnostic/tracy_gpu.rs
+++ b/crates/bevy_render/src/diagnostic/tracy_gpu.rs
@@ -61,7 +61,7 @@ fn initial_timestamp(device: &RenderDevice, queue: &RenderQueue) -> i64 {
 
     map_buffer.slice(..).map_async(MapMode::Read, |_| ());
     device
-        .poll(PollType::Wait)
+        .poll(PollType::wait_indefinitely())
         .expect("Failed to poll device for map async");
 
     let view = map_buffer.slice(..).get_mapped_range();
diff --git a/crates/bevy_render/src/render_resource/uniform_buffer.rs b/crates/bevy_render/src/render_resource/uniform_buffer.rs
index 03cfb8c644991..0fe93506eaa3f 100644
--- a/crates/bevy_render/src/render_resource/uniform_buffer.rs
+++ b/crates/bevy_render/src/render_resource/uniform_buffer.rs
@@ -277,7 +277,7 @@ impl<T: ShaderType + WriteInto> DynamicUniformBuffer<T> {
         max_count: usize,
         device: &RenderDevice,
         queue: &'a RenderQueue,
-    ) -> Option<DynamicUniformBufferWriter<'a, T>> {
+    ) -> Option<DynamicUniformBufferWriter<T>> {
         let alignment = if cfg!(target_abi = "sim") {
             // On iOS simulator on silicon macs, metal validation check that the host OS alignment
             // is respected, but the device reports the correct value for iOS, which is smaller.
@@ -357,27 +357,27 @@ impl<T: ShaderType + WriteInto> DynamicUniformBuffer<T> {
 /// A writer that can be used to directly write elements into the target buffer.
 ///
 /// For more information, see [`DynamicUniformBuffer::get_writer`].
-pub struct DynamicUniformBufferWriter<'a, T> {
-    buffer: encase::DynamicUniformBuffer<QueueWriteBufferViewWrapper<'a>>,
+pub struct DynamicUniformBufferWriter<T> {
+    buffer: encase::DynamicUniformBuffer<QueueWriteBufferViewWrapper>,
     _marker: PhantomData<fn() -> T>,
 }
 
-impl<'a, T: ShaderType + WriteInto> DynamicUniformBufferWriter<'a, T> {
+impl<T: ShaderType + WriteInto> DynamicUniformBufferWriter<T> {
     pub fn write(&mut self, value: &T) -> u32 {
         self.buffer.write(value).unwrap() as u32
     }
 }
 
-/// A wrapper to work around the orphan rule so that [`wgpu::QueueWriteBufferView`] can  implement
+/// A wrapper to work around the orphan rule so that [`wgpu::QueueWriteBufferView`] can implement
 /// [`BufferMut`].
-struct QueueWriteBufferViewWrapper<'a> {
-    buffer_view: wgpu::QueueWriteBufferView<'a>,
+struct QueueWriteBufferViewWrapper {
+    buffer_view: wgpu::QueueWriteBufferView,
     // Must be kept separately and cannot be retrieved from buffer_view, as the read-only access will
     // invoke a panic.
     capacity: usize,
 }
 
-impl<'a> BufferMut for QueueWriteBufferViewWrapper<'a> {
+impl BufferMut for QueueWriteBufferViewWrapper {
     #[inline]
     fn capacity(&self) -> usize {
         self.capacity
diff --git a/crates/bevy_render/src/renderer/mod.rs b/crates/bevy_render/src/renderer/mod.rs
index af716707fc44e..f4cd4ad07be5d 100644
--- a/crates/bevy_render/src/renderer/mod.rs
+++ b/crates/bevy_render/src/renderer/mod.rs
@@ -195,6 +195,9 @@ pub async fn initialize_renderer(
             },
             dx12: wgpu::Dx12BackendOptions {
                 shader_compiler: options.dx12_shader_compiler.clone(),
+                presentation_system: wgpu::wgt::Dx12SwapchainKind::from_env().unwrap_or_default(),
+                latency_waitable_object: wgpu::wgt::Dx12UseFrameLatencyWaitableObject::from_env()
+                    .unwrap_or_default(),
             },
             noop: wgpu::NoopBackendOptions { enable: false },
         },
@@ -431,7 +434,21 @@ pub async fn initialize_renderer(
             max_subgroup_size: limits
                 .max_subgroup_size
                 .min(constrained_limits.max_subgroup_size),
-            max_acceleration_structures_per_shader_stage: 0,
+            max_acceleration_structures_per_shader_stage: limits
+                .max_acceleration_structures_per_shader_stage
+                .min(constrained_limits.max_acceleration_structures_per_shader_stage),
+            max_task_workgroup_total_count: limits
+                .max_task_workgroup_total_count
+                .min(constrained_limits.max_task_workgroup_total_count),
+            max_task_workgroups_per_dimension: limits
+                .max_task_workgroups_per_dimension
+                .min(constrained_limits.max_task_workgroups_per_dimension),
+            max_mesh_output_layers: limits
+                .max_mesh_output_layers
+                .min(constrained_limits.max_mesh_output_layers),
+            max_mesh_multiview_count: limits
+                .max_mesh_multiview_count
+                .min(constrained_limits.max_mesh_multiview_count),
         };
     }
 
@@ -439,6 +456,8 @@ pub async fn initialize_renderer(
         label: options.device_label.as_ref().map(AsRef::as_ref),
         required_features: features,
         required_limits: limits,
+        // SAFETY: TODO, see https://github.com/bevyengine/bevy/issues/22082
+        experimental_features: unsafe { wgpu::ExperimentalFeatures::enabled() },
         memory_hints: options.memory_hints.clone(),
         // See https://github.com/gfx-rs/wgpu/issues/5974
         trace: Trace::Off,
diff --git a/crates/bevy_render/src/renderer/render_device.rs b/crates/bevy_render/src/renderer/render_device.rs
index 21a778040ebd0..f0334a9c8de71 100644
--- a/crates/bevy_render/src/renderer/render_device.rs
+++ b/crates/bevy_render/src/renderer/render_device.rs
@@ -61,19 +61,18 @@ impl RenderDevice {
             wgpu::ShaderSource::SpirV(source)
                 if self
                     .features()
-                    .contains(wgpu::Features::SPIRV_SHADER_PASSTHROUGH) =>
+                    .contains(wgpu::Features::EXPERIMENTAL_PASSTHROUGH_SHADERS) =>
             {
                 // SAFETY:
                 // This call passes binary data to the backend as-is and can potentially result in a driver crash or bogus behavior.
                 // No attempt is made to ensure that data is valid SPIR-V.
                 unsafe {
                     self.device.create_shader_module_passthrough(
-                        wgpu::ShaderModuleDescriptorPassthrough::SpirV(
-                            wgpu::ShaderModuleDescriptorSpirV {
-                                label: desc.label,
-                                source: source.clone(),
-                            },
-                        ),
+                        wgpu::ShaderModuleDescriptorPassthrough {
+                            label: desc.label,
+                            spirv: Some(source.clone()),
+                            ..Default::default()
+                        },
                     )
                 }
             }
diff --git a/crates/bevy_shader/Cargo.toml b/crates/bevy_shader/Cargo.toml
index 9a14fc0184258..f7f0ef3ba75c0 100644
--- a/crates/bevy_shader/Cargo.toml
+++ b/crates/bevy_shader/Cargo.toml
@@ -15,8 +15,8 @@ bevy_reflect = { path = "../bevy_reflect", version = "0.18.0-dev" }
 bevy_platform = { path = "../bevy_platform", version = "0.18.0-dev" }
 
 # other
-wgpu-types = { version = "26", default-features = false }
-naga = { version = "26", features = ["wgsl-in"] }
+wgpu-types = { version = "27", default-features = false }
+naga = { version = "27", features = ["wgsl-in"] }
 serde = { version = "1", features = ["derive"] }
 thiserror = { version = "2", default-features = false }
 wesl = { version = "0.2.0", optional = true }
@@ -25,12 +25,12 @@ tracing = { version = "0.1", default-features = false, features = ["std"] }
 
 [target.'cfg(not(target_arch = "wasm32"))'.dependencies]
 # Omit the `glsl` feature in non-WebAssembly by default.
-naga_oil = { version = "0.19", default-features = false, features = [
+naga_oil = { version = "0.20", default-features = false, features = [
   "test_shader",
 ] }
 
 [target.'cfg(target_arch = "wasm32")'.dependencies]
-naga_oil = { version = "0.19" }
+naga_oil = { version = "0.20" }
 
 [features]
 shader_format_glsl = ["naga/glsl-in", "naga/wgsl-out", "naga_oil/glsl"]
diff --git a/crates/bevy_solari/src/lib.rs b/crates/bevy_solari/src/lib.rs
index 6aaea2180fe0b..0b2e731926c54 100644
--- a/crates/bevy_solari/src/lib.rs
+++ b/crates/bevy_solari/src/lib.rs
@@ -49,8 +49,7 @@ impl PluginGroup for SolariPlugins {
 impl SolariPlugins {
     /// [`WgpuFeatures`] required for these plugins to function.
     pub fn required_wgpu_features() -> WgpuFeatures {
-        WgpuFeatures::EXPERIMENTAL_RAY_TRACING_ACCELERATION_STRUCTURE
-            | WgpuFeatures::EXPERIMENTAL_RAY_QUERY
+        WgpuFeatures::EXPERIMENTAL_RAY_QUERY
             | WgpuFeatures::BUFFER_BINDING_ARRAY
             | WgpuFeatures::TEXTURE_BINDING_ARRAY
             | WgpuFeatures::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING
diff --git a/crates/bevy_sprite/Cargo.toml b/crates/bevy_sprite/Cargo.toml
index f980c56fda8c6..823718762c495 100644
--- a/crates/bevy_sprite/Cargo.toml
+++ b/crates/bevy_sprite/Cargo.toml
@@ -32,7 +32,7 @@ bevy_text = { path = "../bevy_text", version = "0.18.0-dev", optional = true }
 # other
 radsort = "0.1"
 tracing = { version = "0.1", default-features = false, features = ["std"] }
-wgpu-types = { version = "26", default-features = false }
+wgpu-types = { version = "27", default-features = false }
 
 [dev-dependencies]
 approx = "0.5.1"
diff --git a/crates/bevy_text/Cargo.toml b/crates/bevy_text/Cargo.toml
index bc9b134f280a2..9e153138b989b 100644
--- a/crates/bevy_text/Cargo.toml
+++ b/crates/bevy_text/Cargo.toml
@@ -29,7 +29,7 @@ bevy_platform = { path = "../bevy_platform", version = "0.18.0-dev", default-fea
 ] }
 
 # other
-wgpu-types = { version = "26", default-features = false }
+wgpu-types = { version = "27", default-features = false }
 cosmic-text = { version = "0.15", features = ["shape-run-cache"] }
 thiserror = { version = "2", default-features = false }
 serde = { version = "1", features = ["derive"] }
diff --git a/crates/bevy_winit/Cargo.toml b/crates/bevy_winit/Cargo.toml
index 29b87ae8c1feb..6855cfce2314f 100644
--- a/crates/bevy_winit/Cargo.toml
+++ b/crates/bevy_winit/Cargo.toml
@@ -57,7 +57,7 @@ bevy_asset = { path = "../bevy_asset", version = "0.18.0-dev", optional = true }
 ## used by custom_cursor
 bevy_image = { path = "../bevy_image", version = "0.18.0-dev", optional = true }
 ## used by custom_cursor
-wgpu-types = { version = "26", optional = true }
+wgpu-types = { version = "27", optional = true }
 ## used by custom_cursor
 bytemuck = { version = "1.5", optional = true }
 
diff --git a/examples/app/headless_renderer.rs b/examples/app/headless_renderer.rs
index b8e11e2aabb13..b6aa5bf674636 100644
--- a/examples/app/headless_renderer.rs
+++ b/examples/app/headless_renderer.rs
@@ -449,7 +449,7 @@ fn receive_image_from_buffer(
 
         // This blocks until the gpu is done executing everything
         render_device
-            .poll(PollType::Wait)
+            .poll(PollType::wait_indefinitely())
             .expect("Failed to poll device for map async");
 
         // This blocks until the buffer is mapped
