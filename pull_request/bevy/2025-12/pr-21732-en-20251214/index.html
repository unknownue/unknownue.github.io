<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21732 Retain asset without data for RENDER_WORLD-only assets
        
    </title><meta content="#21732 Retain asset without data for RENDER_WORLD-only assets" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-14</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-21732-zh-cn-20251214>中文</a></div></div><div class=pr-content><h1 id=retain-asset-without-data-for-render-world-only-assets>Retain asset without data for RENDER_WORLD-only assets</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Retain asset without data for RENDER_WORLD-only assets<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21732<li><strong>Author</strong>: robtfm<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, A-Assets, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-11-03T13:47:36Z<li><strong>Merged</strong>: 2025-12-14T23:22:16Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>when <code>RenderAssets</code> with <code>RenderAssetUsages::RENDER_WORLD</code> and without <code>RenderAssetUsages::MAIN_WORLD</code> are extracted, the asset is removed from the assets collection. this causes some issues:<ul><li>systems which rely on the asset, like picking with meshes, fail with “asset not found” errors which are unintuitive.<li>loading the asset by path a second time results in the asset being reloaded from storage, re-extracted and re-transferred to gpu, replacing the existing asset<li>knowledge about the asset state is lost, we cannot tell if an asset is already loaded with <code>AssetServer::get_handle</code><li>metadata (image size, e.g.) is no longer available for the asset</ul><h2 id=solution>Solution</h2><h3 id=extraction>extraction:</h3><ul><li>add <code>take_gpu_data</code> to the <code>RenderAsset</code> trait. use it to pull the data out of the asset for transfer, and leave the empty asset in the collection. default implementation just <code>clone</code>s the asset.<li>if the data has already been taken, <del>panic. this follows from modifying an asset after extraction, which is always a code error, so i think panic here makes sense</del> <em>log an error</em></ul><h3 id=mesh-rendermesh>Mesh/RenderMesh:</h3><ul><li>make <code>Mesh::attributes</code> and <code>Mesh::indices</code> options<li>take them on extraction<li><code>expect</code> operations which access or modify the vertex data or indices if it has been extracted. accessing the vertex data after extraction is always a code error. fixes #19737 by resulting in the error <code>Mesh has been extracted to RenderWorld. To access vertex attributes, the mesh must have RenderAssetUsages::MAIN_WORLD</code><li>provide <code>try_xxx</code> operations which allow users to handle the access error gracefully if required (no usages as part of this pr, but provided for future)<li>compute the mesh <code>Aabb</code> when gpu data is taken and store the result. this allows extracted meshes to still use frustum culling (otherwise using multiple copies of an extracted mesh now panics as <code>compute_aabb</code> relied on vertex positions). there’s a bit of a tradeoff here: users may not need the Aabb and we needlessly compute it. but i think users almost always do want them, and computing once (for extracted meshes) is cheaper than the alternative, keeping position data and computing a fresh <code>Aabb</code> every time the mesh is used on a new entity.</ul><h3 id=image-gpuimage>Image/GpuImage:</h3><p>images are a little more complex because the data can be deliberately <code>None</code> for render-targets / GPU-written textures where we only want an uninitialized gpu-side texture.<ul><li>take <code>Image::data</code> on extraction<li>record on the resulting <code>GpuImage</code> whether any data was found initially<li>on subsequent modifications with no data, panic if there was data previously</ul><p>corner case / issue: when used with <code>RenderAssetBytesPerFrameLimiter</code> there may be no previous gpu asset if it is still queued pending upload due to the bandwidth limit. this can result in a modified image with initial data skipping the <code>had_data</code> check, resulting in a blank texture. i think this is sufficiently rare that it’s not a real problem, users would still hit the panic if the asset is transferred in time and the problem/solution should be clear when they do hit it.<h3 id=shaderstoragebuffer-gpushaderstoragebuffer>ShaderStorageBuffer/GpuShaderStorageBuffer</h3><p>follows the same pattern as Image/GpuImage:<ul><li>take <code>ShaderStorageBuffer::data</code> on extraction<li>record on the resulting <code>GpuShaderStorageBuffer</code> whether any data was found initially<li>on modifications with no data, panic if there was data previously</ul><p>we don’t have the queue issue here because <code>GpuShaderStorageBuffer</code> doesn’t implement <code>byte_len</code> so we can’t end up queueing them.<h4 id=other-renderassets>other RenderAssets</h4><p>i didn’t modify the other <code>RenderAsset</code> types (<code>GpuAutoExposureCompensationCurve</code>, <code>GpuLineGizmo</code>, <code>RenderWireframeMaterial</code>, <code>PreparedMaterial</code>, <code>PreparedMaterial2d</code>, <code>PreparedUiMaterial</code>) on the assumption that <del>cloning these is cheap enough anyway</del> <em>the asset usages are not exposed so we should never call <code>take_gpu_data</code>. the default implementation panics with a message directing users to implement the method if required</em><h2 id=testing>Testing</h2><p>only really tested within my work project. i can add some explicit tests if required.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a fundamental issue in Bevy’s asset extraction pipeline where assets marked with <code>RenderAssetUsages::RENDER_WORLD</code> but not <code>RenderAssetUsages::MAIN_WORLD</code> were being completely removed from the asset collection after extraction. This caused several practical problems for developers.<p>The core issue stemmed from a design decision to remove assets from CPU memory once they were uploaded to GPU memory, which makes sense for saving RAM but breaks important functionality. When an asset was extracted, the system would call <code>assets.remove(id)</code>, removing the asset entirely. This meant that systems like mesh picking would fail with “asset not found” errors, reloading an asset by path would cause redundant GPU uploads, and metadata like image dimensions became inaccessible.<p>The solution introduces a more nuanced approach: instead of removing the asset, we extract the GPU-specific data while keeping a skeleton of the asset in the collection. This requires a new abstraction to track which parts of an asset have been extracted.<h3 id=the-extraction-mechanism>The Extraction Mechanism</h3><p>The PR introduces a new <code>take_gpu_data</code> method on the <code>RenderAsset</code> trait:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>    </span><span style=color:#ff8f40>_source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>    </span><span style=color:#ff8f40>_previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>NoExtractionImplementation)
</span><span>}
</span></code></pre><p>The default implementation returns an error, indicating that the asset type doesn’t support this extraction pattern. For assets that do support it, the method should create a copy of the asset with the heavy data (like vertex positions or pixel data) moved out, leaving the original asset in a valid but data-less state.<p>In the extraction system, when an asset has only <code>RENDER_WORLD</code> usage (not <code>MAIN_WORLD</code>), instead of removing it, we now call:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>match </span><span>A</span><span style=color:#ed9366>::</span><span>take_gpu_data(asset</span><span style=color:#61676ccc>,</span><span> previous_asset) {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(gpu_data_asset) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        extracted_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((id</span><span style=color:#61676ccc>,</span><span> gpu_data_asset))</span><span style=color:#61676ccc>;
</span><span>        added</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(id)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(e) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        </span><span style=color:#f07171>error!</span><span>(</span><span style=color:#86b300>"... cannot be extracted: {e}"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>This preserves the asset handle and its metadata while transferring only the GPU-required data to the render world.<h3 id=mesh-the-most-complex-case>Mesh: The Most Complex Case</h3><p>Meshes presented the most challenging implementation because they have multiple data components (vertex attributes, indices, morph targets) that need coordinated extraction. The solution introduces a new enum <code>MeshExtractableData&LTT></code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>enum </span><span style=color:#399ee6>MeshExtractableData</span><span>&LTT> {
</span><span>    Data(T)</span><span style=color:#61676ccc>,
</span><span>    NoData</span><span style=color:#61676ccc>,
</span><span>    ExtractedToRenderWorld</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>This enum replaces direct fields in the <code>Mesh</code> struct:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>attributes</span><span style=color:#61676ccc>: </span><span>BTreeMap&LTMeshVertexAttributeId, MeshAttributeData></span><span style=color:#61676ccc>,
</span><span>indices</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTIndices></span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>attributes</span><span style=color:#61676ccc>: </span><span>MeshExtractableData&LTBTreeMap&LTMeshVertexAttributeId, MeshAttributeData>></span><span style=color:#61676ccc>,
</span><span>indices</span><span style=color:#61676ccc>: </span><span>MeshExtractableData&LTIndices></span><span style=color:#61676ccc>,
</span></code></pre><p>The <code>MeshExtractableData</code> type provides methods that return <code>Result</code> types with <code>MeshAccessError</code>, which can be either <code>ExtractedToRenderWorld</code> or <code>NotFound</code>. This allows the mesh to track whether data has been extracted and provide clear error messages.<p>When GPU data is taken from a mesh via <code>take_gpu_data()</code>, the method also computes and stores the mesh’s AABB:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(MeshAttributeData {
</span><span>    values</span><span style=color:#61676ccc>: </span><span>VertexAttributeValues</span><span style=color:#ed9366>::</span><span>Float32x3(position_values)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#ed9366>..
</span><span>}) </span><span style=color:#ed9366>=</span><span> attributes</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref_option</span><span>()</span><span style=color:#ed9366>?.</span><span style=color:#f07171>and_then</span><span>(|</span><span style=color:#ff8f40>attrs</span><span>| attrs</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ATTRIBUTE_POSITION</span><span style=color:#ed9366>.</span><span>id))
</span><span style=color:#ed9366>&& !</span><span>position_values</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>()
</span><span>{
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> iter </span><span style=color:#ed9366>=</span><span> position_values</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>p</span><span>| Vec3</span><span style=color:#ed9366>::</span><span>from_slice(p))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> min </span><span style=color:#ed9366>=</span><span> iter</span><span style=color:#ed9366>.</span><span style=color:#f07171>next</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> max </span><span style=color:#ed9366>=</span><span> min</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for</span><span> v </span><span style=color:#ed9366>in</span><span> iter {
</span><span>        min </span><span style=color:#ed9366>= </span><span>Vec3</span><span style=color:#ed9366>::</span><span>min(min</span><span style=color:#61676ccc>,</span><span> v)</span><span style=color:#61676ccc>;
</span><span>        max </span><span style=color:#ed9366>= </span><span>Vec3</span><span style=color:#ed9366>::</span><span>max(max</span><span style=color:#61676ccc>,</span><span> v)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>final_aabb </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Aabb3d</span><span style=color:#ed9366>::</span><span>new(min</span><span style=color:#61676ccc>,</span><span> max))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This AABB computation is necessary because frustum culling needs the mesh bounds, but after extraction, the vertex position data is no longer available. Computing it once during extraction is cheaper than keeping all vertex data in RAM just for AABB calculations.<h3 id=api-design-safe-access-patterns>API Design: Safe Access Patterns</h3><p>The mesh API was significantly refactored to provide safe access patterns. For every method that accesses mesh data (like <code>attribute()</code>, <code>indices()</code>, etc.), there are now three variants:<ol><li><strong>Panicking version</strong> (existing API): <code>mesh.attribute(id)</code> - panics with clear error message if data was extracted<li><strong>Result-returning version</strong>: <code>mesh.try_attribute(id)</code> - returns <code>Result<&VertexAttributeValues, MeshAccessError></code><li><strong>Optional version</strong>: <code>mesh.try_attribute_option(id)</code> - returns <code>Result&LTOption<&VertexAttributeValues>, MeshAccessError></code></ol><p>This pattern is applied consistently across all mesh access methods, including attribute access, index access, and mesh operations like <code>compute_normals()</code> and <code>transform_by()</code>.<h3 id=image-and-shaderstoragebuffer-patterns>Image and ShaderStorageBuffer Patterns</h3><p>For <code>Image</code> and <code>ShaderStorageBuffer</code>, the pattern is simpler since they only have one main data field. The solution tracks whether the asset originally had data:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// In GpuImage struct:
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>GpuImage </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing fields
</span><span>    </span><span style=color:#fa6e32>pub </span><span>had_data</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// In take_gpu_data for Image:
</span><span style=color:#fa6e32>let</span><span> data </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> valid_upload </span><span style=color:#ed9366>=</span><span> data</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() </span><span style=color:#ed9366>||</span><span> previous_gpu_asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none_or</span><span>(|</span><span style=color:#ff8f40>prev</span><span>| </span><span style=color:#ed9366>!</span><span>prev</span><span style=color:#ed9366>.</span><span>had_data)</span><span style=color:#61676ccc>;
</span><span>valid_upload</span><span style=color:#ed9366>.</span><span style=color:#f07171>then</span><span>(|| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset { data</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>..</span><span>source</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>() })
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>AlreadyExtracted)
</span></code></pre><p>The <code>had_data</code> flag is crucial for distinguishing between:<ol><li>An image that never had data (like a render target)<li>An image that had data but was extracted<li>An image that still has data</ol><h3 id=edge-cases-and-trade-offs>Edge Cases and Trade-offs</h3><p>The implementation handles several edge cases:<ol><li><p><strong>RenderAssetBytesPerFrameLimiter</strong>: When bandwidth limiting delays GPU upload, there might be no previous GPU asset to check against. This could allow an extracted image to be modified without detection. The PR author considers this rare enough to accept.</p><li><p><strong>AABB Computation Trade-off</strong>: Computing AABB for every extracted mesh adds overhead even if the mesh isn’t used for frustum culling. The alternative would be keeping vertex data in RAM or recomputing AABB each frame, both of which have worse performance characteristics.</p><li><p><strong>Backwards Compatibility</strong>: The existing panicking API is preserved, so existing code continues to work but with better error messages. New <code>try_</code> methods allow graceful error handling when needed.</p></ol><h3 id=impact-and-benefits>Impact and Benefits</h3><p>This change fixes multiple issues simultaneously:<ol><li><strong>Asset Discovery</strong>: Systems can now query if an asset exists without triggering reloads<li><strong>Metadata Access</strong>: Image dimensions, mesh topology, and other metadata remain accessible<li><strong>Error Clarity</strong>: Instead of “asset not found”, users get clear messages about extraction state<li><strong>Performance</strong>: Prevents redundant asset reloading and GPU uploads<li><strong>Memory Efficiency</strong>: Still achieves the original goal of freeing CPU memory for GPU-only assets</ol><p>The implementation demonstrates a sophisticated approach to resource management where assets transition through states (full → extracted → potentially reloaded) while maintaining API safety and clear error reporting.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Asset Loaded with RENDER_WORLD only] --> B{Extraction Phase}
</span><span>    B -->|take_gpu_data| C[GPU Data Extracted]
</span><span>    B -->|Original Asset| D[Asset Skeleton Retained]
</span><span>    C --> E[Render World Processing]
</span><span>    D --> F[CPU-side Queries]
</span><span>    D --> G[Metadata Access]
</span><span>    D --> H[Handle Exists Checks]
</span><span>    
</span><span>    subgraph "Mesh Specifics"
</span><span>        I[Vertex Attributes] --> J[Extracted as MeshExtractableData]
</span><span>        K[Indices] --> J
</span><span>        J --> L[AABB Computed & Stored]
</span><span>        L --> M[Frustum Culling Available]
</span><span>    end
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-mesh-src-mesh-rs-1032-102><code>crates/bevy_mesh/src/mesh.rs</code> (+1032/-102)</h3><p>This file contains the majority of changes, implementing the <code>MeshExtractableData</code> system and updating all mesh access methods.<p><strong>Key changes:</strong><ul><li>Introduced <code>MeshExtractableData&LTT></code> enum to track extraction state<li>Added <code>final_aabb</code> field to store computed bounds after extraction<li>Updated all access methods to return <code>Result</code> types with clear errors<li>Implemented <code>take_gpu_data()</code> method for mesh extraction</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Example of the new access pattern:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>try_attribute</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>id</span><span style=color:#61676ccc>:</span><span> impl </span><span style=color:#55b4d4;font-style:italic>Into</span><span>&LTMeshVertexAttributeId>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#ed9366>&</span><span>VertexAttributeValues, MeshAccessError> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>try_attribute_option</span><span>(id)</span><span style=color:#ed9366>?
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(MeshAccessError</span><span style=color:#ed9366>::</span><span>NotFound)
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>take_gpu_data</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span>, MeshAccessError> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> attributes </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>attributes</span><span style=color:#ed9366>.</span><span style=color:#f07171>extract</span><span>()</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> indices </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>indices</span><span style=color:#ed9366>.</span><span style=color:#f07171>extract</span><span>()</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... compute AABB when data exists
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#fa6e32>Self </span><span>{
</span><span>        attributes</span><span style=color:#61676ccc>,
</span><span>        indices</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>..</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()
</span><span>    })
</span><span>}
</span></code></pre><h3 id=crates-bevy-render-src-render-asset-rs-34-4><code>crates/bevy_render/src/render_asset.rs</code> (+34/-4)</h3><p>Added the <code>take_gpu_data</code> trait method and updated the extraction system.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// New trait method:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>    </span><span style=color:#ff8f40>_source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>    </span><span style=color:#ff8f40>_previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>NoExtractionImplementation)
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Updated extraction logic:
</span><span style=color:#fa6e32>match </span><span>A</span><span style=color:#ed9366>::</span><span>take_gpu_data(asset</span><span style=color:#61676ccc>,</span><span> previous_asset) {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(gpu_data_asset) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        extracted_assets</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((id</span><span style=color:#61676ccc>,</span><span> gpu_data_asset))</span><span style=color:#61676ccc>;
</span><span>        added</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(id)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(e) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        </span><span style=color:#f07171>error!</span><span>(</span><span style=color:#86b300>"... cannot be extracted: {e}"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-render-src-storage-rs-26-3><code>crates/bevy_render/src/storage.rs</code> (+26/-3)</h3><p>Implemented <code>take_gpu_data</code> for <code>ShaderStorageBuffer</code> with <code>had_data</code> tracking.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>take_gpu_data</span><span>(
</span><span>    </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>SourceAsset,
</span><span>    </span><span style=color:#ff8f40>previous_gpu_asset</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset, AssetExtractionError> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> data </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> valid_upload </span><span style=color:#ed9366>=</span><span> data</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some</span><span>() </span><span style=color:#ed9366>||</span><span> previous_gpu_asset</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none_or</span><span>(|</span><span style=color:#ff8f40>prev</span><span>| </span><span style=color:#ed9366>!</span><span>prev</span><span style=color:#ed9366>.</span><span>had_data)</span><span style=color:#61676ccc>;
</span><span>    valid_upload
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>then</span><span>(|| </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>SourceAsset {
</span><span>            data</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>..</span><span>source</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()
</span><span>        })
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>ok_or</span><span>(AssetExtractionError</span><span style=color:#ed9366>::</span><span>AlreadyExtracted)
</span><span>}
</span></code></pre><h3 id=crates-bevy-render-src-texture-gpu-image-rs-22-1><code>crates/bevy_render/src/texture/gpu_image.rs</code> (+22/-1)</h3><p>Implemented <code>take_gpu_data</code> for <code>Image</code> with similar <code>had_data</code> tracking.<h3 id=crates-bevy-render-src-mesh-mod-rs-12-1><code>crates/bevy_render/src/mesh/mod.rs</code> (+12/-1)</h3><p>Implemented <code>take_gpu_data</code> for <code>RenderMesh</code> to delegate to the mesh’s implementation.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_render/latest/bevy_render/render_asset/trait.RenderAsset.html target=_blank>Bevy Render Assets Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/features/assets.html target=_blank>Asset System in Bevy</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/ecs/render-world/ target=_blank>Render World Architecture</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch09-00-error-handling.html target=_blank>Error Handling in Rust</a></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_21732.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>