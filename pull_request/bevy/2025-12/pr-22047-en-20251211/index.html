<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22047 UI per text section picking
        
    </title><meta content="#22047 UI per text section picking" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-11</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22047-zh-cn-20251211>中文</a></div></div><div class=pr-content><h1 id=ui-per-text-section-picking>UI per text section picking</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: UI per text section picking<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22047<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-UI, S-Ready-For-Final-Review, M-Migration-Guide, A-Text, M-Release-Note, D-Modest, A-Picking<li><strong>Created</strong>: 2025-12-06T20:20:52Z<li><strong>Merged</strong>: 2025-12-11T02:16:28Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description>Description</h2><p>Allow picking text per section.<p>Fixes #17477<h2 id=solution>Solution</h2><p>In <code>ui_picking</code> whenever a node with text components is below a pointer, don’t add the <code>Text</code> node’s entity to the <code>hit_nodes</code> list. Instead, iterate the list of text section bounding rects in its <code>TextLayoutInfo</code> component to find which text section the pointer is over, and add that section’s entity id to the <code>hit_nodes</code> list.<ul><li>Add optional text components to <code>NodeQuery</code>.<li>New helper function, <code>pick_ui_text</code>. Finds if a text section is hovered and returns its id.<li>Add the entities of text sections to <code>hit_nodes</code> when hovered.<li>Add the target camera entity to <code>hit_nodes</code>, instead of querying for it a second time.<li>When a picked node is a text node and <code>require_markers</code> is enabled, check if the hit section entity has a <code>Pickable</code> component, instead of the text node.</ul><h1></h1><p>This design might need to be changed later to allow for text selection and copying. But there doesn’t seem any need to overcomplicate things for now by considering it.<h2 id=testing>Testing</h2><p>I added observers to the <code>TextBackgroundColors</code> example’s text entities. The observers turn a text section’s text color to white when the pointer hovers them.<pre style=color:#61676c;background-color:#fafafa><code><span>cargo run --example text_background_colors
</span></code></pre><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This pull request addresses a specific limitation in Bevy’s UI picking system where text nodes were treated as monolithic clickable areas. The issue #17477 highlighted that developers needed finer-grained control over text interaction, wanting to make individual text sections within a single text node respond to pointer events separately.<p>The core problem was straightforward: when a UI text node contained multiple sections (like different colored words or styled phrases), the entire rectangular area of the text node would register as pickable, even areas that didn’t contain actual text. This made it impossible to create interactive text elements where only the text itself was clickable, not the surrounding empty space in the text node’s bounds.<p>The solution modifies the <code>ui_picking</code> system to examine the actual bounding rectangles of individual text sections rather than treating the entire text node as a single pickable area. This required several coordinated changes to the picking backend.<p>First, the <code>NodeQuery</code> needed to be extended to optionally include text layout information:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>NodeQuery </span><span>{
</span><span>    pickable</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> Pickable>,
</span><span>    inherited_visibility</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> InheritedVisibility>,
</span><span>    target_camera</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> ComputedUiTargetCamera,
</span><span>    text_node</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> TextLayoutInfo, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> ComputedTextBlock)>,
</span><span>}
</span></code></pre><p>This change allows the picking system to detect when it’s dealing with a text node and access the necessary layout data. The <code>TextLayoutInfo</code> contains the geometric information about where each text section is rendered, while <code>ComputedTextBlock</code> holds the entity relationships for text sections.<p>The main picking logic in <code>ui_picking</code> was restructured to handle text nodes differently. Previously, when a pointer was over a text node, the entire node’s entity would be added to the hit list. Now, the system checks if the node has text components and, if so, uses a new helper function <code>pick_ui_text_section</code> to determine which specific text section is under the pointer:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>((text_layout_info</span><span style=color:#61676ccc>,</span><span> text_block)) </span><span style=color:#ed9366>=</span><span> node</span><span style=color:#ed9366>.</span><span>text_node {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(text_entity) </span><span style=color:#ed9366>= </span><span style=color:#f07171>pick_ui_text_section</span><span>(
</span><span>        node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#61676ccc>,
</span><span>        node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>*</span><span>cursor_position</span><span style=color:#61676ccc>,
</span><span>        text_layout_info</span><span style=color:#61676ccc>,
</span><span>        text_block</span><span style=color:#61676ccc>,
</span><span>    ) {
</span><span>        </span><span style=color:#fa6e32>if</span><span> settings</span><span style=color:#ed9366>.</span><span>require_markers </span><span style=color:#ed9366>&& !</span><span>pickable_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(text_entity) {
</span><span>            </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>
</span><span>        hit_nodes
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>((camera_entity</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>pointer_id))
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((
</span><span>                text_entity</span><span style=color:#61676ccc>,
</span><span>                camera_entity</span><span style=color:#61676ccc>,
</span><span>                node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>inverse</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>transform_point2</span><span>(</span><span style=color:#ed9366>*</span><span>cursor_position)
</span><span>                    </span><span style=color:#ed9366>/</span><span> node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>()</span><span style=color:#61676ccc>,
</span><span>            ))</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>pick_ui_text_section</code> function performs the critical work of mapping pointer coordinates to individual text sections:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>pick_ui_text_section</span><span>(
</span><span>    </span><span style=color:#ff8f40>uinode</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ComputedNode,
</span><span>    </span><span style=color:#ff8f40>global_transform</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>UiGlobalTransform,
</span><span>    </span><span style=color:#ff8f40>point</span><span style=color:#61676ccc>:</span><span> Vec2,
</span><span>    </span><span style=color:#ff8f40>text_layout_info</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>TextLayoutInfo,
</span><span>    </span><span style=color:#ff8f40>text_block</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>ComputedTextBlock,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> local_point </span><span style=color:#ed9366>=</span><span> global_transform
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>try_inverse</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>transform</span><span>| transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>transform_point2</span><span>(point) </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>0.5 </span><span style=color:#ed9366>*</span><span> uinode</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>())</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>for</span><span> run </span><span style=color:#ed9366>in</span><span> text_layout_info</span><span style=color:#ed9366>.</span><span>run_geometry</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span><span>        </span><span style=color:#fa6e32>if</span><span> run</span><span style=color:#ed9366>.</span><span>bounds</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(local_point) {
</span><span>            </span><span style=color:#fa6e32>return</span><span> text_block</span><span style=color:#ed9366>.</span><span style=color:#f07171>entities</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(run</span><span style=color:#ed9366>.</span><span>span_index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>e</span><span>| e</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#55b4d4;font-style:italic>None
</span><span>}
</span></code></pre><p>This function converts the pointer position from global coordinates to the text node’s local coordinate system, then iterates through the text layout runs to find which one contains the point. If found, it returns the entity of that specific text section.<p>An important architectural change was modifying the data structure of <code>hit_nodes</code> from <code>Vec<(Entity, Vec2)></code> to <code>Vec<(Entity, Entity, Vec2)></code>. This change stores the camera entity alongside each hit entity, eliminating the need to query for it again later. This is a small but meaningful optimization that reduces redundant work.<p>The PR also includes necessary adjustments to handle the <code>Pickable</code> component correctly. When <code>require_markers</code> is enabled (which requires entities to have a <code>Pickable</code> component to be pickable), the system now checks if the individual text section entity has a <code>Pickable</code> component, not the parent text node. This allows for per-section control over pickability.<p>The example update demonstrates the practical utility of this feature. The <code>text_background_colors</code> example now attaches observers to each text section that change the text color when hovered:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>.</span><span style=color:#f07171>observe</span><span>(
</span><span>    |</span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span>On&LTPointer&LTOver>></span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>query</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> TextColor>| {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#fa6e32>mut</span><span> text_color) </span><span style=color:#ed9366>=</span><span> query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(event</span><span style=color:#ed9366>.</span><span>entity) {
</span><span>            text_color</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>= </span><span>Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>WHITE</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>)
</span><span style=color:#ed9366>.</span><span style=color:#f07171>observe</span><span>(
</span><span>    |</span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span>On&LTPointer&LTOut>></span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>query</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> TextColor>| {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#fa6e32>mut</span><span> text_color) </span><span style=color:#ed9366>=</span><span> query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(event</span><span style=color:#ed9366>.</span><span>entity) {
</span><span>            text_color</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>= </span><span>Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>BLACK</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>This creates a hover effect where individual colored text sections change to white when the pointer is over them, providing immediate visual feedback for the picking behavior.<p>The PR acknowledges that this implementation might need refinement for future features like text selection and copying, but correctly prioritizes solving the immediate need without overengineering. The migration guide and release notes properly document the breaking change: non-text areas of UI text nodes are no longer pickable, and developers needing the old behavior can use an intermediate parent node to intercept pointer hits.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Pointer Event] --> B[ui_picking system]
</span><span>    B --> C{Node has text components?}
</span><span>    C -->|Yes| D[Check text section bounds]
</span><span>    C -->|No| E[Check node bounds]
</span><span>    D --> F{Found matching text section?}
</span><span>    F -->|Yes| G[Add text section entity to hit_nodes]
</span><span>    F -->|No| H[No hit recorded]
</span><span>    E --> I{Node bounds contain pointer?}
</span><span>    I -->|Yes| J[Add node entity to hit_nodes]
</span><span>    I -->|No| H
</span><span>    G --> K[Process hits with per-section pickable checks]
</span><span>    J --> L[Process hits with node pickable checks]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><ol><li><p><strong><code>crates/bevy_ui/src/picking_backend.rs</code> (+55/-15)</strong></p> <ul><li>This is the core file where the picking logic was modified to support per-text-section picking.<li>Added text components to <code>NodeQuery</code> to detect text nodes.<li>Changed <code>hit_nodes</code> data structure to store camera entity alongside hit entity.<li>Added <code>pick_ui_text_section</code> helper function for text section picking.<li>Modified picking logic to handle text nodes specially.</ul> <p>Key changes:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Simple node-only picking
</span><span style=color:#fa6e32>if</span><span> node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains_point</span><span>(</span><span style=color:#ed9366>*</span><span>node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>cursor_position) {
</span><span>    hit_nodes
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>((camera_entity</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>pointer_id))
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((node_entity</span><span style=color:#61676ccc>,</span><span> position))</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Text-aware picking
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>((text_layout_info</span><span style=color:#61676ccc>,</span><span> text_block)) </span><span style=color:#ed9366>=</span><span> node</span><span style=color:#ed9366>.</span><span>text_node {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(text_entity) </span><span style=color:#ed9366>= </span><span style=color:#f07171>pick_ui_text_section</span><span>(</span><span style=color:#ed9366>...</span><span>) {
</span><span>        hit_nodes
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>((camera_entity</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>pointer_id))
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((text_entity</span><span style=color:#61676ccc>,</span><span> camera_entity</span><span style=color:#61676ccc>,</span><span> position))</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>} </span><span style=color:#fa6e32>else if</span><span> node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains_point</span><span>(</span><span style=color:#ed9366>*</span><span>node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>cursor_position) {
</span><span>    hit_nodes
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>((camera_entity</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>*</span><span>pointer_id))
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((node_entity</span><span style=color:#61676ccc>,</span><span> camera_entity</span><span style=color:#61676ccc>,</span><span> position))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><li><p><strong><code>examples/ui/text_background_colors.rs</code> (+24/-9)</strong></p> <ul><li>Updated to demonstrate the new per-text-section picking feature.<li>Added observers to each text section entity that change color on hover.<li>Shows practical use of the feature for interactive text elements.</ul> <p>Key addition:</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ed9366>.</span><span style=color:#f07171>observe</span><span>(
</span><span>    |</span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span>On&LTPointer&LTOver>></span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>query</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> TextColor>| {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#fa6e32>mut</span><span> text_color) </span><span style=color:#ed9366>=</span><span> query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(event</span><span style=color:#ed9366>.</span><span>entity) {
</span><span>            text_color</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>= </span><span>Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>WHITE</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>)
</span></code></pre><li><p><strong><code>release-content/migration-guides/the_non_text_areas_of_text_nodes_are_no_longer_pickable.md</code> (+7/-0)</strong></p> <ul><li>New migration guide explaining the breaking change.<li>Documents that only text-containing areas are now pickable.<li>Provides workaround using intermediate parent nodes for old behavior.</ul><li><p><strong><code>release-content/release-notes/per_text_section_picking.md</code> (+7/-0)</strong></p> <ul><li>Release note announcing the new feature.<li>Credits the author and links to the PR.</ul></ol><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_picking/latest/bevy_picking/ target=_blank>Bevy Picking System Documentation</a> - For understanding Bevy’s picking architecture<li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_text/latest/bevy_text/ target=_blank>Bevy UI Text System</a> - For details on text layout and section management<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/observers/ target=_blank>Observer Pattern in Bevy</a> - For understanding how observers work with picking events<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/ui/ target=_blank>Coordinate Systems in Bevy UI</a> - For understanding UI coordinate transformations used in the picking calculations</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22047.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>