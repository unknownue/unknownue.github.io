diff --git a/benches/benches/bevy_reflect/function.rs b/benches/benches/bevy_reflect/function.rs
index ff4c8dca2ffc0..f155d227c8803 100644
--- a/benches/benches/bevy_reflect/function.rs
+++ b/benches/benches/bevy_reflect/function.rs
@@ -48,6 +48,10 @@ fn into(c: &mut Criterion) {
         .bench_function("closure_mut", |b| {
             let mut _capture = 25;
             // `move` is required here because `into_function_mut()` takes ownership of `self`.
+            #[expect(
+                unused_assignments,
+                reason = "rustc bug https://github.com/rust-lang/rust/issues/149889"
+            )]
             let closure = move |a: i32| _capture += a;
             b.iter(|| closure.into_function_mut());
         });
diff --git a/crates/bevy_asset/src/reflect.rs b/crates/bevy_asset/src/reflect.rs
index 063d3dccc8fb7..08ceea28c486f 100644
--- a/crates/bevy_asset/src/reflect.rs
+++ b/crates/bevy_asset/src/reflect.rs
@@ -59,11 +59,11 @@ impl ReflectAsset {
         world: &'w mut World,
         asset_id: impl Into<UntypedAssetId>,
     ) -> Option<&'w mut dyn Reflect> {
-        // SAFETY: unique world access
         #[expect(
             unsafe_code,
             reason = "Use of unsafe `Self::get_unchecked_mut()` function."
         )]
+        // SAFETY: unique world access
         unsafe {
             (self.get_unchecked_mut)(world.as_unsafe_world_cell(), asset_id.into())
         }
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/bundle_on_drop_impl.stderr b/crates/bevy_ecs/compile_fail/tests/ui/bundle_on_drop_impl.stderr
new file mode 100644
index 0000000000000..6cd6d26422fdd
--- /dev/null
+++ b/crates/bevy_ecs/compile_fail/tests/ui/bundle_on_drop_impl.stderr
@@ -0,0 +1,14 @@
+error[E0509]: cannot move out of type `DropBundle`, which implements the `Drop` trait
+ --> tests/ui/bundle_on_drop_impl.rs:7:10
+  |
+7 | #[derive(Bundle, Debug)]
+  |          ^^^^^^
+  |          |
+  |          cannot move out of here
+  |          move occurs because value has type `A`, which does not implement the `Copy` trait
+  |
+  = note: this error originates in the macro `bevy_ecs::ptr::deconstruct_moving_ptr` which comes from the expansion of the derive macro `Bundle` (in Nightly builds, run with -Z macro-backtrace for more info)
+
+error: aborting due to 1 previous error
+
+For more information about this error, try `rustc --explain E0509`.
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.rs b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.rs
index ef6b98cf09417..ffb9173f232ef 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.rs
+++ b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.rs
@@ -9,6 +9,6 @@ use bevy_ecs::prelude::*;
 )]
 pub struct FooWrongCall;
 
-fn wrong_bazzing(path: &str) -> impl Fn(bevy_ecs::world::DeferredWorld) {
-    |world| {}
+fn wrong_bazzing(_path: &str) -> impl Fn(bevy_ecs::world::DeferredWorld) {
+    |_world| {}
 }
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.stderr b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.stderr
index 967cffe4ff399..c9502a7d58f68 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_call_signature_mismatch.stderr
@@ -1,32 +1,18 @@
-warning: unused variable: `path`
-  --> tests/ui/component_hook_call_signature_mismatch.rs:12:18
-   |
-12 | fn wrong_bazzing(path: &str) -> impl Fn(bevy_ecs::world::DeferredWorld) {
-   |                  ^^^^ help: if this is intentional, prefix it with an underscore: `_path`
-   |
-   = note: `#[warn(unused_variables)]` on by default
-
-warning: unused variable: `world`
-  --> tests/ui/component_hook_call_signature_mismatch.rs:13:6
-   |
-13 |     |world| {}
-   |      ^^^^^ help: if this is intentional, prefix it with an underscore: `_world`
-
 error[E0057]: this function takes 1 argument but 2 arguments were supplied
   --> tests/ui/component_hook_call_signature_mismatch.rs:8:14
    |
-5  | #[derive(Component)]
+ 5 | #[derive(Component)]
    |          --------- unexpected argument #2 of type `HookContext`
 ...
-8  |     on_add = wrong_bazzing("foo"),
+ 8 |     on_add = wrong_bazzing("foo"),
    |              ^^^^^^^^^^^^^^^^^^^^
    |
 note: opaque type defined here
-  --> tests/ui/component_hook_call_signature_mismatch.rs:12:33
+  --> tests/ui/component_hook_call_signature_mismatch.rs:12:34
    |
-12 | fn wrong_bazzing(path: &str) -> impl Fn(bevy_ecs::world::DeferredWorld) {
-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+12 | fn wrong_bazzing(_path: &str) -> impl Fn(bevy_ecs::world::DeferredWorld) {
+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-error: aborting due to 1 previous error; 2 warnings emitted
+error: aborting due to 1 previous error
 
 For more information about this error, try `rustc --explain E0057`.
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr
index 01e4d57578af4..6ef40f9bf0255 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr
@@ -22,68 +22,88 @@ error: Custom on_despawn hooks are not supported as this RelationshipTarget alre
 52 |     #[component(on_despawn = foo_hook)]
    |     ^
 
-error[E0277]: the trait bound `FooTargetOfFail: Relationship` is not satisfied
+error[E0277]: the trait bound `FooTargetOfFail: bevy_ecs::relationship::Relationship` is not satisfied
    --> tests/ui/component_hook_relationship.rs:13:42
     |
-13  |     #[relationship_target(relationship = FooTargetOfFail)]
-    |                                          ^^^^^^^^^^^^^^^ the trait `Relationship` is not implemented for `FooTargetOfFail`
+ 13 |     #[relationship_target(relationship = FooTargetOfFail)]
+    |                                          ^^^^^^^^^^^^^^^ unsatisfied trait bound
     |
-    = help: the following other types implement trait `Relationship`:
+help: the trait `bevy_ecs::relationship::Relationship` is not implemented for `FooTargetOfFail`
+   --> tests/ui/component_hook_relationship.rs:10:5
+    |
+ 10 |     pub struct FooTargetOfFail(Entity);
+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
+    = help: the following other types implement trait `bevy_ecs::relationship::Relationship`:
               BarTargetOf
               ChildOf
               FooTargetOf
 note: required by a bound in `bevy_ecs::relationship::RelationshipTarget::Relationship`
-   --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:167:24
+   --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:234:24
     |
-167 |     type Relationship: Relationship<RelationshipTarget = Self>;
+234 |     type Relationship: Relationship<RelationshipTarget = Self>;
     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `RelationshipTarget::Relationship`
 
 error[E0277]: the trait bound `FooTargetsFail: bevy_ecs::relationship::RelationshipTarget` is not satisfied
   --> tests/ui/component_hook_relationship.rs:28:42
    |
 28 |     #[relationship(relationship_target = FooTargetsFail)]
-   |                                          ^^^^^^^^^^^^^^ the trait `bevy_ecs::relationship::RelationshipTarget` is not implemented for `FooTargetsFail`
+   |                                          ^^^^^^^^^^^^^^ unsatisfied trait bound
+   |
+help: the trait `bevy_ecs::relationship::RelationshipTarget` is not implemented for `FooTargetsFail`
+  --> tests/ui/component_hook_relationship.rs:25:5
    |
+25 |     pub struct FooTargetsFail(Vec<Entity>);
+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: the following other types implement trait `bevy_ecs::relationship::RelationshipTarget`:
              BarTargets
              Children
              FooTargets
 note: required by a bound in `bevy_ecs::relationship::Relationship::RelationshipTarget`
-  --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:79:30
+  --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:81:30
    |
-79 |     type RelationshipTarget: RelationshipTarget<Relationship = Self>;
+81 |     type RelationshipTarget: RelationshipTarget<Relationship = Self>;
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Relationship::RelationshipTarget`
 
-error[E0277]: the trait bound `BarTargetOfFail: Relationship` is not satisfied
+error[E0277]: the trait bound `BarTargetOfFail: bevy_ecs::relationship::Relationship` is not satisfied
    --> tests/ui/component_hook_relationship.rs:43:42
     |
-43  |     #[relationship_target(relationship = BarTargetOfFail)]
-    |                                          ^^^^^^^^^^^^^^^ the trait `Relationship` is not implemented for `BarTargetOfFail`
+ 43 |     #[relationship_target(relationship = BarTargetOfFail)]
+    |                                          ^^^^^^^^^^^^^^^ unsatisfied trait bound
     |
-    = help: the following other types implement trait `Relationship`:
+help: the trait `bevy_ecs::relationship::Relationship` is not implemented for `BarTargetOfFail`
+   --> tests/ui/component_hook_relationship.rs:40:5
+    |
+ 40 |     pub struct BarTargetOfFail(Entity);
+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
+    = help: the following other types implement trait `bevy_ecs::relationship::Relationship`:
               BarTargetOf
               ChildOf
               FooTargetOf
 note: required by a bound in `bevy_ecs::relationship::RelationshipTarget::Relationship`
-   --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:167:24
+   --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:234:24
     |
-167 |     type Relationship: Relationship<RelationshipTarget = Self>;
+234 |     type Relationship: Relationship<RelationshipTarget = Self>;
     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `RelationshipTarget::Relationship`
 
 error[E0277]: the trait bound `BarTargetsFail: bevy_ecs::relationship::RelationshipTarget` is not satisfied
   --> tests/ui/component_hook_relationship.rs:58:42
    |
 58 |     #[relationship(relationship_target = BarTargetsFail)]
-   |                                          ^^^^^^^^^^^^^^ the trait `bevy_ecs::relationship::RelationshipTarget` is not implemented for `BarTargetsFail`
+   |                                          ^^^^^^^^^^^^^^ unsatisfied trait bound
+   |
+help: the trait `bevy_ecs::relationship::RelationshipTarget` is not implemented for `BarTargetsFail`
+  --> tests/ui/component_hook_relationship.rs:55:5
    |
+55 |     pub struct BarTargetsFail(Vec<Entity>);
+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: the following other types implement trait `bevy_ecs::relationship::RelationshipTarget`:
              BarTargets
              Children
              FooTargets
 note: required by a bound in `bevy_ecs::relationship::Relationship::RelationshipTarget`
-  --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:79:30
+  --> $BEVY_ROOT/bevy_ecs/src/relationship/mod.rs:81:30
    |
-79 |     type RelationshipTarget: RelationshipTarget<Relationship = Self>;
+81 |     type RelationshipTarget: RelationshipTarget<Relationship = Self>;
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Relationship::RelationshipTarget`
 
 error: aborting due to 8 previous errors
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/deconstruct_moving_ptr.stderr b/crates/bevy_ecs/compile_fail/tests/ui/deconstruct_moving_ptr.stderr
new file mode 100644
index 0000000000000..1534e2e7dac03
--- /dev/null
+++ b/crates/bevy_ecs/compile_fail/tests/ui/deconstruct_moving_ptr.stderr
@@ -0,0 +1,224 @@
+error[E0025]: field `x` bound multiple times in the pattern
+  --> tests/ui/deconstruct_moving_ptr.rs:25:5
+   |
+25 | /     deconstruct_moving_ptr!({
+26 | |         let A { x, x } = a;
+27 | |     });
+   | |      ^
+   | |      |
+   | |______multiple uses of `x` in pattern
+   |        first use of `x`
+   |
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:31:5
+   |
+31 | /     deconstruct_moving_ptr!({
+32 | |         let A { x } = box_a;
+33 | |     });
+   | |      ^
+   | |      |
+   | |______expected `Box<A>`, found `A`
+   |        this expression has type `&mut Box<A>`
+   |
+   = note: expected struct `Box<A>`
+              found struct `A`
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+help: consider dereferencing to access the inner value using the Deref trait
+  --> $BEVY_ROOT/bevy_ptr/src/lib.rs:1461:57
+   |
+146|             let $struct_name { $($field_index: _),* } = &**value;
+   |                                                         +++
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:31:5
+   |
+31 | /     deconstruct_moving_ptr!({
+32 | |         let A { x } = box_a;
+33 | |     });
+   | |______^ expected `A`, found `Box<A>`
+   |
+   = note: expected struct `A`
+              found struct `Box<A>`
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:35:5
+   |
+35 | /     deconstruct_moving_ptr!({
+36 | |         let A { x } = mut_a;
+37 | |     });
+   | |______^ expected `A`, found `&mut A`
+   |
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:39:5
+   |
+39 | /     deconstruct_moving_ptr!({
+40 | |         let tuple { 0: _ } = box_t1;
+41 | |     });
+   | |      ^
+   | |      |
+   | |______expected `Box<(usize,)>`, found `(_,)`
+   |        expected due to the type of this binding
+   |
+   = note: expected struct `Box<(usize,)>`
+               found tuple `(_,)`
+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+help: store this in the heap by calling `Box::new`
+  --> $BEVY_ROOT/bevy_ptr/src/lib.rs:1420:22
+   |
+142|             *value = Box::new(($(unreachable($field_index),)*));
+   |                      +++++++++                                +
+help: consider dereferencing here to assign to the mutably borrowed value
+  --> $BEVY_ROOT/bevy_ptr/src/lib.rs:1420:13
+   |
+142|             **value = ($(unreachable($field_index),)*);
+   |             +
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:43:5
+   |
+43 | /     deconstruct_moving_ptr!({
+44 | |         let tuple { 0: _ } = mut_t1;
+45 | |     });
+   | |      ^
+   | |      |
+   | |______expected `&mut (usize,)`, found `(_,)`
+   |        expected due to the type of this binding
+   |
+   = note: expected mutable reference `&mut (usize,)`
+                          found tuple `(_,)`
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+help: consider dereferencing here to assign to the mutably borrowed value
+  --> $BEVY_ROOT/bevy_ptr/src/lib.rs:1420:13
+   |
+142|             **value = ($(unreachable($field_index),)*);
+   |             +
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:47:5
+   |
+47 | /     deconstruct_moving_ptr!({
+48 | |         let tuple { 0: _, 1: _ } = box_t2;
+49 | |     });
+   | |      ^
+   | |      |
+   | |______expected `Box<(usize, usize)>`, found `(_, _)`
+   |        expected due to the type of this binding
+   |
+   = note: expected struct `Box<(usize, usize)>`
+               found tuple `(_, _)`
+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+help: store this in the heap by calling `Box::new`
+  --> $BEVY_ROOT/bevy_ptr/src/lib.rs:1420:22
+   |
+142|             *value = Box::new(($(unreachable($field_index),)*));
+   |                      +++++++++                                +
+help: consider dereferencing here to assign to the mutably borrowed value
+  --> $BEVY_ROOT/bevy_ptr/src/lib.rs:1420:13
+   |
+142|             **value = ($(unreachable($field_index),)*);
+   |             +
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:51:5
+   |
+51 | /     deconstruct_moving_ptr!({
+52 | |         let tuple { 0: _, 1: _ } = mut_t2;
+53 | |     });
+   | |      ^
+   | |      |
+   | |______expected `&mut (usize, usize)`, found `(_, _)`
+   |        expected due to the type of this binding
+   |
+   = note: expected mutable reference `&mut (usize, usize)`
+                          found tuple `(_, _)`
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+help: consider dereferencing here to assign to the mutably borrowed value
+  --> $BEVY_ROOT/bevy_ptr/src/lib.rs:1420:13
+   |
+142|             **value = ($(unreachable($field_index),)*);
+   |             +
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:77:23
+   |
+75 | /     deconstruct_moving_ptr!({
+76 | |
+77 | |         let A { x } = a;
+   | |                       ^ expected `MovingPtr<'_, _, _>`, found `&mut MovingPtr<'_, A>`
+78 | |     });
+   | |______- expected due to this
+   |
+   = note:         expected struct `MovingPtr<'_, _, _>`
+           found mutable reference `&mut MovingPtr<'_, A, Aligned>`
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:81:30
+   |
+79 | /     deconstruct_moving_ptr!({
+80 | |
+81 | |         let tuple { 0: _ } = t1;
+   | |                              ^^ expected `MovingPtr<'_, _, _>`, found `&mut MovingPtr<'_, (usize,)>`
+82 | |     });
+   | |______- expected due to this
+   |
+   = note:         expected struct `MovingPtr<'_, _, _>`
+           found mutable reference `&mut MovingPtr<'_, (usize,), Aligned>`
+
+error[E0308]: mismatched types
+  --> tests/ui/deconstruct_moving_ptr.rs:85:36
+   |
+83 | /     deconstruct_moving_ptr!({
+84 | |
+85 | |         let tuple { 0: _, 1: _ } = t2;
+   | |                                    ^^ expected `MovingPtr<'_, _, _>`, found `&mut MovingPtr<'_, (usize, usize)>`
+86 | |     });
+   | |______- expected due to this
+   |
+   = note:         expected struct `MovingPtr<'_, _, _>`
+           found mutable reference `&mut MovingPtr<'_, (usize, usize), Aligned>`
+
+error[E0499]: cannot borrow value as mutable more than once at a time
+  --> tests/ui/deconstruct_moving_ptr.rs:59:5
+   |
+59 | /     deconstruct_moving_ptr!({
+60 | |         let tuple { 0: _, 0: _ } = t;
+61 | |     });
+   | |      ^
+   | |      |
+   | |______value was mutably borrowed here in the previous iteration of the loop
+   |        first borrow later used here
+   |
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+
+error[E0793]: reference to packed field is unaligned
+  --> tests/ui/deconstruct_moving_ptr.rs:67:5
+   |
+67 | /     deconstruct_moving_ptr!({
+68 | |         let B { x } = b;
+69 | |     });
+   | |______^
+   |
+   = note: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses
+   = note: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)
+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)
+   = note: this error originates in the macro `deconstruct_moving_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)
+
+warning: unused variable: `x`
+  --> tests/ui/deconstruct_moving_ptr.rs:68:17
+   |
+68 |         let B { x } = b;
+   |                 ^ help: if this is intentional, prefix it with an underscore: `_x`
+   |
+   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
+
+error: aborting due to 13 previous errors; 1 warning emitted
+
+Some errors have detailed explanations: E0025, E0308, E0499, E0793.
+For more information about an error, try `rustc --explain E0025`.
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/query_exact_sized_iterator_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/query_exact_sized_iterator_safety.stderr
index ba14761f58e8f..65c3ed45a91b2 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/query_exact_sized_iterator_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/query_exact_sized_iterator_safety.stderr
@@ -1,7 +1,7 @@
 error[E0277]: `bevy_ecs::query::Changed<Foo>` is not a valid `Query` filter based on archetype information
   --> tests/ui/query_exact_sized_iterator_safety.rs:7:28
    |
-7  |     is_exact_size_iterator(query.iter());
+ 7 |     is_exact_size_iterator(query.iter());
    |     ---------------------- ^^^^^^^^^^^^ invalid `Query` filter
    |     |
    |     required by a bound introduced by this call
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/query_iter_combinations_mut_iterator_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/query_iter_combinations_mut_iterator_safety.stderr
index cb40b8f11ccb5..9c382e6e403f7 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/query_iter_combinations_mut_iterator_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/query_iter_combinations_mut_iterator_safety.stderr
@@ -1,7 +1,7 @@
 error[E0277]: the trait bound `&mut A: ReadOnlyQueryData` is not satisfied
   --> tests/ui/query_iter_combinations_mut_iterator_safety.rs:9:17
    |
-9  |     is_iterator(iter)
+ 9 |     is_iterator(iter)
    |     ----------- ^^^^ the trait `ReadOnlyQueryData` is not implemented for `&mut A`
    |     |
    |     required by a bound introduced by this call
@@ -15,7 +15,7 @@ error[E0277]: the trait bound `&mut A: ReadOnlyQueryData` is not satisfied
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
-           and 36 others
+           and 37 others
    = note: `ReadOnlyQueryData` is implemented for `&A`, but not for `&mut A`
    = note: required for `QueryCombinationIter<'_, '_, &mut A, (), _>` to implement `Iterator`
 note: required by a bound in `is_iterator`
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/query_iter_many_mut_iterator_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/query_iter_many_mut_iterator_safety.stderr
index 24aafb1df49fc..a00fc7c321c5a 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/query_iter_many_mut_iterator_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/query_iter_many_mut_iterator_safety.stderr
@@ -1,7 +1,7 @@
 error[E0277]: the trait bound `&mut A: ReadOnlyQueryData` is not satisfied
   --> tests/ui/query_iter_many_mut_iterator_safety.rs:9:17
    |
-9  |     is_iterator(iter)
+ 9 |     is_iterator(iter)
    |     ----------- ^^^^ the trait `ReadOnlyQueryData` is not implemented for `&mut A`
    |     |
    |     required by a bound introduced by this call
@@ -15,7 +15,7 @@ error[E0277]: the trait bound `&mut A: ReadOnlyQueryData` is not satisfied
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
-           and 36 others
+           and 37 others
    = note: `ReadOnlyQueryData` is implemented for `&A`, but not for `&mut A`
    = note: required for `QueryManyIter<'_, '_, &mut A, (), std::array::IntoIter<bevy_ecs::entity::Entity, 1>>` to implement `Iterator`
 note: required by a bound in `is_iterator`
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/query_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/query_lifetime_safety.stderr
index c39840127ad45..96ad14019be8c 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/query_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/query_lifetime_safety.stderr
@@ -23,9 +23,9 @@ error[E0502]: cannot borrow `query` as immutable because it is also borrowed as
 error[E0502]: cannot borrow `query` as mutable because it is also borrowed as immutable
   --> tests/ui/query_lifetime_safety.rs:31:39
    |
-30 |             let data: &Foo = query.single();
+30 |             let data: &Foo = query.single().unwrap();
    |                              ----- immutable borrow occurs here
-31 |             let mut data2: Mut<Foo> = query.single_mut();
+31 |             let mut data2: Mut<Foo> = query.single_mut().unwrap();
    |                                       ^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
 32 |
 33 |             assert_eq!(data, &mut *data2); // oops UB
@@ -34,9 +34,9 @@ error[E0502]: cannot borrow `query` as mutable because it is also borrowed as im
 error[E0502]: cannot borrow `query` as immutable because it is also borrowed as mutable
   --> tests/ui/query_lifetime_safety.rs:38:30
    |
-37 |             let mut data2: Mut<Foo> = query.single_mut();
+37 |             let mut data2: Mut<Foo> = query.single_mut().unwrap();
    |                                       ----- mutable borrow occurs here
-38 |             let data: &Foo = query.single();
+38 |             let data: &Foo = query.single().unwrap();
    |                              ^^^^^ immutable borrow occurs here
 39 |
 40 |             assert_eq!(data, &mut *data2); // oops UB
@@ -48,7 +48,7 @@ error[E0502]: cannot borrow `query` as mutable because it is also borrowed as im
 44 |             let data: &Foo = query.single().unwrap();
    |                              ----- immutable borrow occurs here
 45 |             let mut data2: Mut<Foo> = query.single_mut().unwrap();
-   |                                       ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
+   |                                       ^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
 46 |
 47 |             assert_eq!(data, &mut *data2); // oops UB
    |             ----------------------------- immutable borrow later used here
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/query_to_readonly.stderr b/crates/bevy_ecs/compile_fail/tests/ui/query_to_readonly.stderr
index 30cbc3c14221b..8ba81f0954499 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/query_to_readonly.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/query_to_readonly.stderr
@@ -23,7 +23,7 @@ error[E0502]: cannot borrow `query` as mutable because it is also borrowed as im
 error[E0502]: cannot borrow `query` as immutable because it is also borrowed as mutable
   --> tests/ui/query_to_readonly.rs:41:30
    |
-38 |         let mut mut_foo = query.single_mut();
+38 |         let mut mut_foo = query.single_mut().unwrap();
    |                           ----- mutable borrow occurs here
 ...
 41 |         let readonly_query = query.as_readonly();
@@ -38,11 +38,11 @@ error[E0502]: cannot borrow `query` as mutable because it is also borrowed as im
 54 |         let readonly_query = query.as_readonly();
    |                              ----- immutable borrow occurs here
 ...
-58 |         let mut mut_foo = query.single_mut();
+58 |         let mut mut_foo = query.single_mut().unwrap();
    |                           ^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
 ...
 61 |         println!("{ref_foo:?}");
-   |                   ----------- immutable borrow later used here
+   |                    ------- immutable borrow later used here
 
 error: aborting due to 4 previous errors
 
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/query_transmute_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/query_transmute_safety.stderr
index d0234b197e595..edd87da242c11 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/query_transmute_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/query_transmute_safety.stderr
@@ -17,7 +17,7 @@ error[E0499]: cannot borrow `lens` as mutable more than once at a time
 34 |         let mut query_b = lens.query();
    |                           ^^^^ second mutable borrow occurs here
 ...
-37 |         let a = query_a.single_mut();
+37 |         let a = query_a.single_mut().unwrap();
    |                 ------- first borrow later used here
 
 error: aborting due to 2 previous errors
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_param_derive_readonly.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_param_derive_readonly.stderr
index 2f767d960cb2f..8d0ad83216136 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_param_derive_readonly.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_param_derive_readonly.stderr
@@ -1,7 +1,7 @@
 error[E0277]: the trait bound `&'static mut Foo: ReadOnlyQueryData` is not satisfied
    --> tests/ui/system_param_derive_readonly.rs:16:11
     |
-16  |     state.get(&world);
+ 16 |     state.get(&world);
     |           ^^^ the trait `ReadOnlyQueryData` is not implemented for `&'static mut Foo`
     |
     = help: the following other types implement trait `ReadOnlyQueryData`:
@@ -13,18 +13,18 @@ error[E0277]: the trait bound `&'static mut Foo: ReadOnlyQueryData` is not satis
               (F0, F1, F2)
               (F0, F1, F2, F3)
               (F0, F1, F2, F3, F4)
-            and 36 others
+            and 37 others
     = note: `ReadOnlyQueryData` is implemented for `&'static Foo`, but not for `&'static mut Foo`
     = note: required for `bevy_ecs::system::Query<'_, '_, &'static mut Foo>` to implement `ReadOnlySystemParam`
     = note: 1 redundant requirement hidden
     = note: required for `Mutable<'_, '_>` to implement `ReadOnlySystemParam`
 note: required by a bound in `SystemState::<Param>::get`
-   --> $BEVY_ROOT/bevy_ecs/src/system/function_system.rs:487:16
+   --> $BEVY_ROOT/bevy_ecs/src/system/function_system.rs:355:16
     |
-485 |     pub fn get<'w, 's>(&'s mut self, world: &'w World) -> SystemParamItem<'w, 's, Param>
+353 |     pub fn get<'w, 's>(&'s mut self, world: &'w World) -> SystemParamItem<'w, 's, Param>
     |            --- required by a bound in this associated function
-486 |     where
-487 |         Param: ReadOnlySystemParam,
+354 |     where
+355 |         Param: ReadOnlySystemParam,
     |                ^^^^^^^^^^^^^^^^^^^ required by this bound in `SystemState::<Param>::get`
 
 error: aborting due to 1 previous error
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_lifetime_safety.stderr
index cd003db5125fe..be8418424288a 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_lifetime_safety.stderr
@@ -1,11 +1,11 @@
 error[E0499]: cannot borrow `query` as mutable more than once at a time
   --> tests/ui/system_query_get_lifetime_safety.rs:8:14
    |
-7  |     let a1 = query.get_mut(e).unwrap();
+ 7 |     let a1 = query.get_mut(e).unwrap();
    |              ----- first mutable borrow occurs here
-8  |     let a2 = query.get_mut(e).unwrap();
+ 8 |     let a2 = query.get_mut(e).unwrap();
    |              ^^^^^ second mutable borrow occurs here
-9  |
+ 9 |
 10 |     println!("{} {}", a1.0, a2.0);
    |                       -- first borrow later used here
 
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_lifetime_safety.stderr
index 91e8b81509e05..310a88f0da935 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_lifetime_safety.stderr
@@ -1,11 +1,11 @@
 error[E0502]: cannot borrow `query` as mutable because it is also borrowed as immutable
   --> tests/ui/system_query_get_many_lifetime_safety.rs:8:14
    |
-7  |     let a1 = query.get_many([e, e]).unwrap();
+ 7 |     let a1 = query.get_many([e, e]).unwrap();
    |              ----- immutable borrow occurs here
-8  |     let a2 = query.get_mut(e).unwrap();
+ 8 |     let a2 = query.get_mut(e).unwrap();
    |              ^^^^^^^^^^^^^^^^ mutable borrow occurs here
-9  |
+ 9 |
 10 |     println!("{} {}", a1[0].0, a2.0);
    |                       ----- immutable borrow later used here
 
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_mut_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_mut_lifetime_safety.stderr
index 567a1da1a683e..fb770e42b2a9c 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_mut_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_query_get_many_mut_lifetime_safety.stderr
@@ -1,11 +1,11 @@
 error[E0499]: cannot borrow `query` as mutable more than once at a time
   --> tests/ui/system_query_get_many_mut_lifetime_safety.rs:8:14
    |
-7  |     let a1 = query.get_many_mut([e, e]).unwrap();
+ 7 |     let a1 = query.get_many_mut([e, e]).unwrap();
    |              ----- first mutable borrow occurs here
-8  |     let a2 = query.get_mut(e).unwrap();
+ 8 |     let a2 = query.get_mut(e).unwrap();
    |              ^^^^^ second mutable borrow occurs here
-9  |
+ 9 |
 10 |     println!("{} {}", a1[0].0, a2.0);
    |                       ----- first borrow later used here
 
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_lifetime_safety.stderr
index bcae3940a4811..309bd73fd7c79 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_lifetime_safety.stderr
@@ -1,7 +1,7 @@
 error[E0499]: cannot borrow `query` as mutable more than once at a time
   --> tests/ui/system_query_iter_lifetime_safety.rs:10:21
    |
-7  |     let mut iter = query.iter_mut();
+ 7 |     let mut iter = query.iter_mut();
    |                    ----- first mutable borrow occurs here
 ...
 10 |     let mut iter2 = query.iter_mut();
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_sort_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_sort_lifetime_safety.stderr
index 4565ece326b29..d3966c0fd158f 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_sort_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_query_iter_sort_lifetime_safety.stderr
@@ -1,7 +1,7 @@
 error[E0521]: borrowed data escapes outside of closure
   --> tests/ui/system_query_iter_sort_lifetime_safety.rs:12:9
    |
-9  |     let mut stored: Option<&A> = None;
+ 9 |     let mut stored: Option<&A> = None;
    |         ---------- `stored` declared here, outside of the closure body
 10 |     let mut sorted = iter.sort_by::<&A>(|left, _right| {
    |                                          ---- `left` is a reference that is only valid in the closure body
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_get_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_get_lifetime_safety.stderr
index be0598f1eb767..1aaceb1721ad8 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_get_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_get_lifetime_safety.stderr
@@ -1,7 +1,7 @@
 error[E0499]: cannot borrow `queries` as mutable more than once at a time
   --> tests/ui/system_query_set_get_lifetime_safety.rs:10:14
    |
-7  |     let mut q2 = queries.p0();
+ 7 |     let mut q2 = queries.p0();
    |                  ------- first mutable borrow occurs here
 ...
 10 |     let q1 = queries.p1();
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_iter_lifetime_safety.stderr b/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_iter_lifetime_safety.stderr
index 8d1a50bd3f8cc..8aebf6c7b6c4d 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_iter_lifetime_safety.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/system_query_set_iter_lifetime_safety.stderr
@@ -1,7 +1,7 @@
 error[E0499]: cannot borrow `queries` as mutable more than once at a time
   --> tests/ui/system_query_set_iter_lifetime_safety.rs:11:14
    |
-7  |     let mut q2 = queries.p0();
+ 7 |     let mut q2 = queries.p0();
    |                  ------- first mutable borrow occurs here
 ...
 11 |     let q1 = queries.p1();
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/world_query_derive.stderr b/crates/bevy_ecs/compile_fail/tests/ui/world_query_derive.stderr
index ec71c112a6a05..2ece1b014ebd1 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/world_query_derive.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/world_query_derive.stderr
@@ -19,20 +19,25 @@ error[E0277]: the trait bound `&'static mut Foo: ReadOnlyQueryData` is not satis
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
-           and 39 others
+           and 40 others
 note: required by a bound in `_::assert_readonly`
   --> tests/ui/world_query_derive.rs:7:10
    |
-7  | #[derive(QueryData)]
+ 7 | #[derive(QueryData)]
    |          ^^^^^^^^^ required by this bound in `assert_readonly`
    = note: this error originates in the derive macro `QueryData` (in Nightly builds, run with -Z macro-backtrace for more info)
 
 error[E0277]: the trait bound `MutableMarked: ReadOnlyQueryData` is not satisfied
-  --> tests/ui/world_query_derive.rs:43:8
+  --> tests/ui/world_query_derive.rs:29:8
    |
-43 |     a: MutableMarked,
-   |        ^^^^^^^^^^^^^ the trait `ReadOnlyQueryData` is not implemented for `MutableMarked`
+29 |     a: MutableMarked,
+   |        ^^^^^^^^^^^^^ unsatisfied trait bound
    |
+help: the trait `ReadOnlyQueryData` is not implemented for `MutableMarked`
+  --> tests/ui/world_query_derive.rs:22:1
+   |
+22 | struct MutableMarked {
+   | ^^^^^^^^^^^^^^^^^^^^
    = help: the following other types implement trait `ReadOnlyQueryData`:
              &Archetype
              &T
@@ -42,14 +47,14 @@ error[E0277]: the trait bound `MutableMarked: ReadOnlyQueryData` is not satisfie
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
-           and 39 others
+           and 40 others
 note: required by a bound in `_::assert_readonly`
-  --> tests/ui/world_query_derive.rs:40:10
+  --> tests/ui/world_query_derive.rs:26:10
    |
-40 | #[derive(QueryData)]
+26 | #[derive(QueryData)]
    |          ^^^^^^^^^ required by this bound in `assert_readonly`
    = note: this error originates in the derive macro `QueryData` (in Nightly builds, run with -Z macro-backtrace for more info)
 
-error: aborting due to 5 previous errors
+error: aborting due to 3 previous errors
 
 For more information about this error, try `rustc --explain E0277`.
diff --git a/crates/bevy_ecs/src/system/exclusive_system_param.rs b/crates/bevy_ecs/src/system/exclusive_system_param.rs
index f87182ab1f13c..89bd1b0d8bcfe 100644
--- a/crates/bevy_ecs/src/system/exclusive_system_param.rs
+++ b/crates/bevy_ecs/src/system/exclusive_system_param.rs
@@ -100,6 +100,7 @@ macro_rules! impl_exclusive_system_param_tuple {
             unused_variables,
             reason = "Zero-length tuples won't use any of the parameters."
         )]
+        #[allow(clippy::unused_unit, reason = "Zero length tuple is unit.")]
         $(#[$meta])*
         impl<$($param: ExclusiveSystemParam),*> ExclusiveSystemParam for ($($param,)*) {
             type State = ($($param::State,)*);
@@ -107,7 +108,7 @@ macro_rules! impl_exclusive_system_param_tuple {
 
             #[inline]
             fn init(world: &mut World, system_meta: &mut SystemMeta) -> Self::State {
-                (($($param::init(world, system_meta),)*))
+                ($($param::init(world, system_meta),)*)
             }
 
             #[inline]
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index 32b4044e6f25b..de15c850ccdb9 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -2145,6 +2145,7 @@ macro_rules! impl_system_param_tuple {
             unused_variables,
             reason = "Zero-length tuples won't use some of the parameters."
         )]
+        #[allow(clippy::unused_unit, reason = "Zero length tuple is unit.")]
         $(#[$meta])*
         // SAFETY: implementers of each `SystemParam` in the tuple have validated their impls
         unsafe impl<$($param: SystemParam),*> SystemParam for ($($param,)*) {
@@ -2153,7 +2154,7 @@ macro_rules! impl_system_param_tuple {
 
             #[inline]
             fn init_state(world: &mut World) -> Self::State {
-                (($($param::init_state(world),)*))
+                ($($param::init_state(world),)*)
             }
 
             fn init_access(state: &Self::State, _system_meta: &mut SystemMeta, _component_access_set: &mut FilteredAccessSet, _world: &mut World) {
diff --git a/crates/bevy_reflect/src/path/parse.rs b/crates/bevy_reflect/src/path/parse.rs
index be5856834a9c3..1a8a0c55f8654 100644
--- a/crates/bevy_reflect/src/path/parse.rs
+++ b/crates/bevy_reflect/src/path/parse.rs
@@ -59,16 +59,16 @@ impl<'a> PathParser<'a> {
         // If we do not find a subsequent token, we are at the end of the parse string.
         let ident_len = to_parse.iter().position(|t| Token::SYMBOLS.contains(t));
         let (ident, remaining) = to_parse.split_at(ident_len.unwrap_or(to_parse.len()));
+        #[expect(
+            unsafe_code,
+            reason = "We have fulfilled the Safety requirements for `from_utf8_unchecked`."
+        )]
         // SAFETY: This relies on `self.remaining` always remaining valid UTF8:
         // - self.remaining is a slice derived from self.path (valid &str)
         // - The slice's end is either the same as the valid &str or
         //   the last byte before an ASCII utf-8 character (ie: it is a char
         //   boundary).
         // - The slice always starts after a symbol ie: an ASCII character's boundary.
-        #[expect(
-            unsafe_code,
-            reason = "We have fulfilled the Safety requirements for `from_utf8_unchecked`."
-        )]
         let ident = unsafe { from_utf8_unchecked(ident) };
 
         self.remaining = remaining;
diff --git a/crates/bevy_remote/src/builtin_methods.rs b/crates/bevy_remote/src/builtin_methods.rs
index 5c359dab5b2e1..4ee7f336aefc2 100644
--- a/crates/bevy_remote/src/builtin_methods.rs
+++ b/crates/bevy_remote/src/builtin_methods.rs
@@ -1690,8 +1690,6 @@ mod tests {
 
     #[test]
     fn insert_reflect_only_component() {
-        use bevy_ecs::prelude::Component;
-        use bevy_reflect::Reflect;
         #[derive(Reflect, Component)]
         #[reflect(Component)]
         struct Player {
diff --git a/crates/bevy_render/src/diagnostic/internal.rs b/crates/bevy_render/src/diagnostic/internal.rs
index ec226c760b96b..2bd360c51bee6 100644
--- a/crates/bevy_render/src/diagnostic/internal.rs
+++ b/crates/bevy_render/src/diagnostic/internal.rs
@@ -323,11 +323,7 @@ impl FrameData {
     ) -> &mut SpanRecord {
         let thread_id = thread::current().id();
 
-        let parent = self
-            .open_spans
-            .iter()
-            .filter(|v| v.thread_id == thread_id)
-            .next_back();
+        let parent = self.open_spans.iter().rfind(|v| v.thread_id == thread_id);
 
         let path_range = match &parent {
             Some(parent) if parent.path_range.end == self.path_components.len() => {
@@ -363,8 +359,7 @@ impl FrameData {
         let iter = self.open_spans.iter();
         let (index, _) = iter
             .enumerate()
-            .filter(|(_, v)| v.thread_id == thread_id)
-            .next_back()
+            .rfind(|(_, v)| v.thread_id == thread_id)
             .unwrap();
 
         let span = self.open_spans.swap_remove(index);
diff --git a/crates/bevy_transform/src/systems.rs b/crates/bevy_transform/src/systems.rs
index 62038b37ed90f..34366b1b3ce25 100644
--- a/crates/bevy_transform/src/systems.rs
+++ b/crates/bevy_transform/src/systems.rs
@@ -881,12 +881,12 @@ mod test {
         // cannot happen
         let mut a = unsafe { child_entity.get_mut_assume_mutable::<ChildOf>().unwrap() };
 
-        // SAFETY: ChildOf is not mutable but this is for a test to produce a scenario that
-        // cannot happen
         #[expect(
             unsafe_code,
             reason = "ChildOf is not mutable but this is for a test to produce a scenario that cannot happen"
         )]
+        // SAFETY: ChildOf is not mutable but this is for a test to produce a scenario that
+        // cannot happen
         let mut b = unsafe {
             grandchild_entity
                 .get_mut_assume_mutable::<ChildOf>()
diff --git a/tools/export-content/src/app.rs b/tools/export-content/src/app.rs
index 7fa2be0d1a494..f734375ccb45a 100644
--- a/tools/export-content/src/app.rs
+++ b/tools/export-content/src/app.rs
@@ -1,3 +1,8 @@
+#![expect(
+    unused_assignments,
+    reason = "Warnings from inside miette due to a rustc bug: https://github.com/rust-lang/rust/issues/147648"
+)]
+
 use std::{env, fs, io::Write, path::PathBuf};
 
 use miette::{diagnostic, Context, Diagnostic, IntoDiagnostic, NamedSource, Result};
