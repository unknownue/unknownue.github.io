<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21983 Add a new `almost_finish` method for `Timer` with immediate first `tick` action
        
    </title><meta content="#21983 Add a new `almost_finish` method for `Timer` with immediate first `tick` action" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-10</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-21983-zh-cn-20251210>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add a new <code>almost_finish</code> method for <code>Timer</code> with immediate first <code>tick</code> action<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21983<li><strong>Author</strong>: Rajveer100<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Usability, S-Ready-For-Final-Review, A-Time, X-Uncontroversial, D-Straightforward<li><strong>Created</strong>: 2025-11-30T11:38:10Z<li><strong>Merged</strong>: 2025-12-10T19:58:51Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>Objective</strong><p>Resolves #21860<p>This new method would tick the timer by <code>duration - 1 ns</code> leaving a very short waiting time for the first tick initiated by the user allowing immediate action.<p><strong>Solution</strong><p>The <code>almost_finish</code> method updates the timer by ticking it with <code>1ns</code> remaining.<p><strong>Testing</strong><p>Tests have been added in <code>almost_finished_repeating</code>.<h1 id=the-story-of-this-pull-request>The Story of This Pull Request</h1><h2 id=the-problem-and-context>The Problem and Context</h2><p>The Bevy engine’s <code>Timer</code> struct provides timing functionality for game development. Developers commonly use timers to trigger actions after a delay, such as spawning enemies or changing game states. However, there was a specific use case where developers wanted to initialize a timer so that its first completion would happen almost immediately when the game starts running, rather than waiting the full duration.<p>Issue #21860 identified this need. The problem was that when you set up a timer with a long duration, you had to wait that entire duration for the first tick to trigger an action. This created a delay at the start of gameplay or system initialization that wasn’t always desirable. Developers needed a way to advance a timer to the point where it would finish on the next update cycle, enabling immediate action without manual time manipulation.<h2 id=the-solution-approach>The Solution Approach</h2><p>The solution implemented is straightforward: add an <code>almost_finish</code> method that advances the timer by nearly its entire duration, leaving exactly 1 nanosecond remaining. This approach has several advantages:<ol><li><strong>Minimal remaining time</strong>: 1 nanosecond is effectively zero in game time terms, ensuring the timer finishes on the next tick<li><strong>No special handling</strong>: The timer can still be used with existing <code>tick()</code> methods<li><strong>Preserves timer state</strong>: The timer isn’t marked as finished until the actual tick occurs, maintaining consistency</ol><p>This method provides a cleaner alternative to manually calculating and calling <code>tick()</code> with a specific duration, reducing boilerplate code and potential errors.<h2 id=the-implementation>The Implementation</h2><p>The implementation adds a single method to the <code>Timer</code> struct in <code>timer.rs</code>. The method is simple but well-considered:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>almost_finish</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> remaining </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>remaining</span><span>() </span><span style=color:#ed9366>- </span><span>Duration</span><span style=color:#ed9366>::</span><span>from_nanos(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>tick</span><span>(remaining)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The key technical aspects:<ul><li>It uses <code>self.remaining()</code> to get the current time left<li>Subtracts 1 nanosecond to leave minimal time remaining<li>Calls the existing <code>tick()</code> method with the calculated duration<li>The <code>#[inline]</code> attribute suggests this is expected to be a performance-sensitive operation</ul><p>This implementation leverages the existing <code>tick()</code> infrastructure, ensuring consistency with how timers normally progress. The method works correctly with both <code>TimerMode::Once</code> and <code>TimerMode::Repeating</code> timers because it simply advances the timer state without special-case logic.<p>The test added verifies the behavior:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>almost_finished_repeating</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> t </span><span style=color:#ed9366>= </span><span>Timer</span><span style=color:#ed9366>::</span><span>from_seconds(</span><span style=color:#ff8f40>10.0</span><span style=color:#61676ccc>, </span><span>TimerMode</span><span style=color:#ed9366>::</span><span>Repeating)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> duration </span><span style=color:#ed9366>= </span><span>Duration</span><span style=color:#ed9366>::</span><span>from_nanos(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    t</span><span style=color:#ed9366>.</span><span style=color:#f07171>almost_finish</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert!</span><span>(</span><span style=color:#ed9366>!</span><span>t</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_finished</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>times_finished_this_tick</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>remaining</span><span>()</span><span style=color:#61676ccc>, </span><span>Duration</span><span style=color:#ed9366>::</span><span>from_nanos(</span><span style=color:#ff8f40>1</span><span>))</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    t</span><span style=color:#ed9366>.</span><span style=color:#f07171>tick</span><span>(duration)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_finished</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>times_finished_this_tick</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This test confirms several important behaviors:<ol><li>After <code>almost_finish()</code>, the timer is not yet marked as finished<li>Exactly 1 nanosecond remains<li>A subsequent tick of 1 nanosecond completes the timer<li>The timer properly reports finishing on that tick</ol><h2 id=technical-insights>Technical Insights</h2><p>The choice of 1 nanosecond is significant. While it’s theoretically possible to use 0 time remaining, that would require special handling to avoid division by zero or other edge cases in the timer logic. By leaving 1 nanosecond, the timer maintains all its normal behavior while being practically ready to finish.<p>This implementation follows the principle of least surprise: <code>almost_finish()</code> doesn’t immediately mark the timer as finished, which would be inconsistent with how timers normally work. Instead, it puts the timer in a state where the next update cycle will complete it.<p>The method also includes comprehensive documentation with examples, making it clear how to use it:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Almost finishes the timer leaving 1 ns of remaining time.
</span><span style=color:#abb0b6;font-style:italic>/// This can be useful when needing an immediate action without having
</span><span style=color:#abb0b6;font-style:italic>/// to wait for the set duration of the timer in the first tick.
</span><span style=color:#abb0b6;font-style:italic>///
</span><span style=color:#abb0b6;font-style:italic>/// # Examples
</span><span style=color:#abb0b6;font-style:italic>/// ```
</span><span style=color:#abb0b6;font-style:italic>/// # use bevy_time::*;
</span><span style=color:#abb0b6;font-style:italic>/// use std::time::Duration;
</span><span style=color:#abb0b6;font-style:italic>/// let mut timer = Timer::from_seconds(1.5, TimerMode::Once);
</span><span style=color:#abb0b6;font-style:italic>/// timer.almost_finish();
</span><span style=color:#abb0b6;font-style:italic>/// assert!(!timer.is_finished());
</span><span style=color:#abb0b6;font-style:italic>/// assert_eq!(timer.remaining(), Duration::from_nanos(1));
</span><span style=color:#abb0b6;font-style:italic>/// ```
</span></code></pre><h2 id=the-impact>The Impact</h2><p>This small addition provides significant quality-of-life improvement for Bevy developers. Game developers can now easily set up timers that trigger almost immediately when systems start running, which is particularly useful for:<ol><li><strong>Initialization sequences</strong>: Setting up initial game state without hardcoded delays<li><strong>Testing</strong>: Quickly advancing to timer-triggered events during development<li><strong>UI transitions</strong>: Creating smooth transitions that appear to start immediately<li><strong>Game mechanics</strong>: Implementing cooldowns or delays that should be ready on first use</ol><p>The method is simple, well-tested, and integrates cleanly with existing timer functionality. It demonstrates how small, focused API additions can solve practical development problems without complicating the codebase.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Timer Struct] --> B[Existing Methods]
</span><span>    A --> C[New Method]
</span><span>    
</span><span>    B --> D[tick]
</span><span>    B --> E[reset]
</span><span>    B --> F[finish]
</span><span>    
</span><span>    C --> G[almost_finish]
</span><span>    
</span><span>    G --> H[Uses tick internally]
</span><span>    H --> I[Advances timer by duration - 1ns]
</span><span>    I --> J[Leaves 1ns remaining]
</span><span>    
</span><span>    style C fill:#d4f7d4
</span><span>    style G fill:#d4f7d4
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-time-src-timer-rs-34-0><code>crates/bevy_time/src/timer.rs</code> (+34/-0)</h3><p>This file contains the <code>Timer</code> struct implementation. The PR adds a new method and corresponding test.<p><strong>Key Changes:</strong><ol><li><strong>New <code>almost_finish</code> method</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Almost finishes the timer leaving 1 ns of remaining time.
</span><span style=color:#abb0b6;font-style:italic>/// This can be useful when needing an immediate action without having
</span><span style=color:#abb0b6;font-style:italic>/// to wait for the set duration of the timer in the first tick.
</span><span style=color:#abb0b6;font-style:italic>///
</span><span style=color:#abb0b6;font-style:italic>/// # Examples
</span><span style=color:#abb0b6;font-style:italic>/// ```
</span><span style=color:#abb0b6;font-style:italic>/// # use bevy_time::*;
</span><span style=color:#abb0b6;font-style:italic>/// use std::time::Duration;
</span><span style=color:#abb0b6;font-style:italic>/// let mut timer = Timer::from_seconds(1.5, TimerMode::Once);
</span><span style=color:#abb0b6;font-style:italic>/// timer.almost_finish();
</span><span style=color:#abb0b6;font-style:italic>/// assert!(!timer.is_finished());
</span><span style=color:#abb0b6;font-style:italic>/// assert_eq!(timer.remaining(), Duration::from_nanos(1));
</span><span style=color:#abb0b6;font-style:italic>/// ```
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>almost_finish</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> remaining </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>remaining</span><span>() </span><span style=color:#ed9366>- </span><span>Duration</span><span style=color:#ed9366>::</span><span>from_nanos(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>tick</span><span>(remaining)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=2><li><strong>Test for the new method</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>almost_finished_repeating</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> t </span><span style=color:#ed9366>= </span><span>Timer</span><span style=color:#ed9366>::</span><span>from_seconds(</span><span style=color:#ff8f40>10.0</span><span style=color:#61676ccc>, </span><span>TimerMode</span><span style=color:#ed9366>::</span><span>Repeating)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> duration </span><span style=color:#ed9366>= </span><span>Duration</span><span style=color:#ed9366>::</span><span>from_nanos(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    t</span><span style=color:#ed9366>.</span><span style=color:#f07171>almost_finish</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert!</span><span>(</span><span style=color:#ed9366>!</span><span>t</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_finished</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>times_finished_this_tick</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>remaining</span><span>()</span><span style=color:#61676ccc>, </span><span>Duration</span><span style=color:#ed9366>::</span><span>from_nanos(</span><span style=color:#ff8f40>1</span><span>))</span><span style=color:#61676ccc>;
</span><span>
</span><span>    t</span><span style=color:#ed9366>.</span><span style=color:#f07171>tick</span><span>(duration)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_finished</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>assert_eq!</span><span>(t</span><span style=color:#ed9366>.</span><span style=color:#f07171>times_finished_this_tick</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><strong>How these changes relate to the overall purpose:</strong><p>The new method directly addresses the requirement stated in issue #21860 by providing a way to advance a timer so it’s ready to finish on the next update. The test validates that the method works correctly and documents the expected behavior for future maintainers.<h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy Timer Documentation</strong>: https://docs.rs/bevy/latest/bevy/time/struct.Timer.html<li><strong>Rust std::time::Duration</strong>: https://doc.rust-lang.org/std/time/struct.Duration.html<li><strong>Game Timing Patterns</strong>: Understanding fixed and variable timesteps in game engines<li><strong>Bevy Time Module Architecture</strong>: How Bevy handles time management across systems</ol><h1 id=full-code-diff>Full Code Diff</h1><pre style=color:#61676c;background-color:#fafafa><code><span>diff --git a/crates/bevy_time/src/timer.rs b/crates/bevy_time/src/timer.rs
</span><span>index bbf76aa1d93a6..a9ce7b3d6ce63 100644
</span><span>--- a/crates/bevy_time/src/timer.rs
</span><span>+++ b/crates/bevy_time/src/timer.rs
</span><span>@@ -206,6 +206,25 @@ impl Timer {
</span><span>         self.tick(remaining);
</span><span>     }
</span><span> 
</span><span>+    /// Almost finishes the timer leaving 1 ns of remaining time.
</span><span>+    /// This can be useful when needing an immediate action without having
</span><span>+    /// to wait for the set duration of the timer in the first tick.
</span><span>+    ///
</span><span>+    /// # Examples
</span><span>+    /// ```
</span><span>+    /// # use bevy_time::*;
</span><span>+    /// use std::time::Duration;
</span><span>+    /// let mut timer = Timer::from_seconds(1.5, TimerMode::Once);
</span><span>+    /// timer.almost_finish();
</span><span>+    /// assert!(!timer.is_finished());
</span><span>+    /// assert_eq!(timer.remaining(), Duration::from_nanos(1));
</span><span>+    /// ```
</span><span>+    #[inline]
</span><span>+    pub fn almost_finish(&mut self) {
</span><span>+        let remaining = self.remaining() - Duration::from_nanos(1);
</span><span>+        self.tick(remaining);
</span><span>+    }
</span><span>+
</span><span>     /// Returns the mode of the timer.
</span><span>     ///
</span><span>     /// # Examples
</span><span>@@ -628,6 +647,21 @@ mod tests {
</span><span>         assert_eq!(t.times_finished_this_tick(), 34);
</span><span>     }
</span><span> 
</span><span>+    #[test]
</span><span>+    fn almost_finished_repeating() {
</span><span>+        let mut t = Timer::from_seconds(10.0, TimerMode::Repeating);
</span><span>+        let duration = Duration::from_nanos(1);
</span><span>+
</span><span>+        t.almost_finish();
</span><span>+        assert!(!t.is_finished());
</span><span>+        assert_eq!(t.times_finished_this_tick(), 0);
</span><span>+        assert_eq!(t.remaining(), Duration::from_nanos(1));
</span><span>+
</span><span>+        t.tick(duration);
</span><span>+        assert!(t.is_finished());
</span><span>+        assert_eq!(t.times_finished_this_tick(), 1);
</span><span>+    }
</span><span>+
</span><span>     #[test]
</span><span>     fn paused() {
</span><span>         let mut t = Timer::from_seconds(10.0, TimerMode::Once);
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_21983.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>