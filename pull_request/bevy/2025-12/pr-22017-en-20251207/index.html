<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22017 Release the asset infos lock before acquiring the file transaction lock.
        
    </title><meta content="#22017 Release the asset infos lock before acquiring the file transaction lock." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-07</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22017-zh-cn-20251207>中文</a></div></div><div class=pr-content><h1 id=release-the-asset-infos-lock-before-acquiring-the-file-transaction-lock>Release the asset infos lock before acquiring the file transaction lock.</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Release the asset infos lock before acquiring the file transaction lock.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22017<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Assets, S-Ready-For-Final-Review, D-Modest<li><strong>Created</strong>: 2025-12-03T08:30:50Z<li><strong>Merged</strong>: 2025-12-07T18:51:37Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Fix the first flake related to #22001.<li>We had a double lock problem. We would first lock <code>asset_infos</code>, then lock one of the assets within <code>asset_infos</code> <strong>and then dropped the <code>asset_infos</code> lock</strong>. This means however that if a process needs to access <code>asset_infos</code> (which is necessary for loading nested assets during processing), we’ll have one thread trying to lock 1) asset_infos, 2) per-asset lock, and we’ll have another thread trying to lock 1) per-asset lock (we’ve already dropped the asset_infos lock), 2) asset_infos. A classic deadlock!</ul><h2 id=solution>Solution</h2><ul><li>Before locking the per-asset lock, we clone the <code>Arc&LTRwLock></code> out of the <code>asset_infos</code>, drop the <code>asset_infos</code>, and only then lock the per-asset lock. This ensures that we never hang on the <code>asset_infos</code> lock when just trying to fetch a single asset.<li>Make all the access to <code>asset_infos</code> “short” - they get what they need out of <code>asset_infos</code> and then drop the lock as soon as possible.<li>I also used <code>?</code> to cleanup some methods in <code>ProcessorAssetInfos</code>, where previously it was “remove the asset info, then have one big <code>if let</code> after it”. Now we just return early if the value is none.<li>I also happened to fix a weird case where the new path in a rename wasn’t guarded by a transaction lock. Now it is!</ul><h2 id=testing>Testing</h2><ul><li>Running without this fix I get “Ran out of loops” from the <code>only_reprocesses_wrong_hash_on_startup</code> test quite quickly (after a minute or so). With this fix, I now only get the assertion failure problem. If I also skip that assertion, the test hasn’t flaked for a while! Yay, no more deadlock!</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a deadlock issue in Bevy’s asset processor that was causing intermittent test failures. The problem stemmed from how the code managed two types of locks: the global <code>asset_infos</code> lock that protects the collection of all asset metadata, and individual <code>file_transaction_lock</code> instances for each asset that control access to that asset’s files.<p>The deadlock occurred because of an ordering issue in lock acquisition. In the original implementation, several methods would:<ol><li>Acquire a write lock on <code>asset_infos</code><li>Retrieve a specific asset’s <code>file_transaction_lock</code> (an <code>Arc&LTRwLock<()>></code>) from the map<li>Immediately acquire a lock on that per-asset lock while still holding the <code>asset_infos</code> lock</ol><p>This created a scenario where Thread A could hold <code>asset_infos</code> and try to lock Asset X’s file lock, while Thread B could hold Asset Y’s file lock and try to lock <code>asset_infos</code>. Since both threads need resources the other holds, they deadlock.<p>The solution is straightforward but required careful refactoring: separate the two locking operations so they never overlap. Instead of holding <code>asset_infos</code> while locking individual assets, the code now:<ol><li>Quickly acquires <code>asset_infos</code>, clones out the needed per-asset lock(s), and immediately releases <code>asset_infos</code><li>Only then acquires locks on the individual assets</ol><p>This change required modifying four key methods that previously held both locks simultaneously: <code>handle_removed_asset</code>, <code>handle_renamed_asset</code>, <code>process_asset</code>, and <code>get_transaction_lock</code>. Each method follows the same pattern: create a small scope for the <code>asset_infos</code> lock, extract what’s needed (usually cloning an <code>Arc</code>), then release the global lock before acquiring per-asset locks.<p>Additionally, the PR improved the <code>ProcessorAssetInfos</code> methods <code>remove</code> and <code>rename</code> to return the transaction locks they were managing, which was necessary for the callers to follow the new locking pattern. These methods were also cleaned up to use early returns with the <code>?</code> operator instead of nested <code>if let</code> statements, making the code more readable.<p>An important side fix was discovered during this refactoring: the rename operation wasn’t properly acquiring a transaction lock for the new asset path. This could have led to race conditions when assets were renamed while being processed. The fix ensures both old and new paths are properly locked during rename operations.<p>The implementation demonstrates a classic concurrency principle: minimize lock scope and avoid holding multiple locks simultaneously when possible. By separating the global map lock from individual resource locks, the code eliminates the deadlock condition while maintaining the necessary synchronization guarantees.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Caller Thread] --> B[Acquire asset_infos lock]
</span><span>    B --> C[Extract asset lock Arc]
</span><span>    C --> D[Release asset_infos lock]
</span><span>    D --> E[Acquire per-asset lock]
</span><span>    E --> F[Perform operation]
</span><span>    
</span><span>    G[Other Thread] --> H[Acquire different asset lock]
</span><span>    H --> I[Need asset_infos lock]
</span><span>    I --> J[No deadlock - asset_infos lock available]
</span><span>    
</span><span>    K[Old Problematic Flow] --> L[Thread A: asset_infos + Asset X lock]
</span><span>    K --> M[Thread B: Asset Y lock + wants asset_infos]
</span><span>    L --> N[Deadlock]
</span><span>    M --> N
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-asset-src-processor-mod-rs-131-102><code>crates/bevy_asset/src/processor/mod.rs</code> (+131/-102)</h3><p>This file contains the core asset processing logic. The changes refactor locking patterns to prevent deadlocks.<p><strong>Key changes in <code>handle_removed_asset</code>:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>handle_removed_asset</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>AssetSource, </span><span style=color:#ff8f40>path</span><span style=color:#61676ccc>:</span><span> PathBuf) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> asset_path </span><span style=color:#ed9366>= </span><span>AssetPath</span><span style=color:#ed9366>::</span><span>from(path)</span><span style=color:#ed9366>.</span><span style=color:#f07171>with_source</span><span>(source</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>debug!</span><span>(</span><span style=color:#86b300>"Removing processed {asset_path} because source was removed"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> infos </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span>processing_state</span><span style=color:#ed9366>.</span><span>asset_infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(info) </span><span style=color:#ed9366>=</span><span> infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>asset_path) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// we must wait for uncontested write access to the asset source to ensure existing readers / writers
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// can finish their operations
</span><span>        </span><span style=color:#fa6e32>let</span><span> _write_lock </span><span style=color:#ed9366>=</span><span> info</span><span style=color:#ed9366>.</span><span>file_transaction_lock</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove_processed_asset_and_meta</span><span>(source</span><span style=color:#61676ccc>,</span><span> asset_path</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>())
</span><span>            </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ed9366>&</span><span>asset_path)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>handle_removed_asset</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>source</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>AssetSource, </span><span style=color:#ff8f40>path</span><span style=color:#61676ccc>:</span><span> PathBuf) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> asset_path </span><span style=color:#ed9366>= </span><span>AssetPath</span><span style=color:#ed9366>::</span><span>from(path)</span><span style=color:#ed9366>.</span><span style=color:#f07171>with_source</span><span>(source</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>debug!</span><span>(</span><span style=color:#86b300>"Removing processed {asset_path} because source was removed"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> lock </span><span style=color:#ed9366>= </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Scope the infos lock so we don't hold up other processing for too long.
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> infos </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span>processing_state</span><span style=color:#ed9366>.</span><span>asset_infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>        infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ed9366>&</span><span>asset_path)</span><span style=color:#ed9366>.</span><span>await
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(lock) </span><span style=color:#ed9366>=</span><span> lock </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// we must wait for uncontested write access to the asset source to ensure existing
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// readers/writers can finish their operations
</span><span>    </span><span style=color:#fa6e32>let</span><span> _write_lock </span><span style=color:#ed9366>=</span><span> lock</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove_processed_asset_and_meta</span><span>(source</span><span style=color:#61676ccc>,</span><span> asset_path</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>())
</span><span>        </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><strong>Key changes in <code>handle_renamed_asset</code>:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before (partial):
</span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(info) </span><span style=color:#ed9366>=</span><span> infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>old) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// we must wait for uncontested write access to the asset source to ensure existing readers / writers
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// can finish their operations
</span><span>    </span><span style=color:#fa6e32>let</span><span> _write_lock </span><span style=color:#ed9366>=</span><span> info</span><span style=color:#ed9366>.</span><span>file_transaction_lock</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#61676ccc>;
</span><span>    processed_writer
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>rename</span><span>(old</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>()</span><span style=color:#61676ccc>,</span><span> new</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>())
</span><span>        </span><span style=color:#ed9366>.</span><span>await
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>    processed_writer
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>rename_meta</span><span>(old</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>()</span><span style=color:#61676ccc>,</span><span> new</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>())
</span><span>        </span><span style=color:#ed9366>.</span><span>await
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span><span>infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>rename</span><span>(</span><span style=color:#ed9366>&</span><span>old</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>new</span><span style=color:#61676ccc>,</span><span> new_task_sender)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> result </span><span style=color:#ed9366>= </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Scope the infos lock so we don't hold up other processing for too long.
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> infos </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span>processing_state</span><span style=color:#ed9366>.</span><span>asset_infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>    infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>rename</span><span>(</span><span style=color:#ed9366>&</span><span>old</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>new</span><span style=color:#61676ccc>,</span><span> new_task_sender)</span><span style=color:#ed9366>.</span><span>await
</span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>((old_lock</span><span style=color:#61676ccc>,</span><span> new_lock)) </span><span style=color:#ed9366>=</span><span> result </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// we must wait for uncontested write access to both assets to ensure existing
</span><span style=color:#abb0b6;font-style:italic>// readers/writers can finish their operations
</span><span style=color:#fa6e32>let</span><span> _old_write_lock </span><span style=color:#ed9366>=</span><span> old_lock</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> _new_write_lock </span><span style=color:#ed9366>=</span><span> new_lock</span><span style=color:#ed9366>.</span><span style=color:#f07171>write</span><span>()</span><span style=color:#61676ccc>;
</span><span>processed_writer
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>rename</span><span>(old</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>()</span><span style=color:#61676ccc>,</span><span> new</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span>await
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>Key changes in <code>ProcessorAssetInfos::remove</code> return type:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>remove</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>asset_path</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>AssetPath<</span><span style=color:#fa6e32>'static</span><span>>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> info </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(asset_path)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(info) </span><span style=color:#ed9366>=</span><span> info {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... complex logic
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>remove</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>asset_path</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>AssetPath<</span><span style=color:#fa6e32>'static</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTArc&LTasync_lock</span><span style=color:#ed9366>::</span><span>RwLock<()>>> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> info </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>infos</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(asset_path)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... simplified logic using early returns
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(info</span><span style=color:#ed9366>.</span><span>file_transaction_lock)
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/nomicon/races.html#deadlocks target=_blank>Rustonomicon: Deadlocks</a> - Understanding deadlock scenarios in concurrent systems<li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/06_multiple_futures/03_channels.html target=_blank>Async Rust: Locks and Channels</a> - Patterns for safe concurrency in async Rust<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/advanced-topics/assets/ target=_blank>Bevy Assets Documentation</a> - How Bevy’s asset system works<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Dining_philosophers_problem target=_blank>The Dining Philosophers Problem</a> - Classic computer science problem illustrating deadlock scenarios</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22017.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>