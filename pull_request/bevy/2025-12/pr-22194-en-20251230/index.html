<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22194 `DirectionalNavigationMap` no longer caches `AutoDirectionalNavigation` node connections
        
    </title><meta content="#22194 `DirectionalNavigationMap` no longer caches `AutoDirectionalNavigation` node connections" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22194-zh-cn-20251230>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: <code>DirectionalNavigationMap</code> no longer caches <code>AutoDirectionalNavigation</code> node connections<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22194<li><strong>Author</strong>: kfc35<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-UI, S-Ready-For-Final-Review, D-Modest<li><strong>Created</strong>: 2025-12-19T07:25:24Z<li><strong>Merged</strong>: 2025-12-30T00:58:57Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Fixes #21949</ul><h2 id=solution>Solution</h2><p>At the suggestion of @viridia and affirmed by @ickshonpe on Discord, the directional navigation map should no longer contain any <code>AutoDirectionalNavigation</code> node connections. This PR:<ul><li>Removes the system that inserts those types of connections into the map and places the burden of the map’s management fully onto the developer. The directional navigation map is now only used to specify <strong>manual</strong> edges.<li>Adds a brute force search among <code>AutoDirectionalNavigation</code> nodes within the <code>navigate</code> function of the <code>DirectionalNavigation</code> system parameter. <code>navigate</code> will prefer to find a destination within the map of manual edges first before conducting the brute force search.</ul><h2 id=testing>Testing</h2><ul><li>Did you test these changes? If so, how? There are two relevant examples that I tested to ensure there were no regressions: <code>cargo run --example directional_navigation</code>: manually defined edges are respected. Navigating east and west along the same row loops correctly, and navigating north and south along a column works without looping as specified in the example. <code>cargo run --example auto_directional_navigation</code>: Navigation also works as expected here. However, I did not manually test whether removing an <code>AutoDirectionalNavigation</code> node during execution of an app results in the navigation system adapting, but I assume it would be evident since the algorithm is no longer using a cached map of those types of edges.<li>Are there any parts that need more testing? I wanted to have a go at writing an automated test for the “automatic” portion of it, but I got stuck trying to get the spawned nodes to have valid values for their <code>ComputedNode</code> and <code>UiGlobalTransform</code> (values that didn’t represent zero sized content or no translation despite my attempts at specifying so). I just stuck to validating that behavior via the auto_directional_navigation example. It would be nice to have a test with both automatic and manual navigation would be nice to have, but may be overkill. It’s just relatively simple if/else logic there.<li>How can other people (reviewers) test your changes? Is there anything specific they need to know? You can test out the examples to make sure that the directional navigation behaves as expected. If you’d like to go above and beyond, you could try removing some <code>AutoDirectionalNavigation</code> nodes during execution and seeing if navigation adapts.<li>If relevant, what platforms did you test these changes on, and are there any important ones you can’t test? I’ve only run the examples on MacOS</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a bug where the directional navigation system in Bevy’s UI framework failed to handle dynamic changes to automatically-navigable UI elements. The core issue was that the system cached automatic navigation connections in a map, which then became stale when UI elements were added, removed, or changed their layout properties.<p>The problem manifested in Issue #21949, where users experienced navigation failures when UI elements with <code>AutoDirectionalNavigation</code> components were modified during runtime. The existing implementation used a system called <code>auto_rebuild_ui_navigation_graph</code> that ran in the <code>PostUpdate</code> stage to rebuild the navigation map whenever <code>AutoDirectionalNavigation</code> nodes changed. However, this approach had a fundamental limitation: the map could only be rebuilt when changes were detected, creating a window where the cached navigation data was incorrect.<p>The solution proposed and implemented here takes a different architectural approach. Instead of maintaining a cached map of automatic connections, the system now performs on-demand brute-force searches when automatic navigation is needed. This eliminates the caching problem entirely and simplifies the overall system design.<p>The implementation involved several coordinated changes. First, the <code>auto_rebuild_ui_navigation_graph</code> system was completely removed from the codebase. This system was previously responsible for detecting changes to <code>AutoDirectionalNavigation</code> nodes and rebuilding the cached navigation connections. By removing it, the responsibility for managing the <code>DirectionalNavigationMap</code> shifted entirely to developers for manual edge definitions.<p>Next, the <code>DirectionalNavigation</code> system parameter was significantly refactored. Previously, it only needed access to the focus state and the navigation map. Now, it includes queries to gather all <code>AutoDirectionalNavigation</code> nodes at navigation time:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>DirectionalNavigation</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> {
</span><span>    </span><span style=color:#fa6e32>pub </span><span>focus</span><span style=color:#61676ccc>: </span><span>ResMut<</span><span style=color:#fa6e32>'w</span><span>, InputFocus>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>map</span><span style=color:#61676ccc>: </span><span>Res<</span><span style=color:#fa6e32>'w</span><span>, DirectionalNavigationMap>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>config</span><span style=color:#61676ccc>: </span><span>Res<</span><span style=color:#fa6e32>'w</span><span>, AutoNavigationConfig>,
</span><span>    navigable_entities_query</span><span style=color:#61676ccc>: </span><span>Query<
</span><span>        </span><span style=color:#fa6e32>'w</span><span>,
</span><span>        </span><span style=color:#fa6e32>'s</span><span>,
</span><span>        (
</span><span>            Entity,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> ComputedNode,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> UiGlobalTransform,
</span><span>            </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> InheritedVisibility,
</span><span>        ),
</span><span>        With&LTAutoDirectionalNavigation>,
</span><span>    >,
</span><span>    focusable_area_query</span><span style=color:#61676ccc>: </span><span>Query<
</span><span>        </span><span style=color:#fa6e32>'w</span><span>,
</span><span>        </span><span style=color:#fa6e32>'s</span><span>,
</span><span>        (Entity, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> ComputedNode, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static</span><span> UiGlobalTransform),
</span><span>        With&LTAutoDirectionalNavigation>,
</span><span>    >,
</span><span>}
</span></code></pre><p>The key algorithmic change is in the <code>navigate</code> method. When a user attempts to navigate in a direction, the system first checks for a manually-defined edge in the <code>DirectionalNavigationMap</code>. Only if no manual edge exists does it fall back to performing a brute-force search among all <code>AutoDirectionalNavigation</code> nodes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>navigate</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>direction</span><span style=color:#61676ccc>:</span><span> CompassOctant,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTEntity, DirectionalNavigationError> {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(current_focus) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>focus</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Respect manual edges first
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(new_focus) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>map</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_neighbor</span><span>(current_focus</span><span style=color:#61676ccc>,</span><span> direction) {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>focus</span><span style=color:#ed9366>.</span><span style=color:#f07171>set</span><span>(new_focus)</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(new_focus)
</span><span>        } </span><span style=color:#fa6e32>else if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(origin) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_to_focusable_area</span><span>(current_focus)
</span><span>            </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(new_focus) </span><span style=color:#ed9366>= </span><span style=color:#f07171>find_best_candidate</span><span>(
</span><span>                </span><span style=color:#ed9366>&</span><span>origin</span><span style=color:#61676ccc>,
</span><span>                direction</span><span style=color:#61676ccc>,
</span><span>                </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_navigable_nodes</span><span>()</span><span style=color:#61676ccc>,
</span><span>                </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>config</span><span style=color:#61676ccc>,
</span><span>            )
</span><span>        {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>focus</span><span style=color:#ed9366>.</span><span style=color:#f07171>set</span><span>(new_focus)</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(new_focus)
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(DirectionalNavigationError</span><span style=color:#ed9366>::</span><span>NoNeighborInDirection {
</span><span>                current_focus</span><span style=color:#61676ccc>,
</span><span>                direction</span><span style=color:#61676ccc>,
</span><span>            })
</span><span>        }
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(DirectionalNavigationError</span><span style=color:#ed9366>::</span><span>NoFocus)
</span><span>    }
</span><span>}
</span></code></pre><p>The brute-force search uses the existing <code>find_best_candidate</code> function (which was extracted from <code>auto_generate_navigation_edges</code>), scoring candidates based on their position, size, and direction relative to the current focus. This scoring algorithm considers both distance and alignment, controlled by the <code>AutoNavigationConfig</code> resource.<p>From a performance perspective, this change trades off constant-time map lookups for linear-time searches through all <code>AutoDirectionalNavigation</code> nodes. However, in practice, UI navigation typically involves a relatively small number of focusable elements, and the navigation operations are triggered by user input rather than occurring every frame. The performance impact is therefore likely negligible for most applications, while providing correct behavior in dynamic UI scenarios.<p>The documentation was updated throughout to reflect the new architecture. The <code>DirectionalNavigationMap</code> is now explicitly described as only storing manually-defined connections, and the <code>AutoDirectionalNavigation</code> component is clarified as a marker that enables nodes to be considered in the automatic navigation algorithm rather than triggering automatic map updates.<p>This architectural simplification has several benefits. It eliminates a whole category of bugs related to stale cached data, reduces the complexity of the navigation system by removing an entire system that needed to run every frame, and makes the behavior more predictable and easier to reason about. The separation between manual and automatic navigation is now clearer: manual edges in the map always take precedence, and automatic navigation is computed on-demand from the current state of the UI.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[User calls navigate] --> B{Manual edge exists?}
</span><span>    B -->|Yes| C[Use manual connection from map]
</span><span>    B -->|No| D[Perform brute-force search]
</span><span>    D --> E[Get all AutoDirectionalNavigation nodes]
</span><span>    E --> F[Score each candidate]
</span><span>    F --> G[Select best candidate]
</span><span>    C --> H[Update focus]
</span><span>    G --> H
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-input-focus-src-directional-navigation-rs-135-133><code>crates/bevy_input_focus/src/directional_navigation.rs</code> (+135/-133)</h3><p>This file contains the complete refactoring of the directional navigation system:<ol><li><p><strong>Removed the automatic map rebuilding system</strong>: The <code>auto_rebuild_ui_navigation_graph</code> system was completely removed, along with its registration in the <code>DirectionalNavigationPlugin</code>.</p><li><p><strong>Updated the <code>DirectionalNavigation</code> system parameter</strong>: Added queries to access <code>AutoDirectionalNavigation</code> nodes and refactored the <code>navigate</code> method to perform on-demand searches.</p></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Simple system parameter with just focus and map
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>DirectionalNavigation</span><span><</span><span style=color:#fa6e32>'w</span><span>> {
</span><span>    </span><span style=color:#fa6e32>pub </span><span>focus</span><span style=color:#61676ccc>: </span><span>ResMut<</span><span style=color:#fa6e32>'w</span><span>, InputFocus>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>map</span><span style=color:#61676ccc>: </span><span>Res<</span><span style=color:#fa6e32>'w</span><span>, DirectionalNavigationMap>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Expanded system parameter with queries for automatic navigation
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>DirectionalNavigation</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'s</span><span>> {
</span><span>    </span><span style=color:#fa6e32>pub </span><span>focus</span><span style=color:#61676ccc>: </span><span>ResMut<</span><span style=color:#fa6e32>'w</span><span>, InputFocus>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>map</span><span style=color:#61676ccc>: </span><span>Res<</span><span style=color:#fa6e32>'w</span><span>, DirectionalNavigationMap>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>config</span><span style=color:#61676ccc>: </span><span>Res<</span><span style=color:#fa6e32>'w</span><span>, AutoNavigationConfig>,
</span><span>    navigable_entities_query</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#f51818>.</span><span>..>,
</span><span>    focusable_area_query</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#f51818>.</span><span>..>,
</span><span>}
</span></code></pre><ol start=3><li><strong>Extracted and reused the candidate scoring logic</strong>: The <code>find_best_candidate</code> function was extracted from <code>auto_generate_navigation_edges</code> to be reusable in the new navigation flow.</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// New function for finding the best navigation candidate
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>find_best_candidate</span><span>(
</span><span>    </span><span style=color:#ff8f40>origin</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>FocusableArea,
</span><span>    </span><span style=color:#ff8f40>direction</span><span style=color:#61676ccc>:</span><span> CompassOctant,
</span><span>    </span><span style=color:#ff8f40>candidates</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[FocusableArea],
</span><span>    </span><span style=color:#ff8f40>config</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>AutoNavigationConfig,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEntity> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... scoring logic that was previously inside auto_generate_navigation_edges
</span><span>}
</span></code></pre><ol start=4><li><strong>Updated documentation</strong>: Throughout the file, documentation was updated to clarify that the <code>DirectionalNavigationMap</code> is now only for manual edges, and automatic navigation happens via on-demand search.</ol><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ui/latest/bevy_ui/ target=_blank>Bevy UI System Documentation</a> - For understanding UI components like <code>ComputedNode</code> and <code>UiGlobalTransform</code><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Entity_component_system target=_blank>Entity Component System Pattern</a> - For context on Bevy’s architectural approach<li><a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/css-nav-1/ target=_blank>Spatial Navigation Algorithms</a> - W3C specification on directional navigation patterns in UI systems</ul><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_input_focus/src/directional_navigation.rs b/crates/bevy_input_focus/src/directional_navigation.rs
</span><span>index f35e91e97cb91..5fc6dba2b402a 100644
</span><span style=color:#c594c5>--- a/crates/bevy_input_focus/src/directional_navigation.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_input_focus/src/directional_navigation.rs
</span><span style=color:#c594c5>@@ -9,12 +9,15 @@
</span><span> //!
</span><span> //! Navigating between focusable entities (commonly UI nodes) is done by
</span><span> //! passing a [`CompassOctant`] into the [`navigate`](DirectionalNavigation::navigate) method
</span><span style=color:#f07171>-//! from the [`DirectionalNavigation`] system parameter.
</span><span style=color:#86b300>+//! from the [`DirectionalNavigation`] system parameter. Under the hood, an entity is found
</span><span style=color:#86b300>+//! automatically via brute force search in the desired [`CompassOctant`] direction.
</span><span> //!
</span><span style=color:#f07171>-//! Under the hood, the [`DirectionalNavigationMap`] stores a directed graph of focusable entities.
</span><span style=color:#f07171>-//! Each entity can have up to 8 neighbors, one for each [`CompassOctant`], balancing flexibility and required precision.
</span><span style=color:#86b300>+//! If some manual navigation is desired, a [`DirectionalNavigationMap`] will override the brute force
</span><span style=color:#86b300>+//! search in a direction for a given entity. The [`DirectionalNavigationMap`] stores a directed graph
</span><span style=color:#86b300>+//! of focusable entities. Each entity can have up to 8 neighbors, one for each [`CompassOctant`],
</span><span style=color:#86b300>+//! balancing flexibility and required precision.
</span><span> //!
</span><span style=color:#f07171>-//! # Creating a Navigation Graph
</span><span style=color:#86b300>+//! # Setting up Directional Navigation
</span><span> //!
</span><span> //! ## Automatic Navigation (Recommended)
</span><span> //!
</span><span style=color:#c594c5>@@ -35,9 +38,6 @@
</span><span> //! }
</span><span> //! ```
</span><span> //!
</span><span style=color:#f07171>-//! The navigation graph automatically updates when UI elements move, resize, or are added/removed.
</span><span style=color:#f07171>-//! Configure the behavior using the [`AutoNavigationConfig`] resource.
</span><span style=color:#f07171>-//!
</span><span> //! ## Manual Navigation
</span><span> //!
</span><span> //! You can also manually define navigation connections using methods like
</span><span style=color:#c594c5>@@ -46,7 +46,7 @@
</span><span> //!
</span><span> //! ## Combining Automatic and Manual
</span><span> //!
</span><span style=color:#f07171>-//! Manual edges always take precedence over auto-generated ones, allowing you to use
</span><span style=color:#86b300>+//! Following manual edges always take precedence, allowing you to use
</span><span> //! automatic navigation for most UI elements while overriding specific connections for
</span><span> //! special cases like wrapping menus or cross-layer navigation.
</span><span> //!
</span><span style=color:#c594c5>@@ -67,7 +67,7 @@ </span><span style=color:#399ee6>use bevy_ecs::{
</span><span>     system::SystemParam,
</span><span> };
</span><span> use bevy_math::{CompassOctant, Dir2, Vec2};
</span><span style=color:#f07171>-use bevy_ui::{ComputedNode, UiGlobalTransform, UiSystems};
</span><span style=color:#86b300>+use bevy_ui::{ComputedNode, UiGlobalTransform};
</span><span> use thiserror::Error;
</span><span> 
</span><span> use crate::InputFocus;
</span><span style=color:#c594c5>@@ -75,34 +75,21 @@ </span><span style=color:#399ee6>use crate::InputFocus;
</span><span> #[cfg(feature = "bevy_reflect")]
</span><span> use bevy_reflect::{prelude::*, Reflect};
</span><span> 
</span><span style=color:#f07171>-/// A plugin that sets up the directional navigation systems and resources.
</span><span style=color:#86b300>+/// A plugin that sets up the directional navigation resources.
</span><span> #[derive(Default)]
</span><span> pub struct DirectionalNavigationPlugin;
</span><span> 
</span><span> impl Plugin for DirectionalNavigationPlugin {
</span><span>     fn build(&self, app: &mut App) {
</span><span>         app.init_resource::&LTDirectionalNavigationMap>()
</span><span style=color:#f07171>-            .init_resource::&LTAutoNavigationConfig>()
</span><span style=color:#f07171>-            .add_systems(
</span><span style=color:#f07171>-                PostUpdate,
</span><span style=color:#f07171>-                auto_rebuild_ui_navigation_graph
</span><span style=color:#f07171>-                    .in_set(UiSystems::PostLayout)
</span><span style=color:#f07171>-                    .after(bevy_camera::visibility::VisibilitySystems::VisibilityPropagate),
</span><span style=color:#f07171>-            );
</span><span style=color:#86b300>+            .init_resource::&LTAutoNavigationConfig>();
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Marker component to enable automatic directional navigation graph generation.
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// Simply add this component to your UI entities and the navigation graph will be
</span><span style=color:#f07171>-/// automatically computed and maintained! The [`DirectionalNavigationPlugin`] includes
</span><span style=color:#f07171>-/// a built-in system that:
</span><span style=color:#f07171>-/// - Detects when nodes with this component change position or size
</span><span style=color:#f07171>-/// - Automatically rebuilds navigation edges based on spatial proximity
</span><span style=color:#f07171>-/// - Respects manual edges (they always take precedence)
</span><span style=color:#f07171>-///
</span><span style=color:#86b300>+/// Marker component to enable automatic directional navigation to and from the entity.
</span><span> ///
</span><span style=color:#f07171>-/// Just add this component to `bevy_ui` entities:
</span><span style=color:#86b300>+/// Simply add this component to your UI entities so that the navigation algorithm will
</span><span style=color:#86b300>+/// consider this entity in its calculations:
</span><span> ///
</span><span> /// ```rust
</span><span> /// # use bevy_ecs::prelude::*;
</span><span style=color:#c594c5>@@ -115,11 +102,9 @@ </span><span style=color:#399ee6>impl Plugin for DirectionalNavigationPlugin {
</span><span> /// }
</span><span> /// ```
</span><span> ///
</span><span style=color:#f07171>-/// The navigation graph updates automatically when nodes move, resize, or are added/removed.
</span><span style=color:#f07171>-///
</span><span> /// # Multi-Layer UIs and Z-Index
</span><span> ///
</span><span style=color:#f07171>-/// **Important**: The automatic navigation system is currently **z-index agnostic** and treats
</span><span style=color:#86b300>+/// **Important**: Automatic navigation is currently **z-index agnostic** and treats
</span><span> /// all entities with `AutoDirectionalNavigation` as a flat set, regardless of which UI layer
</span><span> /// or z-index they belong to. This means navigation may jump between different layers (e.g.,
</span><span> /// from a background menu to an overlay popup).
</span><span style=color:#c594c5>@@ -180,7 +165,7 @@ </span><span style=color:#399ee6>pub struct AutoDirectionalNavigation {
</span><span>     pub respect_tab_order: bool,
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Configuration resource for automatic directional navigation graph generation.
</span><span style=color:#86b300>+/// Configuration resource for automatic navigation.
</span><span> ///
</span><span> /// This resource controls how the automatic navigation system computes which
</span><span> /// nodes should be connected in each direction.
</span><span style=color:#c594c5>@@ -285,7 +270,7 @@ </span><span style=color:#399ee6>impl NavNeighbors {
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// A resource that stores the traversable graph of focusable entities.
</span><span style=color:#86b300>+/// A resource that stores the manually specified traversable graph of focusable entities.
</span><span> ///
</span><span> /// Each entity can have up to 8 neighbors, one for each [`CompassOctant`].
</span><span> ///
</span><span style=color:#c594c5>@@ -297,7 +282,8 @@ </span><span style=color:#399ee6>impl NavNeighbors {
</span><span> ///   although looping around the edges of the screen is also acceptable.
</span><span> /// - **Not self-connected**: An entity should not be a neighbor of itself; use [`None`] instead.
</span><span> ///
</span><span style=color:#f07171>-/// For now, this graph must be built manually, and the developer is responsible for ensuring that it meets the above criteria.
</span><span style=color:#86b300>+/// This graph must be built and maintained manually, and the developer is responsible for ensuring that it meets the above criteria.
</span><span style=color:#86b300>+/// Notably, if the developer adds or removes the navigability of an entity, the developer should update the map as necessary.
</span><span> #[derive(Resource, Debug, Default, Clone, PartialEq)]
</span><span> #[cfg_attr(
</span><span>     feature = "bevy_reflect",
</span><span style=color:#c594c5>@@ -313,8 +299,6 @@ </span><span style=color:#399ee6>pub struct DirectionalNavigationMap {
</span><span> }
</span><span> 
</span><span> impl DirectionalNavigationMap {
</span><span style=color:#f07171>-    /// Adds a new entity to the navigation map, overwriting any existing neighbors for that entity.
</span><span style=color:#f07171>-    ///
</span><span>     /// Removes an entity from the navigation map, including all connections to and from it.
</span><span>     ///
</span><span>     /// Note that this is an O(n) operation, where n is the number of entities in the map,
</span><span style=color:#c594c5>@@ -421,14 +405,35 @@ </span><span style=color:#399ee6>impl DirectionalNavigationMap {
</span><span> 
</span><span> /// A system parameter for navigating between focusable entities in a directional way.
</span><span> #[derive(SystemParam, Debug)]
</span><span style=color:#f07171>-pub struct DirectionalNavigation<'w> {
</span><span style=color:#86b300>+pub struct DirectionalNavigation<'w, 's> {
</span><span>     /// The currently focused entity.
</span><span>     pub focus: ResMut<'w, InputFocus>,
</span><span style=color:#f07171>-    /// The navigation map containing the connections between entities.
</span><span style=color:#86b300>+    /// The directional navigation map containing manually defined connections between entities.
</span><span>     pub map: Res<'w, DirectionalNavigationMap>,
</span><span style=color:#86b300>+    /// Configuration for the automated portion of the navigation algorithm.
</span><span style=color:#86b300>+    pub config: Res<'w, AutoNavigationConfig>,
</span><span style=color:#86b300>+    /// The entities which can possibly be navigated to automatically.
</span><span style=color:#86b300>+    navigable_entities_query: Query<
</span><span style=color:#86b300>+        'w,
</span><span style=color:#86b300>+        's,
</span><span style=color:#86b300>+        (
</span><span style=color:#86b300>+            Entity,
</span><span style=color:#86b300>+            &'static ComputedNode,
</span><span style=color:#86b300>+            &'static UiGlobalTransform,
</span><span style=color:#86b300>+            &'static InheritedVisibility,
</span><span style=color:#86b300>+        ),
</span><span style=color:#86b300>+        With&LTAutoDirectionalNavigation>,
</span><span style=color:#86b300>+    >,
</span><span style=color:#86b300>+    /// A query used to get the [`FocusableArea`] for a given entity to be used in automatic navigation.
</span><span style=color:#86b300>+    focusable_area_query: Query<
</span><span style=color:#86b300>+        'w,
</span><span style=color:#86b300>+        's,
</span><span style=color:#86b300>+        (Entity, &'static ComputedNode, &'static UiGlobalTransform),
</span><span style=color:#86b300>+        With&LTAutoDirectionalNavigation>,
</span><span style=color:#86b300>+    >,
</span><span> }
</span><span> 
</span><span style=color:#f07171>-impl DirectionalNavigation<'_> {
</span><span style=color:#86b300>+impl<'w, 's> DirectionalNavigation<'w, 's> {
</span><span>     /// Navigates to the neighbor in a given direction from the current focus, if any.
</span><span>     ///
</span><span>     /// Returns the new focus if successful.
</span><span style=color:#c594c5>@@ -440,9 +445,20 @@ </span><span style=color:#399ee6>impl DirectionalNavigation<'_> {
</span><span>         direction: CompassOctant,
</span><span>     ) -> Result&LTEntity, DirectionalNavigationError> {
</span><span>         if let Some(current_focus) = self.focus.0 {
</span><span style=color:#86b300>+            // Respect manual edges first
</span><span>             if let Some(new_focus) = self.map.get_neighbor(current_focus, direction) {
</span><span>                 self.focus.set(new_focus);
</span><span>                 Ok(new_focus)
</span><span style=color:#86b300>+            } else if let Some(origin) = self.entity_to_focusable_area(current_focus)
</span><span style=color:#86b300>+                && let Some(new_focus) = find_best_candidate(
</span><span style=color:#86b300>+                    &origin,
</span><span style=color:#86b300>+                    direction,
</span><span style=color:#86b300>+                    &self.get_navigable_nodes(),
</span><span style=color:#86b300>+                    &self.config,
</span><span style=color:#86b300>+                )
</span><span style=color:#86b300>+            {
</span><span style=color:#86b300>+                self.focus.set(new_focus);
</span><span style=color:#86b300>+                Ok(new_focus)
</span><span>             } else {
</span><span>                 Err(DirectionalNavigationError::NoNeighborInDirection {
</span><span>                     current_focus,
</span><span style=color:#c594c5>@@ -453,6 +469,42 @@ </span><span style=color:#399ee6>impl DirectionalNavigation<'_> {
</span><span>             Err(DirectionalNavigationError::NoFocus)
</span><span>         }
</span><span>     }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    /// Returns a vec of [`FocusableArea`] representing nodes that are eligible to be automatically navigated to.
</span><span style=color:#86b300>+    fn get_navigable_nodes(&self) -> Vec&LTFocusableArea> {
</span><span style=color:#86b300>+        self.navigable_entities_query
</span><span style=color:#86b300>+            .iter()
</span><span style=color:#86b300>+            .filter_map(|(entity, computed, transform, inherited_visibility)| {
</span><span style=color:#86b300>+                // Skip hidden or zero-size nodes
</span><span style=color:#86b300>+                if computed.is_empty() || !inherited_visibility.get() {
</span><span style=color:#86b300>+                    return None;
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
</span><span style=color:#86b300>+                Some(FocusableArea {
</span><span style=color:#86b300>+                    entity,
</span><span style=color:#86b300>+                    position: translation,
</span><span style=color:#86b300>+                    size: computed.size(),
</span><span style=color:#86b300>+                })
</span><span style=color:#86b300>+            })
</span><span style=color:#86b300>+            .collect()
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    /// Gets the [`FocusableArea`] of the provided entity, if it exists.
</span><span style=color:#86b300>+    ///
</span><span style=color:#86b300>+    /// Returns None if there was a [`QueryEntityError`](bevy_ecs::query::QueryEntityError).
</span><span style=color:#86b300>+    fn entity_to_focusable_area(&self, entity: Entity) -> Option&LTFocusableArea> {
</span><span style=color:#86b300>+        self.focusable_area_query
</span><span style=color:#86b300>+            .get(entity)
</span><span style=color:#86b300>+            .map_or(None, |(entity, computed, transform)| {
</span><span style=color:#86b300>+                let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
</span><span style=color:#86b300>+                Some(FocusableArea {
</span><span style=color:#86b300>+                    entity,
</span><span style=color:#86b300>+                    position: translation,
</span><span style=color:#86b300>+                    size: computed.size(),
</span><span style=color:#86b300>+                })
</span><span style=color:#86b300>+            })
</span><span style=color:#86b300>+    }
</span><span> }
</span><span> 
</span><span> /// An error that can occur when navigating between focusable entities using [directional navigation](crate::directional_navigation).
</span><span style=color:#c594c5>@@ -473,7 +525,7 @@ </span><span style=color:#399ee6>pub enum DirectionalNavigationError {
</span><span> 
</span><span> /// A focusable area with position and size information.
</span><span> ///
</span><span style=color:#f07171>-/// This struct represents a UI element in the automatic directional navigation system,
</span><span style=color:#86b300>+/// This struct represents a UI element used during automatic directional navigation,
</span><span> /// containing its entity ID, center position, and size for spatial navigation calculations.
</span><span> ///
</span><span> /// The term "focusable area" avoids confusion with UI [`Node`](bevy_ui::Node) components.
</span><span style=color:#c594c5>@@ -624,11 +676,49 @@ </span><span style=color:#399ee6>fn score_candidate(
</span><span>     distance + alignment_penalty
</span><span> }
</span><span> 
</span><span style=color:#86b300>+/// Finds the best entity to navigate to from the origin towards the given direction.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// For details on what "best" means here, refer to [`AutoNavigationConfig`].
</span><span style=color:#86b300>+fn find_best_candidate(
</span><span style=color:#86b300>+    origin: &FocusableArea,
</span><span style=color:#86b300>+    direction: CompassOctant,
</span><span style=color:#86b300>+    candidates: &[FocusableArea],
</span><span style=color:#86b300>+    config: &AutoNavigationConfig,
</span><span style=color:#86b300>+) -> Option&LTEntity> {
</span><span style=color:#86b300>+    // Find best candidate in this direction
</span><span style=color:#86b300>+    let mut best_candidate = None;
</span><span style=color:#86b300>+    let mut best_score = f32::INFINITY;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    for candidate in candidates {
</span><span style=color:#86b300>+        // Skip self
</span><span style=color:#86b300>+        if candidate.entity == origin.entity {
</span><span style=color:#86b300>+            continue;
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Score the candidate
</span><span style=color:#86b300>+        let score = score_candidate(
</span><span style=color:#86b300>+            origin.position,
</span><span style=color:#86b300>+            origin.size,
</span><span style=color:#86b300>+            candidate.position,
</span><span style=color:#86b300>+            candidate.size,
</span><span style=color:#86b300>+            direction,
</span><span style=color:#86b300>+            config,
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        if score < best_score {
</span><span style=color:#86b300>+            best_score = score;
</span><span style=color:#86b300>+            best_candidate = Some(candidate.entity);
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    best_candidate
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span> /// Automatically generates directional navigation edges for a collection of nodes.
</span><span> ///
</span><span> /// This function takes a slice of navigation nodes with their positions and sizes, and populates
</span><span> /// the navigation map with edges to the nearest neighbor in each compass direction.
</span><span style=color:#f07171>-/// Manual edges in the map are preserved and not overwritten.
</span><span style=color:#86b300>+/// Manual edges already in the map are preserved and not overwritten.
</span><span> ///
</span><span> /// # Arguments
</span><span> ///
</span><span style=color:#c594c5>@@ -679,30 +769,7 @@ </span><span style=color:#399ee6>pub fn auto_generate_navigation_edges(
</span><span>             }
</span><span> 
</span><span>             // Find best candidate in this direction
</span><span style=color:#f07171>-            let mut best_candidate = None;
</span><span style=color:#f07171>-            let mut best_score = f32::INFINITY;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-            for candidate in nodes {
</span><span style=color:#f07171>-                // Skip self
</span><span style=color:#f07171>-                if candidate.entity == origin.entity {
</span><span style=color:#f07171>-                    continue;
</span><span style=color:#f07171>-                }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                // Score the candidate
</span><span style=color:#f07171>-                let score = score_candidate(
</span><span style=color:#f07171>-                    origin.position,
</span><span style=color:#f07171>-                    origin.size,
</span><span style=color:#f07171>-                    candidate.position,
</span><span style=color:#f07171>-                    candidate.size,
</span><span style=color:#f07171>-                    octant,
</span><span style=color:#f07171>-                    config,
</span><span style=color:#f07171>-                );
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                if score < best_score {
</span><span style=color:#f07171>-                    best_score = score;
</span><span style=color:#f07171>-                    best_candidate = Some(candidate.entity);
</span><span style=color:#f07171>-                }
</span><span style=color:#f07171>-            }
</span><span style=color:#86b300>+            let best_candidate = find_best_candidate(origin, octant, nodes, config);
</span><span> 
</span><span>             // Add edge if we found a valid candidate
</span><span>             if let Some(neighbor) = best_candidate {
</span><span style=color:#c594c5>@@ -712,74 +779,6 @@ </span><span style=color:#399ee6>pub fn auto_generate_navigation_edges(
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Built-in system that automatically rebuilds the navigation graph for `bevy_ui` nodes.
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// This system runs in `PostUpdate` in the `UiSystems::PostLayout` system set and automatically updates
</span><span style=color:#f07171>-/// the navigation graph when nodes with [`AutoDirectionalNavigation`] component change
</span><span style=color:#f07171>-/// their position or size.
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// # How it works
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// 1. Detects nodes with [`AutoDirectionalNavigation`] that have changed
</span><span style=color:#f07171>-/// 2. Extracts position/size from [`ComputedNode`] and [`UiGlobalTransform`]
</span><span style=color:#f07171>-/// 3. Calls [`auto_generate_navigation_edges`] to rebuild connections
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// This system is automatically added by [`DirectionalNavigationPlugin`], so users
</span><span style=color:#f07171>-/// only need to add the [`AutoDirectionalNavigation`] component to their UI entities.
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// # Note
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// This system only works with `bevy_ui` nodes. For custom UI systems, call
</span><span style=color:#f07171>-/// [`auto_generate_navigation_edges`] directly in your own system.
</span><span style=color:#f07171>-fn auto_rebuild_ui_navigation_graph(
</span><span style=color:#f07171>-    mut directional_nav_map: ResMut&LTDirectionalNavigationMap>,
</span><span style=color:#f07171>-    config: Res&LTAutoNavigationConfig>,
</span><span style=color:#f07171>-    changed_nodes: Query<
</span><span style=color:#f07171>-        (),
</span><span style=color:#f07171>-        (
</span><span style=color:#f07171>-            With&LTAutoDirectionalNavigation>,
</span><span style=color:#f07171>-            Or<(
</span><span style=color:#f07171>-                Added&LTAutoDirectionalNavigation>,
</span><span style=color:#f07171>-                Changed&LTComputedNode>,
</span><span style=color:#f07171>-                Changed&LTUiGlobalTransform>,
</span><span style=color:#f07171>-                Changed&LTInheritedVisibility>,
</span><span style=color:#f07171>-            )>,
</span><span style=color:#f07171>-        ),
</span><span style=color:#f07171>-    >,
</span><span style=color:#f07171>-    all_nodes: Query<
</span><span style=color:#f07171>-        (
</span><span style=color:#f07171>-            Entity,
</span><span style=color:#f07171>-            &ComputedNode,
</span><span style=color:#f07171>-            &UiGlobalTransform,
</span><span style=color:#f07171>-            &InheritedVisibility,
</span><span style=color:#f07171>-        ),
</span><span style=color:#f07171>-        With&LTAutoDirectionalNavigation>,
</span><span style=color:#f07171>-    >,
</span><span style=color:#f07171>-) {
</span><span style=color:#f07171>-    if changed_nodes.is_empty() {
</span><span style=color:#f07171>-        return;
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    let nodes: Vec&LTFocusableArea> = all_nodes
</span><span style=color:#f07171>-        .iter()
</span><span style=color:#f07171>-        .filter_map(|(entity, computed, transform, inherited_visibility)| {
</span><span style=color:#f07171>-            // Skip hidden or zero-size nodes
</span><span style=color:#f07171>-            if computed.is_empty() || !inherited_visibility.get() {
</span><span style=color:#f07171>-                return None;
</span><span style=color:#f07171>-            }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-            let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
</span><span style=color:#f07171>-            Some(FocusableArea {
</span><span style=color:#f07171>-                entity,
</span><span style=color:#f07171>-                position: translation,
</span><span style=color:#f07171>-                size: computed.size(),
</span><span style=color:#f07171>-            })
</span><span style=color:#f07171>-        })
</span><span style=color:#f07171>-        .collect();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    auto_generate_navigation_edges(&mut directional_nav_map, &nodes, &config);
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span> #[cfg(test)]
</span><span> mod tests {
</span><span>     use alloc::vec;
</span><span style=color:#c594c5>@@ -918,7 +917,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span>     }
</span><span> 
</span><span>     #[test]
</span><span style=color:#f07171>-    fn nav_with_system_param() {
</span><span style=color:#86b300>+    fn manual_nav_with_system_param() {
</span><span>         let mut world = World::new();
</span><span>         let a = world.spawn_empty().id();
</span><span>         let b = world.spawn_empty().id();
</span><span style=color:#c594c5>@@ -933,6 +932,9 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         focus.set(a);
</span><span>         world.insert_resource(focus);
</span><span> 
</span><span style=color:#86b300>+        let config = AutoNavigationConfig::default();
</span><span style=color:#86b300>+        world.insert_resource(config);
</span><span style=color:#86b300>+
</span><span>         assert_eq!(world.resource::&LTInputFocus>().get(), Some(a));
</span><span> 
</span><span>         fn navigate_east(mut nav: DirectionalNavigation) {
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22194.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>