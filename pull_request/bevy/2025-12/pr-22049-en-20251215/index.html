<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22049 single query per node in UI picking backend
        
    </title><meta content="#22049 single query per node in UI picking backend" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-15</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22049-zh-cn-20251215>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>single query per node in UI picking backend<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: single query per node in UI picking backend<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22049<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-UI, C-Code-Quality, S-Ready-For-Final-Review, A-Picking<li><strong>Created</strong>: 2025-12-06T21:53:59Z<li><strong>Merged</strong>: 2025-12-15T02:13:04Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>The UI picking backend queries twice for the node data. Simplify <code>ui_picking</code> by storing the camera entity and picking data in <code>hit_nodes</code> instead of the second query.<h2 id=solution>Solution</h2><p>Store the camera entity and picking data in <code>hit_nodes</code> instead of querying for them again.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The PR addresses a straightforward optimization in Bevy’s UI picking system. The <code>ui_picking</code> function, responsible for determining which UI elements are under the cursor, was performing redundant work: it was querying for the same node data twice during its execution. This inefficiency was identified and corrected with a minimal change to the function’s data flow.<p>The core problem was in how the function processed hovered UI nodes. During the initial pass, the function collected nodes that contained the cursor position. For each of these nodes, it stored the node entity and camera entity in a <code>hit_nodes</code> hash map. Later, when processing these hovered nodes to create <code>HitData</code> structures, the function needed to check each node’s <code>Pickable</code> component to determine if it should block interaction with nodes beneath it. This check required a second query:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(pickable) </span><span style=color:#ed9366>=</span><span> pickable_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>*</span><span>hovered_node) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> pickable</span><span style=color:#ed9366>.</span><span>should_block_lower {
</span><span>        </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The solution eliminated this redundant query by modifying the data structure to store the <code>Pickable</code> component data alongside the node and camera entities during the initial collection phase. The change modified the type of <code>hit_nodes</code> from storing tuples of <code>(Entity, Entity, Vec2)</code> to <code>(Entity, Entity, Option&LTPickable>, Vec2)</code>. During the initial pass, when a node is determined to be under the cursor, the function now clones the node’s <code>Pickable</code> component (if it exists) and stores it:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>hit_nodes
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>((camera_entity</span><span style=color:#61676ccc>,</span><span> pointer))
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((
</span><span>        node_entity</span><span style=color:#61676ccc>,
</span><span>        camera_entity</span><span style=color:#61676ccc>,
</span><span>        node</span><span style=color:#ed9366>.</span><span>pickable</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>()</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// New: store the Pickable data
</span><span>        node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>inverse</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>transform_point2</span><span>(</span><span style=color:#ed9366>*</span><span>cursor_position)
</span><span>            </span><span style=color:#ed9366>/</span><span> node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>()</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span></code></pre><p>This change allows the second processing pass to use the stored <code>Pickable</code> data directly without performing an additional query:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>for </span><span>(hovered_node</span><span style=color:#61676ccc>,</span><span> camera_entity</span><span style=color:#61676ccc>,</span><span> pickable</span><span style=color:#61676ccc>,</span><span> position) </span><span style=color:#ed9366>in</span><span> hovered {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(pickable) </span><span style=color:#ed9366>=</span><span> pickable {
</span><span>        </span><span style=color:#fa6e32>if</span><span> pickable</span><span style=color:#ed9366>.</span><span>should_block_lower {
</span><span>            </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The implementation is a classic example of trading memory for computation time. By storing an additional <code>Option&LTPickable></code> (which is a relatively small component containing just a boolean flag) for each hovered node, the function avoids a potentially expensive ECS query per node. This optimization becomes more significant when many UI nodes are under the cursor simultaneously, as it reduces the number of queries from O(n) to O(1) for the second pass.<p>The change also improves code clarity by making the data dependencies more explicit. The second processing loop now receives all the data it needs as parameters, rather than fetching it from the ECS world. This makes the code easier to reason about and maintains better separation of concerns.<p>This type of optimization is particularly valuable in Bevy’s ECS architecture, where minimizing queries can significantly improve performance. Each query involves iterating through archetypes and checking component matches, so reducing query count is a common optimization pattern in ECS-based systems.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[ui_picking system runs] --> B[First pass: collect hovered nodes]
</span><span>    B --> C[Store node_entity, camera_entity, Pickable, position]
</span><span>    C --> D[Second pass: process hovered nodes]
</span><span>    D --> E{Use stored Pickable data}
</span><span>    E --> F[No second query needed]
</span><span>    
</span><span>    G[Old approach] --> H[First pass: collect nodes]
</span><span>    H --> I[Second pass: query for Pickable]
</span><span>    I --> J[Additional ECS query per node]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ui-src-picking-backend-rs-6-3><code>crates/bevy_ui/src/picking_backend.rs</code> (+6/-3)</h3><p>This file contains the main implementation of the UI picking backend. The changes modify the <code>ui_picking</code> function to store <code>Pickable</code> component data during the initial collection phase, eliminating a redundant query.<p><strong>Key changes:</strong><ol><li><strong>Modified data structure type</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let mut</span><span> hit_nodes </span><span style=color:#ed9366>= </span><span>HashMap</span><span style=color:#ed9366>::</span><span><(Entity, PointerId), </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, Entity, Vec2)>></span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let mut</span><span> hit_nodes </span><span style=color:#ed9366>= </span><span>HashMap</span><span style=color:#ed9366>::</span><span><(Entity, PointerId), </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><(Entity, Entity, </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTPickable>, Vec2)>></span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span></code></pre><ol start=2><li><strong>Updated data collection</strong> (for text nodes):</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((
</span><span>    text_entity</span><span style=color:#61676ccc>,
</span><span>    camera_entity</span><span style=color:#61676ccc>,
</span><span>    node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>inverse</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>transform_point2</span><span>(</span><span style=color:#ed9366>*</span><span>cursor_position)
</span><span>        </span><span style=color:#ed9366>/</span><span> node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>()</span><span style=color:#61676ccc>,
</span><span>))</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>((
</span><span>    text_entity</span><span style=color:#61676ccc>,
</span><span>    camera_entity</span><span style=color:#61676ccc>,
</span><span>    node</span><span style=color:#ed9366>.</span><span>pickable</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>()</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// New field
</span><span>    node</span><span style=color:#ed9366>.</span><span>transform</span><span style=color:#ed9366>.</span><span style=color:#f07171>inverse</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>transform_point2</span><span>(</span><span style=color:#ed9366>*</span><span>cursor_position)
</span><span>        </span><span style=color:#ed9366>/</span><span> node</span><span style=color:#ed9366>.</span><span>node</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>()</span><span style=color:#61676ccc>,
</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><ol start=3><li><strong>Updated data processing</strong>:</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>for </span><span>(hovered_node</span><span style=color:#61676ccc>,</span><span> camera_entity</span><span style=color:#61676ccc>,</span><span> position) </span><span style=color:#ed9366>in</span><span> hovered {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(pickable) </span><span style=color:#ed9366>=</span><span> pickable_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>*</span><span>hovered_node) {
</span><span>        </span><span style=color:#fa6e32>if</span><span> pickable</span><span style=color:#ed9366>.</span><span>should_block_lower {
</span><span>            </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>for </span><span>(hovered_node</span><span style=color:#61676ccc>,</span><span> camera_entity</span><span style=color:#61676ccc>,</span><span> pickable</span><span style=color:#61676ccc>,</span><span> position) </span><span style=color:#ed9366>in</span><span> hovered {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(pickable) </span><span style=color:#ed9366>=</span><span> pickable {
</span><span>        </span><span style=color:#fa6e32>if</span><span> pickable</span><span style=color:#ed9366>.</span><span>should_block_lower {
</span><span>            </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The changes eliminate the <code>pickable_query</code> lookup in the second pass by using the stored <code>Pickable</code> data from the initial collection phase.<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Bevy ECS System Optimization</strong>: The official Bevy book section on system optimization discusses patterns for minimizing queries and improving performance: https://bevyengine.org/learn/quick-start/ecs-intro/</p><li><p><strong>ECS Architecture Patterns</strong>: For a deeper understanding of Entity Component System architecture and optimization techniques, the “ECS Back and Forth” series provides comprehensive coverage: https://skypjack.github.io/2019-03-07-ecs-baf-part-1/</p><li><p><strong>Rust HashMap Usage</strong>: The Rust standard library documentation for HashMap provides details on the data structure used in this PR: https://doc.rust-lang.org/std/collections/struct.HashMap.html</p><li><p><strong>Bevy Picking System</strong>: The Bevy UI picking system documentation explains how picking works in the engine: https://github.com/bevyengine/bevy/tree/main/crates/bevy_ui/src/picking</p></ol><h1 id=full-code-diff>Full Code Diff</h1><p>diff –git a/crates/bevy_ui/src/picking_backend.rs b/crates/bevy_ui/src/picking_backend.rs index 1028cfb6b0e5a..d3648ced54f90 100644 — a/crates/bevy_ui/src/picking_backend.rs +++ b/crates/bevy_ui/src/picking_backend.rs @@ -149,7 +149,8 @@ pub fn ui_picking( }<pre style=color:#61676c;background-color:#fafafa><code><span> // The list of node entities hovered for each (camera, pointer) combo
</span></code></pre><ul><li>let mut hit_nodes = HashMap::<(Entity, PointerId), Vec<(Entity, Entity, Vec2)>>::default();</ul><ul><li><p>let mut hit_nodes =</p><li><pre style=color:#61676c;background-color:#fafafa><code><span>   HashMap::<(Entity, PointerId), Vec<(Entity, Entity, Option&LTPickable>, Vec2)>>::default();
</span></code></pre> <p>// prepare an iterator that contains all the nodes that have the cursor in their rect, // from the top node to the bottom one. this will also reset the interaction to <code>None</code> @@ -222,6 +223,7 @@ pub fn ui_picking( .push(( text_entity, camera_entity,</p><li><pre style=color:#61676c;background-color:#fafafa><code><span>                           node.pickable.cloned(),
</span><span>                           node.transform.inverse().transform_point2(*cursor_position)
</span><span>                               / node.node.size(),
</span><span>                       ));
</span></code></pre></ul><p>@@ -240,6 +242,7 @@ pub fn ui_picking( .push(( node_entity, camera_entity,<ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>                       node.pickable.cloned(),
</span><span>                       node.transform.inverse().transform_point2(*cursor_position)
</span><span>                           / node.node.size(),
</span><span>                   ));
</span></code></pre></ul><p>@@ -254,13 +257,13 @@ pub fn ui_picking( let mut picks = Vec::new(); let mut depth = 0.0;<ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   for (hovered_node, camera_entity, position) in hovered {
</span></code></pre></ul><ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>   for (hovered_node, camera_entity, pickable, position) in hovered {
</span><span>       picks.push((
</span><span>           *hovered_node,
</span><span>           HitData::new(*camera_entity, depth, Some(position.extend(0.0)), None),
</span><span>       ));
</span></code></pre></ul><ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       if let Ok(pickable) = pickable_query.get(*hovered_node) {
</span></code></pre></ul><ul><li><pre style=color:#61676c;background-color:#fafafa><code><span>       if let Some(pickable) = pickable {
</span><span>           // If an entity has a `Pickable` component, we will use that as the source of truth.
</span><span>           if pickable.should_block_lower {
</span><span>               break;</span></code></pre></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22049.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>