<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22066 Add flag to force MSAA writeback
        
    </title><meta content="#22066 Add flag to force MSAA writeback" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-09</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22066-zh-cn-20251209>中文</a></div></div><div class=pr-content><h1 id=title-add-flag-to-force-msaa-writeback>Title: Add flag to force MSAA writeback</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add flag to force MSAA writeback<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22066<li><strong>Author</strong>: tychedelia<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, D-Modest, S-Needs-Review<li><strong>Created</strong>: 2025-12-08T23:03:30Z<li><strong>Merged</strong>: 2025-12-09T00:20:22Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><p>For Processing, we sometimes need to write out of band to the main view target, which will get clobbered if it’s the first camera and writeback doesn’t occur.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>The issue stems from how Bevy handles Multi-Sample Anti-Aliasing (MSAA) writeback between cameras. MSAA writeback is the process where a camera’s render output is copied into the MSAA-sampled texture before rendering begins, allowing multiple cameras to layer their results when MSAA is enabled. This is particularly important for rendering pipelines where multiple cameras render to the same target.<p>Prior to this PR, the system had a binary choice: either MSAA writeback was enabled (default) or disabled. When enabled, writeback would only occur if the camera wasn’t the first one rendering to that target. This logic made sense for typical camera stacking scenarios where the first camera has no previous content to preserve. However, it created a problem for advanced rendering techniques where content might be written directly to the main texture via low-level operations like <code>write_texture</code> before any camera renders.<p>In these advanced use cases, developers needed to preserve this pre-written content through the MSAA render pass, but the existing logic would skip writeback for the first camera, effectively clobbering the manually written data. The binary boolean flag <code>msaa_writeback</code> didn’t provide enough granularity to handle this scenario.<h3 id=the-solution-approach>The Solution Approach</h3><p>The developer implemented a more flexible control mechanism by replacing the boolean <code>msaa_writeback</code> field with an enum that offers three distinct modes of operation. This approach maintains backward compatibility while adding the necessary flexibility for advanced use cases.<p>The key insight was that instead of just enabling or disabling writeback, cameras need different policies for when writeback should occur:<ul><li>Some cameras should never do writeback<li>Some should follow the default automatic behavior (writeback only if not first camera)<li>Some should always do writeback, even when they’re the first camera</ul><p>This enum-based approach provides explicit control while keeping the API intuitive and self-documenting.<h3 id=the-implementation>The Implementation</h3><p>The implementation involved changes across five files, with the core change being the introduction of the <code>MsaaWriteback</code> enum. The enum was added to the <code>bevy_camera</code> crate with proper serialization, reflection, and default implementations:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Reflect</span><span style=color:#61676ccc>,</span><span> Serialize</span><span style=color:#61676ccc>,</span><span> Deserialize</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Default</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>reflect</span><span>(Serialize</span><span style=color:#61676ccc>,</span><span> Deserialize</span><span style=color:#61676ccc>,</span><span> Default</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>MsaaWriteback </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Never perform MSAA writeback for this camera.
</span><span>    Off</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Perform MSAA writeback only when this camera is not the first one rendering to the target.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// This is the default behavior - the first camera has nothing to write back.
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>default</span><span>]
</span><span>    Auto</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Always perform MSAA writeback, even if this is the first camera rendering to the target.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// This is useful when content has been written directly to the main texture (e.g., via
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// `write_texture`) and needs to be preserved through the MSAA render pass.
</span><span>    Always</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>The <code>Camera</code> component was updated to use this enum instead of a boolean:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Camera </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... other fields
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Controls when MSAA writeback occurs for this camera.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// See [`MsaaWriteback`] for available options.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>msaa_writeback</span><span style=color:#61676ccc>:</span><span> MsaaWriteback,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... other fields
</span><span>}
</span></code></pre><p>The rendering logic in <code>msaa_writeback.rs</code> was updated to handle the three cases:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> should_writeback </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> camera</span><span style=color:#ed9366>.</span><span>msaa_writeback {
</span><span>    MsaaWriteback</span><span style=color:#ed9366>::</span><span>Off </span><span style=color:#ed9366>=> </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>    MsaaWriteback</span><span style=color:#ed9366>::</span><span>Auto </span><span style=color:#ed9366>=></span><span> camera</span><span style=color:#ed9366>.</span><span>sorted_camera_index_for_target </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,
</span><span>    MsaaWriteback</span><span style=color:#ed9366>::</span><span>Always </span><span style=color:#ed9366>=> </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>,
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>This cleanly separates the decision logic into three distinct branches, making the code more maintainable and easier to understand than the previous boolean logic with an implicit condition.<h3 id=technical-insights>Technical Insights</h3><p>The implementation demonstrates several good engineering practices:<ol><li><p><strong>Backward Compatibility</strong>: By setting <code>Auto</code> as the default variant, existing code continues to work exactly as before without any changes.</p><li><p><strong>Explicit over Implicit</strong>: The enum makes the different behaviors explicit and self-documenting. Developers can clearly see what each option does without having to trace through conditional logic.</p><li><p><strong>Proper API Design</strong>: The enum is placed in the appropriate module (<code>bevy_camera</code>) and exported through the prelude, making it easily accessible to users.</p><li><p><strong>Separation of Concerns</strong>: The decision logic for whether to perform writeback is cleanly separated from the actual writeback implementation, making both easier to test and maintain.</p></ol><p>One important consideration is that this change affects both the ECS component (<code>Camera</code>) and the extracted rendering data (<code>ExtractedCamera</code>), requiring updates in both <code>bevy_camera</code> and <code>bevy_render</code> crates. The implementation handles this consistently across both representations.<h3 id=the-impact>The Impact</h3><p>This change provides several concrete benefits:<ol><li><p><strong>Advanced Rendering Support</strong>: Developers can now use low-level texture writing operations (like <code>write_texture</code>) and preserve that content through MSAA rendering passes, enabling more complex rendering pipelines.</p><li><p><strong>Flexible Camera Control</strong>: The three modes provide fine-grained control over MSAA writeback behavior, accommodating a wider range of use cases without workarounds.</p><li><p><strong>Cleaner Code</strong>: The enum-based approach makes the code more readable and maintainable. The match statement in the rendering logic is clearer than the previous compound boolean condition.</p><li><p><strong>Future Extensibility</strong>: If additional writeback policies are needed in the future, they can be added as new enum variants without breaking existing code.</p></ol><p>The change is relatively small in scope but addresses a real pain point for developers implementing advanced rendering techniques. It demonstrates how thoughtful API design can solve specific problems while maintaining simplicity for common use cases.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Camera Component] --> B[ExtractedCamera Data]
</span><span>    B --> C[MSAA Writeback Decision]
</span><span>    C --> D{MsaaWriteback Enum}
</span><span>    D --> E[Off: Never writeback]
</span><span>    D --> F[Auto: Writeback if not first camera]
</span><span>    D --> G[Always: Always writeback]
</span><span>    E --> H[Perform Writeback?]
</span><span>    F --> H
</span><span>    G --> H
</span><span>    H --> I[Writeback Execution]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-camera-src-clear-color-rs-19-0><code>crates/bevy_camera/src/clear_color.rs</code> (+19/-0)</h3><p>This file now contains the definition of the <code>MsaaWriteback</code> enum. The enum provides three options for controlling MSAA writeback behavior with clear documentation for each variant.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>/// Controls when MSAA writeback occurs for a camera.
</span><span style=color:#abb0b6;font-style:italic>///
</span><span style=color:#abb0b6;font-style:italic>/// MSAA writeback copies the previous camera's output into the MSAA sampled texture before
</span><span style=color:#abb0b6;font-style:italic>/// rendering, allowing multiple cameras to layer their results when MSAA is enabled.
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Reflect</span><span style=color:#61676ccc>,</span><span> Serialize</span><span style=color:#61676ccc>,</span><span> Deserialize</span><span style=color:#61676ccc>,</span><span> Copy</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Default</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>reflect</span><span>(Serialize</span><span style=color:#61676ccc>,</span><span> Deserialize</span><span style=color:#61676ccc>,</span><span> Default</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>MsaaWriteback </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Never perform MSAA writeback for this camera.
</span><span>    Off</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Perform MSAA writeback only when this camera is not the first one rendering to the target.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// This is the default behavior - the first camera has nothing to write back.
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>default</span><span>]
</span><span>    Auto</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Always perform MSAA writeback, even if this is the first camera rendering to the target.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// This is useful when content has been written directly to the main texture (e.g., via
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// `write_texture`) and needs to be preserved through the MSAA render pass.
</span><span>    Always</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><h3 id=crates-bevy-post-process-src-msaa-writeback-rs-9-4><code>crates/bevy_post_process/src/msaa_writeback.rs</code> (+9/-4)</h3><p>This file contains the logic that determines whether to perform MSAA writeback. The boolean check was replaced with a match statement that handles all three enum variants.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>if</span><span> msaa</span><span style=color:#ed9366>.</span><span style=color:#f07171>samples</span><span>() </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>1 </span><span style=color:#ed9366>&&</span><span> camera</span><span style=color:#ed9366>.</span><span>msaa_writeback </span><span style=color:#ed9366>&&</span><span> camera</span><span style=color:#ed9366>.</span><span>sorted_camera_index_for_target </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>0
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> should_writeback </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> camera</span><span style=color:#ed9366>.</span><span>msaa_writeback {
</span><span>    MsaaWriteback</span><span style=color:#ed9366>::</span><span>Off </span><span style=color:#ed9366>=> </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>    MsaaWriteback</span><span style=color:#ed9366>::</span><span>Auto </span><span style=color:#ed9366>=></span><span> camera</span><span style=color:#ed9366>.</span><span>sorted_camera_index_for_target </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,
</span><span>    MsaaWriteback</span><span style=color:#ed9366>::</span><span>Always </span><span style=color:#ed9366>=> </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>,
</span><span>}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>if</span><span> msaa</span><span style=color:#ed9366>.</span><span style=color:#f07171>samples</span><span>() </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>1 </span><span style=color:#ed9366>&&</span><span> should_writeback
</span></code></pre><h3 id=crates-bevy-camera-src-camera-rs-5-7><code>crates/bevy_camera/src/camera.rs</code> (+5/-7)</h3><p>The <code>Camera</code> struct was updated to use the <code>MsaaWriteback</code> enum instead of a boolean, and the documentation was updated to reference the new enum.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub</span><span> msaa_writeback</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub</span><span> msaa_writeback</span><span style=color:#61676ccc>:</span><span> MsaaWriteback</span><span style=color:#61676ccc>,
</span></code></pre><h3 id=crates-bevy-render-src-camera-rs-3-3><code>crates/bevy_render/src/camera.rs</code> (+3/-3)</h3><p>The <code>ExtractedCamera</code> struct was updated to match the change in the <code>Camera</code> component, ensuring consistency between the ECS representation and the extracted rendering data.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub</span><span> msaa_writeback</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub</span><span> msaa_writeback</span><span style=color:#61676ccc>:</span><span> MsaaWriteback</span><span style=color:#61676ccc>,
</span></code></pre><h3 id=crates-bevy-camera-src-lib-rs-2-2><code>crates/bevy_camera/src/lib.rs</code> (+2/-2)</h3><p>The <code>MsaaWriteback</code> enum was added to the prelude exports, making it easily accessible to users without needing to know its exact module path.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Added to prelude:
</span><span>MsaaWriteback</span><span style=color:#61676ccc>,
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy Render Graph Documentation</strong>: For understanding how cameras and render targets work in Bevy’s rendering system<li><strong>MSAA Techniques in Computer Graphics</strong>: For background on multi-sample anti-aliasing and why writeback is necessary<li><strong>Bevy Camera Component Documentation</strong>: For details on camera configuration and rendering options<li><strong>GPU Texture Operations</strong>: For understanding low-level texture operations like <code>write_texture</code> that motivated this change<li><strong>Enum-driven Configuration Patterns</strong>: For learning more about using enums for flexible configuration APIs in Rust</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22066.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>