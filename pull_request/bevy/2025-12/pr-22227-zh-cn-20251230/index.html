<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22227 Make `LoadContext::finish` add all dependencies, and avoid a second texture load in GltfLoader.
        
    </title><meta content="#22227 Make `LoadContext::finish` add all dependencies, and avoid a second texture load in GltfLoader." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-30</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-12/pr-22227-en-20251230>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Make <code>LoadContext::finish</code> add all dependencies, and avoid a second texture load in GltfLoader.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22227<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Assets, S-Ready-For-Final-Review, D-Modest, A-glTF, C-Refinement<li><strong>Created</strong>: 2025-12-22T05:17:19Z<li><strong>Merged</strong>: 2025-12-30T01:09:24Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h3 id=mu-biao>目标</h3><ul><li>glTF 加载器之前对纹理进行了两次加载：第一次执行所有预期的解析和加载。第二次会<strong>故意</strong>尝试执行相同的加载，以 A) 避免进行第二次加载，B) 将句柄作为材质的具体依赖项添加 - 这样材质在所有纹理加载完成之前不会被视为“已加载且依赖项就绪“。<li>通常情况下，一个资产可能持有另一个资产的句柄，但根据 <code>LoadContext</code>，这个句柄不被视为依赖项。<li>此外，<code>StandardMaterial</code> 中的一些句柄缺少 <code>#[dependency]</code> 属性。</ul><h3 id=jie-jue-fang-an>解决方案</h3><ul><li>为 <code>StandardMaterial</code> 中的所有句柄添加 <code>#[dependency]</code> 属性。<li>使 glTF 各项异性扩展也使用与其他扩展相同的 <code>parse_material_extension_texture</code> 函数（现有实现完全匹配）。<li>使 <code>LoadContext::finish</code> 使用 <code>VisitDependencies</code> 更新依赖项列表。<li>将纹理句柄列表通过 <code>GltfLoader</code> 传递，并在需要时克隆句柄。</ul><h3 id=ce-shi>测试</h3><ul><li>在 <code>bevy_asset</code> 中添加测试以验证依赖项跟踪是否有效 - 这部分在 PR 的其他更改之前也会失败。<li>运行了 <code>load_gltf</code> 示例，仍然正常工作。不过这不会显示依赖项跟踪是否正常工作。</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个PR主要解决了Bevy资产系统中两个相关的问题：glTF加载器对纹理的重复加载，以及依赖项跟踪的不一致性。<h3 id=wen-ti-bei-jing-he-dong-ji>问题背景和动机</h3><p>在原始的glTF加载实现中，存在一个效率问题和逻辑问题。当加载glTF材质时，系统会对每个纹理进行两次加载尝试：第一次是实际的解析和加载，第二次是<strong>故意</strong>尝试执行相同的加载。这第二次尝试有两个目的：首先是为了避免重复加载（如果纹理已经加载过），其次是为了将纹理句柄作为材质的依赖项添加，确保材质在所有纹理加载完成之前不被标记为“已加载且依赖项就绪“。<p>这种做法不仅效率低下（需要进行两次尝试），而且在逻辑上也存在问题。更根本的问题是，资产系统中的依赖项跟踪机制存在缺口：一个资产可以持有另一个资产的句柄，但如果这个句柄不是通过同一 <code>LoadContext</code> 加载的，它就不会被自动识别为依赖项。<h3 id=ji-shu-jie-jue-fang-an>技术解决方案</h3><p>这个PR通过三个主要修改来解决这些问题：<ol><li><p><strong>统一依赖项跟踪</strong>：修改 <code>LoadContext::finish</code> 方法，使其在完成资产加载时自动收集资产中的所有依赖项。这是通过调用资产的 <code>visit_dependencies</code> 方法实现的，该方法会遍历资产中所有标记为 <code>#[dependency]</code> 的字段。</p><li><p><strong>消除纹理重复加载</strong>：重构glTF加载器，使其在加载阶段一次性获取所有纹理句柄，然后将这些句柄传递给材质加载函数。这样，材质可以直接使用已经加载的纹理句柄，而不需要尝试第二次加载。</p><li><p><strong>完善依赖项标记</strong>：为 <code>StandardMaterial</code> 中所有之前缺少 <code>#[dependency]</code> 属性的纹理句柄字段添加该属性，确保依赖项跟踪系统能够正确识别这些依赖关系。</p></ol><h3 id=he-xin-shi-xian-xi-jie>核心实现细节</h3><h4 id=loadcontext-finish-de-xiu-gai>LoadContext::finish 的修改</h4><p>关键的变化发生在 <code>crates/bevy_asset/src/loader.rs</code> 中：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>finish</span><span>&LTA</span><span style=color:#61676ccc>:</span><span> Asset>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>:</span><span> A) </span><span style=color:#61676ccc>-> </span><span>LoadedAsset&LTA> {
</span><span>    LoadedAsset {
</span><span>        value</span><span style=color:#61676ccc>,
</span><span>        dependencies</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>dependencies</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>finish</span><span>&LTA</span><span style=color:#61676ccc>:</span><span> Asset>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>:</span><span> A) </span><span style=color:#61676ccc>-> </span><span>LoadedAsset&LTA> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 此时，我们假设资产/子资产已经"锁定"且不会被更改，
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 因此可以确保所有依赖项都被包含（以防句柄被使用但没有通过此LoadContext加载）。
</span><span>    value</span><span style=color:#ed9366>.</span><span style=color:#f07171>visit_dependencies</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ed9366>|</span><span>asset_id</span><span style=color:#ed9366>| </span><span>{
</span><span>        </span><span style=color:#fa6e32>let </span><span>(type_id</span><span style=color:#61676ccc>,</span><span> index) </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> asset_id {
</span><span>            UntypedAssetId</span><span style=color:#ed9366>::</span><span>Index { type_id</span><span style=color:#61676ccc>,</span><span> index } </span><span style=color:#ed9366>=> </span><span>(type_id</span><span style=color:#61676ccc>,</span><span> index)</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// UUID资产无法加载，直接忽略此ID
</span><span>            UntypedAssetId</span><span style=color:#ed9366>::</span><span>Uuid { </span><span style=color:#ed9366>.. </span><span>} </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>,
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>dependencies
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(ErasedAssetIndex { index</span><span style=color:#61676ccc>,</span><span> type_id })</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    LoadedAsset {
</span><span>        value</span><span style=color:#61676ccc>,
</span><span>        dependencies</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>dependencies</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span></code></pre><p>这个修改确保了即使资产句柄不是通过当前 <code>LoadContext</code> 加载的，只要它们被标记为 <code>#[dependency]</code>，就会被正确识别为依赖项。<h4 id=gltfjia-zai-qi-de-zhong-gou>glTF加载器的重构</h4><p>glTF加载器的重构更为复杂。以前，材质加载函数 <code>load_material</code> 直接接收 <code>LoadContext</code> 和 <code>Document</code>，并负责加载纹理。现在，它改为接收预加载的纹理句柄列表：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load_material</span><span>(
</span><span>    </span><span style=color:#ff8f40>material</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Material,
</span><span>    </span><span style=color:#ff8f40>load_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> LoadContext,
</span><span>    </span><span style=color:#ff8f40>document</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Document,
</span><span>    </span><span style=color:#ff8f40>is_scale_inverted</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>Handle&LTStandardMaterial>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load_material</span><span>(
</span><span>    </span><span style=color:#ff8f40>material</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Material,
</span><span>    </span><span style=color:#ff8f40>textures</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[Handle&LTImage>],
</span><span>    </span><span style=color:#ff8f40>is_scale_inverted</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#ff8f40>asset_path</span><span style=color:#61676ccc>: </span><span>AssetPath<'</span><span style=color:#ed9366>_</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>(String, StandardMaterial)
</span></code></pre><p>这个改变有以下几个重要影响：<ol><li>材质加载不再负责加载纹理，而是直接从 <code>textures</code> 数组中获取句柄<li>函数现在返回材质标签和材质本身，而不是直接插入到 <code>LoadContext</code> 中<li>调用者负责使用 <code>add_labeled_asset</code> 将材质添加到上下文中</ol><h4 id=kuo-zhan-de-tong-yi-chu-li>扩展的统一处理</h4><p>PR还统一了glTF扩展对纹理的处理方式。例如，<code>khr_materials_anisotropy</code> 扩展现在使用与其他扩展相同的 <code>parse_material_extension_texture</code> 函数：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: 有自己的纹理加载逻辑
</span><span style=color:#fa6e32>let </span><span>(anisotropy_channel</span><span style=color:#61676ccc>,</span><span> anisotropy_texture) </span><span style=color:#ed9366>=</span><span> extension
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#86b300>"anisotropyTexture"</span><span>)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>and_then</span><span>(|</span><span style=color:#ff8f40>value</span><span>| value</span><span style=color:#ed9366>::</span><span>from_value</span><span style=color:#ed9366>::</span><span>&LTInfo>(value</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#ed9366>.</span><span style=color:#f07171>ok</span><span>())
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>json_info</span><span>| {
</span><span>        (
</span><span>            </span><span style=color:#f07171>uv_channel</span><span>(material</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"anisotropy"</span><span style=color:#61676ccc>,</span><span> json_info</span><span style=color:#ed9366>.</span><span>tex_coord)</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#f07171>texture_handle_from_info</span><span>(</span><span style=color:#ed9366>&</span><span>json_info</span><span style=color:#61676ccc>,</span><span> document</span><span style=color:#61676ccc>,</span><span> load_context)</span><span style=color:#61676ccc>,
</span><span>        )
</span><span>    })
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>unzip</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: 使用统一的函数
</span><span style=color:#fa6e32>let </span><span>(anisotropy_channel</span><span style=color:#61676ccc>,</span><span> anisotropy_texture) </span><span style=color:#ed9366>= </span><span style=color:#f07171>parse_material_extension_texture</span><span>(
</span><span>    material</span><span style=color:#61676ccc>,
</span><span>    extension</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"anisotropyTexture"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"anisotropy"</span><span style=color:#61676ccc>,
</span><span>    textures</span><span style=color:#61676ccc>,
</span><span>    asset_path</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=ce-shi-yan-zheng>测试验证</h3><p>为了确保依赖项跟踪的正确性，PR添加了一个专门的测试 <code>asset_dependency_is_tracked_when_not_loaded</code>。这个测试验证了即使依赖项不是通过子资产的 <code>LoadContext</code> 加载的，它仍然会被正确跟踪。测试创建了一个具有依赖项的资产，其中依赖项在根上下文中加载，但句柄被放入子资产中。测试验证了子资产在依赖项加载完成前不会被标记为“已加载且依赖项就绪“。<h3 id=ji-shu-ying-xiang-he-kao-liang>技术影响和考量</h3><p>这个PR的实现有几个重要的技术考量：<ol><li><p><strong>性能改进</strong>：通过消除纹理的重复加载尝试，减少了glTF加载过程中的冗余操作。虽然第二次加载尝试通常不会实际加载数据（如果纹理已缓存），但仍然涉及查找和检查，现在这些开销被完全消除了。</p><li><p><strong>架构清晰度</strong>：将纹理加载职责与材质加载职责分离，使代码更加模块化。材质加载函数现在只关注如何构建材质，而不关心如何获取纹理句柄。</p><li><p><strong>依赖项跟踪的完整性</strong>：修改确保所有通过 <code>#[dependency]</code> 标记的句柄都会被正确跟踪，无论它们是如何被获取的。这对于确保资产加载状态的正确性至关重要。</p><li><p><strong>向后兼容性</strong>：虽然实现方式发生了变化，但外部API和行为保持不变，确保了现有代码的兼容性。</p></ol><p>这个PR展示了资产系统中依赖项跟踪的重要性，以及如何通过合理的架构设计避免冗余操作。它解决了glTF加载中的一个具体问题，同时也改进了整个资产系统的健壮性。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[GltfLoader] --> B[加载所有纹理]
</span><span>    B --> C[创建textures数组]
</span><span>    C --> D[加载材质]
</span><span>    D --> E[使用textures数组&LTbr>而非LoadContext加载纹理]
</span><span>    E --> F[创建StandardMaterial]
</span><span>    F --> G[标记所有纹理句柄为#[dependency]]
</span><span>    G --> H[LoadContext::finish]
</span><span>    H --> I[自动收集所有依赖项]
</span><span>    I --> J[正确跟踪材质依赖关系]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-asset-src-loader-rs-80-0><code>crates/bevy_asset/src/loader.rs</code> (+80/-0)</h3><p><strong>修改说明</strong>：修改了 <code>LoadContext::finish</code> 方法，使其在完成资产加载时自动调用 <code>visit_dependencies</code> 来收集所有依赖项。<p><strong>关键代码修改</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>finish</span><span>&LTA</span><span style=color:#61676ccc>:</span><span> Asset>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>:</span><span> A) </span><span style=color:#61676ccc>-> </span><span>LoadedAsset&LTA> {
</span><span>    value</span><span style=color:#ed9366>.</span><span style=color:#f07171>visit_dependencies</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ed9366>|</span><span>asset_id</span><span style=color:#ed9366>| </span><span>{
</span><span>        </span><span style=color:#fa6e32>let </span><span>(type_id</span><span style=color:#61676ccc>,</span><span> index) </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match</span><span> asset_id {
</span><span>            UntypedAssetId</span><span style=color:#ed9366>::</span><span>Index { type_id</span><span style=color:#61676ccc>,</span><span> index } </span><span style=color:#ed9366>=> </span><span>(type_id</span><span style=color:#61676ccc>,</span><span> index)</span><span style=color:#61676ccc>,
</span><span>            UntypedAssetId</span><span style=color:#ed9366>::</span><span>Uuid { </span><span style=color:#ed9366>.. </span><span>} </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>,
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>dependencies
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(ErasedAssetIndex { index</span><span style=color:#61676ccc>,</span><span> type_id })</span><span style=color:#61676ccc>;
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    LoadedAsset {
</span><span>        value</span><span style=color:#61676ccc>,
</span><span>        dependencies</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>dependencies</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-gltf-src-loader-mod-rs-263-241><code>crates/bevy_gltf/src/loader/mod.rs</code> (+263/-241)</h3><p><strong>修改说明</strong>：重构了glTF加载器，使其在加载阶段一次性获取所有纹理句柄，然后将这些句柄传递给材质加载函数，避免了纹理的重复加载。<p><strong>关键代码修改</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 加载材质的函数签名变化
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load_material</span><span>(
</span><span>    </span><span style=color:#ff8f40>material</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Material,
</span><span>    </span><span style=color:#ff8f40>textures</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[Handle&LTImage>],  </span><span style=color:#abb0b6;font-style:italic>// 新增参数：预加载的纹理句柄
</span><span>    </span><span style=color:#ff8f40>is_scale_inverted</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    </span><span style=color:#ff8f40>asset_path</span><span style=color:#61676ccc>: </span><span>AssetPath<'</span><span style=color:#ed9366>_</span><span>>,
</span><span>) </span><span style=color:#61676ccc>-> </span><span>(String, StandardMaterial)  </span><span style=color:#abb0b6;font-style:italic>// 返回类型变为元组
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在加载器主循环中使用纹理句柄
</span><span style=color:#fa6e32>let</span><span> handle </span><span style=color:#ed9366>= </span><span>{
</span><span>    </span><span style=color:#fa6e32>let </span><span>(label</span><span style=color:#61676ccc>,</span><span> material) </span><span style=color:#ed9366>= </span><span style=color:#f07171>load_material</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span>material</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>&</span><span>texture_handles</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// 传递纹理句柄数组
</span><span>        </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>        load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>path</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>    load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_labeled_asset</span><span>(label</span><span style=color:#61676ccc>,</span><span> material)
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-gltf-src-loader-gltf-ext-texture-rs-2-65><code>crates/bevy_gltf/src/loader/gltf_ext/texture.rs</code> (+2/-65)</h3><p><strong>修改说明</strong>：移除了不再使用的纹理加载函数，因为现在纹理加载统一在加载器主循环中处理。<p><strong>关键代码删除</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 删除了以下函数：
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>texture_handle_from_info</span><span>(...)
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>texture_handle</span><span>(...)
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>texture_label</span><span>(...)
</span></code></pre><h3 id=crates-bevy-gltf-src-loader-extensions-khr-materials-anisotropy-rs-15-23><code>crates/bevy_gltf/src/loader/extensions/khr_materials_anisotropy.rs</code> (+15/-23)</h3><p><strong>修改说明</strong>：统一了各项异性扩展的纹理处理方式，使其使用与其他扩展相同的 <code>parse_material_extension_texture</code> 函数。<p><strong>关键代码修改</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 函数签名变化
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>parse</span><span>(
</span><span>    </span><span style=color:#ff8f40>material</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Material,
</span><span>    </span><span style=color:#ff8f40>textures</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[Handle&LTImage>],  </span><span style=color:#abb0b6;font-style:italic>// 新增参数
</span><span>    </span><span style=color:#ff8f40>asset_path</span><span style=color:#61676ccc>: </span><span>AssetPath<'</span><span style=color:#ed9366>_</span><span>>,   </span><span style=color:#abb0b6;font-style:italic>// 新增参数
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTAnisotropyExtension>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 使用统一的纹理解析函数
</span><span style=color:#fa6e32>let </span><span>(anisotropy_channel</span><span style=color:#61676ccc>,</span><span> anisotropy_texture) </span><span style=color:#ed9366>= </span><span style=color:#f07171>parse_material_extension_texture</span><span>(
</span><span>    material</span><span style=color:#61676ccc>,
</span><span>    extension</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"anisotropyTexture"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"anisotropy"</span><span style=color:#61676ccc>,
</span><span>    textures</span><span style=color:#61676ccc>,
</span><span>    asset_path</span><span style=color:#61676ccc>,
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-pbr-src-pbr-material-rs><code>crates/bevy_pbr/src/pbr_material.rs</code></h3><p><strong>修改说明</strong>：为 <code>StandardMaterial</code> 中所有之前缺少 <code>#[dependency]</code> 属性的纹理句柄字段添加该属性。<p><strong>关键代码修改</strong>：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 为多个纹理句柄字段添加 #[dependency] 属性
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>dependency</span><span>]
</span><span style=color:#fa6e32>pub</span><span> diffuse_transmission_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTHandle&LTImage>></span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>dependency</span><span>]
</span><span style=color:#fa6e32>pub</span><span> specular_transmission_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTHandle&LTImage>></span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>dependency</span><span>]
</span><span style=color:#fa6e32>pub</span><span> thickness_texture</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTHandle&LTImage>></span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// ... 以及其他类似字段
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Bevy Asset System Documentation</strong>: 了解Bevy资产系统的基本概念和设计原理<li><strong>glTF 2.0 Specification</strong>: 理解glTF格式的详细规范和各扩展的工作原理<li><strong>Rust Attribute Macros</strong>: 学习 <code>#[dependency]</code> 等属性宏的工作原理<li><strong>Dependency Tracking in Game Engines</strong>: 了解游戏引擎中资产依赖项跟踪的常见模式和最佳实践</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22227.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>