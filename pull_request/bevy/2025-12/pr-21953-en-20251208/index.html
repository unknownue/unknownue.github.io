<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21953 Solari: Misc improvements
        
    </title><meta content="#21953 Solari: Misc improvements" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-08</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-21953-zh-cn-20251208>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari: Misc improvements<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21953<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, S-Ready-For-Final-Review, C-Refinement<li><strong>Created</strong>: 2025-11-27T04:48:25Z<li><strong>Merged</strong>: 2025-12-07T23:57:22Z<li><strong>Merged By</strong>: james7132</ul><h2 id=description>Description</h2><ul><li>Search for a spatial neighbor up to 5 times for ReSTIR instead of just once.<li>Bump RAY_T_MIN to 0.001. Prevents artifacts and doesn’t really cause more self intersections.<li>Re-calculate world cache cell_size after jittering the query position to prevent creating extra cells at the wrong LOD for a given position.<li>Prevent the unlikely event of something checksumming to 0, which is reserved for empty cells.</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses four distinct but related issues in Bevy’s Solari rendering system, each affecting different aspects of the real-time global illumination (ReSTIR GI) and direct illumination (ReSTIR DI) pipelines. The changes focus on improving robustness, reducing visual artifacts, and fixing edge cases in the rendering algorithms.<p>The first issue involves spatial neighbor selection in the ReSTIR algorithm. Previously, both the GI and DI implementations would sample exactly one neighboring pixel to reuse illumination data. This approach had a significant flaw: if the randomly selected neighbor was on a different surface (determined by depth, position, and normal similarity checks), the algorithm would simply return an empty reservoir, wasting an opportunity to reuse valid illumination data. The solution replaces this single-try approach with a loop that attempts up to 5 random neighbors. This simple but effective change increases the probability of finding a valid spatial neighbor, reducing noise and improving temporal stability in the rendered output. Both the GI and DI shaders now share this improved logic, though they handle the returned data slightly differently due to their specific requirements.<p>The second change addresses ray tracing precision. The <code>RAY_T_MIN</code> constant controls the minimum distance a ray can travel before hitting a surface, which helps prevent self-intersection artifacts. The original value of 0.01 was found to be too large in practice, causing artifacts in certain scenarios. The PR reduces this to 0.001, providing better precision while maintaining protection against self-intersection. This adjustment demonstrates the importance of tuning such constants based on real-world testing rather than theoretical assumptions.<p>The third fix corrects a subtle bug in the world cache query system. When querying the world cache for illumination data, the algorithm applies jitter to the world position to avoid aliasing artifacts. However, the cell size (which determines the level of detail for cache lookups) was being calculated using the original position before jittering. This could cause the system to create cache cells at incorrect LODs, potentially wasting memory or reducing cache efficiency. The fix recalculates the cell size after applying jitter, ensuring the cache operates at the correct resolution for the actual query point.<p>The final change handles an edge case in the world cache checksum calculation. The hash function could theoretically produce a value of 0, which is reserved to indicate empty cache cells. While statistically unlikely, this could cause valid cache entries to be incorrectly treated as empty. The fix adds a <code>max(key, 1u)</code> to ensure the checksum never returns 0, preserving the semantic meaning of this special value.<p>Together, these changes represent pragmatic improvements to the rendering system’s reliability and visual quality. They demonstrate the iterative refinement process common in graphics programming, where small adjustments to algorithms and constants can have noticeable impacts on output quality and system robustness.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[Solari Rendering System] --> B[ReSTIR Direct Illumination]
</span><span>    A --> C[ReSTIR Global Illumination]
</span><span>    A --> D[World Cache System]
</span><span>    A --> E[Ray Tracing System]
</span><span>    
</span><span>    B --> B1[Fix: 5x spatial neighbor search]
</span><span>    C --> C1[Fix: 5x spatial neighbor search]
</span><span>    D --> D1[Fix: Recalculate cell_size after jitter]
</span><span>    D --> D2[Fix: Ensure checksum ≠ 0]
</span><span>    E --> E1[Fix: Reduce RAY_T_MIN to 0.001]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-restir-di-wgsl-15-11><code>crates/bevy_solari/src/realtime/restir_di.wgsl</code> (+15/-11)</h3><p>This file implements ReSTIR Direct Illumination. The key change replaces a single spatial neighbor lookup with a loop that attempts up to 5 random neighbors.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before: Single attempt
</span><span>fn load_spatial_reservoir(pixel_id: vec2&LTu32>, depth: f32, world_position: vec3&LTf32>, world_normal: vec3&LTf32>, rng: ptr&LTfunction, u32>) -> Reservoir {
</span><span>    let spatial_pixel_id = get_neighbor_pixel_id(pixel_id, rng);
</span><span>
</span><span>    let spatial_depth = textureLoad(depth_buffer, spatial_pixel_id, 0);
</span><span>    let spatial_surface = gpixel_resolve(textureLoad(gbuffer, spatial_pixel_id, 0), spatial_depth, spatial_pixel_id, view.main_pass_viewport.zw, view.world_from_clip);
</span><span>    if pixel_dissimilar(depth, world_position, spatial_surface.world_position, world_normal, spatial_surface.world_normal, view) {
</span><span>        return empty_reservoir();
</span><span>    }
</span><span>
</span><span>    return load_reservoir_b(spatial_pixel_id);
</span><span>}
</span><span>
</span><span>// After: Up to 5 attempts
</span><span>fn load_spatial_reservoir(pixel_id: vec2&LTu32>, depth: f32, world_position: vec3&LTf32>, world_normal: vec3&LTf32>, rng: ptr&LTfunction, u32>) -> Reservoir {
</span><span>    for (var i = 0u; i < 5u; i++) {
</span><span>        let spatial_pixel_id = get_neighbor_pixel_id(pixel_id, rng);
</span><span>
</span><span>        let spatial_depth = textureLoad(depth_buffer, spatial_pixel_id, 0);
</span><span>        let spatial_surface = gpixel_resolve(textureLoad(gbuffer, spatial_pixel_id, 0), spatial_depth, spatial_pixel_id, view.main_pass_viewport.zw, view.world_from_clip);
</span><span>        if pixel_dissimilar(depth, world_position, spatial_surface.world_position, world_normal, spatial_surface.world_normal, view) {
</span><span>            continue;
</span><span>        }
</span><span>
</span><span>        return load_reservoir_b(spatial_pixel_id);
</span><span>    }
</span><span>
</span><span>    return empty_reservoir();
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-restir-gi-wgsl-10-6><code>crates/bevy_solari/src/realtime/restir_gi.wgsl</code> (+10/-6)</h3><p>Similar to the DI shader, this file implements ReSTIR Global Illumination with the same spatial neighbor search improvement.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// After: Up to 5 attempts with GI-specific return structure
</span><span>fn load_spatial_reservoir(pixel_id: vec2&LTu32>, depth: f32, world_position: vec3&LTf32>, world_normal: vec3&LTf32>, rng: ptr&LTfunction, u32>) -> NeighborInfo {
</span><span>    for (var i = 0u; i < 5u; i++) {
</span><span>        let spatial_pixel_id = get_neighbor_pixel_id(pixel_id, rng);
</span><span>
</span><span>        let spatial_depth = textureLoad(depth_buffer, spatial_pixel_id, 0);
</span><span>        let spatial_surface = gpixel_resolve(textureLoad(gbuffer, spatial_pixel_id, 0), spatial_depth, spatial_pixel_id, view.main_pass_viewport.zw, view.world_from_clip);
</span><span>        let spatial_diffuse_brdf = spatial_surface.material.base_color / PI;
</span><span>        if pixel_dissimilar(depth, world_position, spatial_surface.world_position, world_normal, spatial_surface.world_normal, view) {
</span><span>            continue;
</span><span>        }
</span><span>
</span><span>        let spatial_pixel_index = spatial_pixel_id.x + spatial_pixel_id.y * u32(view.main_pass_viewport.z);
</span><span>        var spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
</span><span>
</span><span>        spatial_reservoir.radiance *= trace_point_visibility(world_position, spatial_reservoir.sample_point_world_position);
</span><span>
</span><span>        return NeighborInfo(spatial_reservoir, spatial_surface.world_position, spatial_surface.world_normal, spatial_diffuse_brdf);
</span><span>    }
</span><span>
</span><span>    return NeighborInfo(empty_reservoir(), world_position, world_normal, vec3(0.0));
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-query-wgsl-3-2><code>crates/bevy_solari/src/realtime/world_cache_query.wgsl</code> (+3/-2)</h3><p>This file contains two important fixes for the world cache system.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Fix 1: Recalculate cell_size after jittering
</span><span>fn query_world_cache(world_position: vec3&LTf32>, world_normal: vec3&LTf32>, view_position: vec3&LTf32>, cell_lifetime: u32, rng: ptr&LTfunction, u32>) -> vec3&LTf32> {
</span><span>    var cell_size = get_cell_size(world_position, view_position);  // Changed from 'let' to 'var'
</span><span>
</span><span>    // https://tomclabault.github.io/blog/2025/regir, jitter_world_position_tangent_plane
</span><span>    let TBN = orthonormalize(world_normal);
</span><span>    let offset = (rand_vec2f(rng) * 2.0 - 1.0) * cell_size * 0.5;
</span><span>    let jittered_position = world_position + offset.x * TBN[0] + offset.y * TBN[1];
</span><span>    cell_size = get_cell_size(jittered_position, view_position);  // Added recalculation
</span><span>
</span><span>    // ... rest of function
</span><span>}
</span><span>
</span><span>// Fix 2: Prevent checksum from returning 0
</span><span>fn compute_checksum(world_position: vec3&LTu32>, world_normal: vec3&LTu32>) -> u32 {
</span><span>    var key = pcg_hash(world_position.x);
</span><span>    key = iqint_hash(key + world_position.y);
</span><span>    key = iqint_hash(key + world_position.z);
</span><span>    key = iqint_hash(key + world_normal.x);
</span><span>    key = iqint_hash(key + world_normal.y);
</span><span>    key = iqint_hash(key + world_normal.z);
</span><span>    return max(key, 1u); // 0u is reserved for WORLD_CACHE_EMPTY_CELL
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-scene-raytracing-scene-bindings-wgsl-1-1><code>crates/bevy_solari/src/scene/raytracing_scene_bindings.wgsl</code> (+1/-1)</h3><p>This file contains a simple but important constant adjustment.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>const RAY_T_MIN = 0.01f;
</span><span>
</span><span>// After:
</span><span>const RAY_T_MIN = 0.001f;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>ReSTIR Algorithm</strong>: The original paper “Spatio-temporal reservoir resampling for real-time ray tracing with dynamic direct lighting” by Bitterli et al. provides the theoretical foundation for these implementations.</p><li><p><strong>World Cache Systems</strong>: For background on world cache and level-of-detail systems in real-time rendering, “Real-Time Rendering” by Akenine-Möller et al. covers relevant concepts.</p><li><p><strong>Ray Tracing Precision</strong>: NVIDIA’s “Ray Tracing Gems” series discusses practical considerations for ray tracing constants like <code>RAY_T_MIN</code> and techniques for avoiding self-intersection artifacts.</p><li><p><strong>Hash Functions in Graphics</strong>: The PCG hash function used in the checksum is documented in “PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation” by O’Neill.</p><li><p><strong>Jittering for Anti-Aliasing</strong>: The referenced blog post at https://tomclabault.github.io/blog/2025/regir provides specific context for the jittering technique used in the world cache system.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_21953.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>