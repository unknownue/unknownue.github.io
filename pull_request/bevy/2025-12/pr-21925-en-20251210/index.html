<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21925 Avoid reading the entire asset into memory during asset processing.
        
    </title><meta content="#21925 Avoid reading the entire asset into memory during asset processing." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-10</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-21925-zh-cn-20251210>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Avoid reading the entire asset into memory during asset processing.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21925<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Assets, C-Performance, S-Ready-For-Final-Review, D-Straightforward<li><strong>Created</strong>: 2025-11-24T02:40:44Z<li><strong>Merged</strong>: 2025-12-10T00:19:59Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>When processing assets, we first read the whole asset into memory, then process the asset from that in-memory representation. This means that large assets may just not fit into memory causing much bigger issues (e.g., switching over to slow virtual memory).</ul><h2 id=solution>Solution</h2><ul><li>Read the asset twice during processing: 1) once to determine the asset hash, 2) once to actually process the asset.</ul><p>This means the processing code itself doesn’t need to read the whole asset into memory at any point, meaning we can now process much bigger assets.<p>However, there are some risks. Asset sources which can’t read chunks of an asset - which need to read the whole asset into memory anyway - now have to do so twice (not at the same time though). An example of this kind of asset source is the default Wasm source, or the HTTP asset source. In practice, I don’t think this is a big issue - processing is likely to be happening on local assets anyway - it seems unlikely that users will want to download large assets from an HTTP asset source multiple times (which needs to happen any time you start the app, even ignoring this PR).<h2 id=testing>Testing</h2><ul><li>The processing tests all still pass.</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The asset processing system in Bevy had a straightforward but problematic design: it would load entire asset files into memory before processing them. This approach worked well for small assets but created significant issues with large files. When processing multi-gigabyte assets like 3D models, textures, or video files, the system could exhaust available memory, leading to performance degradation from virtual memory swapping or outright failures.<p>The core issue was in the <code>AssetProcessor::process_asset</code> function, which followed a simple sequence: read the asset file entirely into a <code>Vec&LTu8></code>, compute a hash of those bytes, then pass the entire byte array to the processing logic. While this was convenient for the processing code, it placed an upper limit on the size of assets that could be processed based on available system memory.<p>The solution required rethinking how asset bytes flow through the processing pipeline. Instead of buffering everything in memory, the system needed to stream assets in chunks. However, there was a complication: asset hashing required reading all bytes, and asset processing also required reading all bytes. The straightforward streaming approach would need to read the asset twice.<p>The implementation takes a pragmatic approach. First, the <code>get_asset_hash</code> function in <code>meta.rs</code> was modified to accept an async <code>Reader</code> instead of a byte slice. It now reads the asset in fixed-size chunks (using Blake3’s <code>CHUNK_LEN</code> as the buffer size), updating the hash incrementally:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get_asset_hash</span><span>(
</span><span>    </span><span style=color:#ff8f40>meta_bytes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#fa6e32>u8</span><span>],
</span><span>    </span><span style=color:#ff8f40>asset_reader</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> impl Reader,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTAssetHash, AssetReaderError> {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> hasher </span><span style=color:#ed9366>= </span><span>blake3</span><span style=color:#ed9366>::</span><span>Hasher</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    hasher</span><span style=color:#ed9366>.</span><span style=color:#f07171>update</span><span>(meta_bytes)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> buffer </span><span style=color:#ed9366>= </span><span>[</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>; </span><span>blake3</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>CHUNK_LEN</span><span>]</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>loop </span><span>{
</span><span>        </span><span style=color:#fa6e32>let</span><span> bytes_read </span><span style=color:#ed9366>=</span><span> asset_reader</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> buffer)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>        hasher</span><span style=color:#ed9366>.</span><span style=color:#f07171>update</span><span>(</span><span style=color:#ed9366>&</span><span>buffer[</span><span style=color:#ed9366>..</span><span>bytes_read])</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if</span><span> bytes_read </span><span style=color:#ed9366><</span><span> buffer</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>            </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#ed9366>*</span><span>hasher</span><span style=color:#ed9366>.</span><span style=color:#f07171>finalize</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_bytes</span><span>())
</span><span>}
</span></code></pre><p>This change alone doesn’t solve the memory issue because the processing code still expected the full byte array. The key insight was that the <code>ProcessContext</code>, which provides data to asset processors, could be modified to provide a <code>Reader</code> instead of a byte slice. This allows processors to stream the asset if they choose, or read it entirely into memory if they need random access.<p>In <code>processor/mod.rs</code>, the <code>process_asset</code> function was restructured to create two separate readers: one for hashing and one for processing. The code comments acknowledge the trade-off: “this means that we’re performing two reads for the same file (but we avoid having to load the whole file into memory).” For local file systems, this is generally acceptable since disk I/O is relatively fast. For remote sources like HTTP, this could mean downloading the asset twice, but the PR author argues this is acceptable since asset processing typically happens with local files during development or build time.<p>The <code>ProcessContext</code> struct in <code>processor/process.rs</code> was updated to hold a <code>Box&LTdyn Reader></code> instead of a byte slice reference:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ProcessContext</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    processor</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> AssetProcessor,
</span><span>    path</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a </span><span>AssetPath<</span><span style=color:#fa6e32>'static</span><span>>,
</span><span>    reader</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn Reader </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>'a</span><span>>,
</span><span>    new_processed_info</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a mut</span><span> ProcessedInfo,
</span><span>}
</span></code></pre><p>The <code>asset_bytes()</code> method was replaced with <code>asset_reader()</code> which returns a mutable reference to the reader. This change required updating all existing <code>Process</code> implementations, which is why a migration guide was added.<p>When an asset doesn’t need custom processing (i.e., it uses a <code>()</code> processor), the system now streams directly from the reader to the writer without buffering:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>futures_lite</span><span style=color:#ed9366>::</span><span>io</span><span style=color:#ed9366>::</span><span>copy(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> reader_for_process</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> writer)
</span><span>    </span><span style=color:#ed9366>.</span><span>await
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>map_err</span><span>(|</span><span style=color:#ff8f40>err</span><span>| ProcessError</span><span style=color:#ed9366>::</span><span>AssetWriterError {
</span><span>        path</span><span style=color:#61676ccc>:</span><span> asset_path</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone_owned</span><span>()</span><span style=color:#61676ccc>,
</span><span>        err</span><span style=color:#61676ccc>:</span><span> err</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>,
</span><span>    })</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre><p>This change represents a shift from a memory-centric to a streaming-centric design. The performance characteristics change from being memory-bound to being I/O-bound, which is generally more predictable and scalable. Large assets that previously couldn’t be processed can now be handled, albeit with potentially longer processing times due to multiple disk reads.<p>The trade-offs are clearly documented: assets from sources that don’t support streaming (like HTTP or Wasm) will be downloaded twice. However, the assumption is that asset processing typically happens with local files during development or build processes, not with remote assets at runtime. If this assumption proves incorrect, future optimizations could include caching mechanisms or source-specific optimizations.<p>This change also demonstrates good API design practice: the migration from <code>asset_bytes()</code> to <code>asset_reader()</code> maintains backward compatibility in spirit while enabling new capabilities. Processors that need the entire asset in memory can still call <code>read_to_end()</code> on the reader, while processors that can work streamingly can process chunks as they arrive.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Asset Source] --> B[First Read: Compute Hash]
</span><span>    A --> C[Second Read: Process Asset]
</span><span>    B --> D[Update ProcessedInfo]
</span><span>    C --> E{Has Custom Processor?}
</span><span>    E -->|Yes| F[Process via Process trait]
</span><span>    E -->|No| G[Stream copy to output]
</span><span>    F --> H[Write processed asset]
</span><span>    G --> H
</span><span>    D --> I[Write metadata]
</span><span>    H --> I
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-asset-src-meta-rs><code>crates/bevy_asset/src/meta.rs</code></h3><p><strong>What changed</strong>: Modified <code>get_asset_hash</code> to accept a <code>Reader</code> and compute hash incrementally instead of requiring all bytes in memory. <strong>Why</strong>: To avoid loading large assets entirely into memory just for hashing. <strong>Key code</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Required full byte array
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get_asset_hash</span><span>(</span><span style=color:#ff8f40>meta_bytes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#fa6e32>u8</span><span>], </span><span style=color:#ff8f40>asset_bytes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#fa6e32>u8</span><span>]) </span><span style=color:#61676ccc>-></span><span> AssetHash
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Streams from reader
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get_asset_hash</span><span>(
</span><span>    </span><span style=color:#ff8f40>meta_bytes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#fa6e32>u8</span><span>],
</span><span>    </span><span style=color:#ff8f40>asset_reader</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> impl Reader,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTAssetHash, AssetReaderError>
</span></code></pre><h3 id=crates-bevy-asset-src-processor-mod-rs><code>crates/bevy_asset/src/processor/mod.rs</code></h3><p><strong>What changed</strong>: Restructured asset processing to use two separate reads and avoid buffering the entire asset. <strong>Why</strong>: To enable processing of assets larger than available memory. <strong>Key code</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Single read into memory
</span><span style=color:#fa6e32>let mut</span><span> asset_bytes </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>byte_reader</span><span style=color:#ed9366>.</span><span style=color:#f07171>read_to_end</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> asset_bytes)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> new_hash </span><span style=color:#ed9366>= </span><span style=color:#f07171>get_asset_hash</span><span>(</span><span style=color:#ed9366>&</span><span>meta_bytes</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>asset_bytes)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: First read for hashing, second for processing
</span><span style=color:#fa6e32>let</span><span> new_hash </span><span style=color:#ed9366>= </span><span>{
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> reader_for_hash </span><span style=color:#ed9366>=</span><span> reader</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>(path)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>map_err</span><span>(reader_err)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>get_asset_hash</span><span>(</span><span style=color:#ed9366>&</span><span>meta_bytes</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> reader_for_hash)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>map_err</span><span>(reader_err)</span><span style=color:#ed9366>?
</span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let mut</span><span> reader_for_process </span><span style=color:#ed9366>=</span><span> reader</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>(path)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>map_err</span><span>(reader_err)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-asset-src-processor-process-rs><code>crates/bevy_asset/src/processor/process.rs</code></h3><p><strong>What changed</strong>: Updated <code>ProcessContext</code> to hold a <code>Reader</code> instead of byte slice, and modified related methods. <strong>Why</strong>: To allow processors to stream assets rather than requiring full in-memory representation. <strong>Key code</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Held byte slice
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ProcessContext</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    asset_bytes</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> [</span><span style=color:#fa6e32>u8</span><span>],
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Holds reader
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ProcessContext</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    reader</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn Reader </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>'a</span><span>>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Method changed from:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>asset_bytes</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#fa6e32>u8</span><span>]
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// To:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>asset_reader</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> dyn Reader
</span></code></pre><h3 id=release-content-migration-guides-process-trait-changes-md><code>release-content/migration-guides/process_trait_changes.md</code></h3><p><strong>What changed</strong>: Added migration guide for updating <code>Process</code> implementations. <strong>Why</strong>: The API change from <code>asset_bytes()</code> to <code>asset_reader()</code> requires updates to custom processor code. <strong>Key content</strong>: Shows how to convert code that used <code>asset_bytes()</code> to use <code>asset_reader()</code> with <code>read_to_end()</code> for backward compatibility.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/books/unofficial-bevy-book/features/assets/ target=_blank>Bevy Asset System Documentation</a> - Overview of Bevy’s asset system<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Streaming_algorithm target=_blank>Streaming vs Buffering I/O</a> - Concepts of streaming data processing<li><a rel="noopener nofollow noreferrer" href=https://github.com/BLAKE3-team/BLAKE3 target=_blank>Blake3 Hash Algorithm</a> - Cryptographic hash function used by Bevy<li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/ target=_blank>Async I/O in Rust</a> - Understanding async I/O patterns used in this PR</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_21925.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>