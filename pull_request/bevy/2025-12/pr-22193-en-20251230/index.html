<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22193 Add support for SSR on web
        
    </title><meta content="#22193 Add support for SSR on web" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22193-zh-cn-20251230>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add support for SSR on web<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22193<li><strong>Author</strong>: mate-h<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, O-Web, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-12-18T23:50:10Z<li><strong>Merged</strong>: 2025-12-30T05:40:56Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Implemented WebGPU safe SSR (screen-space reflections) while preserving native behavior<li>Fixes #21700</ul><h2 id=solution>Solution</h2><ul><li>Kept native SSR unchanged by defining <code>USE_DEPTH_SAMPLERS</code> shader def on native<li>the pipeline still binds filtered depth samplers and uses <code>textureSampleLevel</code> on depth<li>added manual depth sampling in <code>ssr/raymarch.wgsl</code> via <code>textureLoad</code> with clamped bilinear and nearest helpers<li>This avoids the validation error previously happening on web (documented in the linked issue above)</ul><h2 id=testing>Testing</h2><ul><li>Ran the ssr example on native and web using the bevy CLI<li>Ran the atmosphere example on native and web</ul><hr><h2 id=showcase>Showcase</h2><p>Atmosphere example running (fixed) using deferred rendering + SSR on web browser (chrome)</p><img alt="Screenshot 2025-12-18 at 3 26 21 PM" height=1140 src=https://github.com/user-attachments/assets/bc9484c1-e3f2-4adf-a740-c0a7c3312a8d width=1388><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a WebGPU validation error that was preventing Screen-Space Reflections (SSR) from working correctly on web platforms. The core issue stems from WebGPU’s stricter validation rules compared to native platforms, specifically regarding how depth textures can be sampled.<p>The problem centers around WebGPU’s specification that depth textures with formats like <code>depth32float</code> cannot be sampled with filtering samplers (like bilinear or nearest-neighbor filters) unless they are used in comparison sampling operations. In Bevy’s SSR implementation, the shader was using regular filtered sampling on depth textures, which worked fine on native platforms but caused WebGPU validation errors when running on web.<p>The developer took a pragmatic approach to solve this compatibility issue without breaking existing native functionality. Instead of changing the native implementation to match web constraints, they implemented a conditional solution that maintains optimal performance on native while providing a compliant workaround for web.<p>The solution introduces a shader definition <code>USE_DEPTH_SAMPLERS</code> that’s only defined on non-WASM32 targets (native platforms). This allows the same shader code to branch between two different sampling strategies. On native, the shader continues to use the standard <code>textureSampleLevel</code> function with filtered samplers, which is more efficient and leverages GPU hardware filtering. On web, the shader falls back to manual sampling using <code>textureLoad</code>, implementing bilinear and nearest-neighbor filtering in shader code.<p>This approach required adding two new helper functions in the WGSL shader: <code>depth_sample_bilinear_clamped</code> and <code>depth_sample_nearest_clamped</code>. These functions manually implement texture filtering by:<ol><li>Calculating texel coordinates from UV coordinates<li>Loading the four surrounding texels for bilinear filtering (or just the nearest texel for nearest-neighbor)<li>Performing the interpolation manually in the shader</ol><p>The manual sampling approach avoids the validation error because it uses <code>textureLoad</code> instead of filtered sampling. While less efficient than hardware filtering, it provides correct results and enables SSR to work on web platforms. The implementation carefully handles edge cases with clamping to prevent sampling outside texture boundaries.<p>From an architectural perspective, this change demonstrates a good pattern for handling platform-specific differences in graphics code. By using shader definitions controlled at compile time, the solution maintains clean separation between platform implementations while keeping the codebase unified. This approach is more maintainable than having completely separate shader files for different platforms.<p>The changes are minimal and focused: two files modified with a total of 54 lines added and 4 lines removed. The Rust-side change is simply adding the <code>USE_DEPTH_SAMPLERS</code> shader definition conditionally. The WGSL changes are self-contained within the shader, wrapping the existing sampling code with conditional branches and adding the manual sampling fallback.<p>This implementation successfully resolves the validation error while preserving visual parity between native and web versions. The SSR effect works correctly on both platforms, as demonstrated by the provided screenshot showing the atmosphere example with deferred rendering and SSR running in Chrome.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[SSR Pipeline Specialization] --> B{Conditional: target_arch = wasm32?}
</span><span>    B -- No --> C[Define USE_DEPTH_SAMPLERS shader def]
</span><span>    B -- Yes --> D[No USE_DEPTH_SAMPLERS defined]
</span><span>    
</span><span>    C --> E[Native Platform Path]
</span><span>    D --> F[Web Platform Path]
</span><span>    
</span><span>    E --> G[Use textureSampleLevel with samplers]
</span><span>    F --> H[Use manual textureLoad with filtering]
</span><span>    
</span><span>    G --> I[SSR Works on Native]
</span><span>    H --> J[SSR Works on Web]
</span><span>    
</span><span>    subgraph "Manual Sampling Implementation"
</span><span>        K[textureLoad with coordinates]
</span><span>        L[Manual bilinear interpolation]
</span><span>        M[Manual nearest-neighbor]
</span><span>        K --> L
</span><span>        K --> M
</span><span>    end
</span><span>    
</span><span>    H --> K
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-pbr-src-ssr-mod-rs-3-0><code>crates/bevy_pbr/src/ssr/mod.rs</code> (+3/-0)</h3><p>This file controls the specialization of the SSR render pipeline. The change adds a conditional shader definition based on the target architecture.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: No conditional shader definition for depth samplers
</span><span style=color:#abb0b6;font-style:italic>// After: Added conditional definition for native platforms
</span><span>
</span><span style=color:#fa6e32>impl </span><span>SpecializedRenderPipeline </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>ScreenSpaceReflectionsPipeline </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing code ...
</span><span>    
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(</span><span style=color:#f29718>not</span><span>(target_arch </span><span style=color:#ed9366>= </span><span style=color:#86b300>"wasm32"</span><span>))]
</span><span>    shader_defs</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(</span><span style=color:#86b300>"USE_DEPTH_SAMPLERS"</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing code ...
</span><span>}
</span></code></pre><p><strong>What changed and why</strong>: The change adds a shader definition <code>USE_DEPTH_SAMPLERS</code> that’s only included when not compiling for WebAssembly (i.e., on native platforms). This serves as a compile-time flag that the WGSL shader can use to conditionally compile different code paths for native vs web platforms.<h3 id=crates-bevy-pbr-src-ssr-raymarch-wgsl-51-4><code>crates/bevy_pbr/src/ssr/raymarch.wgsl</code> (+51/-4)</h3><p>This is the main SSR shader that performs the raymarching algorithm. The changes implement platform-specific sampling strategies.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Always using filtered samplers for depth textures
</span><span style=color:#ed9366>@</span><span style=color:#f07171>group</span><span>(</span><span style=color:#ff8f40>2</span><span>) </span><span style=color:#ed9366>@</span><span style=color:#f07171>binding</span><span>(</span><span style=color:#ff8f40>2</span><span>) var depth_linear_sampler</span><span style=color:#61676ccc>:</span><span> sampler</span><span style=color:#61676ccc>;
</span><span style=color:#ed9366>@</span><span style=color:#f07171>group</span><span>(</span><span style=color:#ff8f40>2</span><span>) </span><span style=color:#ed9366>@</span><span style=color:#f07171>binding</span><span>(</span><span style=color:#ff8f40>3</span><span>) var depth_nearest_sampler</span><span style=color:#61676ccc>:</span><span> sampler</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// In the main function:
</span><span style=color:#fa6e32>let</span><span> linear_depth </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>/</span><span> textureSampleLevel(depth_prepass_texture</span><span style=color:#61676ccc>,</span><span> depth_linear_sampler</span><span style=color:#61676ccc>,</span><span> interp_uv</span><span style=color:#61676ccc>,</span><span> 0u)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> unfiltered_depth </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>/</span><span> textureSampleLevel(depth_prepass_texture</span><span style=color:#61676ccc>,</span><span> depth_nearest_sampler</span><span style=color:#61676ccc>,</span><span> interp_uv</span><span style=color:#61676ccc>,</span><span> 0u)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Conditional compilation based on USE_DEPTH_SAMPLERS
</span><span style=color:#ed9366>#</span><span>ifdef </span><span style=color:#ff8f40>USE_DEPTH_SAMPLERS
</span><span style=color:#ed9366>@</span><span style=color:#f07171>group</span><span>(</span><span style=color:#ff8f40>2</span><span>) </span><span style=color:#ed9366>@</span><span style=color:#f07171>binding</span><span>(</span><span style=color:#ff8f40>2</span><span>) var depth_linear_sampler</span><span style=color:#61676ccc>:</span><span> sampler</span><span style=color:#61676ccc>;
</span><span style=color:#ed9366>@</span><span style=color:#f07171>group</span><span>(</span><span style=color:#ff8f40>2</span><span>) </span><span style=color:#ed9366>@</span><span style=color:#f07171>binding</span><span>(</span><span style=color:#ff8f40>3</span><span>) var depth_nearest_sampler</span><span style=color:#61676ccc>:</span><span> sampler</span><span style=color:#61676ccc>;
</span><span style=color:#ed9366>#</span><span>endif
</span><span>
</span><span style=color:#ed9366>#</span><span>ifndef </span><span style=color:#ff8f40>USE_DEPTH_SAMPLERS
</span><span style=color:#abb0b6;font-style:italic>// Manual sampling implementation for web
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>depth_texel_clamped</span><span>(</span><span style=color:#ff8f40>texel</span><span style=color:#61676ccc>: </span><span>vec2<</span><span style=color:#fa6e32>i32</span><span>>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> dims </span><span style=color:#ed9366>=</span><span> textureDimensions(depth_prepass_texture)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> max_coord </span><span style=color:#ed9366>= </span><span>vec2<</span><span style=color:#fa6e32>i32</span><span>>(</span><span style=color:#fa6e32>i32</span><span>(dims</span><span style=color:#ed9366>.</span><span>x) </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>i32</span><span>(dims</span><span style=color:#ed9366>.</span><span>y) </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> clamped </span><span style=color:#ed9366>= </span><span style=color:#f07171>clamp</span><span>(texel</span><span style=color:#61676ccc>, </span><span>vec2<</span><span style=color:#fa6e32>i32</span><span>>(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>,</span><span> max_coord)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return</span><span> textureLoad(depth_prepass_texture</span><span style=color:#61676ccc>,</span><span> clamped</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>depth_sample_nearest_clamped</span><span>(</span><span style=color:#ff8f40>uv</span><span style=color:#61676ccc>: </span><span>vec2<</span><span style=color:#fa6e32>f32</span><span>>, </span><span style=color:#ff8f40>tex_size</span><span style=color:#61676ccc>: </span><span>vec2<</span><span style=color:#fa6e32>f32</span><span>>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> coord </span><span style=color:#ed9366>=</span><span> uv </span><span style=color:#ed9366>*</span><span> tex_size </span><span style=color:#ed9366>- </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>0.5</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#f07171>depth_texel_clamped</span><span>(vec2<</span><span style=color:#fa6e32>i32</span><span>>(</span><span style=color:#f07171>floor</span><span>(coord </span><span style=color:#ed9366>+ </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>0.5</span><span>))))</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>depth_sample_bilinear_clamped</span><span>(</span><span style=color:#ff8f40>uv</span><span style=color:#61676ccc>: </span><span>vec2<</span><span style=color:#fa6e32>f32</span><span>>, </span><span style=color:#ff8f40>tex_size</span><span style=color:#61676ccc>: </span><span>vec2<</span><span style=color:#fa6e32>f32</span><span>>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> coord </span><span style=color:#ed9366>=</span><span> uv </span><span style=color:#ed9366>*</span><span> tex_size </span><span style=color:#ed9366>- </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>0.5</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> base </span><span style=color:#ed9366>= </span><span>vec2<</span><span style=color:#fa6e32>i32</span><span>>(</span><span style=color:#f07171>floor</span><span>(coord))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> frac </span><span style=color:#ed9366>=</span><span> coord </span><span style=color:#ed9366>- </span><span style=color:#f07171>floor</span><span>(coord)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> d00 </span><span style=color:#ed9366>= </span><span style=color:#f07171>depth_texel_clamped</span><span>(base)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> d10 </span><span style=color:#ed9366>= </span><span style=color:#f07171>depth_texel_clamped</span><span>(base </span><span style=color:#ed9366>+ </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> d01 </span><span style=color:#ed9366>= </span><span style=color:#f07171>depth_texel_clamped</span><span>(base </span><span style=color:#ed9366>+ </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1</span><span>))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> d11 </span><span style=color:#ed9366>= </span><span style=color:#f07171>depth_texel_clamped</span><span>(base </span><span style=color:#ed9366>+ </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1</span><span>))</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> d0 </span><span style=color:#ed9366>= </span><span style=color:#f07171>mix</span><span>(d00</span><span style=color:#61676ccc>,</span><span> d10</span><span style=color:#61676ccc>,</span><span> frac</span><span style=color:#ed9366>.</span><span>x)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> d1 </span><span style=color:#ed9366>= </span><span style=color:#f07171>mix</span><span>(d01</span><span style=color:#61676ccc>,</span><span> d11</span><span style=color:#61676ccc>,</span><span> frac</span><span style=color:#ed9366>.</span><span>x)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#f07171>mix</span><span>(d0</span><span style=color:#61676ccc>,</span><span> d1</span><span style=color:#61676ccc>,</span><span> frac</span><span style=color:#ed9366>.</span><span>y)</span><span style=color:#61676ccc>;
</span><span>}
</span><span style=color:#ed9366>#</span><span>endif
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Wrapper functions that choose implementation based on platform
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>depth_sample_linear</span><span>(</span><span style=color:#ff8f40>uv</span><span style=color:#61676ccc>: </span><span>vec2<</span><span style=color:#fa6e32>f32</span><span>>, </span><span style=color:#ff8f40>tex_size</span><span style=color:#61676ccc>: </span><span>vec2<</span><span style=color:#fa6e32>f32</span><span>>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span style=color:#ed9366>#</span><span>ifdef </span><span style=color:#ff8f40>USE_DEPTH_SAMPLERS
</span><span>    </span><span style=color:#fa6e32>return</span><span> textureSampleLevel(depth_prepass_texture</span><span style=color:#61676ccc>,</span><span> depth_linear_sampler</span><span style=color:#61676ccc>,</span><span> uv</span><span style=color:#61676ccc>,</span><span> 0u)</span><span style=color:#61676ccc>;
</span><span style=color:#ed9366>#</span><span style=color:#fa6e32>else
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#f07171>depth_sample_bilinear_clamped</span><span>(uv</span><span style=color:#61676ccc>,</span><span> tex_size)</span><span style=color:#61676ccc>;
</span><span style=color:#ed9366>#</span><span>endif
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// In the main function (replacing direct sampler calls):
</span><span style=color:#fa6e32>let</span><span> linear_depth </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>/ </span><span style=color:#f07171>depth_sample_linear</span><span>(interp_uv</span><span style=color:#61676ccc>, </span><span>(</span><span style=color:#ed9366>*</span><span>distance_fn)</span><span style=color:#ed9366>.</span><span>depth_tex_size)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> unfiltered_depth </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1.0 </span><span style=color:#ed9366>/ </span><span style=color:#f07171>depth_sample_nearest</span><span>(interp_uv</span><span style=color:#61676ccc>, </span><span>(</span><span style=color:#ed9366>*</span><span>distance_fn)</span><span style=color:#ed9366>.</span><span>depth_tex_size)</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>What changed and why</strong>: The shader now conditionally defines depth samplers only when <code>USE_DEPTH_SAMPLERS</code> is defined (native platforms). For web platforms, it implements manual texture sampling using <code>textureLoad</code>. Two new wrapper functions <code>depth_sample_linear</code> and <code>depth_sample_nearest</code> provide a uniform interface that delegates to either the hardware-sampled or manually-sampled implementation based on the platform. The manual sampling correctly implements both bilinear and nearest-neighbor filtering with proper coordinate clamping.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/webgpu/#texture-formats target=_blank>WebGPU Specification - Texture Formats</a>: Details on which texture formats support which sampling modes<li><a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/WGSL/#texturesamplelevel target=_blank>WGSL Specification - textureSampleLevel</a>: Documentation on texture sampling with mip level specification<li><a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/WGSL/#textureload target=_blank>WGSL Specification - textureLoad</a>: Documentation on direct texel loading without filtering<li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Bilinear_interpolation target=_blank>Bilinear Interpolation</a>: Mathematical background on bilinear filtering implementation<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/advanced-topics/shader-defs/ target=_blank>Bevy Shader Definitions</a>: How shader definitions work in Bevy for conditional compilation</ul><h1 id=full-code-diff>Full Code Diff</h1><p>The full code diff shows exactly what changed:<pre style=color:#61676c;background-color:#fafafa><code><span>diff --git a/crates/bevy_pbr/src/ssr/mod.rs b/crates/bevy_pbr/src/ssr/mod.rs
</span><span>index 40b84f3d733f7..7bd9d02c529de 100644
</span><span>--- a/crates/bevy_pbr/src/ssr/mod.rs
</span><span>+++ b/crates/bevy_pbr/src/ssr/mod.rs
</span><span>@@ -552,6 +552,9 @@ impl SpecializedRenderPipeline for ScreenSpaceReflectionsPipeline {
</span><span>             shader_defs.push("ATMOSPHERE".into());
</span><span>         }
</span><span> 
</span><span>+        #[cfg(not(target_arch = "wasm32"))]
</span><span>+        shader_defs.push("USE_DEPTH_SAMPLERS".into());
</span><span>+
</span><span>         RenderPipelineDescriptor {
</span><span>             label: Some("SSR pipeline".into()),
</span><span>             layout,
</span><span>diff --git a/crates/bevy_pbr/src/ssr/raymarch.wgsl b/crates/bevy_pbr/src/ssr/raymarch.wgsl
</span><span>index 12140c91e3170..20a76afa03202 100644
</span><span>--- a/crates/bevy_pbr/src/ssr/raymarch.wgsl
</span><span>+++ b/crates/bevy_pbr/src/ssr/raymarch.wgsl
</span><span>@@ -24,11 +24,60 @@
</span><span>     position_world_to_ndc,
</span><span> }
</span><span> 
</span><span>+#ifdef USE_DEPTH_SAMPLERS
</span><span> // Allows us to sample from the depth buffer with bilinear filtering.
</span><span> @group(2) @binding(2) var depth_linear_sampler: sampler;
</span><span> 
</span><span> // Allows us to sample from the depth buffer with nearest-neighbor filtering.
</span><span> @group(2) @binding(3) var depth_nearest_sampler: sampler;
</span><span>+#endif
</span><span>+
</span><span>+// Manual depth fetch helpers used on WebGPU where depth + filtering sampler is invalid.
</span><span>+#ifndef USE_DEPTH_SAMPLERS
</span><span>+fn depth_texel_clamped(texel: vec2&LTi32>) -> f32 {
</span><span>+    let dims = textureDimensions(depth_prepass_texture);
</span><span>+    let max_coord = vec2&LTi32>(i32(dims.x) - 1, i32(dims.y) - 1);
</span><span>+    let clamped = clamp(texel, vec2&LTi32>(0), max_coord);
</span><span>+    return textureLoad(depth_prepass_texture, clamped, 0);
</span><span>+}
</span><span>+
</span><span>+fn depth_sample_nearest_clamped(uv: vec2&LTf32>, tex_size: vec2&LTf32>) -> f32 {
</span><span>+    // Match nearest sampling by snapping to the closest texel center.
</span><span>+    let coord = uv * tex_size - vec2(0.5);
</span><span>+    return depth_texel_clamped(vec2&LTi32>(floor(coord + vec2(0.5))));
</span><span>+}
</span><span>+
</span><span>+fn depth_sample_bilinear_clamped(uv: vec2&LTf32>, tex_size: vec2&LTf32>) -> f32 {
</span><span>+    let coord = uv * tex_size - vec2(0.5);
</span><span>+    let base = vec2&LTi32>(floor(coord));
</span><span>+    let frac = coord - floor(coord);
</span><span>+
</span><span>+    let d00 = depth_texel_clamped(base);
</span><span>+    let d10 = depth_texel_clamped(base + vec2(1, 0));
</span><span>+    let d01 = depth_texel_clamped(base + vec2(0, 1));
</span><span>+    let d11 = depth_texel_clamped(base + vec2(1, 1));
</span><span>+
</span><span>+    let d0 = mix(d00, d10, frac.x);
</span><span>+    let d1 = mix(d01, d11, frac.x);
</span><span>+    return mix(d0, d1, frac.y);
</span><span>+}
</span><span>+#endif
</span><span>+
</span><span>+fn depth_sample_linear(uv: vec2&LTf32>, tex_size: vec2&LTf32>) -> f32 {
</span><span>+#ifdef USE_DEPTH_SAMPLERS
</span><span>+    return textureSampleLevel(depth_prepass_texture, depth_linear_sampler, uv, 0u);
</span><span>+#else
</span><span>+    return depth_sample_bilinear_clamped(uv, tex_size);
</span><span>+#endif
</span><span>+}
</span><span>+
</span><span>+fn depth_sample_nearest(uv: vec2&LTf32>, tex_size: vec2&LTf32>) -> f32 {
</span><span>+#ifdef USE_DEPTH_SAMPLERS
</span><span>+    return textureSampleLevel(depth_prepass_texture, depth_nearest_sampler, uv, 0u);
</span><span>+#else
</span><span>+    return depth_sample_nearest_clamped(uv, tex_size);
</span><span>+#endif
</span><span>+}
</span><span> 
</span><span> // Main code
</span><span> 
</span><span>@@ -241,10 +290,8 @@ fn depth_raymarch_distance_fn_evaluate(
</span><span>     // * The false occlusions due to duplo land are rejected because the ray stays above the smooth surface.
</span><span>     // * The shrink-wrap surface is no longer continuous, so it's possible for rays to miss it.
</span><span> 
</span><span>-    let linear_depth =
</span><span>-        1.0 / textureSampleLevel(depth_prepass_texture, depth_linear_sampler, interp_uv, 0u);
</span><span>-    let unfiltered_depth =
</span><span>-        1.0 / textureSampleLevel(depth_prepass_texture, depth_nearest_sampler, interp_uv, 0u);
</span><span>+    let linear_depth = 1.0 / depth_sample_linear(interp_uv, (*distance_fn).depth_tex_size);
</span><span>+    let unfiltered_depth = 1.0 / depth_sample_nearest(interp_uv, (*distance_fn).depth_tex_size);
</span><span> 
</span><span>     var max_depth: f32;
</span><span>     var min_depth: f32;
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22193.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>