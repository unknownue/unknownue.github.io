<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22033 Solari: More accurate ReSTIR DI resampling
        
    </title><meta content="#22033 Solari: More accurate ReSTIR DI resampling" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-09</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22033-zh-cn-20251209>中文</a></div></div><div class=pr-content><h1 id=title-solari-more-accurate-restir-di-resampling>Title: Solari: More accurate ReSTIR DI resampling</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari: More accurate ReSTIR DI resampling<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22033<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, S-Ready-For-Final-Review, C-Refinement<li><strong>Created</strong>: 2025-12-05T03:16:10Z<li><strong>Merged</strong>: 2025-12-09T18:40:55Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>This PR improves the accuracy of ReSTIR DI (Reservoir-based Spatio-Temporal Importance Resampling for Direct Illumination) in Bevy’s Solari rendering system. The changes focus on two main areas:<ol><li>Adds MIS (Multiple Importance Sampling) during reservoir merge which increases emissive light brightness, bringing it a little closer to the pathtraced reference.<li>Tests final reservoir visibility for shading, but <em>not</em> for resampling, which greatly improves shadow accuracy compared to the pathtraced reference, at the unfortunate cost of higher noise.</ol><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses accuracy issues in the ReSTIR DI implementation for the Solari renderer. The core problem was that the reservoir merging process wasn’t properly accounting for differences in geometry between neighboring pixels, leading to biased results that affected both shadow accuracy and emissive light brightness.<p>The existing implementation was performing reservoir merging using a simplified approach that assumed the same geometric context for all merged samples. In ReSTIR terminology, when merging reservoirs from neighboring pixels (temporal or spatial), the algorithm needs to evaluate how well each sample works in <em>both</em> the current pixel’s context <em>and</em> the neighbor’s context. This is crucial for proper Multiple Importance Sampling (MIS) weights.<p>The author refactored the reservoir merging logic to track geometric information alongside each reservoir. Previously, the <code>merge_reservoirs</code> function only received the reservoirs and a single set of geometric properties (world position, normal, BRDF). The new implementation introduced a <code>NeighborInfo</code> struct that bundles a reservoir with its associated geometric context:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>struct NeighborInfo {
</span><span>    reservoir: Reservoir,
</span><span>    world_position: vec3&LTf32>,
</span><span>    world_normal: vec3&LTf32>,
</span><span>    diffuse_brdf: vec3&LTf32>,
</span><span>}
</span></code></pre><p>This change enables proper MIS calculation during reservoir merging. Instead of evaluating samples only in the current pixel’s context, the algorithm now evaluates each sample in <em>both</em> contexts:<ul><li>Canonical sample evaluated at canonical geometry<li>Canonical sample evaluated at neighbor’s geometry<li>Neighbor’s sample evaluated at canonical geometry<li>Neighbor’s sample evaluated at neighbor’s geometry</ul><p>This symmetrical evaluation allows for correct balance heuristic MIS weights:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Resampling weight for canonical sample
</span><span>let canonical_sample_mis_weight = balance_heuristic(
</span><span>    canonical_reservoir.confidence_weight * canonical_contribution_canonical_sample.target_function,
</span><span>    other_reservoir.confidence_weight * other_contribution_canonical_sample.target_function,
</span><span>);
</span><span>
</span><span>// Resampling weight for other sample
</span><span>let other_sample_mis_weight = balance_heuristic(
</span><span>    other_reservoir.confidence_weight * other_contribution_other_sample.target_function,
</span><span>    canonical_reservoir.confidence_weight * canonical_contribution_other_sample.target_function,
</span><span>);
</span></code></pre><p>The second major change involves visibility testing. Previously, visibility was tested during the resampling process, which introduced bias in shadow boundaries. The new implementation adds a compile-time flag <code>BIASED_RESAMPLING</code> that controls when visibility is tested:<ul><li>With <code>BIASED_RESAMPLING</code> defined (default for stability): Visibility is tested <em>after</em> reservoir merging, which extends shadows beyond their correct boundaries but reduces noise.<li>Without <code>BIASED_RESAMPLING</code> (for accuracy): Visibility is tested only during final shading, producing more accurate shadows at the cost of higher noise.</ul><p>The code structure reflects this trade-off clearly:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// More accuracy, less stability
</span><span>#ifndef BIASED_RESAMPLING
</span><span>    store_reservoir_a(global_id.xy, combined_reservoir);
</span><span>#endif
</span><span>
</span><span>if reservoir_valid(combined_reservoir) {
</span><span>    let resolved_light_sample = resolve_light_sample(combined_reservoir.sample, light_sources[combined_reservoir.sample.light_id >> 16u]);
</span><span>    combined_reservoir.unbiased_contribution_weight *= trace_light_visibility(surface.world_position, resolved_light_sample.world_position);
</span><span>}
</span><span>
</span><span>// More stability, less accuracy (shadows extend further out than they should)
</span><span>#ifdef BIASED_RESAMPLING
</span><span>    store_reservoir_a(global_id.xy, combined_reservoir);
</span><span>#endif
</span></code></pre><p>Several supporting changes were also made:<ul><li>The <code>balance_heuristic</code> function was consolidated in <code>sampling.wgsl</code> and improved to return 0 when the sum is zero, preventing division by zero.<li>World cache query jittering was made optional via <code>NO_JITTER_WORLD_CACHE</code>, giving developers control over this trade-off.<li>The <code>power_heuristic</code> function was refactored to use the improved <code>balance_heuristic</code>.</ul><p>The technical insight here is that ReSTIR’s reservoir merging requires careful consideration of geometric context for proper MIS. Each sample’s contribution depends not just on the light source properties, but also on the surface geometry where it’s being evaluated. By tracking and using this geometric context during merging, the algorithm produces more accurate results, particularly for emissive materials and shadow boundaries.<p>The implementation demonstrates a common pattern in real-time rendering: trading between accuracy and stability. By making the visibility testing behavior configurable, the system allows developers to choose based on their specific needs - accuracy for reference comparisons or stability for real-time applications.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[Initial Reservoir Generation] --> B[Temporal Reservoir Loading]
</span><span>    B --> C[Reservoir Merging with MIS]
</span><span>    C --> D{Spatial Reservoir Loading}
</span><span>    D --> E[Reservoir Merging with MIS]
</span><span>    E --> F{BIASED_RESAMPLING?}
</span><span>    F -->|Yes| G[Store Reservoir]
</span><span>    G --> H[Test Visibility]
</span><span>    H --> I[Final Shading]
</span><span>    F -->|No| J[Test Visibility]
</span><span>    J --> K[Store Reservoir]
</span><span>    K --> I
</span><span>    
</span><span>    L[NeighborInfo Struct] --> C
</span><span>    L --> E
</span><span>    M[balance_heuristic] --> C
</span><span>    M --> E
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-crates-bevy-solari-src-realtime-restir-di-wgsl-76-41>1. <code>crates/bevy_solari/src/realtime/restir_di.wgsl</code> (+76/-41)</h3><p>This is the main file containing the ReSTIR DI implementation. The changes introduce proper MIS during reservoir merging and configurable visibility testing.<p><strong>Key Changes:</strong><ul><li>Added <code>NeighborInfo</code> struct to bundle reservoirs with geometric context<li>Refactored <code>merge_reservoirs</code> to accept two full geometric contexts<li>Added proper MIS calculation using <code>balance_heuristic</code><li>Made visibility testing configurable via <code>BIASED_RESAMPLING</code> flag</ul><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before: Single geometric context for both reservoirs
</span><span>fn merge_reservoirs(
</span><span>    canonical_reservoir: Reservoir,
</span><span>    other_reservoir: Reservoir,
</span><span>    world_position: vec3&LTf32>,
</span><span>    world_normal: vec3&LTf32>,
</span><span>    diffuse_brdf: vec3&LTf32>,
</span><span>    rng: ptr&LTfunction, u32>,
</span><span>) -> ReservoirMergeResult
</span><span>
</span><span>// After: Separate geometric contexts for each reservoir
</span><span>fn merge_reservoirs(
</span><span>    canonical_reservoir: Reservoir,
</span><span>    canonical_world_position: vec3&LTf32>,
</span><span>    canonical_world_normal: vec3&LTf32>,
</span><span>    canonical_diffuse_brdf: vec3&LTf32>,
</span><span>    other_reservoir: Reservoir,
</span><span>    other_world_position: vec3&LTf32>,
</span><span>    other_world_normal: vec3&LTf32>,
</span><span>    other_diffuse_brdf: vec3&LTf32>,
</span><span>    rng: ptr&LTfunction, u32>,
</span><span>) -> ReservoirMergeResult
</span></code></pre><h3 id=2-crates-bevy-solari-src-realtime-world-cache-query-wgsl-8-5>2. <code>crates/bevy_solari/src/realtime/world_cache_query.wgsl</code> (+8/-5)</h3><p>Made world cache jittering optional to provide flexibility in the accuracy/stability trade-off.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Added condition to disable jittering
</span><span>#ifndef NO_JITTER_WORLD_CACHE
</span><span>    let TBN = orthonormalize(world_normal);
</span><span>    let offset = (rand_vec2f(rng) * 2.0 - 1.0) * cell_size * 0.5;
</span><span>    world_position += offset.x * TBN[0] + offset.y * TBN[1];
</span><span>    cell_size = get_cell_size(world_position, view_position);
</span><span>#endif
</span></code></pre><h3 id=3-crates-bevy-solari-src-scene-sampling-wgsl-6-2>3. <code>crates/bevy_solari/src/scene/sampling.wgsl</code> (+6/-2)</h3><p>Improved the <code>balance_heuristic</code> function to handle edge cases and ensure non-negative results.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before: Simple division with potential for division by zero
</span><span>fn balance_heuristic(f: f32, g: f32) -> f32 {
</span><span>    return f / (f + g);
</span><span>}
</span><span>
</span><span>// After: Safe division with zero check and non-negative guarantee
</span><span>fn balance_heuristic(f: f32, g: f32) -> f32 {
</span><span>    let sum = f + g;
</span><span>    if sum == 0.0 {
</span><span>        return 0.0;
</span><span>    }
</span><span>    return max(0.0, f / sum);
</span><span>}
</span></code></pre><h3 id=4-crates-bevy-solari-src-realtime-restir-gi-wgsl-1-9>4. <code>crates/bevy_solari/src/realtime/restir_gi.wgsl</code> (+1/-9)</h3><p>Removed duplicate <code>balance_heuristic</code> implementation now that it’s properly defined in <code>sampling.wgsl</code>.<h3 id=5-crates-bevy-solari-src-realtime-specular-gi-wgsl-1-1>5. <code>crates/bevy_solari/src/realtime/specular_gi.wgsl</code> (+1/-1)</h3><p>Updated to use the improved <code>power_heuristic</code> which now uses the safe <code>balance_heuristic</code>.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Changed from potentially negative result to guaranteed non-negative
</span><span>// Before: return max(0.0, power_heuristic(p_light, p_bounce));
</span><span>// After: return power_heuristic(p_light, p_bounce);
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>ReSTIR Paper</strong>: “Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting” (Bitterli et al., 2020)<li><strong>Multiple Importance Sampling</strong>: Chapter 9.2 of “Physically Based Rendering: From Theory to Implementation”<li><strong>Bevy Solari Documentation</strong>: The Solari renderer’s architecture and design decisions<li><strong>WGSL Specification</strong>: WebGPU Shading Language for understanding the shader code structure<li><strong>Real-Time Rendering</strong>: Chapter 11 on “Global Illumination” for context on ReSTIR’s place in real-time rendering</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22033.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>