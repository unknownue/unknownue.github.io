<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20917 Convert RenderTarget to `Component
        
    </title><meta content="#20917 Convert RenderTarget to `Component" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-15</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-12/pr-20917-en-20251215>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>标题</strong>: Convert RenderTarget to <code>Component</code><li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/20917<li><strong>作者</strong>: tychedelia<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review, M-Migration-Guide<li><strong>创建时间</strong>: 2025-09-07T06:54:01Z<li><strong>合并时间</strong>: 2025-12-14T22:57:12Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p><strong>目标</strong><p>#20830 创建了一种可能性，即我们可能希望拥有能产生多个输出（例如深度和法线）的渲染目标 (render targets)。这是实现类似功能（例如 <code>RendersTo</code> 关系）的第一步，通过将 <code>RenderTarget</code> 转换为一个组件 (component) 来实现。这对于希望在 BSN 落地后执行类似 <code>#[require(RenderTarget::Image)]</code> 操作的树外渲染目标也很有用。<p><strong>解决方案</strong><p>使其成为一个组件。<h2 id=ben-ci-prde-ji-shu-fen-xi>本次PR的技术分析</h2><p>本次PR的核心任务是将 <code>RenderTarget</code> 从一个结构体字段转换为一个独立的 Bevy ECS 组件。这是一项看似简单但影响深远的架构调整，其目的是为渲染系统的未来演进铺平道路。<p><strong>问题与背景</strong><p>在修改之前，<code>RenderTarget</code> 是 <code>Camera</code> 结构体的一个字段，用于定义相机渲染的输出目标，例如一个窗口的交换链或一个 <code>Image</code> 句柄。这种设计存在一个固有的限制：一个 <code>Camera</code> 实体只能关联一个 <code>RenderTarget</code>。然而，随着渲染管线复杂性的增加（例如在PR描述中提到的 #20830），未来可能需要一个相机向多个目标渲染（例如同时输出颜色、深度和法线贴图）。将 <code>RenderTarget</code> 作为 <code>Camera</code> 的一个字段使得这种扩展变得困难，因为它与“一个相机对应一个目标”的假设紧密耦合。<p>此外，将 <code>RenderTarget</code> 作为组件，能够更好地利用 Bevy 的 ECS 系统和即将到来的 BSN (Bevy Scene Node) 特性。例如，外部渲染系统可以通过 <code>#[require(RenderTarget::Image)]</code> 这样的属性来声明其对特定类型渲染目标的依赖，这使得代码更模块化、更易于组合。<p><strong>解决方案与实现</strong><p>解决方案非常直接：将 <code>RenderTarget</code> 枚举添加 <code>#[derive(Component)]</code> 属性，并将其从 <code>Camera</code> 结构体中移除，使其成为一个必须与 <code>Camera</code> 组件一起 spawned 的独立组件。<ol><li><p><strong>核心数据结构变更</strong>: 在 <code>camera.rs</code> 中，<code>Camera</code> 结构体移除了 <code>target: RenderTarget</code> 字段。同时，<code>RenderTarget</code> 枚举现在派生 <code>Component</code> trait。</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 文件: crates/bevy_camera/src/camera.rs
</span><span style=color:#abb0b6;font-style:italic>// 之前: Camera 结构体包含 target 字段
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Camera </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>pub </span><span>target</span><span style=color:#61676ccc>:</span><span> RenderTarget, </span><span style=color:#abb0b6;font-style:italic>// 此行被移除
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后: RenderTarget 成为一个组件
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Reflect</span><span style=color:#61676ccc>,</span><span> From)] </span><span style=color:#abb0b6;font-style:italic>// 添加了 Component
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>reflect</span><span>(Clone)]
</span><span>public </span><span style=color:#fa6e32>enum </span><span style=color:#399ee6>RenderTarget </span><span>{
</span><span>    Window(WindowRef)</span><span style=color:#61676ccc>,
</span><span>    Image(Handle&LTImage>)</span><span style=color:#61676ccc>,
</span><span>    ManualTextureView(ManualTextureViewHandle)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>None </span><span>{ size</span><span style=color:#61676ccc>:</span><span> UVec2 }</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre> <p>这个改动是破坏性的。所有之前通过 <code>camera.target</code> 访问渲染目标的代码都需要更新。</p><li><p><strong>系统查询的更新</strong>: 这是本次重构中工作量最大的部分。所有需要同时知道相机及其渲染目标的系统，其查询 (Query) 都必须修改，以同时获取 <code>Camera</code> 和 <code>RenderTarget</code> 组件。这涉及遍布渲染、UI、拾取 (picking) 等模块的十几个文件。</p> <p>例如，在 <code>bevy_render::camera::camera_system</code> 中，查询从 <code>Query<(&mut Camera, &mut Projection)></code> 变为 <code>Query<(&mut Camera, &RenderTarget, &mut Projection)></code>。在计算相机视口大小时，原本通过 <code>camera.target.normalize(...)</code> 获取标准化目标，现在改为通过 <code>render_target.normalize(...)</code>。</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 文件: crates/bevy_render/src/camera.rs
</span><span style=color:#abb0b6;font-style:italic>// 修改前
</span><span style=color:#fa6e32>for </span><span>(</span><span style=color:#fa6e32>mut</span><span> camera</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> camera_projection) </span><span style=color:#ed9366>in &</span><span style=color:#fa6e32>mut</span><span> cameras {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(normalized_target) </span><span style=color:#ed9366>= &</span><span>camera</span><span style=color:#ed9366>.</span><span>target</span><span style=color:#ed9366>.</span><span style=color:#f07171>normalize</span><span>(primary_window) { </span><span style=color:#abb0b6;font-style:italic>/* ... */ </span><span>}
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后
</span><span style=color:#fa6e32>for </span><span>(</span><span style=color:#fa6e32>mut</span><span> camera</span><span style=color:#61676ccc>,</span><span> render_target</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> camera_projection) </span><span style=color:#ed9366>in &</span><span style=color:#fa6e32>mut</span><span> cameras {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(normalized_target) </span><span style=color:#ed9366>=</span><span> render_target</span><span style=color:#ed9366>.</span><span style=color:#f07171>normalize</span><span>(primary_window) { </span><span style=color:#abb0b6;font-style:italic>/* ... */ </span><span>}
</span><span>}
</span></code></pre> <p>类似地，在 <code>bevy_picking::backend::ray</code> 模块中，构建光线 (ray) 的 <code>make_ray</code> 函数现在需要接收 <code>&RenderTarget</code> 作为额外参数，用于判断指针位置是否在相机的视口内。</p><li><p><strong>示例代码迁移</strong>: 所有使用自定义 <code>RenderTarget</code> 的官方示例都得到了更新，以展示新的 API 用法。新的模式是：在生成 (spawn) 相机实体时，将 <code>RenderTarget</code> 作为一个独立的组件添加，而不是设置 <code>Camera</code> 结构体的字段。</p> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 文件: examples/3d/render_to_texture.rs (修改后)
</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>    Camera3d</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>,
</span><span>    Camera {
</span><span>        order</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// target: image_handle.clone().into(), // 旧方式，已移除
</span><span>        clear_color</span><span style=color:#61676ccc>: </span><span>Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>WHITE</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    RenderTarget</span><span style=color:#ed9366>::</span><span>Image(image_handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#61676ccc>, </span><span style=color:#abb0b6;font-style:italic>// 新方式：作为独立组件
</span><span>    Transform</span><span style=color:#ed9366>::</span><span>from_translation(Vec3</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>15.0</span><span>))</span><span style=color:#ed9366>.</span><span style=color:#f07171>looking_at</span><span>(Vec3</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ZERO</span><span style=color:#61676ccc>, </span><span>Vec3</span><span style=color:#ed9366>::</span><span>Y)</span><span style=color:#61676ccc>,
</span><span>    first_pass_layer</span><span style=color:#61676ccc>,
</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><li><p><strong>提供迁移指南</strong>: PR 创建了一个新的迁移指南文件 <code>render_target_component.md</code>，清晰地对比了修改前后的代码，帮助开发者平滑过渡。</p></ol><p><strong>技术见解与影响</strong><ul><li><strong>架构解耦与灵活性提升</strong>：将 <code>RenderTarget</code> 变为组件，使其与 <code>Camera</code> 解耦。这为未来实现一个相机对应多个渲染目标（例如通过 <code>RendersTo</code> 关系组件）扫清了架构障碍。它也符合 ECS 的“数据即组件”哲学，使渲染目标可以独立地被查询和操作。<li><strong>为未来特性奠基</strong>：正如 PR 描述所述，这是实现更复杂渲染管线（如多目标渲染）的“第一步”。同时，它也为 BSN 等未来特性中声明式地要求特定类型的渲染目标做好了准备。<li><strong>API 清晰度</strong>：新的 API 在实体组合上更加清晰。<code>RenderTarget</code> 现在与 <code>Camera3d</code>、<code>Camera2d</code> 等标记组件一样，是一个显式的、必需的组件，这使得实体的配置意图更明确。<li><strong>破坏性变更与更新成本</strong>：这是一个破坏性变更，影响了大量内部系统和所有相关示例。然而，这种成本是为实现更长远架构目标所必须付出的。迁移指南的提供降低了用户端的升级成本。</ul><p><strong>总结</strong><p>本次 PR 实施了一次精心策划的架构重构。它没有增加新功能，而是通过将 <code>RenderTarget</code> 从 <code>Camera</code> 的字段提升为独立的 ECS 组件，为渲染系统的未来扩展奠定了更坚实的基础。这次改动体现了良好的软件设计原则：通过解耦来增强灵活性和可维护性，即使这意味着在短期内需要对多个子系统进行适配。对于 Bevy 用户来说，需要按照迁移指南更新代码；对于 Bevy 开发者而言，这是一个迈向更强大、更灵活渲染管线的清晰信号。<h2 id=visual-representation>Visual Representation</h2><p>以下 Mermaid 图展示了本次 PR 修改的核心关系变化：<code>RenderTarget</code> 从 <code>Camera</code> 的内部字段，转变为与 <code>Camera</code> 并列、共同附加于同一实体的独立组件。<pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    subgraph "修改前"
</span><span>        A1[Camera 实体] --> B1[Camera 组件]
</span><span>        B1 --> C1[包含 target: RenderTarget 字段]
</span><span>    end
</span><span>
</span><span>    subgraph "修改后"
</span><span>        A2[Camera 实体] --> B2[Camera 组件]
</span><span>        A2 --> C2[RenderTarget 组件]
</span><span>        B2 -.->|不再包含 target 字段| C2
</span><span>    end
</span><span>
</span><span>    修改前 -->|重构| 修改后
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><p>本次PR中最重要的文件变更如下：<ol><li><p><strong><code>crates/bevy_camera/src/camera.rs</code> (+27/-21)</strong></p> <ul><li><strong>修改内容与原因</strong>：这是本次重构的核心。移除了 <code>Camera</code> 结构体中的 <code>target: RenderTarget</code> 字段，并为 <code>RenderTarget</code> 枚举添加了 <code>#[derive(Component)]</code>。这是所有其他变更的源头。<li><strong>关键代码片段</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改后 Camera 结构体定义（移除了 target 字段）
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Camera </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// pub target: RenderTarget, // 此字段已被移除
</span><span>    </span><span style=color:#fa6e32>pub </span><span>output_mode</span><span style=color:#61676ccc>:</span><span> CameraOutputMode,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后 RenderTarget 枚举定义（添加了 Component）
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Component</span><span style=color:#61676ccc>,</span><span> Debug</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Reflect</span><span style=color:#61676ccc>,</span><span> From)] </span><span style=color:#abb0b6;font-style:italic>// 注意新增的 Component
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>reflect</span><span>(Clone)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>RenderTarget </span><span>{
</span><span>    Window(WindowRef)</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... 其他变体
</span><span>}
</span></code></pre></ul><li><p><strong><code>crates/bevy_render/src/camera.rs</code> (+27/-21)</strong></p> <ul><li><strong>修改内容与原因</strong>：更新了主要的相机系统 (<code>camera_system</code>) 和相机数据提取系统 (<code>extract_cameras</code>)，使其查询同时包含 <code>Camera</code> 和 <code>RenderTarget</code> 组件，以适配新的数据布局。<li><strong>关键代码片段</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 在 camera_system 中，查询签名变更
</span><span style=color:#abb0b6;font-style:italic>// 之前: mut cameras: Query<(&mut Camera, &mut Projection)>
</span><span style=color:#abb0b6;font-style:italic>// 之后: mut cameras: Query<(&mut Camera, &RenderTarget, &mut Projection)>
</span><span style=color:#fa6e32>for </span><span>(</span><span style=color:#fa6e32>mut</span><span> camera</span><span style=color:#61676ccc>,</span><span> render_target</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut</span><span> camera_projection) </span><span style=color:#ed9366>in &</span><span style=color:#fa6e32>mut</span><span> cameras {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 使用 render_target 而非 camera.target
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(normalized_target) </span><span style=color:#ed9366>=</span><span> render_target</span><span style=color:#ed9366>.</span><span style=color:#f07171>normalize</span><span>(primary_window) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在 extract_cameras 中，查询也增加了 &RenderTarget
</span><span style=color:#fa6e32>let mut</span><span> cameras</span><span style=color:#61676ccc>: </span><span>Query<(
</span><span>    Entity,
</span><span>    RenderEntity,
</span><span>    </span><span style=color:#ed9366>&</span><span>Camera,
</span><span>    </span><span style=color:#ed9366>&</span><span>RenderTarget, // 新增
</span><span>    </span><span style=color:#ed9366>&</span><span>CameraRenderGraph,
</span><span>    // ...
</span><span>)>
</span></code></pre></ul><li><p><strong><code>release-content/migration-guides/render_target_component.md</code> (+25/-0)</strong></p> <ul><li><strong>修改内容与原因</strong>：这是一个新增的迁移指南文件，对于用户升级至关重要。它用简洁的代码对比说明了如何从旧的 API 迁移到新的 API。<li><strong>关键代码片段</strong>:<pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span>// before
</span><span>commands.spawn((
</span><span>    Camera3d::default(),
</span><span>    Camera {
</span><span>        target: RenderTarget::Image(image_handle.into()),
</span><span>        ..default()
</span><span>    },
</span><span>));
</span><span>
</span><span>// after
</span><span>commands.spawn((
</span><span>    Camera3d::default(),
</span><span>    RenderTarget::Image(image_handle.into()), // 作为独立组件添加
</span><span>));
</span></code></pre></ul><li><p><strong><code>crates/bevy_ui/src/picking_backend.rs</code> (+13/-10) 与 <code>crates/bevy_picking/src/backend.rs</code> (+12/-7)</strong></p> <ul><li><strong>修改内容与原因</strong>：UI 和 3D 拾取系统都需要知道指针位于哪个相机的渲染目标内。这些文件更新了相应的查询，以访问独立的 <code>RenderTarget</code> 组件。<li><strong>关键代码片段</strong> (<code>bevy_picking/src/backend.rs</code>):<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 在 ray::make_ray 函数签名中增加了 render_target 参数
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>make_ray</span><span>(
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#ff8f40>camera</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Camera,
</span><span>    </span><span style=color:#ff8f40>render_target</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>RenderTarget, </span><span style=color:#abb0b6;font-style:italic>// 新增参数
</span><span>    </span><span style=color:#ff8f40>camera_tfm</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>GlobalTransform,
</span><span>    </span><span style=color:#ff8f40>pointer_loc</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>PointerLocation,
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTRay3d> {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 判断逻辑改用 render_target
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>pointer_loc</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_in_viewport</span><span>(camera</span><span style=color:#61676ccc>,</span><span> render_target</span><span style=color:#61676ccc>,</span><span> primary_window_entity) {
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>}
</span></code></pre></ul><li><p><strong>多个示例文件 (总计10个)</strong></p> <ul><li><strong>修改内容与原因</strong>：更新了所有使用自定义 <code>RenderTarget</code> 的示例，以演示新的、正确的 API 用法。这是确保文档和用户学习材料保持最新的关键步骤。<li><strong>关键代码片段</strong> (<code>examples/3d/render_to_texture.rs</code>):<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改后，RenderTarget 作为独立组件
</span><span>commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>    Camera3d</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>,
</span><span>    Camera {
</span><span>        order</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 注意：不再设置 camera.target
</span><span>        </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>    }</span><span style=color:#61676ccc>,
</span><span>    RenderTarget</span><span style=color:#ed9366>::</span><span>Image(image_handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#61676ccc>, </span><span style=color:#abb0b6;font-style:italic>// 在这里
</span><span>    Transform</span><span style=color:#ed9366>::</span><span>from_xyz(</span><span style=color:#ed9366>...</span><span>)</span><span style=color:#61676ccc>,
</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre></ul></ol><h2 id=further-reading>Further Reading</h2><ul><li><strong>Bevy ECS 官方文档</strong>：理解组件 (Component)、查询 (Query) 和实体 (Entity) 是如何在 Bevy 中工作的基础。 <ul><li>链接: https://bevyengine.org/learn/quick-start/ecs/</ul><li><strong>RFC #20830</strong>: 本次 PR 提及的、启发此改动的原始讨论。了解其背景有助于理解本次重构的长期目标。 <ul><li>(需要在 Bevy 仓库中查找相关 Issue/PR 链接)</ul><li><strong>《数据导向设计》相关文章</strong>: 本次重构符合数据导向设计的原则，即将关联的数据（相机和其目标）解耦为可以独立组合的单元。<li><strong>Bevy 迁移指南 (Migration Guides)</strong>: 了解如何处理 Bevy 版本升级中的破坏性变更。 <ul><li>链接: https://bevyengine.org/learn/migration-guides/</ul></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_20917.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>