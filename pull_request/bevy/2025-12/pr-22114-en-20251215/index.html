<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22114 Refactor GltfExtensionHandler Hooks
        
    </title><meta content="#22114 Refactor GltfExtensionHandler Hooks" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-15</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22114-zh-cn-20251215>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Refactor GltfExtensionHandler Hooks<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22114<li><strong>Author</strong>: ChristopherBiscardi<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Assets, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-12-15T01:54:41Z<li><strong>Merged</strong>: 2025-12-15T02:42:42Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>As it turns out, many glTF extensions require accessing the data from other extensions.<p>Trying to isolate and scope access is much less helpful than exposing the glTF objects for consumers to take what they want.<p>This includes<ul><li>extension data in the “others” category (anything the gltf crate doesn’t support explicitly)<li>the functions that return the extension data the gltf crate <em>does</em> have hardcoded support for<li>names and any other available data</ul><hr><p>The diff for users is that they<ul><li>no longer have to worry about defining extension ids to process<li>no longer have to worry about multiple calls due to those ids<li>now have to use <code>.extension_value()</code>, <code>.name()</code>, or similar to get relevant data<li>Can now access <code>.light()</code> or any other data built-in to the gltf crate, such as <a rel="noopener nofollow noreferrer" href=https://docs.rs/gltf/1.4.1/gltf/struct.Document.html#method.variants target=_blank><code>.variants</code></a> for <code>KHR_materials_variants</code>.</ul><p>An example diff on the user side can be viewed in the update commit for the Skein PR: https://github.com/rust-adventure/skein/pull/89/changes/ac1e510c9d136d60c23decd68b10f35f6e24f76b<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The problem that motivated this PR was a structural limitation in Bevy’s glTF extension system. The existing <code>GltfExtensionHandler</code> trait required extension handlers to declare which extension IDs they wanted to process, and the system would then call the handler’s hooks once for each declared extension ID. This approach created several issues in practice.<p>First, it made extension handling more complex than necessary. Developers had to implement logic to filter and process data based on extension IDs, even though many extensions naturally need to access data from other extensions. The isolation model didn’t match real-world glTF usage patterns where extensions often build upon or reference each other.<p>Second, the API was verbose and error-prone. Extension handlers received data piecemeal through multiple parameters: an extension ID string, an optional JSON value containing that specific extension’s data, and sometimes additional context like names or handles. This required developers to reconstruct the full context from disparate pieces.<p>The solution refactored the extension system to provide direct access to the underlying glTF objects. Instead of receiving filtered extension data, handlers now receive the complete glTF objects (like <code>gltf::Animation</code>, <code>gltf::Material</code>, etc.) and can extract whatever data they need using the gltf crate’s native methods.<p>This approach has several technical advantages. It eliminates the need for extension IDs entirely, since handlers can inspect any extension data present on the object. It reduces the number of method calls from N (where N is the number of extension IDs) to one per object. Most importantly, it gives extension handlers full access to all the data they might need, including built-in glTF crate methods like <code>.light()</code>, <code>.name()</code>, and <code>.variants()</code>.<p>The implementation required changing both the trait definition and all the call sites in the loader. The trait methods were simplified to remove the <code>extension_id</code> and <code>extension_data</code> parameters, and instead receive the glTF object directly. For example, <code>on_animation</code> changed from:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>extension_id</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>,
</span><span>    </span><span style=color:#ff8f40>extension_data</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>serde_json</span><span style=color:#ed9366>::</span><span>Value>,
</span><span>    </span><span style=color:#ff8f40>gltf_animation</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Animation,
</span><span>    </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>>,
</span><span>    </span><span style=color:#ff8f40>handle</span><span style=color:#61676ccc>: </span><span>Handle&LTAnimationClip>,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Old implementation
</span><span>}
</span></code></pre><p>To:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>gltf_animation</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Animation, </span><span style=color:#ff8f40>handle</span><span style=color:#61676ccc>: </span><span>Handle&LTAnimationClip>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// New implementation
</span><span>}
</span></code></pre><p>This change meant extension handlers now need to use methods on the glTF objects to access data. To get extension data, they can call <code>gltf_animation.extension_value("extension_name")</code>. To get the animation name, they can call <code>gltf_animation.name()</code>. This is more consistent with the underlying gltf crate’s API.<p>The loader implementation was updated to match. Instead of iterating over extension IDs and calling handlers for each ID, it now calls each handler once per glTF object. This simplified the loader code significantly, removing nested loops and reducing code duplication.<p>One special case was the <code>on_texture</code> hook. Due to internal constraints in how textures are loaded, this hook doesn’t receive the glTF texture object directly. Instead, it receives the extensions map as an <code>Option<&serde_json::Map&LTString, serde_json::Value>></code>. This is still an improvement over the old API because it provides access to all extensions at once.<p>The impact of these changes is significant for extension developers. They no longer need to manage extension IDs or handle multiple calls for the same object. The API is more intuitive because it mirrors the gltf crate’s API directly. Extension handlers can now easily access data from multiple extensions, which is essential for many real-world glTF files where extensions interact.<p>The example in <code>gltf_extension_animation_graph.rs</code> shows how the changes affect user code. Instead of receiving separate <code>name</code> and <code>extension_id</code> parameters, the handler now gets the glTF animation object and extracts the name using <code>.name()</code>. This makes the code cleaner and more focused on the actual data processing.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[GltfLoader] --> B[Process glTF object]
</span><span>    B --> C[Call extension handlers]
</span><span>    C --> D{Old API}
</span><span>    D --> E[Loop through extension IDs]
</span><span>    E --> F[Call handler with filtered data]
</span><span>    C --> G{New API}
</span><span>    G --> H[Call handler once]
</span><span>    H --> I[Handler accesses full glTF object]
</span><span>    I --> J[.extension_value()]
</span><span>    I --> K[.name()]
</span><span>    I --> L[.light()]
</span><span>    I --> M[Other gltf crate methods]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-gltf-src-loader-extensions-mod-rs-15-59><code>crates/bevy_gltf/src/loader/extensions/mod.rs</code> (+15/-59)</h3><p>This file contains the <code>GltfExtensionHandler</code> trait definition. The changes simplify the trait by removing the <code>extension_ids</code> method and modifying all hook methods to receive glTF objects instead of filtered extension data.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>extension_id</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>,
</span><span>    </span><span style=color:#ff8f40>extension_data</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>serde_json</span><span style=color:#ed9366>::</span><span>Value>,
</span><span>    </span><span style=color:#ff8f40>gltf_animation</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Animation,
</span><span>    </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>>,
</span><span>    </span><span style=color:#ff8f40>handle</span><span style=color:#61676ccc>: </span><span>Handle&LTAnimationClip>,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Implementation
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>gltf_animation</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Animation, </span><span style=color:#ff8f40>handle</span><span style=color:#61676ccc>: </span><span>Handle&LTAnimationClip>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Implementation now uses gltf_animation.name() and gltf_animation.extension_value()
</span><span>}
</span></code></pre><h3 id=crates-bevy-gltf-src-loader-mod-rs-22-88><code>crates/bevy_gltf/src/loader/mod.rs</code> (+22/-88)</h3><p>This file contains the glTF loader implementation. The changes update all extension handler calls to pass glTF objects instead of iterating through extension IDs and passing filtered data.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>    </span><span style=color:#fa6e32>for</span><span> id </span><span style=color:#ed9366>in</span><span> extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>extension_ids</span><span>() {
</span><span>        extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_animation</span><span>(
</span><span>            id</span><span style=color:#61676ccc>,
</span><span>            animation</span><span style=color:#ed9366>.</span><span style=color:#f07171>extension_value</span><span>(id)</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>&</span><span>animation</span><span style=color:#61676ccc>,
</span><span>            animation</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#61676ccc>,
</span><span>            handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>,
</span><span>        )</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>    extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_animation</span><span>(</span><span style=color:#ed9366>&</span><span>animation</span><span style=color:#61676ccc>,</span><span> handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=examples-gltf-gltf-extension-animation-graph-rs-3-15><code>examples/gltf/gltf_extension_animation_graph.rs</code> (+3/-15)</h3><p>This example was updated to demonstrate the new API. The handler now extracts data directly from the glTF objects instead of receiving it as separate parameters.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: examples/gltf/gltf_extension_animation_graph.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>_extension_id</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>,
</span><span>    </span><span style=color:#ff8f40>_value</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>serde_json</span><span style=color:#ed9366>::</span><span>Value>,
</span><span>    </span><span style=color:#ff8f40>_gltf_animation</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Animation,
</span><span>    </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>>,
</span><span>    </span><span style=color:#ff8f40>handle</span><span style=color:#61676ccc>: </span><span>Handle&LTAnimationClip>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> name</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some_and</span><span>(|</span><span style=color:#ff8f40>v</span><span>| v </span><span style=color:#ed9366>== </span><span style=color:#86b300>"Walk"</span><span>) {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>clip </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>gltf_animation</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Animation, </span><span style=color:#ff8f40>handle</span><span style=color:#61676ccc>: </span><span>Handle&LTAnimationClip>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> gltf_animation</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some_and</span><span>(|</span><span style=color:#ff8f40>v</span><span>| v </span><span style=color:#ed9366>== </span><span style=color:#86b300>"Walk"</span><span>) {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>clip </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/main/extensions target=_blank>glTF Extension Specification</a> - Official glTF extension documentation<li><a rel="noopener nofollow noreferrer" href=https://docs.rs/gltf/1.4.1/gltf/ target=_blank>gltf crate documentation</a> - Rust glTF crate API reference<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/assets/gltf/ target=_blank>Bevy glTF Loading</a> - Bevy’s glTF loading documentation<li><a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_variants target=_blank>KHR_materials_variants extension</a> - Example of a complex glTF extension</ul><h2 id=full-code-diff>Full Code Diff</h2><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_gltf/src/loader/extensions/mod.rs b/crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span>index 32ec5ce6a7fb5..133420881a9cf 100644
</span><span style=color:#c594c5>--- a/crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_gltf/src/loader/extensions/mod.rs
</span><span style=color:#c594c5>@@ -47,46 +47,26 @@ </span><span style=color:#399ee6>pub struct GltfExtensionHandlers(pub Arc&LTRwLock&LTVec&LTBox&LTdyn GltfExtensionHandler
</span><span> /// The type a `GltfExtensionHandler` is implemented for can define data
</span><span> /// which will be cloned for each new glTF load. This enables stateful
</span><span> /// handling of glTF extension data during a single load.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// When loading a glTF file, a glTF object that could contain extension
</span><span style=color:#86b300>+/// data will cause the relevant hook to execute once per object.
</span><span style=color:#86b300>+/// Each invocation will receive all extension data, which is required because
</span><span style=color:#86b300>+/// many extensions require accessing data defined by other extensions.
</span><span style=color:#86b300>+///
</span><span style=color:#86b300>+/// The hooks are always called once, even if there is no extension data
</span><span style=color:#86b300>+/// This is useful for scenarios where additional extension data isn't
</span><span style=color:#86b300>+/// required, but processing should still happen.
</span><span> pub trait GltfExtensionHandler: Send + Sync {
</span><span>     /// Required for dyn cloning
</span><span>     fn dyn_clone(&self) -> Box&LTdyn GltfExtensionHandler>;
</span><span> 
</span><span style=color:#f07171>-    /// When loading a glTF file, a glTF object that could contain extension
</span><span style=color:#f07171>-    /// data will cause the relevant hook to execute once for each id in this list.
</span><span style=color:#f07171>-    /// Each invocation will receive the extension data for one of the extension ids,
</span><span style=color:#f07171>-    /// along with the `extension_id` itself so implementors can differentiate
</span><span style=color:#f07171>-    /// between different calls and parse data correctly.
</span><span style=color:#f07171>-    ///
</span><span style=color:#f07171>-    /// The hooks are always called, even if there is no extension data
</span><span style=color:#f07171>-    /// for a specified id. This is useful for scenarios where additional
</span><span style=color:#f07171>-    /// extension data isn't required, but processing should still happen.
</span><span style=color:#f07171>-    ///
</span><span style=color:#f07171>-    /// Most implementors will pick one extension for this list, causing the
</span><span style=color:#f07171>-    /// relevant hooks to fire once per object. An implementor that does not
</span><span style=color:#f07171>-    /// wish to receive any data but still wants hooks to be called can use
</span><span style=color:#f07171>-    /// an empty string `""` as the extension id, which is also the default
</span><span style=color:#f07171>-    /// value if the function is not implemented by an implementor. If the
</span><span style=color:#f07171>-    /// empty string is used, all extension data in hooks will be `None`.
</span><span style=color:#f07171>-    ///
</span><span style=color:#f07171>-    /// Some implementors will choose to list multiple extensions here.
</span><span style=color:#f07171>-    /// This is an advanced use case and the alternative of having multiple
</span><span style=color:#f07171>-    /// independent handlers should be considered as an option first.
</span><span style=color:#f07171>-    /// If multiple extension ids are listed here, the hooks will fire once
</span><span style=color:#f07171>-    /// for each extension id, and each successive call will receive the data for
</span><span style=color:#f07171>-    /// a separate extension. The extension id is also included in hook arguments
</span><span style=color:#f07171>-    /// for this reason, so multiple extension id implementors can differentiate
</span><span style=color:#f07171>-    /// between the data received.
</span><span style=color:#f07171>-    fn extension_ids(&self) -> &'static [&'static str] {
</span><span style=color:#f07171>-        &[""]
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-
</span><span>     /// Called when the "global" data for an extension
</span><span>     /// at the root of a glTF file is encountered.
</span><span>     #[expect(
</span><span>         unused,
</span><span>         reason = "default trait implementations do not use the arguments because they are no-ops"
</span><span>     )]
</span><span style=color:#f07171>-    fn on_root_data(&mut self, extension_id: &str, value: Option<&serde_json::Value>) {}
</span><span style=color:#86b300>+    fn on_root(&mut self, gltf: &gltf::Gltf) {}
</span><span> 
</span><span>     #[cfg(feature = "bevy_animation")]
</span><span>     #[expect(
</span><span style=color:#c594c5>@@ -94,15 +74,7 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>         reason = "default trait implementations do not use the arguments because they are no-ops"
</span><span>     )]
</span><span>     /// Called when an individual animation is processed
</span><span style=color:#f07171>-    fn on_animation(
</span><span style=color:#f07171>-        &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span style=color:#f07171>-        gltf_animation: &gltf::Animation,
</span><span style=color:#f07171>-        name: Option<&str>,
</span><span style=color:#f07171>-        handle: Handle&LTAnimationClip>,
</span><span style=color:#f07171>-    ) {
</span><span style=color:#f07171>-    }
</span><span style=color:#86b300>+    fn on_animation(&mut self, gltf_animation: &gltf::Animation, handle: Handle&LTAnimationClip>) {}
</span><span> 
</span><span>     #[cfg(feature = "bevy_animation")]
</span><span>     #[expect(
</span><span style=color:#c594c5>@@ -123,14 +95,15 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     }
</span><span> 
</span><span>     /// Called when an individual texture is processed
</span><span style=color:#86b300>+    /// Unlike other hooks, this hook does not receive its glTF
</span><span style=color:#86b300>+    /// object due to internal constraints.
</span><span>     #[expect(
</span><span>         unused,
</span><span>         reason = "default trait implementations do not use the arguments because they are no-ops"
</span><span>     )]
</span><span>     fn on_texture(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span style=color:#86b300>+        extension_data: Option<&serde_json::Map&LTString, serde_json::Value>>,
</span><span>         texture: Handle&LTbevy_image::Image>,
</span><span>     ) {
</span><span>     }
</span><span style=color:#c594c5>@@ -142,11 +115,8 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     )]
</span><span>     fn on_material(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span>         load_context: &mut LoadContext<'_>,
</span><span>         gltf_material: &gltf::Material,
</span><span style=color:#f07171>-        name: Option<&str>,
</span><span>         material: Handle&LTStandardMaterial>,
</span><span>     ) {
</span><span>     }
</span><span style=color:#c594c5>@@ -158,11 +128,8 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     )]
</span><span>     fn on_gltf_mesh(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span>         load_context: &mut LoadContext<'_>,
</span><span>         gltf_mesh: &gltf::Mesh,
</span><span style=color:#f07171>-        name: Option<&str>,
</span><span>         mesh: Handle&LTGltfMesh>,
</span><span>     ) {
</span><span>     }
</span><span style=color:#c594c5>@@ -191,13 +158,10 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     )]
</span><span>     fn on_scene_completed(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span style=color:#86b300>+        load_context: &mut LoadContext<'_>,
</span><span>         scene: &gltf::Scene,
</span><span style=color:#f07171>-        name: Option<&str>,
</span><span>         world_root_id: Entity,
</span><span>         scene_world: &mut World,
</span><span style=color:#f07171>-        load_context: &mut LoadContext<'_>,
</span><span>     ) {
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -208,8 +172,6 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     )]
</span><span>     fn on_gltf_node(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span>         load_context: &mut LoadContext<'_>,
</span><span>         gltf_node: &Node,
</span><span>         entity: &mut EntityWorldMut,
</span><span style=color:#c594c5>@@ -225,8 +187,6 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     )]
</span><span>     fn on_spawn_light_directional(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span>         load_context: &mut LoadContext<'_>,
</span><span>         gltf_node: &Node,
</span><span>         entity: &mut EntityWorldMut,
</span><span style=color:#c594c5>@@ -241,8 +201,6 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     )]
</span><span>     fn on_spawn_light_point(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span>         load_context: &mut LoadContext<'_>,
</span><span>         gltf_node: &Node,
</span><span>         entity: &mut EntityWorldMut,
</span><span style=color:#c594c5>@@ -257,8 +215,6 @@ </span><span style=color:#399ee6>pub trait GltfExtensionHandler: Send + Sync {
</span><span>     )]
</span><span>     fn on_spawn_light_spot(
</span><span>         &mut self,
</span><span style=color:#f07171>-        extension_id: &str,
</span><span style=color:#f07171>-        extension_data: Option<&serde_json::Value>,
</span><span>         load_context: &mut LoadContext<'_>,
</span><span>         gltf_node: &Node,
</span><span>         entity: &mut EntityWorldMut,
</span><span>diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
</span><span>index 1c5bbd94e74c1..e4ecf35f814d4 100644
</span><span style=color:#c594c5>--- a/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_gltf/src/loader/mod.rs
</span><span style=color:#c594c5>@@ -258,9 +258,7 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>         // Let extensions process the root data for the extension ids
</span><span>         // they've subscribed to.
</span><span>         for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-            for id in extension.extension_ids() {
</span><span style=color:#f07171>-                extension.on_root_data(id, gltf.extension_value(id));
</span><span style=color:#f07171>-            }
</span><span style=color:#86b300>+            extension.on_root(&gltf);
</span><span>         }
</span><span> 
</span><span>         let file_name = load_context
</span><span style=color:#c594c5>@@ -597,15 +595,7 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span> 
</span><span>                 // let extensions handle extension data placed on animations
</span><span>                 for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                    for id in extension.extension_ids() {
</span><span style=color:#f07171>-                        extension.on_animation(
</span><span style=color:#f07171>-                            id,
</span><span style=color:#f07171>-                            animation.extension_value(id),
</span><span style=color:#f07171>-                            &animation,
</span><span style=color:#f07171>-                            animation.name(),
</span><span style=color:#f07171>-                            handle.clone(),
</span><span style=color:#f07171>-                        );
</span><span style=color:#f07171>-                    }
</span><span style=color:#86b300>+                    extension.on_animation(&animation, handle.clone());
</span><span>                 }
</span><span> 
</span><span>                 animations.push(handle);
</span><span style=color:#c594c5>@@ -654,13 +644,10 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>                 image.process_loaded_texture(load_context, &mut texture_handles);
</span><span>                 // let extensions handle texture data
</span><span>                 for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                    for id in extension.extension_ids() {
</span><span style=color:#f07171>-                        extension.on_texture(
</span><span style=color:#f07171>-                            id,
</span><span style=color:#f07171>-                            texture.extension_value(id),
</span><span style=color:#f07171>-                            texture_handles.iter().last().unwrap().clone(),
</span><span style=color:#f07171>-                        );
</span><span style=color:#f07171>-                    }
</span><span style=color:#86b300>+                    extension.on_texture(
</span><span style=color:#86b300>+                        texture.extensions(),
</span><span style=color:#86b300>+                        texture_handles.iter().last().unwrap().clone(),
</span><span style=color:#86b300>+                    );
</span><span>                 }
</span><span>             }
</span><span>         } else {
</span><span style=color:#c594c5>@@ -695,13 +682,10 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>                         // We do this differently here because of the IoTaskPool vs
</span><span>                         // gltf::Texture lifetimes
</span><span>                         for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                            for id in extension.extension_ids() {
</span><span style=color:#f07171>-                                extension.on_texture(
</span><span style=color:#f07171>-                                    id,
</span><span style=color:#f07171>-                                    extension_data.as_ref().and_then(|map| map.get(*id)),
</span><span style=color:#f07171>-                                    texture_handles.iter().last().unwrap().clone(),
</span><span style=color:#f07171>-                                );
</span><span style=color:#f07171>-                            }
</span><span style=color:#86b300>+                            extension.on_texture(
</span><span style=color:#86b300>+                                extension_data.as_ref(),
</span><span style=color:#86b300>+                                texture_handles.iter().last().unwrap().clone(),
</span><span style=color:#86b300>+                            );
</span><span>                         }
</span><span>                     }
</span><span>                     Err(err) => {
</span><span style=color:#c594c5>@@ -723,16 +707,7 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span> 
</span><span>                 // let extensions handle material data
</span><span>                 for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                    for id in extension.extension_ids() {
</span><span style=color:#f07171>-                        extension.on_material(
</span><span style=color:#f07171>-                            id,
</span><span style=color:#f07171>-                            material.extension_value(id),
</span><span style=color:#f07171>-                            load_context,
</span><span style=color:#f07171>-                            &material,
</span><span style=color:#f07171>-                            material.name(),
</span><span style=color:#f07171>-                            handle.clone(),
</span><span style=color:#f07171>-                        );
</span><span style=color:#f07171>-                    }
</span><span style=color:#86b300>+                    extension.on_material(load_context, &material, handle.clone());
</span><span>                 }
</span><span> 
</span><span>                 materials.push(handle);
</span><span style=color:#c594c5>@@ -899,16 +874,7 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span>                 named_meshes.insert(name.into(), handle.clone());
</span><span>             }
</span><span>             for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                for id in extension.extension_ids() {
</span><span style=color:#f07171>-                    extension.on_gltf_mesh(
</span><span style=color:#f07171>-                        id,
</span><span style=color:#f07171>-                        gltf_mesh.extension_value(id),
</span><span style=color:#f07171>-                        load_context,
</span><span style=color:#f07171>-                        &gltf_mesh,
</span><span style=color:#f07171>-                        gltf_mesh.name(),
</span><span style=color:#f07171>-                        handle.clone(),
</span><span style=color:#f07171>-                    );
</span><span style=color:#f07171>-                }
</span><span style=color:#86b300>+                extension.on_gltf_mesh(load_context, &gltf_mesh, handle.clone());
</span><span>             }
</span><span> 
</span><span>             meshes.push(handle);
</span><span style=color:#c594c5>@@ -1114,17 +1080,12 @@ </span><span style=color:#399ee6>impl GltfLoader {
</span><span> 
</span><span>             // let extensions handle scene extension data
</span><span>             for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                for id in extension.extension_ids() {
</span><span style=color:#f07171>-                    extension.on_scene_completed(
</span><span style=color:#f07171>-                        id,
</span><span style=color:#f07171>-                        scene.extension_value(id),
</span><span style=color:#f07171>-                        &scene,
</span><span style=color:#f07171>-                        scene.name(),
</span><span style=color:#f07171>-                        world_root_id,
</span><span style=color:#f07171>-                        &mut world,
</span><span style=color:#f07171>-                        &mut scene_load_context,
</span><span style=color:#f07171>-                    );
</span><span style=color:#f07171>-                }
</span><span style=color:#86b300>+                extension.on_scene_completed(
</span><span style=color:#86b300>+                    &mut scene_load_context,
</span><span style=color:#86b300>+                    &scene,
</span><span style=color:#86b300>+                    world_root_id,
</span><span style=color:#86b300>+                    &mut world,
</span><span style=color:#86b300>+                );
</span><span>             }
</span><span> 
</span><span>             let loaded_scene = scene_load_context.finish(Scene::new(world));
</span><span style=color:#c594c5>@@ -1755,15 +1716,7 @@ </span><span style=color:#399ee6>fn load_node(
</span><span>                         });
</span><span>                     }
</span><span>                     for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                        for id in extension.extension_ids() {
</span><span style=color:#f07171>-                            extension.on_spawn_light_directional(
</span><span style=color:#f07171>-                                id,
</span><span style=color:#f07171>-                                gltf_node.extension_value(id),
</span><span style=color:#f07171>-                                load_context,
</span><span style=color:#f07171>-                                gltf_node,
</span><span style=color:#f07171>-                                &mut entity,
</span><span style=color:#f07171>-                            );
</span><span style=color:#f07171>-                        }
</span><span style=color:#86b300>+                        extension.on_spawn_light_directional(load_context, gltf_node, &mut entity);
</span><span>                     }
</span><span>                 }
</span><span>                 gltf::khr_lights_punctual::Kind::Point => {
</span><span style=color:#c594c5>@@ -1786,15 +1739,7 @@ </span><span style=color:#399ee6>fn load_node(
</span><span>                         });
</span><span>                     }
</span><span>                     for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                        for id in extension.extension_ids() {
</span><span style=color:#f07171>-                            extension.on_spawn_light_point(
</span><span style=color:#f07171>-                                id,
</span><span style=color:#f07171>-                                gltf_node.extension_value(id),
</span><span style=color:#f07171>-                                load_context,
</span><span style=color:#f07171>-                                gltf_node,
</span><span style=color:#f07171>-                                &mut entity,
</span><span style=color:#f07171>-                            );
</span><span style=color:#f07171>-                        }
</span><span style=color:#86b300>+                        extension.on_spawn_light_point(load_context, gltf_node, &mut entity);
</span><span>                     }
</span><span>                 }
</span><span>                 gltf::khr_lights_punctual::Kind::Spot {
</span><span style=color:#c594c5>@@ -1822,15 +1767,7 @@ </span><span style=color:#399ee6>fn load_node(
</span><span>                         });
</span><span>                     }
</span><span>                     for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-                        for id in extension.extension_ids() {
</span><span style=color:#f07171>-                            extension.on_spawn_light_spot(
</span><span style=color:#f07171>-                                id,
</span><span style=color:#f07171>-                                gltf_node.extension_value(id),
</span><span style=color:#f07171>-                                load_context,
</span><span style=color:#f07171>-                                gltf_node,
</span><span style=color:#f07171>-                                &mut entity,
</span><span style=color:#f07171>-                            );
</span><span style=color:#f07171>-                        }
</span><span style=color:#86b300>+                        extension.on_spawn_light_spot(load_context, gltf_node, &mut entity);
</span><span>                     }
</span><span>                 }
</span><span>             }
</span><span style=color:#c594c5>@@ -1881,10 +1818,7 @@ </span><span style=color:#399ee6>fn load_node(
</span><span>     // accessing Mesh and Material extension data, which
</span><span>     // are merged onto the same entity in Bevy
</span><span>     for extension in extensions.iter_mut() {
</span><span style=color:#f07171>-        for id in extension.extension_ids() {
</span><span style=color:#f07171>-            let data = gltf_node.extension_value(id);
</span><span style=color:#f07171>-            extension.on_gltf_node(id, data, load_context, gltf_node, &mut node);
</span><span style=color:#f07171>-        }
</span><span style=color:#86b300>+        extension.on_gltf_node(load_context, gltf_node, &mut node);
</span><span>     }
</span><span> 
</span><span>     if let Some(err) = gltf_error {
</span><span>diff --git a/examples/gltf/gltf_extension_animation_graph.rs b/examples/gltf/gltf_extension_animation_graph.rs
</span><span>index dea4112a980b9..7c0d8d0748426 100644
</span><span style=color:#c594c5>--- a/examples/gltf/gltf_extension_animation_graph.rs
</span><span style=color:#c594c5>+++ b/examples/gltf/gltf_extension_animation_graph.rs
</span><span style=color:#c594c5>@@ -135,15 +135,8 @@ </span><span style=color:#399ee6>impl GltfExtensionHandler for GltfExtensionHandlerAnimation {
</span><span>     }
</span><span> 
</span><span>     #[cfg(feature = "bevy_animation")]
</span><span style=color:#f07171>-    fn on_animation(
</span><span style=color:#f07171>-        &mut self,
</span><span style=color:#f07171>-        _extension_id: &str,
</span><span style=color:#f07171>-        _value: Option<&serde_json::Value>,
</span><span style=color:#f07171>-        _gltf_animation: &gltf::Animation,
</span><span style=color:#f07171>-        name: Option<&str>,
</span><span style=color:#f07171>-        handle: Handle&LTAnimationClip>,
</span><span style=color:#f07171>-    ) {
</span><span style=color:#f07171>-        if name.is_some_and(|v| v == "Walk") {
</span><span style=color:#86b300>+    fn on_animation(&mut self, gltf_animation: &gltf::Animation, handle: Handle&LTAnimationClip>) {
</span><span style=color:#86b300>+        if gltf_animation.name().is_some_and(|v| v == "Walk") {
</span><span>             self.clip = Some(handle.clone());
</span><span>         }
</span><span>     }
</span><span style=color:#c594c5>@@ -160,8 +153,6 @@ </span><span style=color:#399ee6>impl GltfExtensionHandler for GltfExtensionHandlerAnimation {
</span><span> 
</span><span>     fn on_gltf_node(
</span><span>         &mut self,
</span><span style=color:#f07171>-        _extension_id: &str,
</span><span style=color:#f07171>-        _value: Option<&serde_json::Value>,
</span><span>         _load_context: &mut LoadContext<'_>,
</span><span>         gltf_node: &gltf::Node,
</span><span>         entity: &mut EntityWorldMut,
</span><span style=color:#c594c5>@@ -174,13 +165,10 @@ </span><span style=color:#399ee6>impl GltfExtensionHandler for GltfExtensionHandlerAnimation {
</span><span>     /// Called when an individual Scene is done processing
</span><span>     fn on_scene_completed(
</span><span>         &mut self,
</span><span style=color:#f07171>-        _extension_id: &str,
</span><span style=color:#f07171>-        _value: Option<&serde_json::Value>,
</span><span style=color:#86b300>+        load_context: &mut LoadContext<'_>,
</span><span>         _scene: &gltf::Scene,
</span><span style=color:#f07171>-        _name: Option<&str>,
</span><span>         _world_root_id: Entity,
</span><span>         world: &mut World,
</span><span style=color:#f07171>-        load_context: &mut LoadContext<'_>,
</span><span>     ) {
</span><span>         // Create an AnimationGraph from the desired clip
</span><span>         let (graph, index) = AnimationGraph::from_clip(self.clip.clone().unwrap());
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22114.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>