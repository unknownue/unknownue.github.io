<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20394 Alternative glTF coordinate conversion
        
    </title><meta content="#20394 Alternative glTF coordinate conversion" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-16</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-12/pr-20394-en-20251216>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Alternative glTF coordinate conversion<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20394<li><strong>Author</strong>: greeble-dev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, S-Ready-For-Final-Review, M-Migration-Guide, X-Blessed, A-glTF<li><strong>Created</strong>: 2025-08-03T11:58:31Z<li><strong>Merged</strong>: 2025-12-16T00:58:04Z<li><strong>Merged By</strong>: cart</ul><h2 id=description-translation>Description Translation</h2><h3 id=mu-biao>目标</h3><p>更改glTF坐标转换以满足一些常见用例，同时避开更有争议的方面。这修复了 #20621，但代价是移除了一个功能。<h3 id=gai-shu>概述</h3><p>Bevy的glTF加载器可以选择将节点和网格从glTF的“+Z forward“语义转换为Bevy的“-Z forward“。但当前实现<a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/20621 target=_blank>存在一些问题</a>，特别是在相机和灯光方面。对于希望重新调整整个场景方向同时保留原始节点语义的用户来说，它也可能导致问题。<p>本PR用对场景根和网格实体的更简单校正替换了节点转换。新方法满足了许多用例并修复了相机和灯光的问题。但对某些用户来说可能是一种退步。<h3 id=bei-jing>背景</h3><p>关于glTF的行为以及用户可能对坐标转换的需求一直存在混淆。本节回顾了基本概念、glTF的语义、当前加载器行为以及一些潜在的用户故事。如果您想直接了解更改内容，可以跳转到下一节。<details><summary>点击展开</summary> <h3 id=zuo-biao-xi-he-yu-yi>坐标系和语义</h3> <p>3D坐标系可以为其轴分配语义。这些语义通常定义为前向轴、上轴和<a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Right-hand_rule target=_blank>手性</a> - 侧轴隐含在其他选择中。</p> <p>Bevy的标准语义是“-Z = 前向，+Y = 上，右手系“。这个标准由<code>Transform</code>和<code>GlobalTransform</code>的<code>forward</code>和<code>up</code>方法以及渲染器对相机和灯光变换的解释来体现。关于这个标准以及用户是否应该能够选择不同语义存在争论。本PR不考虑这些争论，并假设用户希望遵循当前标准。</p> <p>其他引擎、DCC（数字内容创建）工具和文件格式可能具有<a rel="noopener nofollow noreferrer" href=https://mastodon.social/@acegikmo/113313928426095165 target=_blank>不同的语义</a>。与Bevy不同，有些根据对象类型变化其语义 - 相机的前向轴可能与灯光的不同。有些只指定上轴，留下前向和侧轴未指定。</p> <p>资产可能不遵循其文件格式的标准语义。静态网格层次结构和骨骼动画装配甚至可能具有每个节点或每个关节的语义 - 角色装配在场景中可能是+Y前向，而头部关节是+Z前向。一个角色装配可能两只脚都是+X前向，而另一个装配可能左脚是+X前向，右脚是-X前向。这造成了复杂性，但也创造了工作岗位，所以没有人能说这是好是坏。</p> <h3 id=zi-chan-jia-zai-qi-he-zuo-biao-zhuan-huan>资产加载器和坐标转换</h3> <p>Bevy目前有一个glTF加载器，我假设将来会有内置的FBX和USD加载器。这些加载器可能会遵循一个通用模式：</p> <ul><li>文件包含网格，对应于Bevy的<code>Mesh</code>资产和蒙皮网格。 <ul><li>Bevy网格只能有一种材质，所以文件格式认为是单个网格的可能对应多个Bevy网格。</ul><li>文件具有节点层次结构，其中节点大致对应于具有<code>Transform</code>的Bevy实体。 <ul><li>节点可以是网格实例、相机、灯光或蒙皮网格关节。</ul><li>加载器输出资产和尝试匹配文件节点层次结构的<code>Scene</code>实体层次结构。 <ul><li>节点的某些方面（例如枢轴变换）无法在单个Bevy实体中表示。<li>因此1:1映射可能不可能 - 节点变为多个实体，或者某些数据丢失（例如烘焙枢轴变换）。</ul><li>用户可以选择生成场景，或者忽略它直接使用资产。</ul> <p>用户可能希望资产加载器将资产转换为Bevy的标准语义，这样<code>Transform::forward</code>就与资产匹配。但转换的细节可能存在争议 - 用户可能希望场景的某些部分以不同于其他部分的方式进行转换，并且资产可能存在只能由用户解决的歧义。永远不会有简单的“它就能工作“选项，尽管可能有一个满足大多数用户的最小最差默认值。</p> <p>在加载器中转换不是唯一选项。用户可以自己编辑资产或在DCC中运行转换脚本。但这很痛苦 - 特别是对于依赖资产包且没有DCC经验的用户。另一个选项是实现执行坐标转换的资产变换。但在加载器中提供选项是很方便的。</p> <h3 id=yong-hu-gu-shi>用户故事</h3> <p>对于加载器中的坐标转换，一些用户故事可能是：</p> <ul><li>“我想在具有Bevy语义的实体上生成场景并使其看起来正确。” <ul><li>这可能是最常见的情况 - 用户希望执行<code>SceneRoot(load("my.gltf"))</code>并使其在视觉上匹配实体的<code>Transform::forward()</code>，相机和灯光应该做正确的事情。<li>用户可能不关心场景中网格资产和节点的语义 - 他们只希望整个场景看起来正确。</ul><li>“我想生成场景，并将部分或全部节点转换为Bevy语义。” <ul><li>用户可能希望手动动画场景中的节点，或将其连接到假定Bevy语义的其他系统。<li>如果加载器可以将节点的前向转换为匹配<code>Transform::forward()</code>，这会更容易。<li>相反，一些用户可能希望节点保持原样（特别是骨骼动画装配）。</ul><li>“我想要转换为Bevy语义的网格资产。我不使用场景。” <ul><li>也许用户正在执行<code>Mesh3d(load("mesh.gltf#Mesh0"))</code>并希望它匹配实体的前向。<li>或者这是资产管道的第一阶段，剩余阶段期望Bevy语义。</ul><li>“我不希望加载器接触任何东西。” <ul><li>也许他们已经转换了文件，或者希望加载后转换，或者根本不想使用Bevy语义。</ul><li>“我想要其他转换故事之一，但加载器应该转换为我选择的语义而不是Bevy的。” <ul><li>Z向上不是犯罪。</ul></ul> <h3 id=gltfyu-yi>glTF语义</h3> <p>glTF的<a rel="noopener nofollow noreferrer" href=https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#coordinate-system-and-units target=_blank>场景语义</a>是“+Z = 前向，+Y = 上，右手系“。这与Bevy几乎相同，只是场景前向是+Z而不是Bevy的-Z。</p> <p>有些glTF资产不遵循规范中的场景语义。Kenney资产包混合使用+Z和-Z前向。至少<a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/Duck target=_blank>一个Khronos示例资产</a>使用+X前向。也就是说，我测试的大多数Kenney资产和几乎所有Khronos示例资产都遵循规范。</p> <p>glTF的<a rel="noopener nofollow noreferrer" href=https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#view-matrix target=_blank>相机节点</a>和<a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md#adding-light-instances-to-nodes target=_blank>灯光节点</a>语义与glTF场景语义不同 - 它们是-Z前向，与Bevy相同。</p> <p>glTF规范没有明确说明非相机/灯光节点和网格缓冲区是否具有语义。我猜测一些用户的节点和网格遵循规范中的场景语义，并可能希望将它们转换为Bevy语义。但正如用户故事中所述，其他用户可能有不同的需求。</p> <p>glTF和Bevy允许单个节点/实体同时是网格和相机或灯光。只有在用户希望网格具有与相机和灯光相同语义时，这才有意义。我认为极不可能有大量用户需要支持这种组合 - 许多其他DCC、文件格式和引擎根本不支持它。</p> <h3 id=bevy-gltfjia-zai-qi-de-gong-zuo-yuan-li>Bevy glTF加载器的工作原理</h3> <p>加载器将glTF节点映射到Bevy实体。它还为两种情况添加实体：</p> <ol><li>添加一个单独的“场景根“实体作为glTF根节点的父级。 <ul><li>注意，这不是用户具有<code>SceneRoot</code>组件的实体 - 场景根实体是该实体的子级。</ul><li>网格图元实体作为每个glTF网格节点的子级添加。 <ul><li>在glTF中，单个网格节点可以包含多个图元。<li>但在Bevy中，网格组件只能包含单个图元，因此一个实体不能包含多个图元。<li>因此，对于每个图元，Bevy添加一个具有网格组件的子实体。</ul></ol> <p>结果场景层次结构的单个分支可能如下所示：</p> <ul><li>具有<code>SceneRoot</code>组件的用户实体。 <ul><li>场景根实体。 <ul><li>glTF根节点实体。 <ul><li>glTF中间节点实体。 <ul><li>glTF网格节点实体（不包含<code>Mesh3d</code>组件） <ul><li>网格图元实体（包含<code>Mesh3d</code>组件）。</ul></ul></ul></ul></ul></ul> <h3 id=0-17ban-ben-zhong-de-gltfjia-zai-qi-geng-gai>0.17版本中的glTF加载器更改</h3> <p>在Bevy 0.16中，glTF加载器支持的唯一用户故事是“不转换“。在0.17开发周期中，#19633和一些后续PR实现了一个转换节点、网格和动画轨道的选项。</p> <p>这些更改确实满足了一些用户故事，包括常见的“转换场景语义“（大部分）和“转换网格语义“。但存在一些问题（#20621）：</p> <ul><li>转换取决于转换节点和网格。 <ul><li>一些用户可能希望转换场景而不转换节点和/或网格。</ul><li>灯光和相机节点变得复杂。 <ul><li>glTF相机/灯光节点已经匹配Bevy语义，因此需要反向转换（因为它们的父级可能已被转换）。<li>灯光和相机的动画轨道未正确转换。 <ul><li>（反对意见：这可以通过一些复杂性来修复）</ul><li>灯光和相机的子节点未正确转换。 <ul><li>（反对意见：也可修复，可能是一个小众情况？）</ul><li>转换不能支持同时是网格实例又是灯光和/或相机的节点。 <ul><li>（反对意见：如前所述，这可能是一个非常小众或不存在的用例。）</ul></ul></ul></details><h3 id=jie-jue-fang-an>解决方案</h3><p>本PR中的重大更改是移除了节点转换。相反，校正变换应用于场景根实体和网格图元实体。<p>本PR之前：<ul><li>场景根实体。 <ul><li>glTF根节点实体。<– 已转换 <ul><li>glTF中间节点实体。<– 已转换 <ul><li>glTF网格节点实体。<– 已转换 <ul><li>网格图元实体。</ul></ul></ul></ul></ul><p>本PR之后：<ul><li>场景根实体。<– 校正（如果启用了场景转换） <ul><li>glTF根节点实体。 <ul><li>glTF中间节点实体。 <ul><li>glTF网格节点实体。 <ul><li>网格图元实体。<– 校正（如果启用了网格转换）</ul></ul></ul></ul></ul><p>结果是视觉上相同，尽管场景内部不同。相机和灯光现在正常工作，包括在动画时。<p>新的转换也更简单。不需要转换动画，并且转换的场景部分只更改单个实体：<pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span style=color:#86b300>+let world_root_transform = convert_coordinates.scene_conversion_transform();
</span><span>
</span><span> let world_root_id = world
</span><span style=color:#f07171>-    .spawn((Transform::default(), Visibility::default()))
</span><span style=color:#86b300>+    .spawn((world_root_transform, Visibility::default()))
</span><span>     .with_children(|parent| {
</span><span>         for node in scene.nodes() {
</span></code></pre><p>移除节点转换对一些用户来说可能是一种退步。我的猜测是大多数用户只想以正确的方向生成场景，不关心单个节点变换，因此总体而言本PR将是胜利。但我没有太多证据支持这一点。也可能有将节点转换作为选项添加回来的途径 - 参见下面的“未来“部分。<p>以前的转换选项 - <code>GltfPlugin::use_model_forward_direction</code> - 已拆分为场景和网格转换的两个单独选项。<pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span> struct GltfPlugin {
</span><span>     ...
</span><span style=color:#f07171>-    use_model_forward_direction: bool,
</span><span style=color:#86b300>+    convert_coordinates: GltfConvertCoordinates,
</span><span> }
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>GltfConvertCoordinates </span><span>{
</span><span>    scenes</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>    meshes</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>bool</span><span>,
</span><span>}
</span></code></pre><p>这可能最终被证明是不必要的灵活性，但我认为目前这是更安全的选择，以防用户有意外需求。两个选项默认都是禁用的。<h3 id=ce-shi>测试</h3><p>我已经用每个选项组合测试了各种示例和glTF，包括带有动画相机和灯光的glTF。<pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#abb0b6;font-style:italic># 视觉上与当前Bevy*不*转换相同。
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> scene_viewer </span><span style=color:#86b300>"assets/models/faces/faces.glb"
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> scene_viewer </span><span style=color:#86b300>"assets/models/faces/faces.glb"</span><span style=color:#ff8f40> --convert-mesh-coordinates
</span><span>
</span><span style=color:#abb0b6;font-style:italic># 视觉上与当前Bevy*启用了*转换相同。
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> scene_viewer </span><span style=color:#86b300>"assets/models/faces/faces.glb"</span><span style=color:#ff8f40> --convert-scene-coordinates
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> scene_viewer </span><span style=color:#86b300>"assets/models/faces/faces.glb"</span><span style=color:#ff8f40> --convert-scene-coordinates --convert-mesh-coordinates
</span><span>
</span><span style=color:#f29718>cargo</span><span> run</span><span style=color:#ff8f40> --example</span><span> animated_mesh
</span></code></pre><h3 id=wei-lai>未来</h3><details><summary>点击展开</summary> <p>本PR移除了节点转换，这对某些用户来说是一个期望的功能。有几种方法可以将其作为选项添加回来。</p> <p>节点转换的困难部分是如何支持相机和灯光节点。glTF的相机/灯光语义已经匹配Bevy的-Z前向，因此简单地将每个节点从+Z转换为-Z前向将使相机和灯光节点面向错误的方向。</p> <p>明显的解决方案是对相机/灯光节点变换进行特殊处理 - 这就是0.17转换尝试做的。但由于动画、子节点以及可以是网格、相机和灯光的节点，正确实现这一点非常复杂。例如，相机和灯光的子节点需要对其变换和动画轨道应用反向转换。</p> <p>对于相机，另一种选择是将它们拆分为多个实体。现有实体将对应glTF节点并像其他每个节点一样被转换。但Bevy的<code>Camera</code>组件将在一个新的子实体上并具有校正变换。</p> <p>之前：</p> <ul><li>父glTF节点实体。 <ul><li>具有<code>Camera</code>组件和动画变换的相机glTF节点实体。 <ul><li>父级到相机节点的glTF节点。</ul></ul></ul> <p>之后：</p> <ul><li>父glTF节点实体。 <ul><li>具有动画变换的相机glTF节点实体。 <ul><li>具有<code>Camera</code>组件和校正变换的新子实体。<li>父级到相机节点的glTF节点。</ul></ul></ul> <p>灯光已经这样设置，因此它们只需要校正变换。</p> <p>这种方法更简单，因为节点被统一对待。这可以说是对glTF格式更好的反映 - glTF相机与节点是分开的东西，并且可以分配与其节点名称不同的名称。因此对某些用户来说可能更好。</p> <p>缺点是从某些用户（尽管不是所有用户）的角度来看，glTF节点实体可能具有错误的语义。对于当前假设<code>Camera</code>组件在节点实体上的用户来说，这将是令人讨厌的。</p></details><h3 id=ti-dai-fang-an>替代方案</h3><details><summary>点击展开</summary> <h3 id=guan-yu-qian-xiang-biao-zhi-ti-an>关于前向标志提案？</h3> <p>有一个<a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/20135 target=_blank>提案</a>允许每个变换的语义，即“前向标志“。这意味着<code>Transform::forward()</code>和其他方法的轴将取决于<code>Transform</code>中的一个变量。理论上，前向标志可能避免加载器中坐标转换的需要。但这是否在实践中有效尚不清楚，并且该提案似乎已停滞。</p> <h3 id=qi-ta-yin-qing-zuo-shen-me>其他引擎做什么？</h3> <p><a rel="noopener nofollow noreferrer" href=https://docs.godotengine.org/en/4.4/tutorials/assets_pipeline/importing_3d_scenes/model_export_considerations.html#d-asset-direction-conventions target=_blank>Godot的语义</a>与glTF标准相同。Godot不提供任何转换选项。</p> <p>Unreal的默认语义是“+X前向，+Z上，左手系“，但网格通常是“+Y前向，+Z上“。他们的glTF导入器将节点和网格转换为Unreal的网格语义 - 这是通过交换Y和Z轴完成的，这隐式地翻转了X轴以处理手性。因此Unreal的方法实际上更接近当前的主要方法（节点+网格转换），与本PR的场景+网格转换相对。Unreal导入器还支持在正常转换后应用的自定义场景/网格旋转和平移。没有禁用转换的选项。</p></details><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个PR始于一个实际的技术问题：Bevy的glTF坐标转换在0.17版本中存在缺陷，特别是对相机和灯光处理不当。问题#20621报告了转换导致相机和灯光方向错误，这对于想要正确渲染3D场景的用户来说是个严重问题。<p>glTF规范定义场景使用“+Z前向“语义，而Bevy使用“-Z前向“。之前的实现在每个节点层级应用转换，这导致相机和灯光出现问题，因为glTF中的相机和灯光已经使用与Bevy相同的“-Z前向“语义。将它们与其他节点一起转换会造成双重转换，使其方向错误。<p>开发者面临的核心挑战是：如何在保持向后兼容性的同时修复这个问题？简单的解决方案是移除所有转换，但这会破坏依赖转换的用户。更复杂的解决方案是尝试修复节点转换逻辑，但这涉及处理许多边缘情况，如相机/灯光节点、子节点转换和动画轨道。<p>开发者的解决方案很巧妙：不是完全移除转换，而是改变应用转换的位置。之前的实现在每个glTF节点实体上应用转换，新方法改为在场景根实体和网格图元实体上应用校正变换。这样可以在视觉上达到相同的效果，同时避免影响相机和灯光节点。<p>具体来说，PR做出了以下关键更改：<ol><li><p><strong>重构坐标转换API</strong>：将单个布尔选项拆分为<code>GltfConvertCoordinates</code>结构体，包含两个独立选项：<code>rotate_scene_entity</code>（场景转换）和<code>rotate_meshes</code>（网格转换）。这为用户提供了更细粒度的控制。</p><li><p><strong>移除节点转换</strong>：删除了之前在每个glTF节点上应用的转换逻辑。现在节点保持其原始变换，符合glTF规范。</p><li><p><strong>在场景根添加转换</strong>：如果启用场景转换，在场景根实体上应用180度Y轴旋转。这相当于将整个场景从+Z前向翻转为-Z前向。</p><li><p><strong>在网格图元添加校正</strong>：如果启用网格转换，在网格图元实体上应用相同的变换，确保网格方向正确。</p></ol><p>这种方法的优点是：<ul><li>相机和灯光自动正确工作，因为它们的节点不再被转换<li>动画轨道不再需要特殊处理<li>实现更简单，减少了代码复杂度<li>用户仍然可以选择是否转换场景和/或网格</ul><p>技术实现上，关键的变化体现在几个核心函数中。首先，<code>convert_coordinates.rs</code>中的转换逻辑被重写，不再提供通用的节点转换函数，而是提供特定于场景和网格的转换方法：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>scene_conversion_transform</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Transform {
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>rotate_scene_entity {
</span><span>        </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>CONVERSION_TRANSFORM
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        Transform</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>IDENTITY
</span><span>    }
</span><span>}
</span></code></pre><p>其次，在加载器主逻辑中，节点变换函数<code>node_transform</code>不再接受<code>convert_coordinates</code>参数，而是始终返回原始glTF变换：<pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span style=color:#f07171>-pub(crate) fn node_transform(node: &Node, convert_coordinates: bool) -> Transform {
</span><span style=color:#86b300>+pub(crate) fn node_transform(node: &Node) -> Transform {
</span></code></pre><p>最重要的更改在场景生成逻辑中，现在只在场景根实体上应用转换：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> world_root_transform </span><span style=color:#ed9366>=</span><span> convert_coordinates</span><span style=color:#ed9366>.</span><span style=color:#f07171>scene_conversion_transform</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let</span><span> world_root_id </span><span style=color:#ed9366>=</span><span> world
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((world_root_transform</span><span style=color:#61676ccc>, </span><span>Visibility</span><span style=color:#ed9366>::</span><span>default()))
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_children</span><span>(|</span><span style=color:#ff8f40>parent</span><span>| {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 节点保持原始变换
</span><span>    })</span><span style=color:#61676ccc>;
</span></code></pre><p>对于网格实体，转换作为单独的变换组件添加：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> mesh_entity_transform </span><span style=color:#ed9366>=</span><span> convert_coordinates</span><span style=color:#ed9366>.</span><span style=color:#f07171>mesh_conversion_transform_inverse</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let mut</span><span> mesh_entity </span><span style=color:#ed9366>=</span><span> parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>    Mesh3d(load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_label_handle</span><span>(primitive_label</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_string</span><span>()))</span><span style=color:#61676ccc>,
</span><span>    MeshMaterial3d</span><span style=color:#ed9366>::</span><span>&LTStandardMaterial>(
</span><span>        load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_label_handle</span><span>(</span><span style=color:#ed9366>&</span><span>material_label)</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>,
</span><span>    mesh_entity_transform</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// 网格特定变换
</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><p>这种设计允许网格转换独立于场景转换工作。用户可以选择：<ul><li>只转换场景（保持网格原样）<li>只转换网格（保持场景节点原样）<li>两者都转换（相当于之前的节点+网格转换）<li>都不转换（保持一切原样）</ul><p>从技术角度看，这个解决方案展示了良好的工程权衡。它放弃了完全控制每个节点的能力，换来了更健壮、更简单且能满足大多数用户需求的实现。这个权衡是有道理的，因为实践中很少有用户需要逐个节点控制转换语义。<p>迁移指南清楚地解释了如何从旧API迁移到新API。对于之前使用<code>use_model_forward_direction: true</code>的用户，现在应该同时启用<code>rotate_scene_entity</code>和<code>rotate_meshes</code>以获得最接近的行为。<p>这个PR还体现了良好的向后兼容性设计：默认情况下所有转换都是禁用的，所以现有代码不会突然改变行为。用户必须显式启用新选项才能看到变化。<p>从架构角度看，这个改变也更好地分离了关注点：场景转换处理整体方向，网格转换处理资产方向，节点保持其原始语义。这使得系统更模块化，未来更容易扩展。<p>总的来说，这个PR解决了实际的错误，简化了实现，同时为不同需求的用户提供了灵活的选项。它展示了在面对复杂3D坐标系统问题时，有时更简单、更高层次的解决方案比试图处理所有边缘情况的复杂逻辑更有效。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    subgraph "Before PR (0.17)"
</span><span>        A1[Scene Root Entity] --> B1[glTF Root Node Entity&LTbr/>- CONVERTED]
</span><span>        B1 --> C1[glTF Intermediate Node Entity&LTbr/>- CONVERTED]
</span><span>        C1 --> D1[glTF Mesh Node Entity&LTbr/>- CONVERTED]
</span><span>        D1 --> E1[Mesh Primitive Entity]
</span><span>    end
</span><span>    
</span><span>    subgraph "After PR (0.18)"
</span><span>        A2[Scene Root Entity&LTbr/>- CORRECTIVE] --> B2[glTF Root Node Entity]
</span><span>        B2 --> C2[glTF Intermediate Node Entity]
</span><span>        C2 --> D2[glTF Mesh Node Entity]
</span><span>        D2 --> E2[Mesh Primitive Entity&LTbr/>- CORRECTIVE]
</span><span>    end
</span><span>    
</span><span>    style A1 fill:#f9f,stroke:#333,stroke-width:2px
</span><span>    style B1 fill:#f9f,stroke:#333,stroke-width:2px
</span><span>    style C1 fill:#f9f,stroke:#333,stroke-width:2px
</span><span>    style D1 fill:#f9f,stroke:#333,stroke-width:2px
</span><span>    style A2 fill:#9f9,stroke:#333,stroke-width:2px
</span><span>    style E2 fill:#9f9,stroke:#333,stroke-width:2px
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-gltf-src-convert-coordinates-rs-81-46><code>crates/bevy_gltf/src/convert_coordinates.rs</code> (+81/-46)</h3><p>这个文件完全重写，移除了节点转换逻辑，引入了新的<code>GltfConvertCoordinates</code>结构体。<p><strong>主要变化：</strong><ul><li>移除了<code>ConvertCoordinates</code>和<code>ConvertCameraCoordinates</code> trait<li>添加了<code>GltfConvertCoordinates</code>结构体，包含<code>rotate_scene_entity</code>和<code>rotate_meshes</code>选项<li>添加了场景和网格转换的专用方法</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前：通用的转换方法
</span><span style=color:#fa6e32>impl </span><span>ConvertCoordinates </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Transform </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>convert_coordinates</span><span>(</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>translation </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>translation</span><span style=color:#ed9366>.</span><span style=color:#f07171>convert_coordinates</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>rotation </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>rotation</span><span style=color:#ed9366>.</span><span style=color:#f07171>convert_coordinates</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 之后：专用的转换方法
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>GltfConvertCoordinates </span><span>{
</span><span>    </span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>CONVERSION_TRANSFORM</span><span style=color:#61676ccc>:</span><span> Transform </span><span style=color:#ed9366>=
</span><span>        Transform</span><span style=color:#ed9366>::</span><span>from_rotation(Quat</span><span style=color:#ed9366>::</span><span>from_xyzw(</span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.0</span><span>))</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>scene_conversion_transform</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Transform {
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>rotate_scene_entity {
</span><span>            </span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>CONVERSION_TRANSFORM
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            Transform</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>IDENTITY
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-gltf-src-loader-mod-rs-37-67><code>crates/bevy_gltf/src/loader/mod.rs</code> (+37/-67)</h3><p>这是主要的加载逻辑文件，移除了节点转换，添加了场景根和网格图元的转换。<p><strong>关键变化：</strong><ol><li>移除了节点转换逻辑<li>在场景根实体添加转换<li>在网格图元实体添加转换</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 场景生成逻辑中的关键更改
</span><span style=color:#fa6e32>let</span><span> world_root_transform </span><span style=color:#ed9366>=</span><span> convert_coordinates</span><span style=color:#ed9366>.</span><span style=color:#f07171>scene_conversion_transform</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let</span><span> world_root_id </span><span style=color:#ed9366>=</span><span> world
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((world_root_transform</span><span style=color:#61676ccc>, </span><span>Visibility</span><span style=color:#ed9366>::</span><span>default()))  </span><span style=color:#abb0b6;font-style:italic>// 场景根转换
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>with_children</span><span>(|</span><span style=color:#ff8f40>parent</span><span>| {
</span><span>        </span><span style=color:#fa6e32>for</span><span> node </span><span style=color:#ed9366>in</span><span> scene</span><span style=color:#ed9366>.</span><span style=color:#f07171>nodes</span><span>() {
</span><span>            </span><span style=color:#f07171>load_node</span><span>(</span><span style=color:#abb0b6;font-style:italic>/* ... 节点不再转换 ... */</span><span>)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 网格实体创建时的转换
</span><span style=color:#fa6e32>let</span><span> mesh_entity_transform </span><span style=color:#ed9366>=</span><span> convert_coordinates</span><span style=color:#ed9366>.</span><span style=color:#f07171>mesh_conversion_transform_inverse</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let mut</span><span> mesh_entity </span><span style=color:#ed9366>=</span><span> parent</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>    Mesh3d(</span><span style=color:#abb0b6;font-style:italic>/* ... */</span><span>)</span><span style=color:#61676ccc>,
</span><span>    MeshMaterial3d</span><span style=color:#ed9366>::</span><span>&LTStandardMaterial>(</span><span style=color:#abb0b6;font-style:italic>/* ... */</span><span>)</span><span style=color:#61676ccc>,
</span><span>    mesh_entity_transform</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// 网格特定转换
</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-gltf-src-lib-rs-7-17><code>crates/bevy_gltf/src/lib.rs</code> (+7/-17)</h3><p>更新了<code>GltfPlugin</code>以使用新的<code>GltfConvertCoordinates</code>结构体。<pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>struct GltfPlugin {
</span><span>    ...
</span><span style=color:#f07171>-    use_model_forward_direction: bool,
</span><span style=color:#86b300>+    convert_coordinates: GltfConvertCoordinates,
</span><span>}
</span></code></pre><h3 id=crates-bevy-gltf-src-loader-gltf-ext-scene-rs-3-15><code>crates/bevy_gltf/src/loader/gltf_ext/scene.rs</code> (+3/-15)</h3><p>简化了<code>node_transform</code>函数，移除了转换参数。<pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span style=color:#f07171>-pub(crate) fn node_transform(node: &Node, convert_coordinates: bool) -> Transform {
</span><span style=color:#86b300>+pub(crate) fn node_transform(node: &Node) -> Transform {
</span><span>    match node.transform() {
</span><span>        // ... 转换计算逻辑简化
</span><span>    }
</span><span style=color:#f07171>-    if convert_coordinates {
</span><span style=color:#f07171>-        if node.camera().is_some() || node.light().is_some() {
</span><span style=color:#f07171>-            transform.convert_camera_coordinates()
</span><span style=color:#f07171>-        } else {
</span><span style=color:#f07171>-            transform.convert_coordinates()
</span><span style=color:#f07171>-        }
</span><span style=color:#f07171>-    } else {
</span><span style=color:#f07171>-        transform
</span><span style=color:#f07171>-    }
</span><span>}
</span></code></pre><h3 id=release-content-migration-guides-gltf-coordinate-conversion-md-96-0><code>release-content/migration-guides/gltf-coordinate-conversion.md</code> (+96/-0)</h3><p>新增迁移指南，帮助用户从0.17迁移到0.18。<pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span style=color:#fa6e32;font-weight:700># </span><span style=color:#399ee6;font-weight:700>glTF Coordinate Conversion
</span><span>
</span><span style=color:#f07171;font-weight:700>**Bevy 0.17**</span><span> added experimental options for coordinate conversion...
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><p><strong>glTF规范</strong>: <a rel="noopener nofollow noreferrer" href=https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#coordinate-system-and-units target=_blank>glTF 2.0 Coordinate System and Units</a> - 理解glTF的默认坐标系统</p><li><p><strong>原始问题</strong>: <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/20621 target=_blank>Issue #20621</a> - 这个PR要解决的具体问题</p><li><p><strong>之前的转换实现</strong>: <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/19633 target=_blank>PR #19633</a> - 0.17版本中引入的原始转换逻辑</p><li><p><strong>替代方案讨论</strong>: <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/pull/20135 target=_blank>Forward Flag Proposal</a> - 关于每变换语义的更广泛讨论</p><li><p><strong>其他引擎的实践</strong>:</p> <ul><li><a rel="noopener nofollow noreferrer" href=https://docs.godotengine.org/en/4.4/tutorials/assets_pipeline/importing_3d_scenes/model_export_considerations.html#d-asset-direction-conventions target=_blank>Godot Import Considerations</a><li>Unreal Engine的glTF导入器实现</ul><li><p><strong>3D坐标系统基础</strong>: <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Right-hand_rule target=_blank>Right-hand rule</a> - 理解3D坐标系统的基础</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_20394.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>