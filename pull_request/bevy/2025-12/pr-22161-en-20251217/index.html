<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22161 Name the fields of `FontAtlasKey`
        
    </title><meta content="#22161 Name the fields of `FontAtlasKey`" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-17</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22161-zh-cn-20251217>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Name the fields of <code>FontAtlasKey</code><li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22161<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-UI, C-Code-Quality, S-Ready-For-Final-Review, D-Straightforward<li><strong>Created</strong>: 2025-12-17T11:50:51Z<li><strong>Merged</strong>: 2025-12-17T19:16:58Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description>Description</h2><p><strong>Objective</strong><p>Name the fields of the <code>FontAtlasKey</code> struct.<p><strong>Solution</strong><p>Named the fields and added doc comments.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This pull request addresses a straightforward code quality issue in Bevy’s text rendering system. The <code>FontAtlasKey</code> struct was previously defined as a tuple struct with unnamed fields, making the code less readable and maintainable. Tuple structs are appropriate when the fields have obvious meanings from context, but in this case, the three fields represent distinct concepts that benefit from explicit naming.<p>The <code>FontAtlasKey</code> serves as a hash key for caching font atlases - texture regions containing pre-rendered glyphs. Each atlas is specific to a particular font, font size, and font smoothing (antialiasing) setting. The struct needs to implement <code>Hash</code>, <code>PartialEq</code>, and <code>Eq</code> traits to function as a dictionary key in Bevy’s font atlas management system.<p>Before this change, accessing the fields required tuple indexing (<code>key.0</code>, <code>key.1</code>, <code>key.2</code>), which is error-prone because it relies on positional knowledge. For example, in the original code, <code>key.0</code> referred to the <code>AssetId&LTFont></code>, but this wasn’t immediately obvious without looking at the struct definition or usage patterns.<p>The implementation approach was systematic: convert the tuple struct to a regular struct with named fields, update all field accesses throughout the codebase, and add documentation comments to clarify each field’s purpose. This required changes in three files that used the struct.<p>One important technical consideration was maintaining the exact same memory layout and behavior. The struct still contains the same three fields in the same order: an <code>AssetId&LTFont></code> for the font asset identifier, a <code>u32</code> representing the font size (via <code>f32::to_bits()</code> to allow floating-point sizes to be used as hash keys), and a <code>FontSmoothing</code> enum value for the antialiasing method. The conversion from tuple struct to named struct doesn’t change the struct’s ABI or serialization behavior since Rust structs are laid out in memory in declaration order by default.<p>The impact of this change is purely on code quality and maintainability. Developers reading or modifying the text rendering code now have clear, self-documenting field names instead of positional indices. The added documentation comments provide additional context about why <code>font_size_bits</code> stores the result of <code>f32::to_bits()</code> rather than the font size directly. This makes the code more approachable for new contributors and reduces the cognitive load when debugging or extending the font system.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[FontAtlasSet System] --> B[FontAtlasKey]
</span><span>    B --> C[AssetId&LTFont> field]
</span><span>    B --> D[font_size_bits field]
</span><span>    B --> E[font_smoothing field]
</span><span>    F[TextFont] -->|converts to| B
</span><span>    G[TextPipeline] -->|uses as key| B
</span><span>    H[free_unused_font_atlases_system] -->|filters by| C
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><p><strong>1. <code>crates/bevy_text/src/font_atlas_set.rs</code> (+14/-7)</strong> This is the primary file containing the <code>FontAtlasKey</code> struct definition and related systems. The struct was converted from a tuple struct to a regular struct with named, documented fields.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_text/src/font_atlas_set.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Copy)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>FontAtlasKey</span><span>(pub AssetId&LTFont>, pub </span><span style=color:#fa6e32>u32</span><span>, pub FontSmoothing)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Hash</span><span style=color:#61676ccc>,</span><span> PartialEq</span><span style=color:#61676ccc>,</span><span> Eq</span><span style=color:#61676ccc>,</span><span> Clone</span><span style=color:#61676ccc>,</span><span> Copy)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>FontAtlasKey </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Font asset id
</span><span>    </span><span style=color:#fa6e32>pub </span><span>id</span><span style=color:#61676ccc>: </span><span>AssetId&LTFont>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Font size via `f32::to_bits`
</span><span>    </span><span style=color:#fa6e32>pub </span><span>font_size_bits</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Antialiasing method
</span><span>    </span><span style=color:#fa6e32>pub </span><span>font_smoothing</span><span style=color:#61676ccc>:</span><span> FontSmoothing,
</span><span>}
</span></code></pre><p>The <code>From<&TextFont></code> implementation was updated to use the named field constructor syntax:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>From</span><span><</span><span style=color:#ed9366>&</span><span>TextFont> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>FontAtlasKey </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>from</span><span>(</span><span style=color:#ff8f40>font</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>TextFont) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        FontAtlasKey(
</span><span>            font</span><span style=color:#ed9366>.</span><span>font</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()</span><span style=color:#61676ccc>,
</span><span>            font</span><span style=color:#ed9366>.</span><span>font_size</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_bits</span><span>()</span><span style=color:#61676ccc>,
</span><span>            font</span><span style=color:#ed9366>.</span><span>font_smoothing</span><span style=color:#61676ccc>,
</span><span>        )
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>From</span><span><</span><span style=color:#ed9366>&</span><span>TextFont> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>FontAtlasKey </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>from</span><span>(</span><span style=color:#ff8f40>font</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>TextFont) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#fa6e32>Self </span><span>{
</span><span>            id</span><span style=color:#61676ccc>:</span><span> font</span><span style=color:#ed9366>.</span><span>font</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()</span><span style=color:#61676ccc>,
</span><span>            font_size_bits</span><span style=color:#61676ccc>:</span><span> font</span><span style=color:#ed9366>.</span><span>font_size</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_bits</span><span>()</span><span style=color:#61676ccc>,
</span><span>            font_smoothing</span><span style=color:#61676ccc>:</span><span> font</span><span style=color:#ed9366>.</span><span>font_smoothing</span><span style=color:#61676ccc>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>free_unused_font_atlases_system</code> function was updated to use the named field:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>font_atlas_sets</span><span style=color:#ed9366>.</span><span style=color:#f07171>retain</span><span>(|</span><span style=color:#ff8f40>key</span><span style=color:#61676ccc>,</span><span> _| key</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>!= *</span><span>id)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>font_atlas_sets</span><span style=color:#ed9366>.</span><span style=color:#f07171>retain</span><span>(|</span><span style=color:#ff8f40>key</span><span style=color:#61676ccc>,</span><span> _| key</span><span style=color:#ed9366>.</span><span>id </span><span style=color:#ed9366>!= *</span><span>id)</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>2. <code>crates/bevy_text/src/pipeline.rs</code> (+4/-4)</strong> This file contains the text rendering pipeline that uses <code>FontAtlasKey</code> as a dictionary key when looking up or creating font atlases. The code was updated to construct the key using named fields.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: crates/bevy_text/src/pipeline.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> font_atlases </span><span style=color:#ed9366>=</span><span> font_atlas_set
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>(FontAtlasKey(
</span><span>        font_id</span><span style=color:#61676ccc>,
</span><span>        physical_glyph</span><span style=color:#ed9366>.</span><span>cache_key</span><span style=color:#ed9366>.</span><span>font_size_bits</span><span style=color:#61676ccc>,
</span><span>        font_smoothing</span><span style=color:#61676ccc>,
</span><span>    ))
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> font_atlases </span><span style=color:#ed9366>=</span><span> font_atlas_set
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>entry</span><span>(FontAtlasKey {
</span><span>        id</span><span style=color:#61676ccc>:</span><span> font_id</span><span style=color:#61676ccc>,
</span><span>        font_size_bits</span><span style=color:#61676ccc>:</span><span> physical_glyph</span><span style=color:#ed9366>.</span><span>cache_key</span><span style=color:#ed9366>.</span><span>font_size_bits</span><span style=color:#61676ccc>,
</span><span>        font_smoothing</span><span style=color:#61676ccc>,
</span><span>    })
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>or_default</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>3. <code>examples/stress_tests/many_text2d.rs</code> (+1/-1)</strong> This example file contains debugging code that counts font atlases. It was updated to use the named field instead of tuple indexing.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// File: examples/stress_tests/many_text2d.rs
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>filter</span><span>(|(</span><span style=color:#ff8f40>key</span><span style=color:#61676ccc>,</span><span> _)| key</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>==</span><span> font_id)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>filter</span><span>(|(</span><span style=color:#ff8f40>key</span><span style=color:#61676ccc>,</span><span> _)| key</span><span style=color:#ed9366>.</span><span>id </span><span style=color:#ed9366>==</span><span> font_id)
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><strong>Rust Structs Documentation</strong>: The Rust Book’s section on structs explains the difference between tuple structs and structs with named fields: https://doc.rust-lang.org/book/ch05-01-defining-structs.html<li><strong>Bevy Text Rendering</strong>: The Bevy engine’s text rendering system documentation provides context for how font atlases work: https://bevyengine.org/learn/books/bevy-cheatbook/features/text.html<li><strong>Asset System</strong>: Understanding Bevy’s asset system and <code>AssetId</code> is helpful for working with font assets: https://bevyengine.org/learn/books/bevy-cheatbook/features/assets.html<li><strong>Code Quality Best Practices</strong>: This PR exemplifies several Rust code quality practices including self-documenting code and avoiding “magic numbers” (or in this case, “magic indices”).</ol><h1 id=full-code-diff>Full Code Diff</h1><pre style=color:#61676c;background-color:#fafafa><code><span>diff --git a/crates/bevy_text/src/font_atlas_set.rs b/crates/bevy_text/src/font_atlas_set.rs
</span><span>index 76d7bfaa460b2..f189b40733fd6 100644
</span><span>--- a/crates/bevy_text/src/font_atlas_set.rs
</span><span>+++ b/crates/bevy_text/src/font_atlas_set.rs
</span><span>@@ -8,15 +8,22 @@ use bevy_platform::collections::HashMap;
</span><span> ///
</span><span> /// Allows an `f32` font size to be used as a key in a `HashMap`, by its binary representation.
</span><span> #[derive(Debug, Hash, PartialEq, Eq, Clone, Copy)]
</span><span>-pub struct FontAtlasKey(pub AssetId&LTFont>, pub u32, pub FontSmoothing);
</span><span>+pub struct FontAtlasKey {
</span><span>+    /// Font asset id
</span><span>+    pub id: AssetId&LTFont>,
</span><span>+    /// Font size via `f32::to_bits`
</span><span>+    pub font_size_bits: u32,
</span><span>+    /// Antialiasing method
</span><span>+    pub font_smoothing: FontSmoothing,
</span><span>+}
</span><span> 
</span><span> impl From<&TextFont> for FontAtlasKey {
</span><span>     fn from(font: &TextFont) -> Self {
</span><span>-        FontAtlasKey(
</span><span>-            font.font.id(),
</span><span>-            font.font_size.to_bits(),
</span><span>-            font.font_smoothing,
</span><span>-        )
</span><span>+        Self {
</span><span>+            id: font.font.id(),
</span><span>+            font_size_bits: font.font_size.to_bits(),
</span><span>+            font_smoothing: font.font_smoothing,
</span><span>+        }
</span><span>     }
</span><span> }
</span><span> 
</span><span>@@ -39,7 +46,7 @@ pub fn free_unused_font_atlases_system(
</span><span> ) {
</span><span>     for event in font_events.read() {
</span><span>         if let AssetEvent::Removed { id } = event {
</span><span>-            font_atlas_sets.retain(|key, _| key.0 != *id);
</span><span>+            font_atlas_sets.retain(|key, _| key.id != *id);
</span><span>         }
</span><span>     }
</span><span> }
</span><span>diff --git a/crates/bevy_text/src/pipeline.rs b/crates/bevy_text/src/pipeline.rs
</span><span>index 720436f678367..665c8bd1e14b6 100644
</span><span>--- a/crates/bevy_text/src/pipeline.rs
</span><span>+++ b/crates/bevy_text/src/pipeline.rs
</span><span>@@ -412,11 +412,11 @@ impl TextPipeline {
</span><span>                     let physical_glyph = layout_glyph.physical((0., 0.), 1.);
</span><span> 
</span><span>                     let font_atlases = font_atlas_set
</span><span>-                        .entry(FontAtlasKey(
</span><span>-                            font_id,
</span><span>-                            physical_glyph.cache_key.font_size_bits,
</span><span>+                        .entry(FontAtlasKey {
</span><span>+                            id: font_id,
</span><span>+                            font_size_bits: physical_glyph.cache_key.font_size_bits,
</span><span>                             font_smoothing,
</span><span>-                        ))
</span><span>+                        })
</span><span>                         .or_default();
</span><span> 
</span><span>                     let atlas_info = get_glyph_atlas_info(font_atlases, physical_glyph.cache_key)
</span><span>diff --git a/examples/stress_tests/many_text2d.rs b/examples/stress_tests/many_text2d.rs
</span><span>index d3646c8d2c45d..83c091738053a 100644
</span><span>--- a/examples/stress_tests/many_text2d.rs
</span><span>+++ b/examples/stress_tests/many_text2d.rs
</span><span>@@ -181,7 +181,7 @@ fn print_counts(
</span><span>     let font_id = font.0.id();
</span><span>     let num_atlases = font_atlas_set
</span><span>         .iter()
</span><span>-        .filter(|(key, _)| key.0 == font_id)
</span><span>+        .filter(|(key, _)| key.id == font_id)
</span><span>         .map(|(_, atlases)| atlases.len())
</span><span>         .sum::&LTusize>();
</span><span> 
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22161.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>