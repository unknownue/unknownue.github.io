diff --git a/crates/bevy_solari/src/realtime/node.rs b/crates/bevy_solari/src/realtime/node.rs
index 9e280cd0e1416..ac8fc69456e63 100644
--- a/crates/bevy_solari/src/realtime/node.rs
+++ b/crates/bevy_solari/src/realtime/node.rs
@@ -240,7 +240,6 @@ impl ViewNode for SolariLightingNode {
             label: Some("solari_lighting"),
             timestamp_writes: None,
         });
-        let pass_span = diagnostics.pass_span(&mut pass, "solari_lighting");
 
         let dx = solari_lighting_resources.view_size.x.div_ceil(8);
         let dy = solari_lighting_resources.view_size.y.div_ceil(8);
@@ -262,12 +261,16 @@ impl ViewNode for SolariLightingNode {
             pass.dispatch_workgroups(dx, dy, 1);
         }
 
+        let d = diagnostics.time_span(&mut pass, "solari_lighting/presample_light_tiles");
         pass.set_pipeline(presample_light_tiles_pipeline);
         pass.set_push_constants(
             0,
             bytemuck::cast_slice(&[frame_index, solari_lighting.reset as u32]),
         );
         pass.dispatch_workgroups(LIGHT_TILE_BLOCKS as u32, 1, 1);
+        d.end(&mut pass);
+
+        let d = diagnostics.time_span(&mut pass, "solari_lighting/world_cache");
 
         pass.set_bind_group(2, &bind_group_world_cache_active_cells_dispatch, &[]);
 
@@ -301,6 +304,10 @@ impl ViewNode for SolariLightingNode {
             0,
         );
 
+        d.end(&mut pass);
+
+        let d = diagnostics.time_span(&mut pass, "solari_lighting/direct_lighting");
+
         pass.set_pipeline(di_initial_and_temporal_pipeline);
         pass.set_push_constants(
             0,
@@ -315,6 +322,10 @@ impl ViewNode for SolariLightingNode {
         );
         pass.dispatch_workgroups(dx, dy, 1);
 
+        d.end(&mut pass);
+
+        let d = diagnostics.time_span(&mut pass, "solari_lighting/diffuse_indirect_lighting");
+
         pass.set_pipeline(gi_initial_and_temporal_pipeline);
         pass.set_push_constants(
             0,
@@ -329,14 +340,16 @@ impl ViewNode for SolariLightingNode {
         );
         pass.dispatch_workgroups(dx, dy, 1);
 
+        d.end(&mut pass);
+
+        let d = diagnostics.time_span(&mut pass, "solari_lighting/specular_indirect_lighting");
         pass.set_pipeline(specular_gi_pipeline);
         pass.set_push_constants(
             0,
             bytemuck::cast_slice(&[frame_index, solari_lighting.reset as u32]),
         );
         pass.dispatch_workgroups(dx, dy, 1);
-
-        pass_span.end(&mut pass);
+        d.end(&mut pass);
 
         Ok(())
     }
diff --git a/crates/bevy_solari/src/realtime/restir_di.wgsl b/crates/bevy_solari/src/realtime/restir_di.wgsl
index b2f4f309cec09..77a36cebd28de 100644
--- a/crates/bevy_solari/src/realtime/restir_di.wgsl
+++ b/crates/bevy_solari/src/realtime/restir_di.wgsl
@@ -96,9 +96,9 @@ fn spatial_and_shade(@builtin(global_invocation_id) global_id: vec3<u32>) {
     let brdf = evaluate_brdf(surface.world_normal, wo, merge_result.wi, surface.material);
 
     var pixel_color = merge_result.selected_sample_radiance * combined_reservoir.unbiased_contribution_weight;
-    pixel_color *= view.exposure;
     pixel_color *= brdf;
     pixel_color += surface.material.emissive;
+    pixel_color *= view.exposure;
     textureStore(view_output, global_id.xy, vec4(pixel_color, 1.0));
 }
 
diff --git a/crates/bevy_solari/src/realtime/restir_gi.wgsl b/crates/bevy_solari/src/realtime/restir_gi.wgsl
index 88ed44f7e3016..8fc3089da0b33 100644
--- a/crates/bevy_solari/src/realtime/restir_gi.wgsl
+++ b/crates/bevy_solari/src/realtime/restir_gi.wgsl
@@ -67,9 +67,19 @@ fn spatial_and_shade(@builtin(global_invocation_id) global_id: vec3<u32>) {
     let spatial = load_spatial_reservoir(global_id.xy, depth, surface.world_position, surface.world_normal, &rng);
     let merge_result = merge_reservoirs(input_reservoir, surface.world_position, surface.world_normal, surface.material.base_color / PI,
         spatial.reservoir, spatial.world_position, spatial.world_normal, spatial.diffuse_brdf, &rng);
-    let combined_reservoir = merge_result.merged_reservoir;
+    var combined_reservoir = merge_result.merged_reservoir;
 
+    // More accuracy, less stability
+#ifndef BIASED_RESAMPLING
     gi_reservoirs_a[pixel_index] = combined_reservoir;
+#endif
+
+    combined_reservoir.unbiased_contribution_weight *= trace_point_visibility(surface.world_position, combined_reservoir.sample_point_world_position);
+
+    // More stability, less accuracy (shadows extend further out than they should)
+#ifdef BIASED_RESAMPLING
+    gi_reservoirs_a[pixel_index] = combined_reservoir;
+#endif
 
     let brdf = evaluate_diffuse_brdf(surface.material.base_color, surface.material.metallic);
 
@@ -163,10 +173,7 @@ fn load_spatial_reservoir(pixel_id: vec2<u32>, depth: f32, world_position: vec3<
         }
 
         let spatial_pixel_index = spatial_pixel_id.x + spatial_pixel_id.y * u32(view.main_pass_viewport.z);
-        var spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
-
-        spatial_reservoir.radiance *= trace_point_visibility(world_position, spatial_reservoir.sample_point_world_position);
-
+        let spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
         return NeighborInfo(spatial_reservoir, spatial_surface.world_position, spatial_surface.world_normal, spatial_diffuse_brdf);
     }
 
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 6449b40d2bb66..6bc8552bfec16 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -4,15 +4,21 @@ use argh::FromArgs;
 use bevy::{
     camera::CameraMainTextureUsages,
     camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
+    diagnostic::{Diagnostic, DiagnosticPath, DiagnosticsStore},
     gltf::GltfMaterialName,
+    image::{ImageAddressMode, ImageLoaderSettings},
+    mesh::VertexAttributeValues,
+    post_process::bloom::Bloom,
     prelude::*,
-    render::render_resource::TextureUsages,
+    render::{diagnostic::RenderDiagnosticsPlugin, render_resource::TextureUsages},
     scene::SceneInstanceReady,
     solari::{
         pathtracer::{Pathtracer, PathtracingPlugin},
         prelude::{RaytracingMesh3d, SolariLighting, SolariPlugins},
     },
 };
+use rand::{Rng, SeedableRng};
+use rand_chacha::ChaCha8Rng;
 use std::f32::consts::PI;
 
 #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
@@ -26,6 +32,9 @@ struct Args {
     /// use the reference pathtracer instead of the realtime lighting system.
     #[argh(switch)]
     pathtracer: Option<bool>,
+    /// stress test a scene with many lights.
+    #[argh(switch)]
+    many_lights: Option<bool>,
 }
 
 fn main() {
@@ -38,21 +47,34 @@ fn main() {
         "5417916c-0291-4e3f-8f65-326c1858ab96" // Don't copy paste this - generate your own UUID!
     )));
 
-    app.add_plugins((DefaultPlugins, SolariPlugins, FreeCameraPlugin))
-        .insert_resource(args)
-        .add_systems(Startup, setup);
+    app.add_plugins((
+        DefaultPlugins,
+        SolariPlugins,
+        FreeCameraPlugin,
+        RenderDiagnosticsPlugin,
+    ))
+    .insert_resource(args);
+
+    if args.many_lights == Some(true) {
+        app.add_systems(Startup, setup_many_lights);
+    } else {
+        app.add_systems(Startup, setup_pica_pica);
+    }
 
     if args.pathtracer == Some(true) {
         app.add_plugins(PathtracingPlugin);
     } else {
-        app.add_systems(Update, (pause_scene, toggle_lights, patrol_path));
-        app.add_systems(PostUpdate, update_text);
+        if args.many_lights != Some(true) {
+            app.add_systems(Update, (pause_scene, toggle_lights, patrol_path))
+                .add_systems(PostUpdate, update_control_text);
+        }
+        app.add_systems(PostUpdate, update_performance_text);
     }
 
     app.run();
 }
 
-fn setup(
+fn setup_pica_pica(
     mut commands: Commands,
     asset_server: Res<AssetServer>,
     args: Res<Args>,
@@ -145,13 +167,203 @@ fn setup(
     }
 
     commands.spawn((
+        ControlText,
         Text::default(),
         Node {
             position_type: PositionType::Absolute,
-            bottom: Val::Px(12.0),
-            left: Val::Px(12.0),
+            bottom: px(12.0),
+            left: px(12.0),
+            ..default()
+        },
+    ));
+
+    commands.spawn((
+        Node {
+            position_type: PositionType::Absolute,
+            right: px(0.0),
+            padding: px(4.0).all(),
+            border_radius: BorderRadius::bottom_left(px(4.0)),
+            ..default()
+        },
+        BackgroundColor(Color::srgba(0.10, 0.10, 0.10, 0.8)),
+        children![(
+            PerformanceText,
+            Text::default(),
+            TextFont {
+                font_size: 8.0,
+                ..default()
+            },
+        )],
+    ));
+}
+
+fn setup_many_lights(
+    mut commands: Commands,
+    asset_server: Res<AssetServer>,
+    mut meshes: ResMut<Assets<Mesh>>,
+    mut materials: ResMut<Assets<StandardMaterial>>,
+    args: Res<Args>,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] dlss_rr_supported: Option<
+        Res<DlssRayReconstructionSupported>,
+    >,
+) {
+    let mut rng = ChaCha8Rng::seed_from_u64(42);
+
+    let mut plane_mesh = Plane3d::default()
+        .mesh()
+        .size(40.0, 40.0)
+        .build()
+        .with_generated_tangents()
+        .unwrap();
+    match plane_mesh.attribute_mut(Mesh::ATTRIBUTE_UV_0).unwrap() {
+        VertexAttributeValues::Float32x2(items) => {
+            items.iter_mut().flatten().for_each(|x| *x *= 3.0);
+        }
+        _ => unreachable!(),
+    }
+    let plane_mesh = meshes.add(plane_mesh);
+    let cube_mesh = meshes.add(
+        Cuboid::default()
+            .mesh()
+            .build()
+            .with_generated_tangents()
+            .unwrap(),
+    );
+    let sphere_mesh = meshes.add(
+        Sphere::default()
+            .mesh()
+            .build()
+            .with_generated_tangents()
+            .unwrap(),
+    );
+
+    commands
+        .spawn((
+            RaytracingMesh3d(plane_mesh.clone()),
+            MeshMaterial3d(materials.add(StandardMaterial {
+                base_color_texture: Some(
+                    asset_server.load_with_settings::<Image, ImageLoaderSettings>(
+                        "textures/uv_checker_bw.png",
+                        |settings| {
+                            settings
+                                .sampler
+                                .get_or_init_descriptor()
+                                .set_address_mode(ImageAddressMode::Repeat);
+                        },
+                    ),
+                ),
+                perceptual_roughness: 0.0,
+                ..default()
+            })),
+        ))
+        .insert_if(Mesh3d(plane_mesh), || args.pathtracer != Some(true));
+
+    for _ in 0..200 {
+        commands
+            .spawn((
+                RaytracingMesh3d(cube_mesh.clone()),
+                MeshMaterial3d(materials.add(StandardMaterial {
+                    base_color: Color::srgb(rng.random(), rng.random(), rng.random()),
+                    perceptual_roughness: rng.random(),
+                    ..default()
+                })),
+                Transform::default()
+                    .with_scale(Vec3 {
+                        x: rng.random_range(0.2..=2.0),
+                        y: rng.random_range(0.2..=2.0),
+                        z: rng.random_range(0.2..=2.0),
+                    })
+                    .with_translation(Vec3::new(
+                        rng.random_range(-18.0..=18.0),
+                        0.2,
+                        rng.random_range(-18.0..=18.0),
+                    )),
+            ))
+            .insert_if(Mesh3d(cube_mesh.clone()), || args.pathtracer != Some(true));
+    }
+
+    for _ in 0..100 {
+        commands
+            .spawn((
+                RaytracingMesh3d(sphere_mesh.clone()),
+                MeshMaterial3d(
+                    materials.add(StandardMaterial {
+                        emissive: Color::linear_rgb(
+                            rng.random::<f32>() * 20000.0,
+                            rng.random::<f32>() * 20000.0,
+                            rng.random::<f32>() * 20000.0,
+                        )
+                        .into(),
+                        ..default()
+                    }),
+                ),
+                Transform::default().with_translation(Vec3::new(
+                    rng.random_range(-18.0..=18.0),
+                    rng.random_range(6.0..=9.0),
+                    rng.random_range(-18.0..=18.0),
+                )),
+            ))
+            .insert_if(Mesh3d(sphere_mesh.clone()), || {
+                args.pathtracer != Some(true)
+            });
+    }
+
+    let mut camera = commands.spawn((
+        Camera3d::default(),
+        Camera {
+            clear_color: ClearColorConfig::Custom(Color::BLACK),
+            ..default()
+        },
+        FreeCamera {
+            walk_speed: 3.0,
+            run_speed: 10.0,
+            ..Default::default()
+        },
+        Transform::from_translation(Vec3::new(0.0919233, 7.5015035, 28.449198)).with_rotation(
+            Quat::from_xyzw(-0.18394549, 0.0019948867, 0.0003733214, 0.98293436),
+        ),
+        // Msaa::Off and CameraMainTextureUsages with STORAGE_BINDING are required for Solari
+        CameraMainTextureUsages::default().with(TextureUsages::STORAGE_BINDING),
+        Msaa::Off,
+        Bloom {
+            intensity: 0.1,
+            ..Bloom::NATURAL
+        },
+    ));
+
+    if args.pathtracer == Some(true) {
+        camera.insert(Pathtracer::default());
+    } else {
+        camera.insert(SolariLighting::default());
+    }
+
+    // Using DLSS Ray Reconstruction for denoising (and cheaper rendering via upscaling) is _highly_ recommended when using Solari
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    if dlss_rr_supported.is_some() {
+        camera.insert(Dlss::<DlssRayReconstructionFeature> {
+            perf_quality_mode: Default::default(),
+            reset: Default::default(),
+            _phantom_data: Default::default(),
+        });
+    }
+
+    commands.spawn((
+        Node {
+            position_type: PositionType::Absolute,
+            right: px(0.0),
+            padding: px(4.0).all(),
+            border_radius: BorderRadius::bottom_left(px(4.0)),
             ..default()
         },
+        BackgroundColor(Color::srgba(0.10, 0.10, 0.10, 0.8)),
+        children![(
+            PerformanceText,
+            Text::default(),
+            TextFont {
+                font_size: 8.0,
+                ..default()
+            },
+        )],
     ));
 }
 
@@ -305,8 +517,11 @@ fn patrol_path(mut query: Query<(&mut PatrolPath, &mut Transform)>, time: Res<Ti
     }
 }
 
-fn update_text(
-    mut text: Single<&mut Text>,
+#[derive(Component)]
+struct ControlText;
+
+fn update_control_text(
+    mut text: Single<&mut Text, With<ControlText>>,
     robot_light_material: Option<Res<RobotLightMaterial>>,
     materials: Res<Assets<StandardMaterial>>,
     directional_light: Query<Entity, With<DirectionalLight>>,
@@ -351,3 +566,45 @@ fn update_text(
     text.0
         .push_str("\nDenoising: App not compiled with DLSS support");
 }
+
+#[derive(Component)]
+struct PerformanceText;
+
+fn update_performance_text(
+    mut text: Single<&mut Text, With<PerformanceText>>,
+    diagnostics: Res<DiagnosticsStore>,
+) {
+    text.0.clear();
+
+    let mut total = 0.0;
+    let mut add_diagnostic = |name: &str, path: &'static str| {
+        let path = DiagnosticPath::new(path);
+        if let Some(average) = diagnostics.get(&path).and_then(Diagnostic::average) {
+            text.push_str(&format!("{name:17}  {average:.2} ms\n"));
+            total += average;
+        }
+    };
+
+    (add_diagnostic)(
+        "Light tiles",
+        "render/solari_lighting/presample_light_tiles/elapsed_gpu",
+    );
+    (add_diagnostic)(
+        "World cache",
+        "render/solari_lighting/world_cache/elapsed_gpu",
+    );
+    (add_diagnostic)(
+        "Direct lighting",
+        "render/solari_lighting/direct_lighting/elapsed_gpu",
+    );
+    (add_diagnostic)(
+        "Diffuse indirect",
+        "render/solari_lighting/diffuse_indirect_lighting/elapsed_gpu",
+    );
+    (add_diagnostic)(
+        "Specular indirect",
+        "render/solari_lighting/specular_indirect_lighting/elapsed_gpu",
+    );
+    text.push_str(&format!("{:17}     TODO\n", "DLSS-RR"));
+    text.push_str(&format!("\n{:17}  {total:.2} ms", "Total"));
+}
