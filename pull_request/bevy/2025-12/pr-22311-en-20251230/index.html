<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22311 Solari: Specular path spread heuristic
        
    </title><meta content="#22311 Solari: Specular path spread heuristic" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22311-zh-cn-20251230>中文</a></div></div><div class=pr-content><h1 id=solari-specular-path-spread-heuristic>Solari: Specular path spread heuristic</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari: Specular path spread heuristic<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22311<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Performance, S-Ready-For-Final-Review, C-Refinement<li><strong>Created</strong>: 2025-12-30T02:00:30Z<li><strong>Merged</strong>: 2025-12-30T05:40:56Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><p>Currently solari’s specular GI conditionally terminates in the world cache based on the roughness of a surface.<p>This PR changes that. Now, solari tracks the spread of the full path to the camera, and terminates in the world cache once the spread is wide enough.<p>On the plus side this gives<ul><li>A good bit better performance<li>More stable / higher quality lighting sometimes</ul><p>On the downside:<ul><li>Transitions between world cache LODs tend to show up in rough reflections. Unlike ReSTIR GI, there’s currently no temporal reservoirs to hide it.<li>Slightly more light leaks / less accuracy sometimes</ul><p>Overall I think it’s a worthwhile change.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses an optimization opportunity in Bevy’s Solari real-time global illumination system, specifically in how specular GI paths are terminated when querying the world cache. The previous implementation used a simple heuristic: if a surface’s roughness exceeded a fixed threshold (<code>0.4</code>), the path would terminate early and sample from the world cache instead of continuing to trace rays.<p>The problem with this approach is that it doesn’t account for the actual path geometry. A surface might be rough, but if the ray path from the camera to that surface is short, the spread of potential rays might still be small enough to warrant more accurate tracing rather than relying on the world cache’s lower-resolution data. Conversely, a less rough surface viewed from a distance might have a sufficiently wide path spread to benefit from early termination.<p>The solution implements a more physically-based heuristic from the paper “Real-Time Geometric Glinty Reflections using Spherical Caps” by Müller et al. (2021). Instead of checking surface roughness alone, the code now tracks the cumulative spread of the entire path from camera to surface. When this spread exceeds a threshold relative to the world cache’s cell size, the path terminates and uses cached illumination.<p>The implementation required several key changes. First, the shader needed to import <code>get_cell_size</code> to understand the world cache’s spatial resolution. More importantly, the algorithm now calculates <code>a0</code> - a measure of acceptable spread based on camera distance and surface orientation:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>let cos_theta = saturate(dot(wo, surface.world_normal));
</span><span>var a0 = dot(wo_unnormalized, wo_unnormalized) / (4.0 * PI * cos_theta);
</span><span>a0 *= TERMINATE_IN_WORLD_CACHE_THRESHOLD;
</span></code></pre><p>This <code>a0</code> value represents how much spread can be tolerated before switching to the world cache, scaled by a new, much smaller threshold (<code>0.03</code> compared to the previous <code>0.4</code>).<p>During path tracing, the shader accumulates <code>path_spread</code> using the formula from the paper:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>path_spread += sqrt((ray.t * ray.t) / (p_bounce * wo_tangent.z));
</span></code></pre><p>The termination condition changes from a simple roughness check to comparing this accumulated spread against the cache resolution:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>if path_spread * path_spread > a0 * get_cell_size(ray_hit.world_position, view.world_position) {
</span><span>    // Path spread is wide enough, terminate path in the world cache
</span><span>    // ... use world cache ...
</span><span>    break;
</span><span>}
</span></code></pre><p>This approach is more physically accurate because it considers the actual geometry of the light path rather than just material properties. The performance improvement comes from terminating paths earlier when they’re sufficiently diffuse (in a geometric sense), reducing the number of expensive ray traces. The quality improvement in some cases comes from continuing to trace rays for surfaces that are rough but close to the camera, where the world cache’s lower resolution would be noticeable.<p>The trade-offs are technical but important. Without temporal filtering (which ReSTIR GI has but this implementation doesn’t), transitions between world cache levels of detail become visible in rough reflections. There’s also a slight increase in light leaks because the world cache approximation is less accurate than continued ray tracing. However, the performance gains and overall quality improvements make this a net positive change.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Camera Ray] --> B[Surface Hit]
</span><span>    B --> C{Path Spread Calculation}
</span><span>    C -->|Spread ≤ Threshold| D[Continue Ray Tracing]
</span><span>    C -->|Spread > Threshold| E[Query World Cache]
</span><span>    D --> F[Next Bounce]
</span><span>    F --> C
</span><span>    E --> G[Return Illumination]
</span><span>    
</span><span>    H[Old Approach] --> I{Roughness > 0.4?}
</span><span>    I -->|Yes| E
</span><span>    I -->|No| D
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-specular-gi-wgsl-18-8><code>crates/bevy_solari/src/realtime/specular_gi.wgsl</code> (+18/-8)</h3><p>This is the only file modified in the PR. It contains the core specular global illumination shader for Solari. The changes replace a simple roughness-based termination heuristic with a more sophisticated path-spread calculation based on research from Müller et al.<p><strong>Key modifications:</strong><ol><li><strong>Added import and renamed constant</strong>:</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>#import bevy_solari::world_cache::{query_world_cache, WORLD_CACHE_CELL_LIFETIME}
</span><span>const WORLD_CACHE_TERMINATION_ROUGHNESS_THRESHOLD: f32 = 0.4;
</span><span>
</span><span>// After:
</span><span>#import bevy_solari::world_cache::{query_world_cache, get_cell_size, WORLD_CACHE_CELL_LIFETIME}
</span><span>const TERMINATE_IN_WORLD_CACHE_THRESHOLD: f32 = 0.03;
</span></code></pre><ol start=2><li><strong>Modified path tracing call with new parameters</strong>:</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>radiance = trace_glossy_path(surface.world_position, wi, &rng) / pdf;
</span><span>
</span><span>// After:
</span><span>let cos_theta = saturate(dot(wo, surface.world_normal));
</span><span>var a0 = dot(wo_unnormalized, wo_unnormalized) / (4.0 * PI * cos_theta);
</span><span>a0 *= TERMINATE_IN_WORLD_CACHE_THRESHOLD;
</span><span>radiance = trace_glossy_path(surface.world_position, wi, pdf, a0, &rng) / pdf;
</span></code></pre><ol start=3><li><strong>Updated trace_glossy_path function signature and logic</strong>:</ol><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>fn trace_glossy_path(initial_ray_origin: vec3&LTf32>, initial_wi: vec3&LTf32>, rng: ptr&LTfunction, u32>) -> vec3&LTf32> {
</span><span>    // ...
</span><span>    if ray_hit.material.roughness > WORLD_CACHE_TERMINATION_ROUGHNESS_THRESHOLD && i != 0u {
</span><span>        // Surface is very rough, terminate path in the world cache
</span><span>        // ...
</span><span>    }
</span><span>}
</span><span>
</span><span>// After:
</span><span>fn trace_glossy_path(initial_ray_origin: vec3&LTf32>, initial_wi: vec3&LTf32>, initial_p_bounce: f32, a0: f32, rng: ptr&LTfunction, u32>) -> vec3&LTf32> {
</span><span>    // ...
</span><span>    var path_spread = 0.0;
</span><span>    // ...
</span><span>    // https://d1qx31qr3h6wln.cloudfront.net/publications/mueller21realtime.pdf#subsection.3.4, equation (3)
</span><span>    path_spread += sqrt((ray.t * ray.t) / (p_bounce * wo_tangent.z));
</span><span>    
</span><span>    if path_spread * path_spread > a0 * get_cell_size(ray_hit.world_position, view.world_position) {
</span><span>        // Path spread is wide enough, terminate path in the world cache
</span><span>        // ...
</span><span>    }
</span><span>}
</span></code></pre><p>These changes shift the termination heuristic from a material property (roughness) to a geometric property (path spread), which better matches the underlying physics of light transport and provides better performance-quality trade-offs.<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>Primary Reference</strong>: Müller, T., Rousselle, F., Keller, A., & Novák, J. (2021). “Real-Time Geometric Glinty Reflections using Spherical Caps.” The paper that introduced the path spread heuristic used in this PR. Available at: https://d1qx31qr3h6wln.cloudfront.net/publications/mueller21realtime.pdf</p><li><p><strong>Bevy Solari Documentation</strong>: The Bevy engine’s real-time global illumination system that this PR modifies. Understanding the overall architecture helps contextualize these changes.</p><li><p><strong>ReSTIR GI</strong>: The reservoir-based spatiotemporal importance resampling technique mentioned as a comparison point. This approach uses temporal reservoirs to hide LOD transitions, which the current Solari implementation lacks.</p><li><p><strong>WGSL (WebGPU Shading Language)</strong>: The shading language used for Bevy’s graphics pipelines. Familiarity with WGSL helps understand the implementation details.</p><li><p><strong>Global Illumination Techniques</strong>: Background on path tracing, importance sampling, and caching strategies for real-time GI provides context for why this optimization matters.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22311.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>