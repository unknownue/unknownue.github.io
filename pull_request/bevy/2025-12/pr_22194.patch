diff --git a/crates/bevy_input_focus/src/directional_navigation.rs b/crates/bevy_input_focus/src/directional_navigation.rs
index f35e91e97cb91..5fc6dba2b402a 100644
--- a/crates/bevy_input_focus/src/directional_navigation.rs
+++ b/crates/bevy_input_focus/src/directional_navigation.rs
@@ -9,12 +9,15 @@
 //!
 //! Navigating between focusable entities (commonly UI nodes) is done by
 //! passing a [`CompassOctant`] into the [`navigate`](DirectionalNavigation::navigate) method
-//! from the [`DirectionalNavigation`] system parameter.
+//! from the [`DirectionalNavigation`] system parameter. Under the hood, an entity is found
+//! automatically via brute force search in the desired [`CompassOctant`] direction.
 //!
-//! Under the hood, the [`DirectionalNavigationMap`] stores a directed graph of focusable entities.
-//! Each entity can have up to 8 neighbors, one for each [`CompassOctant`], balancing flexibility and required precision.
+//! If some manual navigation is desired, a [`DirectionalNavigationMap`] will override the brute force
+//! search in a direction for a given entity. The [`DirectionalNavigationMap`] stores a directed graph
+//! of focusable entities. Each entity can have up to 8 neighbors, one for each [`CompassOctant`],
+//! balancing flexibility and required precision.
 //!
-//! # Creating a Navigation Graph
+//! # Setting up Directional Navigation
 //!
 //! ## Automatic Navigation (Recommended)
 //!
@@ -35,9 +38,6 @@
 //! }
 //! ```
 //!
-//! The navigation graph automatically updates when UI elements move, resize, or are added/removed.
-//! Configure the behavior using the [`AutoNavigationConfig`] resource.
-//!
 //! ## Manual Navigation
 //!
 //! You can also manually define navigation connections using methods like
@@ -46,7 +46,7 @@
 //!
 //! ## Combining Automatic and Manual
 //!
-//! Manual edges always take precedence over auto-generated ones, allowing you to use
+//! Following manual edges always take precedence, allowing you to use
 //! automatic navigation for most UI elements while overriding specific connections for
 //! special cases like wrapping menus or cross-layer navigation.
 //!
@@ -67,7 +67,7 @@ use bevy_ecs::{
     system::SystemParam,
 };
 use bevy_math::{CompassOctant, Dir2, Vec2};
-use bevy_ui::{ComputedNode, UiGlobalTransform, UiSystems};
+use bevy_ui::{ComputedNode, UiGlobalTransform};
 use thiserror::Error;
 
 use crate::InputFocus;
@@ -75,34 +75,21 @@ use crate::InputFocus;
 #[cfg(feature = "bevy_reflect")]
 use bevy_reflect::{prelude::*, Reflect};
 
-/// A plugin that sets up the directional navigation systems and resources.
+/// A plugin that sets up the directional navigation resources.
 #[derive(Default)]
 pub struct DirectionalNavigationPlugin;
 
 impl Plugin for DirectionalNavigationPlugin {
     fn build(&self, app: &mut App) {
         app.init_resource::<DirectionalNavigationMap>()
-            .init_resource::<AutoNavigationConfig>()
-            .add_systems(
-                PostUpdate,
-                auto_rebuild_ui_navigation_graph
-                    .in_set(UiSystems::PostLayout)
-                    .after(bevy_camera::visibility::VisibilitySystems::VisibilityPropagate),
-            );
+            .init_resource::<AutoNavigationConfig>();
     }
 }
 
-/// Marker component to enable automatic directional navigation graph generation.
-///
-/// Simply add this component to your UI entities and the navigation graph will be
-/// automatically computed and maintained! The [`DirectionalNavigationPlugin`] includes
-/// a built-in system that:
-/// - Detects when nodes with this component change position or size
-/// - Automatically rebuilds navigation edges based on spatial proximity
-/// - Respects manual edges (they always take precedence)
-///
+/// Marker component to enable automatic directional navigation to and from the entity.
 ///
-/// Just add this component to `bevy_ui` entities:
+/// Simply add this component to your UI entities so that the navigation algorithm will
+/// consider this entity in its calculations:
 ///
 /// ```rust
 /// # use bevy_ecs::prelude::*;
@@ -115,11 +102,9 @@ impl Plugin for DirectionalNavigationPlugin {
 /// }
 /// ```
 ///
-/// The navigation graph updates automatically when nodes move, resize, or are added/removed.
-///
 /// # Multi-Layer UIs and Z-Index
 ///
-/// **Important**: The automatic navigation system is currently **z-index agnostic** and treats
+/// **Important**: Automatic navigation is currently **z-index agnostic** and treats
 /// all entities with `AutoDirectionalNavigation` as a flat set, regardless of which UI layer
 /// or z-index they belong to. This means navigation may jump between different layers (e.g.,
 /// from a background menu to an overlay popup).
@@ -180,7 +165,7 @@ pub struct AutoDirectionalNavigation {
     pub respect_tab_order: bool,
 }
 
-/// Configuration resource for automatic directional navigation graph generation.
+/// Configuration resource for automatic navigation.
 ///
 /// This resource controls how the automatic navigation system computes which
 /// nodes should be connected in each direction.
@@ -285,7 +270,7 @@ impl NavNeighbors {
     }
 }
 
-/// A resource that stores the traversable graph of focusable entities.
+/// A resource that stores the manually specified traversable graph of focusable entities.
 ///
 /// Each entity can have up to 8 neighbors, one for each [`CompassOctant`].
 ///
@@ -297,7 +282,8 @@ impl NavNeighbors {
 ///   although looping around the edges of the screen is also acceptable.
 /// - **Not self-connected**: An entity should not be a neighbor of itself; use [`None`] instead.
 ///
-/// For now, this graph must be built manually, and the developer is responsible for ensuring that it meets the above criteria.
+/// This graph must be built and maintained manually, and the developer is responsible for ensuring that it meets the above criteria.
+/// Notably, if the developer adds or removes the navigability of an entity, the developer should update the map as necessary.
 #[derive(Resource, Debug, Default, Clone, PartialEq)]
 #[cfg_attr(
     feature = "bevy_reflect",
@@ -313,8 +299,6 @@ pub struct DirectionalNavigationMap {
 }
 
 impl DirectionalNavigationMap {
-    /// Adds a new entity to the navigation map, overwriting any existing neighbors for that entity.
-    ///
     /// Removes an entity from the navigation map, including all connections to and from it.
     ///
     /// Note that this is an O(n) operation, where n is the number of entities in the map,
@@ -421,14 +405,35 @@ impl DirectionalNavigationMap {
 
 /// A system parameter for navigating between focusable entities in a directional way.
 #[derive(SystemParam, Debug)]
-pub struct DirectionalNavigation<'w> {
+pub struct DirectionalNavigation<'w, 's> {
     /// The currently focused entity.
     pub focus: ResMut<'w, InputFocus>,
-    /// The navigation map containing the connections between entities.
+    /// The directional navigation map containing manually defined connections between entities.
     pub map: Res<'w, DirectionalNavigationMap>,
+    /// Configuration for the automated portion of the navigation algorithm.
+    pub config: Res<'w, AutoNavigationConfig>,
+    /// The entities which can possibly be navigated to automatically.
+    navigable_entities_query: Query<
+        'w,
+        's,
+        (
+            Entity,
+            &'static ComputedNode,
+            &'static UiGlobalTransform,
+            &'static InheritedVisibility,
+        ),
+        With<AutoDirectionalNavigation>,
+    >,
+    /// A query used to get the [`FocusableArea`] for a given entity to be used in automatic navigation.
+    focusable_area_query: Query<
+        'w,
+        's,
+        (Entity, &'static ComputedNode, &'static UiGlobalTransform),
+        With<AutoDirectionalNavigation>,
+    >,
 }
 
-impl DirectionalNavigation<'_> {
+impl<'w, 's> DirectionalNavigation<'w, 's> {
     /// Navigates to the neighbor in a given direction from the current focus, if any.
     ///
     /// Returns the new focus if successful.
@@ -440,9 +445,20 @@ impl DirectionalNavigation<'_> {
         direction: CompassOctant,
     ) -> Result<Entity, DirectionalNavigationError> {
         if let Some(current_focus) = self.focus.0 {
+            // Respect manual edges first
             if let Some(new_focus) = self.map.get_neighbor(current_focus, direction) {
                 self.focus.set(new_focus);
                 Ok(new_focus)
+            } else if let Some(origin) = self.entity_to_focusable_area(current_focus)
+                && let Some(new_focus) = find_best_candidate(
+                    &origin,
+                    direction,
+                    &self.get_navigable_nodes(),
+                    &self.config,
+                )
+            {
+                self.focus.set(new_focus);
+                Ok(new_focus)
             } else {
                 Err(DirectionalNavigationError::NoNeighborInDirection {
                     current_focus,
@@ -453,6 +469,42 @@ impl DirectionalNavigation<'_> {
             Err(DirectionalNavigationError::NoFocus)
         }
     }
+
+    /// Returns a vec of [`FocusableArea`] representing nodes that are eligible to be automatically navigated to.
+    fn get_navigable_nodes(&self) -> Vec<FocusableArea> {
+        self.navigable_entities_query
+            .iter()
+            .filter_map(|(entity, computed, transform, inherited_visibility)| {
+                // Skip hidden or zero-size nodes
+                if computed.is_empty() || !inherited_visibility.get() {
+                    return None;
+                }
+
+                let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
+                Some(FocusableArea {
+                    entity,
+                    position: translation,
+                    size: computed.size(),
+                })
+            })
+            .collect()
+    }
+
+    /// Gets the [`FocusableArea`] of the provided entity, if it exists.
+    ///
+    /// Returns None if there was a [`QueryEntityError`](bevy_ecs::query::QueryEntityError).
+    fn entity_to_focusable_area(&self, entity: Entity) -> Option<FocusableArea> {
+        self.focusable_area_query
+            .get(entity)
+            .map_or(None, |(entity, computed, transform)| {
+                let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
+                Some(FocusableArea {
+                    entity,
+                    position: translation,
+                    size: computed.size(),
+                })
+            })
+    }
 }
 
 /// An error that can occur when navigating between focusable entities using [directional navigation](crate::directional_navigation).
@@ -473,7 +525,7 @@ pub enum DirectionalNavigationError {
 
 /// A focusable area with position and size information.
 ///
-/// This struct represents a UI element in the automatic directional navigation system,
+/// This struct represents a UI element used during automatic directional navigation,
 /// containing its entity ID, center position, and size for spatial navigation calculations.
 ///
 /// The term "focusable area" avoids confusion with UI [`Node`](bevy_ui::Node) components.
@@ -624,11 +676,49 @@ fn score_candidate(
     distance + alignment_penalty
 }
 
+/// Finds the best entity to navigate to from the origin towards the given direction.
+///
+/// For details on what "best" means here, refer to [`AutoNavigationConfig`].
+fn find_best_candidate(
+    origin: &FocusableArea,
+    direction: CompassOctant,
+    candidates: &[FocusableArea],
+    config: &AutoNavigationConfig,
+) -> Option<Entity> {
+    // Find best candidate in this direction
+    let mut best_candidate = None;
+    let mut best_score = f32::INFINITY;
+
+    for candidate in candidates {
+        // Skip self
+        if candidate.entity == origin.entity {
+            continue;
+        }
+
+        // Score the candidate
+        let score = score_candidate(
+            origin.position,
+            origin.size,
+            candidate.position,
+            candidate.size,
+            direction,
+            config,
+        );
+
+        if score < best_score {
+            best_score = score;
+            best_candidate = Some(candidate.entity);
+        }
+    }
+
+    best_candidate
+}
+
 /// Automatically generates directional navigation edges for a collection of nodes.
 ///
 /// This function takes a slice of navigation nodes with their positions and sizes, and populates
 /// the navigation map with edges to the nearest neighbor in each compass direction.
-/// Manual edges in the map are preserved and not overwritten.
+/// Manual edges already in the map are preserved and not overwritten.
 ///
 /// # Arguments
 ///
@@ -679,30 +769,7 @@ pub fn auto_generate_navigation_edges(
             }
 
             // Find best candidate in this direction
-            let mut best_candidate = None;
-            let mut best_score = f32::INFINITY;
-
-            for candidate in nodes {
-                // Skip self
-                if candidate.entity == origin.entity {
-                    continue;
-                }
-
-                // Score the candidate
-                let score = score_candidate(
-                    origin.position,
-                    origin.size,
-                    candidate.position,
-                    candidate.size,
-                    octant,
-                    config,
-                );
-
-                if score < best_score {
-                    best_score = score;
-                    best_candidate = Some(candidate.entity);
-                }
-            }
+            let best_candidate = find_best_candidate(origin, octant, nodes, config);
 
             // Add edge if we found a valid candidate
             if let Some(neighbor) = best_candidate {
@@ -712,74 +779,6 @@ pub fn auto_generate_navigation_edges(
     }
 }
 
-/// Built-in system that automatically rebuilds the navigation graph for `bevy_ui` nodes.
-///
-/// This system runs in `PostUpdate` in the `UiSystems::PostLayout` system set and automatically updates
-/// the navigation graph when nodes with [`AutoDirectionalNavigation`] component change
-/// their position or size.
-///
-/// # How it works
-///
-/// 1. Detects nodes with [`AutoDirectionalNavigation`] that have changed
-/// 2. Extracts position/size from [`ComputedNode`] and [`UiGlobalTransform`]
-/// 3. Calls [`auto_generate_navigation_edges`] to rebuild connections
-///
-/// This system is automatically added by [`DirectionalNavigationPlugin`], so users
-/// only need to add the [`AutoDirectionalNavigation`] component to their UI entities.
-///
-/// # Note
-///
-/// This system only works with `bevy_ui` nodes. For custom UI systems, call
-/// [`auto_generate_navigation_edges`] directly in your own system.
-fn auto_rebuild_ui_navigation_graph(
-    mut directional_nav_map: ResMut<DirectionalNavigationMap>,
-    config: Res<AutoNavigationConfig>,
-    changed_nodes: Query<
-        (),
-        (
-            With<AutoDirectionalNavigation>,
-            Or<(
-                Added<AutoDirectionalNavigation>,
-                Changed<ComputedNode>,
-                Changed<UiGlobalTransform>,
-                Changed<InheritedVisibility>,
-            )>,
-        ),
-    >,
-    all_nodes: Query<
-        (
-            Entity,
-            &ComputedNode,
-            &UiGlobalTransform,
-            &InheritedVisibility,
-        ),
-        With<AutoDirectionalNavigation>,
-    >,
-) {
-    if changed_nodes.is_empty() {
-        return;
-    }
-
-    let nodes: Vec<FocusableArea> = all_nodes
-        .iter()
-        .filter_map(|(entity, computed, transform, inherited_visibility)| {
-            // Skip hidden or zero-size nodes
-            if computed.is_empty() || !inherited_visibility.get() {
-                return None;
-            }
-
-            let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
-            Some(FocusableArea {
-                entity,
-                position: translation,
-                size: computed.size(),
-            })
-        })
-        .collect();
-
-    auto_generate_navigation_edges(&mut directional_nav_map, &nodes, &config);
-}
-
 #[cfg(test)]
 mod tests {
     use alloc::vec;
@@ -918,7 +917,7 @@ mod tests {
     }
 
     #[test]
-    fn nav_with_system_param() {
+    fn manual_nav_with_system_param() {
         let mut world = World::new();
         let a = world.spawn_empty().id();
         let b = world.spawn_empty().id();
@@ -933,6 +932,9 @@ mod tests {
         focus.set(a);
         world.insert_resource(focus);
 
+        let config = AutoNavigationConfig::default();
+        world.insert_resource(config);
+
         assert_eq!(world.resource::<InputFocus>().get(), Some(a));
 
         fn navigate_east(mut nav: DirectionalNavigation) {
