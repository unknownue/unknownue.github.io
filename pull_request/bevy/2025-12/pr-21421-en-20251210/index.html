<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21421 increase morph targets to 256
        
    </title><meta content="#21421 increase morph targets to 256" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-10</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-21421-zh-cn-20251210>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>increase morph targets to 256<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: increase morph targets to 256<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21421<li><strong>Author</strong>: robtfm<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, C-Usability, S-Ready-For-Final-Review, A-Animation, X-Controversial<li><strong>Created</strong>: 2025-10-06T11:57:31Z<li><strong>Merged</strong>: 2025-12-10T21:52:21Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>our current morph target / blend shape limit is 64 per model, documented as “to support all hardware”. many assets use more than this (“over a hundred” is common), so i’d like to increase this limit.<p>the relevant hardware constraint is uniform buffer size (usage in morph.wgsl). morph targets use 4 bytes per entry, and wgpu’s downlevel uniform buffer size limit is 16k so we have a lot of room from the 256 bytes we are currently limiting to, while still supporting the vast majority of hardware.<h2 id=solution>Solution</h2><p>increase the limit to 256 targets / 1k.<p>we also increase the input to the buffer to this 1k size: this was not done previously but worked as long as the min buffer alignment was 256 (which it probably always is at the moment) as it was sized up to match alignment previously.<p>there may be a slight performance impact from using a larger size in all cases but it should be negligible.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a practical limitation in Bevy’s morph target system. The existing code imposed a hard limit of 64 morph targets per model, which was documented as necessary to support all hardware. However, many real-world assets use more than 64 morph targets, with “over a hundred” being common in production scenarios. This limitation prevented users from importing complex character models with detailed facial animations or other morph-based effects.<p>The core constraint wasn’t about GPU computation capabilities, but rather about data transfer and storage. Morph target weights are passed to the GPU via uniform buffers in the rendering pipeline. The previous implementation allocated space for exactly 64 weights in these buffers, which translated to 256 bytes (64 weights × 4 bytes per weight). This conservative limit was set to ensure compatibility with hardware that might have restrictive uniform buffer size limits.<p>The developer investigated the actual hardware constraints and found that the downlevel uniform buffer size limit in wgpu (the WebGPU implementation used by Bevy) is 16KB. This meant the system had significant headroom - the 256-byte allocation was using only a small fraction of the available buffer space. Given that many assets required more than 64 morph targets, increasing the limit to 256 targets (1024 bytes) was a reasonable compromise that would accommodate most real-world use cases while remaining well within hardware limitations.<p>The implementation required changes in three key areas. First, the constant defining the maximum number of morph weights was updated from 64 to 256 in the mesh module. Second, the shader code needed adjustment because morph weights are packed into <code>vec4&LTf32></code> arrays (four weights per vector element). With 256 weights, the array size changed from 16 elements (64 ÷ 4) to 64 elements (256 ÷ 4). Third, a subtle bug was fixed in the buffer extraction logic. Previously, the code only took the available weights up to the maximum, but didn’t ensure the buffer was properly padded to the expected size. This worked by accident because of buffer alignment requirements (typically 256 bytes), but with the increased size, proper padding became necessary to avoid reading uninitialized memory.<p>The fix involved modifying the weight extraction to pad with zeros when there are fewer weights than the maximum. This ensures the uniform buffer always contains exactly <code>MAX_MORPH_WEIGHTS</code> values, regardless of how many weights the actual mesh uses. This is important for shader stability and prevents undefined behavior.<p>While increasing the buffer size from 256 bytes to 1024 bytes might have minor performance implications due to increased memory bandwidth, the impact is negligible for most applications. The trade-off is clearly beneficial: users gain the ability to use more realistic assets with complex morph target animations, while the system remains compatible with virtually all hardware.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[MorphWeights Component] --> B[extract_morphs System]
</span><span>    B --> C[Uniform Buffer: MorphWeights struct]
</span><span>    C --> D[WGSL Shader: mesh_types.wgsl]
</span><span>    
</span><span>    subgraph "Constant Definition"
</span><span>        E[bevy_mesh/src/morph.rs&LTbr/>MAX_MORPH_WEIGHTS: 64 → 256]
</span><span>    end
</span><span>    
</span><span>    subgraph "Data Flow"
</span><span>        B --> F[Padding with zeros]
</span><span>        F --> C
</span><span>    end
</span><span>    
</span><span>    subgraph "Shader Update"
</span><span>        D --> G[array&LTvec4&LTf32>, 16u> → array&LTvec4&LTf32>, 64u>]
</span><span>    end
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=1-crates-bevy-mesh-src-morph-rs-5-1>1. <code>crates/bevy_mesh/src/morph.rs</code> (+5/-1)</h3><p>This file defines the maximum number of morph weights constant. The change increases the limit from 64 to 256, which is the central change of the PR.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub const </span><span style=color:#ff8f40>MAX_MORPH_WEIGHTS</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>64</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const </span><span style=color:#ff8f40>MAX_MORPH_WEIGHTS</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>256</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=2-crates-bevy-pbr-src-render-mesh-types-wgsl-1-1>2. <code>crates/bevy_pbr/src/render/mesh_types.wgsl</code> (+1/-1)</h3><p>This WGSL shader file defines the struct that stores morph weights in GPU memory. Since weights are packed into <code>vec4&LTf32></code> arrays (4 weights per vector), the array size changes from 16 to 64 to accommodate 256 total weights.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>weights: array&LTvec4&LTf32>, 16u>, // 16 = 64 / 4 (64 = MAX_MORPH_WEIGHTS)
</span><span>
</span><span>// After:
</span><span>weights: array&LTvec4&LTf32>, 64u>, // 64 = 256 / 4 (256 = MAX_MORPH_WEIGHTS)
</span></code></pre><h3 id=3-crates-bevy-pbr-src-render-morph-rs-5-1>3. <code>crates/bevy_pbr/src/render/morph.rs</code> (+5/-1)</h3><p>This file contains the system that extracts morph weights and prepares them for the GPU. The change ensures the buffer is always padded to <code>MAX_MORPH_WEIGHTS</code> with zeros, which is necessary for consistent shader behavior.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> legal_weights </span><span style=color:#ed9366>=</span><span> weights</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>(</span><span style=color:#ff8f40>MAX_MORPH_WEIGHTS</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>copied</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> legal_weights </span><span style=color:#ed9366>=</span><span> weights
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>chain</span><span>(iter</span><span style=color:#ed9366>::</span><span>repeat(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>0.0</span><span>))
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>(</span><span style=color:#ff8f40>MAX_MORPH_WEIGHTS</span><span>)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>copied</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p>The key addition is <code>chain(iter::repeat(&0.0))</code>, which creates an infinite iterator of zeros that gets appended to the actual weights. The <code>take(MAX_MORPH_WEIGHTS)</code> then ensures we always have exactly 256 values (or whatever the maximum is set to). This padding is crucial because the shader expects a fixed-size array, and reading beyond initialized memory would cause undefined behavior.<h2 id=further-reading>Further Reading</h2><ol><li><p><strong>WebGPU Uniform Buffer Limits</strong>: The <a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/webgpu/#limits target=_blank>WebGPU specification</a> defines the minimum uniform buffer size requirements that inform these design decisions.</p><li><p><strong>Morph Target Animation</strong>: For background on how morph targets work in computer graphics, see <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Morph_target_animation target=_blank>Wikipedia: Morph target animation</a>.</p><li><p><strong>Bevy Rendering Architecture</strong>: The <a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/features/rendering.html target=_blank>Bevy cheatbook’s rendering section</a> provides context on how Bevy handles GPU data transfer and shader communication.</p><li><p><strong>WGSL Language Reference</strong>: The <a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/WGSL/ target=_blank>WGSL specification</a> explains the shading language syntax and semantics used in the modified shader code.</p><li><p><strong>Buffer Alignment in Graphics Programming</strong>: For understanding why buffer alignment matters, <a rel="noopener nofollow noreferrer" href=https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer target=_blank>Vulkan Memory Alignment</a> provides relevant background concepts that apply to WebGPU as well.</p></ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_21421.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>