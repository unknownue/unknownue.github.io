<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #22106 Add support for arbitrary/third party glTF Extension processing via GltfExtensionHandler
        
    </title><meta content="#22106 Add support for arbitrary/third party glTF Extension processing via GltfExtensionHandler" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-12/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-12-14</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-12/pr-22106-zh-cn-20251214>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add support for arbitrary/third party glTF Extension processing via GltfExtensionHandler<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/22106<li><strong>Author</strong>: ChristopherBiscardi<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Assets, S-Ready-For-Final-Review, D-Modest<li><strong>Created</strong>: 2025-12-13T13:48:36Z<li><strong>Merged</strong>: 2025-12-14T21:49:27Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Currently Bevy doesn’t support arbitrary glTF extensions. The ones it does support are hardcoded.<p>We should support glTF extensions, as this is a primary mechanism for sharing behavior via data exported from applications like Blender.<p>I personally have found usecases in exporting component data, lightmap textures/information, and processing other kinds of data (AnimationGraph, 3d meshes into 2d, etc).<h2 id=solution>Solution</h2><p>This PR introduces a new <code>GltfExtensionHandler</code> trait that users can implement and add to the glTF loader processing via inserting into a Resource.<p>There are two example processors currently added, with a third that I’d like to add after this PR.<ul><li><code>examples/gltf/gltf_extension_animation_graph.rs</code> duplicates the functionality of <code>animation_mesh</code>, constructing AnimationGraphs via extension processing and applying them to be played on the relevant nodes.<li><code>examples/gltf/gltf_extension_mesh_2d.rs</code> duplicates the functionality of the <code>custom_gltf_vertex_attribute</code> example, showing how the extension processing could be used to convert 3d meshes to 2d meshes alongside custom materials.</ul><p>Both of these examples re-use existing assets and thus don’t <em>actually use</em> extension data, but show how one could access the relevant data to say, only convert specifically labelled Mesh3ds to 2d, or process many animations into multiple graphs based on extension-data based labelling introduced in Blender.<p>A third example I want to introduce after this PR is the same core functionality Skein requires: an example that uses reflected component data stored in glTF extensions and inserts that data onto the relevant entities, resulting in scenes that are “ready to go”.<h2 id=comparison-to-extras>Comparison to Extras</h2><p>In comparison to extensions: data placed in glTF extras is well supported through the <code>GltfExtras</code> category of components.<p>Extras only support adding an additional <code>extras</code> field to any object.<p>Data stored in extras is application-specific. It should be usable by Bevy developers to implement their own, application-specific, data transfer. This is supported by applications like Blender through the application of Custom Properties.<p>Once data is used by more than one application, it belongs in a glTF extension.<h2 id=what-is-a-gltf-extension>What is a glTF Extension?</h2><p>Extensions are named with a prefix like <code>KHR</code> or <code>EXT</code>. Bevy has already reserved the <code>BEVY</code> namespace for this, which is listed in the official <a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/blob/7bbd90978cad06389eee3a36882c5ef2f2039faf/extensions/Prefixes.md target=_blank>prefix list</a>.<p>For a glTF file, an extension must be listed in <code>extensionsUsed</code> and optionally <code>extensionsRequired</code>.<pre style=color:#61676c;background-color:#fafafa><code><span>{
</span><span>    "extensionsRequired": [
</span><span>        "KHR_texture_transform"
</span><span>    ],
</span><span>    "extensionsUsed": [
</span><span>        "KHR_texture_transform"
</span><span>    ]
</span><span>}
</span></code></pre><p>Extension data is allowed in any place extras are also allowed, but also allow much more flexibility.<p>Extensions are also allowed to define global data, add additional binary chunks, and more.<p>For meshes, extensions can add additional attribute names, accessor types, and/or component types<p><code>KHR_lights_punctual</code> is a contained and understandable example of an extension: https://github.com/KhronosGroup/glTF/blob/7bbd90978cad06389eee3a36882c5ef2f2039faf/extensions/2.0/Khronos/KHR_lights_punctual/README.md . This one happens to be already hardcoded into Bevy’s handling, so it doesn’t benefit from arbitrary extension processing, but there are additional <a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/7bbd90978cad06389eee3a36882c5ef2f2039faf/extensions#ratified-khronos-extensions target=_blank>ratified</a> and <a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/7bbd90978cad06389eee3a36882c5ef2f2039faf/extensions#in-progress-khronos-and-multi-vendor-extensions-and-projects target=_blank>in-progress</a> extensions, as well as <a rel="noopener nofollow noreferrer" href=https://github.com/KhronosGroup/glTF/tree/7bbd90978cad06389eee3a36882c5ef2f2039faf/extensions#vendor-extensions target=_blank>vendor</a> and other arbitrary extensions that would benefit from userland support.<h2 id=implementation>Implementation</h2><p>This initial implementation is reasonably minimal: enabling extension processing for objects/etc as they’re loaded which may also define extension data, including the scene world. This may leave out useful functionality; as detailed in the next section: “What’s not implemented”.<p>Extension handlers are defined by implementing a trait which can optionally define hooks and data. Extension handler data is cloned to start with a fresh slate for each glTF load, which limits scope to “one glTF load”. So while state can be maintained across hooks during a single load, users who want to combine or handle multiple glTF assets should do so in the main app, not in an extension handler. Following this, because the extensions are stored as <code>dyn GltfExtension</code> <em>and</em> we want to clone them to isolate state to a single load, <code>dyn_clone</code> must be included as a workaround to enable this cloning.<p>An extension handler has to be added to the list of handler by accessing a <code>Resource</code> and pushing an instantiated handler into it. This Resource keeps the list of extension handlers so that a new glTF loader can bootstrap them.<p>The design of the hooks is such that:<ul><li>If no extensions handlers are registered, none are called for processing<li>If an extension handler is defined, it receives all “events” <ul><li>handlers are defined by a trait, and default implementations are called if an override is not specified. <ul><li>default implementations are no-ops</ul></ul></ul><p>It is important that extensions receive all events because certain information is not embedded in extension data. For example, processing animation data into an animation graph could require both processing animations with extension data, tracking the animation roots through hooks like <code>on_node</code>, <em>and</em> applying those graphs in the <code>on_scene_completed</code> hook.<ul><li>Extension data is passed to hooks as <code>Option<&serde_json::Value></code> which is only passing references around as the data has already been converted to <code>Value</code> by the <code>gltf</code> crate.<li><code>LoadContext</code> is required for creating any new additional assets, like <code>AnimationGraph</code>s. <ul><li><em>scene</em> World access is provided in hooks like <code>on_scene_completed</code>, which allows calculating data over the course of a glTF load and applying it to a Scene.</ul></ul><h3 id=what-s-not-implemented>What’s not implemented</h3><p>This PR chooses to <em>not</em> implement some features that it could. Instead the approach in this PR is to offer up the data that Bevy has already processed to extensions to do more with that data.<ul><li>Overriding <code>load_image</code>/<code>process_loaded_texture</code> <ul><li>This could allow projects like bevy_web_codecs, <a rel="noopener nofollow noreferrer" href=https://github.com/jf908/bevy_web_codecs/tree/373bbf29be6555c7603fd6867a01159ab0f20fed/bevy_web_codecs_gltf target=_blank>which currently forks the entire gltf loader</a>. Associated <a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/issues/21185 target=_blank>issue</a>. However I believe this needs some design work dedicated to what exactly happens here to support that use case.</ul><li>This PR doesn’t include any refactoring of the glTF loader, which I feel is important for a first merge.<li><del>There is some benefit to passing in the relevant <code>gltf::*</code> object to every hook. For example, I believe this is the only way to access extension data for <code>KHR_lights_punctual</code>, and <a rel="noopener nofollow noreferrer" href=https://docs.rs/gltf/1.4.1/gltf/struct.Document.html#method.variants target=_blank><code>KHR_materials_variants</code></a> or other extensions with “built-in” support. I haven’t done this in all places.</del> (edit: after external implementation I decided this was a good idea and added it to more places)</ul><h2 id=testing>Testing</h2><pre style=color:#61676c;background-color:#fafafa><code><span>cargo run --example gltf_extension_animation_graph
</span><span>cargo run --example gltf_extension_mesh_2d
</span></code></pre><hr><h2 id=showcase>Showcase</h2><p>Both examples running:<p>https://github.com/user-attachments/assets/f9e7c3c9-cdad-4d33-ace7-7c2ca5469d5e<p>https://github.com/user-attachments/assets/baa9bc92-ca3b-46ad-a3f0-2f74bbc29b68<details><summary>An example that showcases converting Mesh3d to Mesh2d</summary> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Default</span><span style=color:#61676ccc>,</span><span> Clone)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>GltfExtensionProcessorToMesh2d</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl </span><span>GltfExtensionProcessor </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>GltfExtensionProcessorToMesh2d </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>extension_ids</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static </span><span>[</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>] {
</span><span>        </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#86b300>""</span><span>]
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>dyn_clone</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn GltfExtensionHandler> {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new((</span><span style=color:#ed9366>*</span><span style=color:#55b4d4;font-style:italic>self</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_spawn_mesh_and_material</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>        </span><span style=color:#ff8f40>load_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>LoadContext<'</span><span style=color:#ed9366>_</span><span>>,
</span><span>        </span><span style=color:#ff8f40>_gltf_node</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Node,
</span><span>        </span><span style=color:#ff8f40>entity</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> EntityWorldMut,
</span><span>    ) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(mesh3d) </span><span style=color:#ed9366>=</span><span> entity</span><span style=color:#ed9366>.</span><span>get</span><span style=color:#ed9366>::</span><span>&LTMesh3d>()
</span><span>            </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>=</span><span> entity</span><span style=color:#ed9366>.</span><span>get</span><span style=color:#ed9366>::</span><span>&LTMeshMaterial3d&LTStandardMaterial>>()
</span><span>        {
</span><span>            </span><span style=color:#fa6e32>let</span><span> material_handle </span><span style=color:#ed9366>=
</span><span>                load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_loaded_labeled_asset</span><span>(</span><span style=color:#86b300>"AColorMaterial"</span><span style=color:#61676ccc>, </span><span>(CustomMaterial {})</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#fa6e32>let</span><span> mesh_handle </span><span style=color:#ed9366>=</span><span> mesh3d</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>            entity
</span><span>                </span><span style=color:#ed9366>.</span><span>remove</span><span style=color:#ed9366>::</span><span><(Mesh3d, MeshMaterial3d&LTStandardMaterial>)>()
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>((Mesh2d(mesh_handle)</span><span style=color:#61676ccc>,</span><span> MeshMaterial2d(material_handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())))</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre></details><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=the-problem-and-context>The Problem and Context</h3><p>Bevy’s glTF loader had a significant limitation: it only supported a fixed set of glTF extensions that were hardcoded into the engine. This created problems for users who needed to work with custom glTF extensions or vendor-specific extensions that weren’t part of Bevy’s built-in support. Since glTF extensions are a primary mechanism for sharing behavior via data exported from applications like Blender, this limitation prevented Bevy from being fully compatible with the broader glTF ecosystem.<p>The author had encountered practical use cases where this limitation was problematic, including exporting component data, lightmap textures/information, and processing other kinds of data like AnimationGraphs or converting 3D meshes to 2D. Existing workarounds, like forking the entire glTF loader for projects like bevy_web_codecs, highlighted the need for a more extensible solution.<h3 id=the-solution-approach>The Solution Approach</h3><p>The solution introduces a plugin system for glTF extension processing through a new <code>GltfExtensionHandler</code> trait. This approach avoids hardcoding specific extensions and instead provides a framework where users can implement their own extension processors. The design decisions included:<ol><li><strong>Trait-based extensibility</strong>: Instead of modifying the glTF loader directly for each new extension, users implement a trait with optional hook methods.<li><strong>State isolation</strong>: Extension handlers are cloned for each glTF load to maintain isolation between different asset loads.<li><strong>Comprehensive hook coverage</strong>: The trait provides hooks at all major points in the glTF loading process, from root data processing to scene completion.<li><strong>Resource-based registration</strong>: Extension handlers are registered via a <code>GltfExtensionHandlers</code> resource that can be modified at runtime.</ol><p>The implementation intentionally avoids more invasive changes to the glTF loader, opting for a minimal first implementation that can be extended later. For example, the PR doesn’t implement hooks for overriding image loading or texture processing, which would require more design consideration.<h3 id=the-implementation>The Implementation</h3><p>The core of the implementation is the <code>GltfExtensionHandler</code> trait defined in <code>crates/bevy_gltf/src/loader/extensions/mod.rs</code>. This trait provides default no-op implementations for all hooks, allowing users to override only the methods they need:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>GltfExtensionHandler</span><span>: Send + Sync {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>dyn_clone</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn GltfExtensionHandler></span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>extension_ids</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static </span><span>[</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>] {
</span><span>        </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#86b300>""</span><span>]
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_root_data</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>extension_id</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>, </span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>serde_json</span><span style=color:#ed9366>::</span><span>Value>) {}
</span><span>    
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"bevy_animation"</span><span>)]
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>        </span><span style=color:#ff8f40>extension_id</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>,
</span><span>        </span><span style=color:#ff8f40>extension_data</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>serde_json</span><span style=color:#ed9366>::</span><span>Value>,
</span><span>        </span><span style=color:#ff8f40>gltf_animation</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>gltf</span><span style=color:#ed9366>::</span><span>Animation,
</span><span>        </span><span style=color:#ff8f40>name</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>>,
</span><span>        </span><span style=color:#ff8f40>handle</span><span style=color:#61676ccc>: </span><span>Handle&LTAnimationClip>,
</span><span>    ) {
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... additional hook methods
</span><span>}
</span></code></pre><p>The trait design is thoughtful: it includes <code>extension_ids()</code> to specify which extensions a handler processes, and it passes the original <code>gltf::*</code> objects to hooks when needed for accessing extension data that might not be exposed through Bevy’s processed representation.<p>The <code>GltfLoader</code> is modified to maintain a list of extension handlers and call them at appropriate points during loading. For example, when processing animations:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// In GltfLoader::load() method
</span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>    </span><span style=color:#fa6e32>for</span><span> id </span><span style=color:#ed9366>in</span><span> extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>extension_ids</span><span>() {
</span><span>        extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_animation</span><span>(
</span><span>            id</span><span style=color:#61676ccc>,
</span><span>            animation</span><span style=color:#ed9366>.</span><span style=color:#f07171>extension_value</span><span>(id)</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>&</span><span>animation</span><span style=color:#61676ccc>,
</span><span>            animation</span><span style=color:#ed9366>.</span><span style=color:#f07171>name</span><span>()</span><span style=color:#61676ccc>,
</span><span>            handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>,
</span><span>        )</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The implementation also adds proper handling for cloning trait objects via <code>dyn_clone</code>, which is necessary because the handlers are stored as <code>Box&LTdyn GltfExtensionHandler></code> but need to be cloned for each glTF load to maintain state isolation.<h3 id=technical-insights>Technical Insights</h3><p>Several technical aspects of this implementation are noteworthy:<ol><li><p><strong>Trait object cloning</strong>: The use of <code>dyn_clone</code> is a workaround for Rust’s limitation that <code>Clone</code> cannot be made into a trait object. This pattern is common in Rust when dynamic dispatch with cloning is needed.</p><li><p><strong>State management</strong>: By cloning handlers for each load, the implementation ensures that extension processing state doesn’t leak between different glTF files. This is important for correctness but does mean that users who need to coordinate across multiple glTF loads must handle that at the application level.</p><li><p><strong>Performance considerations</strong>: The implementation adds overhead by iterating through all registered extension handlers at each hook point. However, the impact is minimal since the number of handlers is typically small, and default implementations are no-ops that compile away.</p><li><p><strong>Async compatibility</strong>: The handlers need to be <code>Send + Sync</code> because the glTF loader runs in an async context and may process assets across thread boundaries.</p><li><p><strong>JSON data handling</strong>: Extension data is passed as <code>serde_json::Value</code>, which provides flexibility but requires users to handle JSON parsing. This is appropriate since glTF extensions are defined as JSON objects.</p></ol><h3 id=the-impact>The Impact</h3><p>This PR significantly enhances Bevy’s glTF capabilities by:<ol><li><strong>Enabling third-party extensions</strong>: Users can now work with any glTF extension, not just the ones hardcoded into Bevy.<li><strong>Supporting vendor-specific extensions</strong>: Game studios and tool developers can create their own extensions with the <code>BEVY</code> prefix or other vendor prefixes.<li><strong>Improving Blender workflow integration</strong>: Since Blender supports custom properties that can be exported as glTF extensions, this enables richer data exchange between content creation tools and Bevy.<li><strong>Reducing forking needs</strong>: Projects like bevy_web_codecs that previously forked the glTF loader can potentially use this extension system instead.</ol><p>The examples provided demonstrate practical use cases: building animation graphs from glTF data and converting 3D meshes to 2D. These examples show how the system can be used for both data transformation (mesh conversion) and data augmentation (adding animation graphs).<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    subgraph "User Application"
</span><span>        A[App] --> B[Register Extension Handlers]
</span><span>        B --> C[GltfExtensionHandlers Resource]
</span><span>    end
</span><span>    
</span><span>    subgraph "GltfLoader"
</span><span>        D[GltfLoader with extensions field] --> E[Clone handlers for load]
</span><span>        E --> F[Process glTF file]
</span><span>        F --> G[Call hooks at loading stages]
</span><span>        G --> H[Root data]
</span><span>        G --> I[Animations]
</span><span>        G --> J[Textures]
</span><span>        G --> K[Materials]
</span><span>        G --> L[Meshes]
</span><span>        G --> M[Nodes]
</span><span>        G --> N[Scene completion]
</span><span>    end
</span><span>    
</span><span>    subgraph "Extension Handlers"
</span><span>        O[User Handler 1]
</span><span>        P[User Handler 2]
</span><span>        Q[User Handler 3]
</span><span>    end
</span><span>    
</span><span>    C --> D
</span><span>    O --> G
</span><span>    P --> G
</span><span>    Q --> G
</span><span>    
</span><span>    H --> R[Process extension data]
</span><span>    I --> R
</span><span>    J --> R
</span><span>    K --> R
</span><span>    L --> R
</span><span>    M --> R
</span><span>    N --> R
</span><span>    
</span><span>    R --> S[Modify entities/create assets]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-gltf-src-loader-extensions-mod-rs-263-0><code>crates/bevy_gltf/src/loader/extensions/mod.rs</code> (+263/-0)</h3><p>This is the core of the implementation, defining the <code>GltfExtensionHandler</code> trait and the <code>GltfExtensionHandlers</code> resource.<p><strong>Key code:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>GltfExtensionHandler</span><span>: Send + Sync {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>dyn_clone</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn GltfExtensionHandler></span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>extension_ids</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static </span><span>[</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static str</span><span>] {
</span><span>        </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#86b300>""</span><span>]
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_root_data</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>extension_id</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>, </span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>serde_json</span><span style=color:#ed9366>::</span><span>Value>) {}
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... additional hooks for animations, textures, materials, etc.
</span><span>}
</span></code></pre><p>The trait provides a comprehensive set of hooks that cover all major aspects of glTF loading, allowing extension handlers to intervene at the right points in the process.<h3 id=crates-bevy-gltf-src-loader-mod-rs-180-8><code>crates/bevy_gltf/src/loader/mod.rs</code> (+180/-8)</h3><p>This file modifies the <code>GltfLoader</code> to integrate with the extension system. The loader now:<ol><li>Accepts extension handlers as a constructor parameter<li>Clones them for each load<li>Calls the appropriate hooks throughout the loading process</ol><p><strong>Key code:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>GltfLoader </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... existing fields
</span><span>    </span><span style=color:#fa6e32>pub </span><span>extensions</span><span style=color:#61676ccc>: </span><span>Arc&LTRwLock<</span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn extensions</span><span style=color:#ed9366>::</span><span>GltfExtensionHandler>>>>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>GltfLoader </span><span>{
</span><span>    async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>load</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, ...) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTGltf, GltfError> {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// clone extensions to start with a fresh processing state
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> extensions </span><span style=color:#ed9366>=</span><span> loader</span><span style=color:#ed9366>.</span><span>extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>read</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Process root extension data
</span><span>        </span><span style=color:#fa6e32>for</span><span> extension </span><span style=color:#ed9366>in</span><span> extensions</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>() {
</span><span>            </span><span style=color:#fa6e32>for</span><span> id </span><span style=color:#ed9366>in</span><span> extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>extension_ids</span><span>() {
</span><span>                extension</span><span style=color:#ed9366>.</span><span style=color:#f07171>on_root_data</span><span>(id</span><span style=color:#61676ccc>,</span><span> gltf</span><span style=color:#ed9366>.</span><span style=color:#f07171>extension_value</span><span>(id))</span><span style=color:#61676ccc>;
</span><span>            }
</span><span>        }
</span><span>        
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... throughout the loading process, call other hooks
</span><span>    }
</span><span>}
</span></code></pre><p>The changes are integrated throughout the loading pipeline, with hooks called at appropriate points like after animations are collected, when materials are processed, and when nodes are loaded.<h3 id=examples-gltf-gltf-extension-animation-graph-rs-202-0><code>examples/gltf/gltf_extension_animation_graph.rs</code> (+202/-0)</h3><p>This example demonstrates building an animation graph from glTF data using the extension system. It shows how to track animation roots across multiple hooks and apply an animation graph to entities when the scene is complete.<p><strong>Key code:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>GltfExtensionHandler </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>GltfExtensionHandlerAnimation </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_animation</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, ...) {
</span><span>        </span><span style=color:#fa6e32>if</span><span> name</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_some_and</span><span>(|</span><span style=color:#ff8f40>v</span><span>| v </span><span style=color:#ed9366>== </span><span style=color:#86b300>"Walk"</span><span>) {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>clip </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_gltf_node</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, ...) {
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>animation_root_indices</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(</span><span style=color:#ed9366>&</span><span>gltf_node</span><span style=color:#ed9366>.</span><span style=color:#f07171>index</span><span>()) {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>animation_root_entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(entity</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>())</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_scene_completed</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, ...) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Create an AnimationGraph from the desired clip
</span><span>        </span><span style=color:#fa6e32>let </span><span>(graph</span><span style=color:#61676ccc>,</span><span> index) </span><span style=color:#ed9366>= </span><span>AnimationGraph</span><span style=color:#ed9366>::</span><span>from_clip(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>clip</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>())</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> graph_handle </span><span style=color:#ed9366>=</span><span> load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_labeled_asset</span><span>(</span><span style=color:#86b300>"MyAnimationGraphLabel"</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_string</span><span>()</span><span style=color:#61676ccc>,</span><span> graph)</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Insert the `AnimationToPlay` component on the first animation root
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> entity </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_mut</span><span>(</span><span style=color:#ed9366>*</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>animation_root_entities</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>next</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>())</span><span style=color:#61676ccc>;
</span><span>        entity</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>(AnimationToPlay { graph_handle</span><span style=color:#61676ccc>,</span><span> index })</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>This example demonstrates stateful processing across multiple hooks, which is a key capability of the system.<h3 id=examples-gltf-gltf-extension-mesh-2d-rs-129-0><code>examples/gltf/gltf_extension_mesh_2d.rs</code> (+129/-0)</h3><p>This example shows how to convert 3D meshes to 2D meshes using a custom material. It demonstrates the <code>on_spawn_mesh_and_material</code> hook, which is called when a mesh and material are spawned together on an entity.<p><strong>Key code:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>GltfExtensionHandler </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>GltfExtensionHandlerToMesh2d </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>on_spawn_mesh_and_material</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, ...) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(mesh3d) </span><span style=color:#ed9366>=</span><span> entity</span><span style=color:#ed9366>.</span><span>get</span><span style=color:#ed9366>::</span><span>&LTMesh3d>()
</span><span>            </span><span style=color:#ed9366>&& </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>=</span><span> entity</span><span style=color:#ed9366>.</span><span>get</span><span style=color:#ed9366>::</span><span>&LTMeshMaterial3d&LTStandardMaterial>>()
</span><span>        {
</span><span>            </span><span style=color:#fa6e32>let</span><span> material_handle </span><span style=color:#ed9366>=
</span><span>                load_context</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_labeled_asset</span><span>(</span><span style=color:#86b300>"AColorMaterial"</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_string</span><span>()</span><span style=color:#61676ccc>,</span><span> CustomMaterial {})</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#fa6e32>let</span><span> mesh_handle </span><span style=color:#ed9366>=</span><span> mesh3d</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>            entity
</span><span>                </span><span style=color:#ed9366>.</span><span>remove</span><span style=color:#ed9366>::</span><span><(Mesh3d, MeshMaterial3d&LTStandardMaterial>)>()
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>insert</span><span>((Mesh2d(mesh_handle)</span><span style=color:#61676ccc>,</span><span> MeshMaterial2d(material_handle</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>())))</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>This example shows how extension handlers can modify entities during loading, in this case replacing 3D mesh components with 2D mesh components.<h3 id=cargo-toml-23-0><code>Cargo.toml</code> (+23/-0)</h3><p>The PR adds dependencies on <code>gltf</code> and <code>async-lock</code> crates, and adds the two new examples to the examples list.<h2 id=further-reading>Further Reading</h2><ol><li><strong>glTF Extension Specification</strong>: https://github.com/KhronosGroup/glTF/tree/main/specification/2.0#extensions<li><strong>Khronos glTF Extensions Repository</strong>: https://github.com/KhronosGroup/glTF/tree/main/extensions<li><strong>Bevy glTF Documentation</strong>: https://docs.rs/bevy_gltf/latest/bevy_gltf/<li><strong>serde_json Documentation</strong>: https://docs.rs/serde_json/latest/serde_json/ - For handling the JSON extension data passed to hooks<li><strong>dyn-clone crate</strong>: https://docs.rs/dyn-clone/latest/dyn_clone/ - For understanding the trait object cloning pattern used in this implementation</ol></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-12/pr_22106.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>