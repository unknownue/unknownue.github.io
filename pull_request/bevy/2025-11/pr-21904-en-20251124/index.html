<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21904 Solari: Prevent world cache cells from keeping each other alive infinitely
        
    </title><meta content="#21904 Solari: Prevent world cache cells from keeping each other alive infinitely" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-11/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-11-24</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-11/pr-21904-zh-cn-20251124>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Solari: Prevent world cache cells from keeping each other alive infinitely<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21904<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Rendering, S-Ready-For-Review, C-Refinement<li><strong>Created</strong>: 2025-11-21T16:25:08Z<li><strong>Merged</strong>: 2025-11-24T19:42:35Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Prevent world cache cells from querying each other and keeping each other alive infinitely<li>Now when you leave an area of your game, you’re no longer paying performance cost for the out-of-view cells.<li>Also fix a long-standing off-by-1 bug in the world cache compaction code</ul><h2 id=solution>Solution</h2><ul><li>Instead of always resetting cell lifetimes to the max lifetime during a cell query, for world cache update, we now set it to the max of the current cell lifetime and it’s existing lifetime (max prevents a lower-lifetime cell overwriting a higher-lifetime cell).<li>Credit to IsaacSM and @NthTensor for the idea!</ul><h2 id=testing>Testing</h2><p>Video showing the current number of live world cache cells, before and after this PR.<p>https://github.com/user-attachments/assets/7639c62c-9bdb-41d7-aebb-b2494c03c042<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a fundamental issue in Bevy’s Solari global illumination system where world cache cells were creating circular dependencies that prevented proper cleanup. The problem manifested as a memory leak where cells would keep each other alive indefinitely, causing performance degradation over time as the cache grew without bounds.<p>The core issue was in the lifetime management of world cache cells. When cells queried each other during multi-bounce indirect lighting calculations, they would reset each other’s lifetimes to the maximum value, creating a feedback loop. This meant that even when players moved away from an area, the cache cells in that region would continue to consume resources because they were constantly refreshing each other’s lifetimes.<p>The solution implements a more intelligent lifetime management strategy. Instead of unconditionally resetting lifetimes to <code>WORLD_CACHE_CELL_LIFETIME</code> during queries, the system now uses atomic maximum operations to ensure that only higher lifetime values can overwrite existing ones. This prevents lower-lifetime cells from artificially extending the lifespan of cells they query.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>if existing_checksum == checksum {
</span><span>    atomicStore(&world_cache_life[key], WORLD_CACHE_CELL_LIFETIME);
</span><span>    return world_cache_radiance[key].rgb;
</span><span>}
</span><span>
</span><span>// After:
</span><span>if existing_checksum == checksum || existing_checksum == WORLD_CACHE_EMPTY_CELL {
</span><span>#ifdef WORLD_CACHE_QUERY_ATOMIC_MAX_LIFETIME
</span><span>    atomicMax(&world_cache_life[key], cell_lifetime);
</span><span>#endif
</span><span>}
</span></code></pre><p>The implementation required changes across multiple shader stages to ensure consistent lifetime propagation. In <code>world_cache_update.wgsl</code>, when querying other cells for multi-bounce lighting, the system now passes the current cell’s lifetime rather than the maximum lifetime:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before:
</span><span>new_radiance += ray_hit.material.base_color * query_world_cache(ray_hit.world_position, ray_hit.geometric_world_normal, view.world_position, &rng);
</span><span>
</span><span>// After:
</span><span>let cell_life = atomicLoad(&world_cache_life[cell_index]);
</span><span>new_radiance += ray_hit.material.base_color * query_world_cache(ray_hit.world_position, ray_hit.geometric_world_normal, view.world_position, cell_life, &rng);
</span></code></pre><p>This change ensures that when Cell A queries Cell B during multi-bounce calculations, it only extends Cell B’s lifetime to match its own current lifetime, rather than resetting it to the maximum. This breaks the circular dependency chain.<p>Additionally, the PR fixes a long-standing off-by-one bug in the world cache compaction system. The bug was in the calculation of the active cell count during compaction:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before (buggy):
</span><span>world_cache_active_cells_count = compacted_index + 1u;
</span><span>
</span><span>// After (fixed):
</span><span>world_cache_active_cells_count = compacted_index + u32(cell_active);
</span></code></pre><p>The original code would always add 1 to the count, even when there were zero active cells, which could lead to incorrect buffer sizing and dispatch calculations.<p>The changes also include some housekeeping improvements, such as moving configuration constants like <code>WORLD_CACHE_DIRECT_LIGHT_SAMPLE_COUNT</code> and <code>WORLD_CACHE_MAX_GI_RAY_DISTANCE</code> from local constants in <code>world_cache_update.wgsl</code> to shared constants in <code>world_cache_query.wgsl</code>, promoting better consistency across the system.<p>The impact of these changes is significant for long-running applications. Previously, the world cache would grow continuously as cells kept each other alive. Now, cells naturally expire when they’re no longer being actively used by the camera or nearby cells, allowing the system to reclaim resources and maintain consistent performance.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[World Cache Query] --> B[World Cache Update]
</span><span>    B --> C[Multi-bounce Lighting]
</span><span>    C --> A
</span><span>    D[Cell Lifetime Management] --> A
</span><span>    D --> B
</span><span>    E[Compaction System] --> F[Active Cell Tracking]
</span><span>    
</span><span>    style A fill:#e1f5fe
</span><span>    style B fill:#f3e5f5
</span><span>    style D fill:#e8f5e8
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-world-cache-query-wgsl-20-7><code>crates/bevy_solari/src/realtime/world_cache_query.wgsl</code> (+20/-7)</h3><p>This file contains the core world cache query logic. The key change is the introduction of atomic maximum operations for lifetime management and the new function signature that accepts a <code>cell_lifetime</code> parameter.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Key changes:
</span><span>fn query_world_cache(world_position: vec3&LTf32>, world_normal: vec3&LTf32>, view_position: vec3&LTf32>, cell_lifetime: u32, rng: ptr&LTfunction, u32>) -> vec3&LTf32> {
</span><span>
</span><span>// Lifetime management logic:
</span><span>if existing_checksum == checksum || existing_checksum == WORLD_CACHE_EMPTY_CELL {
</span><span>#ifndef WORLD_CACHE_QUERY_ATOMIC_MAX_LIFETIME
</span><span>    atomicStore(&world_cache_life[key], cell_lifetime);
</span><span>#else
</span><span>    atomicMax(&world_cache_life[key], cell_lifetime);
</span><span>#endif
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-update-wgsl-8-7><code>crates/bevy_solari/src/realtime/world_cache_update.wgsl</code> (+8/-7)</h3><p>This file handles updating world cache cells with new lighting samples. The main change is propagating the current cell’s lifetime when querying other cells.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Before multi-bounce query:
</span><span>let cell_life = atomicLoad(&world_cache_life[cell_index]);
</span><span>new_radiance += ray_hit.material.base_color * query_world_cache(ray_hit.world_position, ray_hit.geometric_world_normal, view.world_position, cell_life, &rng);
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-compact-wgsl-4-2><code>crates/bevy_solari/src/realtime/world_cache_compact.wgsl</code> (+4/-2)</h3><p>This file contains the world cache compaction logic. The fix addresses the off-by-one bug in active cell counting.<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Fixed active cell counting:
</span><span>if thread_index == 1023u && workgroup_id.x == 1023u {
</span><span>    world_cache_active_cells_count = compacted_index + u32(cell_active);
</span><span>    world_cache_active_cells_dispatch = vec3((world_cache_active_cells_count + 63u) / 64u, 1u, 1u);
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-restir-gi-wgsl-and-crates-bevy-solari-src-realtime-specular-gi-wgsl><code>crates/bevy_solari/src/realtime/restir_gi.wgsl</code> and <code>crates/bevy_solari/src/realtime/specular_gi.wgsl</code></h3><p>These files were updated to use the new <code>query_world_cache</code> function signature, passing <code>WORLD_CACHE_CELL_LIFETIME</code> as the lifetime parameter.<h3 id=crates-bevy-solari-src-realtime-node-rs><code>crates/bevy_solari/src/realtime/node.rs</code></h3><p>Enabled the <code>WORLD_CACHE_QUERY_ATOMIC_MAX_LIFETIME</code> feature flag for the world cache update pipeline.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://gpuweb.github.io/gpuweb/wgsl/#atomic-ops target=_blank>WGSL Atomic Operations</a> - Documentation on WebGPU Shading Language atomic operations<li><a rel="noopener nofollow noreferrer" href=https://advances.realtimerendering.com/s2021/index.html target=_blank>Global Illumination Techniques</a> - Real-time rendering advancements in GI<li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/bevy/tree/main/crates/bevy_solari target=_blank>Bevy Solari Documentation</a> - Bevy’s global illumination system</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-11/pr_21904.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>