diff --git a/crates/bevy_asset/src/io/embedded/mod.rs b/crates/bevy_asset/src/io/embedded/mod.rs
index f05b1cb240106..9eea1dbb95b75 100644
--- a/crates/bevy_asset/src/io/embedded/mod.rs
+++ b/crates/bevy_asset/src/io/embedded/mod.rs
@@ -6,7 +6,7 @@ pub use embedded_watcher::*;
 
 use crate::io::{
     memory::{Dir, MemoryAssetReader, Value},
-    AssetSource, AssetSourceBuilders,
+    AssetSourceBuilder, AssetSourceBuilders,
 };
 use crate::AssetServer;
 use alloc::boxed::Box;
@@ -19,7 +19,7 @@ use std::path::{Path, PathBuf};
 #[cfg(feature = "embedded_watcher")]
 use alloc::borrow::ToOwned;
 
-/// The name of the `embedded` [`AssetSource`],
+/// The name of the `embedded` [`AssetSource`](crate::io::AssetSource),
 /// as stored in the [`AssetSourceBuilders`] resource.
 pub const EMBEDDED: &str = "embedded";
 
@@ -38,8 +38,8 @@ pub struct EmbeddedAssetRegistry {
 impl EmbeddedAssetRegistry {
     /// Inserts a new asset. `full_path` is the full path (as [`file`] would return for that file, if it was capable of
     /// running in a non-rust file). `asset_path` is the path that will be used to identify the asset in the `embedded`
-    /// [`AssetSource`]. `value` is the bytes that will be returned for the asset. This can be _either_ a `&'static [u8]`
-    /// or a [`Vec<u8>`](alloc::vec::Vec).
+    /// [`AssetSource`](crate::io::AssetSource). `value` is the bytes that will be returned for the asset. This can be
+    /// _either_ a `&'static [u8]` or a [`Vec<u8>`](alloc::vec::Vec).
     #[cfg_attr(
         not(feature = "embedded_watcher"),
         expect(
@@ -58,8 +58,8 @@ impl EmbeddedAssetRegistry {
 
     /// Inserts new asset metadata. `full_path` is the full path (as [`file`] would return for that file, if it was capable of
     /// running in a non-rust file). `asset_path` is the path that will be used to identify the asset in the `embedded`
-    /// [`AssetSource`]. `value` is the bytes that will be returned for the asset. This can be _either_ a `&'static [u8]`
-    /// or a [`Vec<u8>`](alloc::vec::Vec).
+    /// [`AssetSource`](crate::io::AssetSource). `value` is the bytes that will be returned for the asset. This can be _either_
+    /// a `&'static [u8]` or a [`Vec<u8>`](alloc::vec::Vec).
     #[cfg_attr(
         not(feature = "embedded_watcher"),
         expect(
@@ -83,7 +83,7 @@ impl EmbeddedAssetRegistry {
         self.dir.remove_asset(full_path)
     }
 
-    /// Registers the [`EMBEDDED`] [`AssetSource`] with the given [`AssetSourceBuilders`].
+    /// Registers the [`EMBEDDED`] [`AssetSource`](crate::io::AssetSource) with the given [`AssetSourceBuilders`].
     pub fn register_source(&self, sources: &mut AssetSourceBuilders) {
         let dir = self.dir.clone();
         let processed_dir = self.dir.clone();
@@ -95,18 +95,18 @@ impl EmbeddedAssetRegistry {
                 reason = "Variable is only mutated when `embedded_watcher` feature is enabled."
             )
         )]
-        let mut source = AssetSource::build()
-            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }))
-            .with_processed_reader(move || {
-                Box::new(MemoryAssetReader {
-                    root: processed_dir.clone(),
+        let mut source =
+            AssetSourceBuilder::new(move || Box::new(MemoryAssetReader { root: dir.clone() }))
+                .with_processed_reader(move || {
+                    Box::new(MemoryAssetReader {
+                        root: processed_dir.clone(),
+                    })
                 })
-            })
-            // Note that we only add a processed watch warning because we don't want to warn
-            // noisily about embedded watching (which is niche) when users enable file watching.
-            .with_processed_watch_warning(
-                "Consider enabling the `embedded_watcher` cargo feature.",
-            );
+                // Note that we only add a processed watch warning because we don't want to warn
+                // noisily about embedded watching (which is niche) when users enable file watching.
+                .with_processed_watch_warning(
+                    "Consider enabling the `embedded_watcher` cargo feature.",
+                );
 
         #[cfg(feature = "embedded_watcher")]
         {
@@ -262,7 +262,7 @@ pub fn _embedded_asset_path(
 }
 
 /// Creates a new `embedded` asset by embedding the bytes of the given path into the current binary
-/// and registering those bytes with the `embedded` [`AssetSource`].
+/// and registering those bytes with the `embedded` [`AssetSource`](crate::io::AssetSource).
 ///
 /// This accepts the current [`App`] as the first parameter and a path `&str` (relative to the current file) as the second.
 ///
@@ -306,7 +306,7 @@ pub fn _embedded_asset_path(
 /// ```
 ///
 /// Some things to note in the path:
-/// 1. The non-default `embedded://` [`AssetSource`]
+/// 1. The non-default `embedded://` [`AssetSource`](crate::io::AssetSource)
 /// 2. `src` is trimmed from the path
 ///
 /// The default behavior also works for cargo workspaces. Pretend the `bevy_rock` crate now exists in a larger workspace in
diff --git a/crates/bevy_asset/src/io/source.rs b/crates/bevy_asset/src/io/source.rs
index 9f25b3edc631c..d48871ca3f85f 100644
--- a/crates/bevy_asset/src/io/source.rs
+++ b/crates/bevy_asset/src/io/source.rs
@@ -116,10 +116,9 @@ impl<'a> PartialEq for AssetSourceId<'a> {
 
 /// Metadata about an "asset source", such as how to construct the [`AssetReader`](crate::io::AssetReader) and [`AssetWriter`](crate::io::AssetWriter) for the source,
 /// and whether or not the source is processed.
-#[derive(Default)]
 pub struct AssetSourceBuilder {
     /// The [`ErasedAssetReader`] to use on the unprocessed asset.
-    pub reader: Option<Box<dyn FnMut() -> Box<dyn ErasedAssetReader> + Send + Sync>>,
+    pub reader: Box<dyn FnMut() -> Box<dyn ErasedAssetReader> + Send + Sync>,
     /// The [`ErasedAssetWriter`] to use on the unprocessed asset.
     pub writer: Option<Box<dyn FnMut(bool) -> Option<Box<dyn ErasedAssetWriter>> + Send + Sync>>,
     /// The [`AssetWatcher`] to use for unprocessed assets, if any.
@@ -150,6 +149,22 @@ pub struct AssetSourceBuilder {
 }
 
 impl AssetSourceBuilder {
+    /// Creates a new builder, starting with the provided reader.
+    pub fn new(
+        reader: impl FnMut() -> Box<dyn ErasedAssetReader> + Send + Sync + 'static,
+    ) -> AssetSourceBuilder {
+        Self {
+            reader: Box::new(reader),
+            writer: None,
+            watcher: None,
+            processed_reader: None,
+            processed_writer: None,
+            processed_watcher: None,
+            watch_warning: None,
+            processed_watch_warning: None,
+        }
+    }
+
     /// Builds a new [`AssetSource`] with the given `id`. If `watch` is true, the unprocessed source will watch for changes.
     /// If `watch_processed` is true, the processed source will watch for changes.
     pub fn build(
@@ -157,8 +172,8 @@ impl AssetSourceBuilder {
         id: AssetSourceId<'static>,
         watch: bool,
         watch_processed: bool,
-    ) -> Option<AssetSource> {
-        let reader = self.reader.as_mut()?();
+    ) -> AssetSource {
+        let reader = self.reader.as_mut()();
         let writer = self.writer.as_mut().and_then(|w| w(false));
         let processed_writer = self.processed_writer.as_mut().and_then(|w| w(true));
         let mut source = AssetSource {
@@ -202,7 +217,7 @@ impl AssetSourceBuilder {
                 }
             }
         }
-        Some(source)
+        source
     }
 
     /// Will use the given `reader` function to construct unprocessed [`AssetReader`](crate::io::AssetReader) instances.
@@ -210,7 +225,7 @@ impl AssetSourceBuilder {
         mut self,
         reader: impl FnMut() -> Box<dyn ErasedAssetReader> + Send + Sync + 'static,
     ) -> Self {
-        self.reader = Some(Box::new(reader));
+        self.reader = Box::new(reader);
         self
     }
 
@@ -281,8 +296,7 @@ impl AssetSourceBuilder {
     /// For most platforms, this will use [`FileAssetReader`](crate::io::file::FileAssetReader) / [`FileAssetWriter`](crate::io::file::FileAssetWriter),
     /// but some platforms (such as Android) have their own default readers / writers / watchers.
     pub fn platform_default(path: &str, processed_path: Option<&str>) -> Self {
-        let default = Self::default()
-            .with_reader(AssetSource::get_default_reader(path.to_string()))
+        let default = Self::new(AssetSource::get_default_reader(path.to_string()))
             .with_writer(AssetSource::get_default_writer(path.to_string()))
             .with_watcher(AssetSource::get_default_watcher(
                 path.to_string(),
@@ -341,13 +355,12 @@ impl AssetSourceBuilders {
     pub fn build_sources(&mut self, watch: bool, watch_processed: bool) -> AssetSources {
         let mut sources = <HashMap<_, _>>::default();
         for (id, source) in &mut self.sources {
-            if let Some(data) = source.build(
+            let source = source.build(
                 AssetSourceId::Name(id.clone_owned()),
                 watch,
                 watch_processed,
-            ) {
-                sources.insert(id.clone_owned(), data);
-            }
+            );
+            sources.insert(id.clone_owned(), source);
         }
 
         AssetSources {
@@ -355,7 +368,7 @@ impl AssetSourceBuilders {
             default: self
                 .default
                 .as_mut()
-                .and_then(|p| p.build(AssetSourceId::Default, watch, watch_processed))
+                .map(|p| p.build(AssetSourceId::Default, watch, watch_processed))
                 .expect(MISSING_DEFAULT_SOURCE),
         }
     }
@@ -382,11 +395,6 @@ pub struct AssetSource {
 }
 
 impl AssetSource {
-    /// Starts building a new [`AssetSource`].
-    pub fn build() -> AssetSourceBuilder {
-        AssetSourceBuilder::default()
-    }
-
     /// Returns this source's id.
     #[inline]
     pub fn id(&self) -> AssetSourceId<'static> {
diff --git a/crates/bevy_asset/src/io/web.rs b/crates/bevy_asset/src/io/web.rs
index 3eab7cbce05fa..196e36325c1a2 100644
--- a/crates/bevy_asset/src/io/web.rs
+++ b/crates/bevy_asset/src/io/web.rs
@@ -1,5 +1,7 @@
+#[cfg(any(feature = "http", feature = "https"))]
+use crate::io::AssetSourceBuilder;
+use crate::io::PathStream;
 use crate::io::{AssetReader, AssetReaderError, Reader};
-use crate::io::{AssetSource, PathStream};
 use crate::{AssetApp, AssetPlugin};
 use alloc::boxed::Box;
 use bevy_app::{App, Plugin};
@@ -71,16 +73,14 @@ impl Plugin for WebAssetPlugin {
         #[cfg(feature = "http")]
         app.register_asset_source(
             "http",
-            AssetSource::build()
-                .with_reader(move || Box::new(WebAssetReader::Http))
+            AssetSourceBuilder::new(move || Box::new(WebAssetReader::Http))
                 .with_processed_reader(move || Box::new(WebAssetReader::Http)),
         );
 
         #[cfg(feature = "https")]
         app.register_asset_source(
             "https",
-            AssetSource::build()
-                .with_reader(move || Box::new(WebAssetReader::Https))
+            AssetSourceBuilder::new(move || Box::new(WebAssetReader::Https))
                 .with_processed_reader(move || Box::new(WebAssetReader::Https)),
         );
     }
diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
index f0205c9cd9027..2c008b189e8db 100644
--- a/crates/bevy_asset/src/lib.rs
+++ b/crates/bevy_asset/src/lib.rs
@@ -721,7 +721,7 @@ mod tests {
         io::{
             gated::{GateOpener, GatedReader},
             memory::{Dir, MemoryAssetReader},
-            AssetReader, AssetReaderError, AssetSource, AssetSourceEvent, AssetSourceId,
+            AssetReader, AssetReaderError, AssetSourceBuilder, AssetSourceEvent, AssetSourceId,
             AssetWatcher, Reader,
         },
         loader::{AssetLoader, LoadContext},
@@ -914,7 +914,7 @@ mod tests {
         let (gated_memory_reader, gate_opener) = GatedReader::new(MemoryAssetReader { root: dir });
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build().with_reader(move || Box::new(gated_memory_reader.clone())),
+            AssetSourceBuilder::new(move || Box::new(gated_memory_reader.clone())),
         )
         .add_plugins((
             TaskPoolPlugin::default(),
@@ -1853,7 +1853,7 @@ mod tests {
         let mut app = App::new();
         app.register_asset_source(
             "unstable",
-            AssetSource::build().with_reader(move || Box::new(unstable_reader.clone())),
+            AssetSourceBuilder::new(move || Box::new(unstable_reader.clone())),
         )
         .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
         .init_asset::<CoolText>()
@@ -1923,8 +1923,7 @@ mod tests {
 
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build()
-                .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() })),
+            AssetSourceBuilder::new(move || Box::new(MemoryAssetReader { root: dir.clone() })),
         )
         .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()));
 
@@ -2047,7 +2046,7 @@ mod tests {
         let memory_reader = MemoryAssetReader { root: dir };
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build().with_reader(move || Box::new(memory_reader.clone())),
+            AssetSourceBuilder::new(move || Box::new(memory_reader.clone())),
         )
         .add_plugins((
             TaskPoolPlugin::default(),
@@ -2185,7 +2184,7 @@ mod tests {
         let reader = MemoryAssetReader { root: dir.clone() };
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build().with_reader(move || Box::new(reader.clone())),
+            AssetSourceBuilder::new(move || Box::new(reader.clone())),
         )
         .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()));
 
@@ -2241,7 +2240,7 @@ mod tests {
         let reader = MemoryAssetReader { root: dir.clone() };
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build().with_reader(move || Box::new(reader.clone())),
+            AssetSourceBuilder::new(move || Box::new(reader.clone())),
         )
         .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()));
 
@@ -2307,12 +2306,12 @@ mod tests {
 
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build()
-                .with_reader(move || Box::new(memory_reader.clone()))
-                .with_watcher(move |sender| {
+            AssetSourceBuilder::new(move || Box::new(memory_reader.clone())).with_watcher(
+                move |sender| {
                     sender_sender.send(sender).unwrap();
                     Some(Box::new(FakeWatcher))
-                }),
+                },
+            ),
         )
         .add_plugins((
             TaskPoolPlugin::default(),
@@ -2495,8 +2494,8 @@ mod tests {
         let dir = Dir::default();
         dir.insert_asset(Path::new("test.u8"), &[]);
 
-        let asset_source = AssetSource::build()
-            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }));
+        let asset_source =
+            AssetSourceBuilder::new(move || Box::new(MemoryAssetReader { root: dir.clone() }));
 
         // Set up the app.
 
@@ -2559,8 +2558,8 @@ mod tests {
         let dir = Dir::default();
         dir.insert_asset(Path::new("test.txt"), &[]);
 
-        let asset_source = AssetSource::build()
-            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }));
+        let asset_source =
+            AssetSourceBuilder::new(move || Box::new(MemoryAssetReader { root: dir.clone() }));
 
         app.register_asset_source(AssetSourceId::Default, asset_source)
             .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
@@ -2611,8 +2610,8 @@ mod tests {
         let dir = Dir::default();
         dir.insert_asset(Path::new("test.txt"), &[]);
 
-        let asset_source = AssetSource::build()
-            .with_reader(move || Box::new(MemoryAssetReader { root: dir.clone() }));
+        let asset_source =
+            AssetSourceBuilder::new(move || Box::new(MemoryAssetReader { root: dir.clone() }));
 
         app.register_asset_source(AssetSourceId::Default, asset_source)
             .add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
diff --git a/crates/bevy_asset/src/processor/tests.rs b/crates/bevy_asset/src/processor/tests.rs
index 6097ac8a26a12..d52dbd6e71748 100644
--- a/crates/bevy_asset/src/processor/tests.rs
+++ b/crates/bevy_asset/src/processor/tests.rs
@@ -25,8 +25,8 @@ use bevy_tasks::BoxedFuture;
 use crate::{
     io::{
         memory::{Dir, MemoryAssetReader, MemoryAssetWriter},
-        AssetReader, AssetReaderError, AssetSource, AssetSourceEvent, AssetSourceId, AssetWatcher,
-        PathStream, Reader,
+        AssetReader, AssetReaderError, AssetSourceBuilder, AssetSourceEvent, AssetSourceId,
+        AssetWatcher, PathStream, Reader,
     },
     processor::{
         AssetProcessor, LoadTransformAndSave, LogEntry, ProcessorState, ProcessorTransactionLog,
@@ -146,8 +146,7 @@ fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor
 
         app.register_asset_source(
             source_id,
-            AssetSource::build()
-                .with_reader(move || Box::new(source_memory_reader.clone()))
+            AssetSourceBuilder::new(move || Box::new(source_memory_reader.clone()))
                 .with_watcher(move |sender: async_channel::Sender<AssetSourceEvent>| {
                     source_event_sender_sender.send_blocking(sender).unwrap();
                     Some(Box::new(FakeWatcher))
diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
index f840a2c23a4da..8f5b4d6ae64cb 100644
--- a/crates/bevy_gltf/src/loader/mod.rs
+++ b/crates/bevy_gltf/src/loader/mod.rs
@@ -1908,7 +1908,7 @@ mod test {
     use bevy_asset::{
         io::{
             memory::{Dir, MemoryAssetReader},
-            AssetSource, AssetSourceId,
+            AssetSourceBuilder, AssetSourceId,
         },
         AssetApp, AssetLoader, AssetPlugin, AssetServer, Assets, Handle, LoadState,
     };
@@ -1925,7 +1925,7 @@ mod test {
         let reader = MemoryAssetReader { root: dir };
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build().with_reader(move || Box::new(reader.clone())),
+            AssetSourceBuilder::new(move || Box::new(reader.clone())),
         )
         .add_plugins((
             LogPlugin::default(),
@@ -2344,7 +2344,7 @@ mod test {
         // Create a default asset source so we definitely don't try to read from disk.
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build().with_reader(move || {
+            AssetSourceBuilder::new(move || {
                 Box::new(MemoryAssetReader {
                     root: Dir::default(),
                 })
@@ -2352,7 +2352,7 @@ mod test {
         )
         .register_asset_source(
             "custom",
-            AssetSource::build().with_reader(move || Box::new(custom_reader.clone())),
+            AssetSourceBuilder::new(move || Box::new(custom_reader.clone())),
         )
         .add_plugins((
             LogPlugin::default(),
diff --git a/examples/asset/custom_asset_reader.rs b/examples/asset/custom_asset_reader.rs
index 4241725784014..d95abb6a6b650 100644
--- a/examples/asset/custom_asset_reader.rs
+++ b/examples/asset/custom_asset_reader.rs
@@ -4,8 +4,8 @@
 
 use bevy::{
     asset::io::{
-        AssetReader, AssetReaderError, AssetSource, AssetSourceId, ErasedAssetReader, PathStream,
-        Reader,
+        AssetReader, AssetReaderError, AssetSource, AssetSourceBuilder, AssetSourceId,
+        ErasedAssetReader, PathStream, Reader,
     },
     prelude::*,
 };
@@ -42,7 +42,7 @@ impl Plugin for CustomAssetReaderPlugin {
     fn build(&self, app: &mut App) {
         app.register_asset_source(
             AssetSourceId::Default,
-            AssetSource::build().with_reader(|| {
+            AssetSourceBuilder::new(|| {
                 Box::new(CustomAssetReader(
                     // This is the default reader for the current platform
                     AssetSource::get_default_reader("assets".to_string())(),
diff --git a/release-content/migration-guides/custom_asset_source_infallible.md b/release-content/migration-guides/custom_asset_source_infallible.md
new file mode 100644
index 0000000000000..4a921982525ff
--- /dev/null
+++ b/release-content/migration-guides/custom_asset_source_infallible.md
@@ -0,0 +1,28 @@
+---
+title: Custom asset sources now require a reader.
+pull_requests: [21721]
+---
+
+Previously, it was possible to create asset sources with no reader, resulting in your asset sources
+silently being skipped. This is no longer possible, since `AssetSourceBuilder` must now be given a
+reader to start. We also slightly changed how sources are expected to be built.
+
+In previous versions, creating a custom source would look like:
+
+```rust
+AssetSource::build()
+    .with_reader(move || todo!("the reader!"))
+    .with_writer(move || todo!())
+    .with_processed_reader(move || todo!())
+    .with_processed_writer(move || todo!())
+```
+
+In Bevy 0.18, this now looks like:
+
+```rust
+// You may need to import AssetSourceBuilder.
+AssetSourceBuilder::new(move || todo!("the reader!"))
+    .with_writer(move || todo!())
+    .with_processed_reader(move || todo!())
+    .with_processed_writer(move || todo!())
+```
