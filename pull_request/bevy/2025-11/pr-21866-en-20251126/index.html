<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21866 Only present when RenderTarget has been written to
        
    </title><meta content="#21866 Only present when RenderTarget has been written to" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-11/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-11-26</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-11/pr-21866-zh-cn-20251126>中文</a></div></div><div class=pr-content><h1 id=only-present-when-rendertarget-has-been-written-to>Only present when RenderTarget has been written to</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Only present when RenderTarget has been written to<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21866<li><strong>Author</strong>: tychedelia<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-11-17T01:21:56Z<li><strong>Merged</strong>: 2025-11-26T22:15:03Z<li><strong>Merged By</strong>: mockersf</ul><h2 id=description-translation>Description Translation</h2><p>For Processing, we sometimes want to accumulate multiple render updates in the intermediate view texture prior to calling present. Right now, any time the render graph runs it will try to unconditionally present, regardless of whether any work has actually been written to the output target causing unnecessary churn and wasting battery. This is particularly problematic for us as we have a requirement that only a single camera can be active at a time, so to render 3 cameras we need to run app update 3 times at least.<p>NB: previous comments regarding <code>ViewTarget</code> may be misleading. You don’t have to drop views when re-creating the swapchain, just the existing texture as far as I can tell.<p>To test:<details><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>//! A simple 3D scene with light shining over a cube sitting on a plane.
</span><span>
</span><span style=color:#fa6e32>use </span><span>bevy</span><span style=color:#ed9366>::</span><span>camera</span><span style=color:#ed9366>::</span><span>CameraOutputMode</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>use </span><span>bevy</span><span style=color:#ed9366>::</span><span>prelude</span><span style=color:#ed9366>::*</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>    App</span><span style=color:#ed9366>::</span><span>new()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>(DefaultPlugins)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(Startup</span><span style=color:#61676ccc>,</span><span> setup)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>add_systems</span><span>(Update</span><span style=color:#61676ccc>,</span><span> update)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>run</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>/// set up a simple 3D scene
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>setup</span><span>(
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>commands</span><span style=color:#61676ccc>:</span><span> Commands,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>meshes</span><span style=color:#61676ccc>: </span><span>ResMut&LTAssets&LTMesh>>,
</span><span>    </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>materials</span><span style=color:#61676ccc>: </span><span>ResMut&LTAssets&LTStandardMaterial>>,
</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// circular base
</span><span>    commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>        Mesh3d(meshes</span><span style=color:#ed9366>.</span><span style=color:#f07171>add</span><span>(Circle</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>4.0</span><span>)))</span><span style=color:#61676ccc>,
</span><span>        MeshMaterial3d(materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>add</span><span>(Color</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>WHITE</span><span>))</span><span style=color:#61676ccc>,
</span><span>        Transform</span><span style=color:#ed9366>::</span><span>from_rotation(Quat</span><span style=color:#ed9366>::</span><span>from_rotation_x(</span><span style=color:#ed9366>-</span><span>std</span><span style=color:#ed9366>::</span><span>f32</span><span style=color:#ed9366>::</span><span>consts</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>FRAC_PI_2</span><span>))</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// cube
</span><span>    commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>        Mesh3d(meshes</span><span style=color:#ed9366>.</span><span style=color:#f07171>add</span><span>(Cuboid</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>1.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1.0</span><span>)))</span><span style=color:#61676ccc>,
</span><span>        MeshMaterial3d(materials</span><span style=color:#ed9366>.</span><span style=color:#f07171>add</span><span>(Color</span><span style=color:#ed9366>::</span><span>srgb_u8(</span><span style=color:#ff8f40>124</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>144</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>255</span><span>)))</span><span style=color:#61676ccc>,
</span><span>        Transform</span><span style=color:#ed9366>::</span><span>from_xyz(</span><span style=color:#ff8f40>0.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.5</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0.0</span><span>)</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// light
</span><span>    commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>        PointLight {
</span><span>            shadows_enabled</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#ed9366>..</span><span style=color:#f07171>default</span><span>()
</span><span>        }</span><span style=color:#61676ccc>,
</span><span>        Transform</span><span style=color:#ed9366>::</span><span>from_xyz(</span><span style=color:#ff8f40>4.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>8.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>4.0</span><span>)</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// camera
</span><span>    commands</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>((
</span><span>        Camera3d</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>,
</span><span>        Transform</span><span style=color:#ed9366>::</span><span>from_xyz(</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>2.5</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>4.5</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>9.0</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>looking_at</span><span>(Vec3</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ZERO</span><span style=color:#61676ccc>, </span><span>Vec3</span><span style=color:#ed9366>::</span><span>Y)</span><span style=color:#61676ccc>,
</span><span>    ))</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>update</span><span>(</span><span style=color:#ff8f40>buttons</span><span style=color:#61676ccc>: </span><span>Res&LTButtonInput&LTKeyCode>>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>cameras</span><span style=color:#61676ccc>: </span><span>Query<</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Camera>) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> buttons</span><span style=color:#ed9366>.</span><span style=color:#f07171>just_pressed</span><span>(KeyCode</span><span style=color:#ed9366>::</span><span>Space) {
</span><span>        </span><span style=color:#fa6e32>for mut</span><span> camera </span><span style=color:#ed9366>in &</span><span style=color:#fa6e32>mut</span><span> cameras {
</span><span>            </span><span style=color:#fa6e32>match</span><span> camera</span><span style=color:#ed9366>.</span><span>output_mode {
</span><span>                CameraOutputMode</span><span style=color:#ed9366>::</span><span>Write { </span><span style=color:#ed9366>.. </span><span>} </span><span style=color:#ed9366>=> </span><span>{
</span><span>                    camera</span><span style=color:#ed9366>.</span><span>output_mode </span><span style=color:#ed9366>= </span><span>CameraOutputMode</span><span style=color:#ed9366>::</span><span>Skip</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>                CameraOutputMode</span><span style=color:#ed9366>::</span><span>Skip </span><span style=color:#ed9366>=> </span><span>{
</span><span>                    camera</span><span style=color:#ed9366>.</span><span>output_mode </span><span style=color:#ed9366>= </span><span>CameraOutputMode</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre></details><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a performance optimization problem in Bevy’s rendering system where swap chain presentation was happening unconditionally every frame, regardless of whether any actual rendering work had been done to the output target. The issue was particularly problematic for applications that need to accumulate multiple render updates before presenting, or when using multiple cameras that don’t all render every frame.<p>The core problem stemmed from Bevy’s previous approach to handling swap chain textures. In the original implementation, the render system would always remove all <code>ViewTarget</code> components at the end of each frame and present every window’s swap chain texture. This caused unnecessary GPU work and battery drain, especially in scenarios where cameras could be toggled between rendering modes.<p>The solution implemented in this PR introduces a conditional presentation mechanism that only presents windows when their associated render targets have actually been written to. The implementation follows a clear technical approach:<p>First, the PR adds tracking capability to determine if a render target has been used. In <code>texture_attachment.rs</code>, a new <code>needs_present()</code> method is added to <code>OutputColorAttachment</code> that leverages the existing <code>is_first_call</code> atomic flag to track whether the attachment has been written to by a render pass. This is a clever reuse of existing state that avoids adding new tracking overhead.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>needs_present</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#ed9366>!</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>is_first_call</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>SeqCst)
</span><span>}
</span></code></pre><p>This capability is then exposed through the <code>ViewTarget</code> in <code>view/mod.rs</code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>needs_present</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>out_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>needs_present</span><span>()
</span><span>}
</span></code></pre><p>The main rendering logic in <code>renderer/mod.rs</code> undergoes significant changes. Instead of querying just for entities with <code>ViewTarget</code>, the system now queries for both <code>ViewTarget</code> and <code>ExtractedCamera</code> components. The presentation logic becomes conditional:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>for </span><span>(view_target</span><span style=color:#61676ccc>,</span><span> camera) </span><span style=color:#ed9366>in</span><span> views</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(NormalizedRenderTarget</span><span style=color:#ed9366>::</span><span>Window(window)) </span><span style=color:#ed9366>=</span><span> camera</span><span style=color:#ed9366>.</span><span>target
</span><span>        </span><span style=color:#ed9366>&&</span><span> view_target</span><span style=color:#ed9366>.</span><span style=color:#f07171>needs_present</span><span>()
</span><span>    {
</span><span>        </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(window) </span><span style=color:#ed9366>=</span><span> windows</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span>window</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>()) </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        window</span><span style=color:#ed9366>.</span><span style=color:#f07171>present</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>This change eliminates the previous practice of unconditionally removing <code>ViewTarget</code> components, which was originally thought necessary for swap chain re-creation but proved to be overly aggressive.<p>The window management system in <code>view/window/mod.rs</code> gets enhanced with better swap chain texture lifecycle management. A new <code>present()</code> method is added to <code>ExtractedWindow</code> that handles the actual presentation:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>present</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(surface_texture) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>swap_chain_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>        surface_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>present</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The extraction and preparation logic is updated to preserve swap chain textures when they haven’t been presented, reducing unnecessary re-creation:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if</span><span> extracted_window</span><span style=color:#ed9366>.</span><span>swap_chain_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>    extracted_window</span><span style=color:#ed9366>.</span><span>swap_chain_texture_view </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>And in <code>prepare_windows</code>, the system now skips swap chain re-creation when the existing texture is still valid:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if</span><span> window</span><span style=color:#ed9366>.</span><span style=color:#f07171>has_swapchain_texture</span><span>() </span><span style=color:#ed9366>&& !</span><span>window</span><span style=color:#ed9366>.</span><span>size_changed </span><span style=color:#ed9366>&& !</span><span>window</span><span style=color:#ed9366>.</span><span>present_mode_changed {
</span><span>    </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The technical insight here is that swap chain textures don’t need to be recreated every frame if they haven’t been presented and the window configuration hasn’t changed. This optimization reduces GPU overhead and improves battery life, especially for applications that render intermittently.<p>The impact of these changes is substantial for applications that use camera toggling or multi-pass rendering. The provided test case demonstrates this by allowing users to toggle camera output modes with the space bar, switching between <code>Write</code> and <code>Skip</code> modes. When cameras are in <code>Skip</code> mode, their associated windows won’t be presented, saving significant computational resources.<p>This implementation maintains backward compatibility while providing meaningful performance improvements. The changes are particularly beneficial for mobile applications and other battery-constrained environments where unnecessary GPU work directly impacts user experience.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Render System] --> B{Query ViewTarget & Camera}
</span><span>    B --> C{ViewTarget needs_present?}
</span><span>    C -->|Yes| D[Present Window]
</span><span>    C -->|No| E[Skip Presentation]
</span><span>    D --> F[Drop swap_chain_texture]
</span><span>    E --> G[Preserve swap_chain_texture]
</span><span>    F --> H[Next Frame]
</span><span>    G --> H
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-render-src-renderer-mod-rs><code>crates/bevy_render/src/renderer/mod.rs</code></h3><p>This file contains the main rendering system logic. The changes transition from unconditional presentation to conditional presentation based on whether render targets have been written to.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> view_entities </span><span style=color:#ed9366>=</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(world)</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span>collect</span><span style=color:#ed9366>::</span><span><</span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#ed9366>_</span><span>>>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>for</span><span> view_entity </span><span style=color:#ed9366>in</span><span> view_entities {
</span><span>    world</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity_mut</span><span>(view_entity)</span><span style=color:#ed9366>.</span><span>remove</span><span style=color:#ed9366>::</span><span>&LTViewTarget>()</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>let mut</span><span> windows </span><span style=color:#ed9366>=</span><span> world</span><span style=color:#ed9366>.</span><span>resource_mut</span><span style=color:#ed9366>::</span><span>&LTExtractedWindows>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>for</span><span> window </span><span style=color:#ed9366>in</span><span> windows</span><span style=color:#ed9366>.</span><span style=color:#f07171>values_mut</span><span>() {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(surface_texture) </span><span style=color:#ed9366>=</span><span> window</span><span style=color:#ed9366>.</span><span>swap_chain_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>        surface_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>present</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>resource_scope</span><span>(|</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>windows</span><span style=color:#61676ccc>: </span><span>Mut&LTExtractedWindows>| {
</span><span>    </span><span style=color:#fa6e32>let</span><span> views </span><span style=color:#ed9366>=</span><span> state</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(world)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for </span><span>(view_target</span><span style=color:#61676ccc>,</span><span> camera) </span><span style=color:#ed9366>in</span><span> views</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(NormalizedRenderTarget</span><span style=color:#ed9366>::</span><span>Window(window)) </span><span style=color:#ed9366>=</span><span> camera</span><span style=color:#ed9366>.</span><span>target
</span><span>            </span><span style=color:#ed9366>&&</span><span> view_target</span><span style=color:#ed9366>.</span><span style=color:#f07171>needs_present</span><span>()
</span><span>        {
</span><span>            </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(window) </span><span style=color:#ed9366>=</span><span> windows</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>&</span><span>window</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>()) </span><span style=color:#fa6e32>else </span><span>{
</span><span>                </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>            }</span><span style=color:#61676ccc>;
</span><span>            window</span><span style=color:#ed9366>.</span><span style=color:#f07171>present</span><span>()</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-render-src-texture-texture-attachment-rs><code>crates/bevy_render/src/texture/texture_attachment.rs</code></h3><p>Added the core tracking mechanism to determine if an attachment has been written to.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>needs_present</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#ed9366>!</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>is_first_call</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>SeqCst)
</span><span>}
</span></code></pre><h3 id=crates-bevy-render-src-view-mod-rs><code>crates/bevy_render/src/view/mod.rs</code></h3><p>Exposed the presentation tracking through the ViewTarget interface.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>needs_present</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>out_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>needs_present</span><span>()
</span><span>}
</span></code></pre><h3 id=crates-bevy-render-src-view-window-mod-rs><code>crates/bevy_render/src/view/window/mod.rs</code></h3><p>Enhanced window management with better swap chain lifecycle handling and conditional presentation.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>present</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(surface_texture) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>swap_chain_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>() {
</span><span>        surface_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>present</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// In extraction:
</span><span style=color:#fa6e32>if</span><span> extracted_window</span><span style=color:#ed9366>.</span><span>swap_chain_texture</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>    extracted_window</span><span style=color:#ed9366>.</span><span>swap_chain_texture_view </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// In preparation:
</span><span style=color:#fa6e32>if</span><span> window</span><span style=color:#ed9366>.</span><span style=color:#f07171>has_swapchain_texture</span><span>() </span><span style=color:#ed9366>&& !</span><span>window</span><span style=color:#ed9366>.</span><span>size_changed </span><span style=color:#ed9366>&& !</span><span>window</span><span style=color:#ed9366>.</span><span>present_mode_changed {
</span><span>    </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/rendering/render-graph/ target=_blank>Bevy Render Graph Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/wgpu/latest/wgpu/struct.Surface.html#method.get_current_texture target=_blank>wgpu Surface Presentation</a><li><a rel="noopener nofollow noreferrer" href=https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain target=_blank>Vulkan Swap Chain Management</a></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-11/pr_21866.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>