<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21649 Various Solari improvements
        
    </title><meta content="#21649 Various Solari improvements" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-11/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-11-02</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-11/pr-21649-zh-cn-20251102>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Various Solari improvements<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Various Solari improvements<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21649<li><strong>Author</strong>: JMS55<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Bug, A-Rendering, S-Ready-For-Final-Review, C-Refinement<li><strong>Created</strong>: 2025-10-25T00:59:44Z<li><strong>Merged</strong>: 2025-11-02T17:59:48Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><ul><li>Fix compile error when compiling with DLSS enabled after https://github.com/bevyengine/bevy/pull/21205<li>Use permutation sampling for ReSTIR DI temporal reuse to fix artifacts under DLSS-RR <ul><li>For both DI and GI, removed the spatial raytrace, and moved it to the final reservoir before shading.</ul><li>Reduced DI initial samples 32 -> 8 for better performance at the cost of quality<li>Various specular GI improvements and bugfixes (still kinda terrible overall, I need to do some research on how people usually do this kind of thing)<li>Made the world cache adapt faster / be less stable<li>Switched spatial hashing collisions from to linear probing</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses several technical challenges in Bevy’s Solari real-time global illumination system, focusing on fixing bugs, improving performance, and reducing visual artifacts. The changes span multiple components of the rendering pipeline with a common theme: making the GI system more robust and efficient.<p>The work began with a straightforward bug fix for DLSS compilation errors. After PR #21205, the DLSS integration was broken due to incorrect bind group layout handling. The fix was simple but critical - properly retrieving the bind group layout from the pipeline cache:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>bind_group_layout_resolve_dlss_rr_textures</span><span style=color:#61676ccc>,
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#ed9366>&</span><span>pipeline_cache</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_bind_group_layout</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>bind_group_layout_resolve_dlss_rr_textures)</span><span style=color:#61676ccc>,
</span></code></pre><p>The core improvements focus on the ReSTIR (Reservoir-based Spatio-Temporal Importance Resampling) implementation. The most significant change was adopting permutation sampling for temporal reuse in both Direct Illumination (DI) and Global Illumination (GI). Under DLSS-RR, traditional temporal sampling could produce artifacts due to the relationship between sample positions and DLSS’s reconstruction. Permutation sampling breaks this correlation by deterministically shuffling pixel coordinates each frame:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>fn permute_pixel(pixel_id: vec2&LTu32>, frame_index: u32, view_size: vec2&LTf32>) -> vec2&LTu32> {
</span><span>    let r = frame_index;
</span><span>    let offset = vec2(r & 3u, (r >> 2u) & 3u);
</span><span>    var shifted_pixel_id = pixel_id + offset;
</span><span>    shifted_pixel_id ^= vec2(3u);
</span><span>    shifted_pixel_id -= offset;
</span><span>    return min(shifted_pixel_id, vec2&LTu32>(view_size - 1.0));
</span><span>}
</span></code></pre><p>This approach significantly reduced temporal artifacts while maintaining the benefits of reuse across frames.<p>Another key optimization was restructuring when visibility testing occurs. Previously, spatial reuse involved tracing rays for each neighbor sample during the gathering phase. This was moved to the final shading stage, where only the selected sample needs visibility testing:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// In restir_di.wgsl - visibility test moved to final reservoir
</span><span>if reservoir_valid(combined_reservoir) {
</span><span>    let resolved_light_sample = resolve_light_sample(combined_reservoir.sample, light_sources[combined_reservoir.sample.light_id >> 16u]);
</span><span>    combined_reservoir.unbiased_contribution_weight *= trace_light_visibility(surface.world_position, resolved_light_sample.world_position);
</span><span>}
</span></code></pre><p>This change reduced the number of ray traces from potentially dozens per pixel to exactly one, providing substantial performance gains.<p>For performance tuning, the DI initial samples were reduced from 32 to 8. This trade-off sacrifices some quality for better performance, as fewer initial light samples are evaluated. The change reflects practical engineering considerations for real-time rendering where performance targets must be met.<p>The world cache system received multiple improvements to make it more responsive. The temporal accumulation window was halved from 20 to 10 frames, and cell lifetime was drastically reduced from 30 to 4 frames. This makes the cache adapt faster to scene changes but potentially increases noise. The collision resolution strategy was also changed from hash-based probing to linear probing, which can provide better cache locality.<p>For specular GI, several adjustments were made. The roughness threshold for using ReSTIR GI reservoirs was increased from 0.04 to 0.1, meaning more surfaces will benefit from the optimized path. The glossy path tracing was restructured to accumulate world cache contributions at each bounce rather than only at termination:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Add world cache contribution at each bounce
</span><span>let diffuse_brdf = ray_hit.material.base_color / PI;
</span><span>radiance += throughput * diffuse_brdf * query_world_cache(ray_hit.world_position, ray_hit.geometric_world_normal, view.world_position, rng);
</span></code></pre><p>The author notes that specular GI remains challenging and acknowledges the need for further research into established techniques in this area.<p>A subtle but important improvement was adding position jittering to world cache queries, implementing a technique referenced from external research. This reduces artifacts by sampling slightly offset positions in the tangent plane:<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Jitter world position in tangent plane to reduce artifacts
</span><span>let TBN = orthonormalize(world_normal);
</span><span>let offset = (rand_vec2f(rng) * 2.0 - 1.0) * cell_size * 0.5;
</span><span>let jittered_position = world_position + offset.x * TBN[0] + offset.y * TBN[1];
</span></code></pre><p>The changes demonstrate a systematic approach to real-time rendering optimization: identify performance bottlenecks, reduce redundant computations, implement proven sampling techniques, and make deliberate quality/performance trade-offs where appropriate. The improvements work together to create a more robust and efficient global illumination system while maintaining visual quality.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    A[DLSS Integration] --> B[ReSTIR DI/GI Pipeline]
</span><span>    C[World Cache System] --> B
</span><span>    D[Specular GI] --> B
</span><span>    
</span><span>    B --> E[Temporal Reuse]
</span><span>    B --> F[Spatial Reuse]
</span><span>    B --> G[Final Shading]
</span><span>    
</span><span>    E --> H[Permutation Sampling]
</span><span>    F --> I[Visibility Optimization]
</span><span>    G --> J[Quality/Performance Balance]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-solari-src-realtime-restir-di-wgsl-10-12><code>crates/bevy_solari/src/realtime/restir_di.wgsl</code> (+10/-12)</h3><p><strong>Purpose</strong>: Optimize Direct Illumination ReSTIR implementation<ul><li>Reduced initial samples from 32 to 8 for performance<li>Moved visibility testing to final reservoir<li>Added permutation sampling for temporal reuse</ul><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Key change: Reduced initial samples
</span><span>const INITIAL_SAMPLES = 8u;  // Was 32u
</span><span>
</span><span>// Key change: Visibility testing moved to final stage
</span><span>if reservoir_valid(combined_reservoir) {
</span><span>    let resolved_light_sample = resolve_light_sample(combined_reservoir.sample, light_sources[combined_reservoir.sample.light_id >> 16u]);
</span><span>    combined_reservoir.unbiased_contribution_weight *= trace_light_visibility(surface.world_position, resolved_light_sample.world_position);
</span><span>}
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-restir-gi-wgsl-24-56><code>crates/bevy_solari/src/realtime/restir_gi.wgsl</code> (+24/-56)</h3><p><strong>Purpose</strong>: Optimize Global Illumination ReSTIR implementation<ul><li>Simplified temporal reservoir loading using permutation sampling<li>Moved visibility testing to final reservoir<li>Cleaned up merge logic and removed redundant permutation function</ul><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Key change: Simplified temporal loading with permutation
</span><span>let temporal_pixel_id = permute_pixel(vec2&LTu32>(temporal_pixel_id_float), constants.frame_index, view.viewport.zw);
</span><span>
</span><span>// Key change: Final visibility test
</span><span>combined_reservoir.radiance *= trace_point_visibility(surface.world_position, combined_reservoir.sample_point_world_position);
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-world-cache-query-wgsl-16-7><code>crates/bevy_solari/src/realtime/world_cache_query.wgsl</code> (+16/-7)</h3><p><strong>Purpose</strong>: Improve world cache responsiveness and reduce artifacts<ul><li>Reduced temporal accumulation and cell lifetime for faster adaptation<li>Added position jittering to reduce artifacts<li>Changed collision resolution to linear probing</ul><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Key changes: Faster adaptation
</span><span>const WORLD_CACHE_MAX_TEMPORAL_SAMPLES: f32 = 10.0;  // Was 20.0
</span><span>const WORLD_CACHE_CELL_LIFETIME: u32 = 4u;           // Was 30u
</span><span>
</span><span>// Key change: Position jittering
</span><span>let TBN = orthonormalize(world_normal);
</span><span>let offset = (rand_vec2f(rng) * 2.0 - 1.0) * cell_size * 0.5;
</span><span>let jittered_position = world_position + offset.x * TBN[0] + offset.y * TBN[1];
</span><span>
</span><span>// Key change: Linear probing for collisions
</span><span>key += 1u;  // Was: key = wrap_key(pcg_hash(key));
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-specular-gi-wgsl-13-7><code>crates/bevy_solari/src/realtime/specular_gi.wgsl</code> (+13/-7)</h3><p><strong>Purpose</strong>: Improve specular global illumination quality<ul><li>Increased roughness threshold for ReSTIR GI reuse<li>Restructured path tracing to accumulate world cache contributions<li>Fixed cosine term calculation</ul><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// Key change: Higher roughness threshold
</span><span>if surface.material.roughness > 0.1 {  // Was 0.04
</span><span>
</span><span>// Key change: Accumulate world cache at each bounce
</span><span>radiance += throughput * diffuse_brdf * query_world_cache(ray_hit.world_position, ray_hit.geometric_world_normal, view.world_position, rng);
</span><span>
</span><span>// Key change: Fixed cosine term
</span><span>let cos_theta = saturate(dot(wi, N));  // Was: dot(wi, N)
</span></code></pre><h3 id=crates-bevy-solari-src-realtime-gbuffer-utils-wgsl-9-0><code>crates/bevy_solari/src/realtime/gbuffer_utils.wgsl</code> (+9/-0)</h3><p><strong>Purpose</strong>: Add permutation sampling utility function<ul><li>Centralized permutation sampling logic for reuse across DI and GI</ul><pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// New utility function for permutation sampling
</span><span>fn permute_pixel(pixel_id: vec2&LTu32>, frame_index: u32, view_size: vec2&LTf32>) -> vec2&LTu32> {
</span><span>    let r = frame_index;
</span><span>    let offset = vec2(r & 3u, (r >> 2u) & 3u);
</span><span>    var shifted_pixel_id = pixel_id + offset;
</span><span>    shifted_pixel_id ^= vec2(3u);
</span><span>    shifted_pixel_id -= offset;
</span><span>    return min(shifted_pixel_id, vec2&LTu32>(view_size - 1.0));
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://research.nvidia.com/publication/2020-07_restir-reservoir-based-spatio-temporal-importance-resampling target=_blank>ReSTIR Paper</a> - Original research on reservoir-based spatio-temporal importance resampling<li><a rel="noopener nofollow noreferrer" href=https://tomclabault.github.io/blog/2025/regir target=_blank>Real-time Global Illumination</a> - Blog post referenced for world cache jittering technique<li><a rel="noopener nofollow noreferrer" href=https://developer.nvidia.com/dlss target=_blank>DLSS Documentation</a> - NVIDIA DLSS technology overview<li><a rel="noopener nofollow noreferrer" href=https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling target=_blank>Importance Sampling Techniques</a> - Theoretical background on sampling methods used in ReSTIR</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-11/pr_21649.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>