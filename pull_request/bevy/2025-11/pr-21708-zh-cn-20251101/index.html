<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21708 Fix asset processing tests being flaky from hot reloading.
        
    </title><meta content="#21708 Fix asset processing tests being flaky from hot reloading." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-11/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-11-01</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-11/pr-21708-en-20251101>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=fix-asset-processing-tests-being-flaky-from-hot-reloading>Fix asset processing tests being flaky from hot reloading</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Fix asset processing tests being flaky from hot reloading.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21708<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Assets, S-Ready-For-Final-Review, C-Testing, D-Straightforward<li><strong>Created</strong>: 2025-10-31T23:50:30Z<li><strong>Merged</strong>: 2025-11-01T01:01:56Z<li><strong>Merged By</strong>: cart</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h1 id=mu-biao>目标</h1><ul><li>修复 #21673 中引入的不稳定的资产处理测试。<li>之前的热重载处理器测试只会检查完成的处理器状态。但在多线程模式下，处理可能没有足够快地开始，导致测试仍然看到状态为已完成。</ul><h2 id=jie-jue-fang-an>解决方案</h2><ul><li>使用锁来阻止读取源目录，直到处理开始后。这样资产处理器在守卫释放之前甚至无法检查是否有工作要做，因此我们不会错过处理状态。</ul><h2 id=ce-shi>测试</h2><ul><li>在本地以单线程和多线程模式运行。</ul><h2 id=zhe-ge-la-qu-qing-qiu-de-gu-shi>这个拉取请求的故事</h2><p>这个拉取请求解决了一个在多线程环境下出现的竞态条件问题，该问题导致资产处理测试变得不稳定。<p>问题的核心在于测试逻辑和资产处理器线程之间的时序问题。在原来的实现中，测试会设置资产数据，然后立即检查处理器的状态。但是在多线程环境中，资产处理器的后台线程可能还没有开始处理工作，测试就已经检查了处理器状态并错误地认为处理已经完成。<p>开发者采用了同步机制来解决这个问题。具体来说，他们引入了一个读写锁（RwLock）来协调测试代码和资产处理器线程之间的执行顺序：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>AppWithProcessor </span><span>{
</span><span>    app</span><span style=color:#61676ccc>:</span><span> App,
</span><span>    source_gate</span><span style=color:#61676ccc>: </span><span>Arc&LTRwLock<()>>,  </span><span style=color:#abb0b6;font-style:italic>// 新增的同步机制
</span><span>    default_source_dirs</span><span style=color:#61676ccc>:</span><span> ProcessingDirs,
</span><span>    extra_sources_dirs</span><span style=color:#61676ccc>: </span><span>HashMap<</span><span style=color:#55b4d4;font-style:italic>String</span><span>, ProcessingDirs>,
</span><span>}
</span></code></pre><p>这个 <code>source_gate</code> 的作用是在测试开始时获取写锁，从而阻止资产处理器读取源目录。只有当测试完成所有设置工作并准备好让处理器开始工作时，才会释放这个锁。<p>为了实现这个同步机制，开发者创建了一个新的 <code>LockGatedReader</code> 包装器：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>LockGatedReader</span><span>&LTR</span><span style=color:#61676ccc>:</span><span> AssetReader> {
</span><span>    reader</span><span style=color:#61676ccc>:</span><span> R,
</span><span>    gate</span><span style=color:#61676ccc>: </span><span>Arc&LTRwLock<()>>,
</span><span>}
</span></code></pre><p>这个包装器实现了 <code>AssetReader</code> trait，在所有读取操作之前都会先获取读锁。由于测试持有写锁，这些读取操作会被阻塞，直到测试释放锁。<p>测试执行流程也进行了重构：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>run_app_until_finished_processing</span><span>(</span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App, </span><span style=color:#ff8f40>guard</span><span style=color:#61676ccc>: </span><span>RwLockWriteGuard<'</span><span style=color:#ed9366>_</span><span>, ()>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> processor </span><span style=color:#ed9366>=</span><span> app</span><span style=color:#ed9366>.</span><span style=color:#f07171>world</span><span>()</span><span style=color:#ed9366>.</span><span>resource</span><span style=color:#ed9366>::</span><span>&LTAssetProcessor>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 等待处理器开始处理
</span><span>    </span><span style=color:#f07171>run_app_until</span><span>(app</span><span style=color:#61676ccc>, </span><span>|_| {
</span><span>        </span><span style=color:#fa6e32>let</span><span> state </span><span style=color:#ed9366>= </span><span>bevy_tasks</span><span style=color:#ed9366>::</span><span>block_on(processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_state</span><span>())</span><span style=color:#61676ccc>;
</span><span>        (state </span><span style=color:#ed9366>== </span><span>ProcessorState</span><span style=color:#ed9366>::</span><span>Processing </span><span style=color:#ed9366>||</span><span> state </span><span style=color:#ed9366>== </span><span>ProcessorState</span><span style=color:#ed9366>::</span><span>Initializing)</span><span style=color:#ed9366>.</span><span style=color:#f07171>then_some</span><span>(())
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>drop</span><span>(guard)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// 释放锁，允许处理器读取源目录
</span><span>    </span><span style=color:#f07171>run_app_until</span><span>(app</span><span style=color:#61676ccc>, </span><span>|_| {
</span><span>        (bevy_tasks</span><span style=color:#ed9366>::</span><span>block_on(processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_state</span><span>()) </span><span style=color:#ed9366>== </span><span>ProcessorState</span><span style=color:#ed9366>::</span><span>Finished)</span><span style=color:#ed9366>.</span><span style=color:#f07171>then_some</span><span>(())
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>新的流程分为两个阶段：<ol><li>等待处理器进入 Processing 或 Initializing 状态<li>释放锁，让处理器能够实际读取源目录并处理资产<li>等待处理器完成所有工作</ol><p>这种方法比简单地增加重试次数更加可靠，因为它确保了处理器在测试准备好之前不会开始工作，从而消除了竞态条件。<p>所有相关的测试都被更新以使用这个新的同步机制，每个测试现在都会在开始时获取锁：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> guard </span><span style=color:#ed9366>=</span><span> source_gate</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_blocking</span><span>()</span><span style=color:#61676ccc>;
</span></code></pre><p>这个解决方案展示了在处理多线程测试时的一个重要模式：使用同步原语来控制并发执行的顺序，而不是依赖于时间延迟或重试机制。<h2 id=ke-shi-hua-biao-shi>可视化表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[Test Setup] --> B[Acquire Write Lock]
</span><span>    B --> C[Setup Assets]
</span><span>    C --> D[Wait for Processor to Start]
</span><span>    D --> E[Release Lock]
</span><span>    E --> F[Wait for Processor to Finish]
</span><span>    F --> G[Verify Results]
</span><span>    
</span><span>    H[Asset Processor] --> I[Attempt to Read Source]
</span><span>    I --> J[Blocked on Read Lock]
</span><span>    J --> K[Read Lock Acquired]
</span><span>    K --> L[Process Assets]
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><ul><li><code>crates/bevy_asset/src/processor/tests.rs</code> (+115/-33)</ul><p>这个文件包含了所有的修改，主要变化包括：<ol><li>引入了新的同步机制：</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 新增的 LockGatedReader 结构
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>LockGatedReader</span><span>&LTR</span><span style=color:#61676ccc>:</span><span> AssetReader> {
</span><span>    reader</span><span style=color:#61676ccc>:</span><span> R,
</span><span>    gate</span><span style=color:#61676ccc>: </span><span>Arc&LTRwLock<()>>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 更新 AppWithProcessor 结构
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>AppWithProcessor </span><span>{
</span><span>    app</span><span style=color:#61676ccc>:</span><span> App,
</span><span>    source_gate</span><span style=color:#61676ccc>: </span><span>Arc&LTRwLock<()>>,  </span><span style=color:#abb0b6;font-style:italic>// 新增的锁
</span><span>    default_source_dirs</span><span style=color:#61676ccc>:</span><span> ProcessingDirs,
</span><span>    extra_sources_dirs</span><span style=color:#61676ccc>: </span><span>HashMap<</span><span style=color:#55b4d4;font-style:italic>String</span><span>, ProcessingDirs>,
</span><span>}
</span></code></pre><ol start=2><li>重构了测试执行逻辑：</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 之前的方法
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>run_app_until_finished_processing</span><span>(</span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 简单的重试机制
</span><span>    </span><span style=color:#fa6e32>for </span><span style=color:#ed9366>_ in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span style=color:#ff8f40>5 </span><span>{
</span><span>        app</span><span style=color:#ed9366>.</span><span style=color:#f07171>update</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#f07171>run_app_until</span><span>(app</span><span style=color:#61676ccc>, </span><span>|</span><span style=color:#ff8f40>world</span><span>| {
</span><span>        </span><span style=color:#fa6e32>if </span><span>bevy_tasks</span><span style=color:#ed9366>::</span><span>block_on(world</span><span style=color:#ed9366>.</span><span>resource</span><span style=color:#ed9366>::</span><span>&LTAssetProcessor>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_state</span><span>())
</span><span>            </span><span style=color:#ed9366>== </span><span>ProcessorState</span><span style=color:#ed9366>::</span><span>Finished
</span><span>        {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(())
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>None
</span><span>        }
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 新的方法
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>run_app_until_finished_processing</span><span>(</span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App, </span><span style=color:#ff8f40>guard</span><span style=color:#61676ccc>: </span><span>RwLockWriteGuard<'</span><span style=color:#ed9366>_</span><span>, ()>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> processor </span><span style=color:#ed9366>=</span><span> app</span><span style=color:#ed9366>.</span><span style=color:#f07171>world</span><span>()</span><span style=color:#ed9366>.</span><span>resource</span><span style=color:#ed9366>::</span><span>&LTAssetProcessor>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 等待处理器开始处理
</span><span>    </span><span style=color:#f07171>run_app_until</span><span>(app</span><span style=color:#61676ccc>, </span><span>|_| {
</span><span>        </span><span style=color:#fa6e32>let</span><span> state </span><span style=color:#ed9366>= </span><span>bevy_tasks</span><span style=color:#ed9366>::</span><span>block_on(processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_state</span><span>())</span><span style=color:#61676ccc>;
</span><span>        (state </span><span style=color:#ed9366>== </span><span>ProcessorState</span><span style=color:#ed9366>::</span><span>Processing </span><span style=color:#ed9366>||</span><span> state </span><span style=color:#ed9366>== </span><span>ProcessorState</span><span style=color:#ed9366>::</span><span>Initializing)</span><span style=color:#ed9366>.</span><span style=color:#f07171>then_some</span><span>(())
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>drop</span><span>(guard)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// 释放锁
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 等待处理器完成
</span><span>    </span><span style=color:#f07171>run_app_until</span><span>(app</span><span style=color:#61676ccc>, </span><span>|_| {
</span><span>        (bevy_tasks</span><span style=color:#ed9366>::</span><span>block_on(processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_state</span><span>()) </span><span style=color:#ed9366>== </span><span>ProcessorState</span><span style=color:#ed9366>::</span><span>Finished)</span><span style=color:#ed9366>.</span><span style=color:#f07171>then_some</span><span>(())
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ol start=3><li>更新了所有测试用例以使用新的同步机制：</ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>no_meta_or_default_processor_copies_asset</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> AppWithProcessor {
</span><span>        </span><span style=color:#fa6e32>mut</span><span> app</span><span style=color:#61676ccc>,
</span><span>        source_gate</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// 新增
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    } </span><span style=color:#ed9366>= </span><span style=color:#f07171>create_app_with_asset_processor</span><span>(</span><span style=color:#ed9366>&</span><span>[])</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> guard </span><span style=color:#ed9366>=</span><span> source_gate</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_blocking</span><span>()</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// 获取锁
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 设置资产...
</span><span>    source_dir</span><span style=color:#ed9366>.</span><span style=color:#f07171>insert_asset_text</span><span>(path</span><span style=color:#61676ccc>,</span><span> source_asset)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#f07171>run_app_until_finished_processing</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> app</span><span style=color:#61676ccc>,</span><span> guard)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// 传递锁守卫
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 验证结果...
</span><span>}
</span></code></pre><h2 id=jin-yi-bu-yue-du>进一步阅读</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/async-lock/latest/async_lock/struct.RwLock.html target=_blank>RwLock 文档</a> - 了解使用的同步原语<li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/quick-start/assets/ target=_blank>Bevy 资产系统</a> - 了解 Bevy 的资产处理机制<li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch16-00-concurrency.html target=_blank>并发测试模式</a> - Rust 中的并发编程和测试最佳实践</ul><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_asset/src/processor/tests.rs b/crates/bevy_asset/src/processor/tests.rs
</span><span>index 133fde43ee3fd..6097ac8a26a12 100644
</span><span style=color:#c594c5>--- a/crates/bevy_asset/src/processor/tests.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_asset/src/processor/tests.rs
</span><span style=color:#c594c5>@@ -6,6 +6,7 @@ </span><span style=color:#399ee6>use alloc::{
</span><span>     vec,
</span><span>     vec::Vec,
</span><span> };
</span><span style=color:#86b300>+use async_lock::{RwLock, RwLockWriteGuard};
</span><span> use bevy_platform::{
</span><span>     collections::HashMap,
</span><span>     sync::{Mutex, PoisonError},
</span><span style=color:#c594c5>@@ -24,7 +25,8 @@ </span><span style=color:#399ee6>use bevy_tasks::BoxedFuture;
</span><span> use crate::{
</span><span>     io::{
</span><span>         memory::{Dir, MemoryAssetReader, MemoryAssetWriter},
</span><span style=color:#f07171>-        AssetSource, AssetSourceEvent, AssetSourceId, AssetWatcher, Reader,
</span><span style=color:#86b300>+        AssetReader, AssetReaderError, AssetSource, AssetSourceEvent, AssetSourceId, AssetWatcher,
</span><span style=color:#86b300>+        PathStream, Reader,
</span><span>     },
</span><span>     processor::{
</span><span>         AssetProcessor, LoadTransformAndSave, LogEntry, ProcessorState, ProcessorTransactionLog,
</span><span style=color:#c594c5>@@ -45,12 +47,55 @@ </span><span style=color:#399ee6>struct ProcessingDirs {
</span><span> 
</span><span> struct AppWithProcessor {
</span><span>     app: App,
</span><span style=color:#86b300>+    source_gate: Arc&LTRwLock<()>>,
</span><span>     default_source_dirs: ProcessingDirs,
</span><span>     extra_sources_dirs: HashMap&LTString, ProcessingDirs>,
</span><span> }
</span><span> 
</span><span style=color:#86b300>+/// Similar to [`crate::io::gated::GatedReader`], but uses a lock instead of a channel to avoid
</span><span style=color:#86b300>+/// needing to send the "correct" number of messages.
</span><span style=color:#86b300>+#[derive(Clone)]
</span><span style=color:#86b300>+struct LockGatedReader&LTR: AssetReader> {
</span><span style=color:#86b300>+    reader: R,
</span><span style=color:#86b300>+    gate: Arc&LTRwLock<()>>,
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+impl&LTR: AssetReader> LockGatedReader&LTR> {
</span><span style=color:#86b300>+    /// Creates a new [`GatedReader`], which wraps the given `reader`. Also returns a [`GateOpener`] which
</span><span style=color:#86b300>+    /// can be used to open "path gates" for this [`GatedReader`].
</span><span style=color:#86b300>+    fn new(gate: Arc&LTRwLock<()>>, reader: R) -> Self {
</span><span style=color:#86b300>+        Self { gate, reader }
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+impl&LTR: AssetReader> AssetReader for LockGatedReader&LTR> {
</span><span style=color:#86b300>+    async fn read<'a>(&'a self, path: &'a Path) -> Result&LTimpl Reader + 'a, AssetReaderError> {
</span><span style=color:#86b300>+        let _guard = self.gate.read().await;
</span><span style=color:#86b300>+        self.reader.read(path).await
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    async fn read_meta<'a>(&'a self, path: &'a Path) -> Result&LTimpl Reader + 'a, AssetReaderError> {
</span><span style=color:#86b300>+        let _guard = self.gate.read().await;
</span><span style=color:#86b300>+        self.reader.read_meta(path).await
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    async fn read_directory<'a>(
</span><span style=color:#86b300>+        &'a self,
</span><span style=color:#86b300>+        path: &'a Path,
</span><span style=color:#86b300>+    ) -> Result&LTBox&LTPathStream>, AssetReaderError> {
</span><span style=color:#86b300>+        let _guard = self.gate.read().await;
</span><span style=color:#86b300>+        self.reader.read_directory(path).await
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    async fn is_directory<'a>(&'a self, path: &'a Path) -> Result&LTbool, AssetReaderError> {
</span><span style=color:#86b300>+        let _guard = self.gate.read().await;
</span><span style=color:#86b300>+        self.reader.is_directory(path).await
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span> fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor {
</span><span>     let mut app = App::new();
</span><span style=color:#86b300>+    let source_gate = Arc::new(RwLock::new(()));
</span><span> 
</span><span>     struct UnfinishedProcessingDirs {
</span><span>         source: Dir,
</span><span style=color:#c594c5>@@ -72,13 +117,20 @@ </span><span style=color:#399ee6>fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    fn create_source(app: &mut App, source_id: AssetSourceId<'static>) -> UnfinishedProcessingDirs {
</span><span style=color:#86b300>+    fn create_source(
</span><span style=color:#86b300>+        app: &mut App,
</span><span style=color:#86b300>+        source_id: AssetSourceId<'static>,
</span><span style=color:#86b300>+        source_gate: Arc&LTRwLock<()>>,
</span><span style=color:#86b300>+    ) -> UnfinishedProcessingDirs {
</span><span>         let source_dir = Dir::default();
</span><span>         let processed_dir = Dir::default();
</span><span> 
</span><span style=color:#f07171>-        let source_memory_reader = MemoryAssetReader {
</span><span style=color:#f07171>-            root: source_dir.clone(),
</span><span style=color:#f07171>-        };
</span><span style=color:#86b300>+        let source_memory_reader = LockGatedReader::new(
</span><span style=color:#86b300>+            source_gate,
</span><span style=color:#86b300>+            MemoryAssetReader {
</span><span style=color:#86b300>+                root: source_dir.clone(),
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        );
</span><span>         let processed_memory_reader = MemoryAssetReader {
</span><span>             root: processed_dir.clone(),
</span><span>         };
</span><span style=color:#c594c5>@@ -111,14 +163,18 @@ </span><span style=color:#399ee6>fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    let default_source_dirs = create_source(&mut app, AssetSourceId::Default);
</span><span style=color:#86b300>+    let default_source_dirs = create_source(&mut app, AssetSourceId::Default, source_gate.clone());
</span><span> 
</span><span>     let extra_sources_dirs = extra_sources
</span><span>         .iter()
</span><span>         .map(|source_name| {
</span><span>             (
</span><span>                 source_name.clone(),
</span><span style=color:#f07171>-                create_source(&mut app, AssetSourceId::Name(source_name.clone().into())),
</span><span style=color:#86b300>+                create_source(
</span><span style=color:#86b300>+                    &mut app,
</span><span style=color:#86b300>+                    AssetSourceId::Name(source_name.clone().into()),
</span><span style=color:#86b300>+                    source_gate.clone(),
</span><span style=color:#86b300>+                ),
</span><span>             )
</span><span>         })
</span><span>         .collect::&LTVec<_>>();
</span><span style=color:#c594c5>@@ -183,6 +239,7 @@ </span><span style=color:#399ee6>fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor
</span><span> 
</span><span>     AppWithProcessor {
</span><span>         app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs: default_source_dirs.finish(),
</span><span>         extra_sources_dirs: extra_sources_dirs
</span><span>             .into_iter()
</span><span style=color:#c594c5>@@ -191,21 +248,18 @@ </span><span style=color:#399ee6>fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-fn run_app_until_finished_processing(app: &mut App) {
</span><span style=color:#f07171>-    // If the original source changes through an AssetSourceEvent, we'll be racing (on
</span><span style=color:#f07171>-    // multithreaded) between this and processor thread switching the state to `Processing`. So do a
</span><span style=color:#f07171>-    // fixed number of iterations so the processor thread is likely to win.
</span><span style=color:#f07171>-    for _ in 0..5 {
</span><span style=color:#f07171>-        app.update();
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-    run_app_until(app, |world| {
</span><span style=color:#f07171>-        if bevy_tasks::block_on(world.resource::&LTAssetProcessor>().get_state())
</span><span style=color:#f07171>-            == ProcessorState::Finished
</span><span style=color:#f07171>-        {
</span><span style=color:#f07171>-            Some(())
</span><span style=color:#f07171>-        } else {
</span><span style=color:#f07171>-            None
</span><span style=color:#f07171>-        }
</span><span style=color:#86b300>+fn run_app_until_finished_processing(app: &mut App, guard: RwLockWriteGuard<'_, ()>) {
</span><span style=color:#86b300>+    let processor = app.world().resource::&LTAssetProcessor>().clone();
</span><span style=color:#86b300>+    // We can't just wait for the processor state to be finished since we could have already
</span><span style=color:#86b300>+    // finished before, but now that something has changed, we may not have restarted processing
</span><span style=color:#86b300>+    // yet. So wait for processing to start, then finish.
</span><span style=color:#86b300>+    run_app_until(app, |_| {
</span><span style=color:#86b300>+        let state = bevy_tasks::block_on(processor.get_state());
</span><span style=color:#86b300>+        (state == ProcessorState::Processing || state == ProcessorState::Initializing).then_some(())
</span><span style=color:#86b300>+    });
</span><span style=color:#86b300>+    drop(guard);
</span><span style=color:#86b300>+    run_app_until(app, |_| {
</span><span style=color:#86b300>+        (bevy_tasks::block_on(processor.get_state()) == ProcessorState::Finished).then_some(())
</span><span>     });
</span><span> }
</span><span> 
</span><span style=color:#c594c5>@@ -299,6 +353,7 @@ </span><span style=color:#399ee6>fn no_meta_or_default_processor_copies_asset() {
</span><span> 
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs:
</span><span>             ProcessingDirs {
</span><span>                 source: source_dir,
</span><span style=color:#c594c5>@@ -308,6 +363,8 @@ </span><span style=color:#399ee6>fn no_meta_or_default_processor_copies_asset() {
</span><span>         ..
</span><span>     } = create_app_with_asset_processor(&[]);
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     let path = Path::new("abc.cool.ron");
</span><span>     let source_asset = r#"(
</span><span>     text: "abc",
</span><span style=color:#c594c5>@@ -318,7 +375,7 @@ </span><span style=color:#399ee6>fn no_meta_or_default_processor_copies_asset() {
</span><span> 
</span><span>     source_dir.insert_asset_text(path, source_asset);
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     let processed_asset = processed_dir.get_asset(path).unwrap();
</span><span>     let processed_asset = str::from_utf8(processed_asset.value()).unwrap();
</span><span style=color:#c594c5>@@ -329,6 +386,7 @@ </span><span style=color:#399ee6>fn no_meta_or_default_processor_copies_asset() {
</span><span> fn asset_processor_transforms_asset_default_processor() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs:
</span><span>             ProcessingDirs {
</span><span>                 source: source_dir,
</span><span style=color:#c594c5>@@ -350,6 +408,8 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_default_processor() {
</span><span>         ))
</span><span>         .set_default_asset_processor::&LTCoolTextProcessor>("cool.ron");
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     let path = Path::new("abc.cool.ron");
</span><span>     source_dir.insert_asset_text(
</span><span>         path,
</span><span style=color:#c594c5>@@ -361,7 +421,7 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_default_processor() {
</span><span> )"#,
</span><span>     );
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     let processed_asset = processed_dir.get_asset(path).unwrap();
</span><span>     let processed_asset = str::from_utf8(processed_asset.value()).unwrap();
</span><span style=color:#c594c5>@@ -380,6 +440,7 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_default_processor() {
</span><span> fn asset_processor_transforms_asset_with_meta() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs:
</span><span>             ProcessingDirs {
</span><span>                 source: source_dir,
</span><span style=color:#c594c5>@@ -400,6 +461,8 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_with_meta() {
</span><span>             CoolTextSaver,
</span><span>         ));
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     let path = Path::new("abc.cool.ron");
</span><span>     source_dir.insert_asset_text(
</span><span>         path,
</span><span style=color:#c594c5>@@ -422,7 +485,7 @@ </span><span style=color:#399ee6>fn asset_processor_transforms_asset_with_meta() {
</span><span>     ),
</span><span> )"#);
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     let processed_asset = processed_dir.get_asset(path).unwrap();
</span><span>     let processed_asset = str::from_utf8(processed_asset.value()).unwrap();
</span><span style=color:#c594c5>@@ -574,6 +637,7 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_processed_assets() {
</span><span> 
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs:
</span><span>             ProcessingDirs {
</span><span>                 source: source_dir,
</span><span style=color:#c594c5>@@ -599,6 +663,8 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_processed_assets() {
</span><span>         .set_default_asset_processor::&LTGltfProcessor>("gltf")
</span><span>         .set_default_asset_processor::&LTBsnProcessor>("bsn");
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     let gltf_path = Path::new("abc.gltf");
</span><span>     source_dir.insert_asset_text(
</span><span>         gltf_path,
</span><span style=color:#c594c5>@@ -623,7 +689,7 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_processed_assets() {
</span><span> )"#,
</span><span>     );
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     let processed_bsn = processed_dir.get_asset(bsn_path).unwrap();
</span><span>     let processed_bsn = str::from_utf8(processed_bsn.value()).unwrap();
</span><span style=color:#c594c5>@@ -645,6 +711,7 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_processed_assets() {
</span><span> fn asset_processor_loading_can_read_source_assets() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs:
</span><span>             ProcessingDirs {
</span><span>                 source: source_dir,
</span><span style=color:#c594c5>@@ -754,6 +821,8 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_source_assets() {
</span><span>         .set_default_asset_processor::&LTGltfProcessor>("gltf")
</span><span>         .set_default_asset_processor::&LTGltfxProcessor>("gltfx");
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     let gltf_path_1 = Path::new("abc.gltf");
</span><span>     source_dir.insert_asset_text(
</span><span>         gltf_path_1,
</span><span style=color:#c594c5>@@ -783,7 +852,7 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_source_assets() {
</span><span> )"#,
</span><span>     );
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     // Sanity check that the two gltf files were actually processed.
</span><span>     let processed_gltf_1 = processed_dir.get_asset(gltf_path_1).unwrap();
</span><span style=color:#c594c5>@@ -838,6 +907,7 @@ </span><span style=color:#399ee6>fn asset_processor_loading_can_read_source_assets() {
</span><span> fn asset_processor_processes_all_sources() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs:
</span><span>             ProcessingDirs {
</span><span>                 source: default_source_dir,
</span><span style=color:#c594c5>@@ -871,6 +941,8 @@ </span><span style=color:#399ee6>fn asset_processor_processes_all_sources() {
</span><span>         ))
</span><span>         .set_default_asset_processor::&LTAddTextProcessor>("cool.ron");
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     // All the assets will have the same path, but they will still be separately processed since
</span><span>     // they are in different sources.
</span><span>     let path = Path::new("asset.cool.ron");
</span><span style=color:#c594c5>@@ -887,7 +959,7 @@ </span><span style=color:#399ee6>fn asset_processor_processes_all_sources() {
</span><span>     custom_1_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 1 asset"));
</span><span>     custom_2_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 2 asset"));
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     // Check that all the assets are processed.
</span><span>     assert_eq!(
</span><span style=color:#c594c5>@@ -903,13 +975,15 @@ </span><span style=color:#399ee6>fn asset_processor_processes_all_sources() {
</span><span>         serialize_as_cool_text("custom 2 asset processed")
</span><span>     );
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     // Update the default source asset and notify the watcher.
</span><span>     default_source_dir.insert_asset_text(path, &serialize_as_cool_text("default asset changed"));
</span><span>     default_source_events
</span><span>         .send_blocking(AssetSourceEvent::ModifiedAsset(path.to_path_buf()))
</span><span>         .unwrap();
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     // Check that all the assets are processed again.
</span><span>     assert_eq!(
</span><span style=color:#c594c5>@@ -925,6 +999,8 @@ </span><span style=color:#399ee6>fn asset_processor_processes_all_sources() {
</span><span>         serialize_as_cool_text("custom 2 asset processed")
</span><span>     );
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     // Update the custom source assets and notify the watchers.
</span><span>     custom_1_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 1 asset changed"));
</span><span>     custom_2_source_dir.insert_asset_text(path, &serialize_as_cool_text("custom 2 asset changed"));
</span><span style=color:#c594c5>@@ -935,7 +1011,7 @@ </span><span style=color:#399ee6>fn asset_processor_processes_all_sources() {
</span><span>         .send_blocking(AssetSourceEvent::ModifiedAsset(path.to_path_buf()))
</span><span>         .unwrap();
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     // Check that all the assets are processed again.
</span><span>     assert_eq!(
</span><span style=color:#c594c5>@@ -956,6 +1032,7 @@ </span><span style=color:#399ee6>fn asset_processor_processes_all_sources() {
</span><span> fn nested_loads_of_processed_asset_reprocesses_on_reload() {
</span><span>     let AppWithProcessor {
</span><span>         mut app,
</span><span style=color:#86b300>+        source_gate,
</span><span>         default_source_dirs:
</span><span>             ProcessingDirs {
</span><span>                 source: default_source_dir,
</span><span style=color:#c594c5>@@ -1061,6 +1138,8 @@ </span><span style=color:#399ee6>fn nested_loads_of_processed_asset_reprocesses_on_reload() {
</span><span>         ))
</span><span>         .set_default_asset_processor::&LTNesterProcessor>("nest");
</span><span> 
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     // This test also checks that processing of nested assets can occur across asset sources.
</span><span>     custom_source_dir.insert_asset_text(
</span><span>         Path::new("top.nest"),
</span><span style=color:#c594c5>@@ -1077,7 +1156,7 @@ </span><span style=color:#399ee6>fn nested_loads_of_processed_asset_reprocesses_on_reload() {
</span><span>         &serialize_as_leaf("unrelated".into()),
</span><span>     );
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     // The initial processing step should have processed all assets.
</span><span>     assert_eq!(
</span><span style=color:#c594c5>@@ -1106,6 +1185,7 @@ </span><span style=color:#399ee6>fn nested_loads_of_processed_asset_reprocesses_on_reload() {
</span><span> 
</span><span>     // Now we will only send a single source event, but that should still result in all related
</span><span>     // assets being reprocessed.
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span> 
</span><span>     custom_source_dir.insert_asset_text(
</span><span>         Path::new("bottom.nest"),
</span><span style=color:#c594c5>@@ -1115,7 +1195,7 @@ </span><span style=color:#399ee6>fn nested_loads_of_processed_asset_reprocesses_on_reload() {
</span><span>         .send_blocking(AssetSourceEvent::ModifiedAsset("bottom.nest".into()))
</span><span>         .unwrap();
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     assert_eq!(
</span><span>         read_asset_as_string(&custom_processed_dir, Path::new("bottom.nest")),
</span><span style=color:#c594c5>@@ -1138,11 +1218,13 @@ </span><span style=color:#399ee6>fn nested_loads_of_processed_asset_reprocesses_on_reload() {
</span><span> 
</span><span>     // Send a modify event to the middle asset without changing the asset bytes. This should do
</span><span>     // **nothing** since neither its dependencies nor its bytes have changed.
</span><span style=color:#86b300>+    let guard = source_gate.write_blocking();
</span><span style=color:#86b300>+
</span><span>     default_source_events
</span><span>         .send_blocking(AssetSourceEvent::ModifiedAsset("middle.nest".into()))
</span><span>         .unwrap();
</span><span> 
</span><span style=color:#f07171>-    run_app_until_finished_processing(&mut app);
</span><span style=color:#86b300>+    run_app_until_finished_processing(&mut app, guard);
</span><span> 
</span><span>     assert_eq!(
</span><span>         read_asset_as_string(&custom_processed_dir, Path::new("bottom.nest")),
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-11/pr_21708.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>