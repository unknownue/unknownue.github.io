diff --git a/crates/bevy_ecs/macros/src/component.rs b/crates/bevy_ecs/macros/src/component.rs
index c26ed196aa502..5ec637da1a4f7 100644
--- a/crates/bevy_ecs/macros/src/component.rs
+++ b/crates/bevy_ecs/macros/src/component.rs
@@ -407,6 +407,18 @@ enum HookAttributeKind {
 }
 
 impl HookAttributeKind {
+    fn parse(
+        input: syn::parse::ParseStream,
+        default_hook_path: impl FnOnce() -> ExprPath,
+    ) -> Result<Self> {
+        if input.peek(Token![=]) {
+            input.parse::<Token![=]>()?;
+            input.parse::<Expr>().and_then(Self::from_expr)
+        } else {
+            Ok(Self::Path(default_hook_path()))
+        }
+    }
+
     fn from_expr(value: Expr) -> Result<Self> {
         match value {
             Expr::Path(path) => Ok(HookAttributeKind::Path(path)),
@@ -439,12 +451,6 @@ impl HookAttributeKind {
     }
 }
 
-impl Parse for HookAttributeKind {
-    fn parse(input: syn::parse::ParseStream) -> Result<Self> {
-        input.parse::<Expr>().and_then(Self::from_expr)
-    }
-}
-
 #[derive(Debug)]
 pub(super) enum MapEntitiesAttributeKind {
     /// expressions like function or struct names
@@ -566,19 +572,29 @@ fn parse_component_attr(ast: &DeriveInput) -> Result<Attrs> {
                     };
                     Ok(())
                 } else if nested.path.is_ident(ON_ADD) {
-                    attrs.on_add = Some(nested.value()?.parse::<HookAttributeKind>()?);
+                    attrs.on_add = Some(HookAttributeKind::parse(nested.input, || {
+                        parse_quote! { Self::on_add }
+                    })?);
                     Ok(())
                 } else if nested.path.is_ident(ON_INSERT) {
-                    attrs.on_insert = Some(nested.value()?.parse::<HookAttributeKind>()?);
+                    attrs.on_insert = Some(HookAttributeKind::parse(nested.input, || {
+                        parse_quote! { Self::on_insert }
+                    })?);
                     Ok(())
                 } else if nested.path.is_ident(ON_REPLACE) {
-                    attrs.on_replace = Some(nested.value()?.parse::<HookAttributeKind>()?);
+                    attrs.on_replace = Some(HookAttributeKind::parse(nested.input, || {
+                        parse_quote! { Self::on_replace }
+                    })?);
                     Ok(())
                 } else if nested.path.is_ident(ON_REMOVE) {
-                    attrs.on_remove = Some(nested.value()?.parse::<HookAttributeKind>()?);
+                    attrs.on_remove = Some(HookAttributeKind::parse(nested.input, || {
+                        parse_quote! { Self::on_remove }
+                    })?);
                     Ok(())
                 } else if nested.path.is_ident(ON_DESPAWN) {
-                    attrs.on_despawn = Some(nested.value()?.parse::<HookAttributeKind>()?);
+                    attrs.on_despawn = Some(HookAttributeKind::parse(nested.input, || {
+                        parse_quote! { Self::on_despawn }
+                    })?);
                     Ok(())
                 } else if nested.path.is_ident(IMMUTABLE) {
                     attrs.immutable = true;
diff --git a/crates/bevy_ecs/macros/src/lib.rs b/crates/bevy_ecs/macros/src/lib.rs
index f968d36e50ea5..7c34b119968bc 100644
--- a/crates/bevy_ecs/macros/src/lib.rs
+++ b/crates/bevy_ecs/macros/src/lib.rs
@@ -646,6 +646,7 @@ pub fn derive_resource(input: TokenStream) -> TokenStream {
 /// `function` can be either a path, e.g. `some_function::<Self>`,
 /// or a function call that returns a function that can be turned into
 /// a `ComponentHook`, e.g. `get_closure("Hi!")`.
+/// `function` can be elided if the path is `Self::on_add`, `Self::on_insert` etc.
 ///
 /// ## Ignore this component when cloning an entity
 /// ```ignore
diff --git a/crates/bevy_ecs/src/component/mod.rs b/crates/bevy_ecs/src/component/mod.rs
index 0b939000169f6..395cb7db919e7 100644
--- a/crates/bevy_ecs/src/component/mod.rs
+++ b/crates/bevy_ecs/src/component/mod.rs
@@ -405,6 +405,29 @@ use core::{fmt::Debug, marker::PhantomData, ops::Deref};
 /// }
 ///
 /// ```
+///
+/// A hook's function path can be elided if it is `Self::on_add`, `Self::on_insert` etc.
+/// ```
+/// # use bevy_ecs::lifecycle::HookContext;
+/// # use bevy_ecs::prelude::*;
+/// # use bevy_ecs::world::DeferredWorld;
+/// #
+/// #[derive(Component, Debug)]
+/// #[component(on_add)]
+/// struct DoubleOnSpawn(usize);
+///
+/// impl DoubleOnSpawn {
+///     fn on_add(mut world: DeferredWorld, context: HookContext) {
+///         let mut entity = world.get_mut::<Self>(context.entity).unwrap();
+///         entity.0 *= 2;
+///     }
+/// }
+/// #
+/// # let mut world = World::new();
+/// # let entity = world.spawn(DoubleOnSpawn(2));
+/// # assert_eq!(entity.get::<DoubleOnSpawn>().unwrap().0, 4);
+/// ```
+///
 /// # Setting the clone behavior
 ///
 /// You can specify how the [`Component`] is cloned when deriving it.
