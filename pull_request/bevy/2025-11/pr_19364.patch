diff --git a/Cargo.toml b/Cargo.toml
index 0c023fb96b200..88ae83d1861ea 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -2400,7 +2400,6 @@ wasm = false
 name = "states"
 path = "examples/state/states.rs"
 doc-scrape-examples = true
-required-features = ["bevy_dev_tools"]
 
 [package.metadata.example.states]
 name = "States"
diff --git a/examples/state/states.rs b/examples/state/states.rs
index 699e38d7248e6..38dc80173e0b4 100644
--- a/examples/state/states.rs
+++ b/examples/state/states.rs
@@ -5,11 +5,11 @@
 //!
 //! In this case, we're transitioning from a `Menu` state to an `InGame` state.
 
-use bevy::{dev_tools::states::*, prelude::*};
+use bevy::prelude::*;
 
 fn main() {
-    App::new()
-        .add_plugins(DefaultPlugins)
+    let mut app = App::new();
+    app.add_plugins(DefaultPlugins)
         .init_state::<AppState>() // Alternatively we could use .insert_state(AppState::Menu)
         .add_systems(Startup, setup)
         // This system runs when we enter `AppState::Menu`, during the `StateTransition` schedule.
@@ -24,9 +24,14 @@ fn main() {
         .add_systems(
             Update,
             (movement, change_color).run_if(in_state(AppState::InGame)),
-        )
-        .add_systems(Update, log_transitions::<AppState>)
-        .run();
+        );
+
+    #[cfg(feature = "bevy_dev_tools")]
+    app.add_systems(Update, bevy::dev_tools::states::log_transitions::<AppState>);
+    #[cfg(not(feature = "bevy_dev_tools"))]
+    warn!("Enable feature bevy_dev_tools to log state transitions");
+
+    app.run();
 }
 
 #[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]
