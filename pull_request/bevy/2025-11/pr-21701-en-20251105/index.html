<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21701 Parallelize and simplify the asset processing loop.
        
    </title><meta content="#21701 Parallelize and simplify the asset processing loop." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-11/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-11-05</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-11/pr-21701-zh-cn-20251105>中文</a></div></div><div class=pr-content><h1 id=parallelize-and-simplify-the-asset-processing-loop>Parallelize and simplify the asset processing loop</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Parallelize and simplify the asset processing loop.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21701<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Assets, C-Performance, C-Code-Quality, S-Ready-For-Final-Review, D-Modest<li><strong>Created</strong>: 2025-10-31T00:45:27Z<li><strong>Merged</strong>: 2025-11-05T18:11:02Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>The previous asset processing loop was very difficult to understand (IMO). <ul><li>The initial processing of tasks would start a bunch of tasks. Then listening would listen for events and then await on processing tasks one at a time before continuing to listen to events. Finishing a task would also add paths to a <strong>separate</strong> <code>check_reprocess_queue</code> which would only be checked after all the current events have been handled.</ul><li>Also processing tasks did not occur in parallel - so we’d process assets one at a time.</ul><h2 id=solution>Solution</h2><p>Approximately throw everything out. The asset processor now does these things:<ol><li>Initialize the processor: same as before, recover from the transaction log, initialize the state of all processed assets (so we can lock them).<li>Queue all the initial processing tasks: iterate through all processed sources, finding all their assets, and queue a task for them (to recheck whether they need to be processed, and reprocess them if so). Note we don’t spawn any bevy_task::Tasks here.<li>Spawn the “executor” bevy_task::Task: This task spawns the queued tasks and updates the overall state of processing (i.e., processing vs finished).<li>Spawn the source change event listeners: spawns a bevy_task::Task for each asset source to listen on its event receiver and queued up any new tasks as source assets change.</ol><p>So this parallelizes event processing from asset sources, parallelizes processing each asset, and (IMO) makes the whole processing loop much simpler.<p>Also I think it’s funny that parallelizing could make things simpler lol.<h3 id=caveats>Caveats</h3><ul><li>I’ve removed the public methods for <code>process_assets</code> and <code>listen_for_source_change_events</code>. My guess is these were public so that users can call them outside the context of a running app? I’m not entirely sure. I think this needs to be rethought though if that’s the case. For one, a running app currently will not be gated on processing from another app, meaning things will probably get out-of-sync very easily. If need be, I think we can bring this back fairly straight forward. There also isn’t a migration guide since there’s nothing to migrate to here.<li>Parallelizing asset processing <strong>could</strong> be bad for very large tasks. Some GLTF files can get REALLY big, and managing memory there is very important (though we’re still bad at this). So parallelizing asset processing can result in many tasks running concurrently consuming more memory without a way to control it. However I think this is a more general problem and we should find other solutions than “don’t parallelize”.</ul><h2 id=testing>Testing</h2><ul><li>The asset processing tests still pass!<li>The asset_processing example seems to behave the same!</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>The asset processing system in Bevy was facing two major problems: complexity and performance. The original implementation had a convoluted processing loop that was difficult to understand and debug, while also processing assets sequentially, creating a performance bottleneck.<p>The complexity stemmed from several intertwined concerns. The system would start processing tasks, then listen for events while awaiting tasks one at a time. When tasks finished, they would add paths to a separate <code>check_reprocess_queue</code> that was only checked after all current events were handled. This created multiple coordination points and made the flow hard to follow.<p>The developer took a radical approach to solving both problems simultaneously: parallelize everything and simplify the architecture. The new design separates concerns cleanly into four distinct phases that run concurrently:<ol><li><strong>Initialization</strong> - Recover from transaction logs and initialize asset states<li><strong>Task Queueing</strong> - Scan all processed sources and queue processing tasks<li><strong>Task Execution</strong> - Spawn and manage the actual processing tasks<li><strong>Event Listening</strong> - Handle source change events and queue new tasks</ol><p>The key insight was that by using async channels for communication between components, the system could be both parallel and simpler. Each component focuses on one responsibility, and the channel-based communication creates clear boundaries between them.<p>The implementation uses <code>async_channel</code> to create an unbounded channel for task coordination. The <code>new_task_sender</code> is used by both the initial scanning and event listeners to queue tasks, while the <code>new_task_receiver</code> is consumed by the executor to spawn actual processing tasks. This design allows multiple producers (initial scanning and event listeners) to feed tasks to a single consumer (executor) that manages the parallel execution.<p>One notable change was the removal of the separate <code>check_reprocess_queue</code>. Instead, when assets need reprocessing, they’re simply sent through the same channel as new tasks. This eliminates the complex coordination logic that was previously needed to manage the reprocessing queue.<p>The parallelization does introduce a potential memory concern for very large assets like GLTF files, as noted in the caveats. However, the developer argued this is a general memory management problem that should be solved separately rather than preventing parallelization.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[AssetProcessor::start] --> B[Initialize Processor]
</span><span>    B --> C[Queue Initial Tasks]
</span><span>    C --> D[Spawn Executor Task]
</span><span>    C --> E[Spawn Event Listeners]
</span><span>    E --> F[Source 1 Listener]
</span><span>    E --> G[Source 2 Listener]
</span><span>    E --> H[...]
</span><span>    F --> I[Send Tasks]
</span><span>    G --> I
</span><span>    H --> I
</span><span>    D --> J[Task Executor]
</span><span>    I --> J
</span><span>    J --> K[Spawn Processing Tasks]
</span><span>    K --> L[Process Asset 1]
</span><span>    K --> M[Process Asset 2]
</span><span>    K --> N[...]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-asset-src-processor-mod-rs-221-140><code>crates/bevy_asset/src/processor/mod.rs</code> (+221/-140)</h3><p>This file contains the core logic changes that implement the new parallel processing architecture. The main changes include:<ol><li><strong>Complete rewrite of the <code>start</code> method</strong> to implement the new four-phase approach<li><strong>New task coordination system</strong> using <code>async_channel</code> for communication<li><strong>Parallel event processing</strong> with separate tasks for each asset source<li><strong>Simplified state management</strong> by eliminating complex reprocessing queues</ol><p>Key code changes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Complex sequential processing
</span><span style=color:#fa6e32>pub</span><span> async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>process_assets</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> start_time </span><span style=color:#ed9366>= </span><span>std</span><span style=color:#ed9366>::</span><span>time</span><span style=color:#ed9366>::</span><span>Instant</span><span style=color:#ed9366>::</span><span>now()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>debug!</span><span>(</span><span style=color:#86b300>"Processing Assets"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> tasks </span><span style=color:#ed9366>= </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>initialize</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for</span><span> source </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>sources</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_processed</span><span>() {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>process_assets_internal</span><span>(source</span><span style=color:#61676ccc>, </span><span>PathBuf</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>""</span><span>)</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> tasks)
</span><span>            </span><span style=color:#ed9366>.</span><span>await
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#f07171>join_all</span><span>(tasks)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>finish_processing_assets</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> end_time </span><span style=color:#ed9366>= </span><span>std</span><span style=color:#ed9366>::</span><span>time</span><span style=color:#ed9366>::</span><span>Instant</span><span style=color:#ed9366>::</span><span>now()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>debug!</span><span>(</span><span style=color:#86b300>"Processing finished in {:?}"</span><span style=color:#61676ccc>,</span><span> end_time </span><span style=color:#ed9366>-</span><span> start_time)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Parallel task-based processing
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>start</span><span>(</span><span style=color:#ff8f40>processor</span><span style=color:#61676ccc>: </span><span>Res<</span><span style=color:#fa6e32>Self</span><span>>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> processor </span><span style=color:#ed9366>=</span><span> processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>    IoTaskPool</span><span style=color:#ed9366>::</span><span>get()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async </span><span style=color:#fa6e32>move </span><span>{
</span><span>            </span><span style=color:#fa6e32>let</span><span> start_time </span><span style=color:#ed9366>= </span><span>std</span><span style=color:#ed9366>::</span><span>time</span><span style=color:#ed9366>::</span><span>Instant</span><span style=color:#ed9366>::</span><span>now()</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#f07171>debug!</span><span>(</span><span style=color:#86b300>"Processing Assets"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>            processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>initialize</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>            </span><span style=color:#fa6e32>let </span><span>(new_task_sender</span><span style=color:#61676ccc>,</span><span> new_task_receiver) </span><span style=color:#ed9366>= </span><span>async_channel</span><span style=color:#ed9366>::</span><span>unbounded()</span><span style=color:#61676ccc>;
</span><span>            processor
</span><span>                </span><span style=color:#ed9366>.</span><span style=color:#f07171>queue_initial_processing_tasks</span><span>(</span><span style=color:#ed9366>&</span><span>new_task_sender)
</span><span>                </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// Spawn executor task
</span><span>            {
</span><span>                </span><span style=color:#fa6e32>let</span><span> processor </span><span style=color:#ed9366>=</span><span> processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>                </span><span style=color:#fa6e32>let</span><span> new_task_sender </span><span style=color:#ed9366>=</span><span> new_task_sender</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>                IoTaskPool</span><span style=color:#ed9366>::</span><span>get()
</span><span>                    </span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async </span><span style=color:#fa6e32>move </span><span>{
</span><span>                        processor
</span><span>                            </span><span style=color:#ed9366>.</span><span style=color:#f07171>execute_processing_tasks</span><span>(new_task_sender</span><span style=color:#61676ccc>,</span><span> new_task_receiver)
</span><span>                            </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>                    })
</span><span>                    </span><span style=color:#ed9366>.</span><span style=color:#f07171>detach</span><span>()</span><span style=color:#61676ccc>;
</span><span>            }
</span><span>
</span><span>            processor</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span style=color:#f07171>wait_until_finished</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>
</span><span>            </span><span style=color:#fa6e32>let</span><span> end_time </span><span style=color:#ed9366>= </span><span>std</span><span style=color:#ed9366>::</span><span>time</span><span style=color:#ed9366>::</span><span>Instant</span><span style=color:#ed9366>::</span><span>now()</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#f07171>debug!</span><span>(</span><span style=color:#86b300>"Processing finished in {:?}"</span><span style=color:#61676ccc>,</span><span> end_time </span><span style=color:#ed9366>-</span><span> start_time)</span><span style=color:#61676ccc>;
</span><span>
</span><span>            </span><span style=color:#f07171>debug!</span><span>(</span><span style=color:#86b300>"Listening for changes to source assets"</span><span>)</span><span style=color:#61676ccc>;
</span><span>            processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn_source_change_event_listeners</span><span>(</span><span style=color:#ed9366>&</span><span>new_task_sender)</span><span style=color:#61676ccc>;
</span><span>        })
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>detach</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The event handling was also significantly simplified:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Complex event processing with manual polling
</span><span style=color:#fa6e32>while let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#fa6e32>mut</span><span> item) </span><span style=color:#ed9366>= </span><span>{
</span><span>    </span><span style=color:#fa6e32>if</span><span> next</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_none</span><span>() {
</span><span>        next </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(all_receiver</span><span style=color:#ed9366>.</span><span style=color:#f07171>next</span><span>())</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    next</span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()
</span><span>}</span><span style=color:#ed9366>.</span><span>await
</span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>set_state</span><span>(ProcessorState</span><span style=color:#ed9366>::</span><span>Processing)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>loop </span><span>{
</span><span>        </span><span style=color:#fa6e32>let </span><span>(source_id</span><span style=color:#61676ccc>,</span><span> event) </span><span style=color:#ed9366>=</span><span> item</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>handle_asset_source_event</span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span>sources</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(source_id)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>,</span><span> event)
</span><span>            </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> next_next </span><span style=color:#ed9366>=</span><span> all_receiver</span><span style=color:#ed9366>.</span><span style=color:#f07171>next</span><span>()</span><span style=color:#61676ccc>;
</span><span>        item </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match </span><span style=color:#f07171>poll_once</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> next_next)</span><span style=color:#ed9366>.</span><span>await {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>None </span><span style=color:#ed9366>=> </span><span>{
</span><span>                next </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(next_next)</span><span style=color:#61676ccc>;
</span><span>                </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>            }
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#55b4d4;font-style:italic>None</span><span>) </span><span style=color:#ed9366>=> </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>,
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#55b4d4;font-style:italic>Some</span><span>(item)) </span><span style=color:#ed9366>=></span><span> item</span><span style=color:#61676ccc>,
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>finish_processing_assets</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Simple parallel event listeners per source
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>spawn_source_change_event_listeners</span><span>(
</span><span>    </span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>,
</span><span>    </span><span style=color:#ff8f40>sender</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>async_channel</span><span style=color:#ed9366>::</span><span>Sender<(AssetSourceId<</span><span style=color:#fa6e32>'static</span><span>>, PathBuf)>,
</span><span>) {
</span><span>    </span><span style=color:#fa6e32>for</span><span> source </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data</span><span style=color:#ed9366>.</span><span>sources</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_processed</span><span>() {
</span><span>        </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(receiver) </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span style=color:#f07171>event_receiver</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>() </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>        }</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> source_id </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span style=color:#f07171>id</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> processor </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> sender </span><span style=color:#ed9366>=</span><span> sender</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()</span><span style=color:#61676ccc>;
</span><span>        IoTaskPool</span><span style=color:#ed9366>::</span><span>get()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>spawn</span><span>(async </span><span style=color:#fa6e32>move </span><span>{
</span><span>                </span><span style=color:#fa6e32>while let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(event) </span><span style=color:#ed9366>=</span><span> receiver</span><span style=color:#ed9366>.</span><span style=color:#f07171>recv</span><span>()</span><span style=color:#ed9366>.</span><span>await {
</span><span>                    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(source) </span><span style=color:#ed9366>=</span><span> processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_source</span><span>(source_id</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()) </span><span style=color:#fa6e32>else </span><span>{
</span><span>                        </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>                    }</span><span style=color:#61676ccc>;
</span><span>                    processor
</span><span>                        </span><span style=color:#ed9366>.</span><span style=color:#f07171>handle_asset_source_event</span><span>(source</span><span style=color:#61676ccc>,</span><span> event</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>sender)
</span><span>                        </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            })
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>detach</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-asset-cargo-toml-1-0><code>crates/bevy_asset/Cargo.toml</code> (+1/-0)</h3><p>Added the <code>async-await-macro</code> feature to <code>futures-util</code> to support the new async architecture:<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span style=color:#399ee6>futures-util </span><span>= { </span><span style=color:#399ee6>version </span><span>= </span><span style=color:#86b300>"0.3"</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>default-features </span><span>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>features </span><span>= [
</span><span>  </span><span style=color:#86b300>"async-await-macro"</span><span style=color:#61676ccc>,
</span><span>  </span><span style=color:#86b300>"alloc"</span><span style=color:#61676ccc>,
</span><span>] }
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/assets/ target=_blank>Bevy Asset System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/async-channel/ target=_blank>async-channel crate documentation</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/async-tasks/ target=_blank>Bevy Tasks and Parallelism</a><li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/ target=_blank>Rust Async/Await Patterns</a></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-11/pr_21701.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>