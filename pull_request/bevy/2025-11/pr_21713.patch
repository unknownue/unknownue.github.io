diff --git a/crates/bevy_asset/src/loader.rs b/crates/bevy_asset/src/loader.rs
index 90ee558f05dd6..a56aab4a05740 100644
--- a/crates/bevy_asset/src/loader.rs
+++ b/crates/bevy_asset/src/loader.rs
@@ -19,7 +19,7 @@ use core::any::{Any, TypeId};
 use downcast_rs::{impl_downcast, Downcast};
 use ron::error::SpannedError;
 use serde::{Deserialize, Serialize};
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use thiserror::Error;
 
 /// Loads an [`Asset`] from a given byte [`Reader`]. This can accept [`AssetLoader::Settings`], which configure how the [`Asset`]
@@ -465,13 +465,8 @@ impl<'a> LoadContext<'a> {
         }
     }
 
-    /// Gets the source path for this load context.
-    pub fn path(&self) -> &Path {
-        self.asset_path.path()
-    }
-
     /// Gets the source asset path for this load context.
-    pub fn asset_path(&self) -> &AssetPath<'static> {
+    pub fn path(&self) -> &AssetPath<'static> {
         &self.asset_path
     }
 
diff --git a/crates/bevy_asset/src/server/loaders.rs b/crates/bevy_asset/src/server/loaders.rs
index 9c13c861bd986..fe58c5ad36cd4 100644
--- a/crates/bevy_asset/src/server/loaders.rs
+++ b/crates/bevy_asset/src/server/loaders.rs
@@ -326,7 +326,7 @@ impl<T: AssetLoader> AssetLoader for InstrumentedAssetLoader<T> {
         let span = info_span!(
             "asset loading",
             loader = core::any::type_name::<T>(),
-            asset = load_context.asset_path().to_string(),
+            asset = load_context.path().to_string(),
         );
         self.0.load(reader, settings, load_context).instrument(span)
     }
diff --git a/crates/bevy_gltf/src/loader/gltf_ext/texture.rs b/crates/bevy_gltf/src/loader/gltf_ext/texture.rs
index f39646b8cfd18..906aed31e2fea 100644
--- a/crates/bevy_gltf/src/loader/gltf_ext/texture.rs
+++ b/crates/bevy_gltf/src/loader/gltf_ext/texture.rs
@@ -31,7 +31,7 @@ pub(crate) fn texture_handle(
                 load_context.get_label_handle(texture_label(texture).to_string())
             } else {
                 let image_path = load_context
-                    .asset_path()
+                    .path()
                     .resolve_embed(uri)
                     .expect("all URIs were already validated when we initially loaded textures");
                 load_context.load(image_path)
diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
index f840a2c23a4da..960783629e15b 100644
--- a/crates/bevy_gltf/src/loader/mod.rs
+++ b/crates/bevy_gltf/src/loader/mod.rs
@@ -247,7 +247,7 @@ impl GltfLoader {
         let gltf = gltf::Gltf::from_slice(bytes)?;
 
         let file_name = load_context
-            .asset_path()
+            .path()
             .path()
             .to_str()
             .ok_or(GltfError::Gltf(gltf::Error::Io(Error::new(
@@ -601,7 +601,7 @@ impl GltfLoader {
                     texture,
                     &buffer_data,
                     &linear_textures,
-                    load_context.asset_path(),
+                    load_context.path(),
                     loader.supported_compressed_formats,
                     default_sampler,
                     settings,
@@ -614,7 +614,7 @@ impl GltfLoader {
             IoTaskPool::get()
                 .scope(|scope| {
                     gltf.textures().for_each(|gltf_texture| {
-                        let asset_path = load_context.asset_path().clone();
+                        let asset_path = load_context.path().clone();
                         let linear_textures = &linear_textures;
                         let buffer_data = &buffer_data;
                         scope.spawn(async move {
@@ -1744,7 +1744,7 @@ async fn load_buffers(
                     Err(()) => {
                         // TODO: Remove this and add dep
                         let buffer_path = load_context
-                            .asset_path()
+                            .path()
                             .resolve_embed(uri)
                             .map_err(|err| GltfError::InvalidBufferUri(uri.to_owned(), err))?;
                         load_context.read_asset_bytes(buffer_path).await?
diff --git a/crates/bevy_image/src/image_loader.rs b/crates/bevy_image/src/image_loader.rs
index e5a945cf55e7b..7f9616def65f5 100644
--- a/crates/bevy_image/src/image_loader.rs
+++ b/crates/bevy_image/src/image_loader.rs
@@ -180,19 +180,25 @@ impl AssetLoader for ImageLoader {
         let image_type = match settings.format {
             ImageFormatSetting::FromExtension => {
                 // use the file extension for the image type
-                let ext = load_context.path().extension().unwrap().to_str().unwrap();
+                let ext = load_context
+                    .path()
+                    .path()
+                    .extension()
+                    .unwrap()
+                    .to_str()
+                    .unwrap();
                 ImageType::Extension(ext)
             }
             ImageFormatSetting::Format(format) => ImageType::Format(format),
             ImageFormatSetting::Guess => {
                 let format = image::guess_format(&bytes).map_err(|err| FileTextureError {
                     error: err.into(),
-                    path: format!("{}", load_context.path().display()),
+                    path: format!("{}", load_context.path().path().display()),
                 })?;
                 ImageType::Format(ImageFormat::from_image_crate_format(format).ok_or_else(
                     || FileTextureError {
                         error: TextureError::UnsupportedTextureFormat(format!("{format:?}")),
-                        path: format!("{}", load_context.path().display()),
+                        path: format!("{}", load_context.path().path().display()),
                     },
                 )?)
             }
@@ -208,7 +214,7 @@ impl AssetLoader for ImageLoader {
         )
         .map_err(|err| FileTextureError {
             error: err,
-            path: format!("{}", load_context.path().display()),
+            path: format!("{}", load_context.path().path().display()),
         })?;
 
         if let Some(format) = settings.texture_format {
diff --git a/crates/bevy_shader/src/shader.rs b/crates/bevy_shader/src/shader.rs
index 932de7b98ceff..577fb06ee2e95 100644
--- a/crates/bevy_shader/src/shader.rs
+++ b/crates/bevy_shader/src/shader.rs
@@ -367,8 +367,14 @@ impl AssetLoader for ShaderLoader {
         settings: &Self::Settings,
         load_context: &mut LoadContext<'_>,
     ) -> Result<Shader, Self::Error> {
-        let ext = load_context.path().extension().unwrap().to_str().unwrap();
-        let path = load_context.asset_path().to_string();
+        let ext = load_context
+            .path()
+            .path()
+            .extension()
+            .unwrap()
+            .to_str()
+            .unwrap();
+        let path = load_context.path().to_string();
         // On windows, the path will inconsistently use \ or /.
         // TODO: remove this once AssetPath forces cross-platform "slash" consistency. See #10511
         let path = path.replace(std::path::MAIN_SEPARATOR, "/");
@@ -381,7 +387,7 @@ impl AssetLoader for ShaderLoader {
             );
         }
         let mut shader = match ext {
-            "spv" => Shader::from_spirv(bytes, load_context.path().to_string_lossy()),
+            "spv" => Shader::from_spirv(bytes, load_context.path().path().to_string_lossy()),
             "wgsl" => Shader::from_wgsl_with_defs(
                 String::from_utf8(bytes)?,
                 path,
diff --git a/examples/asset/asset_decompression.rs b/examples/asset/asset_decompression.rs
index e514924ca9d0a..ce24bc16c1993 100644
--- a/examples/asset/asset_decompression.rs
+++ b/examples/asset/asset_decompression.rs
@@ -48,13 +48,16 @@ impl AssetLoader for GzAssetLoader {
     ) -> Result<Self::Asset, Self::Error> {
         let compressed_path = load_context.path();
         let file_name = compressed_path
+            .path()
             .file_name()
             .ok_or(GzAssetLoaderError::IndeterminateFilePath)?
             .to_string_lossy();
         let uncompressed_file_name = file_name
             .strip_suffix(".gz")
             .ok_or(GzAssetLoaderError::IndeterminateFilePath)?;
-        let contained_path = compressed_path.join(uncompressed_file_name);
+        let contained_path = compressed_path
+            .resolve_embed(uncompressed_file_name)
+            .map_err(|_| GzAssetLoaderError::IndeterminateFilePath)?;
 
         let mut bytes_compressed = Vec::new();
 
diff --git a/release-content/migration-guides/load_context_asset_path.md b/release-content/migration-guides/load_context_asset_path.md
new file mode 100644
index 0000000000000..8b06e8f5f610d
--- /dev/null
+++ b/release-content/migration-guides/load_context_asset_path.md
@@ -0,0 +1,14 @@
+---
+title: LoadContext::path now returns `AssetPath`.
+pull_requests: [21713]
+---
+
+`LoadContext::asset_path` has been removed, and `LoadContext::path` now returns `AssetPath`. So the
+migrations are:
+
+- `load_context.asset_path()` -> `load_context.path()`
+- `load_context.path()` -> `load_context.asset_path().path()`
+  - While this migration will keep your code running, seriously consider whether you need to use
+    the `Path` itself. The `Path` does not support custom asset sources, so care needs to be taken
+    when using it directly. Consider instead using the `AssetPath` instead, along with
+    `AssetPath::resolve_embed`, to properly support custom asset sources.
