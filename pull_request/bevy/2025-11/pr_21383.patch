diff --git a/assets/models/terrain/terrain.glb b/assets/models/terrain/terrain.glb
index b09e0f414832e..c040600dbeb4e 100644
Binary files a/assets/models/terrain/terrain.glb and b/assets/models/terrain/terrain.glb differ
diff --git a/crates/bevy_pbr/src/atmosphere/bruneton_functions.wgsl b/crates/bevy_pbr/src/atmosphere/bruneton_functions.wgsl
index b7e0fc4e7cc08..1e559ca92991b 100644
--- a/crates/bevy_pbr/src/atmosphere/bruneton_functions.wgsl
+++ b/crates/bevy_pbr/src/atmosphere/bruneton_functions.wgsl
@@ -64,19 +64,19 @@
 // Assuming r between ground and top atmosphere boundary, and mu= cos(zenith_angle)
 // Chosen to increase precision near the ground and to work around a discontinuity at the horizon
 // See Bruneton and Neyret 2008, "Precomputed Atmospheric Scattering" section 4
-fn transmittance_lut_r_mu_to_uv(r: f32, mu: f32) -> vec2<f32> {
+fn transmittance_lut_r_mu_to_uv(atm: Atmosphere, r: f32, mu: f32) -> vec2<f32> {
   // Distance along a horizontal ray from the ground to the top atmosphere boundary
-    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
+    let H = sqrt(atm.top_radius * atm.top_radius - atm.bottom_radius * atm.bottom_radius);
 
   // Distance from a point at height r to the horizon
   // ignore the case where r <= atmosphere.bottom_radius
-    let rho = sqrt(max(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius, 0.0));
+    let rho = sqrt(max(r * r - atm.bottom_radius * atm.bottom_radius, 0.0));
 
   // Distance from a point at height r to the top atmosphere boundary at zenith angle mu
-    let d = distance_to_top_atmosphere_boundary(r, mu);
+    let d = distance_to_top_atmosphere_boundary(atm, r, mu);
 
   // Minimum and maximum distance to the top atmosphere boundary from a point at height r
-    let d_min = atmosphere.top_radius - r; // length of the ray straight up to the top atmosphere boundary
+    let d_min = atm.top_radius - r; // length of the ray straight up to the top atmosphere boundary
     let d_max = rho + H; // length of the ray to the top atmosphere boundary and grazing the horizon
 
     let u = (d - d_min) / (d_max - d_min);
@@ -121,9 +121,9 @@ fn transmittance_lut_uv_to_r_mu(uv: vec2<f32>) -> vec2<f32> {
 /// Center of sphere, c = [0,0,0]
 /// Radius of sphere, r = atmosphere.top_radius
 /// This function solves the quadratic equation for line-sphere intersection simplified under these assumptions
-fn distance_to_top_atmosphere_boundary(r: f32, mu: f32) -> f32 {
-  // ignore the case where r > atmosphere.top_radius
-    let positive_discriminant = max(r * r * (mu * mu - 1.0) + atmosphere.top_radius * atmosphere.top_radius, 0.0);
+fn distance_to_top_atmosphere_boundary(atm: Atmosphere, r: f32, mu: f32) -> f32 {
+  // ignore the case where r > atm.top_radius
+    let positive_discriminant = max(r * r * (mu * mu - 1.0) + atm.top_radius * atm.top_radius, 0.0);
     return max(-r * mu + sqrt(positive_discriminant), 0.0);
 }
 
diff --git a/crates/bevy_pbr/src/atmosphere/functions.wgsl b/crates/bevy_pbr/src/atmosphere/functions.wgsl
index a778e11e27716..bd57a0ee83e0e 100644
--- a/crates/bevy_pbr/src/atmosphere/functions.wgsl
+++ b/crates/bevy_pbr/src/atmosphere/functions.wgsl
@@ -115,7 +115,7 @@ fn sky_view_lut_uv_to_zenith_azimuth(r: f32, uv: vec2<f32>) -> vec2<f32> {
 // LUT SAMPLING
 
 fn sample_transmittance_lut(r: f32, mu: f32) -> vec3<f32> {
-    let uv = transmittance_lut_r_mu_to_uv(r, mu);
+    let uv = transmittance_lut_r_mu_to_uv(atmosphere, r, mu);
     return textureSampleLevel(transmittance_lut, atmosphere_lut_sampler, uv, 0.0).rgb;
 }
 
@@ -256,10 +256,34 @@ fn sample_sun_radiance(ray_dir_ws: vec3<f32>) -> vec3<f32> {
     return sun_radiance;
 }
 
+fn calculate_visible_sun_ratio(atmosphere: Atmosphere, r: f32, mu: f32, sun_angular_size: f32) -> f32 {
+    let bottom_radius = atmosphere.bottom_radius;
+    // Calculate the angle between horizon and sun center
+    // Invert the horizon angle calculation to fix shading direction
+    let horizon_cos = -sqrt(1.0 - (bottom_radius * bottom_radius) / (r * r));
+    let horizon_angle = fast_acos_4(horizon_cos);
+    let sun_zenith_angle = fast_acos_4(mu);
+    
+    // If sun is completely above horizon
+    if sun_zenith_angle + sun_angular_size * 0.5 <= horizon_angle {
+        return 1.0;
+    }
+    
+    // If sun is completely below horizon
+    if sun_zenith_angle - sun_angular_size * 0.5 >= horizon_angle {
+        return 0.0;
+    }
+    
+    // Calculate partial visibility using circular segment area formula
+    let d = (horizon_angle - sun_zenith_angle) / (sun_angular_size * 0.5);
+    let visible_ratio = 0.5 + d * 0.5;
+    return clamp(visible_ratio, 0.0, 1.0);
+}
+
 // TRANSFORM UTILITIES
 
 fn max_atmosphere_distance(r: f32, mu: f32) -> f32 {
-    let t_top = distance_to_top_atmosphere_boundary(r, mu);
+    let t_top = distance_to_top_atmosphere_boundary(atmosphere, r, mu);
     let t_bottom = distance_to_bottom_atmosphere_boundary(r, mu);
     let hits = ray_intersects_ground(r, mu);
     return mix(t_top, t_bottom, f32(hits));
diff --git a/crates/bevy_pbr/src/atmosphere/mod.rs b/crates/bevy_pbr/src/atmosphere/mod.rs
index 39dfe0cd8c473..908f471f39d1d 100644
--- a/crates/bevy_pbr/src/atmosphere/mod.rs
+++ b/crates/bevy_pbr/src/atmosphere/mod.rs
@@ -77,7 +77,10 @@ use resources::{
 };
 use tracing::warn;
 
-use crate::medium::ScatteringMedium;
+use crate::{
+    medium::ScatteringMedium,
+    resources::{init_atmosphere_buffer, write_atmosphere_buffer},
+};
 
 use self::{
     node::{AtmosphereLutsNode, AtmosphereNode, RenderSkyNode},
@@ -154,7 +157,12 @@ impl Plugin for AtmospherePlugin {
             .init_resource::<SpecializedRenderPipelines<RenderSkyBindGroupLayouts>>()
             .add_systems(
                 RenderStartup,
-                (init_atmosphere_probe_layout, init_atmosphere_probe_pipeline).chain(),
+                (
+                    init_atmosphere_probe_layout,
+                    init_atmosphere_probe_pipeline,
+                    init_atmosphere_buffer,
+                )
+                    .chain(),
             )
             .add_systems(
                 Render,
@@ -171,6 +179,7 @@ impl Plugin for AtmospherePlugin {
                     prepare_atmosphere_probe_bind_groups.in_set(RenderSystems::PrepareBindGroups),
                     prepare_atmosphere_transforms.in_set(RenderSystems::PrepareResources),
                     prepare_atmosphere_bind_groups.in_set(RenderSystems::PrepareBindGroups),
+                    write_atmosphere_buffer.in_set(RenderSystems::PrepareResources),
                 ),
             )
             .add_render_graph_node::<ViewNodeRunner<AtmosphereLutsNode>>(
diff --git a/crates/bevy_pbr/src/atmosphere/resources.rs b/crates/bevy_pbr/src/atmosphere/resources.rs
index 134af345f1db8..1d2657d09837b 100644
--- a/crates/bevy_pbr/src/atmosphere/resources.rs
+++ b/crates/bevy_pbr/src/atmosphere/resources.rs
@@ -765,3 +765,45 @@ pub(super) fn prepare_atmosphere_bind_groups(
 
     Ok(())
 }
+
+#[derive(ShaderType)]
+#[repr(C)]
+pub(crate) struct AtmosphereData {
+    pub atmosphere: GpuAtmosphere,
+    pub settings: GpuAtmosphereSettings,
+}
+
+pub fn init_atmosphere_buffer(mut commands: Commands) {
+    commands.insert_resource(AtmosphereBuffer {
+        buffer: StorageBuffer::from(AtmosphereData {
+            atmosphere: GpuAtmosphere {
+                ground_albedo: Vec3::ZERO,
+                bottom_radius: 0.0,
+                top_radius: 0.0,
+            },
+            settings: GpuAtmosphereSettings::default(),
+        }),
+    });
+}
+
+#[derive(Resource)]
+pub struct AtmosphereBuffer {
+    pub(crate) buffer: StorageBuffer<AtmosphereData>,
+}
+
+pub(crate) fn write_atmosphere_buffer(
+    device: Res<RenderDevice>,
+    queue: Res<RenderQueue>,
+    atmosphere_entity: Query<(&GpuAtmosphere, &GpuAtmosphereSettings), With<Camera3d>>,
+    mut atmosphere_buffer: ResMut<AtmosphereBuffer>,
+) {
+    let Ok((atmosphere, settings)) = atmosphere_entity.single() else {
+        return;
+    };
+
+    atmosphere_buffer.buffer.set(AtmosphereData {
+        atmosphere: atmosphere.clone(),
+        settings: settings.clone(),
+    });
+    atmosphere_buffer.buffer.write_buffer(&device, &queue);
+}
diff --git a/crates/bevy_pbr/src/atmosphere/types.wgsl b/crates/bevy_pbr/src/atmosphere/types.wgsl
index a96efe961ecb3..d74a2ce46a478 100644
--- a/crates/bevy_pbr/src/atmosphere/types.wgsl
+++ b/crates/bevy_pbr/src/atmosphere/types.wgsl
@@ -29,3 +29,8 @@ struct AtmosphereSettings {
 struct AtmosphereTransforms {
     world_from_atmosphere: mat4x4<f32>,
 }
+
+struct AtmosphereData {
+    atmosphere: Atmosphere,
+    settings: AtmosphereSettings,
+}
\ No newline at end of file
diff --git a/crates/bevy_pbr/src/deferred/mod.rs b/crates/bevy_pbr/src/deferred/mod.rs
index bbce8dc909fa3..10cd2b9c10074 100644
--- a/crates/bevy_pbr/src/deferred/mod.rs
+++ b/crates/bevy_pbr/src/deferred/mod.rs
@@ -4,7 +4,10 @@ use crate::{
     ViewLightProbesUniformOffset, ViewScreenSpaceReflectionsUniformOffset,
     TONEMAPPING_LUT_SAMPLER_BINDING_INDEX, TONEMAPPING_LUT_TEXTURE_BINDING_INDEX,
 };
-use crate::{DistanceFog, MeshPipelineKey, ViewFogUniformOffset, ViewLightsUniformOffset};
+use crate::{
+    DistanceFog, ExtractedAtmosphere, MeshPipelineKey, ViewFogUniformOffset,
+    ViewLightsUniformOffset,
+};
 use bevy_app::prelude::*;
 use bevy_asset::{embedded_asset, load_embedded_asset, AssetServer, Handle};
 use bevy_core_pipeline::{
@@ -325,6 +328,9 @@ impl SpecializedRenderPipeline for DeferredLightingLayout {
         if key.contains(MeshPipelineKey::DISTANCE_FOG) {
             shader_defs.push("DISTANCE_FOG".into());
         }
+        if key.contains(MeshPipelineKey::ATMOSPHERE) {
+            shader_defs.push("ATMOSPHERE".into());
+        }
 
         // Always true, since we're in the deferred lighting pipeline
         shader_defs.push("DEFERRED_PREPASS".into());
@@ -452,6 +458,7 @@ pub fn prepare_deferred_lighting_pipelines(
         Has<RenderViewLightProbes<EnvironmentMapLight>>,
         Has<RenderViewLightProbes<IrradianceVolume>>,
         Has<SkipDeferredLighting>,
+        Has<ExtractedAtmosphere>,
     )>,
 ) {
     for (
@@ -465,6 +472,7 @@ pub fn prepare_deferred_lighting_pipelines(
         has_environment_maps,
         has_irradiance_volumes,
         skip_deferred_lighting,
+        has_atmosphere,
     ) in &views
     {
         // If there is no deferred prepass or we want to skip the deferred lighting pass,
@@ -489,6 +497,10 @@ pub fn prepare_deferred_lighting_pipelines(
             view_key |= MeshPipelineKey::MOTION_VECTOR_PREPASS;
         }
 
+        if has_atmosphere {
+            view_key |= MeshPipelineKey::ATMOSPHERE;
+        }
+
         // Always true, since we're in the deferred lighting pipeline
         view_key |= MeshPipelineKey::DEFERRED_PREPASS;
 
diff --git a/crates/bevy_pbr/src/render/mesh.rs b/crates/bevy_pbr/src/render/mesh.rs
index 000613efd1c31..e4049877e35d7 100644
--- a/crates/bevy_pbr/src/render/mesh.rs
+++ b/crates/bevy_pbr/src/render/mesh.rs
@@ -1,4 +1,7 @@
-use crate::material_bind_groups::{MaterialBindGroupIndex, MaterialBindGroupSlot};
+use crate::{
+    material_bind_groups::{MaterialBindGroupIndex, MaterialBindGroupSlot},
+    resources::write_atmosphere_buffer,
+};
 use bevy_asset::{embedded_asset, load_embedded_asset, AssetId};
 use bevy_camera::{
     primitives::Aabb,
@@ -194,7 +197,8 @@ impl Plugin for MeshRenderPlugin {
                         prepare_mesh_bind_groups.in_set(RenderSystems::PrepareBindGroups),
                         prepare_mesh_view_bind_groups
                             .in_set(RenderSystems::PrepareBindGroups)
-                            .after(prepare_oit_buffers),
+                            .after(prepare_oit_buffers)
+                            .after(write_atmosphere_buffer),
                         no_gpu_preprocessing::clear_batched_cpu_instance_buffers::<MeshPipeline>
                             .in_set(RenderSystems::Cleanup)
                             .after(RenderSystems::Render),
@@ -325,6 +329,7 @@ pub fn check_views_need_specialization(
             Has<RenderViewLightProbes<IrradianceVolume>>,
         ),
         Has<OrderIndependentTransparencySettings>,
+        Has<ExtractedAtmosphere>,
     )>,
     ticks: SystemChangeTick,
 ) {
@@ -342,6 +347,7 @@ pub fn check_views_need_specialization(
         distance_fog,
         (has_environment_maps, has_irradiance_volumes),
         has_oit,
+        has_atmosphere,
     ) in views.iter_mut()
     {
         let mut view_key = MeshPipelineKey::from_msaa_samples(msaa.samples())
@@ -379,6 +385,10 @@ pub fn check_views_need_specialization(
             view_key |= MeshPipelineKey::OIT_ENABLED;
         }
 
+        if has_atmosphere {
+            view_key |= MeshPipelineKey::ATMOSPHERE;
+        }
+
         if let Some(projection) = projection {
             view_key |= match projection {
                 Projection::Perspective(_) => MeshPipelineKey::VIEW_PROJECTION_PERSPECTIVE,
@@ -2094,7 +2104,8 @@ bitflags::bitflags! {
         const HAS_PREVIOUS_MORPH                = 1 << 19;
         const OIT_ENABLED                       = 1 << 20;
         const DISTANCE_FOG                      = 1 << 21;
-        const LAST_FLAG                         = Self::DISTANCE_FOG.bits();
+        const ATMOSPHERE                        = 1 << 22;
+        const LAST_FLAG                         = Self::ATMOSPHERE.bits();
 
         // Bitfields
         const MSAA_RESERVED_BITS                = Self::MSAA_MASK_BITS << Self::MSAA_SHIFT_BITS;
@@ -2564,6 +2575,10 @@ impl SpecializedMeshPipeline for MeshPipeline {
             shader_defs.push("DISTANCE_FOG".into());
         }
 
+        if key.contains(MeshPipelineKey::ATMOSPHERE) {
+            shader_defs.push("ATMOSPHERE".into());
+        }
+
         if self.binding_arrays_are_usable {
             shader_defs.push("MULTIPLE_LIGHT_PROBES_IN_ARRAY".into());
             shader_defs.push("MULTIPLE_LIGHTMAPS_IN_ARRAY".into());
diff --git a/crates/bevy_pbr/src/render/mesh_view_bindings.rs b/crates/bevy_pbr/src/render/mesh_view_bindings.rs
index 3550e4c8eb0d4..78e7f3e6d7dcb 100644
--- a/crates/bevy_pbr/src/render/mesh_view_bindings.rs
+++ b/crates/bevy_pbr/src/render/mesh_view_bindings.rs
@@ -43,7 +43,9 @@ use crate::{
     irradiance_volume::{
         self, RenderViewIrradianceVolumeBindGroupEntries, IRRADIANCE_VOLUMES_ARE_USABLE,
     },
-    prepass, EnvironmentMapUniformBuffer, FogMeta, GlobalClusterableObjectMeta,
+    prepass,
+    resources::{AtmosphereBuffer, AtmosphereData, AtmosphereSampler, AtmosphereTextures},
+    EnvironmentMapUniformBuffer, ExtractedAtmosphere, FogMeta, GlobalClusterableObjectMeta,
     GpuClusterableObjects, GpuFog, GpuLights, LightMeta, LightProbesBuffer, LightProbesUniform,
     MeshPipeline, MeshPipelineKey, RenderViewLightProbes, ScreenSpaceAmbientOcclusionResources,
     ScreenSpaceReflectionsBuffer, ScreenSpaceReflectionsUniform, ShadowSamplers,
@@ -81,6 +83,7 @@ bitflags::bitflags! {
         const MOTION_VECTOR_PREPASS       = 1 << 3;
         const DEFERRED_PREPASS            = 1 << 4;
         const OIT_ENABLED                 = 1 << 5;
+        const ATMOSPHERE                  = 1 << 6;
     }
 }
 
@@ -93,7 +96,7 @@ impl MeshPipelineViewLayoutKey {
         use MeshPipelineViewLayoutKey as Key;
 
         format!(
-            "mesh_view_layout{}{}{}{}{}{}",
+            "mesh_view_layout{}{}{}{}{}{}{}",
             if self.contains(Key::MULTISAMPLED) {
                 "_multisampled"
             } else {
@@ -124,6 +127,11 @@ impl MeshPipelineViewLayoutKey {
             } else {
                 Default::default()
             },
+            if self.contains(Key::ATMOSPHERE) {
+                "_atmosphere"
+            } else {
+                Default::default()
+            },
         )
     }
 }
@@ -150,6 +158,9 @@ impl From<MeshPipelineKey> for MeshPipelineViewLayoutKey {
         if value.contains(MeshPipelineKey::OIT_ENABLED) {
             result |= MeshPipelineViewLayoutKey::OIT_ENABLED;
         }
+        if value.contains(MeshPipelineKey::ATMOSPHERE) {
+            result |= MeshPipelineViewLayoutKey::ATMOSPHERE;
+        }
 
         result
     }
@@ -385,6 +396,20 @@ fn layout_entries(
         }
     }
 
+    // Atmosphere
+    if layout_key.contains(MeshPipelineViewLayoutKey::ATMOSPHERE) {
+        entries = entries.extend_with_indices((
+            // transmittance LUT
+            (
+                29,
+                texture_2d(TextureSampleType::Float { filterable: true }),
+            ),
+            (30, sampler(SamplerBindingType::Filtering)),
+            // atmosphere data buffer
+            (31, storage_buffer_read_only::<AtmosphereData>(false)),
+        ));
+    }
+
     let mut binding_array_entries = DynamicBindGroupLayoutEntries::new(ShaderStages::FRAGMENT);
     binding_array_entries = binding_array_entries.extend_with_indices((
         (0, environment_map_entries[0]),
@@ -559,6 +584,8 @@ pub fn prepare_mesh_view_bind_groups(
         Option<&RenderViewLightProbes<EnvironmentMapLight>>,
         Option<&RenderViewLightProbes<IrradianceVolume>>,
         Has<OrderIndependentTransparencySettings>,
+        Option<&AtmosphereTextures>,
+        Has<ExtractedAtmosphere>,
     )>,
     (images, mut fallback_images, fallback_image, fallback_image_zero): (
         Res<RenderAssets<GpuImage>>,
@@ -572,7 +599,12 @@ pub fn prepare_mesh_view_bind_groups(
     visibility_ranges: Res<RenderVisibilityRanges>,
     ssr_buffer: Res<ScreenSpaceReflectionsBuffer>,
     oit_buffers: Res<OitBuffers>,
-    (decals_buffer, render_decals): (Res<DecalsBuffer>, Res<RenderClusteredDecals>),
+    (decals_buffer, render_decals, atmosphere_buffer, atmosphere_sampler): (
+        Res<DecalsBuffer>,
+        Res<RenderClusteredDecals>,
+        Option<Res<AtmosphereBuffer>>,
+        Option<Res<AtmosphereSampler>>,
+    ),
 ) {
     if let (
         Some(view_binding),
@@ -607,6 +639,8 @@ pub fn prepare_mesh_view_bind_groups(
             render_view_environment_maps,
             render_view_irradiance_volumes,
             has_oit,
+            atmosphere_textures,
+            has_atmosphere,
         ) in &views
         {
             let fallback_ssao = fallback_images
@@ -622,6 +656,9 @@ pub fn prepare_mesh_view_bind_groups(
             if has_oit {
                 layout_key |= MeshPipelineViewLayoutKey::OIT_ENABLED;
             }
+            if has_atmosphere {
+                layout_key |= MeshPipelineViewLayoutKey::ATMOSPHERE;
+            }
 
             let layout = mesh_pipeline.get_view_layout(layout_key);
 
@@ -702,6 +739,19 @@ pub fn prepare_mesh_view_bind_groups(
                 ));
             }
 
+            if has_atmosphere
+                && let Some(atmosphere_textures) = atmosphere_textures
+                && let Some(atmosphere_buffer) = atmosphere_buffer.as_ref()
+                && let Some(atmosphere_sampler) = atmosphere_sampler.as_ref()
+                && let Some(atmosphere_buffer_binding) = atmosphere_buffer.buffer.binding()
+            {
+                entries = entries.extend_with_indices((
+                    (29, &atmosphere_textures.transmittance_lut.default_view),
+                    (30, &***atmosphere_sampler),
+                    (31, atmosphere_buffer_binding),
+                ));
+            }
+
             let mut entries_binding_array = DynamicBindGroupEntries::new();
 
             let environment_map_bind_group_entries = RenderViewEnvironmentMapBindGroupEntries::get(
diff --git a/crates/bevy_pbr/src/render/mesh_view_bindings.wgsl b/crates/bevy_pbr/src/render/mesh_view_bindings.wgsl
index 0f650e6e54dbb..5aef30ba05637 100644
--- a/crates/bevy_pbr/src/render/mesh_view_bindings.wgsl
+++ b/crates/bevy_pbr/src/render/mesh_view_bindings.wgsl
@@ -1,6 +1,7 @@
 #define_import_path bevy_pbr::mesh_view_bindings
 
 #import bevy_pbr::mesh_view_types as types
+#import bevy_pbr::atmosphere::types as atmosphere
 #import bevy_render::{
     view::View,
     globals::Globals,
@@ -94,6 +95,12 @@ const VISIBILITY_RANGE_UNIFORM_BUFFER_SIZE: u32 = 64u;
 @group(0) @binding(28) var<uniform> oit_settings: types::OrderIndependentTransparencySettings;
 #endif // OIT_ENABLED
 
+#ifdef ATMOSPHERE
+@group(0) @binding(29) var atmosphere_transmittance_texture: texture_2d<f32>;
+@group(0) @binding(30) var atmosphere_transmittance_sampler: sampler;
+@group(0) @binding(31) var<storage> atmosphere_data: atmosphere::AtmosphereData;
+#endif // ATMOSPHERE
+
 #ifdef MULTIPLE_LIGHT_PROBES_IN_ARRAY
 @group(1) @binding(0) var diffuse_environment_maps: binding_array<texture_cube<f32>, 8u>;
 @group(1) @binding(1) var specular_environment_maps: binding_array<texture_cube<f32>, 8u>;
diff --git a/crates/bevy_pbr/src/render/pbr_lighting.wgsl b/crates/bevy_pbr/src/render/pbr_lighting.wgsl
index 7496dea4fc050..c359109aad91e 100644
--- a/crates/bevy_pbr/src/render/pbr_lighting.wgsl
+++ b/crates/bevy_pbr/src/render/pbr_lighting.wgsl
@@ -3,6 +3,8 @@
 #import bevy_pbr::{
     mesh_view_types::POINT_LIGHT_FLAGS_SPOT_LIGHT_Y_NEGATIVE,
     mesh_view_bindings as view_bindings,
+    atmosphere::functions::calculate_visible_sun_ratio,
+    atmosphere::bruneton_functions::transmittance_lut_r_mu_to_uv,
 }
 #import bevy_render::maths::PI
 
@@ -852,5 +854,34 @@ fn directional_light(
     }
 #endif
 
-    return color * (*light).color.rgb * texture_sample;
+color *= (*light).color.rgb * texture_sample;
+
+#ifdef ATMOSPHERE
+    let P = (*input).P;
+    let atmosphere = view_bindings::atmosphere_data.atmosphere;
+    let O = vec3(0.0, atmosphere.bottom_radius, 0.0);
+    let P_scaled = P * vec3(view_bindings::atmosphere_data.settings.scene_units_to_m);
+    let P_as = P_scaled + O;
+    let r = length(P_as);
+    let local_up = normalize(P_as);
+    let mu_light = dot(L, local_up);
+
+    // Sample atmosphere
+    let transmittance = sample_transmittance_lut(r, mu_light);
+    let sun_visibility = calculate_visible_sun_ratio(atmosphere, r, mu_light, (*light).sun_disk_angular_size);
+    
+    // Apply atmospheric effects
+    color *= transmittance * sun_visibility;
+#endif
+
+    return color;
+}
+
+#ifdef ATMOSPHERE
+fn sample_transmittance_lut(r: f32, mu: f32) -> vec3<f32> {
+    let uv = transmittance_lut_r_mu_to_uv(view_bindings::atmosphere_data.atmosphere, r, mu);
+    return textureSampleLevel(
+        view_bindings::atmosphere_transmittance_texture, 
+        view_bindings::atmosphere_transmittance_sampler, uv, 0.0).rgb;
 }
+#endif  // ATMOSPHERE
diff --git a/crates/bevy_pbr/src/ssr/mod.rs b/crates/bevy_pbr/src/ssr/mod.rs
index b752b3daf9214..631acf6a5381d 100644
--- a/crates/bevy_pbr/src/ssr/mod.rs
+++ b/crates/bevy_pbr/src/ssr/mod.rs
@@ -47,9 +47,10 @@ use bevy_utils::{once, prelude::default};
 use tracing::info;
 
 use crate::{
-    binding_arrays_are_usable, graph::NodePbr, MeshPipelineViewLayoutKey, MeshPipelineViewLayouts,
-    MeshViewBindGroup, RenderViewLightProbes, ViewEnvironmentMapUniformOffset,
-    ViewFogUniformOffset, ViewLightProbesUniformOffset, ViewLightsUniformOffset,
+    binding_arrays_are_usable, graph::NodePbr, ExtractedAtmosphere, MeshPipelineViewLayoutKey,
+    MeshPipelineViewLayouts, MeshViewBindGroup, RenderViewLightProbes,
+    ViewEnvironmentMapUniformOffset, ViewFogUniformOffset, ViewLightProbesUniformOffset,
+    ViewLightsUniformOffset,
 };
 
 /// Enables screen-space reflections for a camera.
@@ -177,6 +178,7 @@ pub struct ScreenSpaceReflectionsPipelineKey {
     mesh_pipeline_view_key: MeshPipelineViewLayoutKey,
     is_hdr: bool,
     has_environment_maps: bool,
+    has_atmosphere: bool,
 }
 
 impl Plugin for ScreenSpaceReflectionsPlugin {
@@ -420,11 +422,13 @@ pub fn prepare_ssr_pipelines(
             Has<RenderViewLightProbes<EnvironmentMapLight>>,
             Has<NormalPrepass>,
             Has<MotionVectorPrepass>,
+            Has<ExtractedAtmosphere>,
         ),
         (
             With<ScreenSpaceReflectionsUniform>,
             With<DepthPrepass>,
             With<DeferredPrepass>,
+            With<ExtractedAtmosphere>,
         ),
     >,
 ) {
@@ -434,6 +438,7 @@ pub fn prepare_ssr_pipelines(
         has_environment_maps,
         has_normal_prepass,
         has_motion_vector_prepass,
+        has_atmosphere,
     ) in &views
     {
         // SSR is only supported in the deferred pipeline, which has no MSAA
@@ -449,6 +454,7 @@ pub fn prepare_ssr_pipelines(
             MeshPipelineViewLayoutKey::MOTION_VECTOR_PREPASS,
             has_motion_vector_prepass,
         );
+        mesh_pipeline_view_key.set(MeshPipelineViewLayoutKey::ATMOSPHERE, has_atmosphere);
 
         // Build the pipeline.
         let pipeline_id = pipelines.specialize(
@@ -458,6 +464,7 @@ pub fn prepare_ssr_pipelines(
                 mesh_pipeline_view_key,
                 is_hdr: extracted_view.hdr,
                 has_environment_maps,
+                has_atmosphere,
             },
         );
 
@@ -541,6 +548,10 @@ impl SpecializedRenderPipeline for ScreenSpaceReflectionsPipeline {
             shader_defs.push("MULTIPLE_LIGHT_PROBES_IN_ARRAY".into());
         }
 
+        if key.has_atmosphere {
+            shader_defs.push("ATMOSPHERE".into());
+        }
+
         RenderPipelineDescriptor {
             label: Some("SSR pipeline".into()),
             layout,
diff --git a/crates/bevy_pbr/src/volumetric_fog/render.rs b/crates/bevy_pbr/src/volumetric_fog/render.rs
index f33210cba2f02..e0ddc3ccefe74 100644
--- a/crates/bevy_pbr/src/volumetric_fog/render.rs
+++ b/crates/bevy_pbr/src/volumetric_fog/render.rs
@@ -50,7 +50,7 @@ use bevy_utils::prelude::default;
 use bitflags::bitflags;
 
 use crate::{
-    MeshPipelineViewLayoutKey, MeshPipelineViewLayouts, MeshViewBindGroup,
+    ExtractedAtmosphere, MeshPipelineViewLayoutKey, MeshPipelineViewLayouts, MeshViewBindGroup,
     ViewEnvironmentMapUniformOffset, ViewFogUniformOffset, ViewLightProbesUniformOffset,
     ViewLightsUniformOffset, ViewScreenSpaceReflectionsUniformOffset,
 };
@@ -549,6 +549,13 @@ impl SpecializedRenderPipeline for VolumetricFogPipeline {
             shader_defs.push("MULTISAMPLED".into());
         }
 
+        if key
+            .mesh_pipeline_view_key
+            .contains(MeshPipelineViewLayoutKey::ATMOSPHERE)
+        {
+            shader_defs.push("ATMOSPHERE".into());
+        }
+
         if key
             .flags
             .contains(VolumetricFogPipelineKeyFlags::DENSITY_TEXTURE)
@@ -626,6 +633,7 @@ pub fn prepare_volumetric_fog_pipelines(
             Has<DepthPrepass>,
             Has<MotionVectorPrepass>,
             Has<DeferredPrepass>,
+            Has<ExtractedAtmosphere>,
         ),
         With<VolumetricFog>,
     >,
@@ -644,6 +652,7 @@ pub fn prepare_volumetric_fog_pipelines(
         depth_prepass,
         motion_vector_prepass,
         deferred_prepass,
+        atmosphere,
     ) in view_targets.iter()
     {
         // Create a mesh pipeline view layout key corresponding to the view.
@@ -658,6 +667,7 @@ pub fn prepare_volumetric_fog_pipelines(
             MeshPipelineViewLayoutKey::DEFERRED_PREPASS,
             deferred_prepass,
         );
+        mesh_pipeline_view_key.set(MeshPipelineViewLayoutKey::ATMOSPHERE, atmosphere);
 
         let mut textureless_flags = VolumetricFogPipelineKeyFlags::empty();
         textureless_flags.set(VolumetricFogPipelineKeyFlags::HDR, view.hdr);
diff --git a/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl b/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl
index 27be451fa82f8..12294cd088b1a 100644
--- a/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl
+++ b/crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl
@@ -14,8 +14,15 @@
 // [2]: http://www.alexandre-pestana.com/volumetric-lights/
 
 #import bevy_core_pipeline::fullscreen_vertex_shader::FullscreenVertexOutput
+#import bevy_pbr::atmosphere::{
+    functions::calculate_visible_sun_ratio,
+    bruneton_functions::transmittance_lut_r_mu_to_uv,
+}
 #import bevy_pbr::mesh_functions::{get_world_from_local, mesh_position_local_to_clip}
-#import bevy_pbr::mesh_view_bindings::{globals, lights, view, clusterable_objects}
+#import bevy_pbr::mesh_view_bindings::{
+    globals, lights, view, clusterable_objects, 
+    atmosphere_data, atmosphere_transmittance_texture, atmosphere_transmittance_sampler
+}
 #import bevy_pbr::mesh_view_types::{
     DIRECTIONAL_LIGHT_FLAGS_VOLUMETRIC_BIT,
     POINT_LIGHT_FLAGS_SHADOWS_ENABLED_BIT,
@@ -220,12 +227,14 @@ fn fragment(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
             break;
         }
 
+        let L = (*light).direction_to_light.xyz;
+
         // Offset the depth value by the bias.
-        let depth_offset = (*light).shadow_depth_bias * (*light).direction_to_light.xyz;
+        let depth_offset = (*light).shadow_depth_bias * L;
 
         // Compute phase, which determines the fraction of light that's
         // scattered toward the camera instead of away from it.
-        let neg_LdotV = dot(normalize((*light).direction_to_light.xyz), Rd_world);
+        let neg_LdotV = dot(normalize(L), Rd_world);
         let phase = henyey_greenstein(neg_LdotV);
 
         // Reset `background_alpha` for a new raymarch.
@@ -291,9 +300,24 @@ fn fragment(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
 
             if (local_light_attenuation != 0.0) {
                 let light_attenuation = exp(-density * bounding_radius * (absorption + scattering));
-                let light_factors_per_step = fog_color * light_tint * light_attenuation *
+                var light_factors_per_step = fog_color * light_tint * light_attenuation *
                     scattering * density * step_size_world * light_intensity * exposure;
 
+#ifdef ATMOSPHERE
+                // attenuate by atmospheric scattering
+                let P = P_world + depth_offset;
+                let P_scaled = P * vec3(atmosphere_data.settings.scene_units_to_m);
+                let O = vec3(0.0, atmosphere_data.atmosphere.bottom_radius, 0.0);
+                let P_as = P_scaled + O;
+                let r = length(P_as);
+                let local_up = normalize(P_as);
+                let mu_light = dot(L, local_up);
+                
+                let transmittance = sample_transmittance_lut(r, mu_light);
+                let sun_visibility = calculate_visible_sun_ratio(atmosphere_data.atmosphere, r, mu_light, (*light).sun_disk_angular_size);
+                light_factors_per_step *= transmittance * sun_visibility;
+#endif
+
                 // Modulate the factor we calculated above by the phase, fog color,
                 // light color, light tint.
                 let light_color_per_step = (*light).color.rgb * phase * light_factors_per_step;
@@ -483,4 +507,13 @@ fn fetch_spot_shadow_without_normal(light_id: u32, frag_position: vec4<f32>) ->
         i32(light_id) + lights.spot_light_shadowmap_offset,
         SPOT_SHADOW_TEXEL_SIZE
     );
-}
\ No newline at end of file
+}
+
+#ifdef ATMOSPHERE
+fn sample_transmittance_lut(r: f32, mu: f32) -> vec3<f32> {
+    let uv = transmittance_lut_r_mu_to_uv(atmosphere_data.atmosphere, r, mu);
+    return textureSampleLevel(
+        atmosphere_transmittance_texture, 
+        atmosphere_transmittance_sampler, uv, 0.0).rgb;
+}
+#endif  // ATMOSPHERE
\ No newline at end of file
diff --git a/examples/3d/atmosphere.rs b/examples/3d/atmosphere.rs
index ece73e5bdfaa2..bd27bf888d509 100644
--- a/examples/3d/atmosphere.rs
+++ b/examples/3d/atmosphere.rs
@@ -1,43 +1,116 @@
 //! This example showcases pbr atmospheric scattering
-
+#[cfg(feature = "free_camera")]
+use bevy::camera_controller::free_camera::{FreeCamera, FreeCameraPlugin};
 use std::f32::consts::PI;
 
 use bevy::{
+    anti_alias::fxaa::Fxaa,
     camera::Exposure,
+    color::palettes::css::BLACK,
     core_pipeline::tonemapping::Tonemapping,
-    light::{light_consts::lux, AtmosphereEnvironmentMapLight, CascadeShadowConfigBuilder},
-    pbr::{AtmosphereSettings, EarthlikeAtmosphere},
+    image::{
+        ImageAddressMode, ImageFilterMode, ImageLoaderSettings, ImageSampler,
+        ImageSamplerDescriptor,
+    },
+    input::keyboard::KeyCode,
+    light::{
+        light_consts::lux, AtmosphereEnvironmentMapLight, CascadeShadowConfigBuilder, FogVolume,
+        VolumetricFog, VolumetricLight,
+    },
+    pbr::{
+        AtmosphereMode, AtmosphereSettings, DefaultOpaqueRendererMethod, EarthlikeAtmosphere,
+        ExtendedMaterial, MaterialExtension, ScreenSpaceReflections,
+    },
     post_process::bloom::Bloom,
     prelude::*,
+    render::render_resource::{AsBindGroup, ShaderType},
+    shader::ShaderRef,
 };
 
+#[derive(Resource, Default)]
+struct GameState {
+    paused: bool,
+}
+
 fn main() {
     App::new()
-        .add_plugins(DefaultPlugins)
-        .add_systems(Startup, (setup_camera_fog, setup_terrain_scene))
-        .add_systems(Update, dynamic_scene)
+        .insert_resource(DefaultOpaqueRendererMethod::deferred())
+        .insert_resource(ClearColor(Color::BLACK))
+        .insert_resource(GameState::default())
+        .insert_resource(GlobalAmbientLight::NONE)
+        .add_plugins((
+            DefaultPlugins,
+            #[cfg(feature = "free_camera")]
+            FreeCameraPlugin,
+        ))
+        .add_plugins(MaterialPlugin::<ExtendedMaterial<StandardMaterial, Water>>::default())
+        .add_systems(
+            Startup,
+            (setup_camera_fog, setup_terrain_scene, print_controls),
+        )
+        .add_systems(Update, (dynamic_scene, atmosphere_controls))
         .run();
 }
 
+fn print_controls() {
+    println!("Atmosphere Example Controls:");
+    println!("    1          - Switch to lookup texture rendering method");
+    println!("    2          - Switch to raymarched rendering method");
+    println!("    Enter      - Pause/Resume sun motion");
+    println!("    Up/Down    - Increase/Decrease exposure");
+}
+
+fn atmosphere_controls(
+    keyboard_input: Res<ButtonInput<KeyCode>>,
+    mut atmosphere_settings: Query<&mut AtmosphereSettings>,
+    mut game_state: ResMut<GameState>,
+    mut camera_exposure: Query<&mut Exposure, With<Camera3d>>,
+    time: Res<Time>,
+) {
+    if keyboard_input.just_pressed(KeyCode::Digit1) {
+        for mut settings in &mut atmosphere_settings {
+            settings.rendering_method = AtmosphereMode::LookupTexture;
+            println!("Switched to lookup texture rendering method");
+        }
+    }
+
+    if keyboard_input.just_pressed(KeyCode::Digit2) {
+        for mut settings in &mut atmosphere_settings {
+            settings.rendering_method = AtmosphereMode::Raymarched;
+            println!("Switched to raymarched rendering method");
+        }
+    }
+
+    if keyboard_input.just_pressed(KeyCode::Enter) {
+        game_state.paused = !game_state.paused;
+    }
+
+    if keyboard_input.pressed(KeyCode::ArrowUp) {
+        for mut exposure in &mut camera_exposure {
+            exposure.ev100 -= time.delta_secs() * 2.0;
+        }
+    }
+
+    if keyboard_input.pressed(KeyCode::ArrowDown) {
+        for mut exposure in &mut camera_exposure {
+            exposure.ev100 += time.delta_secs() * 2.0;
+        }
+    }
+}
+
 fn setup_camera_fog(mut commands: Commands, earth_atmosphere: Res<EarthlikeAtmosphere>) {
     commands.spawn((
         Camera3d::default(),
-        Transform::from_xyz(-1.2, 0.15, 0.0).looking_at(Vec3::Y * 0.1, Vec3::Y),
+        Transform::from_xyz(-2.4, 0.04, 0.0).looking_at(Vec3::Y * 0.1, Vec3::Y),
         // get the default `Atmosphere` component
         earth_atmosphere.get(),
-        // The scene is in units of 10km, so we need to scale up the
-        // aerial view lut distance and set the scene scale accordingly.
-        // Most usages of this feature will not need to adjust this.
-        AtmosphereSettings {
-            aerial_view_lut_max_distance: 3.2e5,
-            scene_units_to_m: 1e+4,
-            ..Default::default()
-        },
+        // Can be adjusted to change the scene scale and rendering quality
+        AtmosphereSettings::default(),
         // The directional light illuminance used in this scene
         // (the one recommended for use with this feature) is
         // quite bright, so raising the exposure compensation helps
         // bring the scene to a nicer brightness range.
-        Exposure::SUNLIGHT,
+        Exposure { ev100: 13.0 },
         // Tonemapper chosen just because it looked good with the scene, any
         // tonemapper would be fine :)
         Tonemapping::AcesFitted,
@@ -45,22 +118,65 @@ fn setup_camera_fog(mut commands: Commands, earth_atmosphere: Res<EarthlikeAtmos
         Bloom::NATURAL,
         // Enables the atmosphere to drive reflections and ambient lighting (IBL) for this view
         AtmosphereEnvironmentMapLight::default(),
+        #[cfg(feature = "free_camera")]
+        FreeCamera::default(),
+        VolumetricFog {
+            ambient_intensity: 0.0,
+            ..default()
+        },
+        Msaa::Off,
+        Fxaa::default(),
+        ScreenSpaceReflections::default(),
     ));
 }
 
 #[derive(Component)]
 struct Terrain;
 
+/// A custom [`ExtendedMaterial`] that creates animated water ripples.
+#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
+struct Water {
+    /// The normal map image.
+    ///
+    /// Note that, like all normal maps, this must not be loaded as sRGB.
+    #[texture(100)]
+    #[sampler(101)]
+    normals: Handle<Image>,
+
+    // Parameters to the water shader.
+    #[uniform(102)]
+    settings: WaterSettings,
+}
+
+/// Parameters to the water shader.
+#[derive(ShaderType, Debug, Clone)]
+struct WaterSettings {
+    /// How much to displace each octave each frame, in the u and v directions.
+    /// Two octaves are packed into each `vec4`.
+    octave_vectors: [Vec4; 2],
+    /// How wide the waves are in each octave.
+    octave_scales: Vec4,
+    /// How high the waves are in each octave.
+    octave_strengths: Vec4,
+}
+
+impl MaterialExtension for Water {
+    fn deferred_fragment_shader() -> ShaderRef {
+        "shaders/water_material.wgsl".into()
+    }
+}
+
 fn setup_terrain_scene(
     mut commands: Commands,
     mut meshes: ResMut<Assets<Mesh>>,
     mut materials: ResMut<Assets<StandardMaterial>>,
+    mut water_materials: ResMut<Assets<ExtendedMaterial<StandardMaterial, Water>>>,
     asset_server: Res<AssetServer>,
 ) {
     // Configure a properly scaled cascade shadow map for this scene (defaults are too large, mesh units are in km)
     let cascade_shadow_config = CascadeShadowConfigBuilder {
         first_cascade_far_bound: 0.3,
-        maximum_distance: 3.0,
+        maximum_distance: 15.0,
         ..default()
     }
     .build();
@@ -77,10 +193,17 @@ fn setup_terrain_scene(
             illuminance: lux::RAW_SUNLIGHT,
             ..default()
         },
-        Transform::from_xyz(1.0, -0.4, 0.0).looking_at(Vec3::ZERO, Vec3::Y),
+        Transform::from_xyz(1.0, 0.4, 0.0).looking_at(Vec3::ZERO, Vec3::Y),
+        VolumetricLight,
         cascade_shadow_config,
     ));
 
+    // spawn the fog volume
+    commands.spawn((
+        FogVolume::default(),
+        Transform::from_scale(Vec3::new(10.0, 1.0, 10.0)).with_translation(Vec3::Y * 0.5),
+    ));
+
     let sphere_mesh = meshes.add(Mesh::from(Sphere { radius: 1.0 }));
 
     // light probe spheres
@@ -92,7 +215,7 @@ fn setup_terrain_scene(
             perceptual_roughness: 0.0,
             ..default()
         })),
-        Transform::from_xyz(-0.3, 0.1, -0.1).with_scale(Vec3::splat(0.05)),
+        Transform::from_xyz(-1.0, 0.1, -0.1).with_scale(Vec3::splat(0.05)),
     ));
 
     commands.spawn((
@@ -103,7 +226,7 @@ fn setup_terrain_scene(
             perceptual_roughness: 1.0,
             ..default()
         })),
-        Transform::from_xyz(-0.3, 0.1, 0.1).with_scale(Vec3::splat(0.05)),
+        Transform::from_xyz(-1.0, 0.1, 0.1).with_scale(Vec3::splat(0.05)),
     ));
 
     // Terrain
@@ -116,9 +239,68 @@ fn setup_terrain_scene(
             .with_scale(Vec3::splat(0.5))
             .with_rotation(Quat::from_rotation_y(PI / 2.0)),
     ));
+
+    spawn_water(
+        &mut commands,
+        &asset_server,
+        &mut meshes,
+        &mut water_materials,
+    );
+}
+
+// Spawns the water plane.
+fn spawn_water(
+    commands: &mut Commands,
+    asset_server: &AssetServer,
+    meshes: &mut Assets<Mesh>,
+    water_materials: &mut Assets<ExtendedMaterial<StandardMaterial, Water>>,
+) {
+    commands.spawn((
+        Mesh3d(meshes.add(Plane3d::new(Vec3::Y, Vec2::splat(1.0)))),
+        MeshMaterial3d(water_materials.add(ExtendedMaterial {
+            base: StandardMaterial {
+                base_color: BLACK.into(),
+                perceptual_roughness: 0.0,
+                ..default()
+            },
+            extension: Water {
+                normals: asset_server.load_with_settings::<Image, ImageLoaderSettings>(
+                    "textures/water_normals.png",
+                    |settings| {
+                        settings.is_srgb = false;
+                        settings.sampler = ImageSampler::Descriptor(ImageSamplerDescriptor {
+                            address_mode_u: ImageAddressMode::Repeat,
+                            address_mode_v: ImageAddressMode::Repeat,
+                            mag_filter: ImageFilterMode::Linear,
+                            min_filter: ImageFilterMode::Linear,
+                            ..default()
+                        });
+                    },
+                ),
+                // These water settings are just random values to create some
+                // variety.
+                settings: WaterSettings {
+                    octave_vectors: [
+                        vec4(0.080, 0.059, 0.073, -0.062),
+                        vec4(0.153, 0.138, -0.149, -0.195),
+                    ],
+                    octave_scales: vec4(1.0, 2.1, 7.9, 14.9) * 500.0,
+                    octave_strengths: vec4(0.16, 0.18, 0.093, 0.044) * 0.2,
+                },
+            },
+        })),
+        Transform::from_scale(Vec3::splat(100.0)),
+    ));
 }
 
-fn dynamic_scene(mut suns: Query<&mut Transform, With<DirectionalLight>>, time: Res<Time>) {
-    suns.iter_mut()
-        .for_each(|mut tf| tf.rotate_x(-time.delta_secs() * PI / 10.0));
+fn dynamic_scene(
+    mut suns: Query<&mut Transform, With<DirectionalLight>>,
+    time: Res<Time>,
+    sun_motion_state: Res<GameState>,
+) {
+    // Only rotate the sun if motion is not paused
+    if !sun_motion_state.paused {
+        suns.iter_mut()
+            .for_each(|mut tf| tf.rotate_x(-time.delta_secs() * PI / 10.0));
+    }
 }
diff --git a/release-content/release-notes/atmosphere_occlusion.md b/release-content/release-notes/atmosphere_occlusion.md
new file mode 100644
index 0000000000000..a4ad31b5333ec
--- /dev/null
+++ b/release-content/release-notes/atmosphere_occlusion.md
@@ -0,0 +1,11 @@
+---
+title: "Atmosphere Occlusion and PBR Shading"
+authors: ["@mate-h"]
+pull_requests: [21383]
+---
+
+The procedural atmosphere now affects how light reaches objects in your scene! Sunlight automatically picks up the right colors as it travels through the atmosphere, appearing orange or red when the sun is closer to the horizon.
+
+This works seamlessly with volumetric fog and all rendering modes, so your scenes will have more cohesive and realistic lighting right out of the box.
+
+Check out the updated `atmosphere` example to see it in action!
