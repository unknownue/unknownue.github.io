<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21943 Reduce the flakiness of asset processing tests.
        
    </title><meta content="#21943 Reduce the flakiness of asset processing tests." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-11/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-11-26</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-11/pr-21943-zh-cn-20251126>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Reduce the flakiness of asset processing tests<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Reduce the flakiness of asset processing tests.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21943<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-Assets, S-Ready-For-Final-Review, C-Testing<li><strong>Created</strong>: 2025-11-26T03:01:45Z<li><strong>Merged</strong>: 2025-11-26T04:28:15Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>The processor tests can be flaky. It seems to happen only with hot-reloading.</ul><h2 id=solution>Solution</h2><ul><li>Make sure all the receiver channels for assets are empty before considering whether the processing is in the Processing state.</ul><p>I’m not 100% sure this doesn’t have a race condition now, but it’s definitely much less likely. It technically might be possible for the event listening threads to receive the event, but then take too long to actually make changes to the processor state, but that should generally be a narrow window.<h2 id=testing>Testing</h2><p>I ran this many times on my local machine and haven’t seen a flake since.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a specific but important issue in Bevy’s asset processing system: flaky tests that occur intermittently, particularly when hot-reloading is involved. The problem manifested as test failures that weren’t consistent, making them difficult to debug and fix reliably.<p>The core issue was a race condition in the test verification logic. The test framework was checking whether the asset processor had reached a “Processing” or “Initializing” state, but it wasn’t accounting for pending events in the communication channels between different parts of the asset system. This meant that the test could incorrectly assume processing had completed when there were still events queued for processing.<p>The solution implemented here adds a crucial synchronization step. Before checking the processor state, the test now verifies that all event receiver channels are empty. This ensures that any pending asset events have been fully processed before the test makes assertions about the system state. The implementation iterates through all asset sources and checks their event receivers:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>for</span><span> source </span><span style=color:#ed9366>in</span><span> processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>sources</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(recv) </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span style=color:#f07171>event_receiver</span><span>() </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>recv</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>() {
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>This approach is pragmatic rather than perfect. As the author notes, there’s still a theoretical race condition where event listening threads might have received events but not yet processed them. However, this window is significantly narrower than the original issue, making the tests much more reliable in practice.<p>The engineering trade-off here is clear: the solution improves test reliability substantially with minimal complexity. Rather than implementing a more complex synchronization mechanism, the author chose a straightforward check that addresses the most common failure scenario. This aligns with good testing practices where tests should be reliable enough to catch real issues without being overly complex.<p>The testing approach was empirical - the author ran the modified tests repeatedly on their local machine and observed that the flakiness disappeared. This practical validation is often the most effective way to verify fixes for intermittent test failures.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Test Framework] --> B[Check Event Receivers]
</span><span>    B --> C{All Receivers Empty?}
</span><span>    C -->|No| D[Wait and Retry]
</span><span>    C -->|Yes| E[Check Processor State]
</span><span>    E --> F{Processing/Initializing?}
</span><span>    F -->|No| D
</span><span>    F -->|Yes| G[Test Proceeds]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><p><strong>File:</strong> <code>crates/bevy_asset/src/processor/tests.rs</code><p><strong>Changes:</strong> Added synchronization logic to ensure all asset event receivers are empty before checking processor state.<p><strong>Code Addition:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before we even consider whether the processor is started, make sure that none of the
</span><span style=color:#abb0b6;font-style:italic>// receivers have anything left in them. This prevents us accidentally, considering the
</span><span style=color:#abb0b6;font-style:italic>// processor as processing before all the events have been processed.
</span><span style=color:#fa6e32>for</span><span> source </span><span style=color:#ed9366>in</span><span> processor</span><span style=color:#ed9366>.</span><span style=color:#f07171>sources</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(recv) </span><span style=color:#ed9366>=</span><span> source</span><span style=color:#ed9366>.</span><span style=color:#f07171>event_receiver</span><span>() </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span>recv</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>() {
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>This change was inserted into the <code>run_app_until_finished_processing</code> function, which is responsible for waiting until asset processing reaches a stable state before proceeding with test assertions. The new code ensures that any pending asset events in the communication channels are fully processed before the test continues.<h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/books/assets/ target=_blank>Bevy Asset System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/std/sync/mpsc/ target=_blank>Rust Channel Programming</a><li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/09_example/00_intro.html target=_blank>Testing Asynchronous Systems</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/nomicon/races.html target=_blank>Race Condition Detection and Prevention</a></ul><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_asset/src/processor/tests.rs b/crates/bevy_asset/src/processor/tests.rs
</span><span>index 68941836e7d7c..b31abb47bba02 100644
</span><span style=color:#c594c5>--- a/crates/bevy_asset/src/processor/tests.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_asset/src/processor/tests.rs
</span><span style=color:#c594c5>@@ -267,6 +267,17 @@ </span><span style=color:#399ee6>fn run_app_until_finished_processing(app: &mut App, guard: RwLockWriteGuard<'_,
</span><span>     // finished before, but now that something has changed, we may not have restarted processing
</span><span>     // yet. So wait for processing to start, then finish.
</span><span>     run_app_until(app, |_| {
</span><span style=color:#86b300>+        // Before we even consider whether the processor is started, make sure that none of the
</span><span style=color:#86b300>+        // receivers have anything left in them. This prevents us accidentally, considering the
</span><span style=color:#86b300>+        // processor as processing before all the events have been processed.
</span><span style=color:#86b300>+        for source in processor.sources().iter() {
</span><span style=color:#86b300>+            let Some(recv) = source.event_receiver() else {
</span><span style=color:#86b300>+                continue;
</span><span style=color:#86b300>+            };
</span><span style=color:#86b300>+            if !recv.is_empty() {
</span><span style=color:#86b300>+                return None;
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+        }
</span><span>         let state = bevy_tasks::block_on(processor.get_state());
</span><span>         (state == ProcessorState::Processing || state == ProcessorState::Initializing).then_some(())
</span><span>     });
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-11/pr_21943.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>