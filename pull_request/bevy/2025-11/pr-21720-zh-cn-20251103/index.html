<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21720 Move wgsl color space utils to separate plugin
        
    </title><meta content="#21720 Move wgsl color space utils to separate plugin" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-11/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-11-03</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-11/pr-21720-en-20251103>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=move-wgsl-color-space-utils-to-separate-plugin>Move wgsl color space utils to separate plugin</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Move wgsl color space utils to separate plugin<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/21720<li><strong>作者</strong>: rossleonardy<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: A-Rendering, C-Code-Quality, C-Usability, S-Ready-For-Final-Review<li><strong>创建时间</strong>: 2025-11-02T14:03:57Z<li><strong>合并时间</strong>: 2025-11-03T19:22:50Z<li><strong>合并者</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h1 id=mu-biao>目标</h1><ul><li>为着色器提供颜色转换函数 #20523</ul><h2 id=jie-jue-fang-an>解决方案</h2><ul><li><p>将这些WGSL函数移动到一个单独的插件中，以便可以重复使用</p><li><p>用户可以导入插件本身，也可以导入UiRenderPlugin，后者也会添加此插件。</p><li><p>不确定如何更清楚地表明GradientPlugin现在需要先添加ColorSpacePlugin，对于不导入整个UiRenderPlugin的用户 https://github.com/bevyengine/bevy/issues/69</p><li><p>因为着色器库需要在一个插件中添加，我将这个留在bevy_ui_render中。如果非UI消费者想要使用这个功能而不依赖bevy_ui_render，可能需要移动它。bevy_color是这个功能的逻辑位置，但这会在那里引入对bevy_ecs和bevy_shader的依赖</p></ul><h2 id=ce-shi>测试</h2><ul><li>我在testbed示例中重新测试了渐变着色器</ul><h2 id=zhan-shi>展示</h2><img alt="Screenshot 2025-11-02 at 8 53 52 AM" height=860 src=https://github.com/user-attachments/assets/9d3c90cc-96ab-4a76-b4ff-09b2aa1b9343 width=1392><h2 id=zhe-ge-pull-requestde-gu-shi>这个Pull Request的故事</h2><p>这个PR的核心问题是代码复用和模块化。在Bevy的UI渲染系统中，渐变着色器包含了大量的颜色空间转换函数，这些函数在其他上下文中也可能有用，但被锁定在渐变特定的模块中。<h3 id=wen-ti-shi-bie>问题识别</h3><p>在之前的实现中，<code>gradient.wgsl</code>文件包含了307行代码，其中大部分是通用的颜色空间转换函数，如：<ul><li>sRGB与线性RGB的相互转换<li>HSL、HSV、Oklab、Oklch颜色空间的转换<li>不同颜色空间中的颜色混合函数</ul><p>这些函数虽然用于渐变渲染，但它们本质上是通用的颜色操作工具。将它们与渐变特定的逻辑耦合在一起违反了单一职责原则，也阻碍了在其他着色器中重用这些功能。<h3 id=jie-jue-fang-an-she-ji>解决方案设计</h3><p>开发者采用了经典的模块化方法：提取通用功能到独立的模块中。具体来说：<ol><li><strong>创建新的颜色空间插件</strong>：新增<code>ColorSpacePlugin</code>来管理颜色空间相关的WGSL函数<li><strong>分离关注点</strong>：将颜色转换逻辑从渐变逻辑中分离出来<li><strong>保持向后兼容</strong>：通过让<code>UiRenderPlugin</code>自动包含新的颜色空间插件来确保现有代码继续工作</ol><h3 id=shi-xian-xi-jie>实现细节</h3><p>实现过程主要涉及文件重组和依赖管理：<p>在<code>color_space.wgsl</code>中，开发者创建了一个完整的颜色空间工具库，包含：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>#define_import_path bevy_ui_render::color_space
</span><span>
</span><span>fn srgb_to_linear_rgb(color: vec3&LTf32>) -> vec3&LTf32> {
</span><span>    return vec3(
</span><span>        gamma(color.x),
</span><span>        gamma(color.y),
</span><span>        gamma(color.z)
</span><span>    );
</span><span>}
</span><span>
</span><span>fn mix_oklch(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span>    // 色度接近零时的智能色调插值逻辑
</span><span>    // ...
</span><span>}
</span></code></pre><p>同时，在<code>gradient.wgsl</code>中，原来的颜色转换函数被移除，改为导入新的颜色空间模块：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>#import bevy_ui_render::color_space::{
</span><span>    convert_to_linear_rgba,
</span><span>    mix_oklch,
</span><span>    mix_oklch_long,
</span><span>    // ... 其他函数
</span><span>}
</span></code></pre><p>这种重构显著简化了渐变着色器，从原来的307行减少到60行，同时提高了代码的可维护性。<h3 id=ji-shu-dong-cha>技术洞察</h3><p>这个重构展示了几个重要的软件工程原则：<p><strong>依赖管理考虑</strong>：开发者明确考虑了依赖关系的问题。新的<code>ColorSpacePlugin</code>需要在使用它的<code>GradientPlugin</code>之前被添加。虽然这引入了一个新的依赖约束，但通过让<code>UiRenderPlugin</code>包含两者来最小化对现有用户的影响。<p><strong>代码组织策略</strong>：将通用着色器函数组织到独立的库中，遵循了Bevy的着色器模块化模式。这允许其他系统在需要颜色操作时重用这些函数，而不必依赖整个UI渲染系统。<p><strong>性能考量</strong>：通过将函数提取到单独的WGSL模块中，编译器可以更好地优化这些函数的使用，特别是在多个着色器都使用相同函数的情况下。<h3 id=ying-xiang-yu-gai-jin>影响与改进</h3><p>这个变更带来了几个重要的改进：<ol><li><strong>代码复用性</strong>：其他需要颜色转换的着色器现在可以轻松导入这些函数<li><strong>可维护性</strong>：颜色空间逻辑现在集中在一个地方，更容易测试和维护<li><strong>关注点分离</strong>：渐变着色器现在专注于渐变特定的计算，而颜色转换由专门的模块处理</ol><p>一个值得注意的权衡是引入了新的插件依赖关系，但考虑到代码复用带来的好处，这是一个合理的折衷。<h2 id=shi-jue-biao-shi>视觉表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[UiRenderPlugin] --> B[ColorSpacePlugin]
</span><span>    A --> C[GradientPlugin]
</span><span>    C --> D[依赖颜色空间函数]
</span><span>    B --> E[color_space.wgsl]
</span><span>    E --> F[颜色转换函数]
</span><span>    E --> G[颜色混合函数]
</span><span>    E --> H[颜色空间转换]
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><h3 id=crates-bevy-ui-render-src-color-space-wgsl-xin-zeng><code>crates/bevy_ui_render/src/color_space.wgsl</code> (新增)</h3><p>新增了264行的颜色空间工具库，包含完整的颜色转换和混合功能。<p>关键代码片段：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>#define_import_path bevy_ui_render::color_space
</span><span>
</span><span>// sRGB转换函数
</span><span>fn srgb_to_linear_rgb(color: vec3&LTf32>) -> vec3&LTf32> {
</span><span>    return vec3(
</span><span>        gamma(color.x),
</span><span>        gamma(color.y),
</span><span>        gamma(color.z)
</span><span>    );
</span><span>}
</span><span>
</span><span>// 智能颜色混合函数
</span><span>fn mix_oklch(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span>    // 当端点色度接近零时，不插值色调
</span><span>    // 这允许从黑色或白色平滑过渡到目标颜色
</span><span>    var h = a.z;
</span><span>    var g = b.z;
</span><span>    if a.y < HUE_GUARD {
</span><span>        h = g;
</span><span>    } else if b.y < HUE_GUARD {
</span><span>        g = h;
</span><span>    }
</span><span>    // ... 色调插值逻辑
</span><span>}
</span></code></pre><h3 id=crates-bevy-ui-render-src-gradient-wgsl-zhong-gou><code>crates/bevy_ui_render/src/gradient.wgsl</code> (重构)</h3><p>从307行减少到60行，移除了所有颜色转换函数，改为导入颜色空间模块。<p>重构前后的对比：<pre class=language-wgsl data-lang=wgsl style=color:#61676c;background-color:#fafafa><code class=language-wgsl data-lang=wgsl><span>// 重构前：包含内联的颜色转换函数
</span><span>const PI: f32 = 3.14159265358979323846;
</span><span>const TAU: f32 = 2. * PI;
</span><span>
</span><span>// 内联的gamma校正函数等...
</span><span>fn gamma(value: f32) -> f32 {
</span><span>    // 实现细节...
</span><span>}
</span><span>
</span><span>// 重构后：导入颜色空间模块
</span><span>#import bevy_ui_render::color_space::{
</span><span>    convert_to_linear_rgba,
</span><span>    mix_oklch,
</span><span>    mix_oklch_long,
</span><span>    // ... 其他函数
</span><span>}
</span><span>#import bevy_render::maths::PI
</span></code></pre><h3 id=crates-bevy-ui-render-src-color-space-rs-xin-zeng><code>crates/bevy_ui_render/src/color_space.rs</code> (新增)</h3><p>新增了颜色空间插件，负责加载WGSL颜色空间库。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>bevy_app</span><span style=color:#ed9366>::</span><span>{App</span><span style=color:#61676ccc>,</span><span> Plugin}</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>use </span><span>bevy_shader</span><span style=color:#ed9366>::</span><span>load_shader_library</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>/// 用于WGSL颜色空间工具函数的插件
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>ColorSpacePlugin</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl </span><span>Plugin </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>ColorSpacePlugin </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>build</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>        </span><span style=color:#f07171>load_shader_library!</span><span>(app</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"color_space.wgsl"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-ui-render-src-lib-rs-xiu-gai><code>crates/bevy_ui_render/src/lib.rs</code> (修改)</h3><p>在UI渲染插件中注册新的颜色空间插件。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 新增模块声明
</span><span style=color:#fa6e32>mod </span><span style=color:#399ee6>color_space</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 在插件构建中注册
</span><span style=color:#fa6e32>impl </span><span>Plugin </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>UiRenderPlugin </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>build</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>app</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> App) {
</span><span>        app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>(UiTextureSlicerPlugin)</span><span style=color:#61676ccc>;
</span><span>        app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>(ColorSpacePlugin)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// 新增
</span><span>        app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>(GradientPlugin)</span><span style=color:#61676ccc>;
</span><span>        app</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_plugins</span><span>(BoxShadowPlugin)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><h2 id=jin-yi-bu-yue-du>进一步阅读</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/book/getting-started/shaders/ target=_blank>Bevy着色器系统文档</a><li><a rel="noopener nofollow noreferrer" href=https://www.w3.org/TR/WGSL/ target=_blank>WGSL颜色空间规范</a><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/SRGB target=_blank>sRGB颜色空间标准</a><li><a rel="noopener nofollow noreferrer" href=https://bottosson.github.io/posts/oklab/ target=_blank>Oklab感知均匀颜色空间</a></ul><hr><h1 id=wan-zheng-dai-ma-chai-yi>完整代码差异</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_ui_render/src/color_space.rs b/crates/bevy_ui_render/src/color_space.rs
</span><span>new file mode 100644
</span><span>index 0000000000000..765ed6e660a2a
</span><span style=color:#c594c5>--- /dev/null
</span><span style=color:#c594c5>+++ b/crates/bevy_ui_render/src/color_space.rs
</span><span style=color:#c594c5>@@ -0,0 +1,11 @@
</span><span style=color:#86b300>+use bevy_app::{App, Plugin};
</span><span style=color:#86b300>+use bevy_shader::load_shader_library;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+/// A plugin for WGSL color space utility functions
</span><span style=color:#86b300>+pub struct ColorSpacePlugin;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+impl Plugin for ColorSpacePlugin {
</span><span style=color:#86b300>+    fn build(&self, app: &mut App) {
</span><span style=color:#86b300>+        load_shader_library!(app, "color_space.wgsl");
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span>diff --git a/crates/bevy_ui_render/src/color_space.wgsl b/crates/bevy_ui_render/src/color_space.wgsl
</span><span>new file mode 100644
</span><span>index 0000000000000..80401e10b506c
</span><span style=color:#c594c5>--- /dev/null
</span><span style=color:#c594c5>+++ b/crates/bevy_ui_render/src/color_space.wgsl
</span><span style=color:#c594c5>@@ -0,0 +1,264 @@
</span><span style=color:#86b300>+#define_import_path bevy_ui_render::color_space
</span><span style=color:#86b300>+#import bevy_render::maths::PI
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+const TAU: f32 = 2. * PI;
</span><span style=color:#86b300>+const HUE_GUARD: f32 = 0.0001;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+// https://en.wikipedia.org/wiki/SRGB
</span><span style=color:#86b300>+fn gamma(value: f32) -> f32 {
</span><span style=color:#86b300>+    if value <= 0.0 {
</span><span style=color:#86b300>+        return value;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    if value <= 0.04045 {
</span><span style=color:#86b300>+        return value / 12.92; // linear falloff in dark values
</span><span style=color:#86b300>+    } else {
</span><span style=color:#86b300>+        return pow((value + 0.055) / 1.055, 2.4); // gamma curve in other area
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+// https://en.wikipedia.org/wiki/SRGB
</span><span style=color:#86b300>+fn inverse_gamma(value: f32) -> f32 {
</span><span style=color:#86b300>+    if value <= 0.0 {
</span><span style=color:#86b300>+        return value;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    if value <= 0.0031308 {
</span><span style=color:#86b300>+        return value * 12.92; // linear falloff in dark values
</span><span style=color:#86b300>+    } else {
</span><span style=color:#86b300>+        return 1.055 * pow(value, 1.0 / 2.4) - 0.055; // gamma curve in other area
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn srgb_to_linear_rgb(color: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        gamma(color.x),
</span><span style=color:#86b300>+        gamma(color.y),
</span><span style=color:#86b300>+        gamma(color.z)
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn linear_rgb_to_srgb(color: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        inverse_gamma(color.x),
</span><span style=color:#86b300>+        inverse_gamma(color.y),
</span><span style=color:#86b300>+        inverse_gamma(color.z)
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn oklab_to_linear_rgb(c: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#86b300>+    let l_ = c.x + 0.39633778 * c.y + 0.21580376 * c.z;
</span><span style=color:#86b300>+    let m_ = c.x - 0.105561346 * c.y - 0.06385417 * c.z;
</span><span style=color:#86b300>+    let s_ = c.x - 0.08948418 * c.y - 1.2914855 * c.z;
</span><span style=color:#86b300>+    let l = l_ * l_ * l_;
</span><span style=color:#86b300>+    let m = m_ * m_ * m_;
</span><span style=color:#86b300>+    let s = s_ * s_ * s_;
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        4.0767417 * l - 3.3077116 * m + 0.23096994 * s,
</span><span style=color:#86b300>+        -1.268438 * l + 2.6097574 * m - 0.34131938 * s,
</span><span style=color:#86b300>+        -0.0041960863 * l - 0.7034186 * m + 1.7076147 * s,
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn hsl_to_linear_rgb(hsl: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#86b300>+    let h = hsl.x;
</span><span style=color:#86b300>+    let s = hsl.y;
</span><span style=color:#86b300>+    let l = hsl.z;
</span><span style=color:#86b300>+    let c = (1.0 - abs(2.0 * l - 1.0)) * s;
</span><span style=color:#86b300>+    let hp = h * 6.0;
</span><span style=color:#86b300>+    let x = c * (1.0 - abs(hp % 2.0 - 1.0));
</span><span style=color:#86b300>+    var r: f32 = 0.0;
</span><span style=color:#86b300>+    var g: f32 = 0.0;
</span><span style=color:#86b300>+    var b: f32 = 0.0;
</span><span style=color:#86b300>+    if 0.0 <= hp && hp < 1.0 {
</span><span style=color:#86b300>+        r = c; g = x; b = 0.0;
</span><span style=color:#86b300>+    } else if 1.0 <= hp && hp < 2.0 {
</span><span style=color:#86b300>+        r = x; g = c; b = 0.0;
</span><span style=color:#86b300>+    } else if 2.0 <= hp && hp < 3.0 {
</span><span style=color:#86b300>+        r = 0.0; g = c; b = x;
</span><span style=color:#86b300>+    } else if 3.0 <= hp && hp < 4.0 {
</span><span style=color:#86b300>+        r = 0.0; g = x; b = c;
</span><span style=color:#86b300>+    } else if 4.0 <= hp && hp < 5.0 {
</span><span style=color:#86b300>+        r = x; g = 0.0; b = c;
</span><span style=color:#86b300>+    } else if 5.0 <= hp && hp < 6.0 {
</span><span style=color:#86b300>+        r = c; g = 0.0; b = x;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    let m = l - 0.5 * c;
</span><span style=color:#86b300>+    return srgb_to_linear_rgb(vec3(r + m, g + m, b + m));
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn hsv_to_linear_rgb(hsva: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#86b300>+    let h = hsva.x * 6.0;
</span><span style=color:#86b300>+    let s = hsva.y;
</span><span style=color:#86b300>+    let v = hsva.z;
</span><span style=color:#86b300>+    let c = v * s;
</span><span style=color:#86b300>+    let x = c * (1.0 - abs(h % 2.0 - 1.0));
</span><span style=color:#86b300>+    let m = v - c;
</span><span style=color:#86b300>+    var r: f32 = 0.0;
</span><span style=color:#86b300>+    var g: f32 = 0.0;
</span><span style=color:#86b300>+    var b: f32 = 0.0;
</span><span style=color:#86b300>+    if 0.0 <= h && h < 1.0 {
</span><span style=color:#86b300>+        r = c; g = x; b = 0.0;
</span><span style=color:#86b300>+    } else if 1.0 <= h && h < 2.0 {
</span><span style=color:#86b300>+        r = x; g = c; b = 0.0;
</span><span style=color:#86b300>+    } else if 2.0 <= h && h < 3.0 {
</span><span style=color:#86b300>+        r = 0.0; g = c; b = x;
</span><span style=color:#86b300>+    } else if 3.0 <= h && h < 4.0 {
</span><span style=color:#86b300>+        r = 0.0; g = x; b = c;
</span><span style=color:#86b300>+    } else if 4.0 <= h && h < 5.0 {
</span><span style=color:#86b300>+        r = x; g = 0.0; b = c;
</span><span style=color:#86b300>+    } else if 5.0 <= h && h < 6.0 {
</span><span style=color:#86b300>+        r = c; g = 0.0; b = x;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    return srgb_to_linear_rgb(vec3(r + m, g + m, b + m));
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn oklch_to_linear_rgb(c: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#86b300>+    let hue = c.z * TAU;
</span><span style=color:#86b300>+    return oklab_to_linear_rgb(vec3(c.x, c.y * cos(hue), c.y * sin(hue)));
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn mix_oklch(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span style=color:#86b300>+    // If the chroma is close to zero for one of the endpoints, don't interpolate 
</span><span style=color:#86b300>+    // the hue and instead use the hue of the other endpoint. This allows gradients that smoothly 
</span><span style=color:#86b300>+    // transition from black or white to a target color without passing through unrelated hues.
</span><span style=color:#86b300>+    var h = a.z;
</span><span style=color:#86b300>+    var g = b.z;
</span><span style=color:#86b300>+    if a.y < HUE_GUARD {
</span><span style=color:#86b300>+        h = g;
</span><span style=color:#86b300>+    } else if b.y < HUE_GUARD {
</span><span style=color:#86b300>+        g = h;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let hue_diff = g - h;
</span><span style=color:#86b300>+    if abs(hue_diff) > 0.5 {
</span><span style=color:#86b300>+        if hue_diff > 0.0 {
</span><span style=color:#86b300>+            h += (hue_diff - 1.) * t;
</span><span style=color:#86b300>+        } else {
</span><span style=color:#86b300>+            h += (hue_diff + 1.) * t;
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    } else {
</span><span style=color:#86b300>+        h += hue_diff * t;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        mix(a.x, b.x, t),
</span><span style=color:#86b300>+        mix(a.y, b.y, t),
</span><span style=color:#86b300>+        fract(h),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn mix_oklch_long(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span style=color:#86b300>+    var h = a.z;
</span><span style=color:#86b300>+    var g = b.z;
</span><span style=color:#86b300>+    if a.y < HUE_GUARD {
</span><span style=color:#86b300>+        h = g;
</span><span style=color:#86b300>+    } else if b.y < HUE_GUARD {
</span><span style=color:#86b300>+        g = h;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let hue_diff = g - h;
</span><span style=color:#86b300>+    if abs(hue_diff) < 0.5 {
</span><span style=color:#86b300>+        if hue_diff >= 0.0 {
</span><span style=color:#86b300>+            h += (hue_diff - 1.) * t;
</span><span style=color:#86b300>+        } else {
</span><span style=color:#86b300>+            h += (hue_diff + 1.) * t;
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    } else {
</span><span style=color:#86b300>+        h += hue_diff * t;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        mix(a.x, b.x, t),
</span><span style=color:#86b300>+        mix(a.y, b.y, t),
</span><span style=color:#86b300>+        fract(h),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn mix_hsl(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span style=color:#86b300>+    // If the saturation is close to zero for one of the endpoints, don't interpolate 
</span><span style=color:#86b300>+    // the hue and instead use the hue of the other endpoint. This allows gradients that smoothly 
</span><span style=color:#86b300>+    // transition from black or white to a target color without passing through unrelated hues.
</span><span style=color:#86b300>+    var h = a.x; 
</span><span style=color:#86b300>+    var g = b.x;
</span><span style=color:#86b300>+    if a.y < HUE_GUARD {
</span><span style=color:#86b300>+        h = g;
</span><span style=color:#86b300>+    } else if b.y < HUE_GUARD {
</span><span style=color:#86b300>+        g = h;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        fract(h + (fract(g - h + 0.5) - 0.5) * t),
</span><span style=color:#86b300>+        mix(a.y, b.y, t),
</span><span style=color:#86b300>+        mix(a.z, b.z, t),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn mix_hsl_long(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span style=color:#86b300>+    var h = a.x;
</span><span style=color:#86b300>+    var g = b.x;
</span><span style=color:#86b300>+    if a.y < HUE_GUARD {
</span><span style=color:#86b300>+        h = g;
</span><span style=color:#86b300>+    } else if b.y < HUE_GUARD {
</span><span style=color:#86b300>+        g = h;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let d = fract(g - h + 0.5) - 0.5;
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        fract(h + (d + select(1., -1., 0. < d)) * t),
</span><span style=color:#86b300>+        mix(a.y, b.y, t),
</span><span style=color:#86b300>+        mix(a.z, b.z, t),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn mix_hsv(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span style=color:#86b300>+    // If the saturation is close to zero for one of the endpoints, don't interpolate 
</span><span style=color:#86b300>+    // the hue and instead use the hue of the other endpoint. This allows gradients that smoothly 
</span><span style=color:#86b300>+    // transition from black or white to a target color without passing through unrelated hues.
</span><span style=color:#86b300>+    var h = a.x;
</span><span style=color:#86b300>+    var g = b.x;
</span><span style=color:#86b300>+    if a.y < HUE_GUARD {
</span><span style=color:#86b300>+        h = g;
</span><span style=color:#86b300>+    } else if b.y < HUE_GUARD {
</span><span style=color:#86b300>+        g = h;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let hue_diff = g - h;
</span><span style=color:#86b300>+    if abs(hue_diff) > 0.5 {
</span><span style=color:#86b300>+        if hue_diff > 0.0 {
</span><span style=color:#86b300>+            h += (hue_diff - 1.0) * t;
</span><span style=color:#86b300>+        } else {
</span><span style=color:#86b300>+            h += (hue_diff + 1.0) * t;
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    } else {
</span><span style=color:#86b300>+        h += hue_diff * t;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        fract(h),
</span><span style=color:#86b300>+        mix(a.y, b.y, t),
</span><span style=color:#86b300>+        mix(a.z, b.z, t),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+fn mix_hsv_long(a: vec3&LTf32>, b: vec3&LTf32>, t: f32) -> vec3&LTf32> {
</span><span style=color:#86b300>+    var h = a.x;
</span><span style=color:#86b300>+    var g = b.x;
</span><span style=color:#86b300>+    if a.y < HUE_GUARD {
</span><span style=color:#86b300>+        h = g;
</span><span style=color:#86b300>+    } else if b.y < HUE_GUARD {
</span><span style=color:#86b300>+        g = h;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    let hue_diff = g - h;
</span><span style=color:#86b300>+    if abs(hue_diff) < 0.5 {
</span><span style=color:#86b300>+        if hue_diff >= 0.0 {
</span><span style=color:#86b300>+            h += (hue_diff - 1.0) * t;
</span><span style=color:#86b300>+        } else {
</span><span style=color:#86b300>+            h += (hue_diff + 1.0) * t;
</span><span style=color:#86b300>+        }
</span><span style=color:#86b300>+    } else {
</span><span style=color:#86b300>+        h += hue_diff * t;
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+    return vec3(
</span><span style=color:#86b300>+        fract(h),
</span><span style=color:#86b300>+        mix(a.y, b.y, t),
</span><span style=color:#86b300>+        mix(a.z, b.z, t),
</span><span style=color:#86b300>+    );
</span><span style=color:#86b300>+}
</span><span>diff --git a/crates/bevy_ui_render/src/gradient.wgsl b/crates/bevy_ui_render/src/gradient.wgsl
</span><span>index c36db3abb5895..aa4487f97b12a 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ui_render/src/gradient.wgsl
</span><span style=color:#c594c5>+++ b/crates/bevy_ui_render/src/gradient.wgsl
</span><span style=color:#c594c5>@@ -4,11 +4,24 @@
</span><span>     draw_uinode_border,
</span><span> }
</span><span> 
</span><span style=color:#f07171>-const PI: f32 = 3.14159265358979323846;
</span><span style=color:#86b300>+#import bevy_ui_render::color_space::{
</span><span style=color:#86b300>+    convert_to_linear_rgba,
</span><span style=color:#86b300>+    mix_oklch,
</span><span style=color:#86b300>+    mix_oklch_long,
</span><span style=color:#86b300>+    mix_hsv,
</span><span style=color:#86b300>+    mix_hsv_long,
</span><span style=color:#86b300>+    mix_hsl,
</span><span style=color:#86b300>+    mix_hsl_long,
</span><span style=color:#86b300>+    oklch_to_linear_rgb,
</span><span style=color:#86b300>+    hsv_to_linear_rgb,
</span><span style=color:#86b300>+    hsl_to_linear_rgb,
</span><span style=color:#86b300>+    oklab_to_linear_rgb,
</span><span style=color:#86b300>+}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+#import bevy_render::maths::PI
</span><span style=color:#86b300>+
</span><span> const TAU: f32 = 2. * PI;
</span><span style=color:#f07171>-const HUE_GUARD: f32 = 0.0001;
</span><span> 
</span><span style=color:#f07171>-const TEXTURED = 1u;
</span><span> const RIGHT_VERTEX = 2u;
</span><span> const BOTTOM_VERTEX = 4u;
</span><span> // must align with BORDER_* shader_flags from bevy_ui/render/mod.rs
</span><span style=color:#c594c5>@@ -115,124 +128,10 @@ </span><span style=color:#399ee6>fn fragment(in: GradientVertexOutput) -> @location(0) vec4&LTf32> {
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-// https://en.wikipedia.org/wiki/SRGB
</span><span style=color:#f07171>-fn gamma(value: f32) -> f32 {
</span><span style=color:#f07171>-    if value <= 0.0 {
</span><span style=color:#f07171>-        return value;
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-    if value <= 0.04045 {
</span><span style=color:#f07171>-        return value / 12.92; // linear falloff in dark values
</span><span style=color:#f07171>-    } else {
</span><span style=color:#f07171>-        return pow((value + 0.055) / 1.055, 2.4); // gamma curve in other area
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-// https://en.wikipedia.org/wiki/SRGB
</span><span style=color:#f07171>-fn inverse_gamma(value: f32) -> f32 {
</span><span style=color:#f07171>-    if value <= 0.0 {
</span><span style=color:#f07171>-        return value;
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    if value <= 0.0031308 {
</span><span style=color:#f07171>-        return value * 12.92; // linear falloff in dark values
</span><span style=color:#f07171>-    } else {
</span><span style=color:#f07171>-        return 1.055 * pow(value, 1.0 / 2.4) - 0.055; // gamma curve in other area
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-fn srgb_to_linear_rgb(color: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#f07171>-    return vec3(
</span><span style=color:#f07171>-        gamma(color.x),
</span><span style=color:#f07171>-        gamma(color.y),
</span><span style=color:#f07171>-        gamma(color.z)
</span><span style=color:#f07171>-    );
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-fn linear_rgb_to_srgb(color: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#f07171>-    return vec3(
</span><span style=color:#f07171>-        inverse_gamma(color.x),
</span><span style=color:#f07171>-        inverse_gamma(color.y),
</span><span style=color:#f07171>-        inverse_gamma(color.z)
</span><span style=color:#f07171>-    );
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-fn oklab_to_linear_rgb(c: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#f07171>-    let l_ = c.x + 0.39633778 * c.y + 0.21580376 * c.z;
</span><span style=color:#f07171>-    let m_ = c.x - 0.105561346 * c.y - 0.06385417 * c.z;
</span><span style=color:#f07171>-    let s_ = c.x - 0.08948418 * c.y - 1.2914855 * c.z;
</span><span style=color:#f07171>-    let l = l_ * l_ * l_;
</span><span style=color:#f07171>-    let m = m_ * m_ * m_;
</span><span style=color:#f07171>-    let s = s_ * s_ * s_;
</span><span style=color:#f07171>-    return vec3(
</span><span style=color:#f07171>-        4.0767417 * l - 3.3077116 * m + 0.23096994 * s,
</span><span style=color:#f07171>-        -1.268438 * l + 2.6097574 * m - 0.34131938 * s,
</span><span style=color:#f07171>-        -0.0041960863 * l - 0.7034186 * m + 1.7076147 * s,
</span><span style=color:#f07171>-    );
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-fn hsl_to_linear_rgb(hsl: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#f07171>-    let h = hsl.x;
</span><span style=color:#f07171>-    let s = hsl.y;
</span><span style=color:#f07171>-    let l = hsl.z;
</span><span style=color:#f07171>-    let c = (1.0 - abs(2.0 * l - 1.0)) * s;
</span><span style=color:#f07171>-    let hp = h * 6.0;
</span><span style=color:#f07171>-    let x = c * (1.0 - abs(hp % 2.0 - 1.0));
</span><span style=color:#f07171>-    var r: f32 = 0.0;
</span><span style=color:#f07171>-    var g: f32 = 0.0;
</span><span style=color:#f07171>-    var b: f32 = 0.0;
</span><span style=color:#f07171>-    if 0.0 <= hp && hp < 1.0 {
</span><span style=color:#f07171>-        r = c; g = x; b = 0.0;
</span><span style=color:#f07171>-    } else if 1.0 <= hp && hp < 2.0 {
</span><span style=color:#f07171>-        r = x; g = c; b = 0.0;
</span><span style=color:#f07171>-    } else if 2.0 <= hp && hp < 3.0 {
</span><span style=color:#f07171>-        r = 0.0; g = c; b = x;
</span><span style=color:#f07171>-    } else if 3.0 <= hp && hp < 4.0 {
</span><span style=color:#f07171>-        r = 0.0; g = x; b = c;
</span><span style=color:#f07171>-    } else if 4.0 <= hp && hp < 5.0 {
</span><span style=color:#f07171>-        r = x; g = 0.0; b = c;
</span><span style=color:#f07171>-    } else if 5.0 <= hp && hp < 6.0 {
</span><span style=color:#f07171>-        r = c; g = 0.0; b = x;
</span><span style=color:#f07171>-    }
</span><span style=color:#f07171>-    let m = l - 0.5 * c;
</span><span style=color:#f07171>-    return srgb_to_linear_rgb(vec3(r + m, g + m, b + m));
</span><span style=color:#f07171>-}
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-fn hsv_to_linear_rgb(hsva: vec3&LTf32>) -> vec3&LTf32> {
</span><span style=color:#f07171>-    let h = hsva.x * 6.0;
</span><span style=color:#f07171>-    let s = hsva.y;
</span><span style=color:#f07171>-    let v = hsva.z;
</span><span style=color:#f07171>-    let c = v * s;
</span><span style=color:#f07171>-    let x = c * (</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-11/pr_21720.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>