<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21203 Add two basic tests for asset hot reloading.
        
    </title><meta content="#21203 Add two basic tests for asset hot reloading." property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-26</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-09/pr-21203-zh-cn-20250925>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Add two basic tests for asset hot reloading<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Add two basic tests for asset hot reloading.<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21203<li><strong>Author</strong>: andriyDev<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-Assets, S-Ready-For-Final-Review, C-Testing, D-Straightforward<li><strong>Created</strong>: 2025-09-25T03:20:44Z<li><strong>Merged</strong>: 2025-09-25T23:43:36Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>Improve testing of <code>bevy_asset</code>.</ul><h2 id=solution>Solution</h2><ul><li>Add a simple test for hot reloading, as well as a helper function for testing hot reloading in general.<li>Add an ignored test which should be fixed by #21183.</ul><h2 id=testing>Testing</h2><ul><li>:)</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a gap in the Bevy asset system’s test coverage by adding comprehensive tests for asset hot reloading functionality. The developer recognized that while the asset system supports hot reloading (where assets can be updated while the application is running), there were no dedicated tests verifying this critical feature.<p>The implementation follows a systematic approach to testing hot reloading scenarios. The developer created a helper function <code>create_app_with_source_event_sender()</code> that sets up a test environment with a mock asset source and returns the necessary components for testing. This function:<ul><li>Creates a Bevy app with a memory-based asset reader<li>Sets up a channel to capture asset source events<li>Configures the asset plugin with hot reloading enabled</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>create_app_with_source_event_sender</span><span>() </span><span style=color:#61676ccc>-> </span><span>(App, Dir, Sender&LTAssetSourceEvent>) {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> app </span><span style=color:#ed9366>= </span><span>App</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> dir </span><span style=color:#ed9366>= </span><span>Dir</span><span style=color:#ed9366>::</span><span>default()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> memory_reader </span><span style=color:#ed9366>=</span><span> MemoryAssetReader { root</span><span style=color:#61676ccc>:</span><span> dir</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>() }</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Channel setup for event communication
</span><span>    </span><span style=color:#fa6e32>let </span><span>(sender_sender</span><span style=color:#61676ccc>,</span><span> sender_receiver) </span><span style=color:#ed9366>= </span><span>crossbeam_channel</span><span style=color:#ed9366>::</span><span>bounded(</span><span style=color:#ff8f40>1</span><span>)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... configuration continues
</span><span>}
</span></code></pre><p>Two main test scenarios are implemented:<ol><li><p><strong>Asset modification test</strong> (<code>reloads_asset_after_source_event</code>): Verifies that when an asset file is modified, the system correctly reloads it and emits appropriate modification events.</p><li><p><strong>Missing asset recovery test</strong> (<code>added_asset_reloads_previously_missing_asset</code>): Tests the scenario where an asset that was previously missing becomes available, ensuring the system properly handles the transition from failed load to successful load.</p></ol><p>The tests use a custom <code>run_app_until()</code> function (assumed to exist elsewhere) that runs the app until specific conditions are met, allowing for precise control over when assertions are evaluated.<p>A key technical insight in this implementation is the use of event collection helpers:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>collect_asset_events</span><span>&LTA</span><span style=color:#61676ccc>:</span><span> Asset>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTAssetEvent&LTA>> {
</span><span>    world
</span><span>        </span><span style=color:#ed9366>.</span><span>resource_mut</span><span style=color:#ed9366>::</span><span>&LTMessages&LTAssetEvent&LTA>>>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()
</span><span>}
</span></code></pre><p>These functions extract and clear event messages from the world, enabling clean assertion of expected event sequences.<p>The PR also includes a minor but important fix in <code>crates/bevy_asset/src/server/mod.rs</code> to prevent potential deadlocks in single-threaded environments. The change adds an explicit drop of a lock before spawning tasks that might block on the same lock:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Drop the lock on `AssetInfos` before spawning a task that may block on it in
</span><span style=color:#abb0b6;font-style:italic>// single-threaded.
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(</span><span style=color:#f29718>any</span><span>(target_arch </span><span style=color:#ed9366>= </span><span style=color:#86b300>"wasm32"</span><span style=color:#61676ccc>, </span><span style=color:#f29718>not</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"multi_threaded"</span><span>)))]
</span><span style=color:#f07171>drop</span><span>(infos)</span><span style=color:#61676ccc>;
</span></code></pre><p>This change demonstrates good defensive programming practices, anticipating edge cases in different execution environments.<p>The tests validate that asset events follow the expected sequence:<ul><li>For modifications: <code>LoadedWithDependencies</code> followed by <code>Modified</code><li>For recovered assets: <code>LoadedWithDependencies</code> followed by <code>Added</code></ul><p>The implementation shows careful attention to test isolation and cleanup, with proper event draining between test phases to prevent cross-contamination of test results.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Test Setup] --> B[Create App with Mock Source]
</span><span>    B --> C[Load Initial Asset]
</span><span>    C --> D[Trigger Hot Reload Event]
</span><span>    D --> E[Verify Asset Events]
</span><span>    E --> F[Validate Expected Behavior]
</span><span>    
</span><span>    G[Test Helper] --> H[Event Collection]
</span><span>    G --> I[App Control]
</span><span>    H --> E
</span><span>    I --> C
</span><span>    I --> D
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-asset-src-lib-rs-167-2><code>crates/bevy_asset/src/lib.rs</code> (+167/-2)</h3><p>This file received the bulk of the changes, adding comprehensive test infrastructure for asset hot reloading.<p><strong>Key additions:</strong><ul><li>Helper function <code>create_app_with_source_event_sender()</code> for test setup<li>Event collection utilities <code>collect_asset_events()</code> and <code>collect_asset_load_failed_events()</code><li>Two main test cases covering different hot reloading scenarios</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Example of the main test structure
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>reloads_asset_after_source_event</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let </span><span>(</span><span style=color:#fa6e32>mut</span><span> app</span><span style=color:#61676ccc>,</span><span> dir</span><span style=color:#61676ccc>,</span><span> source_events) </span><span style=color:#ed9366>= </span><span style=color:#f07171>create_app_with_source_event_sender</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test implementation...
</span><span>}
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>test</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>added_asset_reloads_previously_missing_asset</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let </span><span>(</span><span style=color:#fa6e32>mut</span><span> app</span><span style=color:#61676ccc>,</span><span> dir</span><span style=color:#61676ccc>,</span><span> source_events) </span><span style=color:#ed9366>= </span><span style=color:#f07171>create_app_with_source_event_sender</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Test implementation...
</span><span>}
</span></code></pre><h3 id=crates-bevy-asset-src-server-mod-rs-5-0><code>crates/bevy_asset/src/server/mod.rs</code> (+5/-0)</h3><p>Minor but important fix to prevent potential deadlocks in single-threaded environments.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Added code to prevent deadlocks
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>cfg</span><span>(</span><span style=color:#f29718>any</span><span>(target_arch </span><span style=color:#ed9366>= </span><span style=color:#86b300>"wasm32"</span><span style=color:#61676ccc>, </span><span style=color:#f29718>not</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"multi_threaded"</span><span>)))]
</span><span style=color:#f07171>drop</span><span>(infos)</span><span style=color:#61676ccc>;
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/books/assets/ target=_blank>Bevy Asset System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch11-00-testing.html target=_blank>Rust Testing Guide</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/crossbeam/latest/crossbeam/channel/ target=_blank>Crossbeam Channels for Inter-thread Communication</a><li><a rel="noopener nofollow noreferrer" href=https://gameprogrammingpatterns.com/observer.html target=_blank>Asset Hot Reloading Patterns in Game Engines</a></ul><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
</span><span>index bd210d3218c26..a8d5ad7d62f98 100644
</span><span style=color:#c594c5>--- a/crates/bevy_asset/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_asset/src/lib.rs
</span><span style=color:#c594c5>@@ -706,7 +706,8 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         io::{
</span><span>             gated::{GateOpener, GatedReader},
</span><span>             memory::{Dir, MemoryAssetReader},
</span><span style=color:#f07171>-            AssetReader, AssetReaderError, AssetSource, AssetSourceId, Reader,
</span><span style=color:#86b300>+            AssetReader, AssetReaderError, AssetSource, AssetSourceEvent, AssetSourceId,
</span><span style=color:#86b300>+            AssetWatcher, Reader,
</span><span>         },
</span><span>         loader::{AssetLoader, LoadContext},
</span><span>         Asset, AssetApp, AssetEvent, AssetId, AssetLoadError, AssetLoadFailedEvent, AssetPath,
</span><span style=color:#c594c5>@@ -730,8 +731,9 @@ </span><span style=color:#399ee6>mod tests {
</span><span>     use bevy_platform::collections::{HashMap, HashSet};
</span><span>     use bevy_reflect::TypePath;
</span><span>     use core::time::Duration;
</span><span style=color:#86b300>+    use crossbeam_channel::Sender;
</span><span>     use serde::{Deserialize, Serialize};
</span><span style=color:#f07171>-    use std::path::Path;
</span><span style=color:#86b300>+    use std::path::{Path, PathBuf};
</span><span>     use thiserror::Error;
</span><span> 
</span><span>     #[derive(Asset, TypePath, Debug, Default)]
</span><span style=color:#c594c5>@@ -2064,4 +2066,167 @@ </span><span style=color:#399ee6>mod tests {
</span><span>             Err(InvalidGenerationError::Removed { index })
</span><span>         );
</span><span>     }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    // Creates a basic app with the default asset source engineered to get back the asset event
</span><span style=color:#86b300>+    // sender.
</span><span style=color:#86b300>+    fn create_app_with_source_event_sender() -> (App, Dir, Sender&LTAssetSourceEvent>) {
</span><span style=color:#86b300>+        let mut app = App::new();
</span><span style=color:#86b300>+        let dir = Dir::default();
</span><span style=color:#86b300>+        let memory_reader = MemoryAssetReader { root: dir.clone() };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Create a channel to pass the source event sender back to us.
</span><span style=color:#86b300>+        let (sender_sender, sender_receiver) = crossbeam_channel::bounded(1);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        struct FakeWatcher;
</span><span style=color:#86b300>+        impl AssetWatcher for FakeWatcher {}
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.register_asset_source(
</span><span style=color:#86b300>+            AssetSourceId::Default,
</span><span style=color:#86b300>+            AssetSource::build()
</span><span style=color:#86b300>+                .with_reader(move || Box::new(memory_reader.clone()))
</span><span style=color:#86b300>+                .with_watcher(move |sender| {
</span><span style=color:#86b300>+                    sender_sender.send(sender).unwrap();
</span><span style=color:#86b300>+                    Some(Box::new(FakeWatcher))
</span><span style=color:#86b300>+                }),
</span><span style=color:#86b300>+        )
</span><span style=color:#86b300>+        .add_plugins((
</span><span style=color:#86b300>+            TaskPoolPlugin::default(),
</span><span style=color:#86b300>+            AssetPlugin {
</span><span style=color:#86b300>+                watch_for_changes_override: Some(true),
</span><span style=color:#86b300>+                ..Default::default()
</span><span style=color:#86b300>+            },
</span><span style=color:#86b300>+        ));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let sender = sender_receiver.try_recv().unwrap();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        (app, dir, sender)
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    fn collect_asset_events&LTA: Asset>(world: &mut World) -> Vec&LTAssetEvent&LTA>> {
</span><span style=color:#86b300>+        world
</span><span style=color:#86b300>+            .resource_mut::&LTMessages&LTAssetEvent&LTA>>>()
</span><span style=color:#86b300>+            .drain()
</span><span style=color:#86b300>+            .collect()
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    fn collect_asset_load_failed_events&LTA: Asset>(
</span><span style=color:#86b300>+        world: &mut World,
</span><span style=color:#86b300>+    ) -> Vec&LTAssetLoadFailedEvent&LTA>> {
</span><span style=color:#86b300>+        world
</span><span style=color:#86b300>+            .resource_mut::&LTMessages&LTAssetLoadFailedEvent&LTA>>>()
</span><span style=color:#86b300>+            .drain()
</span><span style=color:#86b300>+            .collect()
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn reloads_asset_after_source_event() {
</span><span style=color:#86b300>+        let (mut app, dir, source_events) = create_app_with_source_event_sender();
</span><span style=color:#86b300>+        let asset_server = app.world().resource::&LTAssetServer>().clone();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        dir.insert_asset_text(
</span><span style=color:#86b300>+            Path::new("abc.cool.ron"),
</span><span style=color:#86b300>+            r#"(
</span><span style=color:#86b300>+    text: "a",
</span><span style=color:#86b300>+    dependencies: [],
</span><span style=color:#86b300>+    embedded_dependencies: [],
</span><span style=color:#86b300>+    sub_texts: [],
</span><span style=color:#86b300>+)"#,
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.init_asset::&LTCoolText>()
</span><span style=color:#86b300>+            .init_asset::&LTSubText>()
</span><span style=color:#86b300>+            .register_asset_loader(CoolTextLoader);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let handle: Handle&LTCoolText> = asset_server.load("abc.cool.ron");
</span><span style=color:#86b300>+        run_app_until(&mut app, |world| {
</span><span style=color:#86b300>+            let messages = collect_asset_events(world);
</span><span style=color:#86b300>+            if messages.is_empty() {
</span><span style=color:#86b300>+                return None;
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+            assert_eq!(
</span><span style=color:#86b300>+                messages,
</span><span style=color:#86b300>+                [
</span><span style=color:#86b300>+                    AssetEvent::LoadedWithDependencies { id: handle.id() },
</span><span style=color:#86b300>+                    AssetEvent::Added { id: handle.id() },
</span><span style=color:#86b300>+                ]
</span><span style=color:#86b300>+            );
</span><span style=color:#86b300>+            Some(())
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // Sending an asset event should result in the asset being reloaded - resulting in a
</span><span style=color:#86b300>+        // "Modified" message.
</span><span style=color:#86b300>+        source_events
</span><span style=color:#86b300>+            .send(AssetSourceEvent::ModifiedAsset(PathBuf::from(
</span><span style=color:#86b300>+                "abc.cool.ron",
</span><span style=color:#86b300>+            )))
</span><span style=color:#86b300>+            .unwrap();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        run_app_until(&mut app, |world| {
</span><span style=color:#86b300>+            let messages = collect_asset_events(world);
</span><span style=color:#86b300>+            if messages.is_empty() {
</span><span style=color:#86b300>+                return None;
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+            assert_eq!(
</span><span style=color:#86b300>+                messages,
</span><span style=color:#86b300>+                [
</span><span style=color:#86b300>+                    AssetEvent::LoadedWithDependencies { id: handle.id() },
</span><span style=color:#86b300>+                    AssetEvent::Modified { id: handle.id() }
</span><span style=color:#86b300>+                ]
</span><span style=color:#86b300>+            );
</span><span style=color:#86b300>+            Some(())
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+    }
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    #[test]
</span><span style=color:#86b300>+    fn added_asset_reloads_previously_missing_asset() {
</span><span style=color:#86b300>+        let (mut app, dir, source_events) = create_app_with_source_event_sender();
</span><span style=color:#86b300>+        let asset_server = app.world().resource::&LTAssetServer>().clone();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        app.init_asset::&LTCoolText>()
</span><span style=color:#86b300>+            .init_asset::&LTSubText>()
</span><span style=color:#86b300>+            .register_asset_loader(CoolTextLoader);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        let handle: Handle&LTCoolText> = asset_server.load("abc.cool.ron");
</span><span style=color:#86b300>+        run_app_until(&mut app, |world| {
</span><span style=color:#86b300>+            let failed_ids = collect_asset_load_failed_events(world)
</span><span style=color:#86b300>+                .drain(..)
</span><span style=color:#86b300>+                .map(|event| event.id)
</span><span style=color:#86b300>+                .collect::&LTVec<_>>();
</span><span style=color:#86b300>+            if failed_ids.is_empty() {
</span><span style=color:#86b300>+                return None;
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+            assert_eq!(failed_ids, [handle.id()]);
</span><span style=color:#86b300>+            Some(())
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // The asset has already been considered as failed to load. Now we add the asset data, and
</span><span style=color:#86b300>+        // send an AddedAsset event.
</span><span style=color:#86b300>+        dir.insert_asset_text(
</span><span style=color:#86b300>+            Path::new("abc.cool.ron"),
</span><span style=color:#86b300>+            r#"(
</span><span style=color:#86b300>+    text: "a",
</span><span style=color:#86b300>+    dependencies: [],
</span><span style=color:#86b300>+    embedded_dependencies: [],
</span><span style=color:#86b300>+    sub_texts: [],
</span><span style=color:#86b300>+)"#,
</span><span style=color:#86b300>+        );
</span><span style=color:#86b300>+        source_events
</span><span style=color:#86b300>+            .send(AssetSourceEvent::AddedAsset(PathBuf::from("abc.cool.ron")))
</span><span style=color:#86b300>+            .unwrap();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        run_app_until(&mut app, |world| {
</span><span style=color:#86b300>+            let messages = collect_asset_events(world);
</span><span style=color:#86b300>+            if messages.is_empty() {
</span><span style=color:#86b300>+                return None;
</span><span style=color:#86b300>+            }
</span><span style=color:#86b300>+            assert_eq!(
</span><span style=color:#86b300>+                messages,
</span><span style=color:#86b300>+                [
</span><span style=color:#86b300>+                    AssetEvent::LoadedWithDependencies { id: handle.id() },
</span><span style=color:#86b300>+                    AssetEvent::Added { id: handle.id() }
</span><span style=color:#86b300>+                ]
</span><span style=color:#86b300>+            );
</span><span style=color:#86b300>+            Some(())
</span><span style=color:#86b300>+        });
</span><span style=color:#86b300>+    }
</span><span> }
</span><span>diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs
</span><span>index 534359801eb23..5c938404643ff 100644
</span><span style=color:#c594c5>--- a/crates/bevy_asset/src/server/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_asset/src/server/mod.rs
</span><span style=color:#c594c5>@@ -1763,6 +1763,11 @@ </span><span style=color:#399ee6>pub fn handle_internal_asset_events(world: &mut World) {
</span><span>             }
</span><span>         }
</span><span> 
</span><span style=color:#86b300>+        // Drop the lock on `AssetInfos` before spawning a task that may block on it in
</span><span style=color:#86b300>+        // single-threaded.
</span><span style=color:#86b300>+        #[cfg(any(target_arch = "wasm32", not(feature = "multi_threaded"))]
</span><span style=color:#86b300>+        drop(infos);
</span><span style=color:#86b300>+
</span><span>         for path in paths_to_reload {
</span><span>             info!("Reloading {path} because it has changed");
</span><span>             server.reload(path);
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_21203.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>