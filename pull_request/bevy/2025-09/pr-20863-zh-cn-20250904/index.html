<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20863 prepare_uinodes` refactor
        
    </title><meta content="#20863 prepare_uinodes` refactor" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-04</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-09/pr-20863-en-20250904>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=prepare-uinodes-refactor><code>prepare_uinodes</code> refactor</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: <code>prepare_uinodes</code> refactor<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/20863<li><strong>作者</strong>: ickshonpe<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: D-Trivial, A-Rendering, A-UI, C-Code-Quality, S-Ready-For-Review<li><strong>创建时间</strong>: 2025-09-04T13:01:57Z<li><strong>合并时间</strong>: 2025-09-04T18:07:13Z<li><strong>合并人</strong>: alice-i-cecile</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h1 id=objective>Objective</h1><p>通过使用 let-some-else-continue 替换 if-let-else 块，将 <code>prepare_uinodes</code> 内部代码扁平化一级。<h2 id=ce-shi>测试</h2><p>运行以下命令应该看不到任何变化： <code>cargo run --example testbed_ui</code><h2 id=zhe-ge-prde-gu-shi>这个PR的故事</h2><p>这个PR的核心是一个代码重构(refactoring)任务，专注于改进Bevy引擎UI渲染模块中<code>prepare_uinodes</code>函数的代码结构和可读性。该函数负责准备UI节点进行渲染，是UI渲染管线的关键组成部分。<h3 id=wen-ti-he-bei-jing>问题和背景</h3><p>在原始的<code>prepare_uinodes</code>函数中，存在一个深度嵌套的if-let-else结构：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(extracted_uinode) </span><span style=color:#ed9366>=</span><span> extracted_uinodes
</span><span>    </span><span style=color:#ed9366>.</span><span>uinodes
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(item</span><span style=color:#ed9366>.</span><span>index)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter</span><span>(|</span><span style=color:#ff8f40>n</span><span>| item</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>() </span><span style=color:#ed9366>==</span><span> n</span><span style=color:#ed9366>.</span><span>render_entity)
</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 大量的处理逻辑...
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    batch_image_handle </span><span style=color:#ed9366>= </span><span>AssetId</span><span style=color:#ed9366>::</span><span>invalid()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这种嵌套结构导致了几个问题：<ol><li><strong>代码可读性差</strong>：深层嵌套使得代码难以理解和维护<li><strong>认知负担</strong>：开发者需要跟踪多个嵌套层级才能理解整体逻辑<li><strong>错误处理不清晰</strong>：else分支的处理逻辑被埋藏在深层嵌套中</ol><h3 id=jie-jue-fang-an>解决方案</h3><p>开发者采用了Rust中常见的“提前返回“(early return)模式，将if-let-else结构重构为let-some-else-continue模式：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(extracted_uinode) </span><span style=color:#ed9366>=</span><span> extracted_uinodes
</span><span>    </span><span style=color:#ed9366>.</span><span>uinodes
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(item</span><span style=color:#ed9366>.</span><span>index)
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter</span><span>(|</span><span style=color:#ff8f40>n</span><span>| item</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>() </span><span style=color:#ed9366>==</span><span> n</span><span style=color:#ed9366>.</span><span>render_entity)
</span><span style=color:#fa6e32>else </span><span>{
</span><span>    batch_image_handle </span><span style=color:#ed9366>= </span><span>AssetId</span><span style=color:#ed9366>::</span><span>invalid()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>这种重构带来了几个显著优势：<ol><li><strong>减少嵌套层级</strong>：将原来的if-let-else嵌套减少了一层<li><strong>清晰错误处理</strong>：使用continue明确跳过不符合条件的项<li><strong>代码扁平化</strong>：主逻辑不再被包裹在额外的缩进层级中</ol><h3 id=ji-shu-shi-xian-xi-jie>技术实现细节</h3><p>重构的关键变化是将条件提取提前处理，使得主要业务逻辑能够在更平坦的结构中执行。这种模式在Rust中被称为“let-else“模式，它允许在模式匹配失败时执行else块中的代码，然后退出当前作用域。<p>在UI渲染的上下文中，这个重构特别有价值，因为：<ul><li><code>prepare_uinodes</code>函数处理大量UI节点，清晰的代码结构有助于性能分析和调试<li>渲染逻辑本身已经足够复杂，减少不必要的嵌套可以提高可维护性<li>明确的continue语句使得跳过无效节点的逻辑更加清晰</ul><h3 id=ying-xiang-he-shou-yi>影响和收益</h3><p>这个重构虽然不改变功能行为，但带来了重要的代码质量改进：<ol><li><strong>可读性提升</strong>：代码结构更加清晰，新开发者更容易理解渲染逻辑<li><strong>维护性增强</strong>：减少嵌套使得后续修改和调试更加容易<li><strong>一致性改进</strong>：符合Rust社区的代码风格最佳实践</ol><p>测试验证表明重构没有改变任何功能行为，<code>cargo run --example testbed_ui</code>命令的输出保持不变，确保了重构的安全性。<h2 id=ke-shi-hua-biao-shi>可视化表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[prepare_uinodes函数] --> B[遍历UI阶段项]
</span><span>    B --> C{提取UI节点成功?}
</span><span>    C -->|是| D[处理节点渲染逻辑]
</span><span>    C -->|否| E[重置batch_image_handle并continue]
</span><span>    D --> F[处理Node类型]
</span><span>    D --> G[处理Glyphs类型]
</span><span>    F --> H[更新批次信息]
</span><span>    G --> H
</span><span>    H --> I[继续处理下一个项]
</span><span>    E --> I
</span></code></pre><h2 id=guan-jian-wen-jian-geng-gai>关键文件更改</h2><ul><li><code>crates/bevy_ui_render/src/lib.rs</code> (+269/-271)</ul><h3 id=zhu-yao-bian-geng-miao-shu>主要变更描述</h3><p>这个PR主要重构了<code>prepare_uinodes</code>函数中的节点提取逻辑，将深层的if-let-else结构扁平化为let-some-else-continue模式。<p><strong>重构前代码结构</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>for</span><span> item_index </span><span style=color:#ed9366>in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span>ui_phase</span><span style=color:#ed9366>.</span><span>items</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> item </span><span style=color:#ed9366>= &</span><span style=color:#fa6e32>mut</span><span> ui_phase</span><span style=color:#ed9366>.</span><span>items[item_index]</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(extracted_uinode) </span><span style=color:#ed9366>=</span><span> extracted_uinodes
</span><span>        </span><span style=color:#ed9366>.</span><span>uinodes
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(item</span><span style=color:#ed9366>.</span><span>index)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter</span><span>(|</span><span style=color:#ff8f40>n</span><span>| item</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>() </span><span style=color:#ed9366>==</span><span> n</span><span style=color:#ed9366>.</span><span>render_entity)
</span><span>    {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// 大量的节点处理逻辑...
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        batch_image_handle </span><span style=color:#ed9366>= </span><span>AssetId</span><span style=color:#ed9366>::</span><span>invalid()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p><strong>重构后代码结构</strong>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>for</span><span> item_index </span><span style=color:#ed9366>in </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>..</span><span>ui_phase</span><span style=color:#ed9366>.</span><span>items</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> item </span><span style=color:#ed9366>= &</span><span style=color:#fa6e32>mut</span><span> ui_phase</span><span style=color:#ed9366>.</span><span>items[item_index]</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(extracted_uinode) </span><span style=color:#ed9366>=</span><span> extracted_uinodes
</span><span>        </span><span style=color:#ed9366>.</span><span>uinodes
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(item</span><span style=color:#ed9366>.</span><span>index)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter</span><span>(|</span><span style=color:#ff8f40>n</span><span>| item</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>() </span><span style=color:#ed9366>==</span><span> n</span><span style=color:#ed9366>.</span><span>render_entity)
</span><span>    </span><span style=color:#fa6e32>else </span><span>{
</span><span>        batch_image_handle </span><span style=color:#ed9366>= </span><span>AssetId</span><span style=color:#ed9366>::</span><span>invalid()</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 节点处理逻辑（保持原样）...
</span><span>}
</span></code></pre><p>这个变化虽然看似简单，但显著改善了代码的可读性和维护性，是典型的代码质量改进重构。<h2 id=yan-shen-yue-du>延伸阅读</h2><p>对于想深入了解相关技术的开发者，建议阅读以下资源：<ol><li><strong>Rust let-else语法</strong>: <a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/rfcs/3137-let-else.html target=_blank>Rust RFC 3137</a> - 官方let-else语法提案<li><strong>代码重构技术</strong>: Martin Fowler的《Refactoring: Improving the Design of Existing Code》- 代码重构经典著作<li><strong>Bevy UI渲染架构</strong>: <a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/ target=_blank>Bevy UI文档</a> - Bevy引擎UI系统概述<li><strong>Rust模式匹配</strong>: <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html target=_blank>Rust Book模式匹配章节</a> - Rust模式匹配全面指南</ol><h1 id=wan-zheng-dai-ma-chai-yi>完整代码差异</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_ui_render/src/lib.rs b/crates/bevy_ui_render/src/lib.rs
</span><span>index 2f272449951d2..2eb662ae42fa1 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ui_render/src/lib.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ui_render/src/lib.rs
</span><span style=color:#c594c5>@@ -1331,105 +1331,253 @@ </span><span style=color:#399ee6>pub fn prepare_uinodes(
</span><span> 
</span><span>             for item_index in 0..ui_phase.items.len() {
</span><span>                 let item = &mut ui_phase.items[item_index];
</span><span style=color:#f07171>-                if let Some(extracted_uinode) = extracted_uinodes
</span><span style=color:#86b300>+                let Some(extracted_uinode) = extracted_uinodes
</span><span>                     .uinodes
</span><span>                     .get(item.index)
</span><span>                     .filter(|n| item.entity() == n.render_entity)
</span><span style=color:#f07171>-                {
</span><span style=color:#f07171>-                    let mut existing_batch = batches.last_mut();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                    if batch_image_handle == AssetId::invalid()
</span><span style=color:#f07171>-                        || existing_batch.is_none()
</span><span style=color:#f07171>-                        || (batch_image_handle != AssetId::default()
</span><span style=color:#f07171>-                            && extracted_uinode.image != AssetId::default()
</span><span style=color:#f07171>-                            && batch_image_handle != extracted_uinode.image)
</span><span style=color:#f07171>-                    {
</span><span style=color:#f07171>-                        if let Some(gpu_image) = gpu_images.get(extracted_uinode.image) {
</span><span style=color:#f07171>-                            batch_item_index = item_index;
</span><span style=color:#f07171>-                            batch_image_handle = extracted_uinode.image;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            let new_batch = UiBatch {
</span><span style=color:#f07171>-                                range: vertices_index..vertices_index,
</span><span style=color:#f07171>-                                image: extracted_uinode.image,
</span><span style=color:#f07171>-                            };
</span><span style=color:#86b300>+                else {
</span><span style=color:#86b300>+                    batch_image_handle = AssetId::invalid();
</span><span style=color:#86b300>+                    continue;
</span><span style=color:#86b300>+                };
</span><span> 
</span><span style=color:#f07171>-                            batches.push((item.entity(), new_batch));
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            image_bind_groups
</span><span style=color:#f07171>-                                .values
</span><span style=color:#f07171>-                                .entry(batch_image_handle)
</span><span style=color:#f07171>-                                .or_insert_with(|| {
</span><span style=color:#f07171>-                                    render_device.create_bind_group(
</span><span style=color:#f07171>-                                        "ui_material_bind_group",
</span><span style=color:#f07171>-                                        &ui_pipeline.image_layout,
</span><span style=color:#f07171>-                                        &BindGroupEntries::sequential((
</span><span style=color:#f07171>-                                            &gpu_image.texture_view,
</span><span style=color:#f07171>-                                            &gpu_image.sampler,
</span><span style=color:#f07171>-                                        )),
</span><span style=color:#f07171>-                                    )
</span><span style=color:#f07171>-                                });
</span><span style=color:#86b300>+                let mut existing_batch = batches.last_mut();
</span><span> 
</span><span style=color:#f07171>-                            existing_batch = batches.last_mut();
</span><span style=color:#f07171>-                        } else {
</span><span style=color:#f07171>-                            continue;
</span><span style=color:#f07171>-                        }
</span><span style=color:#f07171>-                    } else if batch_image_handle == AssetId::default()
</span><span style=color:#86b300>+                if batch_image_handle == AssetId::invalid()
</span><span style=color:#86b300>+                    || existing_batch.is_none()
</span><span style=color:#86b300>+                    || (batch_image_handle != AssetId::default()
</span><span>                         && extracted_uinode.image != AssetId::default()
</span><span style=color:#86b300>+                        && batch_image_handle != extracted_uinode.image)
</span><span style=color:#86b300>+                {
</span><span style=color:#86b300>+                    if let Some(gpu_image) = gpu_images.get(extracted_uinode.image) {
</span><span style=color:#86b300>+                        batch_item_index = item_index;
</span><span style=color:#86b300>+                        batch_image_handle = extracted_uinode.image;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let new_batch = UiBatch {
</span><span style=color:#86b300>+                            range: vertices_index..vertices_index,
</span><span style=color:#86b300>+                            image: extracted_uinode.image,
</span><span style=color:#86b300>+                        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        batches.push((item.entity(), new_batch));
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        image_bind_groups
</span><span style=color:#86b300>+                            .values
</span><span style=color:#86b300>+                            .entry(batch_image_handle)
</span><span style=color:#86b300>+                            .or_insert_with(|| {
</span><span style=color:#86b300>+                                render_device.create_bind_group(
</span><span style=color:#86b300>+                                    "ui_material_bind_group",
</span><span style=color:#86b300>+                                    &ui_pipeline.image_layout,
</span><span style=color:#86b300>+                                    &BindGroupEntries::sequential((
</span><span style=color:#86b300>+                                        &gpu_image.texture_view,
</span><span style=color:#86b300>+                                        &gpu_image.sampler,
</span><span style=color:#86b300>+                                    )),
</span><span style=color:#86b300>+                                )
</span><span style=color:#86b300>+                            });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        existing_batch = batches.last_mut();
</span><span style=color:#86b300>+                    } else {
</span><span style=color:#86b300>+                        continue;
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                } else if batch_image_handle == AssetId::default()
</span><span style=color:#86b300>+                    && extracted_uinode.image != AssetId::default()
</span><span style=color:#86b300>+                {
</span><span style=color:#86b300>+                    if let Some(ref mut existing_batch) = existing_batch
</span><span style=color:#86b300>+                        && let Some(gpu_image) = gpu_images.get(extracted_uinode.image)
</span><span>                     {
</span><span style=color:#f07171>-                        if let Some(ref mut existing_batch) = existing_batch
</span><span style=color:#f07171>-                            && let Some(gpu_image) = gpu_images.get(extracted_uinode.image)
</span><span style=color:#f07171>-                        {
</span><span style=color:#f07171>-                            batch_image_handle = extracted_uinode.image;
</span><span style=color:#f07171>-                            existing_batch.1.image = extracted_uinode.image;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            image_bind_groups
</span><span style=color:#f07171>-                                .values
</span><span style=color:#f07171>-                                .entry(batch_image_handle)
</span><span style=color:#f07171>-                                .or_insert_with(|| {
</span><span style=color:#f07171>-                                    render_device.create_bind_group(
</span><span style=color:#f07171>-                                        "ui_material_bind_group",
</span><span style=color:#f07171>-                                        &ui_pipeline.image_layout,
</span><span style=color:#f07171>-                                        &BindGroupEntries::sequential((
</span><span style=color:#f07171>-                                            &gpu_image.texture_view,
</span><span style=color:#f07171>-                                            &gpu_image.sampler,
</span><span style=color:#f07171>-                                        )),
</span><span style=color:#f07171>-                                    )
</span><span style=color:#f07171>-                                });
</span><span style=color:#86b300>+                        batch_image_handle = extracted_uinode.image;
</span><span style=color:#86b300>+                        existing_batch.1.image = extracted_uinode.image;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        image_bind_groups
</span><span style=color:#86b300>+                            .values
</span><span style=color:#86b300>+                            .entry(batch_image_handle)
</span><span style=color:#86b300>+                            .or_insert_with(|| {
</span><span style=color:#86b300>+                                render_device.create_bind_group(
</span><span style=color:#86b300>+                                    "ui_material_bind_group",
</span><span style=color:#86b300>+                                    &ui_pipeline.image_layout,
</span><span style=color:#86b300>+                                    &BindGroupEntries::sequential((
</span><span style=color:#86b300>+                                        &gpu_image.texture_view,
</span><span style=color:#86b300>+                                        &gpu_image.sampler,
</span><span style=color:#86b300>+                                    )),
</span><span style=color:#86b300>+                                )
</span><span style=color:#86b300>+                            });
</span><span style=color:#86b300>+                    } else {
</span><span style=color:#86b300>+                        continue;
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                }
</span><span style=color:#86b300>+                match &extracted_uinode.item {
</span><span style=color:#86b300>+                    ExtractedUiItem::Node {
</span><span style=color:#86b300>+                        atlas_scaling,
</span><span style=color:#86b300>+                        flip_x,
</span><span style=color:#86b300>+                        flip_y,
</span><span style=color:#86b300>+                        border_radius,
</span><span style=color:#86b300>+                        border,
</span><span style=color:#86b300>+                        node_type,
</span><span style=color:#86b300>+                        rect,
</span><span style=color:#86b300>+                        color,
</span><span style=color:#86b300>+                    } => {
</span><span style=color:#86b300>+                        let mut flags = if extracted_uinode.image != AssetId::default() {
</span><span style=color:#86b300>+                            shader_flags::TEXTURED
</span><span>                         } else {
</span><span style=color:#f07171>-                            continue;
</span><span style=color:#86b300>+                            shader_flags::UNTEXTURED
</span><span style=color:#86b300>+                        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let mut uinode_rect = *rect;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let rect_size = uinode_rect.size();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let transform = extracted_uinode.transform;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        // Specify the corners of the node
</span><span style=color:#86b300>+                        let positions = QUAD_VERTEX_POSITIONS
</span><span style=color:#86b300>+                            .map(|pos| transform.transform_point2(pos * rect_size).extend(0.));
</span><span style=color:#86b300>+                        let points = QUAD_VERTEX_POSITIONS.map(|pos| pos * rect_size);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        // Calculate the effect of clipping
</span><span style=color:#86b300>+                        // Note: this won't work with rotation/scaling, but that's much more complex (may need more that 2 quads)
</span><span style=color:#86b300>+                        let mut positions_diff = if let Some(clip) = extracted_uinode.clip {
</span><span style=color:#86b300>+                            [
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    f32::max(clip.min.x - positions[0].x, 0.),
</span><span style=color:#86b300>+                                    f32::max(clip.min.y - positions[0].y, 0.),
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    f32::min(clip.max.x - positions[1].x, 0.),
</span><span style=color:#86b300>+                                    f32::max(clip.min.y - positions[1].y, 0.),
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    f32::min(clip.max.x - positions[2].x, 0.),
</span><span style=color:#86b300>+                                    f32::min(clip.max.y - positions[2].y, 0.),
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    f32::max(clip.min.x - positions[3].x, 0.),
</span><span style=color:#86b300>+                                    f32::min(clip.max.y - positions[3].y, 0.),
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                            ]
</span><span style=color:#86b300>+                        } else {
</span><span style=color:#86b300>+                            [Vec2::ZERO; 4]
</span><span style=color:#86b300>+                        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let positions_clipped = [
</span><span style=color:#86b300>+                            positions[0] + positions_diff[0].extend(0.),
</span><span style=color:#86b300>+                            positions[1] + positions_diff[1].extend(0.),
</span><span style=color:#86b300>+                            positions[2] + positions_diff[2].extend(0.),
</span><span style=color:#86b300>+                            positions[3] + positions_diff[3].extend(0.),
</span><span style=color:#86b300>+                        ];
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let points = [
</span><span style=color:#86b300>+                            points[0] + positions_diff[0],
</span><span style=color:#86b300>+                            points[1] + positions_diff[1],
</span><span style=color:#86b300>+                            points[2] + positions_diff[2],
</span><span style=color:#86b300>+                            points[3] + positions_diff[3],
</span><span style=color:#86b300>+                        ];
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let transformed_rect_size = transform.transform_vector2(rect_size);
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        // Don't try to cull nodes that have a rotation
</span><span style=color:#86b300>+                        // In a rotation around the Z-axis, this value is 0.0 for an angle of 0.0 or π
</span><span style=color:#86b300>+                        // In those two cases, the culling check can proceed normally as corners will be on
</span><span style=color:#86b300>+                        // horizontal / vertical lines
</span><span style=color:#86b300>+                        // For all other angles, bypass the culling check
</span><span style=color:#86b300>+                        // This does not properly handles all rotations on all axis
</span><span style=color:#86b300>+                        if transform.x_axis[1] == 0.0 {
</span><span style=color:#86b300>+                            // Cull nodes that are completely clipped
</span><span style=color:#86b300>+                            if positions_diff[0].x - positions_diff[1].x >= transformed_rect_size.x
</span><span style=color:#86b300>+                                || positions_diff[1].y - positions_diff[2].y
</span><span style=color:#86b300>+                                    >= transformed_rect_size.y
</span><span style=color:#86b300>+                            {
</span><span style=color:#86b300>+                                continue;
</span><span style=color:#86b300>+                            }
</span><span style=color:#86b300>+                        }
</span><span style=color:#86b300>+                        let uvs = if flags == shader_flags::UNTEXTURED {
</span><span style=color:#86b300>+                            [Vec2::ZERO, Vec2::X, Vec2::ONE, Vec2::Y]
</span><span style=color:#86b300>+                        } else {
</span><span style=color:#86b300>+                            let image = gpu_images
</span><span style=color:#86b300>+                                .get(extracted_uinode.image)
</span><span style=color:#86b300>+                                .expect("Image was checked during batching and should still exist");
</span><span style=color:#86b300>+                            // Rescale atlases. This is done here because we need texture data that might not be available in Extract.
</span><span style=color:#86b300>+                            let atlas_extent = atlas_scaling
</span><span style=color:#86b300>+                                .map(|scaling| image.size_2d().as_vec2() * scaling)
</span><span style=color:#86b300>+                                .unwrap_or(uinode_rect.max);
</span><span style=color:#86b300>+                            if *flip_x {
</span><span style=color:#86b300>+                                core::mem::swap(&mut uinode_rect.max.x, &mut uinode_rect.min.x);
</span><span style=color:#86b300>+                                positions_diff[0].x *= -1.;
</span><span style=color:#86b300>+                                positions_diff[1].x *= -1.;
</span><span style=color:#86b300>+                                positions_diff[2].x *= -1.;
</span><span style=color:#86b300>+                                positions_diff[3].x *= -1.;
</span><span style=color:#86b300>+                            }
</span><span style=color:#86b300>+                            if *flip_y {
</span><span style=color:#86b300>+                                core::mem::swap(&mut uinode_rect.max.y, &mut uinode_rect.min.y);
</span><span style=color:#86b300>+                                positions_diff[0].y *= -1.;
</span><span style=color:#86b300>+                                positions_diff[1].y *= -1.;
</span><span style=color:#86b300>+                                positions_diff[2].y *= -1.;
</span><span style=color:#86b300>+                                positions_diff[3].y *= -1.;
</span><span style=color:#86b300>+                            }
</span><span style=color:#86b300>+                            [
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    uinode_rect.min.x + positions_diff[0].x,
</span><span style=color:#86b300>+                                    uinode_rect.min.y + positions_diff[0].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    uinode_rect.max.x + positions_diff[1].x,
</span><span style=color:#86b300>+                                    uinode_rect.min.y + positions_diff[1].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    uinode_rect.max.x + positions_diff[2].x,
</span><span style=color:#86b300>+                                    uinode_rect.max.y + positions_diff[2].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    uinode_rect.min.x + positions_diff[3].x,
</span><span style=color:#86b300>+                                    uinode_rect.max.y + positions_diff[3].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                            ]
</span><span style=color:#86b300>+                            .map(|pos| pos / atlas_extent)
</span><span style=color:#86b300>+                        };
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let color = color.to_f32_array();
</span><span style=color:#86b300>+                        if let NodeType::Border(border_flags) = *node_type {
</span><span style=color:#86b300>+                            flags |= border_flags;
</span><span>                         }
</span><span style=color:#f07171>-                    }
</span><span style=color:#f07171>-                    match &extracted_uinode.item {
</span><span style=color:#f07171>-                        ExtractedUiItem::Node {
</span><span style=color:#f07171>-                            atlas_scaling,
</span><span style=color:#f07171>-                            flip_x,
</span><span style=color:#f07171>-                            flip_y,
</span><span style=color:#f07171>-                            border_radius,
</span><span style=color:#f07171>-                            border,
</span><span style=color:#f07171>-                            node_type,
</span><span style=color:#f07171>-                            rect,
</span><span style=color:#f07171>-                            color,
</span><span style=color:#f07171>-                        } => {
</span><span style=color:#f07171>-                            let mut flags = if extracted_uinode.image != AssetId::default() {
</span><span style=color:#f07171>-                                shader_flags::TEXTURED
</span><span style=color:#f07171>-                            } else {
</span><span style=color:#f07171>-                                shader_flags::UNTEXTURED
</span><span style=color:#f07171>-                            };
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            let mut uinode_rect = *rect;
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            let rect_size = uinode_rect.size();
</span><span> 
</span><span style=color:#f07171>-                            let transform = extracted_uinode.transform;
</span><span style=color:#86b300>+                        for i in 0..4 {
</span><span style=color:#86b300>+                            ui_meta.vertices.push(UiVertex {
</span><span style=color:#86b300>+                                position: positions_clipped[i].into(),
</span><span style=color:#86b300>+                                uv: uvs[i].into(),
</span><span style=color:#86b300>+                                color,
</span><span style=color:#86b300>+                                flags: flags | shader_flags::CORNERS[i],
</span><span style=color:#86b300>+                                radius: (*border_radius).into(),
</span><span style=color:#86b300>+                                border: [border.left, border.top, border.right, border.bottom],
</span><span style=color:#86b300>+                                size: rect_size.into(),
</span><span style=color:#86b300>+                                point: points[i].into(),
</span><span style=color:#86b300>+                            });
</span><span style=color:#86b300>+                        }
</span><span> 
</span><span style=color:#f07171>-                            // Specify the corners of the node
</span><span style=color:#f07171>-                            let positions = QUAD_VERTEX_POSITIONS
</span><span style=color:#f07171>-                                .map(|pos| transform.transform_point2(pos * rect_size).extend(0.));
</span><span style=color:#f07171>-                            let points = QUAD_VERTEX_POSITIONS.map(|pos| pos * rect_size);
</span><span style=color:#86b300>+                        for &i in &QUAD_INDICES {
</span><span style=color:#86b300>+                            ui_meta.indices.push(indices_index + i as u32);
</span><span style=color:#86b300>+                        }
</span><span> 
</span><span style=color:#f07171>-                            // Calculate the effect of clipping
</span><span style=color:#f07171>-                            // Note: this won't work with rotation/scaling, but that's much more complex (may need more that 2 quads)
</span><span style=color:#f07171>-                            let mut positions_diff = if let Some(clip) = extracted_uinode.clip {
</span><span style=color:#86b300>+                        vertices_index += 6;
</span><span style=color:#86b300>+                        indices_index += 4;
</span><span style=color:#86b300>+                    }
</span><span style=color:#86b300>+                    ExtractedUiItem::Glyphs { range } => {
</span><span style=color:#86b300>+                        let image = gpu_images
</span><span style=color:#86b300>+                            .get(extracted_uinode.image)
</span><span style=color:#86b300>+                            .expect("Image was checked during batching and should still exist");
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        let atlas_extent = image.size_2d().as_vec2();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                        for glyph in &extracted_uinodes.glyphs[range.clone()] {
</span><span style=color:#86b300>+                            let color = glyph.color.to_f32_array();
</span><span style=color:#86b300>+                            let glyph_rect = glyph.rect;
</span><span style=color:#86b300>+                            let rect_size = glyph_rect.size();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                            // Specify the corners of the glyph
</span><span style=color:#86b300>+                            let positions = QUAD_VERTEX_POSITIONS.map(|pos| {
</span><span style=color:#86b300>+                                extracted_uinode
</span><span style=color:#86b300>+                                    .transform
</span><span style=color:#86b300>+                                    .transform_point2(glyph.translation + pos * glyph_rect.size())
</span><span style=color:#86b300>+                                    .extend(0.)
</span><span style=color:#86b300>+                            });
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+                            let positions_diff = if let Some(clip) = extracted_uinode.clip {
</span><span>                                 [
</span><span>                                     Vec2::new(
</span><span>                                         f32::max(clip.min.x - positions[0].x, 0.),
</span><span style=color:#c594c5>@@ -1459,91 +1607,47 @@ </span><span style=color:#399ee6>pub fn prepare_uinodes(
</span><span>                                 positions[3] + positions_diff[3].extend(0.),
</span><span>                             ];
</span><span> 
</span><span style=color:#f07171>-                            let points = [
</span><span style=color:#f07171>-                                points[0] + positions_diff[0],
</span><span style=color:#f07171>-                                points[1] + positions_diff[1],
</span><span style=color:#f07171>-                                points[2] + positions_diff[2],
</span><span style=color:#f07171>-                                points[3] + positions_diff[3],
</span><span style=color:#f07171>-                            ];
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            let transformed_rect_size = transform.transform_vector2(rect_size);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            // Don't try to cull nodes that have a rotation
</span><span style=color:#f07171>-                            // In a rotation around the Z-axis, this value is 0.0 for an angle of 0.0 or π
</span><span style=color:#f07171>-                            // In those two cases, the culling check can proceed normally as corners will be on
</span><span style=color:#f07171>-                            // horizontal / vertical lines
</span><span style=color:#f07171>-                            // For all other angles, bypass the culling check
</span><span style=color:#f07171>-                            // This does not properly handles all rotations on all axis
</span><span style=color:#f07171>-                            if transform.x_axis[1] == 0.0 {
</span><span style=color:#f07171>-                                // Cull nodes that are completely clipped
</span><span style=color:#f07171>-                                if positions_diff[0].x - positions_diff[1].x
</span><span style=color:#f07171>-                                    >= transformed_rect_size.x
</span><span style=color:#f07171>-                                    || positions_diff[1].y - positions_diff[2].y
</span><span style=color:#f07171>-                                        >= transformed_rect_size.y
</span><span style=color:#f07171>-                                {
</span><span style=color:#f07171>-                                    continue;
</span><span style=color:#f07171>-                                }
</span><span style=color:#86b300>+                            // cull nodes that are completely clipped
</span><span style=color:#86b300>+                            let transformed_rect_size =
</span><span style=color:#86b300>+                                extracted_uinode.transform.transform_vector2(rect_size);
</span><span style=color:#86b300>+                            if positions_diff[0].x - positions_diff[1].x
</span><span style=color:#86b300>+                                >= transformed_rect_size.x.abs()
</span><span style=color:#86b300>+                                || positions_diff[1].y - positions_diff[2].y
</span><span style=color:#86b300>+                                    >= transformed_rect_size.y.abs()
</span><span style=color:#86b300>+                            {
</span><span style=color:#86b300>+                                continue;
</span><span>                             }
</span><span style=color:#f07171>-                            let uvs = if flags == shader_flags::UNTEXTURED {
</span><span style=color:#f07171>-                                [Vec2::ZERO, Vec2::X, Vec2::ONE, Vec2::Y]
</span><span style=color:#f07171>-                            } else {
</span><span style=color:#f07171>-                                let image = gpu_images.get(extracted_uinode.image).expect(
</span><span style=color:#f07171>-                                    "Image was checked during batching and should still exist",
</span><span style=color:#f07171>-                                );
</span><span style=color:#f07171>-                                // Rescale atlases. This is done here because we need texture data that might not be available in Extract.
</span><span style=color:#f07171>-                                let atlas_extent = atlas_scaling
</span><span style=color:#f07171>-                                    .map(|scaling| image.size_2d().as_vec2() * scaling)
</span><span style=color:#f07171>-                                    .unwrap_or(uinode_rect.max);
</span><span style=color:#f07171>-                                if *flip_x {
</span><span style=color:#f07171>-                                    core::mem::swap(&mut uinode_rect.max.x, &mut uinode_rect.min.x);
</span><span style=color:#f07171>-                                    positions_diff[0].x *= -1.;
</span><span style=color:#f07171>-                                    positions_diff[1].x *= -1.;
</span><span style=color:#f07171>-                                    positions_diff[2].x *= -1.;
</span><span style=color:#f07171>-                                    positions_diff[3].x *= -1.;
</span><span style=color:#f07171>-                                }
</span><span style=color:#f07171>-                                if *flip_y {
</span><span style=color:#f07171>-                                    core::mem::swap(&mut uinode_rect.max.y, &mut uinode_rect.min.y);
</span><span style=color:#f07171>-                                    positions_diff[0].y *= -1.;
</span><span style=color:#f07171>-                                    positions_diff[1].y *= -1.;
</span><span style=color:#f07171>-                                    positions_diff[2].y *= -1.;
</span><span style=color:#f07171>-                                    positions_diff[3].y *= -1.;
</span><span style=color:#f07171>-                                }
</span><span style=color:#f07171>-                                [
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        uinode_rect.min.x + positions_diff[0].x,
</span><span style=color:#f07171>-                                        uinode_rect.min.y + positions_diff[0].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        uinode_rect.max.x + positions_diff[1].x,
</span><span style=color:#f07171>-                                        uinode_rect.min.y + positions_diff[1].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        uinode_rect.max.x + positions_diff[2].x,
</span><span style=color:#f07171>-                                        uinode_rect.max.y + positions_diff[2].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        uinode_rect.min.x + positions_diff[3].x,
</span><span style=color:#f07171>-                                        uinode_rect.max.y + positions_diff[3].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                ]
</span><span style=color:#f07171>-                                .map(|pos| pos / atlas_extent)
</span><span style=color:#f07171>-                            };
</span><span> 
</span><span style=color:#f07171>-                            let color = color.to_f32_array();
</span><span style=color:#f07171>-                            if let NodeType::Border(border_flags) = *node_type {
</span><span style=color:#f07171>-                                flags |= border_flags;
</span><span style=color:#f07171>-                            }
</span><span style=color:#86b300>+                            let uvs = [
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    glyph.rect.min.x + positions_diff[0].x,
</span><span style=color:#86b300>+                                    glyph.rect.min.y + positions_diff[0].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    glyph.rect.max.x + positions_diff[1].x,
</span><span style=color:#86b300>+                                    glyph.rect.min.y + positions_diff[1].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    glyph.rect.max.x + positions_diff[2].x,
</span><span style=color:#86b300>+                                    glyph.rect.max.y + positions_diff[2].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                                Vec2::new(
</span><span style=color:#86b300>+                                    glyph.rect.min.x + positions_diff[3].x,
</span><span style=color:#86b300>+                                    glyph.rect.max.y + positions_diff[3].y,
</span><span style=color:#86b300>+                                ),
</span><span style=color:#86b300>+                            ]
</span><span style=color:#86b300>+                            .map(|pos| pos / atlas_extent);
</span><span> 
</span><span>                             for i in 0..4 {
</span><span>                                 ui_meta.vertices.push(UiVertex {
</span><span>                                     position: positions_clipped[i].into(),
</span><span>                                     uv: uvs[i].into(),
</span><span>                                     color,
</span><span style=color:#f07171>-                                    flags: flags | shader_flags::CORNERS[i],
</span><span style=color:#f07171>-                                    radius: (*border_radius).into(),
</span><span style=color:#f07171>-                                    border: [border.left, border.top, border.right, border.bottom],
</span><span style=color:#86b300>+                                    flags: shader_flags::TEXTURED | shader_flags::CORNERS[i],
</span><span style=color:#86b300>+                                    radius: [0.0; 4],
</span><span style=color:#86b300>+                                    border: [0.0; 4],
</span><span>                                     size: rect_size.into(),
</span><span style=color:#f07171>-                                    point: points[i].into(),
</span><span style=color:#86b300>+                                    point: [0.0; 2],
</span><span>                                 });
</span><span>                             }
</span><span> 
</span><span style=color:#c594c5>@@ -1554,116 +1658,10 @@ </span><span style=color:#399ee6>pub fn prepare_uinodes(
</span><span>                             vertices_index += 6;
</span><span>                             indices_index += 4;
</span><span>                         }
</span><span style=color:#f07171>-                        ExtractedUiItem::Glyphs { range } => {
</span><span style=color:#f07171>-                            let image = gpu_images
</span><span style=color:#f07171>-                                .get(extracted_uinode.image)
</span><span style=color:#f07171>-                                .expect("Image was checked during batching and should still exist");
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            let atlas_extent = image.size_2d().as_vec2();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                            for glyph in &extracted_uinodes.glyphs[range.clone()] {
</span><span style=color:#f07171>-                                let color = glyph.color.to_f32_array();
</span><span style=color:#f07171>-                                let glyph_rect = glyph.rect;
</span><span style=color:#f07171>-                                let rect_size = glyph_rect.size();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                // Specify the corners of the glyph
</span><span style=color:#f07171>-                                let positions = QUAD_VERTEX_POSITIONS.map(|pos| {
</span><span style=color:#f07171>-                                    extracted_uinode
</span><span style=color:#f07171>-                                        .transform
</span><span style=color:#f07171>-                                        .transform_point2(
</span><span style=color:#f07171>-                                            glyph.translation + pos * glyph_rect.size(),
</span><span style=color:#f07171>-                                        )
</span><span style=color:#f07171>-                                        .extend(0.)
</span><span style=color:#f07171>-                                });
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                let positions_diff = if let Some(clip) = extracted_uinode.clip {
</span><span style=color:#f07171>-                                    [
</span><span style=color:#f07171>-                                        Vec2::new(
</span><span style=color:#f07171>-                                            f32::max(clip.min.x - positions[0].x, 0.),
</span><span style=color:#f07171>-                                            f32::max(clip.min.y - positions[0].y, 0.),
</span><span style=color:#f07171>-                                        ),
</span><span style=color:#f07171>-                                        Vec2::new(
</span><span style=color:#f07171>-                                            f32::min(clip.max.x - positions[1].x, 0.),
</span><span style=color:#f07171>-                                            f32::max(clip.min.y - positions[1].y, 0.),
</span><span style=color:#f07171>-                                        ),
</span><span style=color:#f07171>-                                        Vec2::new(
</span><span style=color:#f07171>-                                            f32::min(clip.max.x - positions[2].x, 0.),
</span><span style=color:#f07171>-                                            f32::min(clip.max.y - positions[2].y, 0.),
</span><span style=color:#f07171>-                                        ),
</span><span style=color:#f07171>-                                        Vec2::new(
</span><span style=color:#f07171>-                                            f32::max(clip.min.x - positions[3].x, 0.),
</span><span style=color:#f07171>-                                            f32::min(clip.max.y - positions[3].y, 0.),
</span><span style=color:#f07171>-                                        ),
</span><span style=color:#f07171>-                                    ]
</span><span style=color:#f07171>-                                } else {
</span><span style=color:#f07171>-                                    [Vec2::ZERO; 4]
</span><span style=color:#f07171>-                                };
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                let positions_clipped = [
</span><span style=color:#f07171>-                                    positions[0] + positions_diff[0].extend(0.),
</span><span style=color:#f07171>-                                    positions[1] + positions_diff[1].extend(0.),
</span><span style=color:#f07171>-                                    positions[2] + positions_diff[2].extend(0.),
</span><span style=color:#f07171>-                                    positions[3] + positions_diff[3].extend(0.),
</span><span style=color:#f07171>-                                ];
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                // cull nodes that are completely clipped
</span><span style=color:#f07171>-                                let transformed_rect_size =
</span><span style=color:#f07171>-                                    extracted_uinode.transform.transform_vector2(rect_size);
</span><span style=color:#f07171>-                                if positions_diff[0].x - positions_diff[1].x
</span><span style=color:#f07171>-                                    >= transformed_rect_size.x.abs()
</span><span style=color:#f07171>-                                    || positions_diff[1].y - positions_diff[2].y
</span><span style=color:#f07171>-                                        >= transformed_rect_size.y.abs()
</span><span style=color:#f07171>-                                {
</span><span style=color:#f07171>-                                    continue;
</span><span style=color:#f07171>-                                }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                let uvs = [
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        glyph.rect.min.x + positions_diff[0].x,
</span><span style=color:#f07171>-                                        glyph.rect.min.y + positions_diff[0].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        glyph.rect.max.x + positions_diff[1].x,
</span><span style=color:#f07171>-                                        glyph.rect.min.y + positions_diff[1].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        glyph.rect.max.x + positions_diff[2].x,
</span><span style=color:#f07171>-                                        glyph.rect.max.y + positions_diff[2].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                    Vec2::new(
</span><span style=color:#f07171>-                                        glyph.rect.min.x + positions_diff[3].x,
</span><span style=color:#f07171>-                                        glyph.rect.max.y + positions_diff[3].y,
</span><span style=color:#f07171>-                                    ),
</span><span style=color:#f07171>-                                ]
</span><span style=color:#f07171>-                                .map(|pos| pos / atlas_extent);
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                for i in 0..4 {
</span><span style=color:#f07171>-                                    ui_meta.vertices.push(UiVertex {
</span><span style=color:#f07171>-                                        position: positions_clipped[i].into(),
</span><span style=color:#f07171>-                                        uv: uvs[i].into(),
</span><span style=color:#f07171>-                                        color,
</span><span style=color:#f07171>-                                        flags: shader_flags::TEXTURED | shader_flags::CORNERS[i],
</span><span style=color:#f07171>-                                        radius: [0.0; 4],
</span><span style=color:#f07171>-                                        border: [0.0; 4],
</span><span style=color:#f07171>-                                        size: rect_size.into(),
</span><span style=color:#f07171>-                                        point: [0.0; 2],
</span><span style=color:#f07171>-                                    });
</span><span style=color:#f07171>-                                }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                for &i in &QUAD_INDICES {
</span><span style=color:#f07171>-                                    ui_meta.indices.push(indices_index + i as u32);
</span><span style=color:#f07171>-                                }
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-                                vertices_index += 6;
</span><span style=color:#f07171>-                                indices_index += 4;
</span><span style=color:#f07171>-                            }
</span><span style=color:#f07171>-                        }
</span><span>                     }
</span><span style=color:#f07171>-                    existing_batch.unwrap().1.range.end = vertices_index;
</span><span style=color:#f07171>-                    ui_phase.items[batch_item_index].batch_range_mut().end += 1;
</span><span style=color:#f07171>-                } else {
</span><span style=color:#f07171>-                    batch_image_handle = AssetId::invalid();
</span><span>                 }
</span><span style=color:#86b300>+                existing_batch.unwrap().1.range.end = vertices_index;
</span><span style=color:#86b300>+                ui_phase.items[batch_item_index].batch_range_mut().end += 1;
</span><span>             }
</span><span>         }
</span><span> 
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_20863.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>