<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #21262 Rename "raw" in entity methods into "row"
        
    </title><meta content='#21262 Rename "raw" in entity methods into "row"' property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>‚Üê Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-28</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-09/pr-21262-zh-cn-20250928>‰∏≠Êñá</a></div></div><div class=pr-content><h1 id=title>Title</h1><p>Rename ‚Äúraw‚Äù in entity methods into ‚Äúrow‚Äù<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Rename ‚Äúraw‚Äù in entity methods into ‚Äúrow‚Äù<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/21262<li><strong>Author</strong>: Shatur<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: D-Trivial, A-ECS, C-Usability, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-09-28T20:40:57Z<li><strong>Merged</strong>: 2025-09-28T21:23:15Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>I think ‚Äúraw‚Äù is a leftover from old Entity methods where a raw u32 value was accepted. Since we pass a <em>row</em> now, I think it worth renaming.<h2 id=solution>Solution</h2><ul><li>Adjusted a single letter in 2 methods üòÖ<li>While at it, adjusted the comment about generation since it can be zero since #19121.</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a minor but important naming inconsistency in Bevy‚Äôs Entity API. The issue stemmed from historical naming conventions that no longer accurately reflected the underlying data structures.<p>The core problem was that several Entity methods used the term ‚Äúraw‚Äù in their names, which was a leftover from when these methods accepted raw u32 values directly. However, the current implementation uses an <code>EntityRow</code> type - a newtype wrapper around <code>NonMaxU32</code> that provides additional type safety and clarity. The term ‚Äúraw‚Äù had become misleading because developers were no longer working with raw integers but with structured row identifiers.<p>The solution was straightforward but required careful attention to detail. The developer renamed two key methods:<ul><li><code>from_raw_and_generation</code> became <code>from_row_and_generation</code><li><code>from_raw</code> became <code>from_row</code></ul><p>This change aligns the method names with the actual parameter types and improves API consistency. When developers see <code>from_row_and_generation</code>, they immediately understand they‚Äôre working with an <code>EntityRow</code> rather than a raw integer value.<p>The implementation required updating 55 lines across 4 files, demonstrating how even simple naming changes can have widespread effects in a well-architected codebase. Each change followed the same pattern:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>Entity</span><span style=color:#ed9366>::</span><span>from_raw_and_generation(row</span><span style=color:#61676ccc>,</span><span> generation)
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>Entity</span><span style=color:#ed9366>::</span><span>from_row_and_generation(row</span><span style=color:#61676ccc>,</span><span> generation)
</span></code></pre><p>The developer also took the opportunity to update a comment about entity generation, noting that generation can now be zero since PR #19121. This shows good attention to maintaining accurate documentation alongside code changes.<p>From a technical perspective, this change improves the codebase in several ways:<ol><li><strong>API Consistency</strong>: Method names now accurately reflect parameter types<li><strong>Developer Experience</strong>: New developers can more easily understand what the methods do<li><strong>Type Safety</strong>: The naming reinforces the distinction between raw integers and structured types<li><strong>Documentation</strong>: Updated comments maintain accuracy with current implementation details</ol><p>The changes affect core ECS functionality but don‚Äôt alter any behavior - this is purely a naming improvement. All tests continue to pass, and the API remains backward compatible in terms of functionality, though the method names have changed.<p>This PR demonstrates the importance of maintaining consistent naming conventions as codebases evolve. What started as methods accepting raw integers evolved to use structured types, and the naming needed to evolve accordingly.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph LR
</span><span>    A[Entity Creation] --> B[from_row_and_generation]
</span><span>    A --> C[from_row]
</span><span>    B --> D[EntityRow]
</span><span>    B --> E[EntityGeneration]
</span><span>    C --> D
</span><span>    D --> F[NonMaxU32]
</span><span>    E --> G[u32]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-entity-mod-rs-55-55><code>crates/bevy_ecs/src/entity/mod.rs</code> (+55/-55)</h3><p>This file contains the core Entity implementation and saw the most changes. The main modifications were:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_raw_and_generation</span><span>(</span><span style=color:#ff8f40>row</span><span style=color:#61676ccc>:</span><span> EntityRow, </span><span style=color:#ff8f40>generation</span><span style=color:#61676ccc>:</span><span> EntityGeneration) </span><span style=color:#61676ccc>-></span><span> Entity
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_row_and_generation</span><span>(</span><span style=color:#ff8f40>row</span><span style=color:#61676ccc>:</span><span> EntityRow, </span><span style=color:#ff8f40>generation</span><span style=color:#61676ccc>:</span><span> EntityGeneration) </span><span style=color:#61676ccc>-></span><span> Entity
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_raw</span><span>(</span><span style=color:#ff8f40>row</span><span style=color:#61676ccc>:</span><span> EntityRow) </span><span style=color:#61676ccc>-></span><span> Entity
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_row</span><span>(</span><span style=color:#ff8f40>row</span><span style=color:#61676ccc>:</span><span> EntityRow) </span><span style=color:#61676ccc>-></span><span> Entity
</span></code></pre><p>The changes propagated through the entire file, updating all method calls and test cases to use the new names.<h3 id=crates-bevy-ecs-src-storage-sparse-set-rs-5-5><code>crates/bevy_ecs/src/storage/sparse_set.rs</code> (+5/-5)</h3><p>Updated test cases to use the new method names:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> e0 </span><span style=color:#ed9366>= </span><span>Entity</span><span style=color:#ed9366>::</span><span>from_raw(EntityRow</span><span style=color:#ed9366>::</span><span>from_raw_u32(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>())</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> e0 </span><span style=color:#ed9366>= </span><span>Entity</span><span style=color:#ed9366>::</span><span>from_row(EntityRow</span><span style=color:#ed9366>::</span><span>from_raw_u32(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>())</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ecs-src-entity-map-entities-rs-1-1><code>crates/bevy_ecs/src/entity/map_entities.rs</code> (+1/-1)</h3><p>Updated entity mapping logic:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>let</span><span> new </span><span style=color:#ed9366>= </span><span>Entity</span><span style=color:#ed9366>::</span><span>from_raw_and_generation(
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>let</span><span> new </span><span style=color:#ed9366>= </span><span>Entity</span><span style=color:#ed9366>::</span><span>from_row_and_generation(
</span></code></pre><h3 id=crates-bevy-ecs-src-storage-table-mod-rs-1-1><code>crates/bevy_ecs/src/storage/table/mod.rs</code> (+1/-1)</h3><p>Updated table storage tests:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>index</span><span>| Entity</span><span style=color:#ed9366>::</span><span>from_raw(EntityRow</span><span style=color:#ed9366>::</span><span>from_raw_u32(index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()))
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>index</span><span>| Entity</span><span style=color:#ed9366>::</span><span>from_row(EntityRow</span><span style=color:#ed9366>::</span><span>from_raw_u32(index)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()))
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/ target=_blank>Bevy ECS Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Entity_component_system target=_blank>Entity Component System Pattern</a><li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/api-guidelines/naming.html target=_blank>Rust API Guidelines - Naming</a></ul><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_ecs/src/entity/map_entities.rs b/crates/bevy_ecs/src/entity/map_entities.rs
</span><span>index 2c596552757f0..0ac3ed52fd676 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/entity/map_entities.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/entity/map_entities.rs
</span><span style=color:#c594c5>@@ -276,7 +276,7 @@ </span><span style=color:#399ee6>impl EntityMapper for SceneEntityMapper<'_> {
</span><span>         }
</span><span> 
</span><span>         // this new entity reference is specifically designed to never represent any living entity
</span><span style=color:#f07171>-        let new = Entity::from_raw_and_generation(
</span><span style=color:#86b300>+        let new = Entity::from_row_and_generation(
</span><span>             self.dead_start.row(),
</span><span>             self.dead_start.generation.after_versions(self.generations),
</span><span>         );
</span><span>diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs
</span><span>index 55b8ae19434ef..3e0ee0a813492 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/entity/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/entity/mod.rs
</span><span style=color:#c594c5>@@ -455,9 +455,9 @@ </span><span style=color:#399ee6>impl Hash for Entity {
</span><span> }
</span><span> 
</span><span> impl Entity {
</span><span style=color:#f07171>-    /// Constructs an [`Entity`] from a raw `row` value and a non-zero `generation` value.
</span><span style=color:#86b300>+    /// Creates a new instance with the given index and generation.
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub const fn from_raw_and_generation(row: EntityRow, generation: EntityGeneration) -> Entity {
</span><span style=color:#86b300>+    pub const fn from_row_and_generation(row: EntityRow, generation: EntityGeneration) -> Entity {
</span><span>         Self { row, generation }
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -495,7 +495,7 @@ </span><span style=color:#399ee6>impl Entity {
</span><span>     ///     }
</span><span>     /// }
</span><span>     /// ```
</span><span style=color:#f07171>-    pub const PLACEHOLDER: Self = Self::from_raw(EntityRow::PLACEHOLDER);
</span><span style=color:#86b300>+    pub const PLACEHOLDER: Self = Self::from_row(EntityRow::PLACEHOLDER);
</span><span> 
</span><span>     /// Creates a new entity ID with the specified `row` and a generation of 1.
</span><span>     ///
</span><span style=color:#c594c5>@@ -510,17 +510,17 @@ </span><span style=color:#399ee6>impl Entity {
</span><span>     /// `Entity` lines up between instances, but instead insert a secondary identifier as
</span><span>     /// a component.
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub const fn from_raw(row: EntityRow) -> Entity {
</span><span style=color:#f07171>-        Self::from_raw_and_generation(row, EntityGeneration::FIRST)
</span><span style=color:#86b300>+    pub const fn from_row(row: EntityRow) -> Entity {
</span><span style=color:#86b300>+        Self::from_row_and_generation(row, EntityGeneration::FIRST)
</span><span>     }
</span><span> 
</span><span style=color:#f07171>-    /// This is equivalent to [`from_raw`](Self::from_raw) except that it takes a `u32` instead of an [`EntityRow`].
</span><span style=color:#86b300>+    /// This is equivalent to [`from_row`](Self::from_row) except that it takes a `u32` instead of an [`EntityRow`].
</span><span>     ///
</span><span>     /// Returns `None` if the row is `u32::MAX`.
</span><span>     #[inline(always)]
</span><span>     pub const fn from_raw_u32(row: u32) -> Option&LTEntity> {
</span><span>         match NonMaxU32::new(row) {
</span><span style=color:#f07171>-            Some(row) => Some(Self::from_raw(EntityRow::new(row))),
</span><span style=color:#86b300>+            Some(row) => Some(Self::from_row(EntityRow::new(row))),
</span><span>             None => None,
</span><span>         }
</span><span>     }
</span><span style=color:#c594c5>@@ -657,7 +657,7 @@ </span><span style=color:#399ee6>impl SparseSetIndex for Entity {
</span><span> 
</span><span>     #[inline]
</span><span>     fn get_sparse_set_index(value: usize) -> Self {
</span><span style=color:#f07171>-        Entity::from_raw(EntityRow::get_sparse_set_index(value))
</span><span style=color:#86b300>+        Entity::from_row(EntityRow::get_sparse_set_index(value))
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#c594c5>@@ -680,13 +680,13 @@ </span><span style=color:#399ee6>impl<'a> Iterator for ReserveEntitiesIterator<'a> {
</span><span>         self.freelist_indices
</span><span>             .next()
</span><span>             .map(|&row| {
</span><span style=color:#f07171>-                Entity::from_raw_and_generation(row, self.meta[row.index() as usize].generation)
</span><span style=color:#86b300>+                Entity::from_row_and_generation(row, self.meta[row.index() as usize].generation)
</span><span>             })
</span><span>             .or_else(|| {
</span><span>                 self.new_indices.next().map(|index| {
</span><span>                     // SAFETY: This came from an exclusive range so the max can't be hit.
</span><span>                     let row = unsafe { EntityRow::new(NonMaxU32::new_unchecked(index)) };
</span><span style=color:#f07171>-                    Entity::from_raw(row)
</span><span style=color:#86b300>+                    Entity::from_row(row)
</span><span>                 })
</span><span>             })
</span><span>     }
</span><span style=color:#c594c5>@@ -833,7 +833,7 @@ </span><span style=color:#399ee6>impl Entities {
</span><span>         if n > 0 {
</span><span>             // Allocate from the freelist.
</span><span>             let row = self.pending[(n - 1) as usize];
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(row, self.meta[row.index() as usize].generation)
</span><span style=color:#86b300>+            Entity::from_row_and_generation(row, self.meta[row.index() as usize].generation)
</span><span>         } else {
</span><span>             // Grab a new ID, outside the range of `meta.len()`. `flush()` must
</span><span>             // eventually be called to make it valid.
</span><span style=color:#c594c5>@@ -846,7 +846,7 @@ </span><span style=color:#399ee6>impl Entities {
</span><span>             }
</span><span>             // SAFETY: We just checked the bounds
</span><span>             let row = unsafe { EntityRow::new(NonMaxU32::new_unchecked(raw as u32)) };
</span><span style=color:#f07171>-            Entity::from_raw(row)
</span><span style=color:#86b300>+            Entity::from_row(row)
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -864,14 +864,14 @@ </span><span style=color:#399ee6>impl Entities {
</span><span>         if let Some(row) = self.pending.pop() {
</span><span>             let new_free_cursor = self.pending.len() as IdCursor;
</span><span>             *self.free_cursor.get_mut() = new_free_cursor;
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(row, self.meta[row.index() as usize].generation)
</span><span style=color:#86b300>+            Entity::from_row_and_generation(row, self.meta[row.index() as usize].generation)
</span><span>         } else {
</span><span>             let index = u32::try_from(self.meta.len())
</span><span>                 .ok()
</span><span>                 .and_then(NonMaxU32::new)
</span><span>                 .expect("too many entities");
</span><span>             self.meta.push(EntityMeta::EMPTY);
</span><span style=color:#f07171>-            Entity::from_raw(EntityRow::new(index))
</span><span style=color:#86b300>+            Entity::from_row(EntityRow::new(index))
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -1012,14 +1012,14 @@ </span><span style=color:#399ee6>impl Entities {
</span><span>     pub fn resolve_from_id(&self, row: EntityRow) -> Option&LTEntity> {
</span><span>         let idu = row.index() as usize;
</span><span>         if let Some(&EntityMeta { generation, .. }) = self.meta.get(idu) {
</span><span style=color:#f07171>-            Some(Entity::from_raw_and_generation(row, generation))
</span><span style=color:#86b300>+            Some(Entity::from_row_and_generation(row, generation))
</span><span>         } else {
</span><span>             // `id` is outside of the meta list - check whether it is reserved but not yet flushed.
</span><span>             let free_cursor = self.free_cursor.load(Ordering::Relaxed);
</span><span>             // If this entity was manually created, then free_cursor might be positive
</span><span>             // Returning None handles that case correctly
</span><span>             let num_pending = usize::try_from(-free_cursor).ok()?;
</span><span style=color:#f07171>-            (idu < self.meta.len() + num_pending).then_some(Entity::from_raw(row))
</span><span style=color:#86b300>+            (idu < self.meta.len() + num_pending).then_some(Entity::from_row(row))
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -1058,7 +1058,7 @@ </span><span style=color:#399ee6>impl Entities {
</span><span>                 // SAFETY: the index is less than the meta length, which can not exceeded u32::MAX
</span><span>                 let row = EntityRow::new(unsafe { NonMaxU32::new_unchecked(index as u32) });
</span><span>                 init(
</span><span style=color:#f07171>-                    Entity::from_raw_and_generation(row, meta.generation),
</span><span style=color:#86b300>+                    Entity::from_row_and_generation(row, meta.generation),
</span><span>                     &mut meta.location,
</span><span>                 );
</span><span>                 meta.spawned_or_despawned = SpawnedOrDespawned { by, tick };
</span><span style=color:#c594c5>@@ -1071,7 +1071,7 @@ </span><span style=color:#399ee6>impl Entities {
</span><span>         for row in self.pending.drain(new_free_cursor..) {
</span><span>             let meta = &mut self.meta[row.index() as usize];
</span><span>             init(
</span><span style=color:#f07171>-                Entity::from_raw_and_generation(row, meta.generation),
</span><span style=color:#86b300>+                Entity::from_row_and_generation(row, meta.generation),
</span><span>                 &mut meta.location,
</span><span>             );
</span><span>             meta.spawned_or_despawned = SpawnedOrDespawned { by, tick };
</span><span style=color:#c594c5>@@ -1333,7 +1333,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         let r = EntityRow::from_raw_u32(0xDEADBEEF).unwrap();
</span><span>         assert_eq!(EntityRow::from_bits(r.to_bits()), r);
</span><span> 
</span><span style=color:#f07171>-        let e = Entity::from_raw_and_generation(
</span><span style=color:#86b300>+        let e = Entity::from_row_and_generation(
</span><span>             EntityRow::from_raw_u32(0xDEADBEEF).unwrap(),
</span><span>             EntityGeneration::from_bits(0x5AADF00D),
</span><span>         );
</span><span style=color:#c594c5>@@ -1373,7 +1373,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span> 
</span><span>     #[test]
</span><span>     fn entity_const() {
</span><span style=color:#f07171>-        const C1: Entity = Entity::from_raw(EntityRow::from_raw_u32(42).unwrap());
</span><span style=color:#86b300>+        const C1: Entity = Entity::from_row(EntityRow::from_raw_u32(42).unwrap());
</span><span>         assert_eq!(42, C1.index());
</span><span>         assert_eq!(0, C1.generation().to_bits());
</span><span> 
</span><span style=color:#c594c5>@@ -1381,7 +1381,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         assert_eq!(!0x0000_00cc, C2.index());
</span><span>         assert_eq!(0x0000_00ff, C2.generation().to_bits());
</span><span> 
</span><span style=color:#f07171>-        const C3: u32 = Entity::from_raw(EntityRow::from_raw_u32(33).unwrap()).index();
</span><span style=color:#86b300>+        const C3: u32 = Entity::from_row(EntityRow::from_raw_u32(33).unwrap()).index();
</span><span>         assert_eq!(33, C3);
</span><span> 
</span><span>         const C4: u32 = Entity::from_bits(0x00dd_00ff_1111_1111)
</span><span style=color:#c594c5>@@ -1425,41 +1425,41 @@ </span><span style=color:#399ee6>mod tests {
</span><span>     )]
</span><span>     fn entity_comparison() {
</span><span>         assert_eq!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             ),
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             )
</span><span>         );
</span><span>         assert_ne!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(789)
</span><span>             ),
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             )
</span><span>         );
</span><span>         assert_ne!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             ),
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(789)
</span><span>             )
</span><span>         );
</span><span>         assert_ne!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             ),
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(456).unwrap(),
</span><span>                 EntityGeneration::from_bits(123)
</span><span>             )
</span><span style=color:#c594c5>@@ -1468,93 +1468,93 @@ </span><span style=color:#399ee6>mod tests {
</span><span>         // ordering is by generation then by index
</span><span> 
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span style=color:#f07171>-            ) >= Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) >= Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             )
</span><span>         );
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span style=color:#f07171>-            ) <= Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) <= Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             )
</span><span>         );
</span><span>         assert!(
</span><span style=color:#f07171>-            !(Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            !(Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span style=color:#f07171>-            ) < Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) < Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             ))
</span><span>         );
</span><span>         assert!(
</span><span style=color:#f07171>-            !(Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            !(Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span style=color:#f07171>-            ) > Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) > Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(123).unwrap(),
</span><span>                 EntityGeneration::from_bits(456)
</span><span>             ))
</span><span>         );
</span><span> 
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(9).unwrap(),
</span><span>                 EntityGeneration::from_bits(1)
</span><span style=color:#f07171>-            ) < Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) < Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(1).unwrap(),
</span><span>                 EntityGeneration::from_bits(9)
</span><span>             )
</span><span>         );
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(1).unwrap(),
</span><span>                 EntityGeneration::from_bits(9)
</span><span style=color:#f07171>-            ) > Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) > Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(9).unwrap(),
</span><span>                 EntityGeneration::from_bits(1)
</span><span>             )
</span><span>         );
</span><span> 
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(1).unwrap(),
</span><span>                 EntityGeneration::from_bits(1)
</span><span style=color:#f07171>-            ) > Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) > Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(2).unwrap(),
</span><span>                 EntityGeneration::from_bits(1)
</span><span>             )
</span><span>         );
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(1).unwrap(),
</span><span>                 EntityGeneration::from_bits(1)
</span><span style=color:#f07171>-            ) >= Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) >= Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(2).unwrap(),
</span><span>                 EntityGeneration::from_bits(1)
</span><span>             )
</span><span>         );
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(2).unwrap(),
</span><span>                 EntityGeneration::from_bits(2)
</span><span style=color:#f07171>-            ) < Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) < Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(1).unwrap(),
</span><span>                 EntityGeneration::from_bits(2)
</span><span>             )
</span><span>         );
</span><span>         assert!(
</span><span style=color:#f07171>-            Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(2).unwrap(),
</span><span>                 EntityGeneration::from_bits(2)
</span><span style=color:#f07171>-            ) <= Entity::from_raw_and_generation(
</span><span style=color:#86b300>+            ) <= Entity::from_row_and_generation(
</span><span>                 EntityRow::from_raw_u32(1).unwrap(),
</span><span>                 EntityGeneration::from_bits(2)
</span><span>             )
</span><span style=color:#c594c5>@@ -1570,11 +1570,11 @@ </span><span style=color:#399ee6>mod tests {
</span><span> 
</span><span>         let first_id = 0xC0FFEE << 8;
</span><span>         let first_hash =
</span><span style=color:#f07171>-            hash.hash_one(Entity::from_raw(EntityRow::from_raw_u32(first_id).unwrap()));
</span><span style=color:#86b300>+            hash.hash_one(Entity::from_row(EntityRow::from_raw_u32(first_id).unwrap()));
</span><span> 
</span><span>         for i in 1..=255 {
</span><span>             let id = first_id + i;
</span><span style=color:#f07171>-            let hash = hash.hash_one(Entity::from_raw(EntityRow::from_raw_u32(id).unwrap()));
</span><span style=color:#86b300>+            let hash = hash.hash_one(Entity::from_row(EntityRow::from_raw_u32(id).unwrap()));
</span><span>             assert_eq!(first_hash.wrapping_sub(hash) as u32, i);
</span><span>         }
</span><span>     }
</span><span style=color:#c594c5>@@ -1587,11 +1587,11 @@ </span><span style=color:#399ee6>mod tests {
</span><span> 
</span><span>         let first_id = 0xC0FFEE;
</span><span>         let first_hash =
</span><span style=color:#f07171>-            hash.hash_one(Entity::from_raw(EntityRow::from_raw_u32(first_id).unwrap())) >> 57;
</span><span style=color:#86b300>+            hash.hash_one(Entity::from_row(EntityRow::from_raw_u32(first_id).unwrap())) >> 57;
</span><span> 
</span><span>         for bit in 0..u32::BITS {
</span><span>             let id = first_id ^ (1 << bit);
</span><span style=color:#f07171>-            let hash = hash.hash_one(Entity::from_raw(EntityRow::from_raw_u32(id).unwrap())) >> 57;
</span><span style=color:#86b300>+            let hash = hash.hash_one(Entity::from_row(EntityRow::from_raw_u32(id).unwrap())) >> 57;
</span><span>             assert_ne!(hash, first_hash);
</span><span>         }
</span><span>     }
</span><span style=color:#c594c5>@@ -1616,7 +1616,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span> 
</span><span>     #[test]
</span><span>     fn entity_debug() {
</span><span style=color:#f07171>-        let entity = Entity::from_raw(EntityRow::from_raw_u32(42).unwrap());
</span><span style=color:#86b300>+        let entity = Entity::from_row(EntityRow::from_raw_u32(42).unwrap());
</span><span>         let string = format!("{entity:?}");
</span><span>         assert_eq!(string, "42v0");
</span><span> 
</span><span style=color:#c594c5>@@ -1627,7 +1627,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span> 
</span><span>     #[test]
</span><span>     fn entity_display() {
</span><span style=color:#f07171>-        let entity = Entity::from_raw(EntityRow::from_raw_u32(42).unwrap());
</span><span style=color:#86b300>+        let entity = Entity::from_row(EntityRow::from_raw_u32(42).unwrap());
</span><span>         let string = format!("{entity}");
</span><span>         assert_eq!(string, "42v0");
</span><span> 
</span><span>diff --git a/crates/bevy_ecs/src/storage/sparse_set.rs b/crates/bevy_ecs/src/storage/sparse_set.rs
</span><span>index ffc2aff0d6248..cda28c1597a01 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/storage/sparse_set.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/storage/sparse_set.rs
</span><span style=color:#c594c5>@@ -673,11 +673,11 @@ </span><span style=color:#399ee6>mod tests {
</span><span>     #[test]
</span><span>     fn sparse_set() {
</span><span>         let mut set = SparseSet::&LTEntity, Foo>::default();
</span><span style=color:#f07171>-        let e0 = Entity::from_raw(EntityRow::from_raw_u32(0).unwrap());
</span><span style=color:#f07171>-        let e1 = Entity::from_raw(EntityRow::from_raw_u32(1).unwrap());
</span><span style=color:#f07171>-        let e2 = Entity::from_raw(EntityRow::from_raw_u32(2).unwrap());
</span><span style=color:#f07171>-        let e3 = Entity::from_raw(EntityRow::from_raw_u32(3).unwrap());
</span><span style=color:#f07171>-        let e4 = Entity::from_raw(EntityRow::from_raw_u32(4).unwrap());
</span><span style=color:#86b300>+        let e0 = Entity::from_row(EntityRow::from_raw_u32(0).unwrap());
</span><span style=color:#86b300>+        let e1 = Entity::from_row(EntityRow::from_raw_u32(1).unwrap());
</span><span style=color:#86b300>+        let e2 = Entity::from_row(EntityRow::from_raw_u32(2).unwrap());
</span><span style=color:#86b300>+        let e3 = Entity::from_row(EntityRow::from_raw_u32(3).unwrap());
</span><span style=color:#86b300>+        let e4 = Entity::from_row(EntityRow::from_raw_u32(4).unwrap());
</span><span> 
</span><span>         set.insert(e1, Foo(1));
</span><span>         set.insert(e2, Foo(2));
</span><span>diff --git a/crates/bevy_ecs/src/storage/table/mod.rs b/crates/bevy_ecs/src/storage/table/mod.rs
</span><span>index 5698481060b1b..90c1027233232 100644
</span><span style=color:#c594c5>--- a/crates/bevy_ecs/src/storage/table/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_ecs/src/storage/table/mod.rs
</span><span style=color:#c594c5>@@ -888,7 +888,7 @@ </span><span style=color:#399ee6>mod tests {
</span><span>             .add_column(components.get_info(component_id).unwrap())
</span><span>             .build();
</span><span>         let entities = (0..200)
</span><span style=color:#f07171>-            .map(|index| Entity::from_raw(EntityRow::from_raw_u32(index).unwrap()))
</span><span style=color:#86b300>+            .map(|index| Entity::from_row(EntityRow::from_raw_u32(index).unwrap()))
</span><span>             .collect::&LTVec<_>>();
</span><span>         for entity in &entities {
</span><span>             // SAFETY: we allocate and immediately set data afterwards
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_21262.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>