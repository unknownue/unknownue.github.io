diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs
index f55c2fb75a90e..534359801eb23 100644
--- a/crates/bevy_asset/src/server/mod.rs
+++ b/crates/bevy_asset/src/server/mod.rs
@@ -1702,12 +1702,10 @@ pub fn handle_internal_asset_events(world: &mut World) {
             }
         }
 
-        let reload_parent_folders = |path: PathBuf, source: &AssetSourceId<'static>| {
-            let mut current_folder = path;
-            while let Some(parent) = current_folder.parent() {
-                current_folder = parent.to_path_buf();
+        let reload_parent_folders = |path: &PathBuf, source: &AssetSourceId<'static>| {
+            for parent in path.ancestors().skip(1) {
                 let parent_asset_path =
-                    AssetPath::from(current_folder.clone()).with_source(source.clone());
+                    AssetPath::from(parent.to_path_buf()).with_source(source.clone());
                 for folder_handle in infos.get_path_handles(&parent_asset_path) {
                     info!("Reloading folder {parent_asset_path} because the content has changed");
                     server.load_folder_internal(folder_handle.id(), parent_asset_path.clone());
@@ -1716,24 +1714,31 @@ pub fn handle_internal_asset_events(world: &mut World) {
         };
 
         let mut paths_to_reload = <HashSet<_>>::default();
+        let mut reload_path = |path: PathBuf, source: &AssetSourceId<'static>| {
+            let path = AssetPath::from(path).with_source(source);
+            queue_ancestors(&path, &infos, &mut paths_to_reload);
+            paths_to_reload.insert(path);
+        };
+
         let mut handle_event = |source: AssetSourceId<'static>, event: AssetSourceEvent| {
             match event {
+                AssetSourceEvent::AddedAsset(path) => {
+                    reload_parent_folders(&path, &source);
+                    reload_path(path, &source);
+                }
                 // TODO: if the asset was processed and the processed file was changed, the first modified event
                 // should be skipped?
                 AssetSourceEvent::ModifiedAsset(path) | AssetSourceEvent::ModifiedMeta(path) => {
-                    let path = AssetPath::from(path).with_source(source);
-                    queue_ancestors(&path, &infos, &mut paths_to_reload);
-                    paths_to_reload.insert(path);
+                    reload_path(path, &source);
                 }
                 AssetSourceEvent::RenamedFolder { old, new } => {
-                    reload_parent_folders(old, &source);
-                    reload_parent_folders(new, &source);
+                    reload_parent_folders(&old, &source);
+                    reload_parent_folders(&new, &source);
                 }
-                AssetSourceEvent::AddedAsset(path)
-                | AssetSourceEvent::RemovedAsset(path)
+                AssetSourceEvent::RemovedAsset(path)
                 | AssetSourceEvent::RemovedFolder(path)
                 | AssetSourceEvent::AddedFolder(path) => {
-                    reload_parent_folders(path, &source);
+                    reload_parent_folders(&path, &source);
                 }
                 _ => {}
             }
