<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20870 UI stack partition
        
    </title><meta content="#20870 UI stack partition" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-30</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-09/pr-20870-zh-cn-20250930>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: UI stack partition<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20870<li><strong>Author</strong>: ickshonpe<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Performance, A-UI, C-Code-Quality, S-Ready-For-Final-Review, D-Modest, A-Picking<li><strong>Created</strong>: 2025-09-04T19:53:45Z<li><strong>Merged</strong>: 2025-09-29T23:01:05Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>In the UI picking and rendering systems, we first query for all the pickable or renderable UI nodes and then query per node for the details of the camera and its render target. But the typical application using Bevy UI will have hundreds of UI nodes and just one UI camera, so this is extremely inefficient.<p>Instead, we can partition the UI stack into disjoint slices where all the UI nodes in each slice have the same camera target. Then perform any camera and render target lookups per slice, instead of per node.<h2 id=solution>Solution</h2><p>Partition the UI stack into disjoint layers of nodes sharing the same camera target.<ul><li>Add a <code>partition: Vec&LTRange&LTusize>></code> field to <code>UiStack</code>.<li>Update the partitions in <code>ui_stack_system</code>.<li>Query for cameras per slice in <code>ui_focus_system</code> and <code>ui_picking</code>.</ul><p>Splitting the rendering changes off into their own PR.<hr><h2 id=testing>Testing</h2><p>Some basic checks have been added to the existing <code>test_ui_stack_system</code> and <code>test_with_equal_global_zindex_zindex_decides_order</code> tests.<p>Examples like <code>ui_target_camera</code>, <code>viewport_node</code> and <code>ui_drag_and_drop</code> can be used to test the changes.<h2 id=showcase>Showcase</h2><p>yellow this PR, red main:<p><code>cargo run --example many_buttons --release --features bevy/trace_tracy</code><p><code>ui_picking</code> <img alt=ui_picking src=https://github.com/user-attachments/assets/a0e37205-dcb4-4228-8379-7d3fa4ea6adf width=500><p><code>ui_stack_system</code> <img alt=ui_stack src=https://github.com/user-attachments/assets/7e5487b8-9dc4-4db8-ac0e-04cc162cc420 width=500><hr><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a fundamental performance bottleneck in Bevy’s UI system. The core issue was that UI picking and focus systems were performing camera lookups for every individual UI node, despite most applications having only one UI camera. With hundreds of UI nodes, this resulted in significant redundant work.<p>The solution introduces a partitioning strategy for the UI stack. The key insight is that UI nodes can be grouped into slices where all nodes within a slice share the same camera target. This allows camera lookups to be performed once per slice rather than once per node.<p>The implementation follows a clear three-step approach:<ol><li><strong>Data Structure Enhancement</strong>: Added a <code>partition</code> field to the <code>UiStack</code> resource that tracks ranges of nodes sharing the same camera target<li><strong>Partition Building</strong>: Modified <code>ui_stack_system</code> to construct these partitions while building the UI stack<li><strong>System Optimization</strong>: Updated <code>ui_focus_system</code> and <code>ui_picking</code> to leverage the partitions for efficient camera lookups</ol><p>The performance improvements are substantial, as shown in the provided Tracy profiles. The <code>ui_picking</code> system shows significantly reduced execution time (yellow vs red), and <code>ui_stack_system</code> also benefits from the optimized data structure.<p>From an architectural perspective, this change maintains backward compatibility while enabling significant performance gains. The partition information is computed once and reused across multiple systems, demonstrating good data-oriented design principles.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[ui_stack_system] --> B[UiStack Resource]
</span><span>    B --> C[partition: Vec&LTRange&LTusize>>]
</span><span>    B --> D[uinodes: Vec&LTEntity>]
</span><span>    C --> E[ui_focus_system]
</span><span>    C --> F[ui_picking system]
</span><span>    E --> G[Camera lookups per slice]
</span><span>    F --> G
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ui-src-stack-rs-35-3><code>crates/bevy_ui/src/stack.rs</code> (+35/-3)</h3><p>This file introduces the core partitioning mechanism to the UI stack system.<p><strong>Key Changes:</strong><ul><li>Added <code>partition: Vec&LTRange&LTusize>></code> field to <code>UiStack</code> struct<li>Modified <code>ui_stack_system</code> to track and populate partition ranges<li>Enhanced tests to verify partition correctness</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Resource</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>UiStack </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>uinodes</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTEntity>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> Resource</span><span style=color:#61676ccc>,</span><span> Default)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>UiStack </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Partition of the `uinodes` list into disjoint slices of nodes that all share the same camera target.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>partition</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTRange<</span><span style=color:#fa6e32>usize</span><span>>>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// List of UI nodes ordered from back-to-front
</span><span>    </span><span style=color:#fa6e32>pub </span><span>uinodes</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTEntity>,
</span><span>}
</span></code></pre><p>The system now tracks partition boundaries when processing root nodes:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>for </span><span>(root_entity</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>_</span><span>) </span><span style=color:#ed9366>in</span><span> root_nodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>drain</span><span>(</span><span style=color:#ed9366>..</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> start </span><span style=color:#ed9366>=</span><span> ui_stack</span><span style=color:#ed9366>.</span><span>uinodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>update_uistack_recursive</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> cache</span><span style=color:#61676ccc>,
</span><span>        root_entity</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>&</span><span>children_query</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>&</span><span>zindex_query</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> ui_stack</span><span style=color:#ed9366>.</span><span>uinodes</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> end </span><span style=color:#ed9366>=</span><span> ui_stack</span><span style=color:#ed9366>.</span><span>uinodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()</span><span style=color:#61676ccc>;
</span><span>    ui_stack</span><span style=color:#ed9366>.</span><span>partition</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(start</span><span style=color:#ed9366>..</span><span>end)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-ui-src-focus-rs-35-19><code>crates/bevy_ui/src/focus.rs</code> (+35/-19)</h3><p>This file optimizes the focus system to use partition-based camera lookups.<p><strong>Key Changes:</strong><ul><li>Added local <code>hovered_nodes</code> vector to reduce allocations<li>Restructured iteration to process nodes by partition slices<li>Performs camera lookup once per slice instead of per node</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Camera lookup per node
</span><span style=color:#fa6e32>let mut</span><span> hovered_nodes </span><span style=color:#ed9366>=</span><span> ui_stack
</span><span>    </span><span style=color:#ed9366>.</span><span>uinodes
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>()
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter_map</span><span>(|</span><span style=color:#ff8f40>entity</span><span>| {
</span><span>        </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(node) </span><span style=color:#ed9366>=</span><span> node_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(</span><span style=color:#ed9366>*</span><span>entity) </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>; </span><span>}</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> camera_entity </span><span style=color:#ed9366>=</span><span> node</span><span style=color:#ed9366>.</span><span>target_camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>()</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... cursor position and hit testing
</span><span>    })
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Camera lookup per partition slice
</span><span style=color:#fa6e32>for</span><span> uinodes </span><span style=color:#ed9366>in</span><span> ui_stack</span><span style=color:#ed9366>.</span><span>partition</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>range</span><span>| </span><span style=color:#ed9366>&</span><span>ui_stack</span><span style=color:#ed9366>.</span><span>uinodes[range</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()]) {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(root_node) </span><span style=color:#ed9366>=</span><span> node_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_mut</span><span>(uinodes[</span><span style=color:#ff8f40>0</span><span>]) </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>; </span><span>}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(camera_entity) </span><span style=color:#ed9366>=</span><span> root_node</span><span style=color:#ed9366>.</span><span>target_camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>() </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>; </span><span>}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> cursor_position </span><span style=color:#ed9366>=</span><span> camera_cursor_positions</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>camera_entity)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>for</span><span> entity </span><span style=color:#ed9366>in</span><span> uinodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>() {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... use pre-computed cursor_position for all nodes in slice
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-ui-src-picking-backend-rs-53-41><code>crates/bevy_ui/src/picking_backend.rs</code> (+53/-41)</h3><p>This file applies the same optimization pattern to the UI picking system.<p><strong>Key Changes:</strong><ul><li>Restructured nested loops to iterate by partition slices first, then nodes<li>Moved camera lookup outside the inner node loop<li>Maintains the same picking logic but with optimized camera queries</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before: Camera lookup in inner node loop
</span><span style=color:#fa6e32>for</span><span> node_entity </span><span style=color:#ed9366>in</span><span> ui_stack</span><span style=color:#ed9366>.</span><span>uinodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(node) </span><span style=color:#ed9366>=</span><span> node_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>*</span><span>node_entity) </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>; </span><span>}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(camera_entity) </span><span style=color:#ed9366>=</span><span> node</span><span style=color:#ed9366>.</span><span>target_camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>() </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>; </span><span>}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ... pointer position and hit testing
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After: Camera lookup per partition slice
</span><span style=color:#fa6e32>for</span><span> uinodes </span><span style=color:#ed9366>in</span><span> ui_stack</span><span style=color:#ed9366>.</span><span>partition</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>range</span><span>| </span><span style=color:#ed9366>&</span><span>ui_stack</span><span style=color:#ed9366>.</span><span>uinodes[range</span><span style=color:#ed9366>.</span><span style=color:#f07171>clone</span><span>()]) {
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(uinode) </span><span style=color:#ed9366>=</span><span> node_query</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(uinodes[</span><span style=color:#ff8f40>0</span><span>]) </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>; </span><span>}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(camera_entity) </span><span style=color:#ed9366>=</span><span> uinode</span><span style=color:#ed9366>.</span><span>target_camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>() </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>; </span><span>}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> pointers_on_this_cam </span><span style=color:#ed9366>=</span><span> pointer_pos_by_camera</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>(</span><span style=color:#ed9366>&</span><span>camera_entity)</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>for</span><span> node_entity </span><span style=color:#ed9366>in</span><span> uinodes</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>rev</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>cloned</span><span>() {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ... use pre-computed pointers_on_this_cam for all nodes in slice
</span><span>    }
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_ui/latest/bevy_ui/ target=_blank>Bevy UI System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://gamesfromwithin.com/data-oriented-design target=_blank>Data-Oriented Design Principles</a><li><a rel="noopener nofollow noreferrer" href=https://bevy-cheatbook.github.io/programming/ecs-intro.html target=_blank>ECS Performance Optimization Patterns</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/std/ops/struct.Range.html target=_blank>Rust Range Type Documentation</a></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_20870.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>