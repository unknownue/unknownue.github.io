diff --git a/crates/bevy_ecs/src/error/handler.rs b/crates/bevy_ecs/src/error/handler.rs
index 85a5a13297d22..f5a4f9f9b9886 100644
--- a/crates/bevy_ecs/src/error/handler.rs
+++ b/crates/bevy_ecs/src/error/handler.rs
@@ -20,6 +20,10 @@ pub enum ErrorContext {
         name: DebugName,
         /// The last tick that the run condition was evaluated.
         last_run: Tick,
+        /// The system this run condition is attached to.
+        system: DebugName,
+        /// `true` if this run condition was on a set.
+        on_set: bool,
     },
     /// The error occurred in a command.
     Command {
@@ -45,8 +49,17 @@ impl Display for ErrorContext {
             Self::Observer { name, .. } => {
                 write!(f, "Observer `{name}` failed")
             }
-            Self::RunCondition { name, .. } => {
-                write!(f, "Run condition `{name}` failed")
+            Self::RunCondition {
+                name,
+                system,
+                on_set,
+                ..
+            } => {
+                write!(
+                    f,
+                    "Run condition `{name}` failed for{} system `{system}`",
+                    if *on_set { " set containing" } else { "" }
+                )
             }
         }
     }
diff --git a/crates/bevy_ecs/src/schedule/condition.rs b/crates/bevy_ecs/src/schedule/condition.rs
index e090f7c418a86..c72aa8396b7bd 100644
--- a/crates/bevy_ecs/src/schedule/condition.rs
+++ b/crates/bevy_ecs/src/schedule/condition.rs
@@ -1311,16 +1311,17 @@ where
 #[cfg(test)]
 mod tests {
     use super::{common_conditions::*, SystemCondition};
+    use crate::error::{BevyError, DefaultErrorHandler, ErrorContext};
     use crate::{
         change_detection::ResMut,
         component::Component,
         message::Message,
         query::With,
         schedule::{IntoScheduleConfigs, Schedule},
-        system::Local,
+        system::{IntoSystem, Local, Res, System},
         world::World,
     };
-    use bevy_ecs_macros::Resource;
+    use bevy_ecs_macros::{Resource, SystemSet};
 
     #[derive(Resource, Default)]
     struct Counter(usize);
@@ -1457,4 +1458,41 @@ mod tests {
                 .distributive_run_if(not(run_once)),
         );
     }
+
+    #[test]
+    fn run_if_error_contains_system() {
+        let mut world = World::new();
+        world.insert_resource(DefaultErrorHandler(my_error_handler));
+
+        #[derive(Resource)]
+        struct MyResource;
+
+        fn condition(_res: Res<MyResource>) -> bool {
+            true
+        }
+
+        fn my_error_handler(_: BevyError, ctx: ErrorContext) {
+            let a = IntoSystem::into_system(system_a);
+            let b = IntoSystem::into_system(system_b);
+            assert!(
+                matches!(ctx, ErrorContext::RunCondition { system, on_set, .. } if (on_set && system == b.name()) || (!on_set && system == a.name()))
+            );
+        }
+
+        fn system_a() {}
+        fn system_b() {}
+
+        let mut schedule = Schedule::default();
+        schedule.add_systems(system_a.run_if(condition));
+        schedule.run(&mut world);
+
+        #[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]
+        struct Set;
+
+        let mut schedule = Schedule::default();
+        schedule
+            .add_systems((system_b,).in_set(Set))
+            .configure_sets(Set.run_if(condition));
+        schedule.run(&mut world);
+    }
 }
diff --git a/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs b/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs
index bd99344f498fa..c1ed3ff73bd44 100644
--- a/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs
+++ b/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs
@@ -601,6 +601,8 @@ impl ExecutorState {
                     &mut conditions.set_conditions[set_idx],
                     world,
                     error_handler,
+                    system,
+                    true,
                 )
             };
 
@@ -622,6 +624,8 @@ impl ExecutorState {
                 &mut conditions.system_conditions[system_index],
                 world,
                 error_handler,
+                system,
+                false,
             )
         };
 
@@ -826,6 +830,8 @@ unsafe fn evaluate_and_fold_conditions(
     conditions: &mut [ConditionWithAccess],
     world: UnsafeWorldCell,
     error_handler: ErrorHandler,
+    for_system: &ScheduleSystem,
+    on_set: bool,
 ) -> bool {
     #[expect(
         clippy::unnecessary_fold,
@@ -855,6 +861,8 @@ unsafe fn evaluate_and_fold_conditions(
                             ErrorContext::RunCondition {
                                 name: condition.name(),
                                 last_run: condition.get_last_run(),
+                                system: for_system.name(),
+                                on_set,
                             },
                         );
                     };
diff --git a/crates/bevy_ecs/src/schedule/executor/simple.rs b/crates/bevy_ecs/src/schedule/executor/simple.rs
index 8219339cfafbc..10448225c1ea2 100644
--- a/crates/bevy_ecs/src/schedule/executor/simple.rs
+++ b/crates/bevy_ecs/src/schedule/executor/simple.rs
@@ -17,7 +17,7 @@ use crate::{
         executor::is_apply_deferred, ConditionWithAccess, ExecutorKind, SystemExecutor,
         SystemSchedule,
     },
-    system::RunSystemError,
+    system::{RunSystemError, ScheduleSystem},
     world::World,
 };
 
@@ -71,8 +71,10 @@ impl SystemExecutor for SimpleExecutor {
             .unwrap_or_default();
 
         for system_index in 0..schedule.systems.len() {
+            let system = &mut schedule.systems[system_index].system;
+
             #[cfg(feature = "trace")]
-            let name = schedule.systems[system_index].system.name();
+            let name = system.name();
             #[cfg(feature = "trace")]
             let should_run_span = info_span!("check_conditions", name = name.as_string()).entered();
 
@@ -87,6 +89,8 @@ impl SystemExecutor for SimpleExecutor {
                     &mut schedule.set_conditions[set_idx],
                     world,
                     error_handler,
+                    system,
+                    true,
                 );
 
                 if !set_conditions_met {
@@ -103,12 +107,12 @@ impl SystemExecutor for SimpleExecutor {
                 &mut schedule.system_conditions[system_index],
                 world,
                 error_handler,
+                system,
+                false,
             );
 
             should_run &= system_conditions_met;
 
-            let system = &mut schedule.systems[system_index].system;
-
             #[cfg(feature = "trace")]
             should_run_span.exit();
 
@@ -184,6 +188,8 @@ fn evaluate_and_fold_conditions(
     conditions: &mut [ConditionWithAccess],
     world: &mut World,
     error_handler: ErrorHandler,
+    for_system: &ScheduleSystem,
+    on_set: bool,
 ) -> bool {
     #[cfg(feature = "hotpatching")]
     let hotpatch_tick = world
@@ -210,6 +216,8 @@ fn evaluate_and_fold_conditions(
                             ErrorContext::RunCondition {
                                 name: condition.name(),
                                 last_run: condition.get_last_run(),
+                                system: for_system.name(),
+                                on_set,
                             },
                         );
                     };
diff --git a/crates/bevy_ecs/src/schedule/executor/single_threaded.rs b/crates/bevy_ecs/src/schedule/executor/single_threaded.rs
index b99fbafa6c2ae..70d2ec7e9402d 100644
--- a/crates/bevy_ecs/src/schedule/executor/single_threaded.rs
+++ b/crates/bevy_ecs/src/schedule/executor/single_threaded.rs
@@ -12,7 +12,7 @@ use crate::{
     schedule::{
         is_apply_deferred, ConditionWithAccess, ExecutorKind, SystemExecutor, SystemSchedule,
     },
-    system::RunSystemError,
+    system::{RunSystemError, ScheduleSystem},
     world::World,
 };
 
@@ -73,8 +73,10 @@ impl SystemExecutor for SingleThreadedExecutor {
             .unwrap_or_default();
 
         for system_index in 0..schedule.systems.len() {
+            let system = &mut schedule.systems[system_index].system;
+
             #[cfg(feature = "trace")]
-            let name = schedule.systems[system_index].system.name();
+            let name = system.name();
             #[cfg(feature = "trace")]
             let should_run_span = info_span!("check_conditions", name = name.as_string()).entered();
 
@@ -89,6 +91,8 @@ impl SystemExecutor for SingleThreadedExecutor {
                     &mut schedule.set_conditions[set_idx],
                     world,
                     error_handler,
+                    system,
+                    true,
                 );
 
                 if !set_conditions_met {
@@ -105,12 +109,12 @@ impl SystemExecutor for SingleThreadedExecutor {
                 &mut schedule.system_conditions[system_index],
                 world,
                 error_handler,
+                system,
+                false,
             );
 
             should_run &= system_conditions_met;
 
-            let system = &mut schedule.systems[system_index].system;
-
             #[cfg(feature = "trace")]
             should_run_span.exit();
 
@@ -201,6 +205,8 @@ fn evaluate_and_fold_conditions(
     conditions: &mut [ConditionWithAccess],
     world: &mut World,
     error_handler: ErrorHandler,
+    for_system: &ScheduleSystem,
+    on_set: bool,
 ) -> bool {
     #[cfg(feature = "hotpatching")]
     let hotpatch_tick = world
@@ -227,6 +233,8 @@ fn evaluate_and_fold_conditions(
                             ErrorContext::RunCondition {
                                 name: condition.name(),
                                 last_run: condition.get_last_run(),
+                                system: for_system.name(),
+                                on_set,
                             },
                         );
                     };
