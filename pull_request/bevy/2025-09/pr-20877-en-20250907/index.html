<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20877 Introduce MovingPtr as a safer alternative to moving typed values by raw pointer
        
    </title><meta content="#20877 Introduce MovingPtr as a safer alternative to moving typed values by raw pointer" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-07</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-09/pr-20877-zh-cn-20250907>中文</a></div></div><div class=pr-content><h1 id=title>Title</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Introduce MovingPtr as a safer alternative to moving typed values by raw pointer<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20877<li><strong>Author</strong>: james7132<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Usability, S-Ready-For-Final-Review, A-Pointers, D-Unsafe<li><strong>Created</strong>: 2025-09-05T02:55:01Z<li><strong>Merged</strong>: 2025-09-07T20:57:32Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><p>Make moving potentially large values, like those seen in #20571 and those seen by #20772, safer and easier to review.<h2 id=solution>Solution</h2><p>Introduce <code>MovingPtr<'a, T></code> as a wrapper around <code>NonNull&LTT></code>. This type:<ul><li>Wraps a pointer and is thus cheap to pass through to functions.<li>Acts like a <code>Box&LTT></code> that does not own the allocation it points to. It will drop the value it points to when it’s dropped, but will not deallocate when it’s dropped.<li>Acts like a <code>OwningPtr</code> in that it owns the values it points to and has an associated lifetime, but it has a concrete type.<li>As it owns the value, it does not implement <code>Clone</code> or <code>Copy</code>.<li>Does not support arbitrary pointer arithmetic other than to get <code>MovingPtr</code>s of the value’s fields.<li>Does not support casting to types other than <code>ManuallyDrop&LTT></code> and <code>MaybeUninit&LTT></code>.<li>Has methods that consume the <code>MovingPtr</code> that copies the value into a target pointer or reads it onto the stack.<li>Provide unsafe functions for partially moving values of members out and returns a <code>MovingPtr<'a, MaybeUninit&LTT>></code> in its stead.<li>Optionally supports unaligned pointers like <code>OwningPtr</code> for use cases like #20593.<li>Provides <code>From</code> impl for converting to <code>OwningPtr</code> to type erasure without loss of the lifetime or alignment requirements.<li>Provides a <code>TryFrom</code> impl to attempt to convert an unaligned instance into a aligned one. Can be combined with <code>DebugCheckedUnwrap</code> to assert that the conversion is sound.<li>The <code>deconstruct_moving_ptr</code> provides a less error-prone way of decomposing a <code>MovingPtr</code> into separate <code>MovingPtr</code> for its fields.</ul><p>This design is loosely based on the outptr proposal for <a rel="noopener nofollow noreferrer" href=https://github.com/rust-lang/lang-team/issues/336#issuecomment-3049593105 target=_blank>in-place construction</a>, but currently eschews the requirements for a derive macro.<h2 id=testing>Testing</h2><p>CI, new doc tests pass.<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses a fundamental problem in Rust’s memory management when dealing with large values that need to be moved efficiently. The core issue was that moving potentially large values by raw pointer was error-prone, unsafe, and difficult to review correctly. Developers were manually managing pointer operations that could easily lead to use-after-free bugs, double drops, or alignment issues.<p>The solution introduces <code>MovingPtr<'a, T></code>, a smart pointer type that provides safe ownership semantics without taking responsibility for memory allocation. This type acts like a lifetime-bound <code>Box&LTT></code> but doesn’t own the underlying allocation - it only owns the value itself. When dropped, it properly drops the value but leaves the allocation management to whatever originally owned it (like a <code>Vec</code> or stack frame).<p>The implementation builds on Bevy’s existing pointer infrastructure by extending the <code>IsAligned</code> trait with fundamental pointer operations (<code>read_ptr</code>, <code>copy_nonoverlapping</code>, <code>drop_in_place</code>) that handle both aligned and unaligned cases correctly. This allows <code>MovingPtr</code> to work seamlessly in both scenarios, which is crucial for use cases like working with packed structs or specific memory layouts.<p>Key engineering decisions shaped this implementation:<ol><li><strong>No Clone/Copy</strong>: Since <code>MovingPtr</code> owns the value, allowing duplication would violate Rust’s ownership rules and lead to double drops.<li><strong>Limited pointer arithmetic</strong>: Only field-level access is supported through <code>move_field</code>, preventing arbitrary and unsafe pointer manipulation.<li><strong>Integration with existing types</strong>: <code>MovingPtr</code> can be converted to <code>OwningPtr</code> for type erasure scenarios, maintaining compatibility with Bevy’s ECS system.<li><strong>Safe deconstruction</strong>: The <code>deconstruct_moving_ptr</code> macro provides a structured way to break down complex types into their component fields safely.</ol><p>The most technically interesting aspect is how <code>MovingPtr</code> handles partial moves through the <code>partial_move</code> method. This allows safely extracting fields from a struct while maintaining the integrity of the remaining fields, returning a <code>MovingPtr<'a, MaybeUninit&LTT>></code> for the partially moved value. This is particularly valuable for ECS systems that need to move components between archetypes or storage locations.<p>Performance considerations were central to this design. <code>MovingPtr</code> is designed to be zero-cost - it’s essentially a wrapped <code>NonNull&LTT></code> with the same memory footprint and runtime characteristics. The safety checks happen at compile time through Rust’s type system, with minimal runtime overhead.<p>The impact of this change is significant for Bevy’s memory management patterns. It provides a standardized, safe way to move values in memory without the overhead of full allocation ownership. This is particularly valuable for:<ul><li>ECS component moving between storage locations<li>Efficient serialization/deserialization workflows<li>Safe manipulation of large data structures without copying<li>Memory-efficient data processing pipelines</ul><p>The implementation demonstrates several advanced Rust patterns:<ul><li>Phantom types for alignment tracking<li>Safe abstraction over unsafe pointer operations<li>Macro-based DSLs for complex operations (<code>deconstruct_moving_ptr</code>)<li>Type conversion patterns between different pointer types</ul><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[MovingPtr<'a, T, A>] --> B[OwningPtr<'a, A>]
</span><span>    A --> C[Field Access]
</span><span>    A --> D[Value Movement]
</span><span>    C --> E[move_field method]
</span><span>    D --> F[read/write_to/assign_to]
</span><span>    B --> G[Type Erasure]
</span><span>    
</span><span>    style A fill:#e6f3ff
</span><span>    style B fill:#f0f8e6
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ptr-src-lib-rs-576-22><code>crates/bevy_ptr/src/lib.rs</code> (+576/-22)</h3><p>This file received the majority of changes, adding the <code>MovingPtr</code> type and supporting infrastructure:<p><strong>Key additions:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>repr</span><span>(transparent)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>MovingPtr</span><span><</span><span style=color:#fa6e32>'a</span><span>, T, A</span><span style=color:#61676ccc>:</span><span> IsAligned = Aligned>(NonNull&LTT>, PhantomData<(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a mut</span><span> T, A)</span><span style=color:#ed9366>></span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p><strong>Extended IsAligned trait:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>IsAligned</span><span>: sealed::Sealed {
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>read_ptr</span><span>&LTT>(</span><span style=color:#ff8f40>ptr</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>*const</span><span> T) </span><span style=color:#61676ccc>-></span><span> T</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>copy_nonoverlapping</span><span>&LTT>(</span><span style=color:#ff8f40>src</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>*const</span><span> T, </span><span style=color:#ff8f40>dst</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>*mut</span><span> T, </span><span style=color:#ff8f40>count</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>drop_in_place</span><span>&LTT>(</span><span style=color:#ff8f40>ptr</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>*mut</span><span> T)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><strong>Core MovingPtr methods:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'a</span><span>, T, A</span><span style=color:#61676ccc>:</span><span> IsAligned> </span><span style=color:#399ee6>MovingPtr</span><span><</span><span style=color:#fa6e32>'a</span><span>, T, A> {
</span><span>    </span><span style=color:#fa6e32>pub unsafe fn </span><span style=color:#f29718>new</span><span>(</span><span style=color:#ff8f40>inner</span><span style=color:#61676ccc>: </span><span>NonNull&LTT>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{ </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub unsafe fn </span><span style=color:#f29718>partial_move</span><span>(...) </span><span style=color:#61676ccc>-> </span><span>MovingPtr<</span><span style=color:#fa6e32>'a</span><span>, MaybeUninit&LTT>, A> { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>read</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> T { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub unsafe fn </span><span style=color:#f29718>write_to</span><span>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>dst</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>*mut</span><span> T) { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>assign_to</span><span>(</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>dst</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> T) { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>pub unsafe fn </span><span style=color:#f29718>move_field</span><span>&LTU>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>byte_offset</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>) </span><span style=color:#61676ccc>-> </span><span>MovingPtr<</span><span style=color:#fa6e32>'a</span><span>, U, Unaligned> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><h3 id=crates-bevy-ptr-readme-md-6-0><code>crates/bevy_ptr/README.md</code> (+6/-0)</h3><p>Updated the documentation to include <code>MovingPtr</code> in the pointer type comparison table and add a description:<pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span style=color:#61676ccc>|</span><span style=color:#ed9366;background-color:#61676c10>`MovingPtr<'a, T>`</span><span>   </span><span style=color:#61676ccc>|</span><span>Yes        </span><span style=color:#61676ccc>|</span><span>Yes    </span><span style=color:#61676ccc>|</span><span>Yes           </span><span style=color:#61676ccc>|</span><span>Maybe  </span><span style=color:#61676ccc>|</span><span>Yes     </span><span style=color:#61676ccc>|</span><span>Yes             </span><span style=color:#61676ccc>|</span><span>Yes               </span><span style=color:#61676ccc>|
</span></code></pre><pre class=language-markdown data-lang=markdown style=color:#61676c;background-color:#fafafa><code class=language-markdown data-lang=markdown><span style=color:#ed9366;background-color:#61676c10>`MovingPtr<'a, T>`</span><span> is like a lifetimed-</span><span style=color:#ed9366;background-color:#61676c10>`Box&LTT>`</span><span> or a typed </span><span style=color:#ed9366;background-color:#61676c10>`OwningPtr<'a>`</span><span> made for cheaply moving potentially large values around in memory.
</span><span>It's a pointer that owns the value it points to but does not own the allocation. If dropped, it will drop the value it points to, just as
</span><span>if you dropped a value of the inner type but won't deallocate the allocation where the value lived in. It provides a number of methods for moving the value
</span><span>into another location in memory, including options for partial or deconstructive moves.
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/nomicon/working-with-unsafe.html target=_blank>Rustonomicon - Working with Unsafe</a><li><a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/rfcs/2582-maybe-uninit.html target=_blank>Rust RFC 2582 - MaybeUninit</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/architecture/ecs/ target=_blank>Bevy ECS Architecture</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/std/ptr/struct.NonNull.html target=_blank>NonNull documentation</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/rust-lang/lang-team/issues/336 target=_blank>In-place construction proposal</a></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_20877.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>