<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20951 make taa work with ortho
        
    </title><meta content="#20951 make taa work with ortho" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-10</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-09/pr-20951-en-20250910>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=title>Title</h1><p>make taa work with ortho<h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: make taa work with ortho<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20951<li><strong>Author</strong>: atlv24<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: C-Feature, A-Rendering, S-Ready-For-Final-Review<li><strong>Created</strong>: 2025-09-10T16:01:06Z<li><strong>Merged</strong>: 2025-09-10T17:35:11Z<li><strong>Merged By</strong>: alice-i-cecile</ul><h2 id=description-translation>Description Translation</h2><h1 id=objective>Objective</h1><ul><li>修复正交投影下的时间性抖动 (temporal jitter)</ul><h2 id=solution>Solution</h2><ul><li>查看正交矩阵定义并推导正确的像素值范围<li>移除关于无法在正交投影下使用TAA的内容</ul><h2 id=testing>Testing</h2><ul><li>#20950</ul><h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>这个PR解决了一个具体的渲染问题：时间性抗锯齿 (Temporal Anti-Aliasing, TAA) 在正交投影 (orthographic projection) 相机下无法正常工作的问题。<p>问题的根源在于TAA实现中的投影矩阵抖动计算。TAA技术需要通过轻微抖动相机视角来采样多个帧，然后将这些帧混合以减少锯齿。对于透视投影，抖动计算相对直接，但正交投影需要不同的数学处理。<p>在修改前的代码中，<code>TemporalJitter::jitter_projection</code> 方法有一个明显的限制：它检查投影矩阵的w分量是否为1.0（这是正交投影的特征），如果是就直接发出警告并返回，不进行任何抖动计算。这导致正交相机完全无法使用TAA功能。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前的代码：
</span><span style=color:#fa6e32>if</span><span> clip_from_view</span><span style=color:#ed9366>.</span><span>w_axis</span><span style=color:#ed9366>.</span><span>w </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>1.0 </span><span>{
</span><span>    </span><span style=color:#f07171>warn!</span><span>(
</span><span>        </span><span style=color:#86b300>"TemporalJitter not supported with OrthographicProjection. Use PerspectiveProjection instead."
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>开发者通过分析正交投影矩阵的数学特性，发现问题的核心在于如何正确计算正交投影下的像素偏移。正交投影与透视投影的主要区别在于它没有透视除法，因此抖动计算需要考虑不同的缩放因子。<p>解决方案是保留对正交投影的检测，但不跳过计算，而是应用适当的缩放因子：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改后的代码：
</span><span style=color:#fa6e32>if</span><span> clip_from_view</span><span style=color:#ed9366>.</span><span>w_axis</span><span style=color:#ed9366>.</span><span>w </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>1.0 </span><span>{
</span><span>    jitter </span><span style=color:#ed9366>*= </span><span style=color:#f07171>vec2</span><span>(clip_from_view</span><span style=color:#ed9366>.</span><span>x_axis</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>,</span><span> clip_from_view</span><span style=color:#ed9366>.</span><span>y_axis</span><span style=color:#ed9366>.</span><span>y) </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>0.5</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这里的关键洞察是：正交投影矩阵的x_axis.x和y_axis.y分量实际上包含了视图的宽度和高度信息，可以用来正确缩放抖动偏移量。乘以0.5是因为正交投影的裁剪空间范围是[-1, 1]，而抖动需要在正确的像素尺度上应用。<p>除了核心算法修复，PR还进行了相关的文档和类型系统清理：<ol><li>移除了 <code>bevy_anti_alias/src/taa/mod.rs</code> 中对 <code>Projection</code> 类型的依赖，因为不再需要检查投影类型<li>更新了文档注释，删除了关于TAA不能用于正交投影的限制说明<li>将 <code>TemporalAntiAlias</code> 组件的描述从“3D perspective camera“改为更通用的“3D camera“</ol><p>这些更改虽然看似简单，但体现了对图形学原理的深入理解。开发者没有选择复杂的重写，而是通过精确的数学修正解决了问题，这种针对性的修复最小化了代码变更范围和潜在风险。<p>从架构角度看，这个修改保持了API的一致性，用户现在可以在透视和正交投影中使用相同的TAA组件，无需特殊处理。这对于使用正交相机进行2D游戏或UI渲染的场景特别有价值。<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[TemporalAntiAlias组件] --> B[提取TAA设置]
</span><span>    B --> C[TemporalJitter组件]
</span><span>    C --> D[jitter_projection方法]
</span><span>    D --> E{投影类型检测}
</span><span>    E -->|正交投影| F[应用正交缩放因子]
</span><span>    E -->|透视投影| G[使用标准抖动计算]
</span><span>    F --> H[更新投影矩阵]
</span><span>    G --> H
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-anti-alias-src-taa-mod-rs-6-13><code>crates/bevy_anti_alias/src/taa/mod.rs</code> (+6/-13)</h3><p>主要修改是移除了对透视投影的强制要求，使TAA能够支持正交投影：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前：
</span><span style=color:#fa6e32>for </span><span>(entity</span><span style=color:#61676ccc>,</span><span> camera</span><span style=color:#61676ccc>,</span><span> camera_projection</span><span style=color:#61676ccc>,</span><span> taa_settings) </span><span style=color:#ed9366>in</span><span> cameras_3d</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> main_world) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#fa6e32>mut</span><span> taa_settings) </span><span style=color:#ed9366>=</span><span> taa_settings
</span><span>        </span><span style=color:#ed9366>&&</span><span> camera</span><span style=color:#ed9366>.</span><span>is_active
</span><span>        </span><span style=color:#ed9366>&&</span><span> camera_projection</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_perspective</span><span>()  </span><span style=color:#abb0b6;font-style:italic>// 只允许透视投影
</span><span>    {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后：
</span><span style=color:#fa6e32>for </span><span>(entity</span><span style=color:#61676ccc>,</span><span> camera</span><span style=color:#61676ccc>,</span><span> taa_settings) </span><span style=color:#ed9366>in</span><span> cameras_3d</span><span style=color:#ed9366>.</span><span style=color:#f07171>iter_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> main_world) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#fa6e32>mut</span><span> taa_settings) </span><span style=color:#ed9366>=</span><span> taa_settings
</span><span>        </span><span style=color:#ed9366>&&</span><span> camera</span><span style=color:#ed9366>.</span><span>is_active  </span><span style=color:#abb0b6;font-style:italic>// 移除了投影类型检查
</span><span>    {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-render-src-camera-rs-5-11><code>crates/bevy_render/src/camera.rs</code> (+5/-11)</h3><p>核心修改在 <code>TemporalJitter::jitter_projection</code> 方法中，添加了对正交投影的正确支持：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 修改前：
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>jitter_projection</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>clip_from_view</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Mat4, </span><span style=color:#ff8f40>view_size</span><span style=color:#61676ccc>:</span><span> Vec2) {
</span><span>    </span><span style=color:#fa6e32>if</span><span> clip_from_view</span><span style=color:#ed9366>.</span><span>w_axis</span><span style=color:#ed9366>.</span><span>w </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>1.0 </span><span>{
</span><span>        </span><span style=color:#f07171>warn!</span><span>(</span><span style=color:#86b300>"TemporalJitter not supported with OrthographicProjection..."</span><span>)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// 直接返回，不进行处理
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let</span><span> jitter </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>offset </span><span style=color:#ed9366>* </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>2.0</span><span>)) </span><span style=color:#ed9366>/</span><span> view_size</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 修改后：
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>jitter_projection</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>clip_from_view</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Mat4, </span><span style=color:#ff8f40>view_size</span><span style=color:#61676ccc>:</span><span> Vec2) {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> jitter </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>offset </span><span style=color:#ed9366>* </span><span style=color:#f07171>vec2</span><span>(</span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>2.0</span><span>)) </span><span style=color:#ed9366>/</span><span> view_size</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>if</span><span> clip_from_view</span><span style=color:#ed9366>.</span><span>w_axis</span><span style=color:#ed9366>.</span><span>w </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>1.0 </span><span>{
</span><span>        jitter </span><span style=color:#ed9366>*= </span><span style=color:#f07171>vec2</span><span>(clip_from_view</span><span style=color:#ed9366>.</span><span>x_axis</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>,</span><span> clip_from_view</span><span style=color:#ed9366>.</span><span>y_axis</span><span style=color:#ed9366>.</span><span>y) </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>0.5</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    clip_from_view</span><span style=color:#ed9366>.</span><span>z_axis</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>+=</span><span> jitter</span><span style=color:#ed9366>.</span><span>x</span><span style=color:#61676ccc>;
</span><span>    clip_from_view</span><span style=color:#ed9366>.</span><span>z_axis</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>+=</span><span> jitter</span><span style=color:#ed9366>.</span><span>y</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/books/introduction/ target=_blank>Bevy渲染引擎文档</a><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Temporal_anti-aliasing target=_blank>时间性抗锯齿原理</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/docs/techniques/media/super-resolution-temporal/jitter-space.svg target=_blank>FidelityFX SDK中的抖动空间参考</a><li><a rel="noopener nofollow noreferrer" href=https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/ target=_blank>投影矩阵数学</a></ol><h1 id=full-code-diff>Full Code Diff</h1><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_anti_alias/src/taa/mod.rs b/crates/bevy_anti_alias/src/taa/mod.rs
</span><span>index 1781f90d9935f..44aa6624c1111 100644
</span><span style=color:#c594c5>--- a/crates/bevy_anti_alias/src/taa/mod.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_anti_alias/src/taa/mod.rs
</span><span style=color:#c594c5>@@ -1,6 +1,6 @@
</span><span> use bevy_app::{App, Plugin};
</span><span> use bevy_asset::{embedded_asset, load_embedded_asset, AssetServer, Handle};
</span><span style=color:#f07171>-use bevy_camera::{Camera, Camera3d, Projection};
</span><span style=color:#86b300>+use bevy_camera::{Camera, Camera3d};
</span><span> use bevy_core_pipeline::{
</span><span>     core_3d::graph::{Core3d, Node3d},
</span><span>     prepass::{DepthPrepass, MotionVectorPrepass, ViewPrepassTextures},
</span><span style=color:#c594c5>@@ -83,7 +83,7 @@ </span><span style=color:#399ee6>impl Plugin for TemporalAntiAliasPlugin {
</span><span>     }
</span><span> }
</span><span> 
</span><span style=color:#f07171>-/// Component to apply temporal anti-aliasing to a 3D perspective camera.
</span><span style=color:#86b300>+/// Component to apply temporal anti-aliasing to a 3D camera.
</span><span> ///
</span><span> /// Temporal anti-aliasing (TAA) is a form of image smoothing/filtering, like
</span><span> /// multisample anti-aliasing (MSAA), or fast approximate anti-aliasing (FXAA).
</span><span style=color:#c594c5>@@ -109,8 +109,6 @@ </span><span style=color:#399ee6>impl Plugin for TemporalAntiAliasPlugin {
</span><span> ///
</span><span> /// Any camera with this component must also disable [`Msaa`] by setting it to [`Msaa::Off`].
</span><span> ///
</span><span style=color:#f07171>-/// [Currently](https://github.com/bevyengine/bevy/issues/8423), TAA cannot be used with [`bevy_camera::OrthographicProjection`].
</span><span style=color:#f07171>-///
</span><span> /// TAA also does not work well with alpha-blended meshes, as it requires depth writing to determine motion.
</span><span> ///
</span><span> /// It is very important that correct motion vectors are written for everything on screen.
</span><span style=color:#c594c5>@@ -344,20 +342,15 @@ </span><span style=color:#399ee6>impl SpecializedRenderPipeline for TaaPipeline {
</span><span> }
</span><span> 
</span><span> fn extract_taa_settings(mut commands: Commands, mut main_world: ResMut&LTMainWorld>) {
</span><span style=color:#f07171>-    let mut cameras_3d = main_world.query::<(
</span><span style=color:#f07171>-        RenderEntity,
</span><span style=color:#f07171>-        &Camera,
</span><span style=color:#f07171>-        &Projection,
</span><span style=color:#f07171>-        Option<&mut TemporalAntiAliasing>,
</span><span style=color:#f07171>-    )>();
</span><span style=color:#f07171>-
</span><span style=color:#f07171>-    for (entity, camera, camera_projection, taa_settings) in cameras_3d.iter_mut(&mut main_world) {
</span><span style=color:#86b300>+    let mut cameras_3d =
</span><span style=color:#86b300>+        main_world.query::<(RenderEntity, &Camera, Option<&mut TemporalAntiAliasing>)>();
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+    for (entity, camera, taa_settings) in cameras_3d.iter_mut(&mut main_world) {
</span><span>         let mut entity_commands = commands
</span><span>             .get_entity(entity)
</span><span>             .expect("Camera entity wasn't synced.");
</span><span>         if let Some(mut taa_settings) = taa_settings
</span><span>             && camera.is_active
</span><span style=color:#f07171>-            && camera_projection.is_perspective()
</span><span>         {
</span><span>             entity_commands.insert(taa_settings.clone());
</span><span>             taa_settings.reset = false;
</span><span>diff --git a/crates/bevy_render/src/camera.rs b/crates/bevy_render/src/camera.rs
</span><span>index 085e7733ad397..24047d86402c8 100644
</span><span style=color:#c594c5>--- a/crates/bevy_render/src/camera.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_render/src/camera.rs
</span><span style=color:#c594c5>@@ -658,10 +658,6 @@ </span><span style=color:#399ee6>pub fn sort_cameras(
</span><span> /// A subpixel offset to jitter a perspective camera's frustum by.
</span><span> ///
</span><span> /// Useful for temporal rendering techniques.
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// Do not use with [`OrthographicProjection`].
</span><span style=color:#f07171>-///
</span><span style=color:#f07171>-/// [`OrthographicProjection`]: bevy_camera::OrthographicProjection
</span><span> #[derive(Component, Clone, Default, Reflect)]
</span><span> #[reflect(Default, Component, Clone)]
</span><span> pub struct TemporalJitter {
</span><span style=color:#c594c5>@@ -671,16 +667,14 @@ </span><span style=color:#399ee6>pub struct TemporalJitter {
</span><span> 
</span><span> impl TemporalJitter {
</span><span>     pub fn jitter_projection(&self, clip_from_view: &mut Mat4, view_size: Vec2) {
</span><span style=color:#86b300>+        // https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/d7531ae47d8b36a5d4025663e731a47a38be882f/docs/techniques/media/super-resolution-temporal/jitter-space.svg
</span><span style=color:#86b300>+        let mut jitter = (self.offset * vec2(2.0, -2.0)) / view_size;
</span><span style=color:#86b300>+
</span><span style=color:#86b300>+        // orthographic
</span><span>         if clip_from_view.w_axis.w == 1.0 {
</span><span style=color:#f07171>-            warn!(
</span><span style=color:#f07171>-                "TemporalJitter not supported with OrthographicProjection. Use PerspectiveProjection instead."
</span><span style=color:#f07171>-            );
</span><span style=color:#f07171>-            return;
</span><span style=color:#86b300>+            jitter *= vec2(clip_from_view.x_axis.x, clip_from_view.y_axis.y) * 0.5;
</span><span>         }
</span><span> 
</span><span style=color:#f07171>-        // https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/d7531ae47d8b36a5d4025663e731a47a38be882f/docs/techniques/media/super-resolution-temporal/jitter-space.svg
</span><span style=color:#f07171>-        let jitter = (self.offset * vec2(2.0, -2.0)) / view_size;
</span><span style=color:#f07171>-
</span><span>         clip_from_view.z_axis.x += jitter.x;
</span><span>         clip_from_view.z_axis.y += jitter.y;
</span><span>     }
</span></code></pre></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_20951.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>