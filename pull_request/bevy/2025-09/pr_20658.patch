diff --git a/Cargo.toml b/Cargo.toml
index 09c4651c4ca00..19bd28d8b7f6a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1340,7 +1340,7 @@ wasm = true
 name = "solari"
 path = "examples/3d/solari.rs"
 doc-scrape-examples = true
-required-features = ["bevy_solari"]
+required-features = ["bevy_solari", "https"]
 
 [package.metadata.example.solari]
 name = "Solari"
diff --git a/crates/bevy_asset/src/io/web.rs b/crates/bevy_asset/src/io/web.rs
index 20aaafd20e8c7..b0b297126bce6 100644
--- a/crates/bevy_asset/src/io/web.rs
+++ b/crates/bevy_asset/src/io/web.rs
@@ -62,8 +62,8 @@ pub struct WebAssetPlugin {
 impl Plugin for WebAssetPlugin {
     fn build(&self, app: &mut App) {
         if !self.silence_startup_warning {
-            warn!("WebAssetPlugin is potentially insecure! Make sure to verify asset URLs are safe to load before loading them.\
-            If you promise you know what you're doing, you can silence this warning by setting silence_startup_warning: true\
+            warn!("WebAssetPlugin is potentially insecure! Make sure to verify asset URLs are safe to load before loading them. \
+            If you promise you know what you're doing, you can silence this warning by setting silence_startup_warning: true \
             in the WebAssetPlugin construction.");
         }
         if app.is_plugin_added::<AssetPlugin>() {
diff --git a/crates/bevy_solari/src/realtime/world_cache_compact.wgsl b/crates/bevy_solari/src/realtime/world_cache_compact.wgsl
index a58abee4a9cc9..71585223a5e44 100644
--- a/crates/bevy_solari/src/realtime/world_cache_compact.wgsl
+++ b/crates/bevy_solari/src/realtime/world_cache_compact.wgsl
@@ -25,7 +25,7 @@ fn compact_world_cache_single_block(
     @builtin(local_invocation_index) t: u32,
 ) {
     if t == 0u { w1[0u] = 0u; } else { w1[t] = u32(world_cache_life[cell_id.x - 1u] != 0u); }; workgroupBarrier();
-    if t < 1u { w2  [t] = w1[t]; } else { w2[t] = w1[t] + w1[t - 1u]; } workgroupBarrier();
+    if t < 1u { w2[t] = w1[t]; } else { w2[t] = w1[t] + w1[t - 1u]; } workgroupBarrier();
     if t < 2u { w1[t] = w2[t]; } else { w1[t] = w2[t] + w2[t - 2u]; } workgroupBarrier();
     if t < 4u { w2[t] = w1[t]; } else { w2[t] = w1[t] + w1[t - 4u]; } workgroupBarrier();
     if t < 8u { w1[t] = w2[t]; } else { w1[t] = w2[t] + w2[t - 8u]; } workgroupBarrier();
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 3e3e8d4c07487..12c89abcc9eb4 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -6,7 +6,7 @@ mod camera_controller;
 use argh::FromArgs;
 use bevy::{
     camera::CameraMainTextureUsages,
-    mesh::Indices,
+    gltf::GltfMaterialName,
     prelude::*,
     render::render_resource::TextureUsages,
     scene::SceneInstanceReady,
@@ -47,6 +47,9 @@ fn main() {
 
     if args.pathtracer == Some(true) {
         app.add_plugins(PathtracingPlugin);
+    } else {
+        app.add_systems(Update, (pause_scene, toggle_lights, patrol_path));
+        app.add_systems(PostUpdate, update_text);
     }
 
     app.run();
@@ -61,9 +64,38 @@ fn setup(
     >,
 ) {
     commands
-        .spawn(SceneRoot(asset_server.load(
-            GltfAssetLabel::Scene(0).from_asset("models/CornellBox/CornellBox.glb"),
-        )))
+        .spawn((
+            SceneRoot(
+                asset_server.load(
+                    GltfAssetLabel::Scene(0)
+                        .from_asset("https://github.com/bevyengine/bevy_asset_files/raw/2a5950295a8b6d9d051d59c0df69e87abcda58c3/pica_pica/mini_diorama_01.glb")
+                ),
+            ),
+            Transform::from_scale(Vec3::splat(10.0)),
+        ))
+        .observe(add_raytracing_meshes_on_scene_load);
+
+    commands
+        .spawn((
+            SceneRoot(asset_server.load(
+                GltfAssetLabel::Scene(0).from_asset("https://github.com/bevyengine/bevy_asset_files/raw/2a5950295a8b6d9d051d59c0df69e87abcda58c3/pica_pica/robot_01.glb")
+            )),
+            Transform::from_scale(Vec3::splat(2.0))
+                .with_translation(Vec3::new(-2.0, 0.05, -2.1))
+                .with_rotation(Quat::from_rotation_y(PI / 2.0)),
+            PatrolPath {
+                path: vec![
+                    (Vec3::new(-2.0, 0.05, -2.1), Quat::from_rotation_y(PI / 2.0)),
+                    (Vec3::new(2.2, 0.05, -2.1), Quat::from_rotation_y(0.0)),
+                    (
+                        Vec3::new(2.2, 0.05, 2.1),
+                        Quat::from_rotation_y(3.0 * PI / 2.0),
+                    ),
+                    (Vec3::new(-2.0, 0.05, 2.1), Quat::from_rotation_y(PI)),
+                ],
+                i: 0,
+            },
+        ))
         .observe(add_raytracing_meshes_on_scene_load);
 
     commands.spawn((
@@ -72,7 +104,12 @@ fn setup(
             shadows_enabled: false, // Solari replaces shadow mapping
             ..default()
         },
-        Transform::from_rotation(Quat::from_euler(EulerRot::XYZ, PI * -0.43, PI * -0.08, 0.0)),
+        Transform::from_rotation(Quat::from_xyzw(
+            -0.13334629,
+            -0.86597735,
+            -0.3586996,
+            0.3219264,
+        )),
     ));
 
     let mut camera = commands.spawn((
@@ -82,11 +119,13 @@ fn setup(
             ..default()
         },
         CameraController {
-            walk_speed: 500.0,
-            run_speed: 1500.0,
+            walk_speed: 3.0,
+            run_speed: 10.0,
             ..Default::default()
         },
-        Transform::from_xyz(-278.0, 273.0, 800.0),
+        Transform::from_translation(Vec3::new(0.219417, 2.5764852, 6.9718704)).with_rotation(
+            Quat::from_xyzw(-0.1466768, 0.013738206, 0.002037309, 0.989087),
+        ),
         // Msaa::Off and CameraMainTextureUsages with STORAGE_BINDING are required for Solari
         CameraMainTextureUsages::default().with(TextureUsages::STORAGE_BINDING),
         Msaa::Off,
@@ -107,50 +146,211 @@ fn setup(
             _phantom_data: Default::default(),
         });
     }
+
+    commands.spawn((
+        Text::default(),
+        Node {
+            position_type: PositionType::Absolute,
+            bottom: Val::Px(12.0),
+            left: Val::Px(12.0),
+            ..default()
+        },
+    ));
 }
 
 fn add_raytracing_meshes_on_scene_load(
     event: On<SceneInstanceReady>,
     children: Query<&Children>,
-    mesh: Query<&Mesh3d>,
+    mesh_query: Query<(
+        &Mesh3d,
+        &MeshMaterial3d<StandardMaterial>,
+        Option<&GltfMaterialName>,
+    )>,
     mut meshes: ResMut<Assets<Mesh>>,
     mut materials: ResMut<Assets<StandardMaterial>>,
     mut commands: Commands,
     args: Res<Args>,
 ) {
-    // Ensure meshes are Solari compatible
-    for (_, mesh) in meshes.iter_mut() {
-        mesh.remove_attribute(Mesh::ATTRIBUTE_UV_1.id);
-        mesh.remove_attribute(Mesh::ATTRIBUTE_COLOR.id);
-        mesh.generate_tangents().unwrap();
-
-        if let Some(indices) = mesh.indices_mut()
-            && let Indices::U16(u16_indices) = indices
-        {
-            *indices = Indices::U32(u16_indices.iter().map(|i| *i as u32).collect());
-        }
-    }
-
-    // Add raytracing mesh handles
     for descendant in children.iter_descendants(event.entity()) {
-        if let Ok(mesh) = mesh.get(descendant) {
+        if let Ok((Mesh3d(mesh_handle), MeshMaterial3d(material_handle), material_name)) =
+            mesh_query.get(descendant)
+        {
+            // Add raytracing mesh component
             commands
                 .entity(descendant)
-                .insert(RaytracingMesh3d(mesh.0.clone()));
+                .insert(RaytracingMesh3d(mesh_handle.clone()));
 
+            // Ensure meshes are Solari compatible
+            let mesh = meshes.get_mut(mesh_handle).unwrap();
+            if !mesh.contains_attribute(Mesh::ATTRIBUTE_UV_0) {
+                let vertex_count = mesh.count_vertices();
+                mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, vec![[0.0, 0.0]; vertex_count]);
+                mesh.insert_attribute(
+                    Mesh::ATTRIBUTE_TANGENT,
+                    vec![[0.0, 0.0, 0.0, 0.0]; vertex_count],
+                );
+            }
+            if !mesh.contains_attribute(Mesh::ATTRIBUTE_TANGENT) {
+                mesh.generate_tangents().unwrap();
+            }
+            if mesh.contains_attribute(Mesh::ATTRIBUTE_UV_1) {
+                mesh.remove_attribute(Mesh::ATTRIBUTE_UV_1);
+            }
+
+            // Prevent rasterization if using pathtracer
             if args.pathtracer == Some(true) {
                 commands.entity(descendant).remove::<Mesh3d>();
             }
+
+            // Adjust scene materials to better demo Solari features
+            if material_name.map(|s| s.0.as_str()) == Some("material") {
+                let material = materials.get_mut(material_handle).unwrap();
+                material.emissive = LinearRgba::BLACK;
+            }
+            if material_name.map(|s| s.0.as_str()) == Some("Lights") {
+                let material = materials.get_mut(material_handle).unwrap();
+                material.emissive =
+                    LinearRgba::from(Color::srgb(0.941, 0.714, 0.043)) * 1_000_000.0;
+                material.alpha_mode = AlphaMode::Opaque;
+                material.specular_transmission = 0.0;
+
+                commands.insert_resource(RobotLightMaterial(material_handle.clone()));
+            }
+            if material_name.map(|s| s.0.as_str()) == Some("Glass_Dark_01") {
+                let material = materials.get_mut(material_handle).unwrap();
+                material.alpha_mode = AlphaMode::Opaque;
+                material.specular_transmission = 0.0;
+            }
+        }
+    }
+}
+
+fn pause_scene(mut time: ResMut<Time<Virtual>>, key_input: Res<ButtonInput<KeyCode>>) {
+    if key_input.just_pressed(KeyCode::Space) {
+        if time.is_paused() {
+            time.unpause();
+        } else {
+            time.pause();
+        }
+    }
+}
+
+#[derive(Resource)]
+struct RobotLightMaterial(Handle<StandardMaterial>);
+
+fn toggle_lights(
+    key_input: Res<ButtonInput<KeyCode>>,
+    robot_light_material: Option<Res<RobotLightMaterial>>,
+    mut materials: ResMut<Assets<StandardMaterial>>,
+    directional_light: Query<Entity, With<DirectionalLight>>,
+    mut commands: Commands,
+) {
+    if key_input.just_pressed(KeyCode::Digit1) {
+        if let Ok(directional_light) = directional_light.single() {
+            commands.entity(directional_light).despawn();
+        } else {
+            commands.spawn((
+                DirectionalLight {
+                    illuminance: light_consts::lux::FULL_DAYLIGHT,
+                    shadows_enabled: false, // Solari replaces shadow mapping
+                    ..default()
+                },
+                Transform::from_rotation(Quat::from_xyzw(
+                    -0.13334629,
+                    -0.86597735,
+                    -0.3586996,
+                    0.3219264,
+                )),
+            ));
         }
     }
 
-    // Adjust scene materials to better demo Solari features
-    for (_, material) in materials.iter_mut() {
-        material.emissive *= 200.0;
+    if key_input.just_pressed(KeyCode::Digit2)
+        && let Some(robot_light_material) = robot_light_material
+    {
+        let material = materials.get_mut(&robot_light_material.0).unwrap();
+        if material.emissive == LinearRgba::BLACK {
+            material.emissive = LinearRgba::from(Color::srgb(0.941, 0.714, 0.043)) * 1_000_000.0;
+        } else {
+            material.emissive = LinearRgba::BLACK;
+        }
+    }
+}
 
-        if material.base_color.to_linear() == LinearRgba::new(0.5, 0.5, 0.5, 1.0) {
-            material.metallic = 1.0;
-            material.perceptual_roughness = 0.15;
+#[derive(Component)]
+struct PatrolPath {
+    path: Vec<(Vec3, Quat)>,
+    i: usize,
+}
+
+fn patrol_path(mut query: Query<(&mut PatrolPath, &mut Transform)>, time: Res<Time<Virtual>>) {
+    for (mut path, mut transform) in query.iter_mut() {
+        let (mut target_position, mut target_rotation) = path.path[path.i];
+        let mut distance_to_target = transform.translation.distance(target_position);
+        if distance_to_target < 0.01 {
+            transform.translation = target_position;
+            transform.rotation = target_rotation;
+
+            path.i = (path.i + 1) % path.path.len();
+            (target_position, target_rotation) = path.path[path.i];
+            distance_to_target = transform.translation.distance(target_position);
+        }
+
+        let direction = (target_position - transform.translation).normalize();
+        let movement = direction * time.delta_secs();
+
+        if movement.length() > distance_to_target {
+            transform.translation = target_position;
+            transform.rotation = target_rotation;
+        } else {
+            transform.translation += movement;
         }
     }
 }
+
+fn update_text(
+    mut text: Single<&mut Text>,
+    robot_light_material: Option<Res<RobotLightMaterial>>,
+    materials: Res<Assets<StandardMaterial>>,
+    directional_light: Query<Entity, With<DirectionalLight>>,
+    time: Res<Time<Virtual>>,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] dlss_rr_supported: Option<
+        Res<DlssRayReconstructionSupported>,
+    >,
+) {
+    text.0.clear();
+
+    if time.is_paused() {
+        text.0.push_str("(Space): Resume");
+    } else {
+        text.0.push_str("(Space): Pause");
+    }
+
+    if directional_light.single().is_ok() {
+        text.0.push_str("\n(1): Disable directional light");
+    } else {
+        text.0.push_str("\n(1): Enable directional light");
+    }
+
+    match robot_light_material.and_then(|m| materials.get(&m.0)) {
+        Some(robot_light_material) if robot_light_material.emissive != LinearRgba::BLACK => {
+            text.0.push_str("\n(2): Disable robot emissive light");
+        }
+        _ => {
+            text.0.push_str("\n(2): Enable robot emissive light");
+        }
+    }
+
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    if dlss_rr_supported.is_some() {
+        text.0
+            .push_str("\nDenoising: DLSS Ray Reconstruction enabled");
+    } else {
+        text.0
+            .push_str("\nDenoising: DLSS Ray Reconstruction not supported");
+    }
+
+    #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))]
+    text.0
+        .push_str("\nDenoising: App not compiled with DLSS support");
+}
diff --git a/examples/helpers/camera_controller.rs b/examples/helpers/camera_controller.rs
index 3f6e4ed477487..806ca9999a565 100644
--- a/examples/helpers/camera_controller.rs
+++ b/examples/helpers/camera_controller.rs
@@ -125,7 +125,7 @@ Freecam Controls:
 }
 
 fn run_camera_controller(
-    time: Res<Time>,
+    time: Res<Time<Real>>,
     mut windows: Query<(&Window, &mut CursorOptions)>,
     accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
     accumulated_mouse_scroll: Res<AccumulatedMouseScroll>,
diff --git a/release-content/release-notes/bevy_solari.md b/release-content/release-notes/bevy_solari.md
index cbb6122b30ece..a3ab9f7de15a0 100644
--- a/release-content/release-notes/bevy_solari.md
+++ b/release-content/release-notes/bevy_solari.md
@@ -1,7 +1,7 @@
 ---
 title: Initial raytraced lighting progress (bevy_solari)
 authors: ["@JMS55", "@SparkyPotato"]
-pull_requests: [19058, 19620, 19790, 20020, 20113, 20156, 20213, 20242, 20259, 20406, 20457, 20580, 20596, 20622, 20659]
+pull_requests: [19058, 19620, 19790, 20020, 20113, 20156, 20213, 20242, 20259, 20406, 20457, 20580, 20596, 20622, 20658, 20659]
 ---
 
 ## Overview
