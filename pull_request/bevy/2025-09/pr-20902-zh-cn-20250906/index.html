<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20902 Constify math
        
    </title><meta content="#20902 Constify math" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-06</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-09/pr-20902-en-20250906>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=constify-math>Constify math</h1><h2 id=ji-ben-xin-xi>基本信息</h2><ul><li><strong>标题</strong>: Constify math<li><strong>PR链接</strong>: https://github.com/bevyengine/bevy/pull/20902<li><strong>作者</strong>: exoego<li><strong>状态</strong>: 已合并<li><strong>标签</strong>: C-Usability, S-Ready-For-Final-Review, A-Math, D-Straightforward<li><strong>创建时间</strong>: 2025-09-06T10:07:29Z<li><strong>合并时间</strong>: 2025-09-06T21:53:38Z<li><strong>合并人</strong>: james7132</ul><h2 id=miao-shu-fan-yi>描述翻译</h2><h1 id=objective>Objective</h1><p>Part of https://github.com/bevyengine/bevy/issues/16124<h2 id=solution>Solution</h2><p>Constify where seems legit and easy to maintain<h2 id=ben-ci-prde-gu-shi>本次PR的故事</h2><p>这个PR是Bevy引擎数学库常量化计划的一部分。问题的核心在于让尽可能多的数学函数能够在编译时求值，从而提升性能和开发体验。<p>在Rust中，<code>const fn</code>允许函数在编译时执行，这意味着一些计算可以从运行时转移到编译时，减少运行时的计算开销。对于数学库来说，这尤其有价值，因为很多几何图元的创建和简单计算都是确定性的，适合在编译时完成。<p>开发者采取了务实的方法：只对那些看起来合理且易于维护的函数进行常量化。这意味着：<ol><li>不改变现有函数的逻辑行为<li>只对确实可以在编译时求值的函数添加<code>const</code>关键字<li>确保实现不会因为常量化而变得复杂难懂</ol><p>从实现来看，这个PR主要涉及几个数学模块的改造：<p>在<code>aspect_ratio.rs</code>中，长宽比相关的构造函数现在可以在编译时验证输入参数：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>try_new</span><span>(</span><span style=color:#ff8f40>width</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>, </span><span style=color:#ff8f40>height</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span>, AspectRatioError>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:  
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>try_new</span><span>(</span><span style=color:#ff8f40>width</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>, </span><span style=color:#ff8f40>height</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span>, AspectRatioError>
</span></code></pre><p>在<code>curve/interval.rs</code>中，区间相关的数学操作现在都是常量函数：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 区间长度计算现在可以在编译时完成
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>length</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>end </span><span style=color:#ed9366>- </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>start
</span><span>}
</span></code></pre><p>在<code>isometry.rs</code>中，等距变换的构造函数现在都是const函数，这使得创建恒等变换或简单变换可以在编译时完成：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 从旋转创建等距变换
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_rotation</span><span>(</span><span style=color:#ff8f40>rotation</span><span style=color:#61676ccc>:</span><span> Quat) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    Isometry3d {
</span><span>        rotation</span><span style=color:#61676ccc>,
</span><span>        translation</span><span style=color:#61676ccc>: </span><span>Vec3A</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>ZERO</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span></code></pre><p>在3D图元相关的<code>primitives/dim3.rs</code>中，各种几何体的构造函数和简单计算方法都被常量化了。这里有一个需要注意的技术细节：为了满足const fn的要求，有些实现需要调整：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>from_size</span><span>(</span><span style=color:#ff8f40>size</span><span style=color:#61676ccc>:</span><span> Vec3) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        half_size</span><span style=color:#61676ccc>:</span><span> size </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_size</span><span>(</span><span style=color:#ff8f40>size</span><span style=color:#61676ccc>:</span><span> Vec3) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        half_size</span><span style=color:#61676ccc>: </span><span>Vec3</span><span style=color:#ed9366>::</span><span>new(size</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>,</span><span> size</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>,</span><span> size</span><span style=color:#ed9366>.</span><span>z </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span>)</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span></code></pre><p>原来的<code>size / 2.0</code>在const context中不被允许，所以需要展开为各个分量的分别计算。<p>这个PR的影响是显著的：现在开发者可以在const context中使用这些数学函数，比如定义编译时常量：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>const </span><span style=color:#ff8f40>UNIT_CUBE</span><span style=color:#61676ccc>:</span><span> Cuboid </span><span style=color:#ed9366>= </span><span>Cuboid</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>1.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1.0</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1.0</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>UNIT_SPHERE</span><span style=color:#61676ccc>:</span><span> Sphere </span><span style=color:#ed9366>=</span><span> Sphere { radius</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>1.0 </span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>这种改变对于需要高性能计算的游戏引擎特别有价值，因为它减少了运行时的计算开销，同时保持了代码的可读性和可维护性。<p>从工程角度看，这个PR展示了如何系统地推进代码库的现代化改造。它不是一次性重写所有内容，而是采取渐进式的方法，逐个模块地进行合理的优化。这种模式值得在其他类似的重构项目中借鉴。<h2 id=ke-shi-hua-biao-shi>可视化表示</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Math Primitives] --> B[3D Shapes]
</span><span>    A --> C[Curves]
</span><span>    A --> D[Transformations]
</span><span>    A --> E[Aspect Ratio]
</span><span>    
</span><span>    B --> F[Sphere]
</span><span>    B --> G[Cuboid] 
</span><span>    B --> H[Cylinder]
</span><span>    B --> I[Capsule]
</span><span>    B --> J[Cone]
</span><span>    B --> K[Torus]
</span><span>    B --> L[Triangle]
</span><span>    B --> M[Tetrahedron]
</span><span>    
</span><span>    C --> N[Interval]
</span><span>    
</span><span>    D --> O[Isometry2d]
</span><span>    D --> P[Isometry3d]
</span></code></pre><h2 id=guan-jian-wen-jian-bian-geng>关键文件变更</h2><h3 id=crates-bevy-math-src-primitives-dim3-rs-19-19><code>crates/bevy_math/src/primitives/dim3.rs</code> (+19/-19)</h3><p>这个文件包含了各种3D几何图元的定义。变更主要是将构造函数和简单访问方法标记为const。<p><strong>关键变更示例：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Sphere直径计算
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>diameter</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#ff8f40>2.0 </span><span style=color:#ed9366>* </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>radius
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>diameter</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#ff8f40>2.0 </span><span style=color:#ed9366>* </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>radius
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Cuboid构造函数
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>from_size</span><span>(</span><span style=color:#ff8f40>size</span><span style=color:#61676ccc>:</span><span> Vec3) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        half_size</span><span style=color:#61676ccc>:</span><span> size </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_size</span><span>(</span><span style=color:#ff8f40>size</span><span style=color:#61676ccc>:</span><span> Vec3) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        half_size</span><span style=color:#61676ccc>: </span><span>Vec3</span><span style=color:#ed9366>::</span><span>new(size</span><span style=color:#ed9366>.</span><span>x </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>,</span><span> size</span><span style=color:#ed9366>.</span><span>y </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span style=color:#61676ccc>,</span><span> size</span><span style=color:#ed9366>.</span><span>z </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>2.0</span><span>)</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-math-src-curve-interval-rs-8-8><code>crates/bevy_math/src/curve/interval.rs</code> (+8/-8)</h3><p>区间数学相关的函数常量化，包括区间创建、长度计算、边界检查等。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 区间长度计算
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>length</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>end </span><span style=color:#ed9366>- </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>start
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>length</span><span>(</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32 </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>end </span><span style=color:#ed9366>- </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>start
</span><span>}
</span></code></pre><h3 id=crates-bevy-math-src-isometry-rs-6-6><code>crates/bevy_math/src/isometry.rs</code> (+6/-6)</h3><p>等距变换的构造函数常量化，使得变换创建可以在编译时完成。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 2D等距变换从坐标创建
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>from_xy</span><span>(</span><span style=color:#ff8f40>x</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>, </span><span style=color:#ff8f40>y</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>from_xy</span><span>(</span><span style=color:#ff8f40>x</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>, </span><span style=color:#ff8f40>y</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>f32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self
</span></code></pre><h3 id=crates-bevy-math-src-aspect-ratio-rs-2-2><code>crates/bevy_math/src/aspect_ratio.rs</code> (+2/-2)</h3><p>长宽比计算的构造函数常量化。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 从像素创建长宽比
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>try_from_pixels</span><span>(</span><span style=color:#ff8f40>x</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>, </span><span style=color:#ff8f40>y</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span>, AspectRatioError>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>try_from_pixels</span><span>(</span><span style=color:#ff8f40>x</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>, </span><span style=color:#ff8f40>y</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Self</span><span>, AspectRatioError>
</span></code></pre><h3 id=crates-bevy-math-src-primitives-polygon-rs-2-2><code>crates/bevy_math/src/primitives/polygon.rs</code> (+2/-2)</h3><p>多边形处理相关的辅助函数常量化。<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 点边关系计算
</span><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>point_side</span><span>(</span><span style=color:#ff8f40>p1</span><span style=color:#61676ccc>:</span><span> Vec2, </span><span style=color:#ff8f40>p2</span><span style=color:#61676ccc>:</span><span> Vec2, </span><span style=color:#ff8f40>q</span><span style=color:#61676ccc>:</span><span> Vec2) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>const fn </span><span style=color:#f29718>point_side</span><span>(</span><span style=color:#ff8f40>p1</span><span style=color:#61676ccc>:</span><span> Vec2, </span><span style=color:#ff8f40>p2</span><span style=color:#61676ccc>:</span><span> Vec2, </span><span style=color:#ff8f40>q</span><span style=color:#61676ccc>:</span><span> Vec2) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>f32
</span></code></pre><h2 id=yan-shen-yue-du>延伸阅读</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/reference/const_eval/const_fn.html target=_blank>Rust Reference: Constant functions</a><li><a rel="noopener nofollow noreferrer" href=https://docs.rs/bevy_math/latest/bevy_math/ target=_blank>Bevy Math Module Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md target=_blank>Rust Const Generics RFC</a></ul><h1 id=wan-zheng-dai-ma-chai-yi>完整代码差异</h1><details><summary>展开查看完整diff</summary> <div><pre class=language-diff data-lang=diff style=color:#61676c;background-color:#fafafa><code class=language-diff data-lang=diff><span>diff --git a/crates/bevy_math/src/aspect_ratio.rs b/crates/bevy_math/src/aspect_ratio.rs
</span><span>index 7b7ae6d3bad04..39cfa9f95c973 100644
</span><span style=color:#c594c5>--- a/crates/bevy_math/src/aspect_ratio.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_math/src/aspect_ratio.rs
</span><span style=color:#c594c5>@@ -33,7 +33,7 @@ </span><span style=color:#399ee6>impl AspectRatio {
</span><span>     /// - Either width or height is infinite (`AspectRatioError::Infinite`)
</span><span>     /// - Either width or height is NaN (`AspectRatioError::NaN`)
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn try_new(width: f32, height: f32) -> Result&LTSelf, AspectRatioError> {
</span><span style=color:#86b300>+    pub const fn try_new(width: f32, height: f32) -> Result&LTSelf, AspectRatioError> {
</span><span>         match (width, height) {
</span><span>             (w, h) if w == 0.0 || h == 0.0 => Err(AspectRatioError::Zero),
</span><span>             (w, h) if w.is_infinite() || h.is_infinite() => Err(AspectRatioError::Infinite),
</span><span style=color:#c594c5>@@ -44,7 +44,7 @@ </span><span style=color:#399ee6>impl AspectRatio {
</span><span> 
</span><span>     /// Attempts to create a new [`AspectRatio`] from a given amount of x pixels and y pixels.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn try_from_pixels(x: u32, y: u32) -> Result&LTSelf, AspectRatioError> {
</span><span style=color:#86b300>+    pub const fn try_from_pixels(x: u32, y: u32) -> Result&LTSelf, AspectRatioError> {
</span><span>         Self::try_new(x as f32, y as f32)
</span><span>     }
</span><span> 
</span><span>diff --git a/crates/bevy_math/src/curve/interval.rs b/crates/bevy_math/src/curve/interval.rs
</span><span>index 03ffc0c486462..aeea24ca46054 100644
</span><span style=color:#c594c5>--- a/crates/bevy_math/src/curve/interval.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_math/src/curve/interval.rs
</span><span style=color:#c594c5>@@ -61,7 +61,7 @@ </span><span style=color:#399ee6>impl Interval {
</span><span>     /// but cannot be empty (so `start` must be less than `end`) and neither endpoint can be NaN; invalid
</span><span>     /// parameters will result in an error.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn new(start: f32, end: f32) -> Result&LTSelf, InvalidIntervalError> {
</span><span style=color:#86b300>+    pub const fn new(start: f32, end: f32) -> Result&LTSelf, InvalidIntervalError> {
</span><span>         if start >= end || start.is_nan() || end.is_nan() {
</span><span>             Err(InvalidIntervalError)
</span><span>         } else {
</span><span style=color:#c594c5>@@ -103,7 +103,7 @@ </span><span style=color:#399ee6>impl Interval {
</span><span> 
</span><span>     /// Get the length of this interval. Note that the result may be infinite (`f32::INFINITY`).
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn length(self) -> f32 {
</span><span style=color:#86b300>+    pub const fn length(self) -> f32 {
</span><span>         self.end - self.start
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -111,19 +111,19 @@ </span><span style=color:#399ee6>impl Interval {
</span><span>     ///
</span><span>     /// Equivalently, an interval is bounded if its length is finite.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn is_bounded(self) -> bool {
</span><span style=color:#86b300>+    pub const fn is_bounded(self) -> bool {
</span><span>         self.length().is_finite()
</span><span>     }
</span><span> 
</span><span>     /// Returns `true` if this interval has a finite start.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn has_finite_start(self) -> bool {
</span><span style=color:#86b300>+    pub const fn has_finite_start(self) -> bool {
</span><span>         self.start.is_finite()
</span><span>     }
</span><span> 
</span><span>     /// Returns `true` if this interval has a finite end.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn has_finite_end(self) -> bool {
</span><span style=color:#86b300>+    pub const fn has_finite_end(self) -> bool {
</span><span>         self.end.is_finite()
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -137,13 +137,13 @@ </span><span style=color:#399ee6>impl Interval {
</span><span>     ///
</span><span>     /// This is non-strict: each interval will contain itself.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn contains_interval(self, other: Self) -> bool {
</span><span style=color:#86b300>+    pub const fn contains_interval(self, other: Self) -> bool {
</span><span>         self.start <= other.start && self.end >= other.end
</span><span>     }
</span><span> 
</span><span>     /// Clamp the given `value` to lie within this interval.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn clamp(self, value: f32) -> f32 {
</span><span style=color:#86b300>+    pub const fn clamp(self, value: f32) -> f32 {
</span><span>         value.clamp(self.start, self.end)
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -196,7 +196,7 @@ </span><span style=color:#399ee6>impl TryFrom&LTRangeInclusive&LTf32>> for Interval {
</span><span> 
</span><span> /// Create an [`Interval`] with a given `start` and `end`. Alias of [`Interval::new`].
</span><span> #[inline]
</span><span style=color:#f07171>-pub fn interval(start: f32, end: f32) -> Result&LTInterval, InvalidIntervalError> {
</span><span style=color:#86b300>+pub const fn interval(start: f32, end: f32) -> Result&LTInterval, InvalidIntervalError> {
</span><span>     Interval::new(start, end)
</span><span> }
</span><span> 
</span><span>diff --git a/crates/bevy_math/src/isometry.rs b/crates/bevy_math/src/isometry.rs
</span><span>index a221615b0a5bb..47de2363a17cd 100644
</span><span style=color:#c594c5>--- a/crates/bevy_math/src/isometry.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_math/src/isometry.rs
</span><span style=color:#c594c5>@@ -110,7 +110,7 @@ </span><span style=color:#399ee6>impl Isometry2d {
</span><span> 
</span><span>     /// Create a two-dimensional isometry from a rotation and a translation.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn new(translation: Vec2, rotation: Rot2) -> Self {
</span><span style=color:#86b300>+    pub const fn new(translation: Vec2, rotation: Rot2) -> Self {
</span><span>         Isometry2d {
</span><span>             rotation,
</span><span>             translation,
</span><span style=color:#c594c5>@@ -119,7 +119,7 @@ </span><span style=color:#399ee6>impl Isometry2d {
</span><span> 
</span><span>     /// Create a two-dimensional isometry from a rotation.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn from_rotation(rotation: Rot2) -> Self {
</span><span style=color:#86b300>+    pub const fn from_rotation(rotation: Rot2) -> Self {
</span><span>         Isometry2d {
</span><span>             rotation,
</span><span>             translation: Vec2::ZERO,
</span><span style=color:#c594c5>@@ -128,7 +128,7 @@ </span><span style=color:#399ee6>impl Isometry2d {
</span><span> 
</span><span>     /// Create a two-dimensional isometry from a translation.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn from_translation(translation: Vec2) -> Self {
</span><span style=color:#86b300>+    pub const fn from_translation(translation: Vec2) -> Self {
</span><span>         Isometry2d {
</span><span>             rotation: Rot2::IDENTITY,
</span><span>             translation,
</span><span style=color:#c594c5>@@ -137,7 +137,7 @@ </span><span style=color:#399ee6>impl Isometry2d {
</span><span> 
</span><span>     /// Create a two-dimensional isometry from a translation with the given `x` and `y` components.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn from_xy(x: f32, y: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn from_xy(x: f32, y: f32) -> Self {
</span><span>         Isometry2d {
</span><span>             rotation: Rot2::IDENTITY,
</span><span>             translation: Vec2::new(x, y),
</span><span style=color:#c594c5>@@ -397,7 +397,7 @@ </span><span style=color:#399ee6>impl Isometry3d {
</span><span> 
</span><span>     /// Create a three-dimensional isometry from a rotation.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn from_rotation(rotation: Quat) -> Self {
</span><span style=color:#86b300>+    pub const fn from_rotation(rotation: Quat) -> Self {
</span><span>         Isometry3d {
</span><span>             rotation,
</span><span>             translation: Vec3A::ZERO,
</span><span style=color:#c594c5>@@ -415,7 +415,7 @@ </span><span style=color:#399ee6>impl Isometry3d {
</span><span> 
</span><span>     /// Create a three-dimensional isometry from a translation with the given `x`, `y`, and `z` components.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn from_xyz(x: f32, y: f32, z: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn from_xyz(x: f32, y: f32, z: f32) -> Self {
</span><span>         Isometry3d {
</span><span>             rotation: Quat::IDENTITY,
</span><span>             translation: Vec3A::new(x, y, z),
</span><span>diff --git a/crates/bevy_math/src/primitives/dim3.rs b/crates/bevy_math/src/primitives/dim3.rs
</span><span>index e40e0e2f1fe5a..97ff85bcd6511 100644
</span><span style=color:#c594c5>--- a/crates/bevy_math/src/primitives/dim3.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_math/src/primitives/dim3.rs
</span><span style=color:#c594c5>@@ -50,7 +50,7 @@ </span><span style=color:#399ee6>impl Sphere {
</span><span> 
</span><span>     /// Get the diameter of the sphere
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn diameter(&self) -> f32 {
</span><span style=color:#86b300>+    pub const fn diameter(&self) -> f32 {
</span><span>         2.0 * self.radius
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -430,13 +430,13 @@ </span><span style=color:#399ee6>impl Segment3d {
</span><span> 
</span><span>     /// Get the position of the first endpoint of the line segment.
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn point1(&self) -> Vec3 {
</span><span style=color:#86b300>+    pub const fn point1(&self) -> Vec3 {
</span><span>         self.vertices[0]
</span><span>     }
</span><span> 
</span><span>     /// Get the position of the second endpoint of the line segment.
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn point2(&self) -> Vec3 {
</span><span style=color:#86b300>+    pub const fn point2(&self) -> Vec3 {
</span><span>         self.vertices[1]
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -696,15 +696,15 @@ </span><span style=color:#399ee6>impl Default for Cuboid {
</span><span> impl Cuboid {
</span><span>     /// Create a new `Cuboid` from a full x, y, and z length
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn new(x_length: f32, y_length: f32, z_length: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn new(x_length: f32, y_length: f32, z_length: f32) -> Self {
</span><span>         Self::from_size(Vec3::new(x_length, y_length, z_length))
</span><span>     }
</span><span> 
</span><span>     /// Create a new `Cuboid` from a given full size
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn from_size(size: Vec3) -> Self {
</span><span style=color:#86b300>+    pub const fn from_size(size: Vec3) -> Self {
</span><span>         Self {
</span><span style=color:#f07171>-            half_size: size / 2.0,
</span><span style=color:#86b300>+            half_size: Vec3::new(size.x / 2.0, size.y / 2.0, size.z / 2.0),
</span><span>         }
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -719,7 +719,7 @@ </span><span style=color:#399ee6>impl Cuboid {
</span><span>     /// Create a `Cuboid` from a single length.
</span><span>     /// The resulting `Cuboid` will be the same size in every direction.
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn from_length(length: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn from_length(length: f32) -> Self {
</span><span>         Self {
</span><span>             half_size: Vec3::splat(length / 2.0),
</span><span>         }
</span><span style=color:#c594c5>@@ -792,7 +792,7 @@ </span><span style=color:#399ee6>impl Default for Cylinder {
</span><span> impl Cylinder {
</span><span>     /// Create a new `Cylinder` from a radius and full height
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn new(radius: f32, height: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn new(radius: f32, height: f32) -> Self {
</span><span>         Self {
</span><span>             radius,
</span><span>             half_height: height / 2.0,
</span><span style=color:#c594c5>@@ -801,7 +801,7 @@ </span><span style=color:#399ee6>impl Cylinder {
</span><span> 
</span><span>     /// Get the base of the cylinder as a [`Circle`]
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn base(&self) -> Circle {
</span><span style=color:#86b300>+    pub const fn base(&self) -> Circle {
</span><span>         Circle {
</span><span>             radius: self.radius,
</span><span>         }
</span><span style=color:#c594c5>@@ -811,7 +811,7 @@ </span><span style=color:#399ee6>impl Cylinder {
</span><span>     /// also known as the lateral area
</span><span>     #[inline(always)]
</span><span>     #[doc(alias = "side_area")]
</span><span style=color:#f07171>-    pub fn lateral_area(&self) -> f32 {
</span><span style=color:#86b300>+    pub const fn lateral_area(&self) -> f32 {
</span><span>         4.0 * PI * self.radius * self.half_height
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -871,7 +871,7 @@ </span><span style=color:#399ee6>impl Default for Capsule3d {
</span><span> 
</span><span> impl Capsule3d {
</span><span>     /// Create a new `Capsule3d` from a radius and length
</span><span style=color:#f07171>-    pub fn new(radius: f32, length: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn new(radius: f32, length: f32) -> Self {
</span><span>         Self {
</span><span>             radius,
</span><span>             half_length: length / 2.0,
</span><span style=color:#c594c5>@@ -881,7 +881,7 @@ </span><span style=color:#399ee6>impl Capsule3d {
</span><span>     /// Get the part connecting the hemispherical ends
</span><span>     /// of the capsule as a [`Cylinder`]
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn to_cylinder(&self) -> Cylinder {
</span><span style=color:#86b300>+    pub const fn to_cylinder(&self) -> Cylinder {
</span><span>         Cylinder {
</span><span>             radius: self.radius,
</span><span>             half_height: self.half_length,
</span><span style=color:#c594c5>@@ -941,12 +941,12 @@ </span><span style=color:#399ee6>impl Default for Cone {
</span><span> 
</span><span> impl Cone {
</span><span>     /// Create a new [`Cone`] from a radius and height.
</span><span style=color:#f07171>-    pub fn new(radius: f32, height: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn new(radius: f32, height: f32) -> Self {
</span><span>         Self { radius, height }
</span><span>     }
</span><span>     /// Get the base of the cone as a [`Circle`]
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn base(&self) -> Circle {
</span><span style=color:#86b300>+    pub const fn base(&self) -> Circle {
</span><span>         Circle {
</span><span>             radius: self.radius,
</span><span>         }
</span><span style=color:#c594c5>@@ -1087,7 +1087,7 @@ </span><span style=color:#399ee6>impl Torus {
</span><span>     /// The inner radius is the radius of the hole, and the outer radius
</span><span>     /// is the radius of the entire object
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn new(inner_radius: f32, outer_radius: f32) -> Self {
</span><span style=color:#86b300>+    pub const fn new(inner_radius: f32, outer_radius: f32) -> Self {
</span><span>         let minor_radius = (outer_radius - inner_radius) / 2.0;
</span><span>         let major_radius = outer_radius - minor_radius;
</span><span> 
</span><span style=color:#c594c5>@@ -1101,7 +1101,7 @@ </span><span style=color:#399ee6>impl Torus {
</span><span>     /// For a ring torus, this corresponds to the radius of the hole,
</span><span>     /// or `major_radius - minor_radius`
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn inner_radius(&self) -> f32 {
</span><span style=color:#86b300>+    pub const fn inner_radius(&self) -> f32 {
</span><span>         self.major_radius - self.minor_radius
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -1109,7 +1109,7 @@ </span><span style=color:#399ee6>impl Torus {
</span><span>     /// This corresponds to the overall radius of the entire object,
</span><span>     /// or `major_radius + minor_radius`
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn outer_radius(&self) -> f32 {
</span><span style=color:#86b300>+    pub const fn outer_radius(&self) -> f32 {
</span><span>         self.major_radius + self.minor_radius
</span><span>     }
</span><span> 
</span><span style=color:#c594c5>@@ -1191,7 +1191,7 @@ </span><span style=color:#399ee6>impl Default for Triangle3d {
</span><span> impl Triangle3d {
</span><span>     /// Create a new [`Triangle3d`] from points `a`, `b`, and `c`.
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn new(a: Vec3, b: Vec3, c: Vec3) -> Self {
</span><span style=color:#86b300>+    pub const fn new(a: Vec3, b: Vec3, c: Vec3) -> Self {
</span><span>         Self {
</span><span>             vertices: [a, b, c],
</span><span>         }
</span><span style=color:#c594c5>@@ -1388,7 +1388,7 @@ </span><span style=color:#399ee6>impl Default for Tetrahedron {
</span><span> impl Tetrahedron {
</span><span>     /// Create a new [`Tetrahedron`] from points `a`, `b`, `c` and `d`.
</span><span>     #[inline(always)]
</span><span style=color:#f07171>-    pub fn new(a: Vec3, b: Vec3, c: Vec3, d: Vec3) -> Self {
</span><span style=color:#86b300>+    pub const fn new(a: Vec3, b: Vec3, c: Vec3, d: Vec3) -> Self {
</span><span>         Self {
</span><span>             vertices: [a, b, c, d],
</span><span>         }
</span><span>diff --git a/crates/bevy_math/src/primitives/polygon.rs b/crates/bevy_math/src/primitives/polygon.rs
</span><span>index 096a19ecfb9aa..a95461d11aa45 100644
</span><span style=color:#c594c5>--- a/crates/bevy_math/src/primitives/polygon.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_math/src/primitives/polygon.rs
</span><span style=color:#c594c5>@@ -174,7 +174,7 @@ </span><span style=color:#399ee6>struct SweepLine<'a> {
</span><span> }
</span><span> #[cfg(feature = "alloc")]
</span><span> impl<'a> SweepLine<'a> {
</span><span style=color:#f07171>-    fn new(vertices: &'a [Vec2]) -> Self {
</span><span style=color:#86b300>+    const fn new(vertices: &'a [Vec2]) -> Self {
</span><span>         Self {
</span><span>             vertices,
</span><span>             tree: BTreeMap::new(),
</span><span style=color:#c594c5>@@ -271,7 +271,7 @@ </span><span style=color:#399ee6>impl<'a> SweepLine<'a> {
</span><span>     )
</span><span> )]
</span><span> #[inline(always)]
</span><span style=color:#f07171>-fn point_side(p1: Vec2, p2: Vec2, q: Vec2) -> f32 {
</span><span style=color:#86b300>+const fn point_side(p1: Vec2, p2: Vec2, q: Vec2) -> f32 {
</span><span>     (p2.x - p1.x) * (q.y - p1.y) - (q.x - p1.x) * (p2.y - p1.y)
</span><span> }
</span><span> 
</span><span>diff --git a/crates/bevy_math/src/rotation2d.rs b/crates/bevy_math/src/rotation2d.rs
</span><span>index bcaf7f63b0dec..21839af6b6f01 100644
</span><span style=color:#c594c5>--- a/crates/bevy_math/src/rotation2d.rs
</span><span style=color:#c594c5>+++ b/crates/bevy_math/src/rotation2d.rs
</span><span style=color:#c594c5>@@ -336,13 +336,13 @@ </span><span style=color:#399ee6>impl Rot2 {
</span><span> 
</span><span>     /// Returns `true` if the rotation is neither infinite nor NaN.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn is_finite(self) -> bool {
</span><span style=color:#86b300>+    pub const fn is_finite(self) -> bool {
</span><span>         self.sin.is_finite() && self.cos.is_finite()
</span><span>     }
</span><span> 
</span><span>     /// Returns `true` if the rotation is NaN.
</span><span>     #[inline]
</span><span style=color:#f07171>-    pub fn is_nan(self) -> bool {
</span><span style=color:#86b300>+    pub const fn is_nan(self) -> bool {
</span><span>         self.sin.is_nan() || self.cos.is_nan()
</span><span>     }
</span><span> 
</span></code></pre></div></details></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_20902.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>