diff --git a/release-content/release-notes/bevy_solari.md b/release-content/release-notes/bevy_solari.md
index 79fe344c618a2..bd3acd0deab9c 100644
--- a/release-content/release-notes/bevy_solari.md
+++ b/release-content/release-notes/bevy_solari.md
@@ -22,7 +22,7 @@ The problem with these methods is that they all have large downsides:
 
 * Emissive meshes do not cast light onto other objects, either direct or indirect.
 * Shadow maps are very expensive to render and consume a lot of memory, so you're limited to using only a few shadow casting lights. Good shadow quality can be difficult to obtain in large scenes.
-* Baked lighting does not update in realtime as objects and lights move around, is low resolution/quality, and requires time to bake, slowing down game production.
+* Baked lighting does not update in realtime as objects and lights move around and requires time to bake, slowing down game production.
 * Screen-space methods have low quality and do not capture off-screen geometry and light.
 
 Bevy Solari is intended as a completely alternate, high-end lighting solution for Bevy that uses GPU-accelerated raytracing to fix all of the above problems. Emissive meshes properly cast light and shadows, you can have hundreds of shadow casting lights, quality is much better, it requires no baking time, and it supports _fully_ dynamic scenes!
diff --git a/release-content/release-notes/constructor_functions_for_val_variants.md b/release-content/release-notes/constructor_functions_for_val_variants.md
index 4b23355d86d79..cf517bf9c86f7 100644
--- a/release-content/release-notes/constructor_functions_for_val_variants.md
+++ b/release-content/release-notes/constructor_functions_for_val_variants.md
@@ -4,7 +4,22 @@ authors: ["@Ickshonpe", "@TheBlckbird"]
 pull_requests: [20518, 20551, 20937]
 ---
 
-To make `Val`s easier to construct the following helper functions have been added: `px`, `percent`, `vw`, `vh`, `vmin` and `vmax`. Each function takes any integer type and returns the value wrapped by its corresponding `Val` variant. There is also an `auto` helper function that maps to `Val::Auto`.
+To make `Val`s easier to construct the following helper functions have been added: `px`, `percent`, `vw`, `vh`, `vmin` and `vmax`:
+
+```rust
+// Using Val::Px directly:
+Node {
+    width: Val::Px(200.),
+    ..default()
+}
+// Using the px() helper:
+Node {
+    width: px(200),
+    ..default()
+}
+```
+
+Each function takes any integer type and returns the value wrapped by its corresponding `Val` variant. There is also an `auto` helper function that maps to `Val::Auto`.
 
 Also included with this release is a fluent interface for constructing `UiRect`s from `Val`s:
 
diff --git a/release-content/release-notes/dlss.md b/release-content/release-notes/dlss.md
index 0310d4729e865..8ca75ead37e15 100644
--- a/release-content/release-notes/dlss.md
+++ b/release-content/release-notes/dlss.md
@@ -15,7 +15,7 @@ Compared to Bevy's built-in TAA, DLSS:
 * Produces higher quality and more stable images
 * Supports upscaling in addition to anti-aliasing, leading to much cheaper render times, particularly when used with GPU-heavy features like Bevy Solari
 * Requires a NVIDIA RTX GPU
-* Requires running via the Vulkan backend on Windows/Linux (no macOS, web, or mobile support)
+* Currently requires running via the Vulkan backend on Windows/Linux (no macOS, web, or mobile support)
 
 To use DLSS in your app:
 
diff --git a/release-content/release-notes/entity-spawn-ticks.md b/release-content/release-notes/entity-spawn-ticks.md
index aa319cb2a1158..cc1503df81521 100644
--- a/release-content/release-notes/entity-spawn-ticks.md
+++ b/release-content/release-notes/entity-spawn-ticks.md
@@ -4,50 +4,49 @@ authors: ["@urben1680", "@specificprotagonist"]
 pull_requests: [19047, 19350]
 ---
 
-Keeping track which entities have been spawned since the last time a system ran could only be done indirectly by inserting marker components and do your logic on entities that match an `Added<MyMarker>` filter or in `MyMarker`'s `on_add` hook.
-
-This has the issue however: add events react to component insertions on existing entities too. Sometimes you cannot even add your marker because the spawn call is hidden in some non-public API.
+In previous versions of Bevy, keeping track of which entities have been spawned since the last time a system ran could only be done indirectly by writing your own logic.
 
 The new `SpawnDetails` query data and `Spawned` query filter enable you to find recently spawned entities without any marker components.
 
 ## `SpawnDetails`
 
-Use this in your query when you want to get information about the entity's spawn. You might want to do that for debug purposes, using the struct's `Debug` implementation.
-
-You can also get specific information via methods. The following example prints the entity id (prefixed with "new" if it showed up for the first time), the `Tick` it spawned at and, if the `track_location` feature is activated, the source code location where it was spawned. Said feature is not enabled by default because it comes with a runtime cost.
+Use this in your query when you want to get information about the entity's spawn:
 
 ```rs
 fn print_spawn_details(query: Query<(Entity, SpawnDetails)>) {
     for (entity, spawn_details) in &query {
         if spawn_details.is_spawned() {
-            print!("new ");
+            print!(
+                "new entity {entity:?} spawned at {:?}",
+                spawn_details.spawn_tick()
+            );
+            // if the `track_location` cargo feature is activated, this contains the source
+            // code location where this entity was spawned. This has a runtime cost, so only
+            // use it for debugging!
+            match spawn_details.spawned_by().into_option() {
+                Some(location) => println!(" by {location:?}"),
+                None => println!()
+            }    
         }
-        print!(
-            "entity {entity:?} spawned at {:?}",
-            spawn_details.spawned_at()
-        );
-        match spawn_details.spawned_by().into_option() {
-            Some(location) => println!(" by {location:?}"),
-            None => println!()
-        }    
     }
 }
 ```
 
 ## `Spawned`
 
-Use this filter in your query if you are only interested in entities that were spawned after the last time your system ran.
-
-Note that this, like `Added<T>` and `Changed<T>`, is a non-archetypal filter. This means that your query could still go through millions of entities without yielding any recently spawned ones. Unlike filters like `With<T>` which can easily skip all entities that do not have `T` without checking them one-by-one.
-
-Because of this, these systems have roughly the same performance:
+Use this filter in your query if you are only interested in entities that were spawned after the last time your system ran:
 
-```rs
-fn system1(query: Query<Entity, Spawned>) {
+```rust
+fn system(query: Query<Entity, Spawned>) {
     for entity in &query { /* entity spawned */ }
 }
+```
+
+Note that, much like `Added` and `Changed` filters, this is a "non archetypal filter", meaning it requires scanning every entity matching the query, including those that weren't spawned since the last run.
+Because of this, the system above performs roughly the same as this one:
 
-fn system2(query: Query<(Entity, SpawnDetails)>) {
+```rust
+fn system(query: Query<(Entity, SpawnDetails)>) {
     for (entity, spawned) in &query {
         if spawned.is_spawned() { /* entity spawned */ }
     }
@@ -56,27 +55,8 @@ fn system2(query: Query<(Entity, SpawnDetails)>) {
 
 ## Getter methods
 
-Getting around this weakness of non-archetypal filters can be to check only specific entities for their spawn tick: The method `spawned_at` was added to all entity pointer structs, such as `EntityRef`, `EntityMut` and `EntityWorldMut`.
+You can also use helper methods on `EntityWorldMut` and `EntityCommands`:
 
-In this example we want to filter for entities that were spawned after a certain `tick`:
-
-```rs
-fn filter_spawned_after(
-    entities: impl IntoIterator<Item = Entity>,
-    world: &World,
-    tick: Tick,
-) -> impl Iterator<Item = Entity> {
-    let now = world.last_change_tick();
-    entities.into_iter().filter(move |entity| world
-        .entity(*entity)
-        .spawned_at()
-        .is_newer_than(tick, now)
-    )
-}
+```rust
+world.entity(entity).spawn_tick()
 ```
-
----
-
-The tick is stored in `Entities`. It's method `entity_get_spawned_or_despawned_at` not only returns when a living entity spawned at, it also returns when a despawned entity found it's bitter end.
-
-Note however that despawned entities can be replaced by Bevy at any following spawn. Then this method returns `None` for the despawned entity. The same is true if the entity is not even spawned yet, only allocated.
diff --git a/release-content/release-notes/feathers.md b/release-content/release-notes/feathers.md
index ad8677ab0ddf8..94107a2250123 100644
--- a/release-content/release-notes/feathers.md
+++ b/release-content/release-notes/feathers.md
@@ -7,29 +7,30 @@ pull_requests: [19730, 19900, 19928, 20237, 20169, 20422, 20350, 20548, 20969]
 TODO: add screenshot of `feathers` in practice
 
 To make it easier for Bevy engine developers and third-party tool creators to make comfortable, visually cohesive tooling,
-we're pleased to introduce "Feathers" - a comprehensive widget set that offers:
-
-- Standard widgets designed to match the look and feel of the planned Bevy Editor
-- Components that can be leveraged to build custom editors, inspectors, and utility interfaces
-- Essential UI elements including buttons, sliders, checkboxes, menu buttons, and more
-- Layout containers for organizing and structuring UI elements
-- Decorative elements such as icons for visual enhancement
-- Robust-if-primitive theming support ensuring consistent visual styling across applications
-- Accessibility features with built-in screen reader and assistive technology support
-- Interactive cursor behavior that changes appropriately when hovering over widgets
-- A virtual keyboard suitable for touchscreen text input
-
-Feathers isn't meant as a toolkit for building exciting and cool game UIs: it has a somewhat plain
-and utilitarian look and feel suitable for editors and graphical utilities. That being said, using
-the themeing framework, you can spice up the colors quite a bit.
-
-This is still early in development, and is currently hidden behind an experimental feature flag:
-`experimental_bevy_feathers`.
-If you're looking to experiment with building tooling for Bevy, turn that on and use `feathers` as is!
+we're pleased to introduce "Feathers" - a comprehensive Bevy UI widget set. Feathers is meant to be Bevy's "developer tools" widget set, and it will be used to build the upcoming [Bevy Editor](https://bevy.org/news/bevys-fifth-birthday/#bevy-editor-design). It has a utilitarian look and feel, with an opinionated feature-set tailored for editors and graphical utilities. It builds on top of Bevy's new general-purpose "headless" widget set: `bevy_ui_widgets`. Feathers _can_ be used in games, but that is not its motivating use case.
+
+Feathers currently offers:
+
+- Standard widgets designed to match the look and feel of the planned Bevy Editor.
+- Components that can be leveraged to build custom editors, inspectors, and utility interfaces that feel consistent with other Bevy tooling.
+- Essential UI elements including buttons, sliders, checkboxes, menu buttons, and more.
+- Layout containers for organizing and structuring UI elements.
+- Decorative elements such as icons for visual enhancement.
+- Initial (simple / primitive) theme support to ensure consistent, configurable visual styling across applications. This is not the "final" Bevy UI theme system, but it provides some baseline functionality.
+- Accessibility features with built-in screen reader and assistive technology support.
+- Interactive cursor behavior that changes appropriately when hovering over widgets.
+- A virtual keyboard suitable for touchscreen text input.
+
+Feathers is still early in development. It is currently hidden behind the `experimental_bevy_feathers` feature flag. Feathers is still incomplete and likely to change in a variety of ways:
+
+- We will port Feathers to BSN (Bevy's [Next-Generation Scene/UI System](https://github.com/bevyengine/bevy/pull/20158/)) when that lands (targeted for **Bevy 0.18**).
+- We are still discussing the best way to handle UI callbacks / events in Feathers. It includes a proposal API, but the debate is ongoing!
+- We are still working on polishing up some UX issues.
+- There are missing widgets and features. Notably the "text input" widget is still being developed.
+
+If you're looking to experiment with building tooling for Bevy, enable it and take `feathers` for a test flight!
 Let us know what problems you run into, and feel free to contribute missing widgets and bugs upstream.
 
-But if you can't wait to get your hands on `bevy_ui` widgets for your game,
-copy the code into your project and start hacking away at it!
-While it deliberately does not expose very many tuning levers (keeping a coherent visual style in an open source project is _hard_),
-it's a helpful base to understand how to extend and style `bevy_ui` and our new headless widgets
-to meet the unique style and design patterns of your project.
+If you can't wait to get your hands on `bevy_ui` widgets for your game,
+we recommend copying the Feathers code into your project and start hacking away at it!
+Feathers can serve as a helpful base to understand how to build and theme widgets in Bevy UI. It also illustrates how to use our new "headless" widget set: `bevy_ui_widgets`.
diff --git a/release-content/release-notes/frame_time_graph.md b/release-content/release-notes/frame_time_graph.md
index 2fc1f8fb6c2c2..c23abf14570db 100644
--- a/release-content/release-notes/frame_time_graph.md
+++ b/release-content/release-notes/frame_time_graph.md
@@ -6,13 +6,11 @@ pull_requests: [12561, 19277]
 
 (TODO: Embed frame time graph gif from 12561)
 
-Frame time is often more important to know than FPS but because of the temporal nature of it, just seeing a number is not enough.
-Seeing a graph that shows the history makes it easier to reason about performance.
+When measuring a game's performance, just seeing a number is often not enough. Seeing a graph that shows the history makes it easier to reason about performance. **Bevy 0.17** introduces a new visual "frame time graph" to solve this problem!
 
-Enable the `bevy_dev_tools` feature, and add in `FpsOverlayPlugin` to add a bar graph of the frame time history.
-Each bar is scaled based on the frame time where a bigger frame time will give a taller and wider bar.
+To display the frame time graph, enable the `bevy_dev_tools` cargo feature and add in `FpsOverlayPlugin`:
 
-The color also scales with that frame time where red is at or bellow the minimum target fps and green is at or above the target maximum frame rate.
+This displays "frame time" not "frames per second", so a longer frame time results in a bigger and wider bar. The color also scales with that frame time. Red is at or bellow the minimum target fps and green is at or above the target maximum frame rate.
 Anything between those 2 values will be interpolated between green and red based on the frame time.
 
 The algorithm is highly inspired by [Adam Sawicki's article on visualizing frame times](https://asawicki.info/news_1758_an_idea_for_visualization_of_frame_times).
diff --git a/release-content/release-notes/generic_component_propagation.md b/release-content/release-notes/generic_component_propagation.md
index 4a13508ffbf05..b63c8f1cfabbe 100644
--- a/release-content/release-notes/generic_component_propagation.md
+++ b/release-content/release-notes/generic_component_propagation.md
@@ -10,9 +10,11 @@ but users have had to reinvent the wheel every time they wanted to use similar p
 
 While this pain was most acute when working with [`RenderLayers`], this pattern is more broadly useful,
 and has been exposed to end users in the form of the [`HierarchyPropagatePlugin`].
-You might use this for synchronizing color and alpha values for "ghost" versions of previewed buildings,
-ensuring that all of the parts of a model are on the same render layer,
-or propagating font styles.
+Some example use cases:
+
+- Synchronizing color and alpha values for "ghost" versions of previewed buildings
+- Ensuring that all of the parts of a model are on the same render layer
+- Propagating font styles
 
 This plugin has three generics:
 
diff --git a/release-content/release-notes/headless-widgets.md b/release-content/release-notes/headless-widgets.md
index 4ef7c90f6bb16..9ec54207d1f7c 100644
--- a/release-content/release-notes/headless-widgets.md
+++ b/release-content/release-notes/headless-widgets.md
@@ -28,7 +28,8 @@ sliders, scrollbars, checkboxes, radio buttons, and more. This set will likely b
 future releases.
 
 While these widgets are usable today, and are a solid choice for creating your own widgets for your
-own game or application, they are still **experimental**.
+own game or application, they are still **experimental**. We are still polishing up some aspects of the
+developer experience and filling in gaps.
 Expect breaking changes as we continue to iterate and improve on them!
 
 We're as excited as you are for first-party widgets,
@@ -71,17 +72,9 @@ expansion toggle).
 
 ## Widget Notifications
 
-Applications need a way to be notified when the user interacts with a widget. One way to do this
-is using Bevy observers. This approach is useful in cases where you want the widget notifications
-to bubble up the hierarchy.
-
-However, in UI work it's often desirable to send notifications "point-to-point" in ways that cut
-across the hierarchy. For these kinds of situations, the standard widgets offer a different
-approach: callbacks. The `Callback` enum allows different options for triggering a notification
-when a widget's state is updated. For example, you can pass in the `SystemId` of a registered
-one-shot system as a widget parameter when it is constructed. When the button subsequently
-gets clicked or the slider is dragged, the system gets run. Because it's an ECS system, it can
-inject any additional parameters it needs to update the Bevy world in response to the interaction.
+Applications need a way to be notified when the user interacts with a widget. Currently in `bevy_ui_widgets`
+we're experimenting with a `Callback` system, which uses "one shot systems" under the hood. We're also heavily
+considering using Events / Observers for this. This is one of the primary reasons for the "experimental" label!
 
 ## State Management
 
diff --git a/release-content/release-notes/hot_patching.md b/release-content/release-notes/hot_patching.md
index bcbc085c40d01..6f0b0fd27a2ba 100644
--- a/release-content/release-notes/hot_patching.md
+++ b/release-content/release-notes/hot_patching.md
@@ -4,18 +4,20 @@ authors: ["@mockersf"]
 pull_requests: [19309]
 ---
 
-Bevy now supports hot patching systems through subsecond from the Dixous project.
+Bevy now supports hot patching systems via [subsecond](https://crates.io/crates/subsecond) and the [`dx`](https://crates.io/crates/dioxus-cli) command line tool from the Dioxus project.
 
-Enabled with the feature `hotpatching`, every system can now be modified during execution, and the change directly visible in your game.
+When the cargo feature `hotpatching` is enabled, every system can now be modified during execution, and the changes are immediately visible in your game.
 
-Run `BEVY_ASSET_ROOT="." dx serve --hot-patch --example hotpatching_systems --features hotpatching` to test it.
-
-`dx` is the Dioxus CLI, to install it run `cargo install dioxus-cli@0.7.0-alpha.1`
+`dx` is the Dioxus CLI. To install it run `cargo install dioxus-cli@0.7.0-alpha.1`
 TODO: use the fixed version that will match the version of subsecond dependency used in Bevy at release time
 
-Known limitations:
+Then run `BEVY_ASSET_ROOT="." dx serve --hot-patch --features "bevy/hotpatching"` to test it in your project. You can also try it out using Bevy's [`hotpatching_systems.rs`](https://github.com/bevyengine/bevy/blob/release-0.17.0/examples/ecs/hotpatching_systems.rs) example.
+
+This is just the first step. There are known limitations:
+
+- Only works on the binary crate. Dioxus has plans to expand support here.
+- Not supported in Wasm. Dioxus supports this, but the Bevy side needs some work.
+- If the system's parameters change, it will not be hot reloaded. This is something we need to work out on the Bevy side.
+- It may be sensitive to rust/linker configuration. Dioxus is already pretty good about this though!
 
-- Only works on the binary crate (todo: plan to support it in Dioxus)
-- Not supported in Wasm (todo: supported in Dioxus but not yet implemented in Bevy)
-- No system signature change support (todo: add that in Bevy)
-- May be sensitive to rust/linker configuration (todo: better support in Dioxus)
+We have plans to further expand support, including making the upcoming [`bsn!` macro](https://github.com/bevyengine/bevy/pull/20158/) hot-reloadable (check out [this video](/news/bevys-fifth-birthday/#bevy-hot-reloading) of it in action!).
diff --git a/release-content/release-notes/light-textures.md b/release-content/release-notes/light-textures.md
index 29b0451ee5f0c..7a527ee6fa83b 100644
--- a/release-content/release-notes/light-textures.md
+++ b/release-content/release-notes/light-textures.md
@@ -4,7 +4,7 @@ authors: ["@robtfm"]
 pull_requests: [18031]
 ---
 
-New components `PointLightTexture`, `SpotLightTexture`, and `DirectionalLightTexture` allow specifying light textures for lights, also commonly known as light cookies.
-These modulate the intensity of light cast upon surfaces for various artistic effects. See the `light_textures` example for usage.
+The new components `PointLightTexture`, `SpotLightTexture`, and `DirectionalLightTexture` allow specifying light textures for lights, also commonly known as "light cookies".
+These modulate the intensity of light cast upon surfaces for various artistic effects. See the [`light_textures`](https://github.com/bevyengine/bevy/blob/release-0.17.0/examples/3d/light_textures.rs) example for usage.
 
 (TODO: Embed light_textures example screenshot here)
diff --git a/release-content/release-notes/meshlet-bvh-culling.md b/release-content/release-notes/meshlet-bvh-culling.md
index 7a3cc6adbca76..055e1b76e6eee 100644
--- a/release-content/release-notes/meshlet-bvh-culling.md
+++ b/release-content/release-notes/meshlet-bvh-culling.md
@@ -19,4 +19,4 @@ Speaking of concrete GPU cost, the scene above renders in about 3.5 ms on the 40
 After increasing the instance count to over 1 million (almost *900 billion triangles*!), the total increases to about 4.5 ms, with \~4.1 ms on geometry render and material evaluation remaining constant at ~0.4 ms.
 This is a 30% increase in GPU time for an almost 8x increase in scene complexity.
 
-Comparing GPU times to 0.16 on a much smaller scene with 1,300 instances, previously the full render took 2.2 ms, whereas now it is 1.3 ms.
+Comparing GPU times to **Bevy 0.16** on a much smaller scene with 1,300 instances, previously the full render took 2.2 ms, whereas now in **Bevy 0.17** it takes 1.3 ms.
diff --git a/release-content/release-notes/observer_overhaul.md b/release-content/release-notes/observer_overhaul.md
index de9b9464952af..7ec176b829c76 100644
--- a/release-content/release-notes/observer_overhaul.md
+++ b/release-content/release-notes/observer_overhaul.md
@@ -7,7 +7,7 @@ pull_requests: [20731, 19596, 19663, 19611, 19935, 20274]
 Bevy's Observer API landed a few releases ago, and it has quickly become one of our most popular features. In **Bevy 0.17** we rearchitected and refined the Event and Observer APIs to be clearer, easier to use, and more performant. We plan on rolling out Bevy's next generation Scene / UI system in the near future, and observers are a key piece! We wanted to ensure they were in a better place for the next phase of Bevy development. The old API had some problems:
 
 1. **Concept names were confusing and ambiguous**: Events could be "observed", "buffered" in `Events` collections, or both. Knowing how to produce or consume a given [`Event`] required too much implied context: "do I write an Observer or use an EventReader system?", "do I trigger the event with or without targets?", what should the targets be?", etc. We need better, less ambiguous ways to refer to events.
-2. **The API was not "static" enough**: This relates to (1). Because a given [`Event`] type could be used by and produced for _any context_, we had to provide access to _every possible API_ for _every event type_. It should not be possible to trigger an "entity event" without an entity! An Observer of an event that was not designed to have a target entity should not have an `entity()` field! Every [`Event`] impl had to define an "entity propagation traversal", even it was not designed to propagate (and even if it didn't target entities at all!). Events should be self documenting, impossible to produce or consume in the wrong context, and should only encode the information that is necessary for that event.
+2. **The API was not "static" enough**: This relates to (1). Because a given [`Event`] type could be used by and produced for _any context_, we had to provide access to _every possible API_ for _every event type_. It should not be possible to trigger an "entity event" without an entity! An Observer of an event that was not designed to have a target entity should not have functions that return entity targets! Every [`Event`] impl had to define an "entity propagation traversal", even it was not designed to propagate (and even if it didn't target entities at all!). Events should be self documenting, impossible to produce or consume in the wrong context, and should only encode the information that is necessary for that event.
 3. **The API did too much work**: Because events could be produced and used in any context, this meant that they all branched through code for every possible context. This incurred unnecessary overhead. It also resulted in lots of unnecessary codegen!
 
 In **Bevy 0.17** we have sorted out these issues without fundamentally changing the shape of the API. Migrations should generally be very straightforward.
@@ -57,11 +57,9 @@ world.trigger(GameOver { score: 100 });
 In **Bevy 0.17**, defining observers has only changed slightly:
 
 ```rust
-
 world.add_observer(|game_over: On<GameOver>| {
     info!("Game over! You scored {} points", game_over.score);
 });
-
 ```
 
 `Trigger` is now `On`. `On` encourages developers to think of this parameter _as the event itself_. This is also reflected in the new naming convention, where we name the variable after the `Event` (ex: `game_over`) rather than the `Trigger` (ex: `trigger`).
@@ -125,7 +123,7 @@ struct Attack {
 
 ## EntityEvent Propagation
 
-An [`EntityEvent`] does not "propagate" by default (and they now statically have no access to APIs that control propagation). Propagation can be enabled using the `propagate` attribute (which defaults to using the [`ChildOf`] relationship to "bubble events up the hierarchy"):
+An [`EntityEvent`] does not "propagate" by default (and by default they now _statically_ have no access to APIs that control propagation). Propagation can be enabled using the `propagate` attribute (which defaults to using the [`ChildOf`] relationship to "bubble events up the hierarchy"):
 
 ```rust
 #[derive(EntityEvent)]
@@ -172,7 +170,7 @@ Component lifecycle events are an [`EntityEvent`] (and thus store the target ent
 
 ## AnimationEvent
 
-"Animation events" are custom events that are registered with an [`AnimationPlayer`] and triggered at a specific point in the animation. [`AnimationEvent`] is a new event sub-trait / derive (much like [`EntityEvent`]). Animation events use the [`AnimationEventTrigger`]. They behave like an [`EntityEvent`] (they observers on the [`AnimationPlayer`]), but they notably _do not store the entity on the event type_. This allows for directly registering them in [`AnimationPlayer`] without needing to set an entity target:
+"Animation events" are custom events that are registered with an [`AnimationPlayer`] and triggered at a specific point in the animation. [`AnimationEvent`] is a new event sub-trait / derive (much like [`EntityEvent`]). Animation events use the [`AnimationEventTrigger`]. They behave like an [`EntityEvent`] (they trigger observers of the [`AnimationPlayer`]), but they notably _do not store the entity on the event type_. This allows for directly registering them in [`AnimationPlayer`] without needing to set an entity target:
 
 ```rust
 animation.add_event(
diff --git a/release-content/release-notes/raymarched-atmosphere-space-views.md b/release-content/release-notes/raymarched-atmosphere-space-views.md
index d582211d0e41b..79d3cc20cfd5f 100644
--- a/release-content/release-notes/raymarched-atmosphere-space-views.md
+++ b/release-content/release-notes/raymarched-atmosphere-space-views.md
@@ -6,50 +6,31 @@ pull_requests: [20766]
 
 (Insert screenshot of space shot including volumetric shadows)
 
-Bevy's atmosphere now supports a raymarched rendering path that unlocks accurate views from above the atmosphere. This is ideal for cinematic shots, planets seen from space, and scenes that need sharp shadows through the volume of the atmosphere.
-
-### What changed
-
-- Added `AtmosphereMode::Raymarched`, as an alternative to the existing lookup texture method.
-- Added support for views from above the atmosphere.
-
-### When to choose which
-
-- LookupTexture
-  - Fastest, approximate lighting, inaccurate for long distance views
-  - Ground level and broad outdoor scenes
-  - Most cameras and typical view distances
+Bevy's atmosphere now supports a raymarched rendering path that unlocks accurate views from above the atmosphere. This means **Bevy 0.17** now has two atmosphere rendering modes to choose from:
+
+- [`AtmosphereMode::Raymarched`]
+  - Ideal for cinematic shots, planets seen from space, and "flight simulator" type scenes
+  - More accurate lighting, but slower
+  - Sharper shadows through the atmosphere
+- [`AtmosphereMode::LookupTexture`]
+  - This is the default
+  - Great for ground level and broad outdoor scenes
+  - Less accurate lighting at long distances, but faster
   - Softer shadows through the atmosphere
-- Raymarched
-  - Slightly slower, more accurate lighting
-  - Views from above the atmosphere or far from the scene
-  - Cinematic shots that demand stable lighting over a large range of scales
-  - Flight or space simulators
-  - Sharp, per‑pixel shadows through the atmosphere
 
-### How to use it
-
-Switch the rendering method on the camera’s `AtmosphereSettings`:
+To use it, add an [`Atmosphere`] component to your [`Camera`] and set the rendering method on the camera’s [`AtmosphereSettings`]:
 
 ```rust
-use bevy::prelude::*;
-use bevy::pbr::atmosphere::{Atmosphere, AtmosphereSettings, AtmosphereMode};
-
-fn setup(mut commands: Commands) {
-    commands.spawn((
-        Camera3d::default(),
-        Atmosphere::default(),
-        AtmosphereSettings { 
-          sky_max_samples: 16,
-          rendering_method: AtmosphereMode::Raymarched, 
-          ..Default::default() 
-        }
-    ));
-}
+commands.spawn((
+    Camera3d::default(),
+    Atmosphere::default(),
+    AtmosphereSettings { 
+      rendering_method: AtmosphereMode::Raymarched, 
+      ..default() 
+    }
+));
 ```
 
-You can also adjust the `sky_max_samples` for controlling what is the maximum number of steps to take when raymarching the atmosphere, which is `16` by default to set the right balance between performance and accuracy.
-
-Keep the default method for most scenes. Use raymarching for cinematics, cameras positioned far from the scene, and shots requiring sharp volumetric shadows.
+You can also adjust the `AtmosphereSettings::sky_max_samples` to configure the maximum number of steps to take when raymarching the atmosphere. Lower numbers are faster and less accurate. Higher numbers are slower and more accurate.
 
-See the updated `examples/3d/atmosphere.rs` for a working reference.
+See the updated [`atmosphere` example](https://github.com/bevyengine/bevy/blob/release-0.17.0/examples/3d/atmosphere.rs) for a working reference.
diff --git a/release-content/release-notes/realtime-environment-map-filtering.md b/release-content/release-notes/realtime-environment-map-filtering.md
index 8de10e5285f3a..8f4be508e1000 100644
--- a/release-content/release-notes/realtime-environment-map-filtering.md
+++ b/release-content/release-notes/realtime-environment-map-filtering.md
@@ -20,10 +20,8 @@ Now, Bevy supports both modes of filtering!
 Adding a `GeneratedEnvironmentMapLight` to a `Camera` entity lets you use any environment map
 with Bevy's renderer, and enjoy all the benefits of prefiltering with none of the asset processing.
 
-We've made sure works with our built-in atmosphere shader too.
+We've made sure it works with our built-in atmosphere shader too.
 To enable this, add the new component `AtmosphereEnvironmentMapLight` to the camera entity.
 
-This is fully dynamic per-view effect: no pre-baked environment maps are needed.
+This is a fully dynamic per-view effect: no pre-baked environment maps are needed.
 However, please be aware that light probes are not yet supported.
-
-Special thanks to @atlv24, @JMS55 and @ecoskey for reviews, feedback, and assistance.
diff --git a/release-content/release-notes/reflect_auto_registration.md b/release-content/release-notes/reflect_auto_registration.md
index 1f0f23be33fd0..dc022d8973b13 100644
--- a/release-content/release-notes/reflect_auto_registration.md
+++ b/release-content/release-notes/reflect_auto_registration.md
@@ -4,45 +4,36 @@ authors: ["@eugineerd"]
 pull_requests: [15030]
 ---
 
-## Automatic [`Reflect`] registration
-
-Deriving [`Reflect`] on types opts into **Bevy's** runtime reflection infrastructure, which is used to power systems like component runtime inspection and serialization. Before **Bevy 0.17**, any top-level
-types that derive [`Reflect`] (not used as a field in some other [`Reflect`]-ed type) had to be manually registered using [`register_type`] for the runtime reflection to work with them. With this release,
-all types that [`#[derive(Reflect)]`] are now automatically registered! This works for any types without generic type parameters and should reduce the boilerplate needed when adding functionality that depends on [`Reflect`].
-
-```rs
-fn main() {
-  // No need to manually call .register_type::<Foo>()
-  App::new()
-    .add_plugins(DefaultPlugins)
-    .add_systems(Startup, setup)
-    .run();
-}
+Deriving [`Reflect`] on types opts into **Bevy's** runtime reflection infrastructure, which is used to power systems like runtime component inspection and serialization:
 
+```rust
 #[derive(Reflect)]
 pub struct Foo {
   a: usize,
 }
+```
 
-fn setup(type_registry: Res<AppTypeRegistry>) {
-  let type_registry = type_registry.read();
-  assert!(type_registry.contains(TypeId::of::<Foo>()));
-}
+In previous Bevy versions, any top-level
+types that derived [`Reflect`] had to be manually registered using [`register_type`]:
+
+```rust
+// This would make Foo visible to Bevy
+app.register_type::<Foo>()
 ```
 
-In cases where automatic registration is undesirable, it can be opted-out of by adding #[reflect(no_auto_register)] reflect attribute to a type:
+In **Bevy 0.17**, all types that [`#[derive(Reflect)]`] are now automatically registered! This significantly reduces the boilerplate required to use Bevy's reflection features, which will be increasingly important as we build out Bevy's new scene system, entity inspector, and visual editor.
 
-```rs
-#[derive(Reflect)]
-#[reflect(no_auto_register)]
-pub struct Foo {
-  a: usize,
-}
+Note that generic types still require manual registration, as these types don't (yet) exist when [`Reflect`] is derived:
+
+```rust
+app.register_type::<Container<Item>>()
 ```
 
-## Unsupported platforms
+In cases where automatic registration is undesirable, it can be opted-out of by adding the `#[reflect(no_auto_register)]` attribute to the type.
+
+## Supporting unsupported platforms
 
-This feature relies on the [`inventory`] crate to collect all type registrations at compile-time. However, some niche platforms are not supported by [`inventory`], and while it would be best for
+This feature relies on the [`inventory`] crate to collect all type registrations at compile-time. This is supported on Bevy's most popular platforms: Windows, macOS, iOS, Android, and WebAssembly. However, some niche platforms are not supported by [`inventory`], and while it would be best for
 any unsupported platforms to be supported upstream, sometimes it might not be possible. For this reason, there is a different implementation of this feature that works on all platforms.
 It comes with some caveats with regards to project structure and might increase compile time, so it is better used as a backup solution. The detailed instructions on how to use this feature
 can be found in this [`example`]. Types can also still be manually registered using `app.register_type::<T>()`.
diff --git a/release-content/release-notes/render_startup.md b/release-content/release-notes/render_startup.md
index 43d6d1aa41716..3227885049abf 100644
--- a/release-content/release-notes/render_startup.md
+++ b/release-content/release-notes/render_startup.md
@@ -1,34 +1,14 @@
 ---
-title: "`RenderStartup` and making the renderer my ECS-y"
+title: "`RenderStartup` Schedule"
 authors: ["@IceSentry", "@andriyDev"]
 pull_requests: [19841, 19885, 19886, 19897, 19898, 19901, 19912, 19926, 19999, 20002, 20024, 20124, 20147, 20184, 20194, 20195, 20208, 20209, 20210]
 ---
 
-Previous rendering code looked quite different from other Bevy code. In general, resources were
-initialized with the `FromWorld` trait (where most Bevy code only uses the `Default` trait for most
-resources) and systems/resources were added in `Plugin::finish` (where nearly all Bevy code does not
-use `Plugin::finish` at all). This difference with Bevy code can make it harder for new developers
-to learn rendering, and can result in "cargo cult" copying of rendering code (e.g., "is it important
-to be using `FromWorld` here? Better to be safe and just do what the rendering code is doing!").
+In previous versions of Bevy, render `Plugin` code had to look different than other `Plugin` code, due to how the renderer was initialized. In general, renderer resources and systems had to be added in `Plugin::finish`, separate from the typical spot: `Plugin::build`. The fact that `Plugin::finish` resulted in the correct order was a bit arbitrary / incidental.
 
-As a step towards making the renderer more accessible (and maintainable), we have introduced the
-`RenderStartup` schedule and ported many rendering resources to be initialized in `RenderStartup`
-with systems! This has several benefits:
+As a step towards solving this,  **Bevy 0.17** introduces the `RenderStartup` schedule and ports many renderer resources to be initialized in `RenderStartup` with systems. This makes renderer initialization more structured and allows renderer plugin initialization to be defined "normally" in `Plugin::build`. It also allows renderer init code to benefit from the Bevy ECS scheduler, including automatic parallelization and system ordering.
 
-1. Creating resources in systems makes it clearer that rendering resources **are just regular
-    resources**. Hopefully, this better communicates that how you initialize these resources is
-    totally up to you!
-2. We can now use the system ordering API to ensure that resources are initialized in the correct
-    order. For example, we can do `init_material_pipeline.after(init_mesh_pipeline)` if we need the
-    mesh pipeline to initialize the material pipeline.
-3. These initialization systems clearly describe what resources they require through their argument
-    list. If a system has an argument of `deferred_lighting_layout: Res<DeferredLightingLayout>`, it
-    clearly documents that this system needs to be run **after** we initialize the
-    `DeferredLightingLayout`.
-
-We want developers to become more familiar and comfortable with Bevy's rendering stack, and hope
-that bringing the renderer closer to regular ECS code will encourage that. Code that previously looked
-like this (in Bevy 0.16):
+In previous versions, initializing a renderer resource looked like this:
 
 ```rust
 impl Plugin for MyRenderingPlugin {
@@ -45,24 +25,18 @@ impl Plugin for MyRenderingPlugin {
     }
 }
 
-pub struct MyRenderResource {
-    ...
-}
+#[derive(Resource)]
+pub struct MyRenderResource(/* ... */);
 
 impl FromWorld for MyRenderResource {
     fn from_world(world: &mut World) -> Self {
         let render_device = world.resource::<RenderDevice>();
-        let render_adapter = world.resource::<RenderAdapter>();
-        let asset_server = world.resource::<AssetServer>();
-
-        MyRenderResource {
-            ...
-        }
+        MyRenderResource(/* ... */)
     }
 }
 ```
 
-Can now be written like:
+In **Bevy 0.17**, it can now be written like this:
 
 ```rust
 impl Plugin for MyRenderingPlugin {
@@ -73,31 +47,14 @@ impl Plugin for MyRenderingPlugin {
 
         render_app.add_systems(RenderStartup, init_my_resource);
     }
-
-    // No more finish!!
 }
 
-pub struct MyRenderResource {
-    ...
-}
+#[derive(Resource)]
+pub struct MyRenderResource(/* ... */);
 
-// Just a regular old system!!
-fn init_my_resource(
-    mut commands: Commands,
-    render_device: Res<RenderDevice>,
-    render_adapter: Res<RenderAdapter>,
-    asset_server: Res<AssetServer>,
-) {
-    commands.insert_resource(MyRenderResource {
-        ...
-    });
+fn init_my_resource(mut commands: Commands, render_device: Res<RenderDevice>) {
+    commands.insert_resource(MyRenderResource(/* ... */));
 }
 ```
 
-We highly encourage users to port their own rendering resources to this new system approach (and for
-resources whose initialization depends on a Bevy core resource, it may be required). In fact, we
-encourage users to abandon `Plugin::finish` entirely and move all their system and resource
-initializations for rendering into `Plugin::build` instead.
-
-As stated before, we've ported many resources to be initialized in `RenderStartup`. See the
-migration guide for a full list of affected resources.
+We highly encourage renderer developers to port their own rendering resources to this new approach!
diff --git a/release-content/release-notes/scene-type-crates.md b/release-content/release-notes/scene-type-crates.md
index 9a3abd33120d8..d72899e65d617 100644
--- a/release-content/release-notes/scene-type-crates.md
+++ b/release-content/release-notes/scene-type-crates.md
@@ -4,8 +4,10 @@ authors: ["@atlv24", "@Ickshonpe", "@zeophlite"]
 pull_requests: [20485, 20330, 18703, 20587, 20502, 19997, 19991, 20000, 19949, 19943, 19953, 20498, 20496, 20493, 20492, 20491, 20488, 20487, 20486, 20483, 20480, 20479, 20478, 20477, 20473, 20472, 20471, 20470, 20392, 20390, 20388, 20345, 20344, 20051, 19985, 19973, 19965, 19963, 19962, 19960, 19959, 19958, 19957, 19956, 19955, 19954, 16620, 16619, 15700, 15666, 15650]
 ---
 
-It is now possible to use cameras, lights, shaders, images, meshes, sprites, text, ui, picking, animation, and scenes without depending on the Bevy renderer. This makes it possible for 3rd party custom renderers (as might be required on console, or for teams with divergent goals) to act as drop-in replacements for rendering existing scenes.
+In **Bevy 0.17** we have decoupled most of the user-facing renderer API from `bevy_render` (Bevy's default built-in renderer, which uses [`wgpu`](https://github.com/gfx-rs/wgpu)). It is now possible to use cameras, lights, shaders, images, meshes, sprites, text, ui, picking, animation, and scenes without depending on `bevy_render`.
 
-This is incredibly important for reducing compile time, especially for 3rd party crates: crate authors can now depend more granularly on the specific crates they need, meaning greater chances for compilation parallelism emerge as not everything is bottlenecked on waiting for the bevy_render -> bevy_core_pipelines -> bevy_pbr/bevy_sprite chain to compile.
+With these changes, it is now possible for 3rd party custom renderers to act as drop-in replacements for rendering Bevy scenes, without the need to pull in `bevy_render`.
 
-Another sweet side-effect is that "shader library only" crates are now possible with minimal dependencies thanks to bevy_shader.
+This is also incredibly important for reducing compile time, especially for 3rd party crates: crate authors can now depend more granularly on the specific crates they need. If they don't need access to renderer internals, they don't need to wait for them to start compiling! This increases the potential for parallel compilation.
+
+Additionally, "shader library only" crates with minimal dependencies are now possible thanks to the new separate `bevy_shader` crate.
diff --git a/release-content/release-notes/specialized_ui_transform.md b/release-content/release-notes/specialized_ui_transform.md
index f98e3dfdf7082..3fd95b1baecbf 100644
--- a/release-content/release-notes/specialized_ui_transform.md
+++ b/release-content/release-notes/specialized_ui_transform.md
@@ -4,7 +4,4 @@ authors: ["@Ickshonpe"]
 pull_requests: [16615]
 ---
 
-In Bevy UI `Transform` and `GlobalTransform` have been replaced by `UiTransform` and `UiGlobalTransform`.  `UiTransform` is a specialized 2D UI transform which supports responsive translations.
-
-This is only the first step in a broader effort to dethrone `Transform` as the do-everything position-rotation-scale type.
-Don't worry, we haven't forgotten about 2D: we know that working with quaternions is a headache, and are hoping to define a dedicated 2D transform type, saving space and frustration.
+In Bevy UI `Transform` and `GlobalTransform` have been replaced by `UiTransform` and `UiGlobalTransform`.  `UiTransform` is a specialized 2D UI transform, which more effectively maps to the UI space, improves our internals substantially, and cuts out redundant, unnecessary, often expensive work (such as doing full hierarchical [`Transform`] propagation _in addition_ to the Bevy UI layout algorithm).
diff --git a/release-content/release-notes/text2d_shadows.md b/release-content/release-notes/text2d_shadows.md
index 9d29a7c5f0758..f83fd50c17b41 100644
--- a/release-content/release-notes/text2d_shadows.md
+++ b/release-content/release-notes/text2d_shadows.md
@@ -6,7 +6,4 @@ pull_requests: [20463]
 
 TODO: add showcase image(s)
 
-`Text2d` is a simple worldspace text API: great for damage numbers and simple labels.
-It deserves a few bells and whistles though, so it can keep up with its UI brother, `Text`.
-
-In addition to the new text background color, we've added dropshadows for `Text2d`. Add the `Text2dShadow` component to a `Text2d` entity to draw a shadow effect beneath its text.
+`Text2d` is a simple worldspace text API: great for damage numbers and simple labels. Unlike `Text`, its UI sibling, it didn't support drop shadows, so in **Bevy 0.17** we've added dropshadow support to `Text2d`. Add the `Text2dShadow` component to a `Text2d` entity to draw a shadow effect beneath its text.
diff --git a/release-content/release-notes/text_background_colors.md b/release-content/release-notes/text_background_colors.md
index abeb423195fdc..3e4aa0e8937b4 100644
--- a/release-content/release-notes/text_background_colors.md
+++ b/release-content/release-notes/text_background_colors.md
@@ -6,6 +6,6 @@ pull_requests: [18892, 20464]
 
 TODO: add showcase image(s)
 
-Text in Bevy now supports background colors. Insert the `TextBackgroundColor` component on a UI `Text` or `TextSpan` entity to set a background color for its text section.
+Text in Bevy now supports background colors. Insert the `TextBackgroundColor` component on a UI `Text` or `TextSpan` entity to set a background color for its text section. `TextBackgroundColor` provides the ability to set the color of _each_ "text span", whereas the standard `BackgroundColor` applies to _all_ spans in a `Text` node, and also includes space taken up by padding.
 
-This also works with `Text2d`: perfect for worldspace tooltips.
+`TextBackgroundColor` also works with `Text2d`: perfect for worldspace tooltips!
diff --git a/release-content/release-notes/ui_gradients.md b/release-content/release-notes/ui_gradients.md
index 155e394892aac..994a060bae7df 100644
--- a/release-content/release-notes/ui_gradients.md
+++ b/release-content/release-notes/ui_gradients.md
@@ -4,23 +4,24 @@ authors: ["@Ickshonpe"]
 pull_requests: [18139, 19330, 19992]
 ---
 
-Support for UI node's that display a gradient that transitions smoothly between two or more colors.
+Bevy now supports UI nodes that display a gradient that transitions smoothly between two or more colors.
 
-To draw a UI node with a gradient insert the components `BackgroundGradient` and `BorderGradient`, which both newtype a vector of `Gradient`s. If you set a background color, the background color is drawn first and the gradient(s) are drawn on top.
+You can now add the `BackgroundGradient` component to a `Node` to set its background to a gradient. If you also set a `BackgroundColor`, the background color is drawn first and the gradient(s) are drawn on top. You can also use the `BorderGradient` component to make the border use a gradient.
 
-The are three gradient structs corresponding to the three types of gradients supported: `LinearGradient`, `ConicGradient` and `RadialGradient`. These are then wrapped by the `Gradient` enum discriminator which has `Linear`, `Conic` and `Radial` variants.
+Both of these components wrap the `Gradient` enum type, which has three variants:`Linear`, `Conic` and `Radial`.
 
-Each gradient type consists of the geometric properties for that gradient, a list of color stops and the color space used for interpolation.
-Color stops consist of a color, a position or angle and an optional hint. If no position is specified for a stop, it's evenly spaced between the previous and following stops. Color stop positions are absolute. With the list of stops:
+Each gradient type consists of the geometric properties for that gradient, a list of color stops, and the color space used for interpolation (Bevy defaults to using `InterpolationColorSpace::Oklab`).
 
 ```rust
-vec![ColorStop::new(RED, Val::Percent(90.), ColorStop::new(GREEN), Val::Percent(10.))]
+commands.spawn((
+    Node { width: px(20), height: px(20) },
+    BackgroundGradient::from(LinearGradient {
+        angle: 4.,
+        stops: vec![
+            ColorStop::new(Color::WHITE, percent(15)),
+            ColorStop::new(Color::BLACK, percent(85)),
+        ],
+        ..default()
+    })
+))
 ```
-
-the colors will be reordered and the gradient will transition from green at 10% to red at 90%.
-
-Colors can be interpolated between the stops in OKLab, OKLCH, SRGB, HSL, HSV and linear RGB color spaces. The hint is a normalized value that can be used to shift the mid-point where the colors are mixed 50-50 between the stop with the hint and the following stop. Cylindrical color spaces support interpolation along both short and long hue paths.
-
-For sharp stops with no interpolated transition, place two stops at the same point.
-
-`ConicGradients` and `RadialGradients` have a center which is set using the new `UiPosition` type. `UiPosition` consists of a normalized (relative to the UI node) Vec2 anchor point and a responsive x, y offset.
diff --git a/release-content/release-notes/viewport-node.md b/release-content/release-notes/viewport-node.md
index 81d087fcef59d..d28b1a1b70bbd 100644
--- a/release-content/release-notes/viewport-node.md
+++ b/release-content/release-notes/viewport-node.md
@@ -4,19 +4,16 @@ authors: ["@chompaa", "@ickshonpe"]
 pull_requests: [17253]
 ---
 
-Bevy UI now has a `ViewportNode` component, which lets you render camera output directly to a UI node. Furthermore, if the `bevy_ui_picking_backend` feature is enabled, you can pick using the rendered target. That is, you can use **any** picking backend through the viewport node, as per normal. In terms of UI, the API usage is really straightforward:
+Bevy UI now has a `ViewportNode` component, which lets you render camera output directly to a UI node:
 
 ```rust
-commands.spawn((
-  // `ViewportNode` requires `Node`, so we just need this component!
-  ViewportNode::new(camera)
-  // To disable picking "through" the viewport, just disable picking for the node.
-  // Pickable::IGNORE
-));
+commands.spawn(ViewportNode::new(camera));
 ```
 
 The referenced `camera` here does require its target to be a `RenderTarget::Image`. See the new [`viewport_node`](https://github.com/bevyengine/bevy/blob/v0.17.0/examples/ui/viewport_node.rs) for more implementation details.
 
+Furthermore, if the `bevy_ui_picking_backend` feature is enabled, you can "pick" using the rendered target. That is, you can use **any** picking backend through the viewport node.
+
 ## Showcase
 
 `https://private-user-images.githubusercontent.com/26204416/402285264-39f44eac-2c2a-4fd9-a606-04171f806dc1.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDU4NTY4MDgsIm5iZiI6MTc0NTg1NjUwOCwicGF0aCI6Ii8yNjIwNDQxNi80MDIyODUyNjQtMzlmNDRlYWMtMmMyYS00ZmQ5LWE2MDYtMDQxNzFmODA2ZGMxLm1wND9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MjglMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDI4VDE2MDgyOFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTg0ZDU0OGFmM2Q3NTJmOWJkNDYzODMxNjkyOTBlYzFmNmQ2YWUzMGMzMjJjMjFiZWI0ZmY3ZjZkMjNiMzA5NzkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.DXec6l2SYDIpSCRssEB4o3er7ib3jUQ9t9fvjdY3hYw`
