<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20731 Event Rearchitecture
        
    </title><meta content="#20731 Event Rearchitecture" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-10</span><div class=language-switcher><a class=lang-link data-lang=en href=/pull_request/bevy/2025-09/pr-20731-en-20250910>English</a> / <span class="lang-link active" data-lang=zh-cn>中文</span></div></div><div class=pr-content><h1 id=event-rearchitecture>Event Rearchitecture</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Event Rearchitecture<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20731<li><strong>Author</strong>: cart<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Usability, A-Animation, M-Needs-Migration-Guide, D-Complex, M-Needs-Release-Note, X-Blessed, D-Unsafe, S-Waiting-on-Author<li><strong>Created</strong>: 2025-08-24T02:16:51Z<li><strong>Merged</strong>: 2025-09-10T00:08:24Z<li><strong>Merged By</strong>: cart</ul><h2 id=description-translation>Description Translation</h2><p>普遍共识认为，我们对Events、“entity events”、Observers和BufferedEvents的术语需要更清晰。此外，许多人也同意当前的Observer系统将受益于更多的静态性：目前假设您可以在几乎任何上下文中使用事件，并且它们都通过完全相同的代码路径。<p>Alice提出了一个<a rel="noopener nofollow noreferrer" href=https://hackmd.io/@bevy/rk4S92hmlg target=_blank>Overhaul Observers</a>的提案，并且我们已经在0.17版本中部分实现了它。我认为它很好地概述了许多问题，并合理地解决了它们。但我也认为提议的解决方案还不理想。鉴于它已经为0.17版本部分实现，这是一个破坏性变更，并且考虑到我们已经多次破坏了Observer API，我认为我们需要在下一次发布之前解决这个问题。<p>这是一个大的变更集，但它主要只是对现有内容的重新构架。我没有从根本上改变行为。我只是以更清晰、更简单和更高效的方式进行了精炼和约束。<p>首先，我会对Alice的提案给出一些简要说明（如果你们还没有阅读，应该去读一下！）：<h3 id=guan-yu-aliceti-an-de-shuo-ming>关于Alice提案的说明</h3><ul><li>我喜欢向更静态API的转变<li>我认为我们在“分离术语“的道路上走得太远了。提案引入了大量的API、术语和“子术语“。我认为我们需要简化我们的概念和名称，使这一切在实践中更容易讨论和使用。<li>BroadcastEvent感觉是错误的名称。EntityEvent在完全相同的方式下也是“broadcast“<li>BufferedEvent是一个完全不同于EntityEvent和BroadcastEvent的系统。这混淆了概念太多。它需要自己独立的、单字的概念名称。<li>“Universal observers”：我认为这应该是完全上下文驱动的，而不是需要在API中编码。<li>我同意我们不能摆脱buffered events，并且将它们与“broadcast events“合并没有帮助<li>我不太确定如何使提议的PropagateEvent子特质透明地工作。这不能作为一个特质“分层在上面“。它需要在更基础的层面上内置。<li>我不喜欢<code>app.add_broadcast_observers()</code>、<code>app.add_universal_observers()</code>、<code>Observer::entity_observer</code>、<code>Observer::broadcast</code>等。<code>On</code>事件应该静态地确定一个observer是“entity observer“还是“broadcast“ Observer。这将已经在类型系统中编码，因此是我们可以代表开发人员做的事情。同样，任何在顶层注册的observer本质上不是特定的entity observer。所有这些变体都使用户不必要地猜测和摸索。我想要简单的单字概念名称、单一构造函数等。</ul><h3 id=ti-yi-de-yuan-ze>提议的原则</h3><ul><li>静态性： <ul><li>事件应该只能在它们被定义使用的上下文中使用。<li>当触发时，Observers应该只访问相关的字段和行为： <ul><li>不要返回Option或PLACEHOLDER：字段或函数不应该存在<li>不支持传播的entity events不应该暴露该功能</ul></ul><li>不在运行时做不必要的工作 <ul><li>事件触发器不应该分支通过每个潜在的事件代码路径<li>不要不必要地克隆可能很大的事件上下文列表（例如：我们目前为每个observer调用克隆组件列表）</ul><li>最小化代码生成 <ul><li>不要冗余地重新编译东西。<li>不要编译不必要的代码路径。</ul><li>清晰和简单 <ul><li>最小化浮动的概念名称数量，并将每个概念严格锁定到特定上下文<li>我现在确信“buffered events“和“observer events“共享概念名称是错误的。我们需要两个干净清晰的概念，如果这意味着“observer events“可以更好，我愿意给“buffered events“一个稍微差一点的名称。<li>不要抛弃“Event“这个概念名称…它是一个非常好的名称。相反，将其约束到一个特定的事物。<li>最小化我们的API表面<li>事件包含所有上下文，包括曾经是“target“的内容。这允许人们为上下文定义最有意义的“target“名称，并允许文档完全描述该“target“的上下文。</ul></ul><h3 id=gai-nian>概念</h3><ul><li><strong>Event</strong>（你“observe“的东西） <ul><li>理由：“Event“是这个概念的明确选择。一个“event“感觉像是实时发生的事情。“Event observers“是在事件发生（被触发）时观察事件的东西。此外，这是“传播“的概念，“event propagation“是人们理解的术语。<li><strong>Trigger</strong>：（导致事件为目标发生的动词）。事件被Triggered。这可以包括传递给observers / 通知触发行为的额外上下文/数据。事件有且只有一个Trigger。如果你想要不同的触发行为，定义一个新事件。这使系统更静态、更可预测、更容易理解和文档化。<code>world.trigger_ref_with</code>使得可以传入你自己Trigger数据的可变引用，从而可以自定义输入触发数据并读取最终的触发数据。<li><strong>Observer</strong>（“observes“事件的东西）：事件的<code>Trigger</code>决定哪些observers将运行。<li><strong>Event Types</strong>：你可以构建任何“类型“的事件。“target“的概念已被移除。相反，定义一个期望特定类型事件的<code>Trigger</code>（例如：<code>E: EntityEvent</code>）。 <ul><li><strong>EntityEvent</strong> 我们添加一个新的<code>EntityEvent</code>特质，它定义了一个<code>event.entity()</code>访问器。这由<code>Trigger</code>实现使用：<code>EntityTrigger</code>、<code>PropagateEntityTrigger</code>和<code>EntityComponentsTrigger</code>。</ul></ul><li><strong>Message</strong>（你“read“和“write“的缓冲东西） <ul><li><code>Message</code>是一个坚实的隐喻，表示这是什么…它是被写入的数据，然后在稍后的某个时间点被某人/某物读取。我期望现有的“buffered events“消费者会对这个名称更改感到遗憾，因为“event“感觉更好。但有一个单独的名称符合每个人的最佳利益。<li><strong>MessageReader</strong>（读取消息的东西）<li><strong>MessageWriter</strong>（写入消息的东西）</ul></ul><h3 id=bian-geng>变更</h3><ul><li><code>Event</code>特质变更 <ul><li>Event现在专门由Observers使用<li>添加了<code>Event::Trigger</code>，它定义了此事件将使用什么触发实现</ul><li>添加了<code>Trigger</code>特质 <ul><li>所有共享/硬编码的observer触发逻辑已被分解为单独的特定上下文的Trigger特质。</ul><li>“Trigger Targets“已被移除。 <ul><li>相反，事件结合它们的Trigger实现决定它们将如何被触发。通常，这意味着事件现在将它们的“targets“作为事件上的字段包含。<li>像<code>trigger_targets</code>这样的API已被<code>trigger</code>替换，现在可以用于任何<code>Event</code></ul><li><code>EntityEvent</code>特质变更 <ul><li>传播配置已从<code>EntityEvent</code>特质中移除。它现在位于<code>Trigger</code>特质上（具体是<code>PropagateEntityTrigger</code>特质）。<li><code>EntityEvent</code>现在为它实现的事件提供<code>entity / entity_mut</code>访问器<li><code>EntityEvent</code>默认为无传播（使用更简单的<code>EntityTrigger</code>）<li><code>#[entity_event(propagate)]</code>启用“默认“传播逻辑（使用ChildOf）。现有的<code>#[entity_event(traversal = X)]</code>已重命名为<code>#[entity_event(propagate = X)</code><li>派生<code>EntityEvent</code>需要单个<code>MyEvent(Entity)</code>、<code>entity</code>字段名称（<code>MyEvent { entity: Entity}</code>）或<code>MyEvent { #[event_entity] custom: Entity }</code></ul><li>动画事件变更 <ul><li>动画事件现在有它们自己的<code>AnimationEvent</code>特质，它设置<code>AnimationEventTrigger</code>。这允许开发人员传入不包括Entity字段的事件（因为这由系统设置）。自定义触发器还打开了廉价传入额外动画系统上下文的大门，可通过<code>On</code>访问</ul><li><code>EntityComponentsTrigger</code> <ul><li>内置的Add/Remove/etc生命周期事件现在使用<code>EntityComponentsTrigger</code>，它将组件作为额外状态传入。这显著减少了克隆，因为它进行借用而不是将列表克隆到每个observer执行中。<li>每个事件现在都有一个<code>entity</code>字段。</ul><li>样式变更 <ul><li>偏好使用事件名称作为变量：<code>explode: On&LTExplode></code>而不是<code>event: On&LTExplode></code><li>偏好使用entity events上entity的直接字段名称，而不是<code>event.entity()</code>。这允许我们在适当的地方使用更具体的名称，提供更好/更上下文化的文档，并指导开发人员将<code>On&LTMyEvent></code>视为事件本身。</ul></ul><p>查看示例和内置事件的变更，以了解这在实践中的样子。<h3 id=que-dian>缺点</h3><ul><li>将“target“移动到事件中添加了一些新约束： <ul><li>为多个实体触发相同的事件需要多个触发调用。对于“昂贵“的事件（例如：附加到事件的大量数据），这将更加尴尬。你的选项变为： <ul><li>创建事件的多个实例，克隆昂贵的数据<li>使用<code>trigger_ref</code>，并在每次调用时改变事件以更改目标。<li>将“昂贵“的共享数据移动到Trigger中，并使用<code>trigger_ref_with</code><li>我们可以构建一个新的EntityEvent方法，抽象“事件突变“行为并提供类似于旧<code>trigger_target</code>行为的东西。<li>使用不同的<code>EntityTargetTrigger</code>（目前bevy未提供，但我们可以），这带来了旧行为。这将与<code>trigger_with</code>一起使用以复制旧模式：<code>world.trigger_with(MyEvent, [e1, e2].into())</code>（或者我们可以使<code>into()</code>隐式）</ul><li>冒泡事件涉及改变事件以设置实体。这意味着<code>trigger_ref</code>将导致事件的<code>EntityEvent::entity()</code>成为最终冒泡的实体而不是初始实体。<li>一些API（琐碎地）受益于“target entity“与事件分开。具体来说，这个新API需要对“Animation Event“系统中的AnimationPlayer进行更改。我认为这实际上是一个好的变更集，因为它允许我们： <ul><li>廉价地暴露更多动画状态作为新AnimationEventTrigger实现的一部分<li>将AnimationPlayer提供的那个“隐式“实体目标移动到AnimationEventTrigger中<li>将事件的“animation event trigger-ness“编码到类型本身中（通过要求<code>#[event(trigger = AnimationEventTrigger)]</code>）<li>通过不为AnimationEventTrigger实现Default，我们可以阻止用户手动触发动画事件。</ul></ul></ul><h3 id=cao-an-todo>草案TODO</h3><ul><li><input checked disabled type=checkbox> 填写文档并更新现有文档<li><input disabled type=checkbox> 基准测试：我期望这个实现显著更快。可能还有明显的二进制大小改进，因为我删除了许多冗余的代码生成。<li><input checked disabled type=checkbox> 更新发布说明和迁移指南</ul><h3 id=xia-yi-bu>下一步</h3><ul><li><code>BufferedEvent -> Message</code>重命名未包括以保持大小。</ul><p>修复 #19648<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><h3 id=wen-ti-he-bei-jing>问题和背景</h3><p>Bevy的事件系统在之前的版本中存在几个核心问题。首先，术语混乱：Events、EntityEvents、BufferedEvents和Observers这些概念之间的界限不清晰，导致开发者难以理解和使用。其次，API缺乏静态性：任何事件类型都可以在任何上下文中使用，这导致了不必要的运行时分支和代码生成。最后，性能问题：系统需要为所有可能的事件路径生成代码，即使某些路径永远不会被使用。<p>开发者cart认识到需要从根本上重新架构事件系统，而不是在现有基础上进行小修小补。这个PR的目标是创建一个更清晰、更静态、更高效的事件系统，同时保持向后兼容性尽可能好。<h3 id=jie-jue-fang-an-fang-fa>解决方案方法</h3><p>这个重构的核心思想是将事件系统分为两个清晰的概念：<strong>Event</strong>（用于观察者模式）和<strong>Message</strong>（用于缓冲模式）。Event现在专门用于Observers，而Message用于传统的EventReader/EventWriter模式。<p>关键技术决策包括：<ol><li>引入<code>Trigger</code> trait来定义不同事件的触发行为<li>移除单独的“target“概念，将目标实体作为事件本身的字段<li>为不同类型的事件（EntityEvent、AnimationEvent等）提供专门的Trigger实现<li>通过类型系统静态地约束事件的使用上下文</ol><h3 id=shi-xian-xi-jie>实现细节</h3><h4 id=event-traitzhong-gou>Event Trait重构</h4><p>新的Event trait现在包含一个关联的Trigger类型：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + Sized + 'static {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Trigger</span><span style=color:#ed9366><</span><span style=color:#fa6e32>'a</span><span style=color:#ed9366>></span><span style=color:#61676ccc>: </span><span>Trigger<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这允许每个事件类型定义自己的触发行为，而不是所有事件都通过相同的代码路径。<h4 id=entityeventde-gai-jin>EntityEvent的改进</h4><p>EntityEvent现在要求事件包含目标实体信息：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(EntityEvent)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Explode </span><span>{
</span><span>    entity</span><span style=color:#61676ccc>:</span><span> Entity,
</span><span>}
</span></code></pre><p>触发方式从：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_targets</span><span>(Explode</span><span style=color:#61676ccc>,</span><span> entity)</span><span style=color:#61676ccc>;
</span></code></pre><p>变为：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(Explode { entity })</span><span style=color:#61676ccc>;
</span></code></pre><h4 id=triggerxi-tong-de-shi-xian>Trigger系统的实现</h4><p>新的Trigger trait定义了事件的触发逻辑：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub unsafe trait </span><span style=color:#399ee6>Trigger</span><span>&LTE: Event> {
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>trigger</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>        </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>:</span><span> DeferredWorld,
</span><span>        </span><span style=color:#ff8f40>observers</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>CachedObservers,
</span><span>        </span><span style=color:#ff8f40>trigger_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>TriggerContext,
</span><span>        </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> E,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>提供了几个内置的Trigger实现：<ul><li><code>GlobalTrigger</code>：用于全局事件<li><code>EntityTrigger</code>：用于实体事件<li><code>PropagateEntityTrigger</code>：用于支持传播的实体事件<li><code>EntityComponentsTrigger</code>：用于组件生命周期事件</ul><h4 id=xing-neng-you-hua>性能优化</h4><p><code>EntityComponentsTrigger</code>显著减少了克隆操作，通过借用组件列表而不是克隆它们：<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>EntityComponentsTrigger</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    </span><span style=color:#fa6e32>pub </span><span>components</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a</span><span> [ComponentId],
</span><span>}
</span></code></pre><h3 id=ji-shu-dong-cha>技术洞察</h3><p>这个重构展示了几个重要的软件工程原则：<ol><li><strong>关注点分离</strong>：将Events和Messages分为两个不同的概念，每个都有明确的用途和API<li><strong>静态类型安全</strong>：通过类型系统在编译时捕获错误的使用模式<li><strong>零成本抽象</strong>：专门的Trigger实现允许编译器为每个事件类型生成最优化的代码<li><strong>渐进式迁移</strong>：虽然API发生了变化，但旧的模式仍然可以通过适配器支持</ol><h3 id=ying-xiang>影响</h3><p>这个重构带来了几个显著改进：<ol><li><strong>更清晰的API</strong>：开发者现在可以更清楚地理解每个事件类型的用途和正确用法<li><strong>更好的性能</strong>：减少了不必要的分支和克隆操作<li><strong>更小的代码大小</strong>：移除了冗余的代码生成<li><strong>更好的可维护性</strong>：更模块化的设计使得系统更容易理解和扩展</ol><h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TB
</span><span>    Event[Event Trait] --> GlobalTrigger[GlobalTrigger]
</span><span>    Event --> EntityEvent[EntityEvent Trait]
</span><span>    EntityEvent --> EntityTrigger[EntityTrigger]
</span><span>    EntityEvent --> PropagateEntityTrigger[PropagateEntityTrigger]
</span><span>    EntityEvent --> EntityComponentsTrigger[EntityComponentsTrigger]
</span><span>    Event --> AnimationEvent[AnimationEvent Trait]
</span><span>    AnimationEvent --> AnimationEventTrigger[AnimationEventTrigger]
</span><span>    
</span><span>    Message[Message Trait] --> MessageReader[MessageReader]
</span><span>    Message --> MessageWriter[MessageWriter]
</span><span>    
</span><span>    Observer[Observer System] --> On[On Parameter]
</span><span>    On --> Event
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-event-mod-rs-345-33><code>crates/bevy_ecs/src/event/mod.rs</code> (+345/-33)</h3><p>这个文件重新组织了事件模块的结构，引入了新的Event trait和相关的类型系统。<p><strong>关键变更：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 新的Event trait定义
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + Sized + 'static {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Trigger</span><span style=color:#ed9366><</span><span style=color:#fa6e32>'a</span><span style=color:#ed9366>></span><span style=color:#61676ccc>: </span><span>Trigger<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// EntityEvent trait
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>EntityEvent</span><span>: Event {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>event_target</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Entity</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>event_target_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Entity</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-event-trigger-rs-430-0><code>crates/bevy_ecs/src/event/trigger.rs</code> (+430/-0)</h3><p>新文件，包含了Trigger trait和其各种实现。<p><strong>关键代码：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub unsafe trait </span><span style=color:#399ee6>Trigger</span><span>&LTE: Event> {
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>trigger</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>        </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>:</span><span> DeferredWorld,
</span><span>        </span><span style=color:#ff8f40>observers</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>CachedObservers,
</span><span>        </span><span style=color:#ff8f40>trigger_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>TriggerContext,
</span><span>        </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> E,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// GlobalTrigger实现
</span><span style=color:#fa6e32>unsafe impl</span><span>&LTE</span><span style=color:#61676ccc>: </span><span>for<</span><span style=color:#fa6e32>'a</span><span>> Event&LTTrigger<</span><span style=color:#fa6e32>'a</span><span>> = </span><span style=color:#fa6e32>Self</span><span>>> Trigger&LTE> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>GlobalTrigger </span><span>{
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>trigger</span><span>(...) { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-observer-mod-rs-152-467><code>crates/bevy_ecs/src/observer/mod.rs</code> (+152/-467)</h3><p>Observer系统的重大重构，移除了旧的trigger_targets API，统一使用trigger API。<p><strong>关键变更：</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// 旧的API
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_targets</span><span>(Explode</span><span style=color:#61676ccc>,</span><span> entity)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// 新的API
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(Explode { entity })</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ecs-src-event-buffered-event-mod-rs-180-0><code>crates/bevy_ecs/src/event/buffered_event/mod.rs</code> (+180/-0)</h3><p>新文件，包含了BufferedEvent相关的功能（虽然重命名为Message的计划暂未实施）。<h3 id=crates-bevy-animation-src-animation-event-rs-58-0><code>crates/bevy_animation/src/animation_event.rs</code> (+58/-0)</h3><p>新文件，为动画事件提供了专门的AnimationEvent trait和Trigger实现。<h2 id=further-reading>Further Reading</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/ecs/events/ target=_blank>Bevy ECS Event System Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Observer_pattern target=_blank>Observer Pattern Explained</a><li><a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ch10-00-generics.html target=_blank>Rust Type System and Generics</a><li><a rel="noopener nofollow noreferrer" href=https://blog.rust-lang.org/2015/05/11/traits.html target=_blank>Zero-Cost Abstractions in Rust</a></ol><p>对于想要深入了解这个PR的开发者，建议阅读：<ul><li>PR描述中的详细设计 rationale<li>修改后的示例代码，特别是<code>examples/ecs/observers.rs</code><li>新的测试用例，了解各种事件类型的使用方式</ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_20731.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>