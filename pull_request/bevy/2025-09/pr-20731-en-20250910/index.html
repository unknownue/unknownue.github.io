<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://unknownue.github.io name=base><title>
         #20731 Event Rearchitecture
        
    </title><meta content="#20731 Event Rearchitecture" property=og:title><meta content="A personal blog built with Zola and Apollo theme" property=og:description><meta content="A personal blog built with Zola and Apollo theme" name=description><link href=/icons/favicon.png rel=icon type=image/png><link href=https://unknownue.github.io/fonts.css rel=stylesheet><script src=https://unknownue.github.io/js/codeblock.js></script><script src=https://unknownue.github.io/js/toc.js></script><script src=https://unknownue.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Unknownue's Blog" href=https://unknownue.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://unknownue.github.io/theme/light.css rel=stylesheet><link href=https://unknownue.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://unknownue.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://unknownue.github.io/main.css media=screen rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script><script>// Initialize mermaid once DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            mermaid.initialize({
                startOnLoad: false,
                theme: document.body && document.body.classList.contains('dark') ? 'dark' : 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                sequence: {
                    diagramMarginX: 50,
                    diagramMarginY: 10,
                    actorMargin: 50,
                    width: 150,
                    height: 65
                }
            });
        });</script><script src=https://unknownue.github.io/js/main.js></script><script defer src=https://unknownue.github.io/js/label-colors.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js></script><script>// Ensure highlight.js is properly configured
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof hljs !== 'undefined') {
                hljs.configure({
                    languages: ['rust', 'javascript', 'python', 'cpp', 'go', 'typescript'],
                    ignoreUnescapedHTML: true
                });
                console.log('Highlight.js configured in header');
            }
        });</script><link href=https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js></script><script src=https://unknownue.github.io/js/syntax-highlight.js></script><script src=https://unknownue.github.io/js/diff-sidebar.js></script><script src="https://unknownue.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://unknownue.github.io>Unknownue's Blog</a><div class=socials><a class=social href=https://github.com/unknownue rel=me> <img alt=github src=https://unknownue.github.io/icons/social/github.svg> </a><a class=social href=https://github.com/unknownue/unknownue.github.io rel=me> <img alt=github-io src=https://unknownue.github.io/icons/social/rss.svg> </a></div></div><nav><a href=https://unknownue.github.io/posts style=margin-left:.25em>/posts</a><a href=https://unknownue.github.io/projects style=margin-left:.25em>/projects</a><a href=https://unknownue.github.io/about style=margin-left:.25em>/about</a><a href=https://unknownue.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://unknownue.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://unknownue.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://unknownue.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><div class=pull-request-page><article class=md-content-page style=display:none></article><div class=back-link><a href=/pull_request/bevy/2025-09/>← Back to Pull Requests</a></div><div class=pr-metadata><span class=pr-date>2025-09-10</span><div class=language-switcher><span class="lang-link active" data-lang=en>English</span> / <a class=lang-link data-lang=zh-cn href=/pull_request/bevy/2025-09/pr-20731-zh-cn-20250910>中文</a></div></div><div class=pr-content><h1 id=event-rearchitecture>Event Rearchitecture</h1><h2 id=basic-information>Basic Information</h2><ul><li><strong>Title</strong>: Event Rearchitecture<li><strong>PR Link</strong>: https://github.com/bevyengine/bevy/pull/20731<li><strong>Author</strong>: cart<li><strong>Status</strong>: MERGED<li><strong>Labels</strong>: A-ECS, C-Usability, A-Animation, M-Needs-Migration-Guide, D-Complex, M-Needs-Release-Note, X-Blessed, D-Unsafe, S-Waiting-on-Author<li><strong>Created</strong>: 2025-08-24T02:16:51Z<li><strong>Merged</strong>: 2025-09-10T00:08:24Z<li><strong>Merged By</strong>: cart</ul><h2 id=description-translation>Description Translation</h2><p>There is general consensus that our terminology for Events, “entity events”, Observers, and BufferedEvents needs clarity. Additionally, many of us also agree that the current Observer system would benefit from additional static-ness: currently it is assumed that you can use events in pretty much any context, and they all go through the exact same code path.<p>Alice put forth a proposal to <a rel="noopener nofollow noreferrer" href=https://hackmd.io/@bevy/rk4S92hmlg target=_blank>Overhaul Observers</a>, and we have already partially implemented it for 0.17. I think it does a great job of outlining many of the issues at play, and it solves them reasonably well. But I <em>also</em> think the proposed solution isn’t yet ideal. Given that it is already partially implemented for 0.17, it is a breaking change, <em>and</em> given that we have already broken the Observer API a number of times, I think we need to sort this out before the next release.<p>This is a big changeset, but it is <em>largely</em> just a reframing of what is already there. I haven’t fundamentally changed the behaviors. I’ve just refined and constrained in a way that allows us to do what we are currently doing in a clearer, simpler, and more performant way.<p>First, I’ll give some quick notes on Alice’s proposal (which you all should read if you haven’t yet!):<h3 id=notes-on-alice-s-proposal>Notes on Alice’s Proposal</h3><ul><li>I like the move toward a more static API<li>I think we’ve gone too far down the “separate terminology” path. The proposal introduces a zoo of apis, terms, and “subterms”. I think we need to simplify our concepts and names to make this all easier to talk about and use in practice.<li>BroadcastEvent feels like the wrong name. EntityEvent is also “broadcast” in the exact same way<li>BufferedEvent is a completely different system than EntityEvent and BroadcastEvent. This muddles concepts too much. It needs its own standalone, single-word concept name.<li>“Universal observers”: I think this should be fully context driven, rather than needing encoding in the API.<li>I agree we can’t get rid of buffered events, and that merging them with “broadcast events” isn’t helpful<li>I’m not quite sure how we’d make the proposed PropagateEvent subtrait work transparently. This can’t be “layered on top” as a trait. It needs to be baked in at more fundamental level.</ul><ul><li>I don’t like <code>app.add_broadcast_observers()</code>, <code>app.add_universal_observers()</code>, <code>Observer::entity_observer</code>, <code>Observer::broadcast</code>, etc. The <code>On</code> event should statically determine whether an observer is an “entity observer” or a “broadcast” Observer. This would already be encoded in the type system and is therefore something we can do on the developer’s behalf. Likewise, any observer being registered at a top level is inherently <em>not</em> a specific entity observer. All of these variants serve to make users guess and poke around in a way that is unnecessary. I want simple one word concept names, single constructors, etc.</ul><h3 id=proposed-principals>Proposed Principals</h3><ul><li>Static-ness: <ul><li>Events should only be usable in the context they were defined to be used.<li>When triggered, Observers should <em>only</em> have access to fields and behaviors that are relevant: <ul><li>Dont return Option or PLACEHOLDER: the field or function shouldn’t exist<li>Entity events that don’t support propagation shouldn’t expose that functionality</ul></ul><li>Don’t do unnecessary work at runtime <ul><li>Event triggers shouldn’t branch through every potential event code path <ul><li>Don’t clone potentially large lists of event context unnecessarily (Ex: we currently clone the component list for every observer invocation)</ul></ul><li>Minimize codegen <ul><li>Don’t recompile things redundantly.<li>Don’t compile unnecessary code paths.</ul><li>Clear and Simple <ul><li>Minimize the number of concept names floating around, and lock each concept down heavily to a specific context<li>I’m convinced at this point that “buffered events” and “observer events” sharing concept names is wrong. We need two clean and clear terms, and I’m willing to give “buffered events” a slightly worse name if it means “observer events” can be nicer.<li>Don’t throw the concept name “Event” out … it is a very good name. Instead, constrain it to one specific thing.<li>Minimize our API surface<li>Events contain all context, including what used to be the “target”. This lets people define the “target” name that makes the most sense for the context, and lets the documentation fully describe the context of that “target”.</ul></ul><h3 id=concepts>Concepts</h3><ul><li><strong>Event</strong> (the thing you “observe”) <ul><li>Rationale: “Event” is the clear choice for this concept. An “event” feels like something that happens in real time. “Event observers” are things that observe events when they occur (are triggered). Additionally, this is the concept that “propagates”, and “event propagation” is a term people understand.<li><strong>Trigger</strong>: (the verb that “causes” events to happen for targets). Events are Triggered. This can include additional context/ data that is passed to observers / informs the trigger behavior. Events have <em>exactly</em> one Trigger. If you want a different trigger behavior, define a new event. This makes the system more static, more predictable, and easier to understand and document. <code>world.trigger_ref_with</code> makes it possible to pass in mutable reference to your own Trigger data, making it possible to customize the input trigger data and read out the final trigger data.<li><strong>Observer</strong> (the thing that “observes” events): An event’s <code>Trigger</code> determines which observers will run.<li><strong>Event Types</strong>: You can build any “type” of event. The concept of a “target” has been removed. Instead, define a <code>Trigger</code> that expects a specific kind of event (ex: <code>E: EntityEvent</code>). <ul><li><strong>EntityEvent</strong> We add a new <code>EntityEvent</code> trait, which defines an <code>event.entity()</code> accessor. This is used by the <code>Trigger</code> impls : <code>EntityTrigger</code>, <code>PropagateEntityTrigger</code>, and <code>EntityComponentsTrigger</code>.</ul></ul><li><strong>Message</strong> (the buffered thing you “read” and “write”) <ul><li><code>Message</code> is a solid metaphor for what this is … it is data that is written and then at some later point read by someone / something else. I expect existing consumers of “buffered events” to lament this name change, as “event” feels nicer. But having a separate name is within everyone’s best interest.<li><strong>MessageReader</strong> (the thing that reads messages)<li><strong>MessageWriter</strong> (the thing that writes messages)</ul></ul><h3 id=the-changes>The Changes</h3><ul><li><code>Event</code> trait changes <ul><li>Event is now used exclusively by Observers<li>Added <code>Event::Trigger</code>, which defines what trigger implementation this event will use</ul><li>Added the <code>Trigger</code> trait <ul><li>All of the shared / hard-coded observer trigger logic has been broken out into individual context-specific Trigger traits.</ul><li>“Trigger Targets” have been removed. <ul><li>Instead, Events, in combination with their Trigger impl, decide how they will be triggered. In general, this means that Events now include their “targets” as fields on the event.<li>APIs like <code>trigger_targets</code> have been replaced by <code>trigger</code>, which can now be used for any <code>Event</code></ul><li><code>EntityEvent</code> trait changes <ul><li>Propagation config has been removed from the <code>EntityEvent</code> trait. It now lives on the <code>Trigger</code> trait (specifically the <code>PropagateEntityTrigger</code> trait).<li><code>EntityEvent</code> now provides <code>entity / entity_mut</code> accessors for the Event it is implemented for<li><code>EntityEvent</code> defaults to having no propagation (uses the simpler <code>EntityTrigger</code>)<li><code>#[entity_event(propagate)]</code> enables the “default” propagation logic (uses ChildOf). The existing <code>#[entity_event(traversal = X)]</code> has been renamed to <code>#[entity_event(propagate = X)</code><li>Deriving <code>EntityEvent</code> requires either a single <code>MyEvent(Entity)</code>, the <code>entity</code> field name (<code>MyEvent { entity: Entity}</code>), or <code>MyEvent { #[event_entity] custom: Entity }</code></ul><li>Animation event changes <ul><li>Animation events now have their own <code>AnimationEvent</code> trait, which sets the <code>AnimationEventTrigger</code>. This allows developers to pass in events that <em>dont</em> include the Entity field (as this is set by the system). The custom trigger also opens the doors to cheaply passing in additional animation system context, accessible through <code>On</code></ul><li><code>EntityComponentsTrigger</code> <ul><li>The built in Add/Remove/etc lifecycle events now use the <code>EntityComponentsTrigger</code>, which passes in the components as additional state. This <em>significantly</em> cuts down on clones, as it does a borrow rather than cloning the list into <em>each</em> observer execution.<li>Each event now has an <code>entity</code> field.</ul><li>Style changes <ul><li>Prefer the event name for variables: <code>explode: On&LTExplode></code> not <code>event: On&LTExplode></code><li>Prefer using the direct field name for the entity on entity events, rather than <code>event.entity()</code>. This allows us to use more specific names where appropriate, provides better / more contextual docs, and coaches developers to think of <code>On&LTMyEvent></code> <em>as</em> the event itself.</ul></ul><p>Take a look at the changes to the examples and the built-in events to see what this looks like in practice.<h3 id=downsides>Downsides</h3><ul><li>Moving the “target” into the event adds some new constraints: <ul><li>Triggering the same event for multiple entities requires multiple trigger calls. For “expensive” events (ex: lots of data attached to the event), this will be more awkward. Your options become: <ul><li>Create multiple instances of the event, cloning the expensive data<li>Use <code>trigger_ref</code>, and mutate the event on each call to change the target.<li>Move the “expensive” shared data into the Trigger, and use `trigger_ref_with``<li>We could build a new EntityEvent method that abstracts over the “event mutation” behavior and provides something like the old <code>trigger_target</code> behavior.<li>Use a different <code>EntityTargetTrigger</code> (not currently provided by bevy, but we could), which brings back the old behavior. This would be used with <code>trigger_with</code> to replicate the old pattern: <code>world.trigger_with(MyEvent, [e1, e2].into())</code> (or we could make the <code>into()</code> implicit)</ul><li>Bubbling the event involves mutating the event to set the entity. This means that <code>trigger_ref</code> will result in the event’s <code>EntityEvent::entity()</code> being the final bubbled entity instead of the initial entity.<li>Some APIs (trivially) benefit from the “target entity” being separate from the event. Specifically, this new API requires changes to the “Animation Event” system in AnimationPlayer. I think this is actually a good change set, as it allows us to: <ul><li>Cheaply expose more animation state as part of a new AnimationEventTrigger impl<li>Move that “implict” entity target provided by the AnimationPlayer into the AnimationEventTrigger<li>Encode the “animation event trigger-ness” of the event into the type itself (by requiring <code>#[event(trigger = AnimationEventTrigger)]</code>)<li>By not implementing Default for AnimationEventTrigger, we can block animation events from being fired manually by the user.</ul></ul></ul><h3 id=draft-todo>Draft TODO</h3><ul><li><input checked disabled type=checkbox> Fill in documentation and update existing docs<li><input disabled type=checkbox> Benchmark: I expect this impl to be significantly faster. There might also be tangible binary size improvements, as I’ve removed a lot of redundant codegen.<li><input checked disabled type=checkbox> Update release notes and migration guides</ul><h3 id=next-steps>Next Steps</h3><ul><li>The <code>BufferedEvent -> Message</code> rename was not included to keep the size down.</ul><p>Fixes #19648<h2 id=the-story-of-this-pull-request>The Story of This Pull Request</h2><p>This PR addresses fundamental issues with Bevy’s event system architecture. The existing system had become complex and ambiguous, with overlapping terminology and inefficient runtime behaviors. The core problem was that events were designed to work in any context, which led to unnecessary runtime branching, code duplication, and conceptual confusion for developers.<p>The solution introduces a more static and constrained architecture. Events are now categorized into clear concepts: <strong>Events</strong> for observable actions and <strong>Messages</strong> for buffered data. Each event type defines its own triggering behavior through the new <code>Trigger</code> trait, which determines which observers run and what data they receive.<p>Key technical changes include:<ol><li><strong>Event trait refinement</strong>: The <code>Event</code> trait now includes an associated <code>Trigger</code> type that defines how the event is triggered<li><strong>Entity events</strong>: The new <code>EntityEvent</code> trait handles events targeting specific entities, with the target included as a field<li><strong>Trigger specialization</strong>: Different trigger implementations (<code>GlobalTrigger</code>, <code>EntityTrigger</code>, <code>PropagateEntityTrigger</code>) provide optimized paths for different event types<li><strong>Performance improvements</strong>: Reduced cloning and branching through better static dispatch and borrow-based data passing</ol><p>The implementation required significant changes to the observer system, event macros, and related APIs. For example, the <code>trigger_targets</code> method was removed in favor of including targets directly in event data:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Event)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Explode</span><span style=color:#61676ccc>;
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_targets</span><span>(Explode</span><span style=color:#61676ccc>,</span><span> entity)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(EntityEvent)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Explode </span><span>{
</span><span>    entity</span><span style=color:#61676ccc>:</span><span> Entity
</span><span>}
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(Explode { entity })</span><span style=color:#61676ccc>;
</span></code></pre><p>This change makes the API more explicit and allows for better documentation of event context. The <code>On</code> type (previously <code>Trigger</code>) was also updated to provide direct access to event fields:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(|</span><span style=color:#ff8f40>trigger</span><span style=color:#61676ccc>: </span><span>Trigger&LTExplode>| {
</span><span>    </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"Entity </span><span style=color:#ff8f40>{}</span><span style=color:#86b300> exploded"</span><span style=color:#61676ccc>,</span><span> trigger</span><span style=color:#ed9366>.</span><span style=color:#f07171>entity</span><span>())</span><span style=color:#61676ccc>;
</span><span>})</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>add_observer</span><span>(|</span><span style=color:#ff8f40>explode</span><span style=color:#61676ccc>: </span><span>On&LTExplode>| {
</span><span>    </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"Entity </span><span style=color:#ff8f40>{}</span><span style=color:#86b300> exploded"</span><span style=color:#61676ccc>,</span><span> explode</span><span style=color:#ed9366>.</span><span>entity)</span><span style=color:#61676ccc>;
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p>The architecture now supports proper propagation control through the <code>PropagateEntityTrigger</code>, which allows events to bubble up entity hierarchies while maintaining type safety and performance.<p>These changes result in a clearer, more performant event system that is easier to understand and use. The static nature of the new design eliminates unnecessary runtime checks and reduces codegen, while the improved terminology and APIs make the system more intuitive for developers.<h2 id=visual-representation>Visual Representation</h2><pre class=language-mermaid data-lang=mermaid style=color:#61676c;background-color:#fafafa><code class=language-mermaid data-lang=mermaid><span>graph TD
</span><span>    A[Event] --> B[GlobalTrigger]
</span><span>    A --> C[EntityEvent]
</span><span>    C --> D[EntityTrigger]
</span><span>    C --> E[PropagateEntityTrigger]
</span><span>    C --> F[EntityComponentsTrigger]
</span><span>    A --> G[AnimationEvent]
</span><span>    G --> H[AnimationEventTrigger]
</span><span>    I[Message] --> J[BufferedEvent]
</span></code></pre><h2 id=key-files-changed>Key Files Changed</h2><h3 id=crates-bevy-ecs-src-event-mod-rs-345-33><code>crates/bevy_ecs/src/event/mod.rs</code> (+345/-33)</h3><p>This file now defines the core event traits and types. The <code>Event</code> trait was refactored to include an associated <code>Trigger</code> type, and the <code>EntityEvent</code> trait was added for entity-targeted events.<p><strong>Key changes:</strong><ul><li>Added <code>Event</code> trait with associated <code>Trigger</code> type<li>Added <code>EntityEvent</code> trait with entity accessors<li>Removed old event types and consolidated functionality</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + 'static {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>register_event_key</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> World) </span><span style=color:#61676ccc>-></span><span> EventKey</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>event_key</span><span>(</span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>World) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTEventKey></span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Event</span><span>: Send + Sync + Sized + 'static {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Trigger</span><span style=color:#ed9366><</span><span style=color:#fa6e32>'a</span><span style=color:#ed9366>></span><span style=color:#61676ccc>: </span><span>Trigger<</span><span style=color:#fa6e32>Self</span><span>></span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-event-trigger-rs-430-0><code>crates/bevy_ecs/src/event/trigger.rs</code> (+430/-0)</h3><p>This new file implements the <code>Trigger</code> trait and its specialized implementations for different event contexts.<p><strong>Key code:</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub unsafe trait </span><span style=color:#399ee6>Trigger</span><span>&LTE: Event> {
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>trigger</span><span>(
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>,
</span><span>        </span><span style=color:#ff8f40>world</span><span style=color:#61676ccc>:</span><span> DeferredWorld,
</span><span>        </span><span style=color:#ff8f40>observers</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>CachedObservers,
</span><span>        </span><span style=color:#ff8f40>trigger_context</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>TriggerContext,
</span><span>        </span><span style=color:#ff8f40>event</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> E,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// GlobalTrigger implementation for basic events
</span><span style=color:#fa6e32>unsafe impl</span><span>&LTE</span><span style=color:#61676ccc>: </span><span>for<</span><span style=color:#fa6e32>'a</span><span>> Event&LTTrigger<</span><span style=color:#fa6e32>'a</span><span>> = </span><span style=color:#fa6e32>Self</span><span>>> Trigger&LTE> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>GlobalTrigger </span><span>{
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>trigger</span><span>(...) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Trigger global observers
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-src-observer-mod-rs-152-467><code>crates/bevy_ecs/src/observer/mod.rs</code> (+152/-467)</h3><p>This file was significantly refactored to work with the new event system. The <code>trigger_targets</code> API was removed and replaced with a unified <code>trigger</code> method.<p><strong>Key changes:</strong><ul><li>Removed <code>TriggerTargets</code> trait and related functionality<li>Updated <code>World::trigger</code> to handle all event types<li>Simplified observer invocation logic</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Before:
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger_targets</span><span>(Explode</span><span style=color:#61676ccc>,</span><span> entity)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// After:
</span><span>world</span><span style=color:#ed9366>.</span><span style=color:#f07171>trigger</span><span>(Explode { entity })</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=crates-bevy-ecs-src-observer-system-param-rs><code>crates/bevy_ecs/src/observer/system_param.rs</code></h3><p>The <code>On</code> type was updated to work with the new event system and provide better access to event data.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>On</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'t</span><span>, E</span><span style=color:#61676ccc>:</span><span> Event, B</span><span style=color:#61676ccc>:</span><span> Bundle = ()> {
</span><span>    event</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'w mut</span><span> E,
</span><span>    trigger</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'w mut E</span><span style=color:#ed9366>::</span><span>Trigger<</span><span style=color:#fa6e32>'t</span><span>>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ...
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'t</span><span>, E</span><span style=color:#61676ccc>:</span><span> Event, B</span><span style=color:#61676ccc>:</span><span> Bundle> </span><span style=color:#399ee6>On</span><span><</span><span style=color:#fa6e32>'w</span><span>, </span><span style=color:#fa6e32>'t</span><span>, E, B> {
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>event</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>E {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>event
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>event_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> E {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>event
</span><span>    }
</span><span>}
</span></code></pre><h3 id=crates-bevy-ecs-macros-src-component-rs><code>crates/bevy_ecs/macros/src/component.rs</code></h3><p>The event derives were updated to support the new attributes and generate appropriate <code>Trigger</code> implementations.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// EntityEvent derive with propagation
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(EntityEvent)]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>entity_event</span><span>(propagate)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Click </span><span>{
</span><span>    entity</span><span style=color:#61676ccc>:</span><span> Entity
</span><span>}
</span></code></pre><h2 id=further-reading>Further Reading</h2><ul><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/observer-system target=_blank>Bevy Observer Documentation</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/bevyengine/rfcs/pull/45 target=_blank>Event System RFC</a><li><a rel="noopener nofollow noreferrer" href=https://bevyengine.org/learn/ecs-introduction/ target=_blank>Entity Component System Chapter</a></ul></div><div data-is-md-page=true data-patch-exists=true data-patch-path=/pull_request/bevy/2025-09/pr_20731.patch id=patch-info style=display:none></div><div class=bottom-spacer></div></div></div>