+++
title = "PR #18123"
date = "2025-03-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-03/pr-18123-zh-cn-20250303-071707" }}
+++

# PR #18123: Reextract meshes when their material assets change

## Basic Information
- **Title**: Reextract meshes when their material assets change
- **PR Link**: https://github.com/bevyengine/bevy/pull/18123
- **Author**: pcwalton
- **Status**: MERGED
- **Created**: 2025-03-03T00:59:28Z
- **Merged**: 2025-03-03T04:12:15Z
- **Merged By**: cart

## Description Translation
该提交使`mark_meshes_as_changed_if_their_materials_changed`系统在原有`Changed<MeshMaterial3d>`查询基础上，新增使用`AssetChanged<MeshMaterial3d>`查询过滤器。这确保我们能更新包含无绑定材质槽位的`MeshInputUniform`。更新该Uniform修复了当`MeshBindGroupAllocator`重新分配网格导致其无绑定槽位变化时出现的问题。

关闭 #18102。

## The Story of This Pull Request

### 问题的浮现与背景
在Bevy渲染管线中，材质系统通过无绑定技术（bindless）管理材质槽位。当材质资产发生变化时（例如重新加载或修改），需要及时更新关联网格的`MeshInputUniform`数据。但原有实现只监测`Changed<MeshMaterial3d>`组件变更，未能捕获材质资产本身的变化事件（AssetChanged）。这导致当材质槽位被重新分配时，部分网格的Uniform数据未能同步更新，引发材质错位或丢失的渲染异常。

### 开发者的探索之路
作者pcwalton通过issue #18102发现，当使用`AssetServer`热重载材质时，部分网格未能正确更新其材质绑定。通过调试追踪，发现问题根源在于`MeshBindGroupAllocator`重新分配材质槽位后，相关网格的`MeshInputUniform.material_handle`字段未及时更新。进一步分析发现，原有系统仅通过`Changed<MeshMaterial3d>`组件变更检测机制来触发更新，而材质资产变更事件需要通过`AssetChanged`事件单独处理。

### 精妙的解决方案
在`material.rs`中关键修改如下：

```rust
// 修改前系统参数：
Query<..., Changed<MeshMaterial3d>>

// 修改后系统参数：
Query<..., Or<(Changed<MeshMaterial3d>, AssetChanged<MeshMaterial3d>)>>
```

这个改动将两种变更检测机制有机结合：
1. `Changed<MeshMaterial3d>`：捕获组件数据的直接修改
2. `AssetChanged<MeshMaterial3d>`：捕获底层材质资产的变化

双管齐下的策略确保无论是通过ECS组件直接修改材质参数，还是通过资产系统更新材质内容，都能正确触发`MeshInputUniform`的更新流程。

### 技术洞察：资产与组件的双重维度
Bevy的资产系统与ECS组件系统存在正交性：
- **组件变更（Changed）**：反映实体组件数据的直接修改
- **资产变更（AssetChanged）**：表示底层资产文件的更新事件

这种设计允许：
```rust
// 示例场景：热重载材质
asset_server.watch_for_changes().unwrap();
let handle = asset_server.load("material.material");
// 当外部文件修改时触发AssetChanged事件，无需直接修改组件
```

### 深远影响与启示
此修复：
1. 确保bindless渲染管线中材质槽位动态分配的可靠性
2. 完善资产热重载工作流的完整性
3. 揭示Bevy中资产-组件协同工作的最佳实践

未来扩展可考虑将这种双重检测模式抽象为通用模式，用于其他需要同时响应组件和资产变更的场景。

## Visual Representation

```
┌─────────────────────┐     ┌──────────────────────────┐
│   Material Asset    │───→│ AssetChanged<MeshMaterial3d> │
└─────────────────────┘     └──────────────┬─────────────┘
                                           │
┌─────────────────────┐     ┌──────────────▼─────────────┐
│ MeshMaterial3d Comp │───→│      Changed<MeshMaterial3d> │
└─────────────────────┘     └──────────────┬─────────────┘
                                           │
                                  ┌────────▼────────┐
                                  │ Update Uniform   │
                                  │ MeshInputUniform │
                                  └─────────────────┘
```

## Key Files Changed

### File: `crates/bevy_pbr/src/material.rs`
**变更说明**：扩展材质变更检测逻辑，增加资产变更事件处理

核心代码变更：
```rust
// 修改前：
fn mark_meshes_as_changed_if_their_materials_changed(
    materials: Query<&Handle<MeshMaterial3d>, Changed<MeshMaterial3d>>,
    // ...
)

// 修改后：
fn mark_meshes_as_changed_if_their_materials_changed(
    materials: Query<&Handle<MeshMaterial3d>, Or<(Changed<MeshMaterial3d>, AssetChanged<MeshMaterial3d>)>>,
    // ...
)
```

此修改通过逻辑或（Or）组合查询条件，使得系统能同时响应两种不同类型的变更事件，确保材质槽位更新无遗漏。

## Further Reading
1. [Bevy Asset System 官方文档](https://bevyengine.org/learn/book/assets/)
2. [ECS 变更检测机制详解](https://bevyengine.org/learn/book/change-detection/)
3. [现代图形API中的Bindless技术解析](https://www.khronos.org/opengl/wiki/Bindless_Texture)