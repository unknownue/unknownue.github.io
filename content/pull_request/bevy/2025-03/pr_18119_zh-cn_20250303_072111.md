+++
title = "PR #18119"
date = "2025-03-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-03/pr-18119-zh-cn-20250303-072111" }}
+++

# Title: Fix panic with multiple fog volumes

## Basic Information
- **Title**: Fix panic with multiple fog volumes
- **PR Link**: https://github.com/bevyengine/bevy/pull/18119
- **Author**: greeble-dev
- **Status**: MERGED
- **Created**: 2025-03-02T19:43:55Z
- **Merged**: 2025-03-03T14:22:10Z
- **Merged By**: alice-i-cecile

## Description Translation
### 目标
修复 https://github.com/bevyengine/bevy/issues/17590

### 解决方案
`prepare_volumetric_fog_uniforms` 函数为每个雾体积（fog volume）和视图（view）的组合添加uniform。但原本只给每个视图分配了单个雾体积的uniform空间。

### 测试
在`volumetric_fog`示例中使用1/2/3/4个雾体积运行测试。同时检查了`fog_volumes`和`scrolling_fog`示例（无多个体积的情况）。测试环境为Win10/Vulkan/Nvidia。

尝试在`split_screen`示例中添加雾体积时发现分屏视图的雾位置问题，但该问题在PR前后都存在，推测是独立bug。

![image](https://github.com/user-attachments/assets/4a74d6d7-8a73-4322-9dc6-c5ddd054ece2)

## The Story of This Pull Request

### 问题与背景
故事始于一位开发者在使用Bevy的体積霧（volumetric fog）功能时发现一个致命错误。当场景中存在多个雾体积时，引擎会突然崩溃（panic），错误指向GPU缓冲区溢出。这个问题不仅破坏了视觉效果，更威胁到引擎的稳定性。

问题的根源在于uniform缓冲区的分配逻辑。每个视图（view）需要处理多个雾体积，但原有代码假设每个视图只有一个雾体积。就像给多个客人只准备了一个座位，当客人数量增加时，必然会发生混乱。

### 开发者之旅
开发者首先通过issue #17590重现问题，确认当雾体积数量超过1时，`prepare_volumetric_fog_uniforms`函数中的缓冲区写入会越界。关键线索来自缓冲区大小的计算方式：

```rust
// 原有错误逻辑
let count = views.iter().count();
uniforms.buffer.resize(count);
```

这里只为每个视图分配了一个uniform的空间，而实际上需要为每个视图的每个雾体积分配空间。开发者意识到需要将计算方式改为视图数与每个视图关联的雾体积数的乘积。

### 实现细节
解决方案的核心在于动态计算所需uniform数量。修改后的代码通过遍历所有视图，统计每个视图关联的雾体积数量：

```rust
// 修正后的正确逻辑
let count = views
    .iter()
    .map(|(view, _)| view.fog_volume_entities.len())
    .sum();
uniforms.buffer.resize(count);
```

这个改动就像把固定大小的储物柜换成可扩展的仓库，根据实际需求动态调整存储空间。同时，写入循环也相应修改为双重循环结构：

```rust
for (view_index, (view, view_uniform)) in views.iter().enumerate() {
    for (volume_index, &volume_entity) in view.fog_volume_entities.iter().enumerate() {
        // 写入每个视图-雾体积组合的uniform数据
        let offset = uniforms.buffer.push(...);
    }
}
```

### 技术洞察
这个修复展示了几个重要的图形编程原则：
1. **资源预分配**：必须根据实际使用场景动态计算GPU资源需求
2. **数据对齐**：Uniform缓冲区的布局需要与着色器端定义严格匹配
3. **多视图支持**：现代图形引擎需要处理多摄像机（multi-camera）场景的复杂性

### 影响与启示
修复后，Bevy的体積霧系统可以稳定支持多个雾体积，为复杂场景的视觉效果提供了基础。这也提醒开发者：
- 在处理视图相关资源时要考虑一对多关系
- GPU资源管理需要精确的数学计算
- 测试用例应覆盖边界情况（edge cases）

## Visual Representation

```
┌─────────────┐     ┌──────────────────────┐     ┌──────────────┐
│  View Data  │────>│ prepare_volumetric_fog │────>│ Uniform Buffer│
└─────────────┘     └──────────────────────┘     └──────────────┘
                          │
                          ▼
                    ┌──────────────┐
                    │ Fog Volumes  │
                    └──────────────┘
```

## Key Files Changed

### File: `crates/bevy_pbr/src/volumetric_fog/render.rs` (+8/-8)

**修改说明**：
1. 修正uniform缓冲区的分配逻辑，根据每个视图关联的雾体积数量动态计算总需求
2. 改进数据写入循环结构，支持多视图多雾体积的场景

关键代码对比：

```rust
// Before:
let count = views.iter().count();
uniforms.buffer.resize(count);

// After:
let count = views
    .iter()
    .map(|(view, _)| view.fog_volume_entities.len())
    .sum();
uniforms.buffer.resize(count);
```

```rust
// 数据写入循环结构改进
for (view_index, (view, view_uniform)) in views.iter().enumerate() {
    // 新增雾体积遍历循环
    for (volume_index, &volume_entity) in view.fog_volume_entities.iter().enumerate() {
        // 计算每个雾体积的偏移量
        let offset = uniforms.buffer.push(...);
    }
}
```

## Further Reading

1. [Bevy渲染架构指南](https://bevyengine.org/learn/book/rendering/architecture/)
2. [WGSL Uniform Buffer规范](https://www.w3.org/TR/WGSL/#address-spaces-uniform)
3. [现代图形API资源管理模式](https://developer.nvidia.com/blog/introduction-modern-graphics-programming/)
4. [多摄像机渲染技术](https://learnopengl.com/Advanced-OpenGL/Cubemaps)