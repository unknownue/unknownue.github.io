+++
title = "#23102 Add component info to BRP registry schema"
date = "2026-03-01T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-03/pr-23102-en-20260301" }}
labels = ["A-ECS", "A-Dev-Tools", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Add component info to BRP registry schema
- **PR Link**: https://github.com/bevyengine/bevy/pull/23102
- **Author**: splo
- **Status**: MERGED
- **Labels**: A-ECS, S-Ready-For-Final-Review, A-Dev-Tools, D-Straightforward
- **Created**: 2026-02-21T22:11:53Z
- **Merged**: 2026-03-01T21:11:31Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

Add component metadata to the BRP `registry.schema` method.

The following data related to components is missing and this PR adds it:
- Whether the component is mutable or not.
- Type paths of required components.
- Whether the component is a relationship or relationship target.

Other metadata could easily be added, basically everything in the [`ComponentInfo`](https://docs.rs/bevy/latest/bevy/ecs/component/struct.ComponentInfo.html) type.

## Solution

- Once per type, use `World::components` to obtain a potential `ComponentId` and `ComponentInfo`.
- Use it to fill the new `component_info` field.
- It doesn't introduce a breaking change, as the new field is optional and hidden for non-component types.

## Testing

- I added a unit test. It verifies mutability, required components, and relationship kind for a few test components.
- I also called BRP to retrieve a schema and verify the returned data is correct.

---

## Showcase

Here are a few examples of the returned JSON schema when calling the BRP `registry.schema` method, with other fields omitted for brevity (they are unchanged):

```json
{
  "bevy_ecs::hierarchy::ChildOf": {
    "componentInfo": {
      "isSendAndSync": true,
      "mutable": false,
      "relationshipKind": "Relationship",
      "storageType": "Table"
    }
  },
  "bevy_ecs::hierarchy::Children": {
    "componentInfo": {
      "isSendAndSync": true,
      "mutable": true,
      "relationshipKind": "RelationshipTarget",
      "storageType": "Table"
    }
  },
  "bevy_transform::components::transform::Transform": {
    "componentInfo": {
      "isSendAndSync": true,
      "mutable": true,
      "requiredComponentTypes": [
        "bevy_transform::components::global_transform::GlobalTransform",
        "bevy_transform::components::transform::TransformTreeChanged"
      ],
      "storageType": "Table"
    }
  },
  "bevy_render::sync_world::SyncToRenderWorld": {
    "componentInfo": {
      "isSendAndSync": true,
      "mutable": true,
      "storageType": "SparseSet"
    }
  }
}
```

## The Story of This Pull Request

The Bevy Remote Protocol (BRP) provides a way to introspect type information through its `registry.schema` method, which returns JSON schemas for registered types. Before this PR, the schema lacked important component-specific metadata that tools and external systems need to understand how components behave in the ECS.

The problem was that while the schema system captured general type information through reflection, it didn't expose ECS-specific component characteristics. Specifically, there was no way to know if a component was mutable, what components it required, whether it used table or sparse set storage, or if it was part of a relationship system. This metadata is crucial for tools that need to understand component behavior without directly interacting with the ECS world.

The solution approach was straightforward: leverage the existing `ComponentInfo` structure that already contains all this metadata, and expose it through the JSON schema. The developer accessed the world's `Components` resource, looked up the `ComponentInfo` for each type, and mapped it to a new `ComponentMetadata` structure in the schema. This approach is non-breaking because the new field is optional and only appears for component types.

The implementation required changes in two main areas. First, in `builtin_methods.rs`, the `export_registry_types` function needed to pass the `Components` resource from the world to the schema generation functions. This was done by adding `let components = world.components();` and modifying the call to `export_type` to include this parameter.

```rust
// In builtin_methods.rs, line 1432
let components = world.components();
// ...
let (id, schema) = export_type(type_reg, extra_info, components);
```

Second, in `json_schema.rs`, the schema generation logic was extended to handle component metadata. A new `ComponentMetadata` struct was added with fields for mutability, storage type, thread safety, required components, and relationship kind. The key conversion logic maps from Bevy's internal `ComponentInfo` to this serializable structure:

```rust
// In json_schema.rs, lines 73-96
let component_info: Option<&ComponentInfo> = components
    .get_valid_id(t.type_id())
    .and_then(|component_id| components.get_info(component_id));
typed_schema.component_info = component_info.map(|info| {
    let mutable = info.mutable();
    let storage_type = info.storage_type().into();
    let is_send_and_sync = info.is_send_and_sync();
    let required_component_types = info
        .required_components()
        .iter_ids()
        .flat_map(|component_id| components.get_info(component_id))
        .map(|info: &ComponentInfo| info.name().to_string())
        .collect::<Vec<_>>();
    let relationship_kind = info
        .relationship_accessor()
        .map(|&relationship| relationship.into());
    ComponentMetadata {
        mutable,
        storage_type,
        is_send_and_sync,
        required_component_types,
        relationship_kind,
    }
});
```

An important technical consideration was how to handle required components. The implementation resolves component IDs to their type names by looking up each required component in the `Components` resource and extracting its name. This ensures that the schema contains human-readable type paths rather than opaque IDs.

The test suite was expanded with a comprehensive unit test that validates the new functionality. The test creates two components with specific characteristics: one with required components and relationship attributes, and another with sparse set storage. It then verifies that the generated schema contains the correct metadata:

```rust
#[test]
fn export_registry_types_with_reliationship() {
    #[derive(Component, Debug, Reflect)]
    #[reflect(Component, Debug)]
    #[require(bevy_ecs::name::Name)]
    #[relationship(relationship_target = FollowedBy)]
    struct Following(Entity);
    
    #[derive(Component, Debug, Reflect)]
    #[component(storage = "SparseSet")]
    #[reflect(Component, Debug)]
    #[relationship_target(relationship = Following)]
    struct FollowedBy(Vec<Entity>);
    
    // ... test setup and assertions
}
```

The impact of this change is significant for tooling and external systems that consume BRP schemas. Now they can understand component constraints and relationships without needing to parse Rust attributes or understand the internal ECS implementation. This enables better editor tooling, documentation generation, and runtime analysis tools.

One technical insight from this implementation is the clean separation between reflection metadata (which handles type structure) and component metadata (which handles ECS behavior). The PR maintains this separation by adding component information as an optional field that only appears for types that are actually registered as components in the ECS world.

The implementation also demonstrates good API design by making the new field optional and using camelCase JSON field names (`componentInfo`) to match JavaScript conventions, since the schema is primarily consumed by web-based tools.

## Visual Representation

```mermaid
graph TD
    A[BRP registry.schema Method] --> B[export_registry_types Function]
    B --> C[World.components() Resource]
    C --> D[export_type Function]
    D --> E[ComponentInfo Lookup]
    E --> F[ComponentMetadata Creation]
    F --> G[JSON Schema with componentInfo]
    
    H[TypeRegistry] --> D
    I[SchemaTypesMetadata] --> D
    
    style G fill:#e1f5e1
    style C fill:#e3f2fd
```

## Key Files Changed

### `crates/bevy_remote/src/schemas/json_schema.rs` (+123/-12)

This file contains the core schema definitions and the logic for converting Bevy types to JSON schema. The main changes include:

1. Added new data structures for component metadata:
```rust
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Default)]
#[serde(rename_all = "camelCase")]
pub struct ComponentMetadata {
    pub mutable: bool,
    pub storage_type: StorageKind,
    pub is_send_and_sync: bool,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub required_component_types: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub relationship_kind: Option<RelationshipKind>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Default)]
pub enum StorageKind {
    #[default]
    Table,
    SparseSet,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum RelationshipKind {
    Relationship,
    RelationshipTarget,
}
```

2. Modified the `JsonSchemaBevyType` struct to include the new optional field:
```rust
pub struct JsonSchemaBevyType {
    // ... existing fields
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub component_info: Option<ComponentMetadata>,
}
```

3. Updated the `From` implementation to accept `Components` and populate component metadata.

### `crates/bevy_remote/src/builtin_methods.rs` (+69/-1)

This file contains the BRP built-in methods implementation. The key changes are:

1. Modified `export_registry_types` to pass the `Components` resource:
```rust
// Before:
let (id, schema) = export_type(type_reg, extra_info);

// After:
let components = world.components();
let (id, schema) = export_type(type_reg, extra_info, components);
```

2. Added a comprehensive unit test that validates the new component metadata functionality with actual component definitions and assertions about the generated schema.

## Further Reading

- [Bevy ECS Component Documentation](https://docs.rs/bevy/latest/bevy/ecs/component/index.html) - Understanding component metadata and storage types
- [Bevy Remote Protocol](https://github.com/bevyengine/bevy/tree/main/crates/bevy_remote) - Overview of BRP capabilities
- [JSON Schema Specification](https://json-schema.org/) - Standard for describing JSON data structures
- [Bevy Reflect System](https://bevy-cheatbook.github.io/programming/reflection.html) - How Bevy's reflection system works