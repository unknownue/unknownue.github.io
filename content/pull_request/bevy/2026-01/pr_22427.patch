diff --git a/crates/bevy_pbr/src/render/mesh.rs b/crates/bevy_pbr/src/render/mesh.rs
index e0243899f6b8d..3e3842a23faf5 100644
--- a/crates/bevy_pbr/src/render/mesh.rs
+++ b/crates/bevy_pbr/src/render/mesh.rs
@@ -1,6 +1,7 @@
 use crate::{
     material_bind_groups::{MaterialBindGroupIndex, MaterialBindGroupSlot},
     resources::write_atmosphere_buffer,
+    skin::skin_uniforms_from_world,
 };
 use bevy_asset::{embedded_asset, load_embedded_asset, AssetId};
 use bevy_camera::{
@@ -217,7 +218,7 @@ impl Plugin for MeshRenderPlugin {
                 .init_resource::<ViewKeyCache>()
                 .init_resource::<ViewSpecializationTicks>()
                 .init_resource::<GpuPreprocessingSupport>()
-                .init_resource::<SkinUniforms>()
+                .add_systems(RenderStartup, skin_uniforms_from_world)
                 .add_systems(
                     Render,
                     check_views_need_specialization.in_set(PrepareAssets),
diff --git a/crates/bevy_pbr/src/render/skin.rs b/crates/bevy_pbr/src/render/skin.rs
index 75c424311a056..653c4392d01b8 100644
--- a/crates/bevy_pbr/src/render/skin.rs
+++ b/crates/bevy_pbr/src/render/skin.rs
@@ -116,41 +116,41 @@ pub struct SkinUniforms {
     total_joints: usize,
 }
 
-impl FromWorld for SkinUniforms {
-    fn from_world(world: &mut World) -> Self {
-        let device = world.resource::<RenderDevice>();
-        let buffer_usages = (if skins_use_uniform_buffers(&device.limits()) {
-            BufferUsages::UNIFORM
-        } else {
-            BufferUsages::STORAGE
-        }) | BufferUsages::COPY_DST;
-
-        // Create the current and previous buffer with the minimum sizes.
-        //
-        // These will be swapped every frame.
-        let current_buffer = device.create_buffer(&BufferDescriptor {
-            label: Some("skin uniform buffer"),
-            size: MAX_JOINTS as u64 * size_of::<Mat4>() as u64,
-            usage: buffer_usages,
-            mapped_at_creation: false,
-        });
-        let prev_buffer = device.create_buffer(&BufferDescriptor {
-            label: Some("skin uniform buffer"),
-            size: MAX_JOINTS as u64 * size_of::<Mat4>() as u64,
-            usage: buffer_usages,
-            mapped_at_creation: false,
-        });
+pub fn skin_uniforms_from_world(world: &mut World) {
+    let device = world.resource::<RenderDevice>();
+    let buffer_usages = (if skins_use_uniform_buffers(&device.limits()) {
+        BufferUsages::UNIFORM
+    } else {
+        BufferUsages::STORAGE
+    }) | BufferUsages::COPY_DST;
+
+    // Create the current and previous buffer with the minimum sizes.
+    //
+    // These will be swapped every frame.
+    let current_buffer = device.create_buffer(&BufferDescriptor {
+        label: Some("skin uniform buffer"),
+        size: MAX_JOINTS as u64 * size_of::<Mat4>() as u64,
+        usage: buffer_usages,
+        mapped_at_creation: false,
+    });
+    let prev_buffer = device.create_buffer(&BufferDescriptor {
+        label: Some("skin uniform buffer"),
+        size: MAX_JOINTS as u64 * size_of::<Mat4>() as u64,
+        usage: buffer_usages,
+        mapped_at_creation: false,
+    });
+
+    let res = SkinUniforms {
+        current_staging_buffer: vec![],
+        current_buffer,
+        prev_buffer,
+        allocator: Allocator::new(MAX_TOTAL_JOINTS),
+        skin_uniform_info: MainEntityHashMap::default(),
+        joint_to_skins: MainEntityHashMap::default(),
+        total_joints: 0,
+    };
 
-        Self {
-            current_staging_buffer: vec![],
-            current_buffer,
-            prev_buffer,
-            allocator: Allocator::new(MAX_TOTAL_JOINTS),
-            skin_uniform_info: MainEntityHashMap::default(),
-            joint_to_skins: MainEntityHashMap::default(),
-            total_joints: 0,
-        }
-    }
+    world.insert_resource(res);
 }
 
 impl SkinUniforms {
