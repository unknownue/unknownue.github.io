diff --git a/benches/benches/bevy_ecs/world/mod.rs b/benches/benches/bevy_ecs/world/mod.rs
index 76a7f6aba00d3..3234729142396 100644
--- a/benches/benches/bevy_ecs/world/mod.rs
+++ b/benches/benches/bevy_ecs/world/mod.rs
@@ -39,5 +39,6 @@ criterion_group!(
     query_get_components_mut_2,
     query_get_components_mut_5,
     query_get_components_mut_10,
+    query_get_components_mut_32,
     entity_set_build_and_lookup,
 );
diff --git a/benches/benches/bevy_ecs/world/world_get.rs b/benches/benches/bevy_ecs/world/world_get.rs
index 080990f85d30b..64a45662d9d26 100644
--- a/benches/benches/bevy_ecs/world/world_get.rs
+++ b/benches/benches/bevy_ecs/world/world_get.rs
@@ -420,3 +420,80 @@ macro_rules! query_get_components_mut {
 query_get_components_mut!(query_get_components_mut_2, 2);
 query_get_components_mut!(query_get_components_mut_5, 5);
 query_get_components_mut!(query_get_components_mut_10, 10);
+
+// I'd like to do this as a macro, but we're bounded by the QueryData tuple size limit
+pub fn query_get_components_mut_32(criterion: &mut Criterion) {
+    #[expect(
+        clippy::identity_op,
+        clippy::erasing_op,
+        reason = "Clippy complains that, at some point in the 32 component
+              bench, C32/RefC32 expand to 0 * 16 or 0 * 4 or 0. The
+              alternative is to make the bounds 2..(n + 2) which is
+              much less readable."
+    )]
+    type C32 = seq!(I in 0..2 {
+        ( #(
+            seq!(J in 0..4 {
+                ( #(
+                    seq!(K in 0..4 {
+                        ( #( WideTable::<{I * 16 + J * 4 + K}>, )* )
+                    }),
+                )* )
+            }),
+        )* )
+    });
+    #[expect(
+        clippy::identity_op,
+        clippy::erasing_op,
+        reason = "Clippy complains that, at some point in the 32 component
+              bench, C32/RefC32 expand to 0 * 16 or 0 * 4 or 0. The
+              alternative is to make the bounds 2..(n + 2) which is
+              much less readable."
+    )]
+    type RefC32<'a> = seq!(I in 0..2 {
+        ( #(
+            seq!(J in 0..4 {
+                ( #(
+                    seq!(K in 0..4 {
+                        ( #( &'a WideTable::<{I * 16 + J * 4 + K}>, )* )
+                    }),
+                )* )
+            }),
+        )* )
+    });
+    let mut group = criterion.benchmark_group(bench!("world_query_get_components_mut"));
+    group.warm_up_time(core::time::Duration::from_millis(500));
+    group.measurement_time(core::time::Duration::from_secs(4));
+
+    for entity_count in RANGE.map(|i| i * 10_000) {
+        let (mut world, entities) = setup_wide::<C32>(entity_count);
+        let mut query = world.query::<EntityMut>();
+        group.bench_function("32_components", |bencher| {
+            bencher.iter(|| {
+                for entity in &entities {
+                    assert!(query
+                        .get_mut(&mut world, *entity)
+                        .unwrap()
+                        .get_components_mut::<RefC32>()
+                        .is_ok());
+                }
+            });
+        });
+        group.bench_function("unchecked_32_components", |bencher| {
+            bencher.iter(|| {
+                for entity in &entities {
+                    // SAFETY: no duplicate components are listed
+                    unsafe {
+                        assert!(query
+                            .get_mut(&mut world, *entity)
+                            .unwrap()
+                            .get_components_mut_unchecked::<RefC32>()
+                            .is_ok());
+                    }
+                }
+            });
+        });
+    }
+
+    group.finish();
+}
diff --git a/crates/bevy_ecs/src/query/access.rs b/crates/bevy_ecs/src/query/access.rs
index a36636aac43b6..50e458b9f48dc 100644
--- a/crates/bevy_ecs/src/query/access.rs
+++ b/crates/bevy_ecs/src/query/access.rs
@@ -43,7 +43,7 @@ impl<'a> Debug for FormattedBitSet<'a> {
 ///
 /// Used internally to ensure soundness during system initialization and execution.
 /// See the [`is_compatible`](Access::is_compatible) and [`get_conflicts`](Access::get_conflicts) functions.
-#[derive(Eq, PartialEq, Default)]
+#[derive(Eq, PartialEq, Default, Hash)]
 pub struct Access {
     /// All accessed components, or forbidden components if
     /// `Self::component_read_and_writes_inverted` is set.
diff --git a/crates/bevy_ecs/src/query/access_iter.rs b/crates/bevy_ecs/src/query/access_iter.rs
index 9b79b8156edef..a671651db3796 100644
--- a/crates/bevy_ecs/src/query/access_iter.rs
+++ b/crates/bevy_ecs/src/query/access_iter.rs
@@ -4,44 +4,122 @@ use crate::{
     component::{ComponentId, Components},
     query::{Access, QueryData},
 };
+use bevy_utils::BloomFilter;
+
+// found by benchmarking
+// too low, and smaller queries do unnecessary work
+// maintaining the bloom filter for a handful of checks
+// too high, and the benefit of a simpler loop
+// is outweighed by the n^2 check
+const USE_FILTER_THRESHOLD: usize = 4;
 
 /// Check if `Q` has any internal conflicts.
 #[inline(never)]
 pub fn has_conflicts<Q: QueryData>(components: &Components) -> Result<(), QueryAccessError> {
-    // increasing this too much may slow down smaller queries
-    const MAX_SIZE: usize = 16;
     let Some(state) = Q::get_state(components) else {
         return Err(QueryAccessError::ComponentNotRegistered);
     };
-    let iter = Q::iter_access(&state).enumerate();
-    let size = iter.size_hint().1.unwrap_or(MAX_SIZE);
-
-    if size > MAX_SIZE {
-        for (i, access) in iter {
-            for access_other in Q::iter_access(&state).take(i) {
-                if let Err(err) = access.is_compatible(access_other) {
-                    panic!("{}", err);
-                }
+
+    let result = if let Some(size) = Q::iter_access(&state).size_hint().1
+        && size <= USE_FILTER_THRESHOLD
+    {
+        has_conflicts_small::<Q>(&state)
+    } else {
+        has_conflicts_large::<Q>(&state)
+    };
+    if let Err(e) = result {
+        panic!("{e}");
+    }
+
+    Ok(())
+}
+
+/// Check if `Q` has any internal conflicts by checking all pairs of accesses.
+///
+/// This is intended for queries with fewer components than [`USE_FILTER_THRESHOLD`].
+/// Split from [`has_conflicts`] for easier testing.
+fn has_conflicts_small<'a, Q: QueryData>(
+    state: &'a Q::State,
+) -> Result<(), AccessConflictError<'a>> {
+    // we can optimize small sizes by caching the iteration result in an array on the stack
+    let mut inner_access = [EcsAccessType::Empty; USE_FILTER_THRESHOLD];
+    for (i, access) in Q::iter_access(state).enumerate() {
+        for access_other in inner_access.iter().take(i) {
+            if access.is_compatible(*access_other).is_err() {
+                return Err(AccessConflictError(access, *access_other));
             }
         }
-    } else {
-        // we can optimize small sizes by caching the iteration result in an array on the stack
-        let mut inner_access = [EcsAccessType::Empty; MAX_SIZE];
-        for (i, access) in iter {
-            for access_other in inner_access.iter().take(i) {
-                if let Err(err) = access.is_compatible(*access_other) {
-                    panic!("{}", err);
+        inner_access[i] = access;
+    }
+
+    Ok(())
+}
+
+/// Check if `Q` has any internal conflicts using a bloom filter for efficiency.
+///
+/// This is intended for queries with more components than [`USE_FILTER_THRESHOLD`].
+/// Split from [`has_conflicts`] for easier testing.
+fn has_conflicts_large<'a, Q: QueryData>(
+    state: &'a Q::State,
+) -> Result<(), AccessConflictError<'a>> {
+    // use a bloom filter as a linear time check if we need to run the longer, exact check
+    let mut filter = BloomFilter::<8, 2>::new();
+    for (i, access) in Q::iter_access(state).enumerate() {
+        let needs_check = match access {
+            EcsAccessType::Component(EcsAccessLevel::Read(component_id))
+            | EcsAccessType::Component(EcsAccessLevel::Write(component_id)) => {
+                filter.check_insert(&component_id.index())
+            }
+            EcsAccessType::Component(EcsAccessLevel::ReadAll)
+            | EcsAccessType::Component(EcsAccessLevel::WriteAll) => true,
+            EcsAccessType::Resource(ResourceAccessLevel::Read(resource_id))
+            | EcsAccessType::Resource(ResourceAccessLevel::Write(resource_id)) => {
+                filter.check_insert(&resource_id.index())
+            }
+            EcsAccessType::Access(access) => {
+                if access.has_read_all_resources() || access.has_write_all_resources() {
+                    true
+                } else if let Ok(component_iter) = access.try_iter_component_access() {
+                    let mut needs_check = false;
+                    for kind in component_iter {
+                        let index = match kind {
+                            crate::query::ComponentAccessKind::Shared(id)
+                            | crate::query::ComponentAccessKind::Exclusive(id)
+                            | crate::query::ComponentAccessKind::Archetypal(id) => id.index(),
+                        };
+                        if filter.check_insert(&index) {
+                            needs_check = true;
+                        }
+                    }
+                    for resource_id in access.resource_reads_and_writes() {
+                        if filter.check_insert(&resource_id.index()) {
+                            needs_check = true;
+                        }
+                    }
+                    needs_check
+                } else {
+                    true
+                }
+            }
+            EcsAccessType::Empty => continue,
+        };
+        if needs_check {
+            // we MIGHT have a conflict, fallback to slow check
+            for (j, access_other) in Q::iter_access(state).enumerate() {
+                if i == j {
+                    continue;
+                }
+                if access.is_compatible(access_other).is_err() {
+                    return Err(AccessConflictError(access, access_other));
                 }
             }
-            inner_access[i] = access;
         }
     }
-
     Ok(())
 }
 
 /// The data storage type that is being accessed.
-#[derive(Copy, Clone, Debug, PartialEq)]
+#[derive(Copy, Clone, Debug, PartialEq, Hash)]
 pub enum EcsAccessType<'a> {
     /// Accesses [`Component`](crate::prelude::Component) data
     Component(EcsAccessLevel),
@@ -152,7 +230,7 @@ impl<'a> EcsAccessType<'a> {
 
 /// The way the data will be accessed and whether we take access on all the components on
 /// an entity or just one component.
-#[derive(Clone, Copy, Debug, PartialEq)]
+#[derive(Clone, Copy, Debug, PartialEq, Hash)]
 pub enum EcsAccessLevel {
     /// Reads [`Component`](crate::prelude::Component) with [`ComponentId`]
     Read(ComponentId),
@@ -165,7 +243,7 @@ pub enum EcsAccessLevel {
 }
 
 /// Access level needed by [`QueryData`] fetch to the resource.
-#[derive(Copy, Clone, Debug, PartialEq)]
+#[derive(Copy, Clone, Debug, PartialEq, Hash)]
 pub enum ResourceAccessLevel {
     /// Reads the resource with [`ComponentId`]
     Read(ComponentId),
@@ -293,6 +371,7 @@ mod tests {
     use super::*;
     use crate::{
         prelude::Component,
+        query::WorldQuery,
         world::{EntityMut, EntityMutExcept, EntityRef, EntityRefExcept, World},
     };
 
@@ -316,27 +395,53 @@ mod tests {
         let c = world.components();
 
         // Compatible
+        let state = <&mut C1 as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<&mut C1>(&state).is_ok());
+        assert!(has_conflicts_large::<&mut C1>(&state).is_ok());
         assert!(has_conflicts::<&mut C1>(c).is_ok());
+
+        let state = <&C1 as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<&C1>(&state).is_ok());
+        assert!(has_conflicts_large::<&C1>(&state).is_ok());
         assert!(has_conflicts::<&C1>(c).is_ok());
+
+        let state = <(&C1, &C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&C1, &C1)>(&state).is_ok());
+        assert!(has_conflicts_large::<(&C1, &C1)>(&state).is_ok());
         assert!(has_conflicts::<(&C1, &C1)>(c).is_ok());
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn conflict_component_read_conflicts_write() {
-        let _ = has_conflicts::<(&C1, &mut C1)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&C1, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&C1, &mut C1)>(&state).is_err());
+        assert!(has_conflicts_large::<(&C1, &mut C1)>(&state).is_err());
+        let _ = has_conflicts::<(&C1, &mut C1)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn conflict_component_write_conflicts_read() {
-        let _ = has_conflicts::<(&mut C1, &C1)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&mut C1, &C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, &C1)>(&state).is_err());
+        assert!(has_conflicts_large::<(&mut C1, &C1)>(&state).is_err());
+        let _ = has_conflicts::<(&mut C1, &C1)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn conflict_component_write_conflicts_write() {
-        let _ = has_conflicts::<(&mut C1, &mut C1)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&mut C1, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, &mut C1)>(&state).is_err());
+        assert!(has_conflicts_large::<(&mut C1, &mut C1)>(&state).is_err());
+        let _ = has_conflicts::<(&mut C1, &mut C1)>(c);
     }
 
     #[test]
@@ -345,57 +450,108 @@ mod tests {
         let c = world.components();
 
         // Compatible
+        let state = <(EntityRef, &C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityRef, &C1)>(&state).is_ok());
+        assert!(has_conflicts_large::<(EntityRef, &C1)>(&state).is_ok());
         assert!(has_conflicts::<(EntityRef, &C1)>(c).is_ok());
+
+        let state = <(&C1, EntityRef) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&C1, EntityRef)>(&state).is_ok());
+        assert!(has_conflicts_large::<(&C1, EntityRef)>(&state).is_ok());
         assert!(has_conflicts::<(&C1, EntityRef)>(c).is_ok());
+
+        let state = <(EntityRef, EntityRef) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityRef, EntityRef)>(&state).is_ok());
+        assert!(has_conflicts_large::<(EntityRef, EntityRef)>(&state).is_ok());
         assert!(has_conflicts::<(EntityRef, EntityRef)>(c).is_ok());
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_ref_conflicts_component_write() {
-        let _ = has_conflicts::<(EntityRef, &mut C1)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityRef, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityRef, &mut C1)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityRef, &mut C1)>(&state).is_err());
+        let _ = has_conflicts::<(EntityRef, &mut C1)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn component_write_conflicts_entity_ref() {
-        let _ = has_conflicts::<(&mut C1, EntityRef)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&mut C1, EntityRef) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, EntityRef)>(&state).is_err());
+        assert!(has_conflicts_large::<(&mut C1, EntityRef)>(&state).is_err());
+        let _ = has_conflicts::<(&mut C1, EntityRef)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_mut_conflicts_component_read() {
-        let _ = has_conflicts::<(EntityMut, &C1)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityMut, &C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityMut, &C1)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityMut, &C1)>(&state).is_err());
+        let _ = has_conflicts::<(EntityMut, &C1)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn component_read_conflicts_entity_mut() {
-        let _ = has_conflicts::<(&C1, EntityMut)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&C1, EntityMut) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&C1, EntityMut)>(&state).is_err());
+        assert!(has_conflicts_large::<(&C1, EntityMut)>(&state).is_err());
+        let _ = has_conflicts::<(&C1, EntityMut)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_mut_conflicts_component_write() {
-        let _ = has_conflicts::<(EntityMut, &mut C1)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityMut, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityMut, &mut C1)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityMut, &mut C1)>(&state).is_err());
+        let _ = has_conflicts::<(EntityMut, &mut C1)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn component_write_conflicts_entity_mut() {
-        let _ = has_conflicts::<(&mut C1, EntityMut)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&mut C1, EntityMut) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, EntityMut)>(&state).is_err());
+        assert!(has_conflicts_large::<(&mut C1, EntityMut)>(&state).is_err());
+        let _ = has_conflicts::<(&mut C1, EntityMut)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_mut_conflicts_entity_ref() {
-        let _ = has_conflicts::<(EntityMut, EntityRef)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityMut, EntityRef) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityMut, EntityRef)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityMut, EntityRef)>(&state).is_err());
+        let _ = has_conflicts::<(EntityMut, EntityRef)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_ref_conflicts_entity_mut() {
-        let _ = has_conflicts::<(EntityRef, EntityMut)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityRef, EntityMut) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityRef, EntityMut)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityRef, EntityMut)>(&state).is_err());
+        let _ = has_conflicts::<(EntityRef, EntityMut)>(c);
     }
 
     #[test]
@@ -404,26 +560,82 @@ mod tests {
         let c = world.components();
 
         // Compatible
+        let state = <(EntityRefExcept<C1>, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityRefExcept<C1>, &mut C1)>(&state).is_ok());
+        assert!(has_conflicts_large::<(EntityRefExcept<C1>, &mut C1)>(&state).is_ok());
         assert!(has_conflicts::<(EntityRefExcept<C1>, &mut C1)>(c).is_ok());
+
+        let state = <(&mut C1, EntityRefExcept<C1>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, EntityRefExcept<C1>)>(&state).is_ok());
+        assert!(has_conflicts_large::<(&mut C1, EntityRefExcept<C1>)>(&state).is_ok());
         assert!(has_conflicts::<(&mut C1, EntityRefExcept<C1>)>(c).is_ok());
+
+        let state = <(&C2, EntityRefExcept<C1>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&C2, EntityRefExcept<C1>)>(&state).is_ok());
+        assert!(has_conflicts_large::<(&C2, EntityRefExcept<C1>)>(&state).is_ok());
         assert!(has_conflicts::<(&C2, EntityRefExcept<C1>)>(c).is_ok());
-        assert!(has_conflicts::<(&mut C1, EntityRefExcept<(C1, C2)>,)>(c).is_ok());
-        assert!(has_conflicts::<(EntityRefExcept<(C1, C2)>, &mut C1,)>(c).is_ok());
-        assert!(has_conflicts::<(&mut C1, &mut C2, EntityRefExcept<(C1, C2)>,)>(c).is_ok());
-        assert!(has_conflicts::<(&mut C1, EntityRefExcept<(C1, C2)>, &mut C2,)>(c).is_ok());
-        assert!(has_conflicts::<(EntityRefExcept<(C1, C2)>, &mut C1, &mut C2,)>(c).is_ok());
+
+        let state = <(&mut C1, EntityRefExcept<(C1, C2)>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, EntityRefExcept<(C1, C2)>)>(&state).is_ok());
+        assert!(has_conflicts_large::<(&mut C1, EntityRefExcept<(C1, C2)>)>(&state).is_ok());
+        assert!(has_conflicts::<(&mut C1, EntityRefExcept<(C1, C2)>)>(c).is_ok());
+
+        let state = <(EntityRefExcept<(C1, C2)>, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityRefExcept<(C1, C2)>, &mut C1)>(&state).is_ok());
+        assert!(has_conflicts_large::<(EntityRefExcept<(C1, C2)>, &mut C1)>(&state).is_ok());
+        assert!(has_conflicts::<(EntityRefExcept<(C1, C2)>, &mut C1)>(c).is_ok());
+
+        let state =
+            <(&mut C1, &mut C2, EntityRefExcept<(C1, C2)>) as WorldQuery>::get_state(c).unwrap();
+        assert!(
+            has_conflicts_small::<(&mut C1, &mut C2, EntityRefExcept<(C1, C2)>)>(&state).is_ok()
+        );
+        assert!(
+            has_conflicts_large::<(&mut C1, &mut C2, EntityRefExcept<(C1, C2)>)>(&state).is_ok()
+        );
+        assert!(has_conflicts::<(&mut C1, &mut C2, EntityRefExcept<(C1, C2)>)>(c).is_ok());
+
+        let state =
+            <(&mut C1, EntityRefExcept<(C1, C2)>, &mut C2) as WorldQuery>::get_state(c).unwrap();
+        assert!(
+            has_conflicts_small::<(&mut C1, EntityRefExcept<(C1, C2)>, &mut C2)>(&state).is_ok()
+        );
+        assert!(
+            has_conflicts_large::<(&mut C1, EntityRefExcept<(C1, C2)>, &mut C2)>(&state).is_ok()
+        );
+        assert!(has_conflicts::<(&mut C1, EntityRefExcept<(C1, C2)>, &mut C2)>(c).is_ok());
+
+        let state =
+            <(EntityRefExcept<(C1, C2)>, &mut C1, &mut C2) as WorldQuery>::get_state(c).unwrap();
+        assert!(
+            has_conflicts_small::<(EntityRefExcept<(C1, C2)>, &mut C1, &mut C2)>(&state).is_ok()
+        );
+        assert!(
+            has_conflicts_large::<(EntityRefExcept<(C1, C2)>, &mut C1, &mut C2)>(&state).is_ok()
+        );
+        assert!(has_conflicts::<(EntityRefExcept<(C1, C2)>, &mut C1, &mut C2)>(c).is_ok());
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_ref_except_conflicts_component_write() {
-        let _ = has_conflicts::<(EntityRefExcept<C1>, &mut C2)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityRefExcept<C1>, &mut C2) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityRefExcept<C1>, &mut C2)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityRefExcept<C1>, &mut C2)>(&state).is_err());
+        let _ = has_conflicts::<(EntityRefExcept<C1>, &mut C2)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn component_write_conflicts_entity_ref_except() {
-        let _ = has_conflicts::<(&mut C2, EntityRefExcept<C1>)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&mut C2, EntityRefExcept<C1>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C2, EntityRefExcept<C1>)>(&state).is_err());
+        assert!(has_conflicts_large::<(&mut C2, EntityRefExcept<C1>)>(&state).is_err());
+        let _ = has_conflicts::<(&mut C2, EntityRefExcept<C1>)>(c);
     }
 
     #[test]
@@ -432,36 +644,98 @@ mod tests {
         let c = world.components();
 
         // Compatible
+        let state = <(EntityMutExcept<C1>, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityMutExcept<C1>, &mut C1)>(&state).is_ok());
+        assert!(has_conflicts_large::<(EntityMutExcept<C1>, &mut C1)>(&state).is_ok());
         assert!(has_conflicts::<(EntityMutExcept<C1>, &mut C1)>(c).is_ok());
+
+        let state = <(&mut C1, EntityMutExcept<C1>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, EntityMutExcept<C1>)>(&state).is_ok());
+        assert!(has_conflicts_large::<(&mut C1, EntityMutExcept<C1>)>(&state).is_ok());
         assert!(has_conflicts::<(&mut C1, EntityMutExcept<C1>)>(c).is_ok());
-        assert!(has_conflicts::<(&mut C1, EntityMutExcept<(C1, C2)>,)>(c).is_ok());
-        assert!(has_conflicts::<(EntityMutExcept<(C1, C2)>, &mut C1,)>(c).is_ok());
-        assert!(has_conflicts::<(&mut C1, &mut C2, EntityMutExcept<(C1, C2)>,)>(c).is_ok());
-        assert!(has_conflicts::<(&mut C1, EntityMutExcept<(C1, C2)>, &mut C2,)>(c).is_ok());
-        assert!(has_conflicts::<(EntityMutExcept<(C1, C2)>, &mut C1, &mut C2,)>(c).is_ok());
+
+        let state = <(&mut C1, EntityMutExcept<(C1, C2)>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C1, EntityMutExcept<(C1, C2)>)>(&state).is_ok());
+        assert!(has_conflicts_large::<(&mut C1, EntityMutExcept<(C1, C2)>)>(&state).is_ok());
+        assert!(has_conflicts::<(&mut C1, EntityMutExcept<(C1, C2)>)>(c).is_ok());
+
+        let state = <(EntityMutExcept<(C1, C2)>, &mut C1) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityMutExcept<(C1, C2)>, &mut C1)>(&state).is_ok());
+        assert!(has_conflicts_large::<(EntityMutExcept<(C1, C2)>, &mut C1)>(&state).is_ok());
+        assert!(has_conflicts::<(EntityMutExcept<(C1, C2)>, &mut C1)>(c).is_ok());
+
+        let state =
+            <(&mut C1, &mut C2, EntityMutExcept<(C1, C2)>) as WorldQuery>::get_state(c).unwrap();
+        assert!(
+            has_conflicts_small::<(&mut C1, &mut C2, EntityMutExcept<(C1, C2)>)>(&state).is_ok()
+        );
+        assert!(
+            has_conflicts_large::<(&mut C1, &mut C2, EntityMutExcept<(C1, C2)>)>(&state).is_ok()
+        );
+        assert!(has_conflicts::<(&mut C1, &mut C2, EntityMutExcept<(C1, C2)>)>(c).is_ok());
+
+        let state =
+            <(&mut C1, EntityMutExcept<(C1, C2)>, &mut C2) as WorldQuery>::get_state(c).unwrap();
+        assert!(
+            has_conflicts_small::<(&mut C1, EntityMutExcept<(C1, C2)>, &mut C2)>(&state).is_ok()
+        );
+        assert!(
+            has_conflicts_large::<(&mut C1, EntityMutExcept<(C1, C2)>, &mut C2)>(&state).is_ok()
+        );
+        assert!(has_conflicts::<(&mut C1, EntityMutExcept<(C1, C2)>, &mut C2)>(c).is_ok());
+
+        let state =
+            <(EntityMutExcept<(C1, C2)>, &mut C1, &mut C2) as WorldQuery>::get_state(c).unwrap();
+        assert!(
+            has_conflicts_small::<(EntityMutExcept<(C1, C2)>, &mut C1, &mut C2)>(&state).is_ok()
+        );
+        assert!(
+            has_conflicts_large::<(EntityMutExcept<(C1, C2)>, &mut C1, &mut C2)>(&state).is_ok()
+        );
+        assert!(has_conflicts::<(EntityMutExcept<(C1, C2)>, &mut C1, &mut C2)>(c).is_ok());
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_mut_except_conflicts_component_read() {
-        let _ = has_conflicts::<(EntityMutExcept<C1>, &C2)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityMutExcept<C1>, &C2) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityMutExcept<C1>, &C2)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityMutExcept<C1>, &C2)>(&state).is_err());
+        let _ = has_conflicts::<(EntityMutExcept<C1>, &C2)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn component_read_conflicts_entity_mut_except() {
-        let _ = has_conflicts::<(&C2, EntityMutExcept<C1>)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&C2, EntityMutExcept<C1>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&C2, EntityMutExcept<C1>)>(&state).is_err());
+        assert!(has_conflicts_large::<(&C2, EntityMutExcept<C1>)>(&state).is_err());
+        let _ = has_conflicts::<(&C2, EntityMutExcept<C1>)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn entity_mut_except_conflicts_component_write() {
-        let _ = has_conflicts::<(EntityMutExcept<C1>, &mut C2)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(EntityMutExcept<C1>, &mut C2) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(EntityMutExcept<C1>, &mut C2)>(&state).is_err());
+        assert!(has_conflicts_large::<(EntityMutExcept<C1>, &mut C2)>(&state).is_err());
+        let _ = has_conflicts::<(EntityMutExcept<C1>, &mut C2)>(c);
     }
 
     #[test]
     #[should_panic(expected = "conflicts")]
     fn component_write_conflicts_entity_mut_except() {
-        let _ = has_conflicts::<(&mut C2, EntityMutExcept<C1>)>(setup_world().components());
+        let world = setup_world();
+        let c = world.components();
+        let state = <(&mut C2, EntityMutExcept<C1>) as WorldQuery>::get_state(c).unwrap();
+        assert!(has_conflicts_small::<(&mut C2, EntityMutExcept<C1>)>(&state).is_err());
+        assert!(has_conflicts_large::<(&mut C2, EntityMutExcept<C1>)>(&state).is_err());
+        let _ = has_conflicts::<(&mut C2, EntityMutExcept<C1>)>(c);
     }
 }
diff --git a/crates/bevy_utils/src/bloom_filter.rs b/crates/bevy_utils/src/bloom_filter.rs
new file mode 100644
index 0000000000000..83b9e3cfca0c1
--- /dev/null
+++ b/crates/bevy_utils/src/bloom_filter.rs
@@ -0,0 +1,80 @@
+use bevy_platform::hash::FixedHasher;
+use core::hash::{BuildHasher, Hash};
+
+/// A Bloom filter, parameterized by number of u64 segments `N` and number of hash functions `K`.
+///
+/// `N` should be based on how much you plan to insert into the filter.
+/// `N * 64` should be at least the number of items you plan to insert.
+///
+/// `K` if how little you can tolerate false positives.
+/// 2, the default, should work for most uses. Increase `K` to reduce false positives,
+/// at a pretty large compute cost.
+///
+/// # Examples
+///
+/// ```
+/// use bevy_utils::BloomFilter;
+///
+/// let mut filter = BloomFilter::<1>::new();
+/// filter.insert(&"hello");
+/// assert!(filter.contains(&"hello"));
+/// assert!(!filter.contains(&"world"));
+/// ```
+#[derive(Clone, Copy, Debug)]
+pub struct BloomFilter<const N: usize, const K: usize = 2> {
+    bits: [u64; N],
+}
+
+impl<const N: usize, const K: usize> Default for BloomFilter<N, K> {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+impl<const N: usize, const K: usize> BloomFilter<N, K> {
+    /// Creates a new, empty filter.
+    pub const fn new() -> Self {
+        assert!(N > 0, "size must be at least 1");
+        Self { bits: [0; N] }
+    }
+
+    /// Inserts a value into the filter.
+    pub fn insert(&mut self, item: &impl Hash) {
+        let (h1, h2) = self.hash(item);
+        let m = (N * 64) as u64;
+        for i in 0..K {
+            let idx = (h1.wrapping_add((i as u64).wrapping_mul(h2))) % m;
+            self.bits[idx as usize / 64] |= 1 << (idx % 64);
+        }
+    }
+
+    /// Checks if the filter might contain the value.
+    pub fn contains(&self, item: &impl Hash) -> bool {
+        let (h1, h2) = self.hash(item);
+        let m = (N * 64) as u64;
+        for i in 0..K {
+            let idx = (h1.wrapping_add((i as u64).wrapping_mul(h2))) % m;
+            if self.bits[idx as usize / 64] & (1 << (idx % 64)) == 0 {
+                return false;
+            }
+        }
+        true
+    }
+
+    /// Combined [`Self::contains`] and [`Self::insert`].
+    ///
+    /// Returns `true` if the value was already in the filter.
+    /// Adds the value to the filter if it was not already present.
+    pub fn check_insert(&mut self, item: &impl Hash) -> bool {
+        let res = self.contains(item);
+        if !res {
+            self.insert(item);
+        }
+        res
+    }
+
+    fn hash(&self, item: &impl Hash) -> (u64, u64) {
+        let hash = FixedHasher.hash_one(item);
+        (hash as u32 as u64, hash >> 32)
+    }
+}
diff --git a/crates/bevy_utils/src/lib.rs b/crates/bevy_utils/src/lib.rs
index 9055b825f1f31..286793bd76839 100644
--- a/crates/bevy_utils/src/lib.rs
+++ b/crates/bevy_utils/src/lib.rs
@@ -49,6 +49,8 @@ pub mod prelude {
 }
 
 mod atomic_id;
+mod bloom_filter;
+pub use bloom_filter::*;
 mod debug_info;
 mod default;
 mod once;
