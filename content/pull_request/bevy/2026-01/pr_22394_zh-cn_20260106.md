+++
title = "#22394 Text pipeline update buffer spans refactor"
date = "2026-01-06T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22394-en-20260106" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22394-zh-cn-20260106" }}
+++

# 标题

## 基本信息
- **标题**: Text pipeline update buffer spans refactor
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22394
- **作者**: ickshonpe
- **状态**: 已合并
- **标签**: C-代码质量, S-准备最终审查, A-文本, D-直接
- **创建时间**: 2026-01-05T20:17:36Z
- **合并时间**: 2026-01-06T20:14:00Z
- **合并者**: alice-i-cecile

## 描述翻译

**目标**

`TextPipeline::update_buffer` 使用了一种技巧来缓存 spans 缓冲区的容量。然而，它的实现方式很别扭，缓冲区恢复代码重复了两次。

**解决方案**

重新设计该函数，删除 spans 缓冲区恢复代码的重复部分。

## 本 Pull Request 的故事

这个 PR 的核心是一个代码重构，目标是消除 `TextPipeline::update_buffer` 函数中存在的重复代码模式。这个函数负责更新文本渲染缓冲区，在处理文本跨度的过程中，有一块用于恢复 spans 缓冲区状态的代码在函数的两个不同位置重复出现。

原始代码的结构存在一个明显的问题：当遇到字体未加载的情况时，函数需要提前返回错误，但同时需要确保 spans 缓冲区被正确恢复。这导致了相同的缓冲区清理和重建逻辑在两个地方重复：

1. 在字体未加载的提前返回路径中
2. 在函数正常执行结束的位置

原始实现的思路是使用一个技巧来缓存缓冲区的容量，但实现方式让代码变得难以维护。每次看到相同的代码出现在两个地方，对于开发者来说都是一个需要清理的代码异味(code smell)。

为了解决这个问题，开发者采用了经典的"提取代码块"重构技术。他们没有简单地复制粘贴清理逻辑，而是重新组织了函数的控制流。关键的变化是将主处理逻辑包装在一个代码块中，然后将这个代码块的执行结果存储在一个变量中。

让我用一个简化的伪代码来说明重构前后的对比：

**重构前**：
```rust
fn update_buffer() -> Result<(), Error> {
    // 处理文本跨度...
    for span in text_spans {
        if font_not_loaded() {
            // 清理缓冲区
            spans.clear();
            self.spans_buffer = spans.into_iter().map(...).collect();
            return Err(Error::NoSuchFont);
        }
        // 正常处理
    }
    
    // 更多处理逻辑...
    
    // 再次清理缓冲区（重复代码）
    spans.clear();
    self.spans_buffer = spans.into_iter().map(...).collect();
    Ok(())
}
```

**重构后**：
```rust
fn update_buffer() -> Result<(), Error> {
    let result = {
        // 所有处理逻辑在这里
        for span in text_spans {
            if font_not_loaded() {
                return Err(Error::NoSuchFont); // 直接返回错误
            }
            // 正常处理
        }
        // 更多处理逻辑...
        Ok(())
    };
    
    // 统一的缓冲区清理（只出现一次）
    spans.clear();
    self.spans_buffer = spans.into_iter().map(...).collect();
    
    result
}
```

这种重构的关键技术点是利用了 Rust 的块表达式(block expression)。代码块可以产生一个值，在这里我们使用它来封装整个处理逻辑并捕获其返回结果。这样，无论处理逻辑是成功完成还是提前返回错误，控制流都会跳出代码块，然后执行统一的缓冲区清理代码。

从实现细节来看，有几个值得注意的技术点：

1. **错误处理简化**：在字体处理部分，原本的 `if let Some(font) = fonts.get(handle.id())` 被替换为更简洁的 `let font = fonts.get(handle.id()).ok_or(TextError::NoSuchFont)?`。这种变化不仅更符合 Rust 的错误处理习惯，也使得代码流程更清晰。

2. **容量保持**：清理代码中的 `spans.into_iter().map(...).collect()` 看起来有点奇怪，但实际上是在利用 Rust 的迭代器转换来保持 `spans` 向量的容量。这是原始实现中的"技巧"部分，重构后保留了这一优化。

3. **副作用管理**：代码块的使用确保了即使提前返回错误，外部的缓冲区清理代码仍然会执行。这是一种清晰管理副作用的方式。

这种重构的主要影响是提高了代码的可维护性：
- 消除了重复代码，遵循了 DRY（Don't Repeat Yourself）原则
- 使错误处理路径更加清晰
- 减少了未来修改时可能引入不一致性的风险
- 保持了原有的性能特性（缓冲区容量缓存）

虽然这个 PR 看起来只是简单的代码清理，但它展示了良好的代码重构实践。对于像 Bevy 这样的大型游戏引擎项目，保持代码库的整洁和可维护性至关重要。这种类型的重构可能不会直接影响最终用户，但对于长期的项目健康和维护者体验有积极影响。

## 可视化表示

```mermaid
graph TD
    A[TextPipeline::update_buffer] --> B[主处理代码块]
    B --> C{执行结果}
    C -->|成功| D[Ok(())]
    C -->|失败| E[Err(TextError)]
    B --> F[统一的缓冲区清理]
    F --> G[返回结果]
    
    style B fill:#e1f5e1
    style F fill:#fff3e0
```

## 关键文件变更

**文件**: `crates/bevy_text/src/pipeline.rs` (+80/-93)

这个文件包含了 `TextPipeline` 结构的实现，特别是 `update_buffer` 方法的重大重构。

### 主要变更：

1. **控制流重构**：将原来的线性控制流改为使用代码块封装主逻辑
2. **错误处理简化**：使用 `ok_or` 和 `?` 操作符简化字体加载错误处理
3. **重复代码消除**：统一的缓冲区清理逻辑

### 代码对比示例：

**重构前的主要结构**：
```rust
for (span_index, (entity, depth, span, text_font, color, line_height)) in
    text_spans.enumerate()
{
    // ... 处理每个跨度
    
    let family_name: SmolStr = match &text_font.font {
        FontSource::Handle(handle) => {
            if let Some(font) = fonts.get(handle.id()) {
                // ... 正常处理字体
            } else {
                // 提前返回错误并清理缓冲区（重复代码位置1）
                spans.clear();
                self.spans_buffer = spans.into_iter().map(...).collect();
                return Err(TextError::NoSuchFont);
            }
        }
        // ... 其他情况
    };
    // ... 更多处理
}

// ... 缓冲区设置逻辑

// 正常结束时的缓冲区清理（重复代码位置2）
spans.clear();
self.spans_buffer = spans.into_iter().map(...).collect();
Ok(())
```

**重构后的主要结构**：
```rust
let result = {
    for (span_index, (entity, depth, span, text_font, color, line_height)) in
        text_spans.enumerate()
    {
        // ... 处理每个跨度
        
        let family_name: SmolStr = match &text_font.font {
            FontSource::Handle(handle) => {
                // 使用更简洁的错误处理
                let font = fonts.get(handle.id()).ok_or(TextError::NoSuchFont)?;
                // ... 正常处理字体
            }
            // ... 其他情况
        };
        // ... 更多处理
    }
    
    // ... 缓冲区设置逻辑
    Ok(())
};

// 统一的缓冲区清理（只出现一次）
spans.clear();
self.spans_buffer = spans
    .into_iter()
    .map(
        |_| -> (
            usize,
            &'static str,
            &'static TextFont,
            FontFaceInfo,
            LineHeight,
        ) { unreachable!() },
    )
    .collect();

result
```

## 进一步阅读

对于想要了解更多相关概念的读者，建议参考以下资源：

1. **Rust 错误处理最佳实践**：了解 `Result` 类型、`?` 操作符和 `ok_or` 方法的使用
2. **代码重构技术**：特别是"提取方法"和"消除重复代码"等重构模式
3. **Rust 块表达式**：理解如何使用代码块来组织复杂逻辑和控制流
4. **Bevy 文本渲染系统**：了解 Bevy 引擎中文本渲染的整体架构和工作原理

# 完整代码差异

```diff
diff --git a/crates/bevy_text/src/pipeline.rs b/crates/bevy_text/src/pipeline.rs
index 1f448f43ec931..dce105f4a79da 100644
--- a/crates/bevy_text/src/pipeline.rs
+++ b/crates/bevy_text/src/pipeline.rs
@@ -112,19 +112,21 @@ impl TextPipeline {
 
         computed.entities.clear();
 
-        for (span_index, (entity, depth, span, text_font, color, line_height)) in
-            text_spans.enumerate()
-        {
-            // Save this span entity in the computed text block.
-            computed.entities.push(TextEntity { entity, depth });
-
-            if span.is_empty() {
-                continue;
-            }
+        let result = {
+            for (span_index, (entity, depth, span, text_font, color, line_height)) in
+                text_spans.enumerate()
+            {
+                // Save this span entity in the computed text block.
+                computed.entities.push(TextEntity { entity, depth });
+
+                if span.is_empty() {
+                    continue;
+                }
 
-            let family_name: SmolStr = match &text_font.font {
-                FontSource::Handle(handle) => {
-                    if let Some(font) = fonts.get(handle.id()) {
+                let family_name: SmolStr = match &text_font.font {
+                    FontSource::Handle(handle) => {
+                        // Return early if a font is not loaded yet.
+                        let font = fonts.get(handle.id()).ok_or(TextError::NoSuchFont)?;
                         let data = Arc::clone(&font.data);
                         let ids = font_system
                             .db_mut()
@@ -139,92 +141,77 @@ impl TextPipeline {
                             .0
                             .as_str()
                             .into()
-                    } else {
-                        // Return early if a font is not loaded yet.
-                        spans.clear();
-                        self.spans_buffer = spans
-                            .into_iter()
-                            .map(
-                                |_| -> (
-                                    usize,
-                                    &'static str,
-                                    &'static TextFont,
-                                    FontFaceInfo,
-                                    LineHeight,
-                                ) { unreachable!() },
-                            )
-                            .collect();
-                        return Err(TextError::NoSuchFont);
                     }
-                }
-                FontSource::Family(family) => family.clone(),
-            };
+                    FontSource::Family(family) => family.clone(),
+                };
 
-            let face_info = FontFaceInfo { family_name };
+                let face_info = FontFaceInfo { family_name };
 
-            // Save spans that aren't zero-sized.
-            if scale_factor <= 0.0 || text_font.font_size <= 0.0 {
-                once!(warn!(
-                    "Text span {entity} has a font size <= 0.0. Nothing will be displayed.",
-                ));
+                // Save spans that aren't zero-sized.
+                if scale_factor <= 0.0 || text_font.font_size <= 0.0 {
+                    once!(warn!(
+                        "Text span {entity} has a font size <= 0.0. Nothing will be displayed.",
+                    ));
 
-                continue;
+                    continue;
+                }
+                spans.push((span_index, span, text_font, face_info, color, line_height));
             }
-            spans.push((span_index, span, text_font, face_info, color, line_height));
-        }
-
-        // Map text sections to cosmic-text spans, and ignore sections with negative or zero fontsizes,
-        // since they cannot be rendered by cosmic-text.
-        //
-        // The section index is stored in the metadata of the spans, and could be used
-        // to look up the section the span came from and is not used internally
-        // in cosmic-text.
-        let spans_iter = spans.iter().map(
-            |(span_index, span, text_font, font_info, color, line_height)| {
-                (
-                    *span,
-                    get_attrs(
-                        *span_index,
-                        text_font,
-                        *line_height,
-                        *color,
-                        font_info,
-                        scale_factor,
-                    ),
-                )
-            },
-        );
-
-        // Update the buffer.
-        let buffer = &mut computed.buffer;
-
-        // Set the metrics hinting strategy
-        buffer.set_hinting(font_system, hinting.into());
 
-        buffer.set_wrap(
-            font_system,
-            match linebreak {
-                LineBreak::WordBoundary => Wrap::Word,
-                LineBreak::AnyCharacter => Wrap::Glyph,
-                LineBreak::WordOrCharacter => Wrap::WordOrGlyph,
-                LineBreak::NoWrap => Wrap::None,
-            },
-        );
+            // Map text sections to cosmic-text spans, and ignore sections with negative or zero fontsizes,
+            // since they cannot be rendered by cosmic-text.
+            //
+            // The section index is stored in the metadata of the spans, and could be used
+            // to look up the section the span came from and is not used internally
+            // in cosmic-text.
+            let spans_iter = spans.iter().map(
+                |(span_index, span, text_font, font_info, color, line_height)| {
+                    (
+                        *span,
+                        get_attrs(
+                            *span_index,
+                            text_font,
+                            *line_height,
+                            *color,
+                            font_info,
+                            scale_factor,
+                        ),
+                    )
+                },
+            );
 
-        buffer.set_rich_text(
-            font_system,
-            spans_iter,
-            &Attrs::new(),
-            Shaping::Advanced,
-            Some(justify.into()),
-        );
+            // Update the buffer.
+            let buffer = &mut computed.buffer;
 
-        // Workaround for alignment not working for unbounded text.
-        // See https://github.com/pop-os/cosmic-text/issues/343
-        let width = (bounds.width.is_none() && justify != Justify::Left)
-            .then(|| buffer_dimensions(buffer).x)
-            .or(bounds.width);
-        buffer.set_size(font_system, width, bounds.height);
+            // Set the metrics hinting strategy
+            buffer.set_hinting(font_system, hinting.into());
+
+            buffer.set_wrap(
+                font_system,
+                match linebreak {
+                    LineBreak::WordBoundary => Wrap::Word,
+                    LineBreak::AnyCharacter => Wrap::Glyph,
+                    LineBreak::WordOrCharacter => Wrap::WordOrGlyph,
+                    LineBreak::NoWrap => Wrap::None,
+                },
+            );
+
+            buffer.set_rich_text(
+                font_system,
+                spans_iter,
+                &Attrs::new(),
+                Shaping::Advanced,
+                Some(justify.into()),
+            );
+
+            // Workaround for alignment not working for unbounded text.
+            // See https://github.com/pop-os/cosmic-text/issues/343
+            let width = (bounds.width.is_none() && justify != Justify::Left)
+                .then(|| buffer_dimensions(buffer).x)
+                .or(bounds.width);
+            buffer.set_size(font_system, width, bounds.height);
+            Ok(())
+        };
 
         // Recover the spans buffer.
         spans.clear();
@@ -241,7 +228,7 @@ impl TextPipeline {
             )
             .collect();
 
-        Ok(())
+        result
     }
 
     /// Queues text for measurement
```