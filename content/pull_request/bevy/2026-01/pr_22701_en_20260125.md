+++
title = "#22701 Update some UI examples"
date = "2026-01-25T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22701-en-20260125" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22701-zh-cn-20260125" }}
labels = ["D-Trivial", "C-Examples", "A-UI", "C-Code-Quality"]
+++

# Title
Update some UI examples

## Basic Information
- **Title**: Update some UI examples
- **PR Link**: https://github.com/bevyengine/bevy/pull/22701
- **Author**: ickshonpe
- **Status**: MERGED
- **Labels**: D-Trivial, C-Examples, A-UI, C-Code-Quality, S-Ready-For-Final-Review
- **Created**: 2026-01-25T21:29:39Z
- **Merged**: 2026-01-25T22:26:05Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

Some UI examples use the Val and UiRect constructor methods inconsistantly or not at all.

## Solution

Update some UI examples to use the val and uirect helper functions.

## Testing

The output of the examples should be unchanged

## The Story of This Pull Request

This PR addresses a straightforward code consistency issue in Bevy's UI examples. The problem was that different examples were using different patterns to construct `Val` and `UiRect` values. Some examples directly used constructors like `Val::Percent(100.0)`, while others used helper functions like `percent(100)`. This inconsistency made the codebase harder to read and maintain, as developers had to remember multiple ways to achieve the same result.

The solution was systematic and targeted: update all affected examples to use the helper functions consistently. This approach provides several benefits. First, it makes the code more readable by using shorter, more expressive syntax. Second, it establishes a clear standard for future contributions. Third, it leverages Rust's type system effectively by using these helper functions that return the appropriate types.

Looking at the implementation, we can see two main types of changes. The first type converts direct constructor calls to helper function calls. For example, `Val::Percent(100.0)` becomes `percent(100)` and `Val::Px(4.)` becomes `px(4.)`. The second type converts `UiRect` constructor calls to method calls on `Val` values. For instance, `UiRect::all(px(6))` becomes `px(6).all()` and `UiRect::right(MARGIN)` becomes `MARGIN.right()`.

One interesting technical detail appears in the `image_node_resizing.rs` file. The PR not only updates constructor usage but also improves the code for updating percentage values. Before the change, the code used pattern matching to extract the inner value, performed calculations, and then created a new `Val::Percent`. After the change, the code uses mutable references to directly update the inner value. This change is more efficient because it avoids creating a new `Val` instance and instead modifies the existing one in place.

Here's a comparison of the old and new approach in `image_node_resizing.rs`:

```rust
// Before:
if let Val::Percent(val) = node.height {
    let new_val = (val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
    node.height = Val::Percent(new_val);
}

// After:
if let Val::Percent(val) = &mut node.height {
    *val = (*val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
}
```

The new approach is cleaner and more idiomatic. It uses a mutable reference to the `Val` enum variant's payload, allowing direct modification without reconstructing the enum. This pattern is more efficient and clearer about the intent to modify the existing value.

The impact of these changes is primarily on code quality and developer experience. While the visual output of the examples remains unchanged, the code itself becomes more consistent and easier to understand. This is particularly important for examples, which serve as educational resources for developers learning the Bevy UI system. Consistent patterns in examples help developers learn the recommended way to write Bevy UI code.

From an architectural perspective, this PR reinforces the value of helper functions in public APIs. The `percent()` and `px()` functions provide a more fluent interface than direct enum constructors, and the methods on `Val` like `.all()` and `.right()` create a more intuitive way to build `UiRect` values. This approach aligns with Rust's convention of providing convenient constructor functions for commonly used types.

## Visual Representation

```mermaid
graph TD
    A[UI Examples] --> B[Val Construction]
    A --> C[UiRect Construction]
    
    B --> D[Direct: Val::Percent(100.0)]
    B --> E[Helper: percent(100)]
    
    C --> F[Direct: UiRect::all(px(6))]
    C --> G[Method: px(6).all()]
    
    E -.-> H[Consistent Pattern]
    G -.-> H
```

## Key Files Changed

### `examples/ui/image_node_resizing.rs` (+16/-20)
This file had the most significant changes, including both constructor updates and logic improvements for percentage value updates.

**Before:**
```rust
padding: UiRect::all(px(6)),
width: Val::Percent(IMAGE_GROUP_BOX_INIT_WIDTH),
if let Val::Percent(val) = node.height {
    let new_val = (val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
    node.height = Val::Percent(new_val);
}
```

**After:**
```rust
padding: px(6).all(),
width: percent(IMAGE_GROUP_BOX_INIT_WIDTH),
if let Val::Percent(val) = &mut node.height {
    *val = (*val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
}
```

### `examples/ui/flex_layout.rs` (+3/-9)
Updated `UiRect` constructor usage to method calls.

**Before:**
```rust
padding: UiRect::all(MARGIN),
UiRect::right(MARGIN),
UiRect::top(px(top_margin)),
```

**After:**
```rust
padding: MARGIN.all(),
MARGIN.right(),
px(top_margin).top(),
```

### `examples/ui/ui_drag_and_drop.rs` (+4/-4)
Converted `Val::Px` and `UiRect::all` to helper function patterns.

**Before:**
```rust
width: Val::Px(TILE_SIZE),
border: UiRect::all(Val::Px(4.)),
width: Val::Px(2.),
```

**After:**
```rust
width: px(TILE_SIZE),
border: px(4.).all(),
width: px(2.),
```

### `examples/picking/dragdrop_picking.rs` (+2/-2)
Simple conversion from `Val::Percent` to `percent()` helper.

### `examples/ui/strikethrough_and_underline.rs` (+2/-2)
Simple conversion from `Val::Percent` to `percent()` helper.

## Further Reading

1. Bevy UI Documentation: https://bevyengine.org/learn/quick-start/ui/
2. Rust Enum Patterns: Understanding how to work with enum variants, especially with pattern matching and mutable references
3. Builder Pattern: The helper function approach follows the builder pattern, which is common in Rust for creating complex objects
4. Code Consistency: The importance of consistent patterns in example code for developer onboarding and maintenance