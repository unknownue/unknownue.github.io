+++
title = "#22642 Emit a `warn_once` if a font size is larger than 1000"
date = "2026-01-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22642-en-20260124" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22642-zh-cn-20260124" }}
labels = ["C-Usability", "A-Text", "D-Straightforward"]
+++

# Title
## Basic Information
- **Title**: Emit a `warn_once` if a font size is larger than 1000
- **PR Link**: https://github.com/bevyengine/bevy/pull/22642
- **Author**: WaterWhisperer
- **Status**: MERGED
- **Labels**: C-Usability, S-Ready-For-Final-Review, A-Text, X-Uncontroversial, D-Straightforward
- **Created**: 2026-01-22T05:46:58Z
- **Merged**: 2026-01-24T19:38:56Z
- **Merged By**: alice-i-cecile

## Description Translation
**Objective**
- Fixes #22625

**Solution**
- Add a WARN_FONT_SIZE const and emit a `warn_once` when font size larger than it
- Change some `once!(warn!())` to `warn_once!()`

**Testing**
- Did you test these changes? If so, how?
`cargo check`

## The Story of This Pull Request

This PR addresses a usability issue in Bevy's text rendering system where developers could accidentally set font sizes that cause performance problems without any warning. The issue (#22625) was that extremely large font sizes would lead to excessive memory usage and slow font atlas generation, but the system provided no feedback to developers about this potentially problematic configuration.

The core problem was straightforward: when developers set font sizes that are too large (especially when combined with scale factors), the text rendering pipeline would generate massive font atlases, consuming significant memory and CPU resources during atlas generation. This could happen unintentionally when developers are experimenting with text scaling or when they misinterpret units.

The solution implemented takes a pragmatic approach. Rather than preventing large font sizes (which might be intentionally needed in some cases), the PR adds a warning system that alerts developers when they've configured a font size that exceeds a reasonable threshold. The threshold is set at 1000 points (after applying scale factor), which is large enough that legitimate use cases are unlikely to hit it, but small enough to catch most accidental misconfigurations.

The implementation leverages Bevy's existing `warn_once!` macro, which ensures that the warning message is only logged once per unique condition during the application's lifetime. This prevents log spam while still providing the necessary feedback. The PR also includes some minor cleanup by converting existing `once!(warn!(...))` patterns to use the more concise `warn_once!` macro, which serves the same purpose but with cleaner syntax.

Looking at the code changes, the implementation adds a `WARN_FONT_SIZE` constant (1000.0) and checks whether the scaled font size exceeds this value. The warning message clearly explains the consequences: "Extremely large font sizes will cause performance issues with font atlas generation and high memory usage." This gives developers immediate feedback about why their configuration might be problematic.

The choice to use a constant rather than a magic number inline follows good engineering practices, making the threshold easily discoverable and modifiable if needed. The warning only triggers when the scaled font size (original size multiplied by scale factor) exceeds the threshold, which correctly accounts for the actual size that will be rendered.

This change fits well into the existing text pipeline architecture. The check occurs in the `queue_text` method of `TextPipeline`, which is responsible for processing text components and preparing them for rendering. This is the appropriate place for such validation because it has access to both the font size and the scale factor, and it runs whenever text needs to be re-rendered.

The PR doesn't attempt to solve the performance issues themselves - that would require more complex changes to the font atlas generation system. Instead, it provides a practical, low-cost solution that helps developers avoid the problem in the first place. This is a good example of defensive programming and improving developer experience through better feedback mechanisms.

From an engineering perspective, this change has minimal performance impact. The additional check is a simple floating-point comparison that happens once per text span when the text needs rerendering. The memory overhead is negligible since it only adds a single constant to the binary.

One interesting aspect is the use of `warn_once!` versus `once!(warn!(...))`. The PR standardizes on the former, which is a newer, more ergonomic macro that achieves the same goal. This is a minor cleanup but contributes to code consistency across the codebase.

## Visual Representation

```mermaid
graph TD
    A[Text Component Created/Modified] --> B[TextPipeline.queue_text]
    B --> C{Check font size > 0}
    C -->|No| D[warn_once: "font size <= 0"]
    C -->|Yes| E{Check scaled font size > 1000}
    E -->|Yes| F[warn_once: "excessively large font size"]
    E -->|No| G[Proceed with text rendering]
    D --> H[Skip this text span]
    F --> G
```

## Key Files Changed

**File: `crates/bevy_text/src/pipeline.rs` (+15/-6)**

This is the only file modified in the PR. It contains the text rendering pipeline logic that processes text components and prepares them for rendering.

**Key changes:**

1. **Import statement update:**
```rust
// Before:
use bevy_log::{once, warn};

// After:
use bevy_log::warn_once;
```

2. **Replacement of `once!(warn!(...))` patterns with `warn_once!(...)`:**
```rust
// Before (line ~169):
once!(warn!(
    "Text scale factor is <= 0.0. No text will be displayed.",
));

// After (line ~169):
warn_once!("Text scale factor is <= 0.0. No text will be displayed.",);
```

```rust
// Before (line ~213):
once!(warn!(
    "Text span {entity} has a font size <= 0.0. Nothing will be displayed.",
));

// After (line ~213):
warn_once!(
    "Text span {entity} has a font size <= 0.0. Nothing will be displayed.",
);
```

3. **Addition of font size warning check:**
```rust
// Added after the check for font size <= 0.0 (lines 220-229):
const WARN_FONT_SIZE: f32 = 1000.0;
if text_font.font_size * scale_factor as f32 > WARN_FONT_SIZE {
    warn_once!(
        "Text span {entity} has an excessively large font size ({} with scale factor {}). \
        Extremely large font sizes will cause performance issues with font atlas \
        generation and high memory usage.",
        text_font.font_size,
        scale_factor,
    );
}
```

The changes are straightforward and focused:
- The import change removes the unused `once` and `warn` imports in favor of `warn_once`
- Two existing warning patterns are updated to use the more concise `warn_once!` macro
- A new warning is added for excessively large font sizes with a clear explanation of the potential performance impact

## Further Reading

1. **Bevy Logging System**: Understanding Bevy's logging macros (`warn!`, `warn_once!`, `info!`, etc.) and how they work with Bevy's scheduling system.
2. **Text Rendering Pipeline**: How Bevy processes text components, generates font atlases, and renders text to the screen.
3. **Font Atlas Generation**: The process of creating texture atlases for fonts, including performance considerations for large glyph sizes.
4. **Defensive Programming**: Techniques for writing code that detects and handles improper usage, providing better developer feedback.
5. **Bevy ECS System Ordering**: How systems like `TextPipeline::queue_text` fit into Bevy's ECS architecture and when they execute relative to other systems.