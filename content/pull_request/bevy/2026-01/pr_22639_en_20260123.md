+++
title = "#22639 Improve realism of entity benches by warming up the entity allocator"
date = "2026-01-23T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22639-en-20260123" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22639-zh-cn-20260123" }}
labels = ["A-ECS", "C-Benchmarks", "D-Straightforward"]
+++

# Title
Improve realism of entity benches by warming up the entity allocator

## Basic Information
- **Title**: Improve realism of entity benches by warming up the entity allocator
- **PR Link**: https://github.com/bevyengine/bevy/pull/22639
- **Author**: ElliottjPierce
- **Status**: MERGED
- **Labels**: A-ECS, C-Benchmarks, D-Straightforward, S-Needs-Review
- **Created**: 2026-01-22T02:46:25Z
- **Merged**: 2026-01-23T02:23:17Z
- **Merged By**: cart

## Description Translation

# Objective

As per [this](https://github.com/bevyengine/bevy/pull/18670#issuecomment-3776301267) comment on #18670, this PR attempts to make entity related benchmarks more realistic by warming up the entity allocator. This helps test the freelist in the entity allocator.

## Solution

This PR introduces a new `WorldBuilder` type that starts with `World::new`, allows configuration options for warming up the world via the builder pattern, and then builds the warmed up, realistic world. For now, the only available "warm up" is for entities, but we could also add functionality in the future to cache bundle info, pre-create tables, etc to make our benchmarks more realistic. That is, more closely match the performance of a running app, rather than an app at startup.

The current implementation for entity warmups allocates some entities and frees them in a random order. It also spawns the highest allocated entity index to prepare `Entities`'s location storage, etc. This involves using `rng` (deterministically), but without this, the entities are allocated in a linear index order (0, 1, 2, ...), which is unrealistic and extremely cache friendly (so it probably makes an impact in performance not desirable for a benchmark).

The major downsides here are that the benches take a little longer to run now and that startup/caching time is no longer benchmarked. That is for example, that benchmarking despawning only one entity used to tell us some information about performance of allocating the free list (amongst other one time actions). Now, that information is lost since the world is already warmed up. In practice, for N values of entities, it used to be the case that a higher N showed the performance of the operation, and a lower N showed the performance of the operation + any registration/caching costs. Now, the different N values only tell us more about how well the CPU accommodates a batch of the operation. 

Currently in Bevy, making a change might make the `...1_entity` benches much worse but the `...1000_entities` much much better because the change added some new caching.  The inverse is also common. With this PR, that will no longer be the case, at least for entities and whatever else we add to the `WorldBuilder` in the future. And that change may or may not be desirable.

## Testing

Ran a sampling of the benchmarks.

## The Story of This Pull Request

This pull request addresses a fundamental issue with Bevy's ECS benchmarks: they weren't testing realistic runtime conditions. When benchmarks used `World::new()` or `World::default()` to create a fresh world, they were measuring startup behavior with a "cold" entity allocator, not the performance characteristics of a running application where entities have been allocated and freed in non-sequential patterns.

The problem originated from how entity IDs are allocated. In a fresh world, entities get sequential IDs (0, 1, 2, ...), which is extremely cache-friendly and doesn't exercise the entity allocator's freelist mechanism. In real applications, entities are created and destroyed in arbitrary orders, leaving gaps that get reused through the freelist. This creates fragmentation that affects memory layout and cache performance.

The solution introduces a `WorldBuilder` utility specifically for benchmarks. Instead of starting with a cold world, benchmarks can now use this builder to create a "hot" world with a warmed-up entity allocator. The implementation follows a straightforward pattern:

1. Allocate a batch of entities (default: 10,000)
2. Spawn and immediately despawn the highest-index entity to prepare the `Entities` storage
3. Shuffle the entity IDs using a deterministic RNG
4. Free them in random order to create realistic freelist fragmentation

This approach ensures that subsequent entity allocations in the benchmark won't get sequential IDs but will instead draw from a fragmented freelist, better simulating real-world conditions.

The technical implementation centers around a new `WorldBuilder` struct in `main.rs`. It uses the builder pattern to configure warm-up operations, starting with the most important one: `warm_up_entity_allocator()`. This method handles the allocation/freeing cycle and uses `SmallRng` with a fixed seed for deterministic benchmarks.

```rust
pub fn warm_up_entity_allocator(mut self) -> Self {
    // allocate
    let mut entities = Vec::new();
    entities.reserve_exact(self.max_expected_entities as usize);
    entities.extend(
        self.world
            .entity_allocator()
            .alloc_many(self.max_expected_entities),
    );

    // Spawn the high index to warm up `Entities`.
    let Some(high_index) = entities.last_mut() else {
        // There were no expected entities.
        return self;
    };
    self.world.spawn_empty_at(*high_index).unwrap();
    *high_index = self.world.try_despawn_no_free(*high_index).unwrap();

    // free
    entities.shuffle(&mut self.rng);
    entities
        .drain(..)
        .for_each(|e| self.world.entity_allocator_mut().free(e));

    self
}
```

The PR updates five benchmark files to use this new `WorldBuilder`:
- `commands.rs`: For command spawning and insertion benchmarks
- `spawn.rs`: For entity spawning benchmarks
- `despawn.rs`: For entity despawning benchmarks
- `despawn_recursive.rs`: For recursive despawning benchmarks

Each benchmark now follows the same pattern: create the world using `WorldBuilder`, configure it with the expected entity count, warm up the entity allocator, and then run the benchmark operations.

There are important trade-offs with this approach. Benchmarks now take longer to run due to the warm-up phase, and they no longer measure startup costs like first-time component registration or table creation. This changes how benchmark results should be interpreted - previously, low entity counts could show startup costs while high counts showed batch operation performance. Now, all entity counts primarily measure batch operation performance on a pre-warmed system.

The PR author notes that this might not always be desirable, as it obscures the impact of caching mechanisms. A change that improves caching might show up as worse performance in 1-entity benchmarks but better in 1000-entity benchmarks with the old approach. With this change, that distinction disappears.

The implementation includes careful engineering decisions:
1. **Deterministic RNG**: Uses a fixed seed (`2039482342342`) to ensure benchmark reproducibility
2. **Configurable entity count**: The `with_max_expected_entities()` method lets benchmarks tailor the warm-up to their specific needs
3. **High-index preparation**: Spawning and despawning the highest entity ensures `Entities` storage is properly sized
4. **Randomized freeing order**: The shuffle operation creates realistic freelist fragmentation patterns

This change represents a shift in benchmarking philosophy - from measuring startup performance to measuring steady-state runtime performance. It provides more realistic data for optimization decisions in production scenarios while sacrificing some visibility into initialization costs.

## Visual Representation

```mermaid
graph TD
    A[Benchmark Setup] --> B[WorldBuilder::new()]
    B --> C[.with_max_expected_entities()]
    C --> D[.warm_up_entity_allocator()]
    D --> E[Allocate Entities]
    E --> F[Spawn/Despawn Highest Entity]
    F --> G[Shuffle Entity IDs]
    G --> H[Free in Random Order]
    H --> I[.build()]
    I --> J[Benchmark Operations]
    J --> K[Spawn/Despawn/Query/etc]
```

## Key Files Changed

### `benches/benches/bevy_ecs/main.rs` (+77/-0)
Added a new `world_builder` module that provides the `WorldBuilder` struct for creating pre-warmed worlds. This is the core infrastructure that enables realistic benchmarking.

**Key code:**
```rust
pub struct WorldBuilder {
    world: World,
    rng: SmallRng,
    max_expected_entities: u32,
}

impl WorldBuilder {
    pub fn new() -> Self {
        Self {
            world: World::new(),
            rng: SmallRng::seed_from_u64(2039482342342),
            max_expected_entities: 10_000,
        }
    }
    
    pub fn warm_up_entity_allocator(mut self) -> Self {
        // Implementation as shown above
    }
}
```

### `benches/benches/bevy_ecs/world/commands.rs` (+19/-5)
Updated command-related benchmarks to use `WorldBuilder` instead of `World::default()`. This affects spawn commands, non-empty spawn commands, and insert commands.

**Key change:**
```rust
// Before:
let mut world = World::default();

// After:
let mut world = WorldBuilder::new()
    .with_max_expected_entities(entity_count)
    .warm_up_entity_allocator()
    .build();
```

### `benches/benches/bevy_ecs/world/spawn.rs` (+11/-3)
Updated entity spawning benchmarks. Also fixed a type conversion issue where `batch_count` (a `u32`) was passed directly to `std::iter::repeat_n()` which expects `usize`.

**Key change:**
```rust
// Before:
world.spawn_batch(std::iter::repeat_n(
    (A(Mat4::default()), B(Vec4::default())),
    batch_count,  // u32, potentially causing issues
));

// After:
world.spawn_batch(std::iter::repeat_n(
    (A(Mat4::default()), B(Vec4::default())),
    batch_count as usize,  // Explicit conversion
));
```

### `benches/benches/bevy_ecs/world/despawn.rs` (+6/-1)
Updated entity despawning benchmarks to use the warmed-up world.

### `benches/benches/bevy_ecs/world/despawn_recursive.rs` (+6/-1)
Updated recursive despawning benchmarks with the same pattern.

## Further Reading

1. **Bevy ECS Architecture**: Understanding Bevy's Entity Component System architecture helps contextualize why entity allocation patterns matter
2. **Memory Fragmentation**: Research on how memory fragmentation affects cache performance and allocation strategies
3. **Deterministic Benchmarking**: Techniques for creating reproducible benchmarks, especially important for CI/CD pipelines
4. **Builder Pattern**: The builder pattern used in `WorldBuilder` is a common Rust idiom for complex object construction
5. **Freelist Allocators**: How freelist-based allocators work and their performance characteristics compared to sequential allocators