+++
title = "#22339 fix testbeds with argh in wasm"
date = "2026-01-01T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22339-en-20260101" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22339-zh-cn-20260101" }}
labels = ["C-Examples", "O-Web"]
+++

# Title
## Basic Information
- **Title**: fix testbeds with argh in wasm
- **PR Link**: https://github.com/bevyengine/bevy/pull/22339
- **Author**: mockersf
- **Status**: MERGED
- **Labels**: C-Examples, O-Web
- **Created**: 2026-01-01T17:48:22Z
- **Merged**: 2026-01-01T20:12:08Z
- **Merged By**: mockersf

## Description Translation
# Objective

- #22223 used argh in the testbed examples
- this compiles in wasm but crashes when running them

## Solution

- Fix it like the other examples using argh

## The Story of This Pull Request

This PR addresses a compatibility issue that emerged after PR #22223 introduced the `argh` command-line argument parsing library to the testbed examples. The problem was straightforward: while the code compiled successfully for WebAssembly (wasm) targets, it would crash at runtime. The root cause lies in how `argh::from_env()` operates differently between native and wasm environments.

In native execution contexts, `argh::from_env()` reads arguments from the standard command-line interface via `std::env::args()`. However, in a wasm environment running in a browser, there is no traditional command line. The `std::env::args()` function isn't available or returns an empty iterator, causing `argh::from_env()` to fail when it tries to parse non-existent arguments.

The solution implemented here follows a pattern already established elsewhere in the Bevy codebase for handling this exact scenario. Instead of calling `argh::from_env()` unconditionally, the code now uses conditional compilation with `#[cfg]` attributes. For non-wasm targets, it continues to use `argh::from_env()` as before. For wasm32 targets, it calls `Args::from_args(&[], &[]).unwrap()`, which creates a default instance of the argument struct using empty argument arrays.

This approach works because `Args::from_args()` is a lower-level API that allows manually passing arguments as slices, bypassing the need for `std::env::args()`. By passing empty slices, we effectively create the argument struct with default values, which is appropriate for wasm execution where command-line arguments don't exist.

The fix is applied consistently across all three testbed examples (2D, 3D, and UI), ensuring uniform behavior. Each example file receives identical changes, making the solution straightforward and maintainable. The conditional compilation ensures that the correct code path is selected at compile time based on the target architecture, with no runtime overhead.

This type of platform-specific adaptation is common in cross-platform development, particularly when dealing with web targets that have different execution models than native applications. The solution demonstrates a pragmatic approach to maintaining compatibility while preserving functionality across different deployment targets.

## Visual Representation

```mermaid
graph TD
    A[PR #22223 introduces argh] --> B[Testbed examples compile for wasm]
    B --> C[Runtime crash in wasm environment]
    C --> D{Identify root cause}
    D --> E[argh::from_env() relies on std::env::args()]
    E --> F[std::env::args() unavailable in wasm]
    F --> G[Implement conditional compilation]
    G --> H[Non-wasm: Use argh::from_env()]
    G --> I[Wasm32: Use Args::from_args(&[], &[])]
    H --> J[Works on native platforms]
    I --> K[Works on WebAssembly]
```

## Key Files Changed

### 1. `examples/testbed/2d.rs`
**Change**: Added conditional compilation for argument parsing to support wasm32 architecture.

**Code Snippet**:
```rust
// Before:
fn main() {
    let args: Args = argh::from_env();
    // ... rest of code
}

// After:
fn main() {
    #[cfg(not(target_arch = "wasm32"))]
    let args: Args = argh::from_env();
    #[cfg(target_arch = "wasm32")]
    let args: Args = Args::from_args(&[], &[]).unwrap();
    // ... rest of code
}
```

### 2. `examples/testbed/3d.rs`
**Change**: Identical conditional compilation pattern applied to 3D testbed.

**Code Snippet**:
```rust
// Before:
fn main() {
    let args: Args = argh::from_env();
    // ... rest of code
}

// After:
fn main() {
    #[cfg(not(target_arch = "wasm32"))]
    let args: Args = argh::from_env();
    #[cfg(target_arch = "wasm32")]
    let args: Args = Args::from_args(&[], &[]).unwrap();
    // ... rest of code
}
```

### 3. `examples/testbed/ui.rs`
**Change**: Same fix applied to UI testbed example.

**Code Snippet**:
```rust
// Before:
fn main() {
    let args: Args = argh::from_env();
    // ... rest of code
}

// After:
fn main() {
    #[cfg(not(target_arch = "wasm32"))]
    let args: Args = argh::from_env();
    #[cfg(target_arch = "wasm32")]
    let args: Args = Args::from_args(&[], &[]).unwrap();
    // ... rest of code
}
```

## Further Reading

- [Rust Conditional Compilation Documentation](https://doc.rust-lang.org/reference/conditional-compilation.html) - Official guide to `#[cfg]` attributes and conditional compilation in Rust
- [argh crate documentation](https://docs.rs/argh/latest/argh/) - API reference for the argh command-line argument parser
- [WebAssembly Platform Considerations](https://rustwasm.github.io/docs/book/reference/js-ffi.html) - Understanding Rust/WASM interoperability challenges
- [Bevy WebAssembly Guide](https://bevyengine.org/learn/quick-start/platforms/wasm/) - Official Bevy documentation for WASM deployment