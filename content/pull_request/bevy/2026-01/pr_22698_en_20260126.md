+++
title = "#22698 render buffer debug label type prepopulation"
date = "2026-01-26T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22698-en-20260126" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22698-zh-cn-20260126" }}
labels = ["A-Rendering", "A-Dev-Tools", "C-Refinement"]
+++

# Title
render buffer debug label type prepopulation

## Basic Information
- **Title**: render buffer debug label type prepopulation
- **PR Link**: https://github.com/bevyengine/bevy/pull/22698
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: A-Rendering, S-Ready-For-Final-Review, A-Dev-Tools, X-Uncontroversial, C-Refinement
- **Created**: 2026-01-25T16:05:10Z
- **Merged**: 2026-01-26T00:35:30Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

- The vast majority of our buffers are unlabelled. This makes debugging wgpu errors really annoying, cus they lack context.

## Solution

- We have type information, and buffers predominantly are custom struct types, and the few cases in which they arent they seem to be manually named anyways. Let's exploit the type info to populate the buffer names under a debug gate.

## Testing

- ran occlusion_culling example with and without the debug feature, it currently crashes due to a wgpu 28 change.

## Showcase

Before:
```
Caused by:
  In a CommandEncoder
    In a dispatch command, indirect:true
      Attempted to use Buffer with '' label with conflicting usages. Current usage BufferUses(STORAGE_READ_WRITE) and new usage BufferUses(INDIRECT). BufferUses(STORAGE_READ_WRITE) is an exclusive usage and cannot be used with any other usages within the usage scope (renderpass or compute dispatch).
```

After:
```
Caused by:
  In a CommandEncoder
    In a dispatch command, indirect:true
      Attempted to use Buffer with 'bevy_render::render_resource::buffer_vec::RawBufferVec<bevy_render::batching::gpu_preprocessing::LatePreprocessWorkItemIndirectParameters>' label with conflicting usages. Current usage BufferUses(STORAGE_READ_WRITE) and new usage BufferUses(INDIRECT). BufferUses(STORAGE_READ_WRITE) is an exclusive usage and cannot be used with any other usages within the usage scope (renderpass or compute dispatch).
```

Note that now we know 1. its a `RawBufferVec`, 2. of `LatePreprocessWorkItemIndirectParameters`. This lets us greatly narrow the scope of the search for an offender.



Note: this is the evolution of several different attempts at improving debug info. First attempt was with `#[track_caller]`, but that doesn't work in const contexts because Location isnt allowed there. Second attempt was to prepopulate type name info in constructors, but `std::any::type_name()` returns a `&'static str`, and label is `Option<String>`, and `.into()` and `.to_string()` are both not const because `String` is heap allocated. Finally, i moved it to the buffer creation site, and then extracted it into a generic function to deduplicate.

## The Story of This Pull Request

Debugging GPU buffer errors in Bevy was challenging because most buffers lacked meaningful labels. When wgpu reported usage conflicts or other buffer-related errors, developers would see empty string labels in error messages, making it difficult to identify which specific buffer was causing the problem. The developer atlv24 recognized that type information was available at compile time and could be used to automatically populate labels when manual labels weren't provided.

The initial approach considered using `#[track_caller]` to capture source location information, but this wasn't viable because `Location` types can't be used in const contexts. A second approach attempted to prepopulate type names in constructors using `std::any::type_name()`, but this presented a type conversion problem: `type_name()` returns a `&'static str` while buffer labels are `Option<String>`, and converting to `String` involves heap allocation which isn't allowed in const contexts.

The final solution moves the label generation to the buffer creation site and extracts it into a reusable generic function. This approach works because buffer types are known at the point where `make_buffer_label` is called, allowing the compiler to generate type-specific implementations. The solution is gated behind a `type_label_buffers` feature flag, which is included in Bevy's broader `debug` feature set, ensuring the additional debug information doesn't affect release builds.

The implementation modifies three key buffer types in Bevy's renderer: `RawBufferVec`, `StorageBuffer`/`DynamicStorageBuffer`, and `UniformBuffer`/`DynamicUniformBuffer`. Each of these previously used `self.label.as_deref()` for their buffer labels. The change replaces this with `make_buffer_label::<Self>(&self.label)`, which checks if a manual label exists and, if not (and when the debug feature is enabled), returns the type name using `core::any::type_name::<T>()`.

The helper function `make_buffer_label` is defined in `buffer_vec.rs` with `pub(crate)` visibility, making it accessible to other render resource modules. It uses conditional compilation with `#[cfg(feature = "type_label_buffers")]` to include the type name logic only when the feature is enabled. When disabled, it falls back to the original behavior of returning the provided label.

The practical impact is significant for debugging. Error messages that previously showed empty labels now display the full type path, including generics. For example, instead of seeing a buffer with `''` label, developers now see `'bevy_render::render_resource::buffer_vec::RawBufferVec<bevy_render::batching::gpu_preprocessing::LatePreprocessWorkItemIndirectParameters>'`. This immediately tells developers both the container type (`RawBufferVec`) and the contained type (`LatePreprocessWorkItemIndirectParameters`), dramatically narrowing the search space when debugging buffer usage conflicts.

The changes required minimal modifications to the build system. A new `type_label_buffers` feature was added to both the root `Cargo.toml` and `bevy_internal/Cargo.toml`, and this feature was included in the existing `debug` feature set. This ensures the type labeling behavior is opt-in through the debug features, maintaining performance in production builds.

## Visual Representation

```mermaid
graph TD
    A[Debug Buffer Errors] --> B[Empty Labels in Error Messages]
    B --> C[Need Better Debug Context]
    C --> D[Attempt: #[track_caller] - Failed]
    C --> E[Attempt: Constructor Type Names - Failed]
    C --> F[Solution: make_buffer_label at Creation]
    F --> G[Generic Helper Function]
    G --> H[Conditional Compilation]
    H --> I[Type Names in Error Messages]
    I --> J[Improved Debugging Experience]
    
    subgraph "Buffer Types Modified"
        K[RawBufferVec]
        L[StorageBuffer]
        M[UniformBuffer]
    end
    
    G --> K
    G --> L
    G --> M
```

## Key Files Changed

1. **`crates/bevy_render/src/render_resource/buffer_vec.rs`** (+12/-3)
   - Added `make_buffer_label` function that conditionally returns type names when debug feature is enabled
   - Modified three buffer creation sites to use the new helper function

   **Key code snippet:**
   ```rust
   // New helper function added
   #[inline]
   pub(crate) fn make_buffer_label<'a, T>(label: &'a Option<String>) -> Option<&'a str> {
       #[cfg(feature = "type_label_buffers")]
       if label.is_none() {
           return Some(core::any::type_name::<T>());
       }
       label.as_deref()
   }
   
   // Usage in buffer creation (example from RawBufferVec)
   // Before:
   label: self.label.as_deref(),
   
   // After:
   label: make_buffer_label::<Self>(&self.label),
   ```

2. **`crates/bevy_render/src/render_resource/storage_buffer.rs`** (+6/-3)
   - Added import for `make_buffer_label`
   - Modified `StorageBuffer` and `DynamicStorageBuffer` to use type-based labels

   **Key code snippet:**
   ```rust
   // Added import
   use crate::render_resource::make_buffer_label;
   
   // Modified buffer creation
   label: make_buffer_label::<Self>(&self.label),
   ```

3. **`crates/bevy_render/src/render_resource/uniform_buffer.rs`** (+3/-3)
   - Added import for `make_buffer_label`
   - Modified `UniformBuffer` and `DynamicUniformBuffer` to use type-based labels

   **Key code snippet:**
   ```rust
   // Added import
   use crate::render_resource::make_buffer_label;
   
   // Modified buffer creation
   label: make_buffer_label::<Self>(&self.label),
   ```

4. **`crates/bevy_internal/Cargo.toml`** (+4/-1)
   - Added `type_label_buffers` feature definition
   - Added `bevy_render/debug` to the `debug` feature set

   **Key code snippet:**
   ```toml
   # New feature definition
   type_label_buffers = ["bevy_render/type_label_buffers"]
   
   # Added to debug feature
   debug = ["bevy_utils/debug", "bevy_ecs/debug", "bevy_render/debug"]
   ```

5. **`crates/bevy_render/Cargo.toml`** (+4/-0)
   - Added `type_label_buffers` feature
   - Added `debug` feature that includes `type_label_buffers`

   **Key code snippet:**
   ```toml
   type_label_buffers = []
   debug = ["type_label_buffers"]
   ```

## Further Reading

- [Rust `core::any::type_name` documentation](https://doc.rust-lang.org/core/any/fn.type_name.html) - Understanding how type names are obtained at compile time
- [wgpu Buffer Labels documentation](https://wgpu.rs/doc/wgpu/struct.BufferDescriptor.html#structfield.label) - How labels are used in wgpu for debugging
- [Bevy Feature Flags guide](https://github.com/bevyengine/bevy/blob/main/docs/cargo_features.md) - Understanding Bevy's feature system
- [Conditional Compilation in Rust](https://doc.rust-lang.org/reference/conditional-compilation.html) - Using `#[cfg]` attributes for feature gating