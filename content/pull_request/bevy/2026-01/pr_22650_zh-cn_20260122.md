+++
title = "#22650 WinitSettings` cleanup"
date = "2026-01-22T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22650-en-20260122" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22650-zh-cn-20260122" }}
+++

# `WinitSettings` 清理工作

## 基本信息
- **标题**: `WinitSettings` cleanup
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22650
- **作者**: ickshonpe
- **状态**: 已合并 (MERGED)
- **标签**: D-Trivial, C-Code-Quality, S-Ready-For-Final-Review
- **创建时间**: 2026-01-22T17:31:23Z
- **合并时间**: 2026-01-22T18:42:32Z
- **合并者**: alice-i-cecile

## 描述翻译
### 目标 (Objective)

#### 一些清理工作
1. `many_gradients` 示例中插入了两次 `WinitSettings`。
2. 用 `WinitSettings::continuous()` 替换那些可以手动配置的地方。

## 本次拉取请求的始末

在 Bevy 游戏引擎的示例代码仓库中，存在一些可以简化和标准化的配置代码。本次 PR 的核心是清理几个示例项目中关于 `WinitSettings` 资源配置的代码。`WinitSettings` 是一个用于控制 Bevy 应用主事件循环更新行为的资源，特别是在窗口聚焦 (focused) 和失焦 (unfocused) 状态下的更新模式 (UpdateMode)。

最初的问题在于代码风格的不一致和潜在的配置冗余。在多个压力测试 (`stress_tests`) 和大场景 (`large_scenes`) 示例中，开发者为了确保应用在任何状态下（无论是窗口在前台还是后台）都能以最高性能、不间断地 (`Continuous`) 运行更新循环，手动构造了 `WinitSettings` 结构体实例。这种手动构造的代码模式虽然功能上正确，但显得冗长，且与 Bevy 提供的便捷 API 不一致。

具体来看，原始的代码模式如下：
```rust
.insert_resource(WinitSettings {
    focused_mode: UpdateMode::Continuous,
    unfocused_mode: UpdateMode::Continuous,
})
```
这段代码明确地将聚焦模式和失焦模式都设置为 `UpdateMode::Continuous`。这符合压力测试和大型场景演示的需求，因为这些示例通常需要在渲染或逻辑更新上保持最大吞吐量，以测试引擎的极限性能。

然而，Bevy 的 API 设计早已预见了这种常见需求，并提供了一个名为 `continuous()` 的关联函数（工厂方法）来直接生成具有相同配置的 `WinitSettings` 实例。使用这个 API 不仅能使代码更简洁，还能提高可读性和一致性，因为阅读者一看到 `WinitSettings::continuous()` 就能立刻理解其意图，而无需逐行解析结构体的字段。

因此，本次修改的技术方案非常直接：用一行 `WinitSettings::continuous()` 的调用替换所有重复的、手动的结构体初始化代码。这个改动属于典型的“代码质量” (Code Quality) 提升，不涉及任何功能逻辑的变更，其影响纯粹是语法层面的优化。

在实施过程中，开发者 `ickshonpe` 发现了 `many_gradients.rs` 这个示例文件中存在一个额外问题：`WinitSettings` 被插入了两次。这很可能是一个疏忽导致的错误。重复插入同一个类型的资源在 Bevy 中虽然不会导致崩溃（后插入的值会覆盖先前的值），但它造成了代码的混淆和微小的运行时开销（尽管可以忽略不计）。更严重的是，它传达了错误的代码意图，让后来者困惑于为何要配置两次。修复方案是移除多余的手动构造行，并确保 `WinitSettings::continuous()` 和示例特定的 `args` 资源以清晰的顺序插入。

让我们看看 `many_gradients.rs` 的具体变化。修改前，代码中存在两处 `insert_resource` 调用：
```rust
// 修改前 (many_gradients.rs 部分代码)
        .insert_resource(WinitSettings {
            focused_mode: UpdateMode::Continuous,
            unfocused_mode: UpdateMode::Continuous,
        })
        .insert_resource(args)
        .insert_resource(WinitSettings::continuous()) // 注意：这一行是后来添加的，但造成了重复
```
可以看到，这里先插入了一个手动配置的 `WinitSettings`，然后又试图插入一个通过工厂方法创建的 `WinitSettings`。PR 将其修正为：
```rust
// 修改后 (many_gradients.rs 部分代码)
        .insert_resource(WinitSettings::continuous())
        .insert_resource(args)
```
这个改动一举两得：一是消除了重复配置，二是采用了更简洁的工厂方法。代码的行数从原来的 6 行（定义结构体）减少到 1 行，并且意图更加明确。

对于其他四个示例文件 (`bistro`, `caldera_hotel`, `many_cubes`, `many_materials`)，修改模式是统一的，都是将冗长的手动构造替换为 `WinitSettings::continuous()`。例如，在 `many_cubes.rs` 中的改动：
```rust
// 修改前 (many_cubes.rs)
    .insert_resource(WinitSettings {
        focused_mode: UpdateMode::Continuous,
        unfocused_mode: UpdateMode::Continuous,
    })

// 修改后 (many_cubes.rs)
    .insert_resource(WinitSettings::continuous())
```
这一改动将代码从 5 行缩减到 2 行（包括换行），在视觉上大大减轻了认知负担。

从技术角度来看，`WinitSettings::continuous()` 是一个简单的工厂方法，其内部实现很可能就是返回一个预先配置好的结构体实例。使用这种方法符合 Rust 和 Bevy 社区鼓励的 API 设计模式：为常见的、固定的配置提供便捷的构造函数。这有助于减少样板代码 (boilerplate code)，降低出错概率（比如拼错字段名），并使得代码库的整体风格保持一致。

本次 PR 的影响是积极且有限的。积极之处在于，它提升了示例代码的质量，使其更清晰、更符合最佳实践，从而为学习 Bevy 的新开发者树立了更好的榜样。有限之处在于，它仅修改了示例代码，并未触及引擎的核心逻辑。尽管如此，这类清理工作对于维护大型开源项目至关重要，它有助于防止“破窗效应”，保持代码库的整洁和可维护性。

总结来说，这是一个典型的“童子军规则”实践：在修改代码时，顺手将遇到的坏味道 (code smell) 清理干净。通过将重复、冗长的配置代码替换为标准化的便捷 API，本次 PR 在几乎零成本的情况下，提升了代码的可读性和一致性。

## 视觉表示

以下 Mermaid 图展示了本次 PR 中代码模式的转变关系：

```mermaid
graph TD
    A[旧模式: 手动构造 WinitSettings] -->|PR #22650 更改| B[新模式: 使用工厂方法 continuous()]
    C[重复插入 WinitSettings] -->|PR #22650 修复| D[单一、正确的资源插入]
    B --> E[结果: 更简洁、更一致的示例代码]
    D --> E
```

## 关键文件更改

以下是本次 PR 中修改的主要文件：

- `examples/stress_tests/many_gradients.rs` (+2/-6)
- `examples/large_scenes/bistro/src/main.rs` (+2/-5)
- `examples/large_scenes/caldera_hotel/src/main.rs` (+2/-5)
- `examples/stress_tests/many_cubes.rs` (+2/-5)
- `examples/stress_tests/many_materials.rs` (+2/-5)

### 详细变更说明

**1. `examples/stress_tests/many_gradients.rs`**
*   **修改内容与原因**：修复了重复插入 `WinitSettings` 资源的问题，并统一使用 `WinitSettings::continuous()` 工厂方法。
*   **代码变更**:
    ```rust
    // 修改前 (关键部分):
    // .insert_resource(WinitSettings { // 手动构造 (第69-72行)
    //     focused_mode: UpdateMode::Continuous,
    //     unfocused_mode: UpdateMode::Continuous,
    // })
    // .insert_resource(args)
    // .insert_resource(WinitSettings::continuous()) // 重复插入 (第73行)

    // 修改后:
        .insert_resource(WinitSettings::continuous()) // 使用工厂方法，只插入一次
        .insert_resource(args) // 保持 args 资源的插入
    ```
*   **与 PR 目标的关联**：直接解决了 PR 描述中提到的第一个问题（重复插入），并应用了第二个优化（使用工厂方法）。

**2. `examples/large_scenes/bistro/src/main.rs`**
*   **修改内容与原因**：将手动构造 `WinitSettings` 的代码替换为 `WinitSettings::continuous()`，以简化代码。
*   **代码变更**:
    ```rust
    // 修改前:
    .insert_resource(WinitSettings {
        focused_mode: UpdateMode::Continuous,
        unfocused_mode: UpdateMode::Continuous,
    })

    // 修改后:
    .insert_resource(WinitSettings::continuous())
    ```
*   **与 PR 目标的关联**：实现了 PR 描述中的第二个目标，用工厂方法替换了手动配置。

**3. `examples/large_scenes/caldera_hotel/src/main.rs`**
*   **修改内容与原因**：与 `bistro` 示例相同，用工厂方法简化 `WinitSettings` 的配置。
*   **代码变更**:
    ```rust
    // 修改前:
    .insert_resource(WinitSettings {
        focused_mode: UpdateMode::Continuous,
        unfocused_mode: UpdateMode::Continuous,
    })

    // 修改后:
    .insert_resource(WinitSettings::continuous())
    ```
*   **与 PR 目标的关联**：实现了 PR 描述中的第二个目标。

**4. `examples/stress_tests/many_cubes.rs`**
*   **修改内容与原因**：在压力测试示例中，将手动的 `WinitSettings` 配置替换为 `continuous()` 方法。
*   **代码变更**:
    ```rust
    // 修改前:
    .insert_resource(WinitSettings {
        focused_mode: UpdateMode::Continuous,
        unfocused_mode: UpdateMode::Continuous,
    })

    // 修改后:
    .insert_resource(WinitSettings::continuous())
    ```
*   **与 PR 目标的关联**：实现了 PR 描述中的第二个目标，使代码更简洁。

**5. `examples/stress_tests/many_materials.rs`**
*   **修改内容与原因**：另一个压力测试示例，同样将冗长的手动配置替换为工厂方法。
*   **代码变更**:
    ```rust
    // 修改前:
    .insert_resource(WinitSettings {
        focused_mode: UpdateMode::Continuous,
        unfocused_mode: UpdateMode::Continuous,
    })

    // 修改后:
    .insert_resource(WinitSettings::continuous())
    ```
*   **与 PR 目标的关联**：实现了 PR 描述中的第二个目标，完成了对相关示例的清理。

## 进一步阅读

对于希望深入了解相关概念的读者，可以参考以下资源：

1.  **Bevy 官方文档 - WinitSettings**: 了解 `WinitSettings` 结构体的详细字段、`UpdateMode` 枚举的不同变体（如 `Continuous`, `Reactive`）及其对应用行为和性能的影响。
    *   [https://docs.rs/bevy/latest/bevy/winit/struct.WinitSettings.html](https://docs.rs/bevy/latest/bevy/winit/struct.WinitSettings.html)

2.  **Bevy 示例仓库**: 浏览其他示例，学习 Bevy 引擎不同模块的使用模式和最佳实践。
    *   [https://github.com/bevyengine/bevy/tree/main/examples](https://github.com/bevyengine/bevy/tree/main/examples)

3.  **Rust 编程中的“工厂模式” (Factory Pattern)**: 理解像 `continuous()` 这样的关联函数如何作为工厂方法，用于创建和返回复杂或常见配置的对象实例，这是 Rust 中减少样板代码的常用技巧。
    *   相关 Rust 编程书籍或社区文章中对“构造函数模式”和“Builder 模式”的讨论也与此相关。

4.  **代码重构 (Refactoring) 原则**: 学习如何识别像“重复代码”和“冗长参数列表”这样的代码坏味道，并运用“以函数调用取代硬编码”等重构手法进行改善。
    *   推荐书籍：《重构：改善既有代码的设计》（Martin Fowler 著）

# Full Code Diff
（此处完整包含 PR 描述中提供的 diff 内容，内容与上文“关键文件更改”部分的代码摘要一致，故不再重复列出。）