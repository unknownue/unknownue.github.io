+++
title = "#22393 new 2d rotation example"
date = "2026-01-05T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22393-en-20260105" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22393-zh-cn-20260105" }}
labels = ["C-Examples", "A-Transform", "D-Straightforward"]
+++

# new 2d rotation example

## Basic Information
- **Title**: new 2d rotation example
- **PR Link**: https://github.com/bevyengine/bevy/pull/22393
- **Author**: ChristopherBiscardi
- **Status**: MERGED
- **Labels**: C-Examples, S-Ready-For-Final-Review, A-Transform, D-Straightforward
- **Created**: 2026-01-05T19:48:21Z
- **Merged**: 2026-01-05T23:18:20Z
- **Merged By**: alice-i-cecile

## Description Translation

**Objective**

Address the 2d use case of rotating an entity to face the cursor in the minimal amount of code

**Solution**

New example

**Testing**

```
cargo run --example rotate_to_cursor
```

---

**Showcase**

https://github.com/user-attachments/assets/2f3aeade-5def-4fa3-a343-93985be55e57

## The Story of This Pull Request

This PR adds a practical example to Bevy's 2D examples suite that demonstrates a common game development pattern: rotating an entity to face the cursor. The problem being addressed is straightforward but important for developers new to Bevy's coordinate system and transform operations. Many 2D games need entities (like player characters or turrets) to rotate toward a target point, typically the mouse cursor, and implementing this correctly requires understanding several Bevy concepts working together.

The developer approached this by creating a minimal, focused example that demonstrates the core mechanics without additional complexity. The implementation shows how to combine several Bevy systems: accessing cursor position from the window, converting screen coordinates to world coordinates using the camera, and calculating the rotation angle between two points. This example fills a gap in the existing documentation - while there was already a "rotation" example showing basic quaternion rotation, it didn't demonstrate the practical use case of rotating toward a dynamic target like the cursor.

Looking at the implementation, the key technical insight is how to properly convert between coordinate systems and calculate the correct rotation angle. The example uses `camera.viewport_to_world_2d()` to convert screen coordinates to world coordinates, which is essential because the cursor position is in screen space (pixels from the top-left corner) while the entity's transform exists in world space. Once both positions are in world space, the code calculates the vector between them and uses `Vec2::to_angle()` to get the angle in radians.

A subtle but important detail in the implementation is the adjustment using `FRAC_PI_2` (π/2 or 90 degrees). This compensates for the default orientation of the sprite asset - the ship texture faces "up" in its local coordinate system, but the mathematical calculation produces an angle where 0 radians points to the right. This kind of asset-specific adjustment is common in game development and the example usefully documents this requirement.

The code structure follows Bevy's ECS (Entity Component System) patterns cleanly:
- It defines a `Player` component to tag the entity that should follow the cursor
- It uses the `Single` query filter to efficiently access the single player entity
- It demonstrates proper use of Bevy's coordinate system documentation in comments
- The example runs in `FixedUpdate` which is appropriate for cursor-following behavior

This example provides immediate practical value to developers working on 2D games in Bevy. Rather than having to piece together multiple concepts from different parts of the documentation, they now have a complete, working example that demonstrates a common game mechanic. The example is also well-positioned in the codebase - it's added to the 2D examples category alongside other rendering examples, and the existing "rotation" example is renamed to "Generic 2D Rotation" to distinguish it from this more specific use case.

From an engineering perspective, this PR demonstrates good example design: it's minimal, focused on one concept, well-documented with comments explaining the coordinate system and mathematical adjustments, and includes visual feedback (the rotating ship sprite) so users can immediately see that it's working correctly. The example also works in WebAssembly (as indicated by `wasm = true` in the Cargo.toml metadata), which is important for Bevy's cross-platform capabilities.

## Visual Representation

```mermaid
graph TD
    A[Window System] --> B[Provides cursor_position]
    C[Camera System] --> D[Provides viewport_to_world_2d]
    B --> E[Player Movement System]
    D --> E
    E --> F[Calculates vector: cursor_world_pos - player_position]
    F --> G[Converts to angle using to_angle()]
    G --> H[Adjusts by FRAC_PI_2 for sprite orientation]
    H --> I[Sets player.rotation Quat]
    I --> J[Sprite rotates to face cursor]
```

## Key Files Changed

**1. `examples/2d/rotate_to_cursor.rs` (+59/-0)**

This is a new file that contains the complete example implementation.

```rust
//! Demonstrates rotating sprites to face the cursor.

use bevy::prelude::*;
use std::f32::consts::FRAC_PI_2;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup)
        .add_systems(FixedUpdate, player_movement_system)
        .run();
}

/// Player component
#[derive(Component)]
struct Player;

/// Add the game's entities to our world and create an orthographic camera for 2D rendering.
///
/// The Bevy coordinate system is the same for 2D and 3D, in terms of 2D this means that:
///
/// * `X` axis goes from left to right (`+X` points right)
/// * `Y` axis goes from bottom to top (`+Y` point up)
/// * `Z` axis goes from far to near (`+Z` points towards you, out of the screen)
///
/// The world origin in this case is at the center of the screen, but the camera could
/// move in which case the world origin would not be the center of the screen
fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    let ship_handle = asset_server.load("textures/simplespace/ship_C.png");

    commands.spawn(Camera2d);

    // Player controlled ship
    commands.spawn((Sprite::from_image(ship_handle), Player));
}

/// Demonstrates applying rotation and movement based on keyboard input.
fn player_movement_system(
    mut player: Single<&mut Transform, With<Player>>,
    camera_query: Single<(&Camera, &GlobalTransform)>,
    window: Single<&Window>,
) {
    let (camera, camera_transform) = *camera_query;

    if let Some(cursor_position) = window.cursor_position()
        // Calculate a world position based on the cursor's position.
        && let Ok(cursor_world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_position)
    {
        // The angle an entity needs to rotate to face a point is defined
        // by the vector between the two points (Vec2 - Vec2), which we can then
        // turn into radians using to_angle.
        //
        // FRAC_PI_2 is because our sprite's ship is facing "up" so we rotate it an additional 90 degrees
        // so that it faces the cursor.
        player.rotation = Quat::from_rotation_z(
            (cursor_world_pos - player.translation.xy()).to_angle() - FRAC_PI_2,
        );
    }
}
```

**2. `Cargo.toml` (+13/-1)**

This file was updated to add the new example to Bevy's example registry and adjust the metadata of the existing rotation example.

```toml
# Before (lines around the change):
[[example]]
name = "rotation"
path = "examples/2d/rotation.rs"
# Causes an ICE on docs.rs
doc-scrape-examples = false

[package.metadata.example.rotation]
name = "2D Rotation"
description = "Demonstrates rotating entities in 2D with quaternions"
category = "2D Rendering"
wasm = true

# After the change:
[[example]]
name = "rotate_to_cursor"
path = "examples/2d/rotate_to_cursor.rs"
# Causes an ICE on docs.rs
doc-scrape-examples = false

[package.metadata.example.rotate_to_cursor]
name = "2D Rotation to Cursor"
description = "Demonstrates rotating entities in 2D to follow the cursor"
category = "2D Rendering"
wasm = true

[[example]]
name = "rotation"
path = "examples/2d/rotation.rs"
# Causes an ICE on docs.rs
doc-scrape-examples = false

[package.metadata.example.rotation]
name = "Generic 2D Rotation"
description = "Demonstrates rotating entities in 2D with quaternions"
category = "2D Rendering"
wasm = true
```

**3. `examples/README.md` (+2/-1)**

The documentation was updated to include the new example and rename the existing example for clarity.

```markdown
# Before:
Example | Description
--- | ---
[2D Bloom](../examples/2d/bloom_2d.rs) | Illustrates bloom post-processing in 2d
[2D Rotation](../examples/2d/rotation.rs) | Demonstrates rotating entities in 2D with quaternions
[2D Shapes](../examples/2d/2d_shapes.rs) | Renders simple 2D primitive shapes like circles and polygons

# After:
Example | Description
--- | ---
[2D Bloom](../examples/2d/bloom_2d.rs) | Illustrates bloom post-processing in 2d
[2D Rotation to Cursor](../examples/2d/rotate_to_cursor.rs) | Demonstrates rotating entities in 2D to follow the cursor
[2D Shapes](../examples/2d/2d_shapes.rs) | Renders simple 2D primitive shapes like circles and polygons
[Generic 2D Rotation](../examples/2d/rotation.rs) | Demonstrates rotating entities in 2D with quaternions
```

## Further Reading

1. **Bevy Transform Documentation**: For understanding how transforms, translation, and rotation work in Bevy's coordinate system
2. **Bevy Coordinate Systems Guide**: To understand the differences between world space, screen space, and viewport space
3. **Vector Mathematics for Game Development**: For deeper understanding of vector operations like subtraction and angle calculation
4. **Bevy Quaternion Documentation**: Since Bevy uses quaternions for 3D rotation (which also applies to 2D rotation around the Z-axis)
5. **Bevy ECS Query Documentation**: To understand how the `Single` query filter and component system work in the example