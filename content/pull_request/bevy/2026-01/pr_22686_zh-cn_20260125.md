+++
title = "#22686 relax return value of `World::resource_scope`"
date = "2026-01-25T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22686-en-20260125" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22686-zh-cn-20260125" }}
labels = ["A-ECS", "C-Usability", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: relax return value of `World::resource_scope`
- **PR Link**: https://github.com/bevyengine/bevy/pull/22686
- **Author**: joseph-gio
- **Status**: MERGED
- **Labels**: A-ECS, C-Usability, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-01-24T20:37:58Z
- **Merged**: 2026-01-25T21:00:58Z
- **Merged By**: alice-i-cecile

## Description Translation

# 目标

跟进 #22290

目前，当在作用域内调用`World::clear_resources`时，调用`resource_scope`或`try_resource_scope`会分别触发panic或返回`None`。这种行为在 #22290 中被有意保留以减少对用户的改动，但这种行为并非必要，因为在它变得相关的时间点，用户提供的作用域闭包已经成功完成。既然我们明确支持`clear_resources`等方法，我们应该将它们视为有效调用，并避免引起不必要的连锁错误。

## 测试

#22290中添加的测试已更新以反映新行为。

## The Story of This Pull Request

这个PR解决了一个在`World::resource_scope`方法中关于清理资源的边界情况问题。问题的核心在于`try_resource_scope`方法如何处理在作用域内调用`clear_resources`等清理操作的情况。

在PR #22290中，为了解决资源作用域内的潜在panic问题，引入了`was_successful`标志来跟踪资源是否被成功重新插入。当时的设计选择是在检测到资源元数据被清理时，让`try_resource_scope`返回`None`，而`resource_scope`则会panic。这种设计虽然防止了panic，但也带来了一些限制——它阻止了用户在作用域内合法地使用`clear_resources`等功能。

经过分析，开发者意识到这种限制是不必要的。关键的技术洞察在于：当用户闭包执行完成后，无论资源是否被清理，用户代码都已经完成了它的工作。此时再返回`None`或触发panic，实际上是在惩罚合法的使用模式。用户可能确实需要在作用域内清理资源，这种操作应该是被允许的。

具体实现上，PR移除了`ReinsertGuard`结构体中的`was_successful`字段，并简化了控制流。原来的设计需要跟踪guard是否成功执行了重新插入操作，现在改为直接返回结果。如果资源在作用域内被清理，guard的drop实现会检测到这一点并跳过重新插入，这已经是安全的行为了。

从工程角度看，这个改动有几个好处：

1. **简化了实现**：移除了复杂的成功状态跟踪逻辑
2. **提高了可用性**：允许用户在资源作用域内使用所有合法的World操作
3. **保持了安全性**：资源管理的基本保证仍然有效——如果没有被清理，资源会被正确重新插入

这个改动展示了在API设计中如何平衡安全性和灵活性。原来的实现过于保守，限制了合法的使用场景。通过仔细分析实际的需求和使用模式，开发者能够提出一个既安全又灵活的设计。

实现细节上的变化主要集中在`try_resource_scope`函数中。原来的实现使用了一个临时的`was_successful`变量来跟踪状态，现在这个变量被移除了。函数现在总是返回`Some(result)`，无论资源是否被重新插入。这是合理的，因为闭包已经执行完成，返回值应该是确定的。

## Visual Representation

```mermaid
graph TD
    A[调用 try_resource_scope] --> B[创建 ReinsertGuard]
    B --> C[执行用户闭包 f]
    C --> D{用户是否调用 clear_resources?}
    D -->|是| E[Guard drop 时不重新插入]
    D -->|否| F[Guard drop 时重新插入资源]
    E --> G[返回 Some(result)]
    F --> G
```

## Key Files Changed

### `crates/bevy_ecs/src/world/mod.rs` (+31/-33)

这个文件包含了`try_resource_scope`方法的主要实现改动。移除了成功状态跟踪逻辑，简化了控制流。

**关键改动1：移除了was_successful跟踪逻辑**

```rust
// Before:
struct ReinsertGuard<'a, R> {
    // ... 其他字段
    was_successful: &'a mut bool,  // 跟踪是否成功重新插入
}

// After:
struct ReinsertGuard<'a, R> {
    world: &'a mut World,
    component_id: ComponentId,
    value: ManuallyDrop<R>,
    ticks: ComponentTicks,
    caller: MaybeLocation,
    // was_successful字段被移除了
}
```

**关键改动2：简化了返回值逻辑**

```rust
// Before:
let mut was_successful = false;
let result = {
    // ... 执行闭包
    // guard的drop impl在这里运行
};
was_successful.then_some(result)

// After:
let result = f(guard.world, value_mut);
Some(result)  // 总是返回Some
```

**关键改动3：更新了文档注释**
增加了关于`clear_resources`和`clear_all`的说明，明确指出如果在作用域内清理资源元数据，资源将不会被重新插入。

### `crates/bevy_ecs/src/lib.rs` (+1/-3)

更新了测试以反映新的行为。原来的测试期望在`clear_resources`被调用后返回`None`，现在期望返回`Some(())`。

```rust
// 移除了关于测试目的的注释
// 测试现在期望Some(())而不是None
#[test]
fn resource_scope_resources_cleared() {
    let mut world = World::default();
    world.insert_resource(ResA(1));
    let r = world.try_resource_scope(|world, _r| {
        assert!(!world.contains_resource::<ResA>());
        world.clear_resources();
    });
    assert_eq!(r, Some(()));  // 从assert_eq!(r, None)改为assert_eq!(r, Some(()))
    assert!(!world.contains_resource::<ResA>());
}
```

## Further Reading

1. **Bevy ECS文档**：关于资源管理的详细说明 https://bevyengine.org/learn/book/next/programming/ecs/resources/
2. **PR #22290**：这个PR的前序改动，引入了原来的成功状态跟踪逻辑 https://github.com/bevyengine/bevy/pull/22290
3. **Rust的Drop trait**：理解guard模式如何利用Drop trait进行资源清理 https://doc.rust-lang.org/std/ops/trait.Drop.html
4. **Bevy的World API**：完整的World方法文档，了解其他可用的资源操作方法