+++
title = "#22226 Optimize Visibility Systems"
date = "2026-01-01T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22226-en-20260101" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22226-zh-cn-20260101" }}
labels = ["A-Rendering", "C-Performance", "P-Regression"]
+++

# Title

## Basic Information
- **Title**: Optimize Visibility Systems
- **PR Link**: https://github.com/bevyengine/bevy/pull/22226
- **Author**: aevyrie
- **Status**: MERGED
- **Labels**: A-Rendering, C-Performance, S-Ready-For-Final-Review, P-Regression
- **Created**: 2025-12-22T02:04:27Z
- **Merged**: 2026-01-01T22:25:12Z
- **Merged By**: alice-i-cecile

## 描述翻译
**目标**
- 让可见性系统运行得更快
- 在（GPU 受限的）6.7ms 帧中，渲染 Caldera Hotel 场景时，最高可节省 1.2ms 的 CPU 时间
- 修复 #22256

**解决方案**
- 将 `EntityHashSet` 替换为直接添加到实体的组件。这仍然允许对可见性进行正确的变更检测触发，但避免了哈希计算。同时这也实现了并行更新。

**总结**
- 这个 PR 发现了一个深层问题，揭示了 #22256
- 这个 PR 解决了自 0.17 版本发布以来引入的性能回归
- 更公平的比较不是与当前主分支（存在回归问题）比较，而是与 0.17 版本比较
- 与 0.17.3 相比，在 M4 Max 上运行 Caldera Hotel 场景时，`PostUpdate` 调度性能提升了 27%

<img width="558" height="251" alt="image" src="https://github.com/user-attachments/assets/2d711e3c-b65e-4c3a-9d2a-a587f8f36aae" />

**测试**
- 大量立方体、大量狐狸、Caldera Hotel 场景
- 黄色是新代码，红色是旧代码
- 注意旧代码跟踪中的双峰分布，这是可重复出现的，似乎与 `EntityHashSet` 和 `EntityHashMap` 有关。值得进一步调查，因为之前也见过这种双峰行为，并归因于性能核心与能效核心，但已验证不是这个原因
- 总结：Caldera Hotel 场景不再表现出双峰性能分布，避免了运行非常缓慢的病理模式。粗略比较约 90% 分位的性能，优化后的代码大约快 1.2ms。这在设备已经达到 150fps（GPU 受限）的情况下特别显著，因为每帧只有 6.7ms 的预算
- 值得注意的是，可见性检查曾是大多数 Bevy 应用常见热路径中最后一个性能明显不佳的系统集，现在在帧分析中不再明显显示为慢速：

<img width="1738" height="512" alt="image" src="https://github.com/user-attachments/assets/5252ff0f-d9f3-49d1-a3ce-309bd84d5485" />

**Caldera Hotel - 所有实体都在视图中**
此测试中，我没有移动摄像机，所以所有实体始终在视图中

`check_visibility`
<img width="1262" height="397" alt="image" src="https://github.com/user-attachments/assets/c80c470a-1548-42d2-838c-4e74525a6cb8" />

`reset_view_visibility`
<img width="1262" height="407" alt="image" src="https://github.com/user-attachments/assets/7b550823-f832-41f1-9e42-20cab342b0f2" />

`mark_newly_hidden_entities_invisible`
这比主分支现有代码的"快速模式"慢 23us，但比主分支的"慢速模式"快 180-250us。新代码更稳定，不会出现超慢模式

<img width="1256" height="418" alt="image" src="https://github.com/user-attachments/assets/b7cbf57d-a221-468a-9af8-3381981874b2" />

**Caldera Hotel - 没有实体在视图中**
此测试中，我立即旋转摄像机，使酒店不在视图中

`check_visibility`
基本持平。旧代码快 2us，但这可能在噪声范围内

<img width="1255" height="372" alt="image" src="https://github.com/user-attachments/assets/2c795f72-ebea-4b35-ba19-a8eccd4c56fc" />

`reset_view_visibility`
这是个大改进。主峰值现在快了约 30us，但主要改进是最坏情况，快了近 500us

<img width="1252" height="398" alt="image" src="https://github.com/user-attachments/assets/f8a9d99f-a6e1-48db-8639-d52276dba9ab" />

`mark_newly_hidden_entities_invisible`
与所有实体都在视图中的 Caldera 比较相同，比主分支的快速模式稍慢，但比主分支的慢速模式快得多

<img width="1248" height="400" alt="image" src="https://github.com/user-attachments/assets/4564d94e-911a-4b3f-a584-c6e102ef2dd0" />

## 这个Pull Request的故事

这个PR起源于对Bevy引擎中可见性系统性能回归的深度调查。在0.17版本之后，开发者发现可见性检查在一些场景中出现了显著性能下降，特别是在Caldera Hotel这样的复杂场景中，有时会浪费1.2ms的宝贵CPU时间，而GPU受限帧的预算只有6.7ms。

问题的核心在于`PreviousVisibleEntities`资源的设计。这个资源使用了`EntityHashSet`来存储前一帧可见的实体，然后在每帧开始时重置所有实体的`ViewVisibility`组件。可见性检查系统会在本帧中标记可见的实体，最后`mark_newly_hidden_entities_invisible`系统会遍历前帧可见但本帧不可见的实体，将它们的状态重置为隐藏。

这种设计存在几个关键问题。首先，哈希操作本身有开销，特别是在实体数量多的情况下。其次，更严重的是，这种设计导致了双峰性能分布——有时系统运行很快，有时却异常缓慢。作者发现这与`EntityHashSet`的内部行为有关，但这种不稳定性是不可接受的。

解决方案的关键洞察是：与其使用外部哈希集存储前帧可见实体，不如直接将状态信息编码到`ViewVisibility`组件中。新的设计将`ViewVisibility`从简单的`bool`包装器改为`u8`类型，利用位操作来存储当前和前一帧的可见状态：

```rust
pub struct ViewVisibility(
    /// 位打包的布尔值，用于跟踪当前和之前的视图可见性状态
    u8,
);
```

具体来说，最低有效位（bit 0）表示当前帧是否可见，第二位（bit 1）表示前一帧是否可见。这种设计有几个优势：避免了哈希操作，减少了内存分配，最重要的是支持了并行处理。

实现上，系统的工作流程重新设计为：

1. **reset_view_visibility**：并行遍历所有实体的`ViewVisibility`组件，将当前可见状态复制到前一帧位置，并清除当前状态
2. **check_visibility**：并行执行可见性检查，通过新的`SetViewVisibility` trait的`set_visible()`方法标记可见实体
3. **mark_newly_hidden_entities_invisible**：并行检查所有实体，将前一帧可见但当前帧不可见的实体标记为隐藏

`SetViewVisibility` trait的实现确保了变更检测只在必要时触发：

```rust
impl<'a> SetViewVisibility for Mut<'a, ViewVisibility> {
    #[inline]
    fn set_visible(&mut self) {
        if !self.as_ref().get() {
            // 将第一位置为true
            self.0 |= 1;
        }
    }
}
```

光照系统也相应更新，移除了对`PreviousVisibleEntities`的依赖，直接使用新的API。这是一个关键的架构改进，因为光源（特别是投射阴影的光源）需要标记不在摄像机视图中但需要渲染的实体。

技术层面上，这个改变解决了几个深层问题。首先，它消除了`EntityHashSet`带来的哈希开销和内存碎片。其次，并行处理现在成为可能，因为每个实体的状态更新是独立的。最后，通过将状态内化到组件中，系统更容易理解和维护。

性能改进是显著的。在Caldera Hotel场景中，`PostUpdate`调度相对于0.17.3版本提升了27%。更令人印象深刻的是，双峰性能分布完全消失，系统现在表现出稳定、可预测的性能。对于已经达到150fps（GPU受限）的场景，节省1.2ms意味着将近18%的CPU时间预算被释放出来。

这个PR也揭示了更广泛的设计原则：当需要跨帧跟踪状态时，将状态内化到组件中通常比使用外部数据结构更高效。这不仅适用于可见性系统，也适用于其他需要历史状态信息的场景。

从工程角度看，这个改变展示了几个重要技术：
1. 位打包用于存储紧凑的跨帧状态
2. trait设计用于封装状态更新逻辑
3. 并行处理通过避免共享可变状态实现
4. 变更检测的最小化触发

值得注意的是，作者没有采用简单的暴力重置所有`ViewVisibility`为false的方法，而是实现了更精细的状态跟踪。这是因为实体可能被多个视图（摄像机、光源等）看到，所以知道实体对某个视图可见是容易的，但知道实体对所有视图都不可见是困难的。通过跟踪前一帧的可见性，系统可以精确地只更新那些真正改变状态的实体。

这个优化对整个渲染管线都有积极影响。可见性系统曾是Bevy应用中最后一个明显慢速的热路径组件，现在它不再在性能分析中突出显示。这为其他系统留下了更多的CPU时间预算，也使引擎在性能受限的设备上表现更好。

## 可视化表示

```mermaid
graph TD
    A[ViewVisibility组件<br/>u8位打包状态] --> B[reset_view_visibility系统<br/>并行更新状态]
    B --> C[check_visibility系统<br/>并行标记可见实体]
    C --> D[mark_newly_hidden_entities_invisible系统<br/>并行清理状态]
    
    E[摄像机] --> C
    F[光源] --> C
    G[SetViewVisibility trait] --> C
    
    C --> H[VisibleEntities<br/>按可见性类分组]
    
    B --> I[性能改进<br/>避免哈希操作]
    C --> I
    D --> I
    
    style A fill:#e1f5fe
    style B