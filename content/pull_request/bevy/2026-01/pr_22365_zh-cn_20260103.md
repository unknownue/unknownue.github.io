+++
title = "#22365 Fix flickering on macOS 26 when tracy is enabled"
date = "2026-01-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22365-en-20260103" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22365-zh-cn-20260103" }}
labels = ["C-Bug", "A-Rendering", "O-MacOS", "A-Accessibility", "S-Needs-Testing"]
+++

# Title: Fix flickering on macOS 26 when tracy is enabled

## Basic Information
- **Title**: Fix flickering on macOS 26 when tracy is enabled
- **PR Link**: https://github.com/bevyengine/bevy/pull/22365
- **Author**: aevyrie
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, O-MacOS, A-Accessibility, S-Needs-Testing
- **Created**: 2026-01-03T20:04:21Z
- **Merged**: 2026-01-03T22:37:03Z
- **Merged By**: mockersf

## Description Translation
**目标**
- 修复使用 tracy 时出现的画面闪烁/频闪问题。
- 关闭 Issue #22257

**解决方案**
- 在 macOS 上，禁用命令编码器 (command encoder) 中的时间戳写入功能。

**测试**
- 使用 `cargo run --example bloom_3d --features=trace_tracy` 命令无法再复现该问题。
- `bevy_bistro_scene` 示例也不再出现闪烁现象。

## The Story of This Pull Request

这个 Pull Request 处理的是一个非常具体且与平台相关的问题：当在 macOS 上启用 `tracy` 性能分析工具时，渲染画面会出现间歇性的闪烁（flickering）或频闪（strobing）。这个问题被记录在 Issue #22257 中，对用户体验和渲染的稳定性有明显的负面影响。

问题的核心在于 `tracy` 如何与 Bevy 的渲染后端（WebGPU）交互以收集 GPU 性能数据。`tracy` 是一个强大的实时性能分析工具，它依赖于精确的时间戳来测量 GPU 命令的执行耗时。在 Bevy 的实现中，这是通过调用 WebGPU 的 `CommandEncoder::write_timestamp` 方法来完成的。这个方法会在 GPU 的命令缓冲区中插入一个特殊的命令，用于记录一个高精度的时间戳到指定的 `QuerySet` 中。

然而，在特定的 macOS 版本（代号 Tahoe）上，当 `write_timestamp` 的调用时机非常接近帧的最终呈现（presentation）时，似乎会干扰底层的图形驱动或 GPU 调度逻辑，导致正在渲染的画面出现不完整的提交或同步问题，从而在屏幕上表现为闪烁。

开发者 `aevyrie` 采取的解决方案是直接且务实的。与其深入挖掘 macOS 图形驱动或 Metal API（WebGPU 在 macOS 的底层实现）中可能存在的、难以定位的底层 bug，不如针对出现问题的特定平台和特定操作（写入时间戳）施加一个运行时规避措施。

具体的实现是在 `WriteTimestamp` trait 针对 `CommandEncoder` 的实现中，添加了一个条件判断。在编译目标为 `macos` 时，这个 `write_timestamp` 函数会提前返回，不再执行任何实际的操作。

```rust
impl WriteTimestamp for CommandEncoder {
    fn write_timestamp(&mut self, query_set: &QuerySet, index: u32) {
        if cfg!(target_os = "macos") {
            // When using tracy (and thus this function), rendering was flickering on macOS Tahoe.
            // See: https://github.com/bevyengine/bevy/issues/22257
            // The issue seems to be triggered when `write_timestamp` is called very close to frame
            // presentation.
            return;
        }
        CommandEncoder::write_timestamp(self, query_set, index);
    }
}
```

这个方法有几个关键点：
1.  **平台特异性 (Platform-specific)**：使用 `cfg!(target_os = "macos")` 编译时属性，确保只有 macOS 平台会激活此规避逻辑，不影响其他操作系统（如 Windows, Linux）上的性能分析功能。
2.  **功能降级 (Graceful Degradation)**：在 macOS 上，这实质上禁用了通过 `write_timestamp` 进行的 GPU 计时功能。对于 `tracy` 用户来说，这意味着他们无法获取 macOS 上精确的 GPU 区间性能数据，但应用程序的核心渲染功能恢复了稳定，不再闪烁。这是一个典型的可用性优先于辅助功能的权衡。
3.  **最小侵入性 (Minimally Invasive)**：这个修改仅存在于诊断和性能分析模块中，对 Bevy 引擎的核心渲染逻辑、ECS（Entity Component System）或其他游戏逻辑完全没有影响。

这个解决方案是有效的，正如测试部分所述，原先能够稳定复现问题的示例程序（如 `bloom_3d` 和 `bevy_bistro_scene`）在应用此补丁后，闪烁现象消失了。这种“规避性修复” (workaround) 在跨平台图形编程中很常见，尤其是在处理不同供应商的驱动或操作系统层级的差异时。

从工程角度看，这个 PR 提供了一个清晰的模式：当遇到一个复杂的、根因可能在第三方驱动或库中的问题时，一个局部的、条件性的规避措施可以作为一种快速且稳定的解决方案。当然，这也留下了未来改进的空间，例如，可以探索是否在某些更新的 macOS 版本或驱动中此问题已被修复，从而有条件地重新启用该功能；或者寻找其他不引发闪烁的 GPU 计时方法。

## Visual Representation

```mermaid
graph TD
    subgraph "Tracy Profiling"
        A[Tracy Client] -->|Requests GPU Timing| B[WriteTimestamp Trait]
    end

    subgraph "Platform Abstraction"
        B --> C{cfg!(target_os = "macos")?}
        C -->|No| D[Call Native write_timestamp]
        C -->|Yes| E[Early Return (Workaround)]
    end

    subgraph "Rendering Backend"
        D --> F[GPU Command Buffer]
        E --> G[No Timestamp Inserted]
    end

    F -->|Timestamp Close to Present| H[Potential Driver Bug: Flickering]
    G -->|No Interference| I[Stable Rendering]
```

## Key Files Changed

### `crates/bevy_render/src/diagnostic/internal.rs` (+7/-0)
1.  **变更描述与原因**：
    此文件是渲染系统内部诊断功能的一部分。新增的代码在 `WriteTimestamp` trait 的实现中添加了一个针对 macOS 平台的防护。其目的是在 macOS 系统上，当检测到正在执行写入时间戳操作（通常由 Tracy 触发）时，直接跳过该操作，以避免触发底层图形驱动的 bug，从而解决渲染画面闪烁的问题。

2.  **关键代码片段**：
    ```rust
    // File: crates/bevy_render/src/diagnostic/internal.rs
    // After (新增的代码块):
    impl WriteTimestamp for CommandEncoder {
        fn write_timestamp(&mut self, query_set: &QuerySet, index: u32) {
            if cfg!(target_os = "macos") {
                // When using tracy (and thus this function), rendering was flickering on macOS Tahoe.
                // See: https://github.com/bevyengine/bevy/issues/22257
                // The issue seems to be triggered when `write_timestamp` is called very close to frame
                // presentation.
                return;
            }
            CommandEncoder::write_timestamp(self, query_set, index);
        }
    }
    ```
    （变更前，`impl` 块内直接调用 `CommandEncoder::write_timestamp(self, query_set, index);`，没有条件判断。）

3.  **与 PR 目标的关联**：
    这是实现整个 PR 解决方案的唯一变更。它直接拦截了导致 macOS 上 Tracy 启用时闪烁问题的特定 API 调用，通过一个平台相关的“短路”逻辑实现了修复。

## Further Reading
1.  **Tracy Profiler**: https://github.com/wolfpld/tracy - 理解此 PR 试图集成的性能分析工具。
2.  **WebGPU `writeTimestamp` API**: https://www.w3.org/TR/webgpu/#dom-gpucommandencoder-writetimestamp - 了解被禁用的底层 WebGPU 方法的功能。
3.  **Rust `cfg!` macro**: https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute - 学习 Rust 中用于条件编译的属性，这是实现平台特异性代码的关键。
4.  **Graphics Driver Workarounds**: 在大型图形引擎（如 Unity， Unreal）的发布说明或代码库中，经常可以看到针对特定 GPU 或驱动版本的“workaround”。这个 PR 是一个小而具体的例子。

# Full Code Diff
```
diff --git a/crates/bevy_render/src/diagnostic/internal.rs b/crates/bevy_render/src/diagnostic/internal.rs
index 2bd360c51bee6..641f5a9efc668 100644
--- a/crates/bevy_render/src/diagnostic/internal.rs
+++ b/crates/bevy_render/src/diagnostic/internal.rs
@@ -643,6 +643,13 @@ pub trait WriteTimestamp {
 
 impl WriteTimestamp for CommandEncoder {
     fn write_timestamp(&mut self, query_set: &QuerySet, index: u32) {
+        if cfg!(target_os = "macos") {
+            // When using tracy (and thus this function), rendering was flickering on macOS Tahoe.
+            // See: https://github.com/bevyengine/bevy/issues/22257
+            // The issue seems to be triggered when `write_timestamp` is called very close to frame
+            // presentation.
+            return;
+        }
         CommandEncoder::write_timestamp(self, query_set, index);
     }
 }
```