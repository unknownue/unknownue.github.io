+++
title = "#22290 fix: add unwind safety to `resource_scope"
date = "2026-01-06T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22290-en-20260106" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22290-zh-cn-20260106" }}
+++

# Title

## 基本信息
- **标题**: fix: add unwind safety to `resource_scope`
- **PR链接**: https://github.com/bevyengine/bevy/pull/22290
- **作者**: joseph-gio
- **状态**: 已合并
- **标签**: C-Bug, A-ECS, S-Ready-For-Final-Review, D-Complex, X-Uncontroversial
- **创建时间**: 2025-12-28T01:28:50Z
- **合并时间**: 2026-01-05T23:43:56Z
- **合并者**: alice-i-cecile

## 描述翻译

# 目标

`World::resource_scope` 函数是一个基础原语，允许用户同时获取对资源和对世界其他部分的可变访问权限。这对于排他系统（exclusive systems）、`Command` 的实现和自定义抽象非常有用。它的工作原理是临时从世界中移除资源，然后使用户提供的闭包可以同时对两者进行可变访问。闭包完成后，资源被重新插入到世界中供其他代码使用。

在当前实现中，用户提供的闭包中发生的任何恐慌（panic）都会导致资源丢失。这有几个问题：
* 任何希望使用 `std::panic::catch_unwind` 的用户都必须处理恐慌导致世界处于无效状态的问题。
  * 虽然有些人认为 catch_unwind 是不良实践，但它是 Rust 的原生功能，我们应该提供支持。在某些情况下它很有价值：
    * 当创建面向生产环境的应用程序时，避免用户程序硬崩溃至关重要，而且在许多情况下，确保每个代码路径总是成功完成是不合理的。catch_unwind 对于捕获恐慌并切换到受控错误状态很有用。当世界处于无效状态时，这很难做到。
    * 将恐慌局部化（localize）通常很有用，而不是完全从中恢复。当使用线程或异步任务时，通常的默认做法是将恐慌局部化到引起它们的原始上下文。当实现允许异步任务访问世界的抽象时，捕获恐慌并将其传播回异步上下文很有用。
* 在 `resource_scope` 内部发生的恐慌可能导致连锁错误，这可能使调试更加困难，因为用户可能需要筛选许多错误才能确定哪个是根本原因。

这里的目标是使 resource_scope 具有恐慌安全性（panic-safe），确保从恐慌展开时资源总是被恢复到世界中（在支持展开的平台上；`panic=abort` 在设计上是不可恢复的）。这使得恐慌处理更加健壮，并允许在恐慌真正致命时实现更优雅的关闭序列。

## 解决方案

添加一个"守卫"（guard）类型，它捕获对世界的可变访问和资源的临时所有权。该类型有一个 `Drop` 实现，负责在作用域结束时重新插入资源——这种模式类似于许多语言中的 `try ... finally` 块。

## 测试

* 添加了一个测试，验证从 `resource_scope` 展开时资源是否正确恢复。
* 为现有的由 `World::clear_resources` 或 `World::clear_all` 触发的边缘情况添加了回归测试。

## 本次PR的技术分析

这个PR解决了一个关于`World::resource_scope`函数恐慌安全性的重要问题。在分析实现之前，我们需要理解这个函数的核心作用：它允许开发者临时从ECS世界中移除一个资源，在闭包中同时操作这个资源和世界的其他部分，然后在闭包结束后将资源重新插入世界。

### 问题本质

原来的实现有一个严重缺陷：当闭包中发生恐慌时，资源的重新插入逻辑永远不会执行。这是因为恐慌会立即开始栈展开，跳过后面的重新插入代码。结果是资源从世界中永久丢失，导致世界处于不一致的状态。

这个问题对多种使用场景都有影响：
1. 使用`catch_unwind`进行错误恢复的应用程序无法正常工作
2. 恐慌会导致连锁错误，使调试更加困难
3. 任何依赖资源存在的后续系统都会失败

### 解决方案的技术实现

开发者采用了一个经典的Rust模式：使用守卫类型（guard type）通过`Drop`特性确保清理逻辑总会执行。这个模式的核心思想是，无论闭包正常返回还是恐慌退出，守卫的`drop`方法都会执行，从而保证资源被重新插入。

让我们看看关键的实现细节。在修改后的`resource_scope`函数中：

```rust
// 类型用于管理在作用域结束时重新插入资源。使用drop实现意味着即使用户提供的闭包展开，资源也会被插入。
// 这有助于局部恐慌恢复，并通过避免连锁错误使应用程序在响应恐慌时的关闭更加优雅。
struct ReinsertGuard<'a, R> {
    world: &'a mut World,
    component_id: ComponentId,
    value: ManuallyDrop<R>,
    ticks: ComponentTicks,
    caller: MaybeLocation,
    was_successful: &'a mut bool,
}
```

守卫结构体包含了重新插入资源所需的所有信息：
- `world`: 对世界的可变引用
- `component_id`: 资源类型标识符
- `value`: 资源值本身，使用`ManuallyDrop`包装以控制析构时机
- `ticks`和`caller`: 变更跟踪所需的数据
- `was_successful`: 标记是否成功重新插入的布尔标志

守卫的`Drop`实现是这个解决方案的核心：

```rust
impl<R> Drop for ReinsertGuard<'_, R> {
    fn drop(&mut self) {
        // 首先获取值的所有权，这样如果提前返回，它会被丢弃
        // 安全性：drop语义确保在此调用后永远不会再次访问`self.value`
        let value = unsafe { ManuallyDrop::take(&mut self.value) };

        let Some(resource_data) = self.world.storages.resources.get_mut(self.component_id)
        else {
            return;
        };

        // 在调试模式下，如果用户代码在此作用域内重新插入了此类型的资源，则引发恐慌。
        // 资源插入通常表示用户代码存在逻辑错误，在开发时捕获很有用，
        // 但它本质上不会导致状态损坏，因此我们避免为生产构建引入不必要的崩溃。
        if resource_data.is_present() {
            #[cfg(debug_assertions)]
            {
                // 如果已经在恐慌中，记录错误而不是恐慌，因为双重恐慌会导致中止
                #[cfg(feature = "std")]
                if std::thread::panicking() {
                    log::error!("Resource `{}` was inserted during a call to World::resource_scope, which may result in unexpected behavior.\n\
                           In release builds, the value inserted will be overwritten at the end of the scope.",
                           DebugName::type_name::<R>());
                    // 提前返回以在调试构建中保持与非恐慌调用一致的行为
                    return;
                }

                panic!("Resource `{}` was inserted during a call to World::resource_scope, which may result in unexpected behavior.\n\
                       In release builds, the value inserted will be overwritten at the end of the scope.",
                       DebugName::type_name::<R>());
            }
            #[cfg(not(debug_assertions))]
            {
                #[cold]
                #[inline(never)]
                fn warn_reinsert(resource_name: &str) {
                    warn!(
                        "Resource `{resource_name}` was inserted during a call to World::resource_scope: the inserted value will be overwritten.",
                    );
                }

                warn_reinsert(&DebugName::type_name::<R>());
            }
        }

        OwningPtr::make(value, |ptr| {
            // 安全性：ptr的类型为`R`，与用于检索资源数据的组件ID对应。
            unsafe {
                resource_data.insert_with_ticks(ptr, self.ticks, self.caller);
            }
        });

        *self.was_successful = true;
    }
}
```

这个`Drop`实现有几个值得注意的技术细节：

1. **安全处理双重恐慌**：使用`std::thread::panicking()`检查是否已经在恐慌状态，避免双重恐慌导致程序中止。

2. **调试与发布构建的不同行为**：
   - 调试构建：如果用户代码在作用域内重新插入资源，会触发恐慌（除非已经在恐慌中，这时记录错误）
   - 发布构建：只记录警告，然后覆盖用户插入的值

3. **使用`ManuallyDrop`的原因**：资源需要在守卫的`drop`方法中手动处理。使用`ManuallyDrop`确保我们可以控制何时以及如何丢弃或重新插入资源值。

### 性能考量

PR描述中提到一个重要的性能决策：为什么使用`was_successful`标志而不是在正常路径中调用单独的`guard.apply()`方法。开发者解释说，虽然替代方案可能更直观，但它需要为恐慌和正常控制流维护两条代码路径，这会产生次优的代码生成。由于`resource_scope`在引擎和用户代码中被广泛使用，这个微小的性能开销是值得的。

### 测试验证

PR添加了两个重要的测试：

1. `resource_scope_unwind`：验证恐慌时资源是否正确恢复
2. `resource_scope_resources_cleared`：验证当在作用域内调用`world.clear_resources()`时的现有行为（这是一个边缘情况）

第一个测试特别重要，因为它直接验证了恐慌安全性的核心功能：

```rust
#[cfg(feature = "std")]
#[test]
fn resource_scope_unwind() {
    #[derive(Debug, PartialEq)]
    struct Panic;

    let mut world = World::default();
    assert!(world.try_resource_scope::<ResA, _>(|_, _| {}).is_none());
    world.insert_resource(ResA(0));
    let panic = std::panic::catch_unwind(core::panic::AssertUnwindSafe(|| {
        world.resource_scope(|world: &mut World, _value: Mut<ResA>| {
            assert!(!world.contains_resource::<ResA>());
            std::panic::panic_any(Panic);
        });
        unreachable!();
    }));
    assert_eq!(panic.unwrap_err().downcast_ref::<Panic>(), Some(&Panic));
    assert!(world.contains_resource::<ResA>());
}
```

这个测试创建了一个恐慌，捕获它，然后验证资源是否仍然存在于世界中。

### 技术影响

这个修复使得`resource_scope`在支持展开的平台上是恐慌安全的。这意味着：

1. 开发者可以安全地使用`catch_unwind`来从恐慌中恢复，而不必担心世界状态被破坏
2. 恐慌被更好地局部化，减少了连锁错误的可能性
3. 生产环境应用程序可以实现更优雅的错误处理和关闭序列

这个修复也展示了Rust中一个重要的模式：使用`Drop`实现来确保资源清理，无论控制流如何退出。这是Rust中实现类似`try-finally`行为的惯用方式。

## 组件关系图

```mermaid
graph TD
    A[World::resource_scope] --> B[创建ReinsertGuard]
    B --> C[执行用户闭包]
    C --> D{闭包正常完成?}
    D -->|是| E[守卫drop: 重新插入资源]
    D -->|否(恐慌)| E
    E --> F[返回结果或None]
    
    G[用户代码] --> C
    H[恐慌处理] --> E
```

## 关键文件变更

### `crates/bevy_ecs/src/world/mod.rs` (+104/-30)

这个文件包含了主要的功能实现变更。`resource_scope`方法被完全重写以使用新的`ReinsertGuard`结构。

**关键变更示例：**

```rust
// 重构后的resource_scope方法核心部分
let mut was_successful = false;
let result = {
    let mut guard = ReinsertGuard {
        world: self,
        component_id,
        value: ManuallyDrop::new(value),
        ticks,
        caller,
        was_successful: &mut was_successful,
    };

    let value_mut = Mut {
        value: &mut *guard.value,
        ticks: ComponentTicksMut {
            added: &mut guard.ticks.added,
            changed: &mut guard.ticks.changed,
            changed_by: guard.caller.as_mut(),
            last_run: last_change_tick,
            this_run: change_tick,
        },
    };

    f(guard.world, value_mut)

    // guard的drop实现在这里运行
};

was_successful.then_some(result)
```

### `crates/bevy_ecs/src/lib.rs` (+35/-0)

这个文件添加了测试用例来验证恐慌安全性和边缘情况。

**新增的测试：**

```rust
#[cfg(feature = "std")]
#[test]
fn resource_scope_unwind() {
    // ... 测试恐慌安全性
}

#[test]
fn resource_scope_resources_cleared() {
    // ... 测试清除资源时的边缘情况
}
```

## 扩展阅读

- [Rust的恐慌安全（Unwind Safety）](https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html)
- [Rust的Drop特性](https://doc.rust-lang.org/std/ops/trait.Drop.html)
- [ManuallyDrop的文档](https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html)
- [Bevy ECS资源系统](https://bevyengine.org/learn/quick-start/resource/)
- [RAII（Resource Acquisition Is Initialization）模式](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)