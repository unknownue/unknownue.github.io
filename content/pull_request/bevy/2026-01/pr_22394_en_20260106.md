+++
title = "#22394 Text pipeline update buffer spans refactor"
date = "2026-01-06T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22394-en-20260106" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22394-zh-cn-20260106" }}
labels = ["C-Code-Quality", "A-Text", "D-Straightforward"]
+++

# Text pipeline update buffer spans refactor

## Basic Information
- **Title**: Text pipeline update buffer spans refactor
- **PR Link**: https://github.com/bevyengine/bevy/pull/22394
- **Author**: ickshonpe
- **Status**: MERGED
- **Labels**: C-Code-Quality, S-Ready-For-Final-Review, A-Text, D-Straightforward
- **Created**: 2026-01-05T20:17:36Z
- **Merged**: 2026-01-06T20:14:00Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

`TextPipeline::update_buffer` uses a trick to cache the spans buffer's capacity.
It's awkwardly implemented though, with the buffer recovery code repeated twice.

## Solution

Rework the function to remove the duplication of the spans buffer recovery code.

## The Story of This Pull Request

This pull request addresses a code quality issue in Bevy's text rendering system, specifically in the `TextPipeline::update_buffer` method. The problem centered around an optimization technique that was correctly implemented but had redundant code that made maintenance more difficult than necessary.

The `update_buffer` method processes text spans for rendering using the cosmic-text library. It maintains a buffer called `spans_buffer` that stores span information between calls. To avoid unnecessary allocations, the implementation uses a capacity-preserving trick: after processing spans, it clears the buffer but maintains its allocated capacity by replacing it with a vector of dummy values. This optimization is sound, but the implementation had a structural flaw.

The original code handled buffer recovery in two separate places. When a font wasn't found during processing, it would clear and recover the buffer before returning an error. When processing completed successfully, it would perform the same buffer recovery operation at the end of the function. This duplication created maintenance risk because any change to the buffer recovery logic would need to be made in two places.

The solution refactors the method to eliminate this duplication. The key insight was to wrap the main processing logic in a block that returns a `Result`, then handle buffer recovery once after that block completes, regardless of whether it succeeded or failed. This approach uses Rust's error propagation mechanism to handle the early return case cleanly.

Here's how the refactoring works technically. The original early error return looked like this:

```rust
if let Some(font) = fonts.get(handle.id()) {
    // process font
} else {
    // Return early if a font is not loaded yet.
    spans.clear();
    self.spans_buffer = spans
        .into_iter()
        .map(
            |_| -> (
                usize,
                &'static str,
                &'static TextFont,
                FontFaceInfo,
                LineHeight,
            ) { unreachable!() },
        )
        .collect();
    return Err(TextError::NoSuchFont);
}
```

The refactored version simplifies this to:

```rust
let font = fonts.get(handle.id()).ok_or(TextError::NoSuchFont)?;
```

The `?` operator propagates the error, but now the error occurs inside a block whose result is captured. After the block completes (whether with success or error), the buffer recovery code runs exactly once:

```rust
// Recover the spans buffer.
spans.clear();
self.spans_buffer = spans
    .into_iter()
    .map(
        |_| -> (
            usize,
            &'static str,
            &'static TextFont,
            FontFaceInfo,
            LineHeight,
        ) { unreachable!() },
    )
    .collect();

result
```

This pattern ensures that the buffer recovery logic has a single source of truth while preserving the optimization of maintaining buffer capacity between calls. The refactoring reduces the line count from 93 to 80 (a net reduction of 13 lines) while making the code more maintainable.

The changes don't affect functionality or performance—they're purely structural improvements. The buffer capacity optimization remains intact, and all text rendering behavior stays the same. This is a classic example of refactoring for maintainability: identifying duplicated logic, extracting it to a single location, and simplifying control flow.

From an engineering perspective, this refactoring demonstrates good use of Rust's error handling patterns. The `?` operator allows for clean error propagation without nested conditionals, and wrapping the main logic in a block provides a clear boundary for when the buffer recovery should occur. This approach could be applied to similar patterns in other parts of the codebase where cleanup or recovery logic needs to run regardless of success or failure.

## Visual Representation

```mermaid
graph TD
    A[update_buffer function] --> B[Original: Duplicate buffer recovery]
    B --> C[Case 1: Early error return]
    B --> D[Case 2: Success completion]
    
    A --> E[Refactored: Single buffer recovery]
    E --> F[Processing block]
    F --> G[Success: Ok(())]
    F --> H[Error: Err(TextError)]
    G --> I[Recover buffer once]
    H --> I
    I --> J[Return result]
```

## Key Files Changed

### `crates/bevy_text/src/pipeline.rs` (+80/-93)

This file contains the `TextPipeline` implementation, which handles text layout and rendering using the cosmic-text library. The changes focus on the `update_buffer` method, which processes text spans and prepares them for rendering.

The key modification reorganizes the method to eliminate duplicated buffer recovery code. Before the change, the method had two separate sections that handled clearing and preserving the capacity of the `spans_buffer`. After the change, this logic appears only once at the end of the method.

**Key code changes:**

```rust
// Before: Error handling with duplicated buffer recovery
if let Some(font) = fonts.get(handle.id()) {
    // process font
} else {
    // Return early if a font is not loaded yet.
    spans.clear();
    self.spans_buffer = spans
        .into_iter()
        .map(
            |_| -> (
                usize,
                &'static str,
                &'static TextFont,
                FontFaceInfo,
                LineHeight,
            ) { unreachable!() },
        )
        .collect();
    return Err(TextError::NoSuchFont);
}

// ... later in the function ...

// Buffer recovery code duplicated here for successful completion
spans.clear();
self.spans_buffer = spans
    .into_iter()
    .map(
        |_| -> (
            usize,
            &'static str,
            &'static TextFont,
            FontFaceInfo,
            LineHeight,
        ) { unreachable!() },
    )
    .collect();

Ok(())
```

```rust
// After: Single buffer recovery point
let result = {
    // All processing logic, including error propagation with ?
    let font = fonts.get(handle.id()).ok_or(TextError::NoSuchFont)?;
    // ... rest of processing
    Ok(())
};

// Buffer recovery happens once, regardless of success or error
spans.clear();
self.spans_buffer = spans
    .into_iter()
    .map(
        |_| -> (
            usize,
            &'static str,
            &'static TextFont,
            FontFaceInfo,
            LineHeight,
        ) { unreachable!() },
    )
    .collect();

result
```

The refactoring wraps the core processing logic in a block that captures its result, then performs buffer recovery once after the block completes. This ensures the recovery code runs whether the block succeeds or returns early due to an error.

## Further Reading

1. **Rust Error Handling**: The Rust Book's chapter on error handling (https://doc.rust-lang.org/book/ch09-00-error-handling.html) explains the `Result` type and the `?` operator used in this refactoring.

2. **cosmic-text**: The text layout library used by Bevy (https://github.com/pop-os/cosmic-text). Understanding this library helps contextualize the span processing in the `update_buffer` method.

3. **Code Refactoring Patterns**: Martin Fowler's "Refactoring: Improving the Design of Existing Code" covers common patterns for improving code structure, including eliminating duplicate code.

4. **Bevy Text Rendering**: The Bevy engine's documentation on text rendering (https://bevy-cheatbook.github.io/features/text.html) provides context for how text rendering works in the engine.

5. **RAII and Cleanup Patterns**: While Rust uses RAII (Resource Acquisition Is Initialization) for most cleanup, this PR shows an alternative pattern for cases where cleanup must happen regardless of success or failure paths.