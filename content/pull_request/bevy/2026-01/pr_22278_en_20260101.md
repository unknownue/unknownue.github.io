+++
title = "#22278 `AutoNavigationConfig::max_search_distance` fix"
date = "2026-01-01T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22278-en-20260101" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22278-zh-cn-20260101" }}
labels = ["C-Bug", "A-UI", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: `AutoNavigationConfig::max_search_distance` fix
- **PR Link**: https://github.com/bevyengine/bevy/pull/22278
- **Author**: ickshonpe
- **Status**: MERGED
- **Labels**: C-Bug, A-UI, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2025-12-26T16:00:54Z
- **Merged**: 2025-12-31T23:18:03Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

Automatic directional navigation ignores scale factor.

Fixes #22277

## Solution

Multiply the size and translation of each `FocusableArea` by the inverse scale factor.

## The Story of This Pull Request

This pull request addresses a specific bug in Bevy's UI navigation system where automatic directional navigation wasn't accounting for UI scale factor. The issue manifests when UI elements are scaled, causing navigation calculations to use incorrect coordinates and potentially fail to find adjacent focusable elements.

The core problem was in the directional navigation algorithm's distance calculations. When determining which UI element should receive focus next when using keyboard navigation (arrow keys), the system calculates distances between the current focused element and candidate elements. These calculations were using world-space coordinates directly without considering any scaling applied to UI nodes.

The fix is mathematically straightforward: multiply both the position and size of each focusable area by the inverse scale factor. This transformation converts the coordinates from scaled space back to the original logical space where the navigation algorithm's distance calculations work correctly. The inverse scale factor is used because if a UI element is scaled up by a factor of 2, its world-space coordinates and dimensions are twice as large, so we need to divide by 2 (multiply by 1/2) to get back to the logical coordinates.

The implementation affects only two code blocks in the same function where `FocusableArea` structs are created. In both cases, the same pattern is applied: multiply the `translation` (position) and the computed `size()` by `computed.inverse_scale_factor()`. This ensures that regardless of whether the node has a target camera or not, the focusable area coordinates are consistently adjusted.

This fix is minimal and targeted, affecting only the specific calculation that was broken. It doesn't change the overall architecture of the navigation system or introduce any new abstractions. The solution preserves the existing algorithm while correcting the coordinate space transformation.

One important consideration is performance: multiplying by the inverse scale factor adds minimal overhead since it's just a scalar multiplication of vectors. The `inverse_scale_factor()` method is already available on `ComputedUiRect`, so there's no additional computation cost for obtaining the scale factor itself.

The fix ensures that UI navigation works correctly across different display scales and zoom levels, which is particularly important for accessibility features and for games with configurable UI scaling. Without this fix, users with high DPI displays or scaled UI might experience broken navigation between UI elements.

## Visual Representation

```mermaid
graph LR
    A[UI Node with Scale] --> B[ComputedUiRect]
    B --> C[FocusableArea Creation]
    C --> D{Apply Inverse Scale?}
    D -->|Before Fix| E[Incorrect Navigation]
    D -->|After Fix| F[Correct Navigation]
    
    subgraph "Fix Applied"
        G[translation * inverse_scale_factor()]
        H[size * inverse_scale_factor()]
    end
```

## Key Files Changed

### `crates/bevy_input_focus/src/directional_navigation.rs` (+4/-4)

This file contains the directional navigation system implementation. The changes fix a bug where automatic directional navigation calculations didn't account for UI scale factor, causing incorrect focus navigation when UI elements were scaled.

**Key modifications:**
```rust
// Before (line 499-500):
position: translation,
size: computed.size(),

// After:
position: translation * computed.inverse_scale_factor(),
size: computed.size() * computed.inverse_scale_factor(),
```

```rust
// Before (line 528-529):
position: translation,
size: computed.size(),

// After:
position: translation * computed.inverse_scale_factor(),
size: computed.size() * computed.inverse_scale_factor(),
```

The fix is applied in two locations where `FocusableArea` structs are instantiated. Both instances follow the same pattern: multiply the position and size by the inverse scale factor to convert from scaled world coordinates back to logical coordinates for navigation calculations.

## Further Reading

1. **Bevy UI System Documentation**: For understanding how Bevy handles UI scaling and transformations
2. **Affine Transformations in Computer Graphics**: To understand coordinate space transformations including scaling
3. **UI Navigation Systems**: For broader context on focus management in game UIs
4. **Issue #22277**: The original bug report that this PR fixes

# Full Code Diff
diff --git a/crates/bevy_input_focus/src/directional_navigation.rs b/crates/bevy_input_focus/src/directional_navigation.rs
index 79dc20680084a..bc1bd91d14bd4 100644
--- a/crates/bevy_input_focus/src/directional_navigation.rs
+++ b/crates/bevy_input_focus/src/directional_navigation.rs
@@ -496,8 +496,8 @@ impl<'w, 's> DirectionalNavigation<'w, 's> {
                             transform.to_scale_angle_translation();
                         Some(FocusableArea {
                             entity,
-                            position: translation,
-                            size: computed.size(),
+                            position: translation * computed.inverse_scale_factor(),
+                            size: computed.size() * computed.inverse_scale_factor(),
                         })
                     } else {
                         // The node either does not have a target camera or it is not the same as the desired one.
@@ -525,8 +525,8 @@ impl<'w, 's> DirectionalNavigation<'w, 's> {
                         target_camera,
                         FocusableArea {
                             entity,
-                            position: translation,
-                            size: computed.size(),
+                            position: translation * computed.inverse_scale_factor(),
+                            size: computed.size() * computed.inverse_scale_factor(),
                         },
                     ))
                 } else {