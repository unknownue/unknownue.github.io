+++
title = "#22423 Allow reading the individual accesses of a `FilteredAccessSet`."
date = "2026-01-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22423-en-20260108" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22423-zh-cn-20260108" }}
labels = ["C-Feature", "D-Trivial", "A-ECS"]
+++

# Title

## Basic Information
- **Title**: Allow reading the individual accesses of a `FilteredAccessSet`.
- **PR Link**: https://github.com/bevyengine/bevy/pull/22423
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: C-Feature, D-Trivial, A-ECS, S-Ready-For-Final-Review
- **Created**: 2026-01-08T08:23:16Z
- **Merged**: 2026-01-08T09:19:06Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

- A `FilteredAccessSet` doesn't give access to the individual filters. This is sad for introspecting the access of systems (e.g., for visualizing systems in a schedule).

## Solution

- Add a getter for `filtered_accesses`.

# The Story of This Pull Request

The PR addresses a straightforward but important need in the Bevy ECS (Entity Component System) for better introspection capabilities. When developers work with Bevy's scheduling system, they often need to understand what components systems access and how they interact. This is particularly important for debugging performance issues, understanding system dependencies, and building visualization tools for schedules.

Before this change, the `FilteredAccessSet` struct provided access to the combined access information through the `combined_access()` method, but did not expose the individual `FilteredAccess` entries that make up the set. This limitation made it difficult to analyze system behavior at a granular level. For example, when building schedule visualization tools or debugging system conflicts, developers couldn't easily see which specific components each system was accessing with what filters.

The solution implemented is minimal and focused. A single getter method was added to the `FilteredAccessSet` implementation that returns a reference to the underlying vector of `FilteredAccess` objects. This approach follows Rust's borrowing patterns correctly - it returns an immutable reference (`&[FilteredAccess]`) rather than exposing the internal vector directly, maintaining encapsulation while providing the necessary access.

The method is marked with `#[inline]`, which is a reasonable optimization for a simple getter that just returns a reference to a field. This allows the compiler to potentially eliminate the function call overhead in release builds.

The implementation doesn't change any existing behavior or add new functionality beyond the getter. It simply makes existing internal data accessible for introspection purposes. This is a classic example of the "make internal state observable" pattern - keeping the core logic unchanged but adding observability for debugging and tooling.

From an architectural perspective, this change aligns with Bevy's growing ecosystem of development tools. As Bevy matures, having better introspection capabilities becomes increasingly important for both engine developers and users building complex applications. The ability to inspect `FilteredAccess` entries directly enables better debugging tools, performance analyzers, and schedule visualizers.

The change is backward compatible - existing code continues to work unchanged, and the new method provides additional functionality without breaking any APIs. The simplicity of the change (adding a single getter method) means there's minimal maintenance overhead and no performance impact on existing code paths.

## Visual Representation

```mermaid
graph TD
    A[FilteredAccessSet] --> B[combined_access: &CombinedAccess]
    A --> C[filtered_accesses: &[FilteredAccess]]
    C --> D[Individual FilteredAccess objects]
    D --> E[Component access patterns]
    D --> F[Filter conditions]
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
```

## Key Files Changed

**crates/bevy_ecs/src/query/access.rs** (+6/-0)

This file contains the implementation of access tracking for Bevy's ECS queries. The change adds a single public method to expose the internal `filtered_accesses` vector.

**Before the change:**
The `FilteredAccessSet` struct had methods to access the combined access information, but no way to inspect individual filtered accesses.

**After the change:**
```rust
/// Returns a reference to the filtered accesses of the set.
#[inline]
pub fn filtered_accesses(&self) -> &[FilteredAccess] {
    &self.filtered_accesses
}
```

This method provides read-only access to the vector of `FilteredAccess` objects. Each `FilteredAccess` contains information about which components are accessed and any filter conditions applied. The method signature returns a slice reference (`&[FilteredAccess]`), which is appropriate for a getter that doesn't need to transfer ownership.

The placement of this method in the code is logical - it's added right after the existing `combined_access()` getter, keeping related methods together. The documentation comment clearly states what the method returns, and the `#[inline]` attribute suggests the method is simple enough to be inlined by the compiler.

## Further Reading

1. **Bevy ECS Documentation**: The official Bevy ECS documentation provides comprehensive information about the entity component system architecture, queries, and access patterns.

2. **Rust Borrowing and References**: Understanding Rust's ownership model and borrowing rules is essential for working with getter methods that return references.

3. **Introspection in Game Engines**: Articles and talks about debugging and profiling game engines often discuss the importance of introspection capabilities for development tools.

4. **Bevy Schedule Visualization**: Community tools and projects that visualize Bevy schedules can benefit from this change to provide more detailed information about system dependencies.

5. **API Design Patterns**: Resources on API design, particularly around exposing internal state for debugging while maintaining encapsulation.