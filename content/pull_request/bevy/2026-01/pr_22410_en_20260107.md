+++
title = "#22410 Update `Combine` trait example to use `unwrap_or(false)`"
date = "2026-01-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22410-en-20260107" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22410-zh-cn-20260107" }}
labels = ["C-Docs", "D-Trivial", "A-ECS"]
+++

# Title
Update `Combine` trait example to use `unwrap_or(false)`

## Basic Information
- **Title**: Update `Combine` trait example to use `unwrap_or(false)`
- **PR Link**: https://github.com/bevyengine/bevy/pull/22410
- **Author**: WaterWhisperer
- **Status**: MERGED
- **Labels**: C-Docs, D-Trivial, A-ECS, S-Ready-For-Final-Review
- **Created**: 2026-01-07T05:33:42Z
- **Merged**: 2026-01-07T06:19:42Z
- **Merged By**: alice-i-cecile

## Description Translation
The PR description is already in English, so it's included as-is:

# Objective

- Fixes #22363 

## Solution

- Replace `Ok(a((), data)? ^ b((), data)?)` with `Ok(a((), data).unwrap_or(false) ^ b((), data).unwrap_or(false))`

## Testing

- Doc test

## The Story of This Pull Request

This PR addresses a documentation issue in the Bevy game engine's ECS (Entity Component System) module. The problem was relatively straightforward but highlights an important aspect of Rust error handling in the context of Bevy's system combinators.

The issue originated in the `Combine` trait documentation within `combinator.rs`. The trait is part of Bevy's ECS framework and provides a way to combine multiple systems. In this specific example, the documentation showed how to combine two systems that return `Result<bool, RunSystemError>`. The original code attempted to use the `?` operator to propagate errors, but this approach didn't compile because of type inference issues with the XOR operation.

The core problem was that the `?` operator returns early when it encounters an error, which doesn't work well in this context where we want to combine boolean results even when individual systems might fail. The original code would have compiled if we were just returning the boolean values directly, but the `^` (XOR) operator expects boolean operands, and the `?` operator yields a `bool` only when the result is `Ok`. When there's an error, the function returns early, so the XOR operation never happens in that case.

The solution replaces the `?` operator with `.unwrap_or(false)`. This change has two important effects:

1. It ensures the code compiles by providing concrete boolean values to the XOR operator
2. It defines explicit error handling behavior: when a system returns an error, it's treated as `false` for the purpose of the combination

This approach is more appropriate for this example because it demonstrates a practical way to handle errors in system combinations. Using `.unwrap_or(false)` means that when a system fails, we treat it as returning `false` and continue with the combination logic, rather than aborting the entire operation.

The change is minimal but significant because documentation examples serve as templates for developers. By showing `unwrap_or(false)` instead of `?`, the example now provides a working pattern for combining systems that might fail, while also being explicit about error handling. This is particularly important in game development contexts where you might want to continue execution with default values even when some systems encounter recoverable errors.

From an engineering perspective, this change demonstrates the trade-off between error propagation and fault tolerance. The `?` operator is great for propagating errors up the call stack when you want to abort on failure. However, in a combinator context where you're merging results from multiple systems, you often want to handle errors locally and continue with some default behavior. The `unwrap_or()` pattern provides that flexibility while maintaining type safety.

## Visual Representation

```mermaid
graph TD
    A[Combine Trait Example] --> B[System A returns Result<bool, RunSystemError>]
    A --> C[System B returns Result<bool, RunSystemError>]
    B --> D[Original: a((), data)?]
    C --> E[Original: b((), data)?]
    D --> F[XOR Operation]
    E --> F
    F --> G[Compilation Error]
    
    B --> H[Fixed: a((), data).unwrap_or(false)]
    C --> I[Fixed: b((), data).unwrap_or(false)]
    H --> J[XOR Operation]
    I --> J
    J --> K[Successful Compilation]
    J --> L[Error Handling: Errors treated as false]
```

## Key Files Changed

**File:** `crates/bevy_ecs/src/system/combinator.rs`

**Change Description:** Updated the documentation example for the `Combine` trait to use `unwrap_or(false)` instead of the `?` operator. This fixes a compilation error and provides more explicit error handling in the example.

**Code Change:**

```rust
// File: crates/bevy_ecs/src/system/combinator.rs
// Before:
use super::{IntoSystem, ReadOnlySystem, RunSystemError, System};

/// Combine two systems that return `Result<bool, RunSystemError>` using XOR.
///
/// # Examples
///
/// ```
/// # use bevy_ecs::system::{RunSystemError, Combine};
/// #
/// impl Combine<Self> for bool {
///     type In = ();
///     type Out = bool;
/// 
///     fn combine(
///         a: impl FnOnce(A::In, &mut T) -> Result<A::Out, RunSystemError>,
///         b: impl FnOnce(B::In, &mut T) -> Result<B::Out, RunSystemError>,
///     ) -> Result<Self::Out, RunSystemError> {
///         Ok(a((), data)? ^ b((), data)?)
///     }
/// }
/// ```

// After:
use super::{IntoSystem, ReadOnlySystem, RunSystemError, System};

/// Combine two systems that return `Result<bool, RunSystemError>` using XOR.
///
/// # Examples
///
/// ```
/// # use bevy_ecs::system::{RunSystemError, Combine};
/// #
/// impl Combine<Self> for bool {
///     type In = ();
///     type Out = bool;
/// 
///     fn combine(
///         a: impl FnOnce(A::In, &mut T) -> Result<A::Out, RunSystemError>,
///         b: impl FnOnce(B::In, &mut T) -> Result<B::Out, RunSystemError>,
///     ) -> Result<Self::Out, RunSystemError> {
///         Ok(a((), data).unwrap_or(false) ^ b((), data).unwrap_or(false))
///     }
/// }
/// ```

**How this relates to the overall purpose:** This change fixes issue #22363 by correcting a documentation example that didn't compile. The fix demonstrates proper error handling in system combinations and provides developers with a working pattern to follow.

## Further Reading

1. **Rust Error Handling:** The Rust Book's chapter on error handling provides foundational knowledge about `Result`, `?` operator, and `unwrap_or()`: https://doc.rust-lang.org/book/ch09-00-error-handling.html

2. **Bevy ECS System Combinators:** Bevy's documentation on system combinators explains how to combine multiple systems: https://bevyengine.org/learn/book/next/ecs/system-combinators/

3. **Rust's `Option` and `Result` Types:** Understanding the difference between `unwrap()`, `expect()`, `unwrap_or()`, and `?` operator is crucial for effective Rust programming.

4. **Bevy GitHub Issues:** The original issue #22363 that this PR fixes provides additional context about the problem and discussion around the solution.