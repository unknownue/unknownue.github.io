+++
title = "#22339 fix testbeds with argh in wasm"
date = "2026-01-01T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22339-en-20260101" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22339-zh-cn-20260101" }}
labels = ["C-Examples", "O-Web"]
+++

# Title

## Basic Information
- **Title**: fix testbeds with argh in wasm
- **PR Link**: https://github.com/bevyengine/bevy/pull/22339
- **Author**: mockersf
- **Status**: MERGED
- **Labels**: C-Examples, O-Web
- **Created**: 2026-01-01T17:48:22Z
- **Merged**: 2026-01-01T20:12:08Z
- **Merged By**: mockersf

## Description Translation
### 目标
- #22223 在 testbed 示例中使用了 argh
- 这在 wasm 中可以编译，但运行时会崩溃

### 解决方案
- 像其他使用 argh 的示例一样修复它

## The Story of This Pull Request

这个 PR 讲述了一个典型的跨平台兼容性修复的故事。问题始于之前的 PR #22223，它在 testbed（测试平台）示例中引入了 `argh` 命令行参数解析库。`argh` 是一个轻量级的 Rust 库，用于解析命令行参数。在桌面平台（如 Windows、macOS、Linux）上，这一改动工作正常，因为它可以访问 `std::env::args()` 来获取命令行参数。

然而，当这些示例被编译为 WebAssembly (wasm) 并在浏览器中运行时，问题就出现了。WebAssembly 运行在一个受限的沙箱环境中，通常无法直接访问宿主系统（浏览器）的命令行参数。`argh::from_env()` 函数在底层依赖于 `std::env::args()`，而这个函数在 wasm32 目标架构下可能没有有意义的实现，或者其行为与桌面环境不同，导致运行时崩溃或未定义行为。

因此，这个 PR 的核心目标是确保相同的代码库能够同时在桌面和 wasm 目标上正常工作，而不引发运行时错误。

解决方案采用了 Rust 中处理平台特定代码的惯用方法：条件编译。开发者没有尝试寻找一个能在所有环境下工作的统一 API，而是根据目标平台选择了不同的初始化策略。这是处理 WebAssembly 与原生环境根本性差异的一种务实且有效的方法。

具体的实现很简单。在每个 testbed 示例的 `main` 函数中，原来只有一行 `let args: Args = argh::from_env();`。现在，这行代码被包裹在条件编译属性 `#[cfg(not(target_arch = "wasm32"))]` 中，意味着它只会在编译目标**不是** `wasm32` 时生效。对于 `wasm32` 目标，则添加了另一段代码：`let args: Args = Args::from_args(&[], &[]).unwrap();`。

`Args::from_args` 是 `argh` 库提供的一个底层方法，它允许手动传入参数向量。这里传入了两个空切片 `&[]`，分别代表命令行参数和附加参数（如环境变量）。这实际上创建了一个使用所有默认值的 `Args` 结构体实例，因为没有任何参数被提供。对于运行在浏览器中的 wasm 应用来说，这是合理的行为——它们通常不需要也没有办法处理传统的命令行参数。

这种修复模式并非首创。PR 描述中提到“像其他使用 argh 的示例一样修复它”，这表明 Bevy 代码库中已经存在处理此类跨平台问题的既定模式。这个 PR 只是将这种已被验证有效的模式应用到新引入 `argh` 的 testbed 示例中，确保了整个项目在跨平台支持上的一致性。

从工程角度看，这个改动很小但很重要。它保证了 Bevy 的示例代码在宣传的各个目标平台（包括 Web）上都能顺畅运行，这对于用户体验和项目信誉至关重要。同时，它也展示了在 Rust 中如何使用 `cfg` 属性优雅地处理平台差异，这是一个值得学习的简单而实用的技巧。

## Visual Representation

```mermaid
graph TD
    subgraph "Root Cause: PR #22223"
        A[引入 argh 库] --> B[在桌面平台工作正常]
        A --> C[在 wasm 平台运行时崩溃]
    end

    C --> D{诊断问题}
    D --> E[原因：wasm 环境无法访问命令行]

    subgraph "Solution: PR #22339"
        F[应用条件编译] --> G
        F --> H
        
        subgraph G[非 wasm 目标]
            G1[使用 argh::from_env()]
        end
        
        subgraph H[wasm32 目标]
            H1[使用 Args::from_args(&[], &[])]
        end
    end

    G --> I[所有平台示例正常运行]
    H --> I
```

## Key Files Changed

修改了三个平行的测试平台示例文件，每个文件的修复模式完全相同。

- `examples/testbed/2d.rs` (+3/-0)
- `examples/testbed/3d.rs` (+3/-0)
- `examples/testbed/ui.rs` (+3/-0)

### 修改详情

每个文件的修改都是为了解决同一个问题：在 wasm 目标下安全地初始化 `Args` 结构体。修改方式是在 `main` 函数中，将单行的初始化代码替换为基于目标平台的条件编译块。

**关键代码片段（以 `2d.rs` 为例）:**

```rust
// File: examples/testbed/2d.rs
// Before:
fn main() {
    let args: Args = argh::from_env(); // 在 wasm 上会崩溃
    // ... 其余代码
}

// After:
fn main() {
    #[cfg(not(target_arch = "wasm32"))]
    let args: Args = argh::from_env(); // 仅在非 wasm 平台执行
    #[cfg(target_arch = "wasm32")]
    let args: Args = Args::from_args(&[], &[]).unwrap(); // 在 wasm 平台使用空参数初始化
    // ... 其余代码
}
```

**关系说明：**
这三个文件分别是 2D、3D 和 UI 测试平台的入口点。它们都因为 PR #22223 而引入了 `argh`，因此也共享了相同的 wasm 兼容性问题。本 PR 对它们进行了统一修复，确保所有 testbed 示例在 Web 目标上都能正常工作。`3d.rs` 和 `ui.rs` 的修改与上面展示的 `2d.rs` 的修改完全一致。

## Further Reading

1.  **argh Crate Documentation**: 了解 `argh` 命令行解析库的完整 API，包括 `from_env()` 和 `from_args()` 等方法。
    - 链接：https://docs.rs/argh

2.  **Rust `#[cfg]` Attribute**: 官方文档详细解释了如何使用条件编译属性来处理不同平台、特性或版本的代码。
    - 链接：https://doc.rust-lang.org/reference/conditional-compilation.html

3.  **Bevy WebAssembly Guide**: Bevy 官方关于如何将应用编译和运行到 Web 平台的指南，有助于理解 wasm 目标下的独特约束。
    - 链接：https://bevyengine.org/learn/quick-start/getting-started/setup/#wasm

# Full Code Diff
diff --git a/examples/testbed/2d.rs b/examples/testbed/2d.rs
index d535147704425..6ee73f2a0c36a 100644
--- a/examples/testbed/2d.rs
+++ b/examples/testbed/2d.rs
@@ -16,7 +16,10 @@ pub struct Args {
 }
 
 fn main() {
+    #[cfg(not(target_arch = "wasm32"))]
     let args: Args = argh::from_env();
+    #[cfg(target_arch = "wasm32")]
+    let args: Args = Args::from_args(&[], &[]).unwrap();
 
     let mut app = App::new();
     app.add_plugins((DefaultPlugins,))
diff --git a/examples/testbed/3d.rs b/examples/testbed/3d.rs
index da94d773e2da8..01c5c5bd40a43 100644
--- a/examples/testbed/3d.rs
+++ b/examples/testbed/3d.rs
@@ -16,7 +16,10 @@ pub struct Args {
 }
 
 fn main() {
+    #[cfg(not(target_arch = "wasm32"))]
     let args: Args = argh::from_env();
+    #[cfg(target_arch = "wasm32")]
+    let args: Args = Args::from_args(&[], &[]).unwrap();
 
     let mut app = App::new();
     app.add_plugins((DefaultPlugins,))
diff --git a/examples/testbed/ui.rs b/examples/testbed/ui.rs
index d2b71a1023d41..32bec7dc55c07 100644
--- a/examples/testbed/ui.rs
+++ b/examples/testbed/ui.rs
@@ -16,7 +16,10 @@ pub struct Args {
 }
 
 fn main() {
+    #[cfg(not(target_arch = "wasm32"))]
     let args: Args = argh::from_env();
+    #[cfg(target_arch = "wasm32")]
+    let args: Args = Args::from_args(&[], &[]).unwrap();
 
     let mut app = App::new();
     app.add_plugins(DefaultPlugins.set(WindowPlugin {