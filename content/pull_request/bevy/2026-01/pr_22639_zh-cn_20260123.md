+++
title = "#22639 Improve realism of entity benches by warming up the entity allocator"
date = "2026-01-23T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22639-zh-cn-20260123" }}
labels = ["A-ECS", "C-Benchmarks", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Improve realism of entity benches by warming up the entity allocator
- **PR Link**: https://github.com/bevyengine/bevy/pull/22639
- **Author**: ElliottjPierce
- **Status**: MERGED
- **Labels**: A-ECS, C-Benchmarks, D-Straightforward, S-Needs-Review
- **Created**: 2026-01-22T02:46:25Z
- **Merged**: 2026-01-23T02:23:17Z
- **Merged By**: cart

## Description Translation
根据 #18670 中的[评论](https://github.com/bevyengine/bevy/pull/18670#issuecomment-3776301267)，该PR尝试通过预热实体分配器（entity allocator）使实体相关的基准测试更加真实。这有助于测试实体分配器中的空闲列表（freelist）。

## 解决方案

该PR引入了一个新的 `WorldBuilder` 类型，该类型从 `World::new` 开始，通过构建器模式（builder pattern）提供预热世界的配置选项，然后构建预热后的真实世界。目前，唯一的"预热"功能是针对实体的，但未来我们也可以添加功能来缓存bundle信息、预创建表等，使基准测试更加真实。即，更接近运行中应用的性能，而不是启动时应用的性能。

当前的实体预热实现分配一些实体并以随机顺序释放它们。它还会生成最高分配的实体索引以准备 `Entities` 的位置存储等。这涉及使用 `rng`（确定性地），但如果没有这个，实体会按线性索引顺序（0, 1, 2, ...）分配，这是不现实的且对缓存极其友好（因此可能对基准测试不期望的性能产生影响）。

这里的主要缺点是基准测试现在需要稍长一点的时间来运行，并且启动/缓存时间不再被基准测试。例如，以前只基准测试反生成（despawn）一个实体可以告诉我们一些关于分配空闲列表（以及其他一次性操作）性能的信息。现在，这些信息丢失了，因为世界已经被预热。实际上，对于实体的N个值，过去的情况是：较高的N显示操作的性能，较低的N显示操作 + 任何注册/缓存成本。现在，不同的N值只更多地告诉我们CPU如何处理一批操作。

目前在Bevy中，进行更改可能会使 `...1_entity` 基准测试变得更差，但使 `...1000_entities` 基准测试变得更好，因为该更改添加了一些新的缓存。反之亦然。通过此PR，这种情况将不再发生，至少对于实体以及未来我们添加到 `WorldBuilder` 的任何其他内容是如此。这种变化可能理想，也可能不理想。

## 测试

运行了部分基准测试的抽样。

## The Story of This Pull Request

### 问题与背景

在Bevy引擎中，基准测试（benchmark）对于评估性能改进至关重要。然而，现有的实体相关基准测试存在一个关键问题：它们使用的是"冷"世界（cold world），即通过 `World::new` 或 `World::default` 创建的全新世界。在这种冷世界中，实体分配器是全新的，实体ID按顺序分配（0, 1, 2, ...），空闲列表（freelist）为空，`Entities` 存储也没有预分配。

这种设置虽然能测量启动成本和初始分配性能，但不能反映运行中应用的典型状态。在一个长时间运行的应用中，实体会被频繁创建和销毁，导致实体分配器中的空闲列表被填充，实体ID变得分散，`Entities` 存储也会被扩展以容纳更高的实体索引。这些因素都会影响实体操作的性能，尤其是内存访问模式和缓存效率。

正如PR描述中提到的，先前的一个PR（#18670）的评论指出了这个问题，并建议预热实体分配器以获得更真实的基准测试结果。

### 解决方案方法

开发者采用了构建器模式（builder pattern）来创建一个灵活的 `WorldBuilder`，专门用于生成预热后的世界。这种方法有几个优点：

1. **可配置性**：可以针对不同的基准测试需求配置不同的预热选项（目前只有实体预热，但设计上支持扩展）。
2. **隔离性**：预热逻辑集中在 `WorldBuilder` 中，不污染生产代码。
3. **可控性**：使用确定性的随机数生成器（RNG），确保基准测试结果可重现。

核心思路是：在基准测试开始前，先分配一定数量的实体，然后以随机顺序释放它们，从而填充实体分配器的空闲列表，并预分配 `Entities` 的存储空间。

### 具体实现

在 `benches/benches/bevy_ecs/main.rs` 中新增了 `world_builder` 模块，包含 `WorldBuilder` 结构体：

```rust
pub struct WorldBuilder {
    world: World,
    rng: SmallRng,
    max_expected_entities: u32,
}
```

`WorldBuilder` 提供以下方法：
- `new()`：初始化构建器，使用固定的种子创建随机数生成器，默认最大预期实体数为10,000。
- `with_max_expected_entities()`：设置最大预期实体数。
- `warm_up_entity_allocator()`：执行实体预热的核心逻辑。
- `build()`：返回预热后的世界。

预热逻辑的关键步骤：
1. 分配 `max_expected_entities` 个实体ID，但不实际创建这些实体（使用 `alloc_many`）。
2. 生成最高索引的实体并立即反生成它（使用 `spawn_empty_at` 和 `try_despawn_no_free`），以预分配 `Entities` 的存储。
3. 将分配的实体ID列表随机打乱，然后按随机顺序释放它们，填充空闲列表。

这种方法模拟了实体分配器在长期运行后的状态：空闲列表包含各种索引的实体ID，且 `Entities` 存储已经扩展以容纳可能的最大实体索引。

### 技术细节与权衡

**随机化的重要性**：如果不使用随机顺序释放实体，实体ID会按顺序释放回空闲列表，这仍然会导致不现实的缓存友好行为。随机打乱确保了实体分配模式更接近真实场景。

**性能权衡**：
- **优点**：基准测试现在能更准确地反映运行中应用的性能，特别是涉及实体分配、反生成和重用的情况。
- **缺点**：
  1. 基准测试运行时间增加，因为需要预热阶段。
  2. 启动和一次性成本（如组件注册、表创建）不再被测量。这可能导致某些优化（如缓存改进）在基准测试中无法被观察到。

**设计决策**：
1. **单独的构建器**：而不是修改 `World::new` 或添加 `World::warmed_up()` 方法，因为预热是有成本的，不应影响生产代码。
2. **确定性RNG**：使用固定种子的 `SmallRng` 确保基准测试可重现。
3. **可扩展设计**：`WorldBuilder` 可以未来添加其他预热选项，如缓存bundle信息、预创建表等。

### 对基准测试的影响

修改了五个基准测试文件：
- `commands.rs`：命令（commands）相关的基准测试。
- `despawn.rs`：反生成实体的基准测试。
- `despawn_recursive.rs`：递归反生成的基准测试。
- `spawn.rs`：生成实体的基准测试。

每个文件都做了类似的修改：将 `World::default()` 替换为 `WorldBuilder` 链式调用，根据测试的实体数量设置 `max_expected_entities` 并调用 `warm_up_entity_allocator()`。

例如，在 `spawn.rs` 中：

```rust
// 之前：
let mut world = World::default();

// 之后：
let mut world = WorldBuilder::new()
    .with_max_expected_entities(entity_count)
    .warm_up_entity_allocator()
    .build();
```

这种改变确保了这些基准测试现在测量的是在已经运行一段时间、实体分配器已经预热的状态下的性能，而不是冷启动状态下的性能。

### 潜在影响与未来方向

这个变化显著改变了基准测试的测量重点。开发者需要意识到：
- 以前 `1_entity` 基准测试可能测量的是操作成本+启动成本，现在只测量操作成本。
- 不同实体数量的基准测试现在更纯粹地反映批量操作的性能，而不是混合了缓存/启动成本。

未来可以考虑：
1. 添加更多预热选项，如组件注册缓存、表预创建等。
2. 提供不同的 `WorldBuilder` 预设，针对不同类型的基准测试（如启动性能 vs 运行时性能）。
3. 考虑是否需要在某些基准测试中保留冷世界测试，以继续测量启动成本。

## Visual Representation

```mermaid
graph TD
    A[Benchmark Tests] --> B{Need Warm World?}
    B -->|Yes| C[Use WorldBuilder]
    B -->|No| D[Use World::new]
    
    C --> E[WorldBuilder::new]
    E --> F[.with_max_expected_entities()]
    F --> G[.warm_up_entity_allocator()]
    G --> H[.build()]
    H --> I[Warmed World]
    
    D --> J[Cold World]
    
    I --> K[Run Benchmark]
    J --> K
```

## Key Files Changed

### 1. `benches/benches/bevy_ecs/main.rs` (+77/-0)
**变化说明**：新增了 `WorldBuilder` 模块，提供了创建预热世界的构建器。

**关键代码**：
```rust
pub struct WorldBuilder {
    world: World,
    rng: SmallRng,
    max_expected_entities: u32,
}

impl WorldBuilder {
    pub fn new() -> Self {
        // 初始化，使用固定种子确保可重现性
    }
    
    pub fn with_max_expected_entities(mut self, max_expected_entities: u32) -> Self {
        self.max_expected_entities = max_expected_entities;
        self
    }
    
    pub fn warm_up_entity_allocator(mut self) -> Self {
        // 分配实体
        let mut entities = Vec::new();
        entities.reserve_exact(self.max_expected_entities as usize);
        entities.extend(
            self.world
                .entity_allocator()
                .alloc_many(self.max_expected_entities),
        );
        
        // 预热 Entities 存储
        let Some(high_index) = entities.last_mut() else {
            return self;
        };
        self.world.spawn_empty_at(*high_index).unwrap();
        *high_index = self.world.try_despawn_no_free(*high_index).unwrap();
        
        // 随机释放实体以填充空闲列表
        entities.shuffle(&mut self.rng);
        entities
            .drain(..)
            .for_each(|e| self.world.entity_allocator_mut().free(e));
        
        self
    }
    
    pub fn build(self) -> World {
        self.world
    }
}
```

### 2. `benches/benches/bevy_ecs/world/commands.rs` (+19/-5)
**变化说明**：将命令相关的基准测试从使用 `World::default()` 改为使用 `WorldBuilder`。

**关键代码**：
```rust
// 之前：
let mut world = World::default();

// 之后：
let mut world = WorldBuilder::new()
    .with_max_expected_entities(entity_count)
    .warm_up_entity_allocator()
    .build();
```

### 3. `benches/benches/bevy_ecs/world/spawn.rs` (+11/-3)
**变化说明**：将生成实体相关的基准测试从使用 `World::default()` 改为使用 `WorldBuilder`。

**关键代码**：
```rust
// 之前：
let mut world = World::default();

// 之后：
let mut world = WorldBuilder::new()
    .with_max_expected_entities(entity_count)
    .warm_up_entity_allocator()
    .build();
```

### 4. `benches/benches/bevy_ecs/world/despawn.rs` (+6/-1)
**变化说明**：将反生成实体相关的基准测试从使用 `World::default()` 改为使用 `WorldBuilder`。

**关键代码**：
```rust
// 之前：
let mut world = World::default();

// 之后：
let mut world = WorldBuilder::new()
    .with_max_expected_entities(entity_count)
    .warm_up_entity_allocator()
    .build();
```

### 5. `benches/benches/bevy_ecs/world/despawn_recursive.rs` (+6/-1)
**变化说明**：将递归反生成相关的基准测试从使用 `World::default()` 改为使用 `WorldBuilder`。

**关键代码**：
```rust
// 之前：
let mut world = World::default();

// 之后：
let mut world = WorldBuilder::new()
    .with_max_expected_entities(entity_count)
    .warm_up_entity_allocator()
    .build();
```

## Further Reading

1. **Bevy ECS 架构**：了解 Bevy 的实体组件系统如何工作，特别是实体分配器和空闲列表的实现。
   - [Bevy ECS 文档](https://bevyengine.org/learn/quick-start/ecs/)
   - [Bevy GitHub 仓库中的 ECS 模块](https://github.com/bevyengine/bevy/tree/main/crates/bevy_ecs)

2. **基准测试最佳实践**：如何设计有效的基准测试，特别是微基准测试（microbenchmarks）。
   - [Criterion.rs 文档](https://bheisler.github.io/criterion.rs/book/)
   - [《Systems Performance: Enterprise and the Cloud》](https://www.brendangregg.com/systems-performance-2nd-edition-book.html) 中的基准测试章节

3. **内存分配模式与性能**：理解不同的内存分配模式如何影响性能，特别是缓存友好性（cache-friendliness）。
   - [《What Every Programmer Should Know About Memory》](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf)
   - [CPU 缓存的工作原理](https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips)

4. **构建器模式**：深入学习构建器模式及其在 Rust 中的实现。
   - [《Rust 程序设计语言》中的构建器模式示例](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#the-builder-pattern)
   - [Rust Design Patterns: Builder Pattern](https://rust-unofficial.github.io/patterns/patterns/creational/builder.html)