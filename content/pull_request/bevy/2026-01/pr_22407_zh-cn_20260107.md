+++
title = "#22407 docs: adds migration guide for Assets<Mesh> retaining render_world only meshes"
date = "2026-01-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22407-en-20260107" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22407-zh-cn-20260107" }}
labels = ["C-Docs", "A-Rendering", "A-Picking"]
+++

# Title

## Basic Information
- **Title**: docs: adds migration guide for Assets<Mesh> retaining render_world only meshes
- **PR Link**: https://github.com/bevyengine/bevy/pull/22407
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: C-Docs, A-Rendering, S-Needs-Review, A-Picking
- **Created**: 2026-01-07T02:07:59Z
- **Merged**: 2026-01-07T05:42:46Z
- **Merged By**: alice-i-cecile

## Description Translation
此PR的目标是`release-0.18.0`分支，而非`main`！

# 目标 (Objective)
- 修复 #22206

## 解决方案 (Solution)
- 为 #21732 中的变更添加一份迁移指南。鉴于我对网格(Mesh)相关的内容不是特别熟悉，希望能得到更熟悉这些变更和网格系统的开发者审阅！

FYI @robtfm @beicause

## The Story of This Pull Request

这个PR的故事源于Bevy引擎渲染管线中一个关于资源生命周期的设计变更。在0.17版本及之前，`Assets<Mesh>`资源的行为有一个潜在问题：当一个网格(Mesh)被标记为`RenderAssetUsages::RENDER_WORLD`时，意味着它仅用于渲染世界(Render World)，一旦其数据被提取(extract)到渲染世界后，它在主世界的`Assets<Mesh>`集合中就不再保留其实际数据。这个设计导致了一个问题：如果其他系统在主世界尝试访问一个已被提取的网格的数据，会直接导致程序panic，因为数据已经不存在了。

为了解决这个问题，PR #21732 修改了行为：从Bevy 0.18开始，`Assets<Mesh>`会保留`RenderAssetUsages::RENDER_WORLD`类型的网格，即使它们的数据已经被提取到渲染世界。这是一个积极的架构改进，因为它消除了因数据访问时机不当导致的意外崩溃，使得资源管理更加健壮。然而，这个改进引入了一个新的挑战：当网格数据在渲染世界时，主世界的代码尝试修改或读取这些数据在逻辑上是不允许的，因为这涉及到跨线程的数据竞争和安全问题（渲染通常发生在独立的线程）。

因此，解决方案不是简单地允许访问，而是提供一个安全、显式的机制来让开发者处理这种情况。这就是`try_*`系列函数被引入的原因。原有的如`mesh.insert_attribute()`这样的函数被设计为直接修改内部数据。在新的架构下，如果一个网格是`RENDER_WORLD`类型且已被提取，调用这些函数将导致panic，因为数据不可变或不存在。新的`mesh.try_insert_attribute()`等函数则返回一个`Result`类型。如果网格数据可用（例如，它是`MAIN_WORLD`类型，或者尚未被提取），则操作成功。如果数据已被提取到渲染世界，则返回一个`Err(MeshAccessError::ExtractedToRenderWorld)`错误。这强制开发者显式处理这种可能的失败情况，从而编写出更健壮的代码。

这份迁移指南（PR #22407）的核心任务就是清晰地文档化这一行为变更，并为开发者提供一个从0.17升级到0.18的明确路径。它没有修改任何运行时代码，而是创建了一份详尽的“函数映射表”。这份表格列出了所有受到影响的`Mesh`方法，并指明了它们在0.17中的原名和在0.18中对应的`try_*`版本。例如，你需要将`mesh.insert_attribute(...)`替换为`mesh.try_insert_attribute(...)`，然后处理其返回的`Result`。

值得注意的是，指南还提到了另一类函数，如`mesh.get_vertex_size(...)`。这些函数没有对应的`try_*`版本，但在0.18中，如果调用时网格数据已被提取，它们同样会panic。这可能是出于性能或API简洁性的考虑，同时也提醒开发者，在使用这些函数时需要确保上下文安全（例如，仅在数据确定可用的预处理阶段使用）。

从工程角度来看，这个变更体现了几个重要的软件设计原则：
1.  **Fail-fast 与 明确性**：通过`Result`类型，将潜在的运行时错误提升为编译时必须处理的类型系统错误，使错误处理路径更加清晰。
2.  **资源生命周期管理**：明确了`RENDER_WORLD`资源的所有权转移（数据移动到渲染线程），并通过API强制实施访问规则。
3.  **向后兼容与平滑迁移**：提供详尽的迁移指南是维护大型项目生态健康的关键。开发者可以根据这份清单系统地更新代码，而不是在运行时遇到神秘的崩溃后再去调试。

总之，这个PR虽然只是一个文档变更，但它是一把关键的“钥匙”，解锁了#21732中重要架构改进的实用价值。它确保了开发者社区能够顺利地从旧有的、可能不安全的模式，过渡到新的、更安全、更明确的资源访问模式。

## Visual Representation

```mermaid
graph TD
    subgraph "Main World (逻辑世界)"
        A[Assets<Mesh> 资源集合] --> B{网格使用类型?}
        B -- RenderAssetUsages::MAIN_WORLD --> C[数据可被主世界直接访问/修改]
        B -- RenderAssetUsages::RENDER_WORLD --> D[数据将被提取]
    end

    D --> E[Extract阶段]
    E --> F[Render World 渲染世界]
    
    C --> G[调用 mesh.try_*() 成功]
    D -.->|数据已提取后| H[在主世界调用 mesh.try_*() 返回 Err(ExtractedToRenderWorld)]
    
    style C fill:#cfc
    style H fill:#fcc
```

## Key Files Changed

- `release-content/migration-guides/assets_mesh_try_functions.md` (+125/-0)

这是此PR创建的唯一文件，一个全新的迁移指南文档。它没有“之前”的内容，因为文件是新建的。

**内容描述**：
该文件是一个结构清晰的迁移指南，专门用于指导开发者适应`Assets<Mesh>`对`RENDER_WORLD`网格的保留行为。其核心内容是两个并列的函数列表，分别对应0.17版本（旧函数）和0.18版本（新函数）。它明确告知开发者：如果你的代码可能处理`RENDER_WORLD`类型的网格，就必须将左侧列表中的函数调用替换为右侧对应的`try_*`版本，并妥善处理`Result`。

**关键代码片段**：
文档中的核心部分是两个对比列表，下面是一个节选：

```rust
// 0.17 版本中直接调用的函数（在0.18中，如果网格已提取，这些函数会Panic）
mesh.insert_attribute(...)
mesh.with_inserted_attribute(...)
mesh.remove_attribute(...)

// 0.18 版本中对应的安全函数
mesh.try_insert_attribute(...)        // 返回 Result
mesh.try_with_inserted_attribute(...) // 返回 Result
mesh.try_remove_attribute(...)        // 返回 Result
```

此外，文档还解释了新引入的错误类型：
```rust
// 这些函数返回一个 `Result<..., MeshAccessError>`。
// 当网格已提取时，返回 `Err(MeshAccessError::ExtractedToRenderWorld)`。
```

以及那些没有`try_*`版本但行为改变的函数：
```rust
// 以下函数没有对应的 try_* 版本，但如果网格数据已被提取到 `RenderWorld`，现在会直接 panic。
mesh.get_vertex_size(...)
mesh.get_vertex_buffer_size(...)
```

**与PR目的的关系**：
这份文档是PR #21732所实现功能面向用户的最终接口。没有这份指南，开发者升级到0.18后可能会遇到令人困惑的panic或编译错误，而不清楚如何修复。它直接服务于PR的“目标”（Fix #22206），即提供一个清晰的升级路径，解决因行为变更导致的迁移问题。

## Further Reading

1.  **PR #21732**: 这是实现核心行为变更的PR。阅读它可以深入理解`Assets<Mesh>`保留机制和`try_*`函数是如何被实现的。
2.  **Issue #22206**: 原始问题报告，可能包含了用户遇到的具体错误场景和讨论，有助于理解此变更要解决的痛点。
3.  **Bevy官方文档 - Render Phases and Extract**: 了解Bevy的渲染阶段，特别是“Extract”阶段，对于理解为什么网格数据会被移动到`RenderWorld`至关重要。
4.  **Rust的`Result`和错误处理**: 熟悉Rust的`Result`枚举和`?`操作符，将帮助你更高效地处理`try_*`函数返回的错误。