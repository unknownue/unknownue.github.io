+++
title = "#22437 Store registered system as Option and take it when running"
date = "2026-01-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22437-en-20260108" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22437-zh-cn-20260108" }}
labels = ["C-Bug", "A-ECS"]
+++

# Title: Store registered system as Option and take it when running

## Basic Information
- **Title**: Store registered system as Option and take it when running
- **PR Link**: https://github.com/bevyengine/bevy/pull/22437
- **Author**: cart
- **Status**: MERGED
- **Labels**: C-Bug, A-ECS, S-Ready-For-Final-Review
- **Created**: 2026-01-08T21:38:15Z
- **Merged**: 2026-01-08T22:47:07Z
- **Merged By**: cart

## Description
Translate the PR description to the target language, preserving:
- Technical terms in English
- All image references and links exactly as they appear
- Code blocks and formatting

# Objective

Fixes #22380

## Solution

- Store the registered system as Option
- Take it when running instead of removing `RegisteredSystem`

This prevents a flush of the global command buffer and also enables running one-shot systems without changing the shape of entities (opening up DeferredWorld scenarios).

## Testing

- Tested the repro in #22380

## The Story of This Pull Request

This PR addresses a bug in Bevy's ECS where recursive system execution would fail. The issue occurred when a system tried to run itself during its own execution, which would panic because the `RegisteredSystem` component had been temporarily removed from the entity.

The root cause was in how systems were stored and accessed. Previously, when running a system, the code would completely remove the `RegisteredSystem` component from its entity, run the system, then re-insert it. This approach had several problems. First, it caused structural changes to entities that could flush command buffers unexpectedly. Second, it made recursive system execution impossible because the component would be missing when the system tried to run itself again.

The solution changes the storage approach from direct ownership to optional ownership. Instead of removing the entire `RegisteredSystem` component, we now store the system inside an `Option<BoxedSystem>`. When running the system, we take the system out of the `Option`, leaving `None` in its place, run the system, then put it back. This approach maintains the component's presence on the entity while still allowing exclusive access to the system during execution.

The key implementation changes are in `crates/bevy_ecs/src/system/system_registry.rs`. The `RegisteredSystem` struct now stores the system as `Option<BoxedSystem<I, O>>` instead of `BoxedSystem<I, O>`. This change is reflected in the constructor and all usage sites.

```rust
// Before:
pub(crate) struct RegisteredSystem<I, O> {
    initialized: bool,
    system: BoxedSystem<I, O>,
}

// After:
pub(crate) struct RegisteredSystem<I, O> {
    initialized: bool,
    system: Option<BoxedSystem<I, O>>,
}
```

The `run_system` method shows the most significant change in logic. Instead of taking the entire `RegisteredSystem` component:

```rust
// Old approach - removed component entirely
let Some(RegisteredSystem {
    mut initialized,
    mut system,
}) = entity.take::<RegisteredSystem<I, O>>()
else {
    return Err(RegisteredSystemError::Recursive(id));
};
```

The new approach gets a mutable reference to the component and takes the system from the Option:

```rust
// New approach - takes system from Option within component
let Some(mut registered_system) = entity.get_mut::<RegisteredSystem<I, O>>() else {
    return Err(RegisteredSystemError::MissingRegisteredSystemComponent(id));
};

let mut system = registered_system
    .system
    .take()
    .ok_or(RegisteredSystemError::SystemMissing(id))?;
```

After running the system, it's put back into the component:

```rust
if let Ok(mut entity) = self.get_entity_mut(id.entity)
    && let Some(mut registered_system) = entity.get_mut::<RegisteredSystem<I, O>>()
{
    registered_system.system = Some(system);
    registered_system.initialized = true;
}
```

This change has several technical benefits. First, it prevents unnecessary command buffer flushes because entities aren't undergoing structural changes (components aren't being added/removed). Second, it enables one-shot systems to work with deferred world operations more reliably. Third, it provides better error messages when systems go missing - instead of a generic "recursive" error, we now get specific errors about missing systems or missing components.

The error handling was also improved. The `RegisteredSystemError::Recursive` variant was replaced with two more specific errors: `MissingRegisteredSystemComponent` and `SystemMissing`. This provides clearer diagnostics for debugging system execution issues.

A subtle but important consideration is that this approach leaves the system as `None` during execution. If the system panics during execution, the system won't be returned to the component, leaving it permanently missing. The TODO comment in the code acknowledges this limitation and suggests using `catch_unwind` as a future improvement.

This implementation demonstrates a common pattern in Rust for temporary ownership: using `Option::take()` to move a value out, work with it, then `Option::replace()` or assignment to put it back. This pattern maintains the container's structure while allowing exclusive access to its contents.

## Visual Representation

```mermaid
graph TD
    A[System Execution Request] --> B{Get RegisteredSystem Component}
    B -->|Success| C[Take system from Option]
    B -->|Missing| D[Error: MissingRegisteredSystemComponent]
    C -->|Some(system)| E[Run System]
    C -->|None| F[Error: SystemMissing]
    E --> G[Return system to Option]
    G --> H[Command Buffer Execution]
```

## Key Files Changed

### `crates/bevy_ecs/src/system/system_registry.rs` (+30/-20)

This is the only file modified in this PR. It contains the core logic for registering and running systems in Bevy's ECS.

**Key Changes:**

1. **RegisteredSystem struct changed to use Option**:
   ```rust
   // Before:
   pub(crate) struct RegisteredSystem<I, O> {
       initialized: bool,
       system: BoxedSystem<I, O>,
   }
   
   // After:
   pub(crate) struct RegisteredSystem<I, O> {
       initialized: bool,
       system: Option<BoxedSystem<I, O>>,
   }
   ```

2. **run_system method updated to take system from Option**:
   ```rust
   // Before: Remove entire component
   let Some(RegisteredSystem {
       mut initialized,
       mut system,
   }) = entity.take::<RegisteredSystem<I, O>>()
   
   // After: Take system from Option within component
   let Some(mut registered_system) = entity.get_mut::<RegisteredSystem<I, O>>() else {
       return Err(RegisteredSystemError::MissingRegisteredSystemComponent(id));
   };
   
   let mut system = registered_system
       .system
       .take()
       .ok_or(RegisteredSystemError::SystemMissing(id))?;
   ```

3. **Error types updated for better diagnostics**:
   ```rust
   // Before:
   #[error("System {0:?} tried to run itself recursively")]
   Recursive(SystemId<I, O>),
   
   // After:
   #[error("System {0:?} does not have a RegisteredSystem component. This only happens if app code removed the component.")]
   MissingRegisteredSystemComponent(SystemId<I, O>),
   
   #[error("The system is not present in the RegisteredSystem component. This can happen if the system was called recursively or if the system panicked on the last run.")]
   SystemMissing(SystemId<I, O>),
   ```

4. **System return logic preserves component structure**:
   ```rust
   // Put system back after execution
   if let Ok(mut entity) = self.get_entity_mut(id.entity)
       && let Some(mut registered_system) = entity.get_mut::<RegisteredSystem<I, O>>()
   {
       registered_system.system = Some(system);
       registered_system.initialized = true;
   }
   ```

## Further Reading

1. **Bevy ECS Documentation**: https://bevyengine.org/learn/book/next/programming/ecs-intro/
2. **Rust Option Type**: https://doc.rust-lang.org/std/option/enum.Option.html
3. **Bevy Command Buffer System**: Understanding how command buffering works in Bevy's ECS
4. **Temporary Ownership Patterns in Rust**: Common patterns for borrowing and taking ownership temporarily

# Full Code Diff
```diff
diff --git a/crates/bevy_ecs/src/system/system_registry.rs b/crates/bevy_ecs/src/system/system_registry.rs
index 2488dbcfd0b47..7305bd5dd8b9f 100644
--- a/crates/bevy_ecs/src/system/system_registry.rs
+++ b/crates/bevy_ecs/src/system/system_registry.rs
@@ -20,14 +20,14 @@ use thiserror::Error;
 #[require(SystemIdMarker = SystemIdMarker::typed_system_id_marker::<I, O>())]
 pub(crate) struct RegisteredSystem<I, O> {
     initialized: bool,
-    system: BoxedSystem<I, O>,
+    system: Option<BoxedSystem<I, O>>,
 }
 
 impl<I, O> RegisteredSystem<I, O> {
     pub fn new(system: BoxedSystem<I, O>) -> Self {
         RegisteredSystem {
             initialized: false,
-            system,
+            system: Some(system),
         }
     }
 }
@@ -236,7 +236,9 @@ impl World {
                 entity.despawn();
                 Ok(RemovedSystem {
                     initialized: registered_system.initialized,
-                    system: registered_system.system,
+                    system: registered_system
+                        .system
+                        .ok_or(RegisteredSystemError::SystemMissing(id))?,
                 })
             }
             Err(_) => Err(RegisteredSystemError::SystemIdNotRegistered(id)),
@@ -374,11 +376,7 @@ impl World {
             .map_err(|_| RegisteredSystemError::SystemIdNotRegistered(id))?;
 
         // Take ownership of system trait object
-        let Some(RegisteredSystem {
-            mut initialized,
-            mut system,
-        }) = entity.take::<RegisteredSystem<I, O>>()
-        else {
+        let Some(mut registered_system) = entity.get_mut::<RegisteredSystem<I, O>>() else {
             let Some(system_id_marker) = entity.get::<SystemIdMarker>() else {
                 return Err(RegisteredSystemError::SystemIdNotRegistered(id));
             };
@@ -390,13 +388,17 @@ impl World {
                     system_id_marker.clone(),
                 ));
             }
-            return Err(RegisteredSystemError::Recursive(id));
+            return Err(RegisteredSystemError::MissingRegisteredSystemComponent(id));
         };
 
+        let mut system = registered_system
+            .system
+            .take()
+            .ok_or(RegisteredSystemError::SystemMissing(id))?;
+
         // Initialize the system
-        if !initialized {
+        if !registered_system.initialized {
             system.initialize(self);
-            initialized = true;
         }
 
         // refresh hotpatches for stored systems
@@ -416,11 +418,11 @@ impl World {
         system.queue_deferred(self.into());
 
         // Return ownership of system trait object (if entity still exists)
-        if let Ok(mut entity) = self.get_entity_mut(id.entity) {
-            entity.insert::<RegisteredSystem<I, O>>(RegisteredSystem {
-                initialized,
-                system,
-            });
+        if let Ok(mut entity) = self.get_entity_mut(id.entity)
+            && let Some(mut registered_system) = entity.get_mut::<RegisteredSystem<I, O>>()
+        {
+            registered_system.system = Some(system);
+            registered_system.initialized = true;
         }
 
         // Run any commands enqueued by the system
@@ -539,9 +541,9 @@ pub enum RegisteredSystemError<I: SystemInput = (), O = ()> {
     /// Did you forget to register it?
     #[error("Cached system was not found")]
     SystemNotCached,
-    /// A system tried to run itself recursively.
-    #[error("System {0:?} tried to run itself recursively")]
-    Recursive(SystemId<I, O>),
+    /// The `RegisteredSystem` component is missing.
+    #[error("System {0:?} does not have a RegisteredSystem component. This only happens if app code removed the component.")]
+    MissingRegisteredSystemComponent(SystemId<I, O>),
     /// A system tried to remove itself.
     #[error("System {0:?} tried to remove itself")]
     SelfRemove(SystemId<I, O>),
@@ -555,6 +557,10 @@ pub enum RegisteredSystemError<I: SystemInput = (), O = ()> {
     /// [`SystemId`] had different input and/or output types than [`SystemIdMarker`]
     #[error("Could not get system from `{}`, entity was `SystemId<{}, {}>`", DebugName::type_name::<SystemId<I, O>>(), .1.input_type_id.name, .1.output_type_id.name)]
     IncorrectType(SystemId<I, O>, SystemIdMarker),
+    /// System is not present in the `RegisteredSystem` component.
+    // TODO: We should consider using catch_unwind to protect against the panic case.
+    #[error("The system is not present in the RegisteredSystem component. This can happen if the system was called recursively or if the system panicked on the last run.")]
+    SystemMissing(SystemId<I, O>),
 }
 
 impl<I: SystemInput, O> From<RunSystemError> for RegisteredSystemError<I, O> {
@@ -573,7 +579,10 @@ impl<I: SystemInput, O> core::fmt::Debug for RegisteredSystemError<I, O> {
                 f.debug_tuple("SystemIdNotRegistered").field(arg0).finish()
             }
             Self::SystemNotCached => write!(f, "SystemNotCached"),
-            Self::Recursive(arg0) => f.debug_tuple("Recursive").field(arg0).finish(),
+            Self::MissingRegisteredSystemComponent(arg0) => f
+                .debug_tuple("MissingRegisteredSystemComponent")
+                .field(arg0)
+                .finish(),
             Self::SelfRemove(arg0) => f.debug_tuple("SelfRemove").field(arg0).finish(),
             Self::Skipped(arg0) => f.debug_tuple("Skipped").field(arg0).finish(),
             Self::Failed(arg0) => f.debug_tuple("Failed").field(arg0).finish(),
@@ -582,6 +591,7 @@ impl<I: SystemInput, O> core::fmt::Debug for RegisteredSystemError<I, O> {
                 .field(arg0)
                 .field(arg1)
                 .finish(),
+            Self::SystemMissing(arg0) => f.debug_tuple("SystemMissing").field(arg0).finish(),
         }
     }
 }
```