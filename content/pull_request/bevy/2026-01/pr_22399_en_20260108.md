+++
title = "#22399 Directional navigation now considers UiTransform rotation"
date = "2026-01-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22399-en-20260108" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22399-zh-cn-20260107" }}
labels = ["C-Bug", "A-UI", "D-Straightforward"]
+++

# Directional navigation now considers UiTransform rotation

## Basic Information
- **Title**: Directional navigation now considers UiTransform rotation
- **PR Link**: https://github.com/bevyengine/bevy/pull/22399
- **Author**: snk-git-hub
- **Status**: MERGED
- **Labels**: C-Bug, A-UI, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-01-06T06:24:09Z
- **Merged**: 2026-01-07T22:47:43Z
- **Merged By**: cart

## Description Translation
**Objective**
Fixes #22234
The directional navigation system was ignoring `UiTransform` rotation and scaling when calculating which node to navigate to. This caused navigation to select incorrect nodes when they were rotated or scaled, because the system used unrotated layout positions instead of the visual positions seen by users.

**Solution**
- Added `get_rotated_bounds()` helper function to calculate the axis-aligned bounding box of a rotated rectangle
- Updated `get_navigable_nodes()` to apply both rotation and scale transforms from `UiGlobalTransform` when creating `FocusableArea` structs
- Updated `entity_to_camera_and_focusable_area()` to apply rotation and scale transforms
- Used `bevy_math::ops` instead of `f32` methods for deterministic trigonometry

The fix ensures that directional navigation uses the visual position of nodes (after transforms) rather than just the layout position, so users navigate to the button they actually see on screen.

**Testing**
- Tested with `auto_directional_navigation` example - navigation works correctly with scattered button layouts 

![Screencast From 2026-01-06 11-37-04](https://github.com/user-attachments/assets/fcaf5d24-f337-4f2d-b1e9-c08651bd9d97)

## The Story of This Pull Request

The issue began with a bug report (#22234) where users experienced incorrect directional navigation in UI systems when UI elements were rotated or scaled. In Bevy's UI system, directional navigation allows users to move between focusable elements (like buttons) using arrow keys or gamepad inputs. The navigation algorithm calculates which element is in a given direction based on their positions and sizes.

The problem was that the navigation system was using the raw layout positions and sizes from `ComputedNode` without accounting for the transformations applied by `UiTransform`. When a button was rotated 90 degrees or scaled up, its visual bounding box on screen changed, but the navigation system still treated it as if it were in its original orientation and size. This led to confusing navigation behavior where pressing an arrow key would select a different button than the one that appeared to be in that direction.

Looking at the existing code, the navigation system was extracting only the translation component from `UiGlobalTransform` while ignoring the rotation and scale:

```rust
let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
```

The solution needed to account for both rotation and scaling. When a rectangle is rotated, its axis-aligned bounding box (the rectangle that contains it, aligned with the coordinate axes) changes dimensions. For example, a square rotated 45 degrees needs a larger bounding box to contain it.

The implementation added a helper function `get_rotated_bounds()` that calculates the axis-aligned bounding box for a rotated rectangle. The mathematical approach uses the absolute values of cosine and sine to compute the new width and height:

```rust
Vec2::new(
    size.x * cos_r + size.y * sin_r,
    size.x * sin_r + size.y * cos_r,
)
```

This formula gives the dimensions of the smallest axis-aligned rectangle that can contain the rotated original rectangle. The function first checks if rotation is zero to avoid unnecessary computation, which is a sensible optimization since many UI elements won't be rotated.

The key change was updating both `get_navigable_nodes()` and `entity_to_camera_and_focusable_area()` functions to:
1. Extract all three components from the transform (scale, rotation, and translation)
2. Apply the scale to the computed size
3. Calculate the rotated bounds using the new helper function
4. Use the transformed position and rotated size in the `FocusableArea`

An important technical detail was using `bevy_math::ops` instead of the standard `f32` trigonometric functions. The `ops` module provides deterministic versions of these functions, which is important for consistency in networked or replay scenarios where floating-point differences could cause desynchronization.

The example file was updated to test the fix by adding rotation and scaling to one of the buttons. Specifically, the 5th button (index 4) was given a 1.2x scale and 90-degree rotation:

```rust
let transform = if i == 4 {
    UiTransform {
        scale: Vec2::splat(1.2),
        rotation: Rot2::FRAC_PI_2,
        ..default()
    }
} else {
    UiTransform::IDENTITY
};
```

This change demonstrated that the navigation system now correctly handles transformed UI elements. The fix ensures that directional navigation works intuitively - users navigate to the visual position of buttons, not their raw layout positions.

The implementation is efficient because it only calculates rotated bounds when rotation is non-zero, and it reuses the existing transform decomposition. The changes are minimal and focused, addressing exactly the reported issue without introducing unnecessary complexity.

## Visual Representation

```mermaid
graph TD
    A[UiTransform Component] --> B[UiGlobalTransform System]
    B --> C[to_scale_angle_translation()]
    C --> D{Extract scale, rotation, translation}
    D --> E[Apply scale to computed size]
    E --> F[Calculate rotated bounds]
    F --> G[FocusableArea with correct bounds]
    G --> H[Navigation system uses visual position]
    
    I[ComputedNode Component] --> E
    J[Before: Ignored rotation/scale] --> K[Incorrect navigation]
    L[After: Considers rotation/scale] --> M[Correct navigation]
    
    D -.-> J
    G -.-> L
```

## Key Files Changed

### `crates/bevy_ui/src/auto_directional_navigation.rs`

This file contains the core logic for automatic directional navigation in Bevy's UI system. The changes ensure that navigation calculations consider the visual transformations (rotation and scaling) of UI elements.

**Key Changes:**
1. Updated `get_navigable_nodes()` to extract and apply rotation and scale from `UiGlobalTransform`
2. Updated `entity_to_camera_and_focusable_area()` similarly
3. Added `get_rotated_bounds()` helper function to compute axis-aligned bounding boxes

**Code Snippets:**

```rust
// Before (in get_navigable_nodes):
let (_scale, _rotation, translation) = transform.to_scale_angle_translation();
Some(FocusableArea {
    entity,
    position: translation * computed.inverse_scale_factor(),
    size: computed.size() * computed.inverse_scale_factor(),
})

// After:
let (scale, rotation, translation) = transform.to_scale_angle_translation();
let scaled_size = computed.size() * computed.inverse_scale_factor() * scale;
let rotated_size = get_rotated_bounds(scaled_size, rotation);
Some(FocusableArea {
    entity,
    position: translation * computed.inverse_scale_factor(),
    size: rotated_size,
})

// New helper function:
fn get_rotated_bounds(size: Vec2, rotation: f32) -> Vec2 {
    if rotation == 0.0 {
        return size;
    }
    let cos_r = ops::cos(rotation).abs();
    let sin_r = ops::sin(rotation).abs();
    Vec2::new(
        size.x * cos_r + size.y * sin_r,
        size.x * sin_r + size.y * cos_r,
    )
}
```

### `examples/ui/auto_directional_navigation.rs`

This example demonstrates auto-directional navigation functionality. The change adds a rotated and scaled button to test the fix.

**Key Changes:**
1. Added conditional transform for the 5th button with scale=1.2 and 90-degree rotation
2. Included the transform in the spawned button entity

**Code Snippet:**

```rust
// Before: No transform applied to buttons
for (i, (x, y)) in button_positions.iter().enumerate() {
    let button_entity = commands
        .spawn((
            Button,
            Node { /* ... */ },
            // No transform component
            // ...
        ))
        .id();
}

// After: 5th button gets rotation and scale
let transform = if i == 4 {
    UiTransform {
        scale: Vec2::splat(1.2),
        rotation: Rot2::FRAC_PI_2,
        ..default()
    }
} else {
    UiTransform::IDENTITY
};

let button_entity = commands
    .spawn((
        Button,
        Node { /* ... */ },
        transform, // Added here
        // ...
    ))
    .id();
```

## Further Reading

- [Bevy UI System Documentation](https://bevyengine.org/learn/quick-start/getting-started/ui/)
- [Transforms in Bevy](https://bevyengine.org/learn/quick-start/getting-started/transform/)
- [Directional Navigation RFC](https://github.com/bevyengine/rfcs/blob/main/rfcs/62-ui-navigation.md)
- [Axis-Aligned Bounding Boxes (AABB) Mathematics](https://en.wikipedia.org/wiki/Minimum_bounding_box)
- [Deterministic Floating Point Operations in Game Development](https://gafferongames.com/post/floating_point_determinism/)