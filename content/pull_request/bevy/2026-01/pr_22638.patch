diff --git a/crates/bevy_ecs/src/bundle/spawner.rs b/crates/bevy_ecs/src/bundle/spawner.rs
index b471d8735fd39..36a10670e868b 100644
--- a/crates/bevy_ecs/src/bundle/spawner.rs
+++ b/crates/bevy_ecs/src/bundle/spawner.rs
@@ -194,7 +194,7 @@ impl<'w> BundleSpawner<'w> {
     #[inline]
     pub(crate) fn allocator(&mut self) -> &'w mut EntityAllocator {
         // SAFETY: No outstanding references to self.world, changes to entities cannot invalidate our internal pointers
-        unsafe { &mut self.world.world_mut().allocator }
+        unsafe { &mut self.world.world_mut().entity_allocator }
     }
 
     /// # Safety
diff --git a/crates/bevy_ecs/src/entity/clone_entities.rs b/crates/bevy_ecs/src/entity/clone_entities.rs
index 7b1884e54e5d1..8292dc0725cca 100644
--- a/crates/bevy_ecs/src/entity/clone_entities.rs
+++ b/crates/bevy_ecs/src/entity/clone_entities.rs
@@ -651,7 +651,7 @@ impl EntityCloner {
                         target,
                         &bundle_scratch_allocator,
                         &mut bundle_scratch,
-                        world.entities_allocator(),
+                        world.entity_allocator(),
                         info,
                         state,
                         mapper,
diff --git a/crates/bevy_ecs/src/entity/map_entities.rs b/crates/bevy_ecs/src/entity/map_entities.rs
index 552f3493924a9..7fd83859e46b9 100644
--- a/crates/bevy_ecs/src/entity/map_entities.rs
+++ b/crates/bevy_ecs/src/entity/map_entities.rs
@@ -339,7 +339,7 @@ impl<'m> SceneEntityMapper<'m> {
     pub fn new(map: &'m mut EntityHashMap<Entity>, world: &World) -> Self {
         Self {
             map,
-            dead_start: world.allocator.alloc(),
+            dead_start: world.entity_allocator.alloc(),
             generations: 0,
         }
     }
@@ -354,7 +354,7 @@ impl<'m> SceneEntityMapper<'m> {
                 .entities
                 .mark_free(self.dead_start.index(), self.generations)
         };
-        world.allocator.free(reuse_row);
+        world.entity_allocator.free(reuse_row);
     }
 
     /// Creates an [`SceneEntityMapper`] from a provided [`World`] and [`EntityHashMap<Entity>`], then calls the
diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs
index 280d7a764bf96..9e9adf6e744ca 100644
--- a/crates/bevy_ecs/src/entity/mod.rs
+++ b/crates/bevy_ecs/src/entity/mod.rs
@@ -766,7 +766,7 @@ impl EntityAllocator {
     /// ```
     /// # use bevy_ecs::{prelude::*};
     /// let mut world = World::new();
-    /// let entity = world.entities_allocator().alloc();
+    /// let entity = world.entity_allocator().alloc();
     /// // wait as long as you like
     /// let entity_access = world.spawn_empty_at(entity).unwrap(); // or spawn_at(entity, my_bundle)
     /// // treat it as a normal entity
diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index 9069ade2d7082..6074af00ff021 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -366,10 +366,10 @@ mod tests {
     #[test]
     fn spawning_with_manual_entity_allocation() {
         let mut world = World::new();
-        let e1 = world.entities_allocator_mut().alloc();
+        let e1 = world.entity_allocator_mut().alloc();
         world.spawn_at(e1, (TableStored("abc"), A(123))).unwrap();
 
-        let e2 = world.entities_allocator_mut().alloc();
+        let e2 = world.entity_allocator_mut().alloc();
         assert!(matches!(
             world.try_despawn_no_free(e2),
             Err(EntityDespawnError(
@@ -377,9 +377,9 @@ mod tests {
             ))
         ));
         assert!(!world.despawn(e2));
-        world.entities_allocator_mut().free(e2);
+        world.entity_allocator_mut().free(e2);
 
-        let e3 = world.entities_allocator_mut().alloc();
+        let e3 = world.entity_allocator_mut().alloc();
         let e3 = world
             .spawn_at(e3, (TableStored("junk"), A(0)))
             .unwrap()
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index 58859fd88eef7..6419ee7d4e4a6 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -234,7 +234,7 @@ enum InternalQueue<'s> {
 impl<'w, 's> Commands<'w, 's> {
     /// Returns a new `Commands` instance from a [`CommandQueue`] and a [`World`].
     pub fn new(queue: &'s mut CommandQueue, world: &'w World) -> Self {
-        Self::new_from_entities(queue, &world.allocator, &world.entities)
+        Self::new_from_entities(queue, &world.entity_allocator, &world.entities)
     }
 
     /// Returns a new `Commands` instance from a [`CommandQueue`] and an [`Entities`] reference.
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index b59698651a9b7..41d45cd84a29b 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -1697,7 +1697,7 @@ unsafe impl<'a> SystemParam for &'a EntityAllocator {
         world: UnsafeWorldCell<'w>,
         _change_tick: Tick,
     ) -> Self::Item<'w, 's> {
-        world.entities_allocator()
+        world.entity_allocator()
     }
 }
 
diff --git a/crates/bevy_ecs/src/world/deferred_world.rs b/crates/bevy_ecs/src/world/deferred_world.rs
index cb67888873b77..6ef13dd316c46 100644
--- a/crates/bevy_ecs/src/world/deferred_world.rs
+++ b/crates/bevy_ecs/src/world/deferred_world.rs
@@ -75,7 +75,7 @@ impl<'w> DeferredWorld<'w> {
         unsafe {
             Commands::new_raw_from_entities(
                 command_queue,
-                self.world.entities_allocator(),
+                self.world.entity_allocator(),
                 self.world.entities(),
             )
         }
@@ -440,7 +440,7 @@ impl<'w> DeferredWorld<'w> {
         let raw_queue = unsafe { cell.get_raw_command_queue() };
         // SAFETY: `&mut self` ensures the commands does not outlive the world.
         let commands = unsafe {
-            Commands::new_raw_from_entities(raw_queue, cell.entities_allocator(), cell.entities())
+            Commands::new_raw_from_entities(raw_queue, cell.entity_allocator(), cell.entities())
         };
 
         (fetcher, commands)
diff --git a/crates/bevy_ecs/src/world/entity_access/world_mut.rs b/crates/bevy_ecs/src/world/entity_access/world_mut.rs
index 10e5dae4765db..a676a9f52b62d 100644
--- a/crates/bevy_ecs/src/world/entity_access/world_mut.rs
+++ b/crates/bevy_ecs/src/world/entity_access/world_mut.rs
@@ -1726,7 +1726,7 @@ impl<'w> EntityWorldMut<'w> {
     pub(crate) fn despawn_with_caller(mut self, caller: MaybeLocation) {
         self.despawn_no_free_with_caller(caller);
         if let Ok(None) = self.world.entities.get(self.entity) {
-            self.world.allocator.free(self.entity);
+            self.world.entity_allocator.free(self.entity);
         }
 
         // Otherwise:
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index 8157b03a61afc..2493827e12f0d 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -97,7 +97,7 @@ use unsafe_world_cell::UnsafeWorldCell;
 pub struct World {
     id: WorldId,
     pub(crate) entities: Entities,
-    pub(crate) allocator: EntityAllocator,
+    pub(crate) entity_allocator: EntityAllocator,
     pub(crate) components: Components,
     pub(crate) component_ids: ComponentIds,
     pub(crate) archetypes: Archetypes,
@@ -117,7 +117,7 @@ impl Default for World {
         let mut world = Self {
             id: WorldId::new().expect("More `bevy` `World`s have been created than is supported"),
             entities: Entities::new(),
-            allocator: EntityAllocator::default(),
+            entity_allocator: EntityAllocator::default(),
             components: Default::default(),
             archetypes: Archetypes::new(),
             storages: Default::default(),
@@ -213,14 +213,14 @@ impl World {
 
     /// Retrieves this world's [`EntityAllocator`] collection.
     #[inline]
-    pub fn entities_allocator(&self) -> &EntityAllocator {
-        &self.allocator
+    pub fn entity_allocator(&self) -> &EntityAllocator {
+        &self.entity_allocator
     }
 
     /// Retrieves this world's [`EntityAllocator`] collection mutably.
     #[inline]
-    pub fn entities_allocator_mut(&mut self) -> &mut EntityAllocator {
-        &mut self.allocator
+    pub fn entity_allocator_mut(&mut self) -> &mut EntityAllocator {
+        &mut self.entity_allocator
     }
 
     /// Retrieves this world's [`Entities`] collection mutably.
@@ -301,7 +301,7 @@ impl World {
         unsafe {
             Commands::new_raw_from_entities(
                 self.command_queue.clone(),
-                &self.allocator,
+                &self.entity_allocator,
                 &self.entities,
             )
         }
@@ -1026,7 +1026,7 @@ impl World {
         let raw_queue = unsafe { cell.get_raw_command_queue() };
         // SAFETY: `&mut self` ensures the commands does not outlive the world.
         let commands = unsafe {
-            Commands::new_raw_from_entities(raw_queue, cell.entities_allocator(), cell.entities())
+            Commands::new_raw_from_entities(raw_queue, cell.entity_allocator(), cell.entities())
         };
 
         (fetcher, commands)
@@ -1234,7 +1234,7 @@ impl World {
         bundle: MovingPtr<'_, B>,
         caller: MaybeLocation,
     ) -> EntityWorldMut<'_> {
-        let entity = self.allocator.alloc();
+        let entity = self.entity_allocator.alloc();
         // This was just spawned from null, so it shouldn't panic.
         self.spawn_at_unchecked(entity, bundle, caller)
     }
@@ -1270,7 +1270,7 @@ impl World {
     }
 
     pub(crate) fn spawn_empty_with_caller(&mut self, caller: MaybeLocation) -> EntityWorldMut<'_> {
-        let entity = self.allocator.alloc();
+        let entity = self.entity_allocator.alloc();
         // This was just spawned from null, so it shouldn't panic.
         self.spawn_empty_at_unchecked(entity, caller)
     }
@@ -3205,7 +3205,7 @@ impl World {
         self.storages.sparse_sets.clear_entities();
         self.archetypes.clear_entities();
         self.entities.clear();
-        self.allocator.restart();
+        self.entity_allocator.restart();
     }
 
     /// Clears all resources in this [`World`].
diff --git a/crates/bevy_ecs/src/world/unsafe_world_cell.rs b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
index cae3f5d333db7..bed992015b111 100644
--- a/crates/bevy_ecs/src/world/unsafe_world_cell.rs
+++ b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
@@ -266,10 +266,10 @@ impl<'w> UnsafeWorldCell<'w> {
 
     /// Retrieves this world's [`Entities`] collection.
     #[inline]
-    pub fn entities_allocator(self) -> &'w EntityAllocator {
+    pub fn entity_allocator(self) -> &'w EntityAllocator {
         // SAFETY:
         // - we only access world metadata
-        &unsafe { self.world_metadata() }.allocator
+        &unsafe { self.world_metadata() }.entity_allocator
     }
 
     /// Retrieves this world's [`Archetypes`] collection.
diff --git a/release-content/migration-guides/entity_allocator.md b/release-content/migration-guides/entity_allocator.md
new file mode 100644
index 0000000000000..b95479ab83907
--- /dev/null
+++ b/release-content/migration-guides/entity_allocator.md
@@ -0,0 +1,6 @@
+---
+title: "`World::entities_allocator` is now `World::entity_allocator`"
+pull_requests: [22638]
+---
+
+`World::entities_allocator()` has been renamed to `World::entity_allocator()` to match the type returned (`EntityAllocator`). Likewise, `World::entities_allocator_mut()` has been renamed to `World::entity_allocator_mut()`.
