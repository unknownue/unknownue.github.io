diff --git a/crates/bevy_text/src/pipeline.rs b/crates/bevy_text/src/pipeline.rs
index 1f448f43ec931..dce105f4a79da 100644
--- a/crates/bevy_text/src/pipeline.rs
+++ b/crates/bevy_text/src/pipeline.rs
@@ -112,19 +112,21 @@ impl TextPipeline {
 
         computed.entities.clear();
 
-        for (span_index, (entity, depth, span, text_font, color, line_height)) in
-            text_spans.enumerate()
-        {
-            // Save this span entity in the computed text block.
-            computed.entities.push(TextEntity { entity, depth });
-
-            if span.is_empty() {
-                continue;
-            }
+        let result = {
+            for (span_index, (entity, depth, span, text_font, color, line_height)) in
+                text_spans.enumerate()
+            {
+                // Save this span entity in the computed text block.
+                computed.entities.push(TextEntity { entity, depth });
+
+                if span.is_empty() {
+                    continue;
+                }
 
-            let family_name: SmolStr = match &text_font.font {
-                FontSource::Handle(handle) => {
-                    if let Some(font) = fonts.get(handle.id()) {
+                let family_name: SmolStr = match &text_font.font {
+                    FontSource::Handle(handle) => {
+                        // Return early if a font is not loaded yet.
+                        let font = fonts.get(handle.id()).ok_or(TextError::NoSuchFont)?;
                         let data = Arc::clone(&font.data);
                         let ids = font_system
                             .db_mut()
@@ -139,92 +141,77 @@ impl TextPipeline {
                             .0
                             .as_str()
                             .into()
-                    } else {
-                        // Return early if a font is not loaded yet.
-                        spans.clear();
-                        self.spans_buffer = spans
-                            .into_iter()
-                            .map(
-                                |_| -> (
-                                    usize,
-                                    &'static str,
-                                    &'static TextFont,
-                                    FontFaceInfo,
-                                    LineHeight,
-                                ) { unreachable!() },
-                            )
-                            .collect();
-                        return Err(TextError::NoSuchFont);
                     }
-                }
-                FontSource::Family(family) => family.clone(),
-            };
+                    FontSource::Family(family) => family.clone(),
+                };
 
-            let face_info = FontFaceInfo { family_name };
+                let face_info = FontFaceInfo { family_name };
 
-            // Save spans that aren't zero-sized.
-            if scale_factor <= 0.0 || text_font.font_size <= 0.0 {
-                once!(warn!(
-                    "Text span {entity} has a font size <= 0.0. Nothing will be displayed.",
-                ));
+                // Save spans that aren't zero-sized.
+                if scale_factor <= 0.0 || text_font.font_size <= 0.0 {
+                    once!(warn!(
+                        "Text span {entity} has a font size <= 0.0. Nothing will be displayed.",
+                    ));
 
-                continue;
+                    continue;
+                }
+                spans.push((span_index, span, text_font, face_info, color, line_height));
             }
-            spans.push((span_index, span, text_font, face_info, color, line_height));
-        }
-
-        // Map text sections to cosmic-text spans, and ignore sections with negative or zero fontsizes,
-        // since they cannot be rendered by cosmic-text.
-        //
-        // The section index is stored in the metadata of the spans, and could be used
-        // to look up the section the span came from and is not used internally
-        // in cosmic-text.
-        let spans_iter = spans.iter().map(
-            |(span_index, span, text_font, font_info, color, line_height)| {
-                (
-                    *span,
-                    get_attrs(
-                        *span_index,
-                        text_font,
-                        *line_height,
-                        *color,
-                        font_info,
-                        scale_factor,
-                    ),
-                )
-            },
-        );
-
-        // Update the buffer.
-        let buffer = &mut computed.buffer;
-
-        // Set the metrics hinting strategy
-        buffer.set_hinting(font_system, hinting.into());
 
-        buffer.set_wrap(
-            font_system,
-            match linebreak {
-                LineBreak::WordBoundary => Wrap::Word,
-                LineBreak::AnyCharacter => Wrap::Glyph,
-                LineBreak::WordOrCharacter => Wrap::WordOrGlyph,
-                LineBreak::NoWrap => Wrap::None,
-            },
-        );
-
-        buffer.set_rich_text(
-            font_system,
-            spans_iter,
-            &Attrs::new(),
-            Shaping::Advanced,
-            Some(justify.into()),
-        );
-
-        // Workaround for alignment not working for unbounded text.
-        // See https://github.com/pop-os/cosmic-text/issues/343
-        let width = (bounds.width.is_none() && justify != Justify::Left)
-            .then(|| buffer_dimensions(buffer).x)
-            .or(bounds.width);
-        buffer.set_size(font_system, width, bounds.height);
+            // Map text sections to cosmic-text spans, and ignore sections with negative or zero fontsizes,
+            // since they cannot be rendered by cosmic-text.
+            //
+            // The section index is stored in the metadata of the spans, and could be used
+            // to look up the section the span came from and is not used internally
+            // in cosmic-text.
+            let spans_iter = spans.iter().map(
+                |(span_index, span, text_font, font_info, color, line_height)| {
+                    (
+                        *span,
+                        get_attrs(
+                            *span_index,
+                            text_font,
+                            *line_height,
+                            *color,
+                            font_info,
+                            scale_factor,
+                        ),
+                    )
+                },
+            );
+
+            // Update the buffer.
+            let buffer = &mut computed.buffer;
+
+            // Set the metrics hinting strategy
+            buffer.set_hinting(font_system, hinting.into());
+
+            buffer.set_wrap(
+                font_system,
+                match linebreak {
+                    LineBreak::WordBoundary => Wrap::Word,
+                    LineBreak::AnyCharacter => Wrap::Glyph,
+                    LineBreak::WordOrCharacter => Wrap::WordOrGlyph,
+                    LineBreak::NoWrap => Wrap::None,
+                },
+            );
+
+            buffer.set_rich_text(
+                font_system,
+                spans_iter,
+                &Attrs::new(),
+                Shaping::Advanced,
+                Some(justify.into()),
+            );
+
+            // Workaround for alignment not working for unbounded text.
+            // See https://github.com/pop-os/cosmic-text/issues/343
+            let width = (bounds.width.is_none() && justify != Justify::Left)
+                .then(|| buffer_dimensions(buffer).x)
+                .or(bounds.width);
+            buffer.set_size(font_system, width, bounds.height);
+            Ok(())
+        };
 
         // Recover the spans buffer.
         spans.clear();
@@ -241,7 +228,7 @@ impl TextPipeline {
             )
             .collect();
 
-        Ok(())
+        result
     }
 
     /// Queues text for measurement
