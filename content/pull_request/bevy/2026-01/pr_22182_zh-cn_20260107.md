+++
title = "#22182 bevy_asset: support upgrading Reader to SeekableReader"
date = "2026-01-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22182-en-20260107" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22182-zh-cn-20260107" }}
+++

# Title
## 基本特性
- **标题**: bevy_asset: support upgrading Reader to SeekableReader
- **PR链接**: https://github.com/bevyengine/bevy/pull/22182
- **作者**: cart
- **状态**: 已合并
- **标签**: C-Feature, A-Assets, C-Usability, S-Waiting-on-Author
- **创建时间**: 2025-12-18T01:22:30Z
- **合并时间**: 2026-01-07T22:09:38Z
- **合并者**: cart

## 描述翻译
# Objective

#22104 添加了 `AsyncSeek` 支持，但它有一些缺点：

- 它非常“宽松”：它依赖 `AssetLoader` 来“声明”它需要 seek 功能。然而，无论是否需要，AssetLoader 都可以访问 `AsyncSeek` API（因为它是 Reader 的超特性），并且即使没有要求，AssetReader 也会提供 `AsyncSeek` 行为。在实践中，这可能会导致 AssetLoader 不请求 `AsyncSeek` 而默认依赖它，当 AssetLoader 消费者尝试使用不支持 AsyncSeek 的其他 AssetReader 时，会导致意外的兼容性问题。
- 它鼓励在无法直接支持 AsyncSeek 的情况下（例如，将整个内容读入 Vec）在 AssetReader 中构建“回退”行为。从加载器的角度来看，这会默默地改变性能特征，并强制使用特定类型的回退行为。更好的做法是将回退行为交给 AssetLoader 处理。

## Solution

- 移除 `ReaderRequiredFeatures` 和相关功能
- 添加一个新的 `SeekableReader` 特性，其中 `SeekableReader: Reader + AsyncSeek`。
- 添加一个新的 `Reader::seekable(&mut self) -> Result<&mut dyn SeekableReader, ReaderNotSeekableError>`，如果支持，可以失败或转换为 `SeekableReader`。

```rust
let seekable_reader = reader.seekable()?;
seekable_reader.seek(SeekFrom::Start(10)).await?;
```

这为 `AssetLoader` 实现者在处理 `Reader` 功能支持时提供了更清晰的指导，赋予他们对回退行为更多的自主权，使我们的 API 更加静态，并降低了整个系统的复杂性。

## 这个 PR 的故事

这个 PR 的核心是对 Bevy 资产系统中 Reader 功能支持方式的一次重新设计。它解决的问题源于一个看似便利但实则脆弱的抽象。

### 问题和背景

在之前的实现中（PR #22104），系统引入了一个名为 `ReaderRequiredFeatures` 的结构体，允许 `AssetLoader` 声明它需要的 Reader 功能，特别是 `AsyncSeek` 能力。这个设计的初衷是好的：让 AssetLoader 声明需求，AssetReader 可以据此提供合适的实现或回退。

但在实践中，这个设计暴露了两个关键问题：

1. **边界模糊**：由于 `AsyncSeek` 是 `Reader` 的超特性（supertrait），即使 AssetLoader 没有明确请求，它也能访问到 `AsyncSeek` 的方法。这导致了一个矛盾：加载器可能在无意中依赖了 seek 功能，而系统却无法可靠地检测到这种隐式依赖。

2. **回退行为的位置不当**：当 AssetReader 不支持 `AsyncSeek` 时，系统鼓励在 Reader 实现内部进行回退（例如将整个文件读入内存）。这种设计存在两个问题：
   - 性能特征被默默改变：加载器可能不知道它正在使用一个内存缓冲版本，这可能导致意外的内存使用。
   - 回退策略被硬编码在 Reader 中，而不是由最了解自己需求的 AssetLoader 来控制。

### 解决方案

这个 PR 采用了更直接、更静态的方法。它移除了整个 `ReaderRequiredFeatures` 机制，转而引入了一个简单的升级接口：`Reader::seekable()`。

新的设计遵循了“显式优于隐式”的原则：
- 如果一个 Reader 支持 seek，它可以通过实现 `seekable()` 方法来明确声明这一点。
- 如果 AssetLoader 需要 seek 功能，它必须显式调用 `seekable()` 并处理可能失败的情况。
- 回退行为现在完全由 AssetLoader 控制，它们可以根据自己的需求选择最合适的回退策略。

### 实现细节

实现这个改变需要修改 Bevy 资产系统的多个层次：

1. **核心 trait 的重构**：
   - `Reader` trait 不再要求实现 `AsyncSeek`，而是只需要 `AsyncRead`。
   - 新增 `SeekableReader` trait，它组合了 `Reader + AsyncSeek`。
   - 添加 `Reader::seekable()` 方法，允许有条件地将 `Reader` 升级为 `SeekableReader`。

2. **接口简化**：
   - `AssetReader::read()` 方法移除了 `required_features` 参数。
   - 所有 AssetReader 实现（文件、内存、Android、Web 等）都相应更新。

3. **错误处理**：
   - 引入 `ReaderNotSeekableError` 替代之前的 `UnsupportedReaderFeature`。
   - 错误类型更简单、更专注。

```rust
// 之前：通过特征请求声明需求
let reader = asset_reader.read(path, ReaderRequiredFeatures { seek: SeekKind::AnySeek }).await?;

// 之后：显式尝试升级
let mut reader = asset_reader.read(path).await?;
let seekable_reader = reader.seekable()?;
seekable_reader.seek(SeekFrom::Start(10)).await?;
```

### 技术洞察

这个设计改变带来了几个重要的技术优势：

1. **更清晰的契约**：现在，Reader 和 AssetLoader 之间的契约更加明确。要么 Reader 支持 seek（通过实现 `seekable()`），要么不支持。没有中间的模糊状态。

2. **更好的关注点分离**：回退行为现在完全由 AssetLoader 控制。这意味着：
   - 加载器可以根据资产大小决定是否使用内存缓冲。
   - 加载器可以实现更复杂的回退策略，比如部分预读。
   - 性能特征对加载器是透明的，不会在背后被改变。

3. **减少复杂性**：移除了 `ReaderRequiredFeatures`、`SeekKind`、`UnsupportedReaderFeature` 等类型，简化了类型系统和 API 表面积。

4. **更好的编译时检查**：由于 seek 功能现在通过 trait 转换显式获取，编译器可以更好地跟踪哪些代码路径需要 seek 支持。

### 影响

这个改变影响了整个资产系统：

1. **向后兼容性**：对于大多数现有代码，这个改变是透明的。所有内置的 Reader 实现都继续支持 seek，只是通过新的接口暴露。

2. **迁移需求**：
   - 自定义 `AssetLoader` 实现如果依赖 seek 功能，现在需要显式调用 `reader.seekable()`。
   - 自定义 `Reader` 实现需要实现 `seekable()` 方法。
   - 直接使用 `AsyncSeekForward` trait 的代码需要迁移到使用标准的 `AsyncSeek` trait。

3. **性能考虑**：这个改变本身不应该引入性能回归。如果 AssetLoader 选择实现内存回退，那么性能特征将由加载器明确控制，而不是隐藏在 Reader 实现中。

## 视觉表示

```mermaid
graph TD
    A[AssetReader] --> B[提供 Reader]
    B --> C{是否支持 seek?}
    C -->|是| D[实现 seekable() 返回 SeekableReader]
    C -->|否| E[实现 seekable() 返回错误]
    D --> F[AssetLoader 可以调用 seek 方法]
    E --> G[AssetLoader 实现自己的回退策略]
    
    H[Reader trait] --> I[AsyncRead]
    H --> J[seekable() 方法]
    K[SeekableReader trait] --> H
    K --> L[AsyncSeek]
```

## 关键文件更改

### `crates/bevy_asset/src/io/mod.rs` (+61/-94)
这是最重要的更改文件，定义了核心的 trait 和类型。

**主要更改：**
1. 移除了 `ReaderRequiredFeatures`、`SeekKind` 和 `UnsupportedReaderFeature` 类型。
2. 修改了 `Reader` trait，不再要求 `AsyncSeek`，添加了 `seekable()` 方法。
3. 新增 `SeekableReader` trait 和 `ReaderNotSeekableError` 错误类型。
4. 更新了 `AssetReader` trait，移除了 `read()` 方法中的 `required_features` 参数。

**代码片段：**
```rust
// 之前：
pub trait Reader: AsyncRead + AsyncSeek + Unpin + Send + Sync {
    // ...
}

pub struct ReaderRequiredFeatures {
    pub seek: SeekKind,
}

// 之后：
pub trait Reader: AsyncRead + Unpin + Send + Sync {
    // ...
    fn seekable(&mut self) -> Result<&mut dyn SeekableReader, ReaderNotSeekableError>;
}

pub trait SeekableReader: Reader + AsyncSeek {}

#[derive(Error, Debug, Copy, Clone)]
#[error(
    "The `Reader` returned by the current `AssetReader` does not support `AsyncSeek` behavior."
)]
pub struct ReaderNotSeekableError;
```

### `crates/bevy_asset/src/processor/process.rs` (+1/-32)
处理资产处理逻辑的更改。

**主要更改：**
1. 移除了 `Process` trait 中的 `reader_required_features` 方法。
2. 移除了 `ErasedProcessor` trait 中相应的方法。

**代码片段：**
```rust
// 之前：
pub trait Process: TypePath + Send + Sync + Sized + 'static {
    // ...
    fn reader_required_features(_settings: &Self::Settings) -> ReaderRequiredFeatures {
        ReaderRequiredFeatures::default()
    }
}

// 之后：该方法被完全移除
```

### `crates/bevy_asset/src/io/processor_gated.rs` (+10/-19)
处理处理器门控读取器的更改。

**主要更改：**
1. `TransactionLockedReader` 不再实现 `AsyncSeek`，而是通过 `Reader::seekable()` 委托给内部的 reader。
2. 简化了实现，移除了直接的 seek 实现。

**代码片段：**
```rust
// 之前：
impl AsyncSeek for TransactionLockedReader<'_> {
    fn poll_seek(
        mut self: Pin<&mut Self>,
        cx: &mut core::task::Context<'_>,
        pos: SeekFrom,
    ) -> Poll<std::io::Result<u64>> {
        Pin::new(&mut self.reader).poll_seek(cx, pos)
    }
}

// 之后：
impl Reader for TransactionLockedReader<'_> {
    // ...
    fn seekable(&mut self) -> Result<&mut dyn SeekableReader, ReaderNotSeekableError> {
        self.reader.seekable()
    }
}
```

### `crates/bevy_asset/src/processor/mod.rs` (+3/-25)
资产处理器的主要模块。

**主要更改：**
1. 移除了对 `ReaderRequiredFeatures` 的依赖。
2. 简化了代码，不再需要传递特征需求。

**代码片段：**
```rust
// 之前：
let reader_for_process = reader
    .read(path, reader_features)
    .await
    .map_err(reader_err)?;

// 之后：
let reader_for_process = reader.read(path).await.map_err(reader_err)?;
```

### `release-content/migration-guides/seekable_readers.md` (+28/-0)
新增的迁移指南，帮助用户适应这些更改。

**内容：**
```markdown
---
title: `Reader` 的实现现在必须实现 `Reader::seekable`，并且 `AsyncSeekForward` 被删除。
pull_requests: [22182]
---

`Reader` trait 不再要求实现 `AsyncSeekForward`，而是要求实现 `Reader::seekable`，
如果支持 `AsyncSeek`，该方法会将 `Reader` 转换为 `&mut dyn SeekableReader`（`SeekableReader: Reader + AsyncSeek`）。

```rust
// 如果 MyReader 实现 `AsyncSeek`
impl Reader for MyReader {
    fn seekable(&mut self) -> Result<&mut dyn SeekableReader, ReaderNotSeekableError> {
        Ok(self)
    }
}

// 如果 MyReader 不实现 `AsyncSeek`
impl Reader for MyReader {
    fn seekable(&mut self) -> Result<&mut dyn SeekableReader, ReaderNotSeekableError> {
        Err(ReaderNotSeekableError)
    }
}
```

由于我们现在只使用 `AsyncSeek` trait，我们删除了 `AsyncSeekForward` trait。
使用此 trait 的用户可以通过使用 `SeekFrom::Current(offset)` 调用 `AsyncSeek::poll_seek` 方法，
或使用 `AsyncSeekExt::seek` 方法进行迁移。
```

## 进一步阅读

1. **原始 PR #22104**: 引入了 `AsyncSeek` 支持，这个 PR 是对其设计的改进。
2. **Rust 的 Trait 系统**: 理解 trait 继承和超特性对于理解这个更改很重要。
3. **Bevy 资产系统文档**: 了解 Bevy 如何处理资产加载和处理。
4. **显式与隐式接口设计**: 这个 PR 是显式接口设计优点的典型案例。