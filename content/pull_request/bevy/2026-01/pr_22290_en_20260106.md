+++
title = "#22290 fix: add unwind safety to `resource_scope`"
date = "2026-01-06T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22290-en-20260106" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22290-zh-cn-20260106" }}
labels = ["C-Bug", "A-ECS", "D-Complex"]
+++

# Title
## Basic Information
- **Title**: fix: add unwind safety to `resource_scope`
- **PR Link**: https://github.com/bevyengine/bevy/pull/22290
- **Author**: joseph-gio
- **Status**: MERGED
- **Labels**: C-Bug, A-ECS, S-Ready-For-Final-Review, D-Complex, X-Uncontroversial
- **Created**: 2025-12-28T01:28:50Z
- **Merged**: 2026-01-05T23:43:56Z
- **Merged By**: alice-i-cecile

## Description Translation
The function `World::resource_scope` is a primitive that allows the user to get mutable access to a resource and the rest of the world at the same time. This is incredibly useful for exclusive systems, implementations of `Command`, and custom abstractions. It works by temporarily removing the resource from the world and running a user-provided closure with mutable access to both. After the closure completes, the resource is re-inserted into the world for other code to use.

With the current implementation, any panics originating in the user-provided closure will result in the resource being lost. This is problematic for a couple of reasons:
* Any users wishing to utilize `std::panic::catch_unwind` have to deal with the fact that the panic has left the world in an invalid state.
  * While some individuals consider catch_unwind to be bad practice, it is a native feature of Rust that we should provide support for. In certain situations it is quite valuable:
    * When creating apps targeting production, it is crucial to avoid hard-crashing on users, and in many cases it is not reasonable to ensure that every code path will always complete successfully. catch_unwind is useful for capturing panics and shifting into a controlled error state. This is hard to do when the world is left in an invalid state.
    * It is often useful to _localize_ panics, rather than fully recover from them. When using threads or async tasks, the usual default is to localize panics to the original context that caused them. When implementing abstractions that give async tasks access to the world, it is useful to capture panics and propagate them back to the async context.
* Panics occurring inside of `resource_scope` can lead to knock-on errors, which can make debugging more difficult, as the user may need to sort through many errors to identify which one was the root cause.

The objective here is to make resource_scope panic-safe, ensuring that the resource is always restored to the world when unwinding from a panic (on platforms that support unwinding; `panic=abort` is unrecoverable by design). This enables more robust panic handling, and allows for more graceful shutdown sequences when panics are truly fatal.

## Solution

Add a "guard" type that captures mutable access to the world and temporary ownership of the resource. This type has a `Drop` implementation that is responsible for re-inserting the resource at the end of the scope -- this pattern is similar to `try ... finally` blocks in many languages.

## Testing

* Added a test that verifies the resource is properly restored when unwinding from `resource_scope`.
* Added a regression test for an existing edge-case triggered by `World::clear_resources` or `World::clear_all`.

## The Story of This Pull Request

The `World::resource_scope` method in Bevy's ECS provides a critical primitive: it allows code to temporarily take exclusive ownership of a resource while still having mutable access to the rest of the world. This is essential for exclusive systems, custom commands, and various abstractions that need to operate on a resource while also modifying other parts of the world.

The original implementation followed a straightforward pattern: remove the resource from the world, run the user's closure with access to the resource and world, then re-insert the resource. However, this approach had a significant flaw - if the user's closure panicked, the resource would never be re-inserted, leaving the world in an invalid state.

This problem manifested in several concrete scenarios. Developers using `std::panic::catch_unwind` for production applications found their worlds corrupted after panics, making controlled error recovery impossible. Those implementing async task systems that needed to isolate panics to individual tasks discovered that panics in `resource_scope` would leak resources and cause cascading failures. Even in debugging scenarios, the loss of resources created confusing knock-on errors that obscured the original problem.

The solution implements a guard pattern using Rust's drop semantics. The key insight is that by wrapping the temporary resource ownership in a struct with a custom `Drop` implementation, we can guarantee the resource gets re-inserted regardless of how the closure exits - whether through normal completion, early return, or panic unwinding.

The implementation introduces a `ReinsertGuard` struct that holds:
- A mutable reference to the world
- The component ID of the resource
- The resource value wrapped in `ManuallyDrop`
- The component ticks and caller metadata
- A boolean flag tracking successful re-insertion

The guard's `Drop` implementation handles several edge cases intelligently. If the resource was already re-inserted by user code during the scope (which typically indicates a logic error), the behavior differs between debug and release builds. In debug builds, it panics to alert developers during development. In release builds, it logs a warning and overwrites the user-inserted value with the original one. This pragmatic approach balances safety during development with robustness in production.

A subtle but important optimization is the use of a `was_successful` boolean flag. This tracks whether the guard successfully re-inserted the resource, avoiding the need for separate code paths for normal vs panicking control flow. The method returns `Some(result)` only if re-insertion succeeded, maintaining the existing API contract while adding unwind safety.

The implementation also includes careful handling of the case where resource metadata is cleared during the scope (via `World::clear_resources`). In this scenario, the guard's drop implementation detects that the resource data is no longer present and simply drops the resource value without attempting re-insertion. This maintains backward compatibility with existing behavior while ensuring resources aren't leaked.

Two new tests validate the implementation. The `resource_scope_unwind` test verifies that resources are properly restored after a panic, using `std::panic::catch_unwind` to simulate panic recovery. The `resource_scope_resources_cleared` test documents and preserves the existing edge-case behavior when resources are cleared within the scope, serving as a regression test for future maintainers.

This change demonstrates a common Rust pattern for resource management: using `Drop` implementations to ensure cleanup happens regardless of control flow. It's particularly relevant for ECS systems where resource ownership and lifetimes are critical to maintaining invariants. The implementation shows careful attention to both development experience (with helpful panic messages in debug builds) and production robustness (with non-panicking behavior in release builds).

## Visual Representation

```mermaid
graph TD
    A[World::resource_scope called] --> B[Remove resource from world]
    B --> C[Create ReinsertGuard with resource]
    C --> D[Run user closure]
    D --> E{Closure exits normally?}
    E -->|Yes| F[Guard.drop() re-inserts resource]
    E -->|No - Panic| G[Unwind begins]
    G --> H[Guard.drop() re-inserts resource]
    F --> I[Return Some(result)]
    H --> J[Panic propagates]
    
    subgraph "ReinsertGuard::drop logic"
        K[Check if resource already present]
        K --> L{Resource present?}
        L -->|No| M[Insert resource]
        L -->|Yes| N[Debug: Panic/Release: Warn]
        N --> O[Overwrite with original value]
        M --> P[Set was_successful = true]
        O --> P
    end
```

## Key Files Changed

### `crates/bevy_ecs/src/world/mod.rs` (+104/-30)
This file contains the core implementation change to `try_resource_scope`. The method was completely rewritten to use the `ReinsertGuard` pattern.

**Key changes:**
1. Added the `ReinsertGuard` struct with custom `Drop` implementation
2. Modified the control flow to use the guard for resource management
3. Added debug/release differentiation for handling resource re-insertion during scope

**Code snippet showing the guard implementation:**
```rust
// type used to manage reinserting the resource at the end of the scope. use of a drop impl means that
// the resource is inserted even if the user-provided closure unwinds.
// this facilitates localized panic recovery and makes app shutdown in response to a panic more graceful
// by avoiding knock-on errors.
struct ReinsertGuard<'a, R> {
    world: &'a mut World,
    component_id: ComponentId,
    value: ManuallyDrop<R>,
    ticks: ComponentTicks,
    caller: MaybeLocation,
    was_successful: &'a mut bool,
}
impl<R> Drop for ReinsertGuard<'_, R> {
    fn drop(&mut self) {
        // take ownership of the value first so it'll get dropped if we return early
        // SAFETY: drop semantics ensure that `self.value` will never be accessed again after this call
        let value = unsafe { ManuallyDrop::take(&mut self.value) };

        let Some(resource_data) = self.world.storages.resources.get_mut(self.component_id)
        else {
            return;
        };

        // in debug mode, raise a panic if user code re-inserted a resource of this type within the scope.
        // resource insertion usually indicates a logic error in user code, which is useful to catch at dev time,
        // however it does not inherently lead to corrupted state, so we avoid introducing an unnecessary crash
        // for production builds.
        if resource_data.is_present() {
            #[cfg(debug_assertions)]
            {
                // if we're already panicking, log an error instead of panicking, as double-panics result in an abort
                #[cfg(feature = "std")]
                if std::thread::panicking() {
                    log::error!("Resource `{}` was inserted during a call to World::resource_scope, which may result in unexpected behavior.\n\
                           In release builds, the value inserted will be overwritten at the end of the scope.",
                           DebugName::type_name::<R>());
                    // return early to maintain consistent behavior with non-panicking calls in debug builds
                    return;
                }

                panic!("Resource `{}` was inserted during a call to World::resource_scope, which may result in unexpected behavior.\n\
                       In release builds, the value inserted will be overwritten at the end of the scope.",
                       DebugName::type_name::<R>());
            }
            #[cfg(not(debug_assertions))]
            {
                #[cold]
                #[inline(never)]
                fn warn_reinsert(resource_name: &str) {
                    warn!(
                        "Resource `{resource_name}` was inserted during a call to World::resource_scope: the inserted value will be overwritten.",
                    );
                }

                warn_reinsert(&DebugName::type_name::<R>());
            }
        }

        OwningPtr::make(value, |ptr| {
            // SAFETY: ptr is of type `R`, which corresponds to the same component ID used to retrieve the resource data.
            unsafe {
                resource_data.insert_with_ticks(ptr, self.ticks, self.caller);
            }
        });

        *self.was_successful = true;
    }
}
```

### `crates/bevy_ecs/src/lib.rs` (+35/-0)
This file contains the new tests for unwind safety and edge-case behavior.

**Key changes:**
1. Added `resource_scope_unwind` test to verify panic recovery
2. Added `resource_scope_resources_cleared` test for the clear_resources edge case

**Code snippet showing the unwind test:**
```rust
#[cfg(feature = "std")]
#[test]
fn resource_scope_unwind() {
    #[derive(Debug, PartialEq)]
    struct Panic;

    let mut world = World::default();
    assert!(world.try_resource_scope::<ResA, _>(|_, _| {}).is_none());
    world.insert_resource(ResA(0));
    let panic = std::panic::catch_unwind(core::panic::AssertUnwindSafe(|| {
        world.resource_scope(|world: &mut World, _value: Mut<ResA>| {
            assert!(!world.contains_resource::<ResA>());
            std::panic::panic_any(Panic);
        });
        unreachable!();
    }));
    assert_eq!(panic.unwrap_err().downcast_ref::<Panic>(), Some(&Panic));
    assert!(world.contains_resource::<ResA>());
}
```

## Further Reading

1. **Rust's Unwind Safety**: The Rustonomicon chapter on [Exception Safety](https://doc.rust-lang.org/nomicon/exception-safety.html) explains the concepts behind panic safety and unwind safety.

2. **RAII Pattern**: The guard pattern used here is an example of Resource Acquisition Is Initialization (RAII). The [Rust Book section on Drop](https://doc.rust-lang.org/book/ch15-03-drop.html) covers this fundamental Rust pattern.

3. **Bevy ECS Resources**: The [Bevy ECS Resources documentation](https://bevy-cheatbook.github.io/programming/resources.html) provides context on how resources are used in Bevy's Entity Component System.

4. **std::panic Module**: The [std::panic module documentation](https://doc.rust-lang.org/std/panic/index.html) covers Rust's panic handling mechanisms, including `catch_unwind`.

5. **ManuallyDrop**: The [std::mem::ManuallyDrop documentation](https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html) explains how to control drop order and manual destruction of values.