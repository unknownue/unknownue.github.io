+++
title = "#21837 通过每关节包围盒改进蒙皮网格的视锥体剔除"
date = "2026-01-26T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-21837-en-20260126" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-21837-zh-cn-20260126" }}
+++

# Title

## 基本信息
- **标题**: 通过每关节包围盒改进蒙皮网格的视锥体剔除
- **PR链接**: https://github.com/bevyengine/bevy/pull/21837
- **作者**: greeble-dev
- **状态**: 已合并
- **标签**: C-Bug, C-Feature, A-Rendering, S-Ready-For-Final-Review, A-Animation, M-Release-Note
- **创建时间**: 2025-11-14T11:57:46Z
- **合并时间**: 2026-01-26T04:53:29Z
- **合并者**: alice-i-cecile

## 描述翻译
**目标**
主要修复 #4971，通过添加一个新选项来根据关节变换更新蒙皮网格的 `Aabb` 组件。

https://github.com/user-attachments/assets/c25b31fa-142d-462b-9a1d-012ea928f839

这修复了顶点位置仅通过蒙皮（skinning）修改的情况。它不修复其他情况，例如变形目标（morph targets）和顶点着色器。

该PR在某种程度上将 [`bevy_mod_skinned_aabb`](https://github.com/greeble-dev/bevy_mod_skinned_aabb) 功能上游化了，但做了一些改动，使其更简单、更可靠。

**依赖关系**
- （已合并）#21732（或类似改动）是可取的，以使新选项能够与仅使用 `RenderAssetUsages::RENDER_WORLD` 的网格一起工作。
   - 此PR的编写方式假设21732已经落地。但如果那没有发生，我可以调整此PR以注明限制。
- （可选）#21845 添加了一个与蒙皮网格包围盒相关的选项。
   - 任一PR都可以先合并 - 后一个需要相应更新。

**背景**
如果主世界中的一个实体有 `Mesh3d` 组件，那么它会自动获得一个 `Aabb` 组件。这是由 `bevy_camera` 或 `bevy_gltf` 完成的。`Aabb` 被 `bevy_camera` 用于视锥体剔除（frustum culling）。它也可以被 `bevy_picking` 用作优化，或被第三方crate使用。

但有个问题 - 如果在 `Aabb` 计算之后有东西改变了网格的顶点位置，那么 `Aabb` 可能是错误的。这可以通过顶点着色器完成 - 特别是蒙皮和变形目标 - 或者通过修改 `Mesh` 资产 (#4294)。

对于蒙皮的情况，最常见的解决方案是通过 `NoFrustumCulling` 组件禁用视锥体剔除。这很简单，并且对于网格倾向于停留在屏幕上的应用来说，甚至可能是最高效的方法。但它实现起来很烦人，对于网格经常离开屏幕的应用来说很糟糕，而且它只修复视锥体剔除 - 它不能帮助其他使用 `Aabb` 的系统。

**解决方案**
本PR添加了一种可靠且相当高效的方法，用于根据蒙皮网格的动画关节变换更新其 `Aabb`。更多细节请参见“它是如何工作的”部分。

如果启用了 `GltfPlugin` 或 `GltfLoaderSettings` 中的一个新选项 `GltfSkinnedMeshBoundsPolicy`，glTF加载器可以自动为蒙皮网格添加包围盒：

```rust
app.add_plugins(DefaultPlugins.set(GltfPlugin {
    skinned_mesh_bounds_policy: GltfSkinnedMeshBoundsPolicy::Dynamic,
    ..default()
}))
```

_默认启用新的glTF加载器选项_。我认为这是一个正确的选择，原因如下：
- 由蒙皮网格剔除引起的bug一直是新用户和有经验用户的常见痛点。现在最常见的情况可以“开箱即用”（Just Works™）。
- CPU成本适中（见后面部分），高级用户可以退出。
- GPU受限的应用如果用户之前禁用了剔除，可能会看到性能提升。

非glTF情况需要一些手动步骤。用户必须要求 `Mesh` 生成蒙皮网格包围盒，然后将 `DynamicSkinnedMeshBounds` 标记组件添加到他们的网格实体。

```rust
mesh.generate_skinned_mesh_bounds()?;
let mesh_asset = mesh_assets.add(mesh);
entity.insert((Mesh3d(mesh_asset), DynamicSkinnedMeshBounds));
```

实际代码请参见 `custom_skinned_mesh` 示例。

**额外功能**

**`GltfSkinnedMeshBoundsPolicy::NoFrustumCulling`**
这是一个方便的功能，适用于那些更喜欢 `NoFrustumCulling` 解决方法，但又想在glTF场景生成后避免手动添加它的麻烦的用户。

```rust
app.add_plugins(DefaultPlugins.set(GltfPlugin {
    skinned_mesh_bounds_policy: GltfSkinnedMeshBoundsPolicy::NoFrustumCulling,
    ..default()
}))
```

PR #21845 也在添加一个与蒙皮网格包围盒相关的选项。如果那个PR先合并，我也没问题 - 我会更新此PR以包含该选项。

**Gizmos**
`bevy_gizmos::SkinnedMeshBoundsGizmoPlugin` 可以绘制每个关节的AABB。

```rust
fn toggle_skinned_mesh_bounds(mut config: ResMut<GizmoConfigStore>) {
    config.config_mut::<SkinnedMeshBoundsGizmoConfigGroup>().1.draw_all ^= true;
}
```

名称有待商榷。严格来说，它绘制的不是蒙皮网格的包围盒 - 它绘制的是构成蒙皮网格包围盒的每个关节的包围盒。

**测试**
```sh
cargo run --example test_skinned_mesh_bounds

# 按 `B` 显示网格包围盒，按 'J' 显示关节包围盒。
cargo run --example scene_viewer --features "free_camera" -- "assets/models/animated/Fox.glb"
cargo run --example scene_viewer --features "free_camera" -- "assets/models/SimpleSkin/SimpleSkin.gltf"

# 更复杂的网格，从 https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/RecursiveSkeletons 下载
cargo run --example scene_viewer --features "free_camera" -- "RecursiveSkeletons.glb"

cargo run --example custom_skinned_mesh
```

我还修改了 `custom_skinned_mesh` 来模拟旋转和屏幕外实体等棘手情况。

**它是如何工作的？**
<details><summary>点击展开</summary>

**总结**
`Mesh::generate_skinned_mesh_bounds` 为网格中的每个关节计算一个AABB - 该AABB包围了所有蒙皮到该关节的顶点。然后每一帧，`bevy_camera::update_skinned_mesh_bounds` 使用当前的关节变换计算一个包围所有关节AABB的 `Aabb`。

这种方法是可靠的，因为最终的 `Aabb` 将始终包围蒙皮后的顶点。但它可能比实际需要的大。实际上，它足够紧凑，是有用的，并且很少超过50%。

即使存在非刚体变换和软蒙皮，这种方法也有效。如果有任何疑问，我可以添加更多细节。

**棘手之处**
解决方案并不像它可能的那样简单和高效。

**问题1：关节变换是世界空间的，`Aabb` 是实体空间的。**
- 理想情况下，我们会使用世界空间的关节变换来计算世界空间的 `Aabb`，但这不可能。
- 明显的解决方案是将关节变换到实体空间，这样 `Aabb` 就可以直接在实体空间中计算。
   - 但这意味着每个关节需要额外的矩阵乘法。
- 本PR在世界空间中计算 `Aabb`，然后将其变换到实体空间。
   - 这避免了每个关节的矩阵乘法，但可能会增加 `Aabb` 的大小。

**问题2：关节AABB位于一个令人惊讶的空间中。**
- 从网格创建关节AABB时，直观的解决方案是在关节空间中计算它们。
   - 然后更新时只需要用世界空间的关节变换变换它们。
- 但要在关节空间中计算它们，我们需要绑定姿势的顶点位置和绑定姿势的关节变换。
   - 这两部分位于不同的资产中 - `Mesh` 和 `SkinnedMeshInverseBindposes` - 并且这些资产可以混合和匹配。
   - 因此我们需要为每个 `Mesh` 和 `SkinnedMeshInverseBindposes` 的组合计算一个 `SkinnedMeshBoundsAsset`。
   - (`bevy_mod_skinned_aabb` 使用这种方法 - 它速度慢且脆弱。）
- 本PR在*网格空间*（或更严格地说：绑定姿势空间）中计算关节AABB。
   - 这可以仅使用 `Mesh` 资产完成。
- 一个缺点是更新时需要额外的矩阵乘法，以便从网格空间转换到世界空间。
   - 然而，如果视锥体剔除发生变化，这可能成为性能优势 - 参见“未来选项”部分。
- 另一个小缺点是网格空间的AABB（下图中红色）往往比关节空间的AABB（绿色）大，因为具有一个长轴的关节在网格空间中可能处于一个尴尬的角度。

<img width="1085" height="759" alt="image" src="https://github.com/user-attachments/assets/a02a28c3-8882-412c-9be1-64109b767da7" />

**未来选项**
对于视锥体剔除，有一种巧妙的方法可以优化和简化蒙皮网格包围盒的计算 - 将视锥体剔除放到渲染器中，并在 `extract_skins` 期间计算世界空间的AABB。关节变换将已经加载并处于正确的空间，因此我们可以避免实体查找和矩阵乘法。我估计这会使蒙皮网格包围盒计算快3倍。

另一个选项是更改主世界的视锥体剔除，使其使用世界空间的AABB。因此会有一个新的 `GlobalAabb` 组件，每帧根据 `Aabb` 和实体变换进行更新（这基本上类似于变换传播以及 `Transform` 和 `GlobalTransform` 之间的关系）。这有一些优点和缺点，但我不在这里详述 - 我认为将视锥体剔除放到渲染器中是更好的选择。

（请注意，将视锥体剔除放到渲染器中并不意味着移除当前主世界的可见性系统 - 它只是意味着主世界系统将成为单独的可选系统）

</details>

**性能**
<details><summary>点击展开</summary>

**初始化**
为 `Fox.glb`（576个顶点，22个蒙皮关节）创建蒙皮网格包围盒资产需要 **0.03毫秒**。加载整个glTF需要8.7毫秒，所以这是 **<1% 的增加**。

**每帧**
`many_foxes` 示例有1000个蒙皮网格，每个有22个蒙皮关节。更新蒙皮网格包围盒需要 **0.086毫秒**。这大约是每毫秒250,000个关节的吞吐量，使用两个线程。

<img width="2404" height="861" alt="image" src="https://github.com/user-attachments/assets/c27165ae-dc6c-4f6b-bbfb-4e211ab0263c" />

整个动画更新需要3.67毫秒（其中“动画更新” = 推进播放器 + 图求值 + 变换传播）。所以我们可以粗略地声称，此PR将蒙皮动画的成本增加了大约 **3%**。但这非常粗略，且取决于具体情况。

这是在AMD Ryzen 7900上测试的，但使用了 `TaskPoolOptions::with_num_threads(6)` 来模拟低规格CPU。与其他几种线程选项进行比较：
- 非并行：**0.141毫秒**。
- 6个线程（2个计算线程）：**0.086毫秒**。
- 24个线程（15个计算线程）：**0.051毫秒**。

所以并行迭代器更好，但随着线程数增加，很快会遇到收益递减。

**未来选项**
“它是如何工作的”部分提到了将蒙皮网格包围盒计算移到渲染器的皮肤提取中。基于一些微基准测试，我估计这会将非并行的 `many_foxes` 从0.141毫秒减少到0.049毫秒，大约快3倍。要求AVX2（以实现广播加载）或预分散（为SSE模拟广播加载）可以再减少25%。更花哨的SIMD方法可以做得更好。

还有一些方法以可靠性换取性能。对于角色装备，一个有效的优化是将脸部和手指关节折叠到头和手关节的单个包围盒中。这可以将所需的关节数量减少50-80%。

</details>

**常见问题**
<details><summary>点击展开</summary>

**为什么不能自动添加到任何网格？这样glTF导入器和自定义网格生成器就不需要特殊逻辑了。**
`bevy_mod_skinned_aabb` 采用了自动方法，我认为结果并不好。它需要一些相当繁琐和脆弱的逻辑来决定实体何时拥有正确组合的资产并处于正确的加载状态。而且它永远无法与 `RenderAssetUsages::RENDER_WORLD` 一起工作。

因此，本PR采用了更保守和手动的方法。我认为随着资产管道的成熟，有很大的空间进行泛化和自动化。如果glTF导入器变成更纯粹的glTF -> BSN变换，那么添加蒙皮网格包围盒可以成为一个通用的场景/资产变换，与其他导入器和自定义网格生成器共享。

**为什么数据在 `Mesh` 中？难道不应该放到 `SkinnedMesh` 或 `SkinnedMeshInverseBindposes` 中吗？**
这看起来直观，但实际上行不通 - 数据仅从 `Mesh` 派生。`SkinnedMesh` 不行，因为它是每个网格实例的，所以数据会被重复。`SkinnedMeshInverseBindposes` 不行，因为它可以在多个网格之间共享。

名称有点误导性 - `Mesh` 确实包含一些蒙皮数据，而 `SkinnedMesh` 和 `SkinnedMeshInverseBindposes` 更像是与顶点数据隔了一层的关节绑定。

**为什么不把包围盒放在关节实体上？**
这在实践中出奇地棘手，因为多个网格可以绑定到同一个关节实体。因此需要逻辑来跟踪绑定，并在网格被添加和移除时更新包围盒。

**为什么需要 `DynamicSkinnedMeshBounds` 组件？**
这是一个针对想要退出的用户的优化。它也可能对未来的扩展有用，例如添加选项用附加到单个关节的AABB来近似包围盒。

**为什么更新系统和 `DynamicSkinnedMeshBounds` 组件在 `bevy_camera` 中？难道不应该在 `bevy_mesh` 中吗？**
`bevy_camera` 是 `Aabb` 的所有者和主要用户，并且已经有了一些与网格相关的逻辑（`calculate_bounds` 自动为网格实体添加 `Aabb`）。所以把它放在 `bevy_camera` 中与当前结构是一致的。我同意这有点尴尬，未来可能会改变。

</details>

**其他引擎的做法**
<details><summary>点击展开</summary>

- **Unreal**：自动使用附加到关节的[碰撞形状](https://dev.epicgames.com/documentation/en-us/unreal-engine/physics-asset-editor-in-unreal-engine)，这实际上与本PR类似，但脆弱且低效。也支持各种固定包围盒选项。
- **Unity**：附着到根骨骼的固定包围盒。从动画姿势自动计算或手动指定（[文档](https://docs.unity3d.com/6000.4/Documentation/Manual/troubleshooting-skinned-mesh-renderer-visibility.html)）。
- **Godot**：似乎使用与本PR大致相同的方法，尽管我没有100%确认。参见 [`MeshStorage::mesh_get_aabb`](https://github.com/godotengine/godot/blob/fafc07335bdecacd96b548c4119fbe1f47ee5866/servers/rendering/renderer_rd/storage_rd/mesh_storage.cpp#L650) 和 [`RendererSceneCull::_update_instance_aabb`](https://github.com/godotengine/godot/blob/235a32ad11f40ecba26d6d9ceea8ab245c13adb0/servers/rendering/renderer_scene_cull.cpp#L1991)。
- **O3DE**：附着到根骨骼的固定包围盒，加上从关节原点和修正因子近似AABB的选项。
- **Northlight**（Remedy，Alan Wake 2）：专门针对植被，在GPU上根据关节范围计算包围盒（[来源](https://gdcvault.com/play/1034310/Large-Scale-GPU-Based-Skinning)，第48张幻灯片）

有人多次为Bevy提议采用Unity的“从动画姿势固定AABB”方法。我认为这比许多人预期的更复杂且更不可靠。更复杂是因为将动画链接到网格通常很困难。更不可靠是因为它不考虑布娃娃和程序动画。但对于简单情况，比如具有基本动画的单个自包含glTF，它仍然可行。

</details>

## 本次PR的故事

在渲染引擎中，视锥体剔除是一个关键的性能优化技术，用于避免渲染不在摄像机视野内的物体。然而，对于使用骨骼动画的蒙皮网格，一个长期存在的问题困扰着开发者和用户：由于网格的包围盒（AABB）在绑定姿势下计算，而动画会改变顶点位置，导致网格在动画过程中被错误地剔除，产生闪烁或消失的现象（如问题 #4971 所描述）。

**问题与背景**
在Bevy引擎的当前实现中，当实体拥有 `Mesh3d` 组件时，系统会自动为其计算一个轴对齐包围盒（`Aabb`），该包围盒用于决定实体是否在摄像机的视锥体内。这个计算发生在网格加载时，基于其静态的顶点位置。然而，蒙皮动画通过顶点着色器（基于 `SkinnedMesh` 和 `SkinnedMeshInverseBindposes` 组件）在GPU上实时修改顶点位置。这意味着CPU端的 `Aabb` 不再反映动画后网格的实际范围，导致错误的剔除决策。

常见的解决方法是给实体添加 `NoFrustumCulling` 组件来完全禁用剔除，但这会带来性能损失（始终渲染所有网格），并且只解决了剔除问题，而没有为其他可能依赖准确AABB的系统（如 `bevy_picking` 或第三方工具）提供帮助。

**解决方案**
开发者greedy-dev提出的方案核心是：为网格中每个骨骼预计算一个包围盒（称为关节包围盒 `JointAabb`），该包围盒包含了所有受该骨骼影响的顶点。然后在运行时，根据每一帧的骨骼变换，动态地计算整个网格的包围盒。这个新的包围盒将可靠地包含所有受蒙皮影响的顶点，从而允许进行正确的视锥体剔除。

实现这一方案需要在多个层面进行修改：
1. **数据生成**：在 `Mesh` 资产中添加 `SkinnedMeshBounds` 结构，它存储了每个关节的包围盒（在模型空间）。
2. **运行时更新**：添加 `DynamicSkinnedMeshBounds` 标记组件。拥有此组件的实体，其 `Aabb` 将在每帧根据骨骼的当前 `GlobalTransform` 和 `SkinnedMeshBounds` 数据重新计算。
3. **生态系统集成**：
   - **glTF加载器**：默认情况下，加载glTF时自动为蒙皮网格生成包围盒并添加 `DynamicSkinnedMeshBounds` 组件（通过 `GltfSkinnedMeshBoundsPolicy::Dynamic` 选项）。同时提供 `BindPose`（旧行为）和 `NoFrustumCulling` 选项。
   - **手动使用**：对于非glTF来源的蒙皮网格，用户需要手动调用 `mesh.generate_skinned_mesh_bounds()` 并添加 `DynamicSkinnedMeshBounds` 组件。
   - **调试工具**：新增 `bevy_gizmos::SkinnedMeshBoundsGizmoPlugin`，可以可视化每个关节的包围盒，方便调试。

**技术实现细节与权衡**
实现中遇到几个关键的工程挑战和权衡：

1. **空间坐标系转换**：
   - 关节变换是世界空间的，但 `Aabb` 组件期望是相对于实体局部空间的。为了解决这个问题，代码首先计算世界空间的包围盒，然后再用实体的 `GlobalTransform` 的逆变换将其转换回实体空间。这避免了为每个关节单独进行坐标系转换（关节数可能很多），但可能导致最终包围盒比最优情况稍大一些。

2. **关节包围盒的存储空间**：
   - 最直观的做法是将关节包围盒存储在关节自身的局部空间中。但这需要同时知道网格的顶点数据（在 `Mesh` 中）和骨骼的逆绑定姿势矩阵（在 `SkinnedMeshInverseBindposes` 中），意味着需要为每个 `(Mesh, SkinnedMeshInverseBindposes)` 组合生成一份独立的 `SkinnedMeshBounds` 数据，这在资产管理和组合性上很复杂。
   - 最终实现选择将关节包围盒存储在模型空间（即网格的绑定姿势空间）。这只需要 `Mesh` 数据，简化了资产依赖。代价是每帧更新时需要多一步矩阵乘法（从模型空间到世界空间），但如果未来将剔除计算移到渲染管线内（骨骼变换数据已就绪），这反而可能成为优势。

3. **性能优化**：
   - **`JointAabb` 结构**：设计为 `center` 和 `half_size` 的形式，而非 `min`/`max`，是为了更高效地进行 `transform_aabb` 运算，该函数利用了AABB变换的数学特性，避免变换8个顶点。
   - **`AabbAccumulator`**：这是一个辅助结构，用于高效地合并多个点或AABB以计算一个总的包围盒。它的初始化值设为 `(Vec3A::MAX, Vec3A::MIN)`，确保第一次 `add` 操作能正确更新状态，无需分支判断。
   - **并行迭代**：更新系统使用 `par_iter_mut` 进行并行处理，以利用多核CPU。根据测试，对于1000个网格（每个22个关节），更新成本仅约0.086毫秒，影响微乎其微。

**影响与启示**
此PR的合并对Bevy生态系统有显著影响：

1. **解决了一个长期痛点**：大量用户遇到的蒙皮网格错误剔除问题得到默认修复，提升了开发体验。
2. **性能与功能平衡**：提供了一种可靠且高效的动态包围盒计算方法，使视锥体剔除对蒙皮网格重新生效，提升了GPU受限场景的性能（相比于完全禁用剔除）。
3. **架构清晰**：解决方案没有过度设计，而是将新功能（`SkinnedMeshBounds` 数据、`DynamicSkinnedMeshBounds` 组件）清晰地集成到现有资产和组件系统中。
4. **为未来优化铺路**：实现方式（在模型空间存储包围盒）为将来可能的优化（如将剔除计算移到渲染管线）留下了空间。

值得注意的是，开发者有意识地选择了**默认启用**新行为，因为这解决了最常见的问题。同时，他们提供了灵活的配置选项，允许高级用户根据需求选择旧行为或完全禁用剔除。

这个PR展示了一种典型的游戏引擎问题解决思路：在准确性、性能、实现复杂性和用户体验之间找到平衡点。它不是追求数学上最精确的包围盒，而是提供了一个在绝大多数情况下可靠、高效且“开箱即用”的解决方案。

## 视觉关系图

```mermaid
graph TB
    subgraph “资产层”
        A[Mesh 资产]
        A -->|包含| B[SkinnedMeshBounds]
        C[SkinnedMeshInverseBindposes 资产]
    end

    subgraph “实体层”
        D[Mesh3d 组件]
        D -->|引用| A
        E[SkinnedMesh 组件]
        E -->|引用| C
        E -->|包含| F[关节实体列表]
        G[DynamicSkinnedMeshBounds 组件]
        H[Aabb 组件]
    end

    subgraph “关节实体”
        I[GlobalTransform 组件]
    end

    subgraph “系统层”
        J[update_skinned_mesh_bounds 系统]
        J -->|查询| D
        J -->|查询| E
        J -->|查询| G
        J -->|查询| I
        J -->|读取| B
        J -->|计算并写入| H
    end

    subgraph “外部集成”
        K[GltfLoader]
        K -->|根据策略| L[添加 DynamicSkinnedMeshBounds]
        K -->|根据策略| M[添加 NoFrustumCulling]
    end

    B -.->|被| J
    C -.->|被| J
```

## 关键文件变更

**1. `crates/bevy_mesh/src/skinning.rs` (+687/-2)**
这是核心逻辑实现所在。新增了 `SkinnedMeshBounds`、`JointAabb` 等数据结构，以及从 `Mesh` 生成这些数据和根据关节变换计算最终 `Aabb` 的函数。

**关键修改:**
```rust
// 新增数据结构
pub struct SkinnedMeshBounds {
    pub aabbs: Vec<JointAabb>, // 关节包围盒
    pub aabb_index_to_joint_index: Vec<JointIndex>, // 索引映射
}
pub struct JointAabb {
    pub center: Vec3,
    pub half_size: Vec3,
}

// 新增方法，从Mesh生成SkinnedMeshBounds
pub fn from_mesh(mesh: &Mesh) -> Result<SkinnedMeshBounds, SkinnedMeshBoundsError> {
    // ... 读取顶点位置、关节索引、权重属性
    // ... 为每个关节累加顶点位置，形成包围盒
}

// 核心函数：根据当前关节变换计算实体的Aabb
pub fn entity_aabb_from_skinned_mesh_bounds(
    joint_entities: &Query<&GlobalTransform>,
    mesh: &Mesh,
    skinned_mesh: &SkinnedMesh,
    skinned_mesh_inverse_bindposes: &SkinnedMeshInverseBindposes,
    world_from_entity: Option<&GlobalTransform>,
) -> Result<Aabb3d, EntityAabbFromSkinnedMeshBoundsError> {
    // 1. 获取网格的SkinnedMeshBounds
    // 2. 遍历每个关节包围盒，用当前关节的 GlobalTransform 和逆绑定姿势矩阵将其变换到世界空间
    // 3. 合并所有世界空间的关节包围盒，得到世界空间的网格总包围盒
    // 4. 如果实体有GlobalTransform，将世界空间包围盒变换回实体局部空间
}
```

**与整体目标的关联:**
此文件实现了计算动态蒙皮包围盒的算法核心。`SkinnedMeshBounds` 是预处理数据，`entity_aabb_from_skinned_mesh_bounds` 是每帧更新时的计算逻辑。

**2. `crates/bevy_camera/src/visibility/mod.rs` (+49/-1)**
在此文件中添加了 `DynamicSkinnedMeshBounds` 组件定义和每帧更新 `Aabb` 的系统。

**关键修改:**
```rust
// 新增组件
#[derive(Debug, Component, Default, Reflect)]
pub struct DynamicSkinnedMeshBounds;

// 新增系统
fn update_skinned_mesh_bounds(
    inverse_bindposes_assets: Res<Assets<SkinnedMeshInverseBindposes>>,
    mesh_assets: Res<Assets<Mesh>>,
    mut mesh_entities: Query<
        (&mut Aabb, &Mesh3d, &SkinnedMesh, Option<&GlobalTransform>),
        With<DynamicSkinnedMeshBounds>, // 只处理拥有此组件的实体
    >,
    joint_entities: Query<&GlobalTransform>,
) {
    mesh_entities
        .par_iter_mut() // 并行迭代
        .for_each(|(mut aabb, mesh, skinned_mesh, world_from_entity)| {
            if let Some(inverse_bindposes_asset) =
                inverse_bindposes_assets.get(&skinned_mesh.inverse_bindposes)
                && let Some(mesh_asset) = mesh_assets.get(mesh)
                && let Ok(skinned_aabb) = entity_aabb_from_skinned_mesh_bounds(
                    &joint_entities,
                    mesh_asset,
                    skinned_mesh,
                    inverse_bindposes_asset,
                    world_from_entity,
                )
            {
                *aabb = skinned_aabb.into(); // 更新Aabb组件
            }
        });
}
```

**与整体目标的关联:**
`DynamicSkinnedMeshBounds` 是一个标记组件，用于指示哪些实体的 `Aabb` 需要每帧更新。`update_skinned_mesh_bounds` 系统则是驱动这一更新的调度器，它查询所有相关组件和资产，调用 `skinning.rs` 中的计算函数，并更新结果。

**3. `crates/bevy_mesh/src/mesh.rs`**
在 `Mesh` 结构体中添加了 `skinned_mesh_bounds` 字段及相关方法，允许存储和生成 `SkinnedMeshBounds`。

**关键修改:**
```rust
pub struct Mesh {
    // ...
    skinned_mesh_bounds: Option<SkinnedMeshBounds>, // 新增字段
}

// 新增方法
impl Mesh {
    pub fn generate_skinned_mesh_bounds(&mut self) -> Result<(), SkinnedMeshBoundsError> {
        self.skinned_mesh_bounds = Some(SkinnedMeshBounds::from_mesh(self)?);
        Ok(())
    }
    pub fn with_generated_skinned_mesh_bounds(mut self) -> Result<Self, SkinnedMeshBoundsError> {
        self.generate_skinned_mesh_bounds()?;
        Ok(self)
    }
    // ... 其他getter/setter
}
```

**与整体目标的关联:**
将 `SkinnedMeshBounds` 数据作为 `Mesh` 资产的一部分存储，使得该数据可以随网格一起加载、缓存和共享。`generate_skinned_mesh_bounds` 方法为用户提供了生成此数据的接口。

**4. `crates/bevy_gltf/src/lib.rs` 和 `crates/bevy_gltf/src/loader/mod.rs`**
修改glTF插件和加载器，使其能够根据策略自动为加载的蒙皮网格添加 `DynamicSkinnedMeshBounds` 组件或 `NoFrustumCulling` 组件，并在加载时尝试生成 `SkinnedMeshBounds` 数据。

**关键修改:**
```rust
// 新增策略枚举
pub enum GltfSkinnedMeshBoundsPolicy {
    BindPose, // 旧行为，使用绑定姿势的Aabb
    #[default]
    Dynamic, // 新行为，添加DynamicSkinnedMeshBounds
    NoFrustumCulling, // 添加NoFrustumCulling组件
}

// 在GltfPlugin中新增默认策略字段
pub struct GltfPlugin {
    pub skinned_mesh_bounds_policy: GltfSkinnedMeshBoundsPolicy,
    // ...
}

// 在加载器中应用策略
if (skinned_mesh_bounds_policy == GltfSkinnedMeshBoundsPolicy::Dynamic)
    && meshes_on_skinned_nodes.contains(&gltf_mesh.index())
    && let Err(err) = mesh.generate_skinned_mesh_bounds()
{
    warn!("Failed to generate skinned mesh bounds: {err}");
}
// ... 在创建网格实体时，根据策略插入相应组件
match skinned_mesh_bounds_policy {
    GltfSkinnedMeshBoundsPolicy::Dynamic => {
        mesh_entity.insert(DynamicSkinnedMeshBounds);
    }
    GltfSkinnedMeshBoundsPolicy::NoFrustumCulling => {
        mesh_entity.insert(NoFrustumCulling);
    }
    _ => {}
}
```

**与整体目标的关联:**
这是实现“开箱即用”体验的关键。通过修改glTF加载器，使大多数用户（使用glTF格式）无需任何额外操作即可获得正确的蒙皮网格剔除行为。

**5. `tests/3d/test_skinned_mesh_bounds.rs` (+288/-0)**
这是一个新的集成测试/示例文件，用于展示和验证功能。

**关键内容:**
```rust
// 创建一个自定义的简单蒙皮网格（一个由两个关节控制的带状网格）
let mesh = Mesh::new(...)
    .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, ...)
    .with_inserted_attribute(Mesh::ATTRIBUTE_JOINT_INDEX, ...)
    .with_inserted_attribute(Mesh::ATTRIBUTE_JOINT_WEIGHT, ...)
    .with_generated_skinned_mesh_bounds() // 生成包围盒数据
    .unwrap();

// 为实体添加DynamicSkinnedMeshBounds组件
commands.spawn((
    Mesh3d(mesh_handle),
    SkinnedMesh { ... },
    DynamicSkinnedMeshBounds, // 关键组件
));
```
这个示例演示了如何手动为自定义蒙皮网格启用动态包围盒功能。

**与整体目标的关联:**
为功能提供测试和用法示例。

**6. `crates/bevy_gizmos/src/skinned_mesh_bounds.rs` (+164/-0)**
新增调试可视化插件，可以绘制每个关节的包围盒。

**关键修改:**
```rust
// 插件和配置组
pub struct SkinnedMeshBoundsGizmoPlugin;
pub struct SkinnedMeshBoundsGizmoConfigGroup {
    pub draw_all: bool,
    pub default_color: Color,
}

// 绘制函数
fn draw(...) {
    if let Some(mesh_asset) = mesh_assets.get(mesh)
        && let Some(bounds) = mesh_asset.skinned_mesh_bounds() // 获取包围盒数据
    {
        for (&joint_index, &joint_aabb) in bounds.iter() {
            // 计算关节的世界变换
            let world_from_mesh = world_from_joint.affine() * Affine3A::from_mat4(joint_from_mesh);
            // 绘制该关节的AABB
            gizmos.aabb_3d(joint_aabb, world_from_mesh, color);
        }
    }
}
```

**与整体目标的关联:**
提供强大的调试工具，帮助开发者理解动态包围盒是如何计算出来的，验证其正确性。

**7. `release-content/release-notes/skinned_mesh_culling.md` (+68/-0)**
新增的发布说明文档，简要总结了功能、用法和迁移指南。

**与整体目标的关联:**
告知用户此变更，特别是对于从 `bevy_mod_skinned_aabb` 迁移的用户。

## 进一步阅读

- **Bevy 官方文档 - 蒙皮 (Skinning)**: 了解Bevy中蒙皮网格的基本概念和工作原理。
- **《图形宝石 I》（Graphics Gems I）中 "Transforming Axis-Aligned Bounding Boxes" (James Arvo)**: PR中 `transform_aabb` 函数参考的经典算法，高效地变换AABB。
- **Godot 引擎源码**：`mesh_get_aabb` 和 `_update_instance_aabb` 函数，了解其他开源引擎如何处理类似问题。
- **“Large-Scale GPU-Based Skinning” (GDC 演讲)**: 了解在大规模场景中