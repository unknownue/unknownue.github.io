+++
title = "#22701 Update some UI examples"
date = "2026-01-25T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22701-en-20260125" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22701-zh-cn-20260125" }}
+++

# Update some UI examples

## 基本信息
- **标题**: Update some UI examples
- **PR链接**: https://github.com/bevyengine/bevy/pull/22701
- **作者**: ickshonpe
- **状态**: 已合并
- **标签**: D-Trivial, C-Examples, A-UI, C-Code-Quality, S-Ready-For-Final-Review
- **创建时间**: 2026-01-25T21:29:39Z
- **合并时间**: 2026-01-25T22:26:05Z
- **合并者**: alice-i-cecile

## 描述翻译

### 目标

一些UI示例中，Val和UiRect的构造函数使用不一致或完全未使用。

### 解决方案

更新一些UI示例以使用val和uirect辅助函数。

### 测试

示例的输出应保持不变

## 本次Pull Request的故事

这个PR的故事很简单，但体现了良好的工程实践：保持代码一致性。在Bevy引擎的UI示例中，开发者发现一个问题——不同的示例文件使用了不同的方式来创建UI布局值。有的直接使用构造函数如`Val::Percent(100.0)`，有的则使用辅助函数如`percent(100)`。这种不一致性虽然不影响功能，但会影响代码的可读性和维护性。

从本质上讲，这是一个代码质量改进（code quality）的任务。作者的目标是通过统一使用辅助函数来简化代码，让示例更清晰，同时为新的Bevy开发者提供一致的代码范式参考。

### 问题与上下文

Bevy的UI系统使用`Val`枚举来表示尺寸值（像素、百分比等），使用`UiRect`结构体来表示边距（margin）和内边距（padding）。这些类型有两种创建方式：

1. **直接使用构造函数**：`Val::Percent(100.0)`、`Val::Px(10.0)`
2. **使用辅助函数**：`percent(100)`、`px(10.0)`

同样，`UiRect`也有多种构造方式。问题在于不同的示例文件混合使用了这些方式，没有统一的标准。虽然这只是风格问题，但在开源项目中，代码一致性很重要——特别是对于示例代码，它们是新用户学习API的第一手资料。

### 解决方案

作者的解决方案很直接：扫一遍UI相关的示例文件，将所有能替换为辅助函数的地方都统一替换。这种方法有几个优点：

1. **代码更简洁**：`percent(100)`比`Val::Percent(100.0)`更短更清晰
2. **统一API使用方式**：为开发者提供了明确的编码模式
3. **保持向后兼容**：没有改变任何功能，只是改变了写法

从技术实现角度看，这个PR涉及7个文件的小范围修改，每个修改都很简单直接。作者没有引入新的辅助函数，只是更好地利用了现有的API。

### 实现细节

看一下具体的修改，主要有三种类型的变化：

**第一类：Val值的简化**
```rust
// 之前：
width: Val::Percent(100.0),
height: Val::Percent(100.0),

// 之后：
width: percent(100),
height: percent(100),
```

**第二类：UiRect的简化**
```rust
// 之前：
padding: UiRect::all(MARGIN),

// 之后：
padding: MARGIN.all(),
```

**第三类：方法链式调用的使用**
```rust
// 之前：
spawn_nested_text_bundle(builder, font.clone(), color, UiRect::top(px(top_margin)), &text);

// 之后：
spawn_nested_text_bundle(builder, font.clone(), color, px(top_margin).top(), &text);
```

这些修改都遵循同一个原则：使用更简洁、更易读的辅助函数。

### 一个有趣的技术点

在`image_node_resizing.rs`文件中，有一个更复杂的重构。原始代码在处理百分比值的增减时，使用了模式匹配和重新赋值的模式：

```rust
// 之前：
if let Val::Percent(val) = node.height {
    let new_val = (val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
    node.height = Val::Percent(new_val);
}
```

修改后的版本利用了Rust的可变引用和模式匹配，直接在原值上操作：

```rust
// 之后：
if let Val::Percent(val) = &mut node.height {
    *val = (*val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
}
```

这种修改不仅让代码更简洁，还减少了一次`Val::Percent`构造函数的调用。虽然性能提升可以忽略不计，但这种写法更符合Rust的惯用法。

### 影响

这个PR的影响主要体现在代码质量方面：

1. **一致性提升**：所有UI示例现在使用统一的API风格
2. **可读性改善**：辅助函数让代码意图更明确
3. **更好的示例**：新用户学习Bevy时，看到的将是更简洁、一致的代码

从工程角度看，这种类型的清理工作很重要。虽然不直接影响功能，但它降低了代码的认知负担，让后续的维护和扩展更容易。

### 值得注意的细节

值得注意的是，这个PR没有修改任何业务逻辑，所有修改都保持API行为不变。这是代码重构的基本原则——只改变形式，不改变功能。

此外，这个PR的改动范围很精准，只针对示例文件。这意味着：
1. 不影响生产代码
2. 不影响现有用户的代码
3. 只影响学习和参考用的示例

这种精准的修改范围显示了作者的良好判断力——在保持代码库稳定的前提下进行改进。

## 视觉表示

```mermaid
graph TD
    A[UI示例一致性改进] --> B[Val构造器替换]
    A --> C[UiRect构造器替换]
    A --> D[代码简化优化]
    
    B --> E[percent()辅助函数]
    B --> F[px()辅助函数]
    
    C --> G[.all()方法]
    C --> H[.right()方法]
    C --> I[.top()方法]
    
    D --> J[减少构造函数调用]
    D --> K[使用可变引用模式匹配]
```

## 关键文件变更

### `examples/ui/image_node_resizing.rs` (+16/-20)
**变更描述**：这个文件中的UI示例展示了图像节点的尺寸调整功能，修改统一了Val和UiRect的使用方式。

**关键代码修改**：
```rust
// 之前：
padding: UiRect::all(px(6)),

// 之后：
padding: px(6).all(),
```

```rust
// 之前：
width: Val::Percent(IMAGE_GROUP_BOX_INIT_WIDTH),

// 之后：
width: percent(IMAGE_GROUP_BOX_INIT_WIDTH),
```

```rust
// 之前：
if let Val::Percent(val) = node.height {
    let new_val = (val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
    node.height = Val::Percent(new_val);
}

// 之后：
if let Val::Percent(val) = &mut node.height {
    *val = (*val + MIN_RESIZE_VAL).min(IMAGE_GROUP_BOX_MAX_HEIGHT);
}
```

### `examples/ui/flex_layout.rs` (+3/-9)
**变更描述**：这个示例展示了Flex布局系统，修改简化了边距和内边距的设置。

**关键代码修改**：
```rust
// 之前：
padding: UiRect::all(MARGIN),

// 之后：
padding: MARGIN.all(),
```

```rust
// 之前：
UiRect::right(MARGIN),

// 之后：
MARGIN.right(),
```

### `examples/ui/ui_drag_and_drop.rs` (+4/-4)
**变更描述**：这个示例展示了UI的拖放功能，修改统一了尺寸和边框的设置方式。

**关键代码修改**：
```rust
// 之前：
width: Val::Px(TILE_SIZE),
height: Val::Px(TILE_SIZE),
border: UiRect::all(Val::Px(4.)),

// 之后：
width: px(TILE_SIZE),
height: px(TILE_SIZE),
border: px(4.).all(),
```

### `examples/picking/dragdrop_picking.rs` (+2/-2)
**变更描述**：这个示例展示了拖放拾取功能，修改简化了百分比尺寸的设置。

**关键代码修改**：
```rust
// 之前：
width: Val::Percent(100.0),
height: Val::Percent(100.0),

// 之后：
width: percent(100),
height: percent(100),
```

### `examples/ui/strikethrough_and_underline.rs` (+2/-2)
**变更描述**：这个示例展示了文本的下划线和删除线效果，修改简化了容器尺寸设置。

**关键代码修改**：
```rust
// 之前：
width: Val::Percent(100.),
height: Val::Percent(100.),

// 之后：
width: percent(100),
height: percent(100),
```

## 扩展阅读

对于想深入了解相关概念的开发者，建议阅读：

1. **Bevy UI系统文档**：了解Val和UiRect的完整API
2. **Rust模式匹配**：学习如何优雅地处理枚举值
3. **代码重构原则**：理解如何在不改变功能的情况下改进代码质量
4. **API设计一致性**：学习如何设计易于使用且一致的API

这些资源可以帮助开发者更好地理解本次PR背后的设计理念和实现细节。