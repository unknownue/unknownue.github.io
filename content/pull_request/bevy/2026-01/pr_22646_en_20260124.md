+++
title = "#22646 Round sub pixel font sizes"
date = "2026-01-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-01/pr-22646-en-20260124" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-01/pr-22646-zh-cn-20260124" }}
labels = ["C-Performance", "A-Text", "X-Contentious", "D-Straightforward"]
+++

# Round sub pixel font sizes

## Basic Information
- **Title**: Round sub pixel font sizes
- **PR Link**: https://github.com/bevyengine/bevy/pull/22646
- **Author**: ickshonpe
- **Status**: MERGED
- **Labels**: C-Performance, S-Ready-For-Final-Review, A-Text, X-Contentious, D-Straightforward
- **Created**: 2026-01-22T13:03:58Z
- **Merged**: 2026-01-24T20:23:33Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

Sub-pixel font sizes don't provide much benefit with bitmap fonts and rounding them to the nearest pixel massively reduces the number of font atlases when a text entity's font size is naively interpolated.

fixes #22626

## Solution

Round the font sizes before adding them to the Cosmic Text `Attrs`.

## Testing

```
cargo run --example animated_ui
```

In main, the window is blank and it rapidly generates gigabytes of font atlas images.

With this PR, the text is visible and animated, and memory usage remains stable.

## The Story of This Pull Request

This PR addresses a performance issue in Bevy's text rendering system that occurs when text font sizes are animated or interpolated. The problem manifests when font sizes change by small, sub-pixel amounts during animation, causing the system to generate an excessive number of font atlases.

In Bevy, font atlases are cached based on the combination of font handle and scaled font size. When text is animated and the font size changes continuously (even by tiny fractions of a pixel), each distinct font size value triggers the creation of a new font atlas. This leads to rapid memory growth - in the reported issue, gigabytes of font atlas images were being generated, eventually causing the application to become unresponsive or crash.

The core issue stems from how Bevy handles font size scaling. When text is rendered, the base font size is multiplied by the window scale factor and UI scale to determine the final font size used for layout and rasterization. Previously, this scaled value was passed directly to Cosmic Text (the underlying text layout engine) without rounding, resulting in many distinct font atlas entries for what are effectively the same visual appearance.

The fix is straightforward: round the scaled font size to the nearest whole pixel before passing it to Cosmic Text. This approach makes sense because bitmap fonts (which Bevy primarily uses for text rendering) don't benefit from sub-pixel precision in font sizing. The visual difference between a font size of 15.1 pixels and 15.0 pixels is negligible, but treating them as different sizes has significant performance consequences.

The implementation modifies the `get_attrs` function in the text pipeline to round the scaled font size:

```rust
let font_size = (text_font.font_size * scale_factor as f32).round();
```

This simple change has a profound impact on performance. By collapsing many similar font sizes into a single integer value, the number of unique font atlas entries is dramatically reduced. The PR description notes that in the `animated_ui` example, the memory usage stabilizes and the text becomes visible and animated, whereas previously the window would go blank as the system exhausted memory generating atlas images.

The change also affects how line height is calculated. Since the rounded font size is now used for layout, line height calculations must be adjusted to use this rounded value rather than the original unrounded font size. This ensures consistency between font size and line spacing in the rendered text.

One important consideration is that this change represents a trade-off: we sacrifice the theoretical possibility of sub-pixel font sizing for substantial performance gains. This is a reasonable trade-off because:
1. Bitmap fonts don't actually render differently at sub-pixel sizes
2. The performance impact of not rounding is severe in common use cases (animations, interpolations)
3. The visual difference is imperceptible in practice

The PR also includes documentation updates to clarify that font sizes are rounded after scaling, helping future developers understand this aspect of Bevy's text rendering behavior.

## Visual Representation

```mermaid
graph TD
    A[TextFont.font_size] --> B[Multiply by scale_factor]
    B --> C{Round to nearest pixel?}
    C -->|No (before PR)| D[Many distinct font atlas entries]
    C -->|Yes (after PR)| E[Fewer distinct font atlas entries]
    D --> F[Performance issues: memory exhaustion]
    E --> G[Stable performance]
    
    H[LineHeight calculation] --> I{Use original or rounded font_size?}
    I -->|Original (before PR)| J[Inconsistent with actual font size]
    I -->|Rounded (after PR)| K[Consistent with actual font size]
```

## Key Files Changed

### `crates/bevy_text/src/pipeline.rs` (+10/-7)
This file contains the main logic change for rounding font sizes. The `get_attrs` function is modified to round the scaled font size and adjust line height calculation accordingly.

**Key changes:**
```rust
// Before:
.metrics(
    Metrics {
        font_size: text_font.font_size,
        line_height: line_height.eval(text_font.font_size),
    }
    .scale(scale_factor as f32),
)

// After:
let font_size = (text_font.font_size * scale_factor as f32).round();
let line_height = match line_height {
    LineHeight::Px(px) => px * scale_factor as f32,
    LineHeight::RelativeToFont(s) => s * font_size,
};

.metrics(Metrics {
    font_size,
    line_height,
})
```

The change replaces the previous approach of scaling the entire `Metrics` struct with explicit calculation of rounded font size and line height. This ensures that both font size and line height use the same rounded value for consistent layout.

### `crates/bevy_text/src/text.rs` (+3/-11)
This file contains documentation updates and removal of unused code. The `LineHeight::eval` method is removed since it's no longer used after the refactoring in `pipeline.rs`.

**Key changes:**
```rust
// Documentation update for TextFont::font_size field:
// Before:
/// This is multiplied by the window scale factor and `UiScale`, but not the text entity
/// transform or camera projection.

// After:
/// This is multiplied by the window scale factor and `UiScale`, but not the text entity's
/// transform or camera projection. Then, the scaled font size is rounded to the nearest pixel
/// to produce the final font size used during glyph layout.

// Removal of unused LineHeight::eval method:
// Before:
impl LineHeight {
    pub(crate) fn eval(self, font_size: f32) -> f32 {
        match self {
            LineHeight::Px(px) => px,
            LineHeight::RelativeToFont(scale) => scale * font_size,
        }
    }
}

// After: (method completely removed)
```

The documentation update is crucial for understanding the font size rounding behavior, while removing the unused `eval` method cleans up the codebase.

## Further Reading

1. **Bevy Text Rendering Documentation**: The official Bevy documentation on text rendering and font atlases
2. **Cosmic Text**: The text layout engine used by Bevy (https://github.com/pop-os/cosmic-text)
3. **Font Atlas Management**: General techniques for optimizing font atlas usage in game engines
4. **Issue #22626**: The original issue report that prompted this fix, providing context on the specific performance problem
5. **Bitmap Font Rendering**: Technical details on how bitmap fonts differ from vector fonts in terms of scaling and sub-pixel precision