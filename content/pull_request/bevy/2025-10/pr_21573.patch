diff --git a/crates/bevy_pbr/src/extended_material.rs b/crates/bevy_pbr/src/extended_material.rs
index 4e310a2d388bd..258408cf4cc62 100644
--- a/crates/bevy_pbr/src/extended_material.rs
+++ b/crates/bevy_pbr/src/extended_material.rs
@@ -196,6 +196,10 @@ impl<B: Material, E: MaterialExtension> AsBindGroup for ExtendedMaterial<B, E> {
         }
     }
 
+    fn label() -> &'static str {
+        E::label()
+    }
+
     fn bind_group_data(&self) -> Self::Data {
         MaterialExtensionBindGroupData {
             base: self.base.bind_group_data(),
diff --git a/crates/bevy_pbr/src/material_bind_groups.rs b/crates/bevy_pbr/src/material_bind_groups.rs
index eaedf1d82f5fc..d987725bfda72 100644
--- a/crates/bevy_pbr/src/material_bind_groups.rs
+++ b/crates/bevy_pbr/src/material_bind_groups.rs
@@ -52,7 +52,7 @@ pub enum MaterialBindGroupAllocator {
 /// their resources.
 pub struct MaterialBindGroupBindlessAllocator {
     /// The label of the bind group allocator to use for allocated buffers.
-    label: Option<&'static str>,
+    label: &'static str,
     /// The slabs, each of which contains a bind group.
     slabs: Vec<MaterialBindlessSlab>,
     /// The layout of the bind groups that we produce.
@@ -176,7 +176,7 @@ where
 /// The allocator that stores bind groups for non-bindless materials.
 pub struct MaterialBindGroupNonBindlessAllocator {
     /// The label of the bind group allocator to use for allocated buffers.
-    label: Option<&'static str>,
+    label: &'static str,
     /// A mapping from [`MaterialBindGroupIndex`] to the bind group allocated in
     /// each slot.
     bind_groups: Vec<Option<MaterialNonBindlessAllocatedBindGroup>>,
@@ -457,7 +457,7 @@ impl MaterialBindGroupAllocator {
     /// single material.
     pub fn new(
         render_device: &RenderDevice,
-        label: Option<&'static str>,
+        label: &'static str,
         bindless_descriptor: Option<BindlessDescriptor>,
         bind_group_layout: BindGroupLayoutDescriptor,
         slab_capacity: Option<BindlessSlabResourceLimit>,
@@ -769,7 +769,7 @@ impl MaterialBindGroupBindlessAllocator {
     /// for a single bindless material.
     fn new(
         render_device: &RenderDevice,
-        label: Option<&'static str>,
+        label: &'static str,
         bindless_descriptor: BindlessDescriptor,
         bind_group_layout: BindGroupLayoutDescriptor,
         slab_capacity: Option<BindlessSlabResourceLimit>,
@@ -1205,7 +1205,7 @@ impl MaterialBindlessSlab {
         &mut self,
         render_device: &RenderDevice,
         pipeline_cache: &PipelineCache,
-        label: Option<&'static str>,
+        label: &'static str,
         bind_group_layout: &BindGroupLayoutDescriptor,
         fallback_bindless_resources: &FallbackBindlessResources,
         fallback_buffers: &HashMap<BindlessIndex, Buffer>,
@@ -1243,7 +1243,7 @@ impl MaterialBindlessSlab {
         &mut self,
         render_device: &RenderDevice,
         pipeline_cache: &PipelineCache,
-        label: Option<&'static str>,
+        label: &'static str,
         bind_group_layout: &BindGroupLayoutDescriptor,
         fallback_bindless_resources: &FallbackBindlessResources,
         fallback_buffers: &HashMap<BindlessIndex, Buffer>,
@@ -1311,7 +1311,7 @@ impl MaterialBindlessSlab {
         }
 
         self.bind_group = Some(render_device.create_bind_group(
-            label,
+            Some(label),
             &pipeline_cache.get_bind_group_layout(bind_group_layout),
             &bind_group_entries,
         ));
@@ -1816,7 +1816,7 @@ pub fn init_fallback_bindless_resources(mut commands: Commands, render_device: R
 impl MaterialBindGroupNonBindlessAllocator {
     /// Creates a new [`MaterialBindGroupNonBindlessAllocator`] managing the
     /// bind groups for a single non-bindless material.
-    fn new(label: Option<&'static str>) -> MaterialBindGroupNonBindlessAllocator {
+    fn new(label: &'static str) -> MaterialBindGroupNonBindlessAllocator {
         MaterialBindGroupNonBindlessAllocator {
             label,
             bind_groups: vec![],
diff --git a/crates/bevy_render/macros/src/as_bind_group.rs b/crates/bevy_render/macros/src/as_bind_group.rs
index 820a336d7a5ba..ee11aae4f9b59 100644
--- a/crates/bevy_render/macros/src/as_bind_group.rs
+++ b/crates/bevy_render/macros/src/as_bind_group.rs
@@ -1054,8 +1054,8 @@ pub fn derive_as_bind_group(ast: syn::DeriveInput) -> Result<TokenStream> {
 
             #bindless_slot_count
 
-            fn label() -> Option<&'static str> {
-                Some(#struct_name_literal)
+            fn label() -> &'static str {
+                #struct_name_literal
             }
 
             fn unprepared_bind_group(
diff --git a/crates/bevy_render/src/render_resource/bind_group.rs b/crates/bevy_render/src/render_resource/bind_group.rs
index 29675a9cfb3c9..fe750e70c9f33 100644
--- a/crates/bevy_render/src/render_resource/bind_group.rs
+++ b/crates/bevy_render/src/render_resource/bind_group.rs
@@ -5,7 +5,6 @@ use crate::{
     renderer::{RenderDevice, WgpuWrapper},
     texture::GpuImage,
 };
-use alloc::borrow::Cow;
 use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::system::{SystemParam, SystemParamItem};
 use bevy_render::render_resource::BindGroupLayoutDescriptor;
@@ -525,9 +524,7 @@ pub trait AsBindGroup {
     }
 
     /// label
-    fn label() -> Option<&'static str> {
-        None
-    }
+    fn label() -> &'static str;
 
     /// Creates a bind group for `self` matching the layout defined in [`AsBindGroup::bind_group_layout`].
     fn as_bind_group(
@@ -599,7 +596,7 @@ pub trait AsBindGroup {
         Self: Sized,
     {
         BindGroupLayoutDescriptor {
-            label: Self::label().map(Into::<Cow<str>>::into),
+            label: Self::label().into(),
             entries: Self::bind_group_layout_entries(render_device, false),
         }
     }
diff --git a/crates/bevy_render/src/render_resource/pipeline.rs b/crates/bevy_render/src/render_resource/pipeline.rs
index 98ab1b4d67228..f3976f68af916 100644
--- a/crates/bevy_render/src/render_resource/pipeline.rs
+++ b/crates/bevy_render/src/render_resource/pipeline.rs
@@ -90,14 +90,14 @@ impl Deref for ComputePipeline {
 #[derive(Clone, Debug, PartialEq, Eq, Hash, Default)]
 pub struct BindGroupLayoutDescriptor {
     /// Debug label of the bind group layout descriptor. This will show up in graphics debuggers for easy identification.
-    pub label: Option<Cow<'static, str>>,
+    pub label: Cow<'static, str>,
     pub entries: Vec<BindGroupLayoutEntry>,
 }
 
 impl BindGroupLayoutDescriptor {
     pub fn new(label: impl Into<Cow<'static, str>>, entries: &[BindGroupLayoutEntry]) -> Self {
         Self {
-            label: Some(label.into()),
+            label: label.into(),
             entries: entries.into(),
         }
     }
diff --git a/crates/bevy_render/src/render_resource/pipeline_cache.rs b/crates/bevy_render/src/render_resource/pipeline_cache.rs
index 5a6b949612ae6..76ff5eaafc322 100644
--- a/crates/bevy_render/src/render_resource/pipeline_cache.rs
+++ b/crates/bevy_render/src/render_resource/pipeline_cache.rs
@@ -221,10 +221,8 @@ impl BindGroupLayoutCache {
         self.bgls
             .entry(descriptor)
             .or_insert_with_key(|descriptor| {
-                render_device.create_bind_group_layout(
-                    descriptor.label.as_ref().map(Cow::as_ref),
-                    &descriptor.entries,
-                )
+                render_device
+                    .create_bind_group_layout(descriptor.label.as_ref(), &descriptor.entries)
             })
             .clone()
     }
diff --git a/examples/3d/manual_material.rs b/examples/3d/manual_material.rs
index aa2d8006987ad..9a57f47638747 100644
--- a/examples/3d/manual_material.rs
+++ b/examples/3d/manual_material.rs
@@ -100,7 +100,13 @@ fn init_image_material_resources(
 
     bind_group_allocators.insert(
         TypeId::of::<ImageMaterial>(),
-        MaterialBindGroupAllocator::new(&render_device, None, None, bind_group_layout, None),
+        MaterialBindGroupAllocator::new(
+            &render_device,
+            "image_material_allocator",
+            None,
+            bind_group_layout,
+            None,
+        ),
     );
 }
 
diff --git a/examples/shader_advanced/texture_binding_array.rs b/examples/shader_advanced/texture_binding_array.rs
index a774de5a70749..ab249c9dd46d1 100644
--- a/examples/shader_advanced/texture_binding_array.rs
+++ b/examples/shader_advanced/texture_binding_array.rs
@@ -129,7 +129,7 @@ impl AsBindGroup for BindlessMaterial {
         }
 
         let bind_group = render_device.create_bind_group(
-            "bindless_material_bind_group",
+            Self::label(),
             &pipeline_cache.get_bind_group_layout(layout),
             &BindGroupEntries::sequential((&textures[..], &fallback_image.sampler)),
         );
@@ -191,6 +191,10 @@ impl AsBindGroup for BindlessMaterial {
         )
         .to_vec()
     }
+
+    fn label() -> &'static str {
+        "bindless_material_bind_group"
+    }
 }
 
 impl Material for BindlessMaterial {
diff --git a/release-content/migration-guides/bindgroup-labels-mandatory.md b/release-content/migration-guides/bindgroup-labels-mandatory.md
new file mode 100644
index 0000000000000..efe9667b14db7
--- /dev/null
+++ b/release-content/migration-guides/bindgroup-labels-mandatory.md
@@ -0,0 +1,14 @@
+---
+title: "`BindGroupLayout` labels are no longer optional"
+pull_requests: [21573]
+---
+
+In previous versions of Bevy, the `label` of a `BindGroupLayout` was optional. This practically only applies when implementing `AsBindGroup` manually without the `AsBindGroup` derive.
+
+If you were previously omitting the `label` implementation from a `impl AsBindGroup`, you now must implement it:
+
+```rust
+fn label() -> &'static str {
+    "my label"
+}
+```
