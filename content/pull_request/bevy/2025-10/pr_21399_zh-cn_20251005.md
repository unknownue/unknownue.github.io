+++
title = "#21399 Remove uses of `#[cfg(feature = \"track_location\")]` outside of the implementation of `MaybeLocation`"
date = "2025-10-05T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-10/pr-21399-en-20251005" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-10/pr-21399-zh-cn-20251005" }}
labels = ["A-ECS", "C-Code-Quality", "D-Straightforward"]
+++

# Title
Remove uses of `#[cfg(feature = "track_location")]` outside of the implementation of `MaybeLocation`

## Basic Information
- **Title**: Remove uses of `#[cfg(feature = "track_location")]` outside of the implementation of `MaybeLocation`
- **PR Link**: https://github.com/bevyengine/bevy/pull/21399
- **Author**: chescock
- **Status**: MERGED
- **Labels**: A-ECS, C-Code-Quality, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2025-10-05T15:39:21Z
- **Merged**: 2025-10-05T20:30:40Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

移除 `MaybeLocation` 实现之外的 `#[cfg(feature = "track_location")]` 使用。

减少条件编译的数量使代码更健壮，因为无论是否启用该特性都能发现编译错误。

我们还希望确保在 `bevy_ecs` 之外使用 `MaybeLocation` 不需要它们自己的特性标志。即使在 `bevy_ecs` 内部避免这些标志也有助于确保覆盖所有用例，并且更容易将实现从 `bevy_ecs` 移动或复制到其他 crate 中。

## Solution

移除 `#[cfg(feature = "track_location")]` 注解。在我们希望行为取决于是否启用该特性的情况下使用 `.into_option()`。

## The Story of This Pull Request

这个 PR 解决了一个在 Bevy ECS 代码库中条件编译使用不当的问题。问题的核心在于 `track_location` 特性标志的使用方式过于分散，导致代码维护困难和潜在的编译错误。

### 问题识别

在原来的实现中，`track_location` 特性标志被用在多个地方来控制代码的编译，包括：
- 模块导入 (`use` 语句)
- 结构体字段定义
- 结构体初始化
- Debug 实现
- 警告消息生成
- 测试代码

这种分散的条件编译使得代码难以维护，因为：
1. 当特性被禁用时，编译器无法检查相关代码的正确性
2. 在 `bevy_ecs` 之外使用 `MaybeLocation` 时需要重复定义特性标志
3. 代码难以在不同 crate 之间移动

### 解决方案设计

开发者采用了集中化的方法来解决这个问题。核心思路是：

1. **统一导入**：无论特性是否启用，都导入 `MaybeLocation`
2. **统一字段定义**：在 `CommandQueue` 中始终包含 `caller` 字段
3. **运行时条件检查**：使用 `into_option()` 方法在运行时决定行为

这种方法的关键洞察是：`MaybeLocation` 类型本身已经内部处理了特性标志，因此外部代码不需要重复进行条件编译。

### 具体实现分析

在 `command_queue.rs` 中，主要变化包括：

**导入统一化**：
```rust
// 之前：
#[cfg(feature = "track_location")]
use crate::change_detection::MaybeLocation;

// 之后：
use crate::change_detection::MaybeLocation;
```

**字段定义统一化**：
```rust
// 之前：
#[cfg(feature = "track_location")]
pub(crate) caller: MaybeLocation,

// 之后：
pub(crate) caller: MaybeLocation,
```

**Debug 实现简化**：
```rust
// 之前：
let mut binding = f.debug_struct("CommandQueue");
binding.field("len_bytes", &self.bytes.len());

#[cfg(feature = "track_location")]
binding.field("caller", &self.caller.into_option());

binding.finish_non_exhaustive()

// 之后：
f.debug_struct("CommandQueue")
    .field("len_bytes", &self.bytes.len())
    .field("caller", &self.caller)
    .finish_non_exhaustive()
```

**警告消息的条件化处理**：
```rust
// 之前：
#[cfg(feature = "track_location")]
warn!("CommandQueue has un-applied commands being dropped. Did you forget to call SystemState::apply? caller:{:?}",self.caller.into_option());
#[cfg(not(feature = "track_location"))]
warn!("CommandQueue has un-applied commands being dropped. Did you forget to call SystemState::apply?");

// 之后：
if let Some(caller) = self.caller.into_option() {
    warn!("CommandQueue has un-applied commands being dropped. Did you forget to call SystemState::apply? caller:{caller:?}");
} else {
    warn!("CommandQueue has un-applied commands being dropped. Did you forget to call SystemState::apply?");
}
```

在 `entity_ref.rs` 的测试代码中，同样采用了运行时条件检查：

```rust
// 之前使用条件编译的测试代码被替换为：
if let (Some(e1_spawned), Some(e1_despawned)) =
    (e1_spawned.into_option(), e1_despawned.into_option())
{
    assert!(e1_despawned.is_some());
    assert_ne!(Some(e1_spawned), e1_despawned);
}
```

### 技术优势

这种重构带来了几个重要的技术优势：

1. **编译时安全性**：现在无论特性是否启用，所有代码都会被编译器检查，减少了潜在的编译错误
2. **代码可维护性**：消除了重复的条件编译逻辑，使代码更清晰
3. **API 一致性**：`MaybeLocation` 现在可以在 `bevy_ecs` 之外使用，无需额外的特性标志
4. **测试覆盖**：测试代码现在会在所有构建配置下运行，提高了测试覆盖率

### 架构影响

这个变化体现了良好的软件设计原则：将条件逻辑封装在适当的抽象层。`MaybeLocation` 类型现在完全负责处理 `track_location` 特性的细节，外部代码只需与统一的接口交互。

这种方法也使得未来更容易修改或移除 `track_location` 特性，因为变化只需要在 `MaybeLocation` 的实现中处理。

## Visual Representation

```mermaid
graph TD
    A[External Code] --> B[MaybeLocation Type]
    B --> C[track_location feature]
    B --> D[.into_option() method]
    D --> E[SomeLocation when enabled]
    D --> F[None when disabled]
    
    G[CommandQueue] --> B
    H[EntityRef Tests] --> B
```

## Key Files Changed

### `crates/bevy_ecs/src/world/command_queue.rs` (+10/-15)

这个文件包含了主要的架构改进，移除了分散的条件编译，统一使用 `MaybeLocation` 的运行时接口。

**关键修改：**
```rust
// 结构体定义 - 移除了条件编译
pub struct CommandQueue {
    pub(crate) bytes: Vec<MaybeUninit<u8>>,
    pub(crate) cursor: usize,
    pub(crate) panic_recovery: Vec<MaybeUninit<u8>>,
    pub(crate) caller: MaybeLocation,  // 不再有条件编译
}

// Debug 实现 - 简化了代码结构
fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    f.debug_struct("CommandQueue")
        .field("len_bytes", &self.bytes.len())
        .field("caller", &self.caller)  // 直接使用 caller，无需条件编译
        .finish_non_exhaustive()
}

// Drop 实现 - 使用运行时条件检查
fn drop(&mut self) {
    if !self.bytes.is_empty() {
        if let Some(caller) = self.caller.into_option() {
            warn!("... caller:{caller:?}");  // 有条件的信息
        } else {
            warn!("...");  // 无条件的信息
        }
    }
    // ... 其余代码
}
```

### `crates/bevy_ecs/src/world/entity_ref.rs` (+8/-4)

测试代码被重构为使用运行时条件检查，而不是编译时条件。

**关键修改：**
```rust
// 测试代码 - 使用运行时条件而非编译时条件
let e1_spawned = world.entity(id1).spawned_by();
let e1_despawned = world.entities().entity_get_spawned_or_despawned_by(id1);

// 只在 track_location 启用时运行断言
if let (Some(e1_spawned), Some(e1_despawned)) =
    (e1_spawned.into_option(), e1_despawned.into_option())
{
    assert!(e1_despawned.is_some());
    assert_ne!(Some(e1_spawned), e1_despawned);
}
```

## Further Reading

- [Rust 条件编译文档](https://doc.rust-lang.org/reference/conditional-compilation.html)
- [Bevy ECS 架构指南](https://bevyengine.org/learn/quick-start/ecs/)
- [Rust 特性标志最佳实践](https://doc.rust-lang.org/cargo/reference/features.html)
- [MaybeLocation 类型实现](https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/src/change_detection.rs)