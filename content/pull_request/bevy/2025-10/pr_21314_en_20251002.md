+++
title = "#21314 `font_count` method"
date = "2025-10-02T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-10/pr-21314-en-20251002" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-10/pr-21314-zh-cn-20251002" }}
labels = ["D-Trivial", "A-Text"]
+++

# Title

## Basic Information
- **Title**: `font_count` method
- **PR Link**: https://github.com/bevyengine/bevy/pull/21314
- **Author**: ickshonpe
- **Status**: MERGED
- **Labels**: D-Trivial, S-Ready-For-Final-Review, A-Text
- **Created**: 2025-10-01T08:26:24Z
- **Merged**: 2025-10-02T20:41:24Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

Splitting off some trivial changes from the text rework.

This adds a method that counts the number of rasterized fonts stored in `FontAtlasSets`.

# Solution

Return the sum of the lengths of all the sets.

## The Story of This Pull Request

This pull request introduces a straightforward but useful utility method to the Bevy text system. The developer was working on a larger text system rework and identified a simple enhancement that could be extracted as a separate, self-contained change.

The core problem addressed is the need to quickly determine how many rasterized fonts exist across all font atlas sets in the system. Previously, if a developer wanted to get this information, they would need to manually iterate through all the sets and sum their lengths, which is exactly what this PR encapsulates into a clean API.

The implementation follows a logical approach: the `FontAtlasSets` struct already contains a HashMap of `FontAtlasSet` instances, each tracking rasterized font glyphs for a specific font. The new `font_count` method simply iterates through all these sets and sums their individual lengths using Rust's iterator combinators.

From an engineering perspective, this change demonstrates good API design principles. It provides a convenient method for a common operation that would otherwise require boilerplate code. The implementation is efficient - it performs a single pass over the sets with O(n) complexity where n is the number of font sets, which is appropriate for this type of utility method.

The method signature is clean and follows Rust conventions: `pub fn font_count(&self) -> usize` returns the count as a simple integer without any allocation or complex return types. This makes it easy to use in performance-sensitive contexts like rendering systems or diagnostics.

This change fits well into Bevy's architecture because it extends existing functionality without modifying the core data structures or algorithms. The `FontAtlasSets` struct already had methods for accessing individual sets (`get` and `get_mut`), so adding a method for aggregate information is a natural extension.

## Visual Representation

```mermaid
graph TD
    A[FontAtlasSets] --> B[HashMap<AssetId<Font>, FontAtlasSet>]
    B --> C[FontAtlasSet 1]
    B --> D[FontAtlasSet 2]
    B --> E[FontAtlasSet N]
    C --> F[len(): usize]
    D --> G[len(): usize]
    E --> H[len(): usize]
    A --> I[font_count(): usize]
    I --> J[Sum of all set lengths]
```

## Key Files Changed

### `crates/bevy_text/src/font_atlas_set.rs` (+6/-0)

This file contains the core change - adding the `font_count` method to the `FontAtlasSets` struct.

**Key modification:**
```rust
// File: crates/bevy_text/src/font_atlas_set.rs
// Before:
impl FontAtlasSets {
    pub fn get(&self, id: impl Into<AssetId<Font>>) -> Option<&FontAtlasSet> {
        let id: AssetId<Font> = id.into();
        self.sets.get(&id)
    }
    
    pub fn get_mut(&mut self, id: impl Into<AssetId<Font>>) -> Option<&mut FontAtlasSet> {
        let id: AssetId<Font> = id.into();
        self.sets.get_mut(&id)
    }
}

// After:
impl FontAtlasSets {
    pub fn get(&self, id: impl Into<AssetId<Font>>) -> Option<&FontAtlasSet> {
        let id: AssetId<Font> = id.into();
        self.sets.get(&id)
    }
    
    pub fn get_mut(&mut self, id: impl Into<AssetId<Font>>) -> Option<&mut FontAtlasSet> {
        let id: AssetId<Font> = id.into();
        self.sets.get_mut(&id)
    }

    /// Returns the total number of rasterized fonts across all sets.
    pub fn font_count(&self) -> usize {
        self.sets.values().map(FontAtlasSet::len).sum()
    }
}
```

The change adds a new public method that:
1. Iterates over all values in the `sets` HashMap using `self.sets.values()`
2. Maps each `FontAtlasSet` to its length using `FontAtlasSet::len`
3. Sums all the lengths using Rust's `sum()` method

This method provides a convenient way to get aggregate statistics about font usage across the entire system, which can be useful for debugging, profiling, or resource management.

## Further Reading

- [Rust Iterator Documentation](https://doc.rust-lang.org/std/iter/trait.Iterator.html) - For understanding the iterator methods used in the implementation
- [Bevy Text System Documentation](https://docs.rs/bevy_text/latest/bevy_text/) - For context on how font atlases work in Bevy
- [HashMap API Documentation](https://doc.rust-lang.org/std/collections/struct.HashMap.html) - For understanding the data structure being iterated over

# Full Code Diff
```diff
diff --git a/crates/bevy_text/src/font_atlas_set.rs b/crates/bevy_text/src/font_atlas_set.rs
index b1d70ea7e66f3..4979b1054a172 100644
--- a/crates/bevy_text/src/font_atlas_set.rs
+++ b/crates/bevy_text/src/font_atlas_set.rs
@@ -21,11 +21,17 @@ impl FontAtlasSets {
         let id: AssetId<Font> = id.into();
         self.sets.get(&id)
     }
+
     /// Get a mutable reference to the [`FontAtlasSet`] with the given font asset id.
     pub fn get_mut(&mut self, id: impl Into<AssetId<Font>>) -> Option<&mut FontAtlasSet> {
         let id: AssetId<Font> = id.into();
         self.sets.get_mut(&id)
     }
+
+    /// Returns the total number of rasterized fonts across all sets.
+    pub fn font_count(&self) -> usize {
+        self.sets.values().map(FontAtlasSet::len).sum()
+    }
 }
 
 /// A system that cleans up [`FontAtlasSet`]s for removed [`Font`]s
```