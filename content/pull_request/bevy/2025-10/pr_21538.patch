diff --git a/crates/bevy_camera_controller/src/free_cam.rs b/crates/bevy_camera_controller/src/free_cam.rs
index b640786b18bdc..37a064d00ba98 100644
--- a/crates/bevy_camera_controller/src/free_cam.rs
+++ b/crates/bevy_camera_controller/src/free_cam.rs
@@ -10,7 +10,8 @@
 //! By contrast, the default settings of this particular free cam are optimized for precise control.
 //!
 //! To use this controller, add [`FreeCamPlugin`] to your app,
-//! and [`FreeCam`] to your camera entity.
+//! and attach the [`FreeCam`] component to your camera entity.
+//! The required [`FreeCamState`] component will be added automatically.
 //!
 //! To configure the settings of this controller, modify the fields of the [`FreeCam`] component.
 
@@ -32,8 +33,8 @@ use core::{f32::consts::*, fmt};
 
 /// A freecam-style camera controller plugin.
 ///
-/// Use [`FreeCam`] to add a freecam controller to a camera entity,
-/// and change its values to customize the controls and change its behavior.
+/// Use the [`FreeCam`] struct to add and customize the controller for a camera entity.
+/// The camera's dynamic state is managed by the [`FreeCamState`] struct.
 pub struct FreeCamPlugin;
 
 impl Plugin for FreeCamPlugin {
@@ -53,16 +54,22 @@ impl Plugin for FreeCamPlugin {
 /// it because it felt nice.
 const RADIANS_PER_DOT: f32 = 1.0 / 180.0;
 
-/// Freecam controller settings and state.
+/// Stores the settings for the [`FreeCam`] controller.
 ///
-/// Add this component to a [`Camera`] entity and add [`FreeCamPlugin`]
-/// to your [`App`] to enable freecam controls.
+/// This component defines static configuration for camera controls,
+/// including movement speed, sensitivity, and input bindings.
+///
+/// From the controllerâ€™s perspective, this data is treated as immutable,
+/// but it may be modified externally (e.g., by a settings UI) at runtime.
+///
+/// Add this component to a [`Camera`] entity to enable freecam controls.
+/// The associated dynamic state is automatically handled by [`FreeCamState`],
+/// which is added to the entity as a required component.
+///
+/// To activate the controller, add the [`FreeCamPlugin`] to your [`App`].
 #[derive(Component)]
+#[require(FreeCamState)]
 pub struct FreeCam {
-    /// Enables this [`FreeCam`] when `true`.
-    pub enabled: bool,
-    /// Indicates if this controller has been initialized by the [`FreeCamPlugin`].
-    pub initialized: bool,
     /// Multiplier for pitch and yaw rotation speed.
     pub sensitivity: f32,
     /// [`KeyCode`] for forward translation.
@@ -84,28 +91,20 @@ pub struct FreeCam {
     pub mouse_key_cursor_grab: MouseButton,
     /// [`KeyCode`] for grabbing the keyboard focus.
     pub keyboard_key_toggle_cursor_grab: KeyCode,
-    /// Multiplier for unmodified translation speed.
+    /// Base multiplier for unmodified translation speed.
     pub walk_speed: f32,
-    /// Multiplier for running translation speed.
+    /// Base multiplier for running translation speed.
     pub run_speed: f32,
     /// Multiplier for how the mouse scroll wheel modifies [`walk_speed`](FreeCam::walk_speed)
     /// and [`run_speed`](FreeCam::run_speed).
     pub scroll_factor: f32,
-    /// Friction factor used to exponentially decay [`velocity`](FreeCam::velocity) over time.
+    /// Friction factor used to exponentially decay [`velocity`](FreeCamState::velocity) over time.
     pub friction: f32,
-    /// This [`FreeCam`]'s pitch rotation.
-    pub pitch: f32,
-    /// This [`FreeCam`]'s yaw rotation.
-    pub yaw: f32,
-    /// This [`FreeCam`]'s translation velocity.
-    pub velocity: Vec3,
 }
 
 impl Default for FreeCam {
     fn default() -> Self {
         Self {
-            enabled: true,
-            initialized: false,
             sensitivity: 0.2,
             key_forward: KeyCode::KeyW,
             key_back: KeyCode::KeyS,
@@ -120,9 +119,6 @@ impl Default for FreeCam {
             run_speed: 15.0,
             scroll_factor: 0.5,
             friction: 40.0,
-            pitch: 0.0,
-            yaw: 0.0,
-            velocity: Vec3::ZERO,
         }
     }
 }
@@ -154,10 +150,48 @@ Freecam Controls:
     }
 }
 
-/// This system is typically added via the [`FreeCamPlugin`].
+/// Tracks the runtime state of a [`FreeCam`] controller.
 ///
-/// Reads inputs and then moves the camera entity according
-/// to the settings given in [`FreeCam`].
+/// This component holds dynamic data that changes during camera operation,
+/// such as pitch, yaw, velocity, and whether the controller is currently enabled.
+///
+/// It is automatically added to any entity that has a [`FreeCam`] component,
+/// and is updated by the [`FreeCamPlugin`] systems in response to user input.
+#[derive(Component)]
+pub struct FreeCamState {
+    /// Enables [`FreeCam`] controls when `true`.
+    pub enabled: bool,
+    /// Internal flag indicating if this controller has been initialized by the [`FreeCamPlugin`].
+    initialized: bool,
+    /// This [`FreeCam`]'s pitch rotation.
+    pub pitch: f32,
+    /// This [`FreeCam`]'s yaw rotation.
+    pub yaw: f32,
+    /// Multiplier applied to movement speed.
+    pub speed_multiplier: f32,
+    /// This [`FreeCam`]'s translation velocity.
+    pub velocity: Vec3,
+}
+
+impl Default for FreeCamState {
+    fn default() -> Self {
+        Self {
+            enabled: true,
+            initialized: false,
+            pitch: 0.0,
+            yaw: 0.0,
+            speed_multiplier: 1.0,
+            velocity: Vec3::ZERO,
+        }
+    }
+}
+
+/// Updates the camera's position and orientation based on user input.
+///
+/// - [`FreeCam`] contains static configuration such as key bindings, movement speed, and sensitivity.
+/// - [`FreeCamState`] stores the dynamic runtime state, including pitch, yaw, velocity, and enable flags.
+///
+/// This system is typically added via the [`FreeCamPlugin`].
 pub fn run_freecam_controller(
     time: Res<Time<Real>>,
     mut windows: Query<(&Window, &mut CursorOptions)>,
@@ -167,23 +201,23 @@ pub fn run_freecam_controller(
     key_input: Res<ButtonInput<KeyCode>>,
     mut toggle_cursor_grab: Local<bool>,
     mut mouse_cursor_grab: Local<bool>,
-    mut query: Query<(&mut Transform, &mut FreeCam), With<Camera>>,
+    mut query: Query<(&mut Transform, &mut FreeCamState, &FreeCam), With<Camera>>,
 ) {
     let dt = time.delta_secs();
 
-    let Ok((mut transform, mut controller)) = query.single_mut() else {
+    let Ok((mut transform, mut state, controller)) = query.single_mut() else {
         return;
     };
 
-    if !controller.initialized {
+    if !state.initialized {
         let (yaw, pitch, _roll) = transform.rotation.to_euler(EulerRot::YXZ);
-        controller.yaw = yaw;
-        controller.pitch = pitch;
-        controller.initialized = true;
+        state.yaw = yaw;
+        state.pitch = pitch;
+        state.initialized = true;
         info!("{}", *controller);
     }
 
-    if !controller.enabled {
+    if !state.enabled {
         // don't keep the cursor grabbed if the controller was disabled.
         if *toggle_cursor_grab || *mouse_cursor_grab {
             *toggle_cursor_grab = false;
@@ -206,8 +240,9 @@ pub fn run_freecam_controller(
         }
     };
     scroll += amount;
-    controller.walk_speed += scroll * controller.scroll_factor * controller.walk_speed;
-    controller.run_speed = controller.walk_speed * 3.0;
+    state.speed_multiplier += scroll * controller.scroll_factor;
+    // Clamp the speed multiplier for safety
+    state.speed_multiplier = state.speed_multiplier.clamp(0.0, f32::MAX);
 
     // Handle key input
     let mut axis_input = Vec3::ZERO;
@@ -248,26 +283,26 @@ pub fn run_freecam_controller(
     // Update velocity
     if axis_input != Vec3::ZERO {
         let max_speed = if key_input.pressed(controller.key_run) {
-            controller.run_speed
+            controller.run_speed * state.speed_multiplier
         } else {
-            controller.walk_speed
+            controller.walk_speed * state.speed_multiplier
         };
-        controller.velocity = axis_input.normalize() * max_speed;
+        state.velocity = axis_input.normalize() * max_speed;
     } else {
         let friction = controller.friction.clamp(0.0, f32::MAX);
-        controller.velocity.smooth_nudge(&Vec3::ZERO, friction, dt);
-        if controller.velocity.length_squared() < 1e-6 {
-            controller.velocity = Vec3::ZERO;
+        state.velocity.smooth_nudge(&Vec3::ZERO, friction, dt);
+        if state.velocity.length_squared() < 1e-6 {
+            state.velocity = Vec3::ZERO;
         }
     }
 
     // Apply movement update
-    if controller.velocity != Vec3::ZERO {
+    if state.velocity != Vec3::ZERO {
         let forward = *transform.forward();
         let right = *transform.right();
-        transform.translation += controller.velocity.x * dt * right
-            + controller.velocity.y * dt * Vec3::Y
-            + controller.velocity.z * dt * forward;
+        transform.translation += state.velocity.x * dt * right
+            + state.velocity.y * dt * Vec3::Y
+            + state.velocity.z * dt * forward;
     }
 
     // Handle cursor grab
@@ -292,11 +327,10 @@ pub fn run_freecam_controller(
     // Handle mouse input
     if accumulated_mouse_motion.delta != Vec2::ZERO && cursor_grab {
         // Apply look update
-        controller.pitch = (controller.pitch
+        state.pitch = (state.pitch
             - accumulated_mouse_motion.delta.y * RADIANS_PER_DOT * controller.sensitivity)
             .clamp(-PI / 2., PI / 2.);
-        controller.yaw -=
-            accumulated_mouse_motion.delta.x * RADIANS_PER_DOT * controller.sensitivity;
-        transform.rotation = Quat::from_euler(EulerRot::ZYX, 0.0, controller.yaw, controller.pitch);
+        state.yaw -= accumulated_mouse_motion.delta.x * RADIANS_PER_DOT * controller.sensitivity;
+        transform.rotation = Quat::from_euler(EulerRot::ZYX, 0.0, state.yaw, state.pitch);
     }
 }
diff --git a/examples/camera/free_cam_controller.rs b/examples/camera/free_cam_controller.rs
index 1443dda8519f3..05240e5c4e9c4 100644
--- a/examples/camera/free_cam_controller.rs
+++ b/examples/camera/free_cam_controller.rs
@@ -41,7 +41,7 @@
 use std::f32::consts::{FRAC_PI_4, PI};
 
 use bevy::{
-    camera_controller::free_cam::{FreeCam, FreeCamPlugin},
+    camera_controller::free_cam::{FreeCam, FreeCamPlugin, FreeCamState},
     color::palettes::tailwind,
     prelude::*,
 };
@@ -130,8 +130,11 @@ fn spawn_text(mut commands: Commands, freecam_query: Query<&FreeCam>) {
     ));
 }
 
-fn update_camera_settings(mut camera_query: Query<&mut FreeCam>, input: Res<ButtonInput<KeyCode>>) {
-    let mut free_cam = camera_query.single_mut().unwrap();
+fn update_camera_settings(
+    mut camera_query: Query<(&mut FreeCam, &mut FreeCamState)>,
+    input: Res<ButtonInput<KeyCode>>,
+) {
+    let (mut free_cam, mut free_cam_state) = camera_query.single_mut().unwrap();
 
     if input.pressed(KeyCode::KeyZ) {
         free_cam.sensitivity = (free_cam.sensitivity - 0.005).max(0.005);
@@ -152,24 +155,27 @@ fn update_camera_settings(mut camera_query: Query<&mut FreeCam>, input: Res<Butt
         free_cam.scroll_factor += 0.02;
     }
     if input.just_pressed(KeyCode::KeyB) {
-        free_cam.enabled = !free_cam.enabled;
+        free_cam_state.enabled = !free_cam_state.enabled;
     }
 }
 
-fn update_text(mut text_query: Query<&mut Text, With<InfoText>>, camera_query: Query<&FreeCam>) {
+fn update_text(
+    mut text_query: Query<&mut Text, With<InfoText>>,
+    camera_query: Query<(&FreeCam, &FreeCamState)>,
+) {
     let mut text = text_query.single_mut().unwrap();
 
-    let free_cam = camera_query.single().unwrap();
+    let (free_cam, free_cam_state) = camera_query.single().unwrap();
 
     text.0 = format!(
         "Enabled: {},\nSensitivity: {:.03}\nFriction: {:.01}\nScroll factor: {:.02}\nWalk Speed: {:.02}\nRun Speed: {:.02}\nSpeed: {:.02}",
-        free_cam.enabled,
+        free_cam_state.enabled,
         free_cam.sensitivity,
         free_cam.friction,
         free_cam.scroll_factor,
         free_cam.walk_speed,
         free_cam.run_speed,
-        free_cam.velocity.length(),
+        free_cam_state.velocity.length(),
     );
 }
 
