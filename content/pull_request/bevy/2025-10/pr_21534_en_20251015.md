+++
title = "#21534 Do not attempt to grab pointer on web if unsupported."
date = "2025-10-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-10/pr-21534-en-20251015" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-10/pr-21534-zh-cn-20251015" }}
labels = ["C-Bug", "A-Windowing", "P-Crash", "P-Regression", "X-Contentious"]
+++

# Do not attempt to grab pointer on web if unsupported.

## Basic Information
- **Title**: Do not attempt to grab pointer on web if unsupported.
- **PR Link**: https://github.com/bevyengine/bevy/pull/21534
- **Author**: rectalogic
- **Status**: MERGED
- **Labels**: C-Bug, A-Windowing, P-Crash, S-Ready-For-Final-Review, P-Regression, X-Contentious
- **Created**: 2025-10-13T21:02:57Z
- **Merged**: 2025-10-14T21:46:31Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

Fixes https://github.com/bevyengine/bevy/issues/21497

## Solution

Mobile web does not support pointer APIs and panics if they are used. Check if they exist before using them.

## Testing

Tested on iOS Safari using https://github.com/rectalogic/pointerlock

## The Story of This Pull Request

This PR addresses a critical crash issue that occurred when Bevy applications attempted to use pointer grab functionality on mobile web browsers. The problem stemmed from the fact that mobile web platforms like iOS Safari don't support the Pointer Lock API, which is part of the web's pointer handling capabilities.

The issue manifested as a panic when Bevy's cursor grab system tried to use pointer APIs that simply don't exist in mobile browser environments. This was a regression that broke Bevy applications on mobile web platforms, making them crash immediately when attempting to initialize cursor grab functionality.

The solution implemented here follows a defensive programming approach. Rather than assuming pointer APIs are available on all web platforms, the code now performs a runtime check to verify the existence of the required APIs before attempting to use them. This is particularly important for web targets where feature availability can vary significantly between desktop and mobile browsers, and even between different mobile browsers.

The implementation adds a new `pointer_supported()` function that uses JavaScript reflection to check for the presence of the `exitPointerLock` method on the document object. This method is part of the Pointer Lock API specification, so its presence indicates that the browser supports pointer locking functionality. The check is wrapped in proper error handling that returns `ExternalError::Ignored` if the necessary web APIs aren't available, allowing the application to continue running without the pointer grab feature rather than crashing.

In the `attempt_grab` function, this check is now performed conditionally for wasm32 targets before any pointer operations are attempted. If pointer APIs aren't supported, the function returns early with an `ExternalError::Ignored`, effectively making the pointer grab operation a no-op on unsupported platforms. This approach maintains compatibility with existing code while preventing crashes.

The technical approach demonstrates good cross-platform development practices. By checking for feature availability at runtime rather than relying solely on compile-time feature detection, the solution handles the reality that web platform capabilities can vary even within the same architecture (wasm32). The use of `js_sys::Reflect::has` provides a robust way to check for API availability without making assumptions about the execution environment.

This fix is minimal and surgical - it only affects the specific code path that was causing crashes and doesn't change the behavior on platforms that properly support pointer APIs. The addition of the `js-sys` dependency is necessary for the JavaScript reflection capabilities but doesn't significantly impact bundle size or performance.

## Visual Representation

```mermaid
graph TD
    A[attempt_grab called] --> B{Is target wasm32?}
    B -->|Yes| C[Check pointer_supported()]
    B -->|No| D[Proceed with normal grab logic]
    C -->|Not Supported| E[Return ExternalError::Ignored]
    C -->|Supported| D
    D --> F[Execute pointer grab operations]
```

## Key Files Changed

### `crates/bevy_winit/Cargo.toml`
Added the `js-sys` dependency for wasm32 targets, which provides Rust bindings for JavaScript's standard library and enables JavaScript reflection capabilities needed for runtime feature detection.

```toml
[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = { version = "0.2" }
web-sys = "0.3"
+ js-sys = "0.3"
```

### `crates/bevy_winit/src/winit_windows.rs`
Added runtime pointer API detection and early return for unsupported platforms.

```rust
#[cfg(target_arch = "wasm32")]
fn pointer_supported() -> Result<bool, ExternalError> {
    Ok(js_sys::Reflect::has(
        web_sys::window()
            .ok_or(ExternalError::Ignored)?
            .document()
            .ok_or(ExternalError::Ignored)?
            .as_ref(),
        &"exitPointerLock".into(),
    )
    .unwrap_or(false))
}

pub(crate) fn attempt_grab(
    winit_window: &WinitWindow,
    grab_mode: CursorGrabMode,
) -> Result<(), ExternalError> {
    // Do not attempt to grab on web if unsupported (e.g. mobile)
    #[cfg(target_arch = "wasm32")]
    if !pointer_supported()? {
        return Err(ExternalError::Ignored);
    }

    let grab_result = match grab_mode {
        // ... rest of the function unchanged
```

## Further Reading

- [MDN Web Docs: Pointer Lock API](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API)
- [WASM-bindgen documentation](https://rustwasm.github.io/wasm-bindgen/)
- [js-sys crate documentation](https://docs.rs/js-sys/latest/js_sys/)
- [Bevy Web Assembly Guide](https://bevyengine.org/learn/quick-start/platforms/wasm/)