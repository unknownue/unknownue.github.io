diff --git a/crates/bevy_sprite_render/src/text2d/mod.rs b/crates/bevy_sprite_render/src/text2d/mod.rs
index b839edeba8058..74e6a69823b5a 100644
--- a/crates/bevy_sprite_render/src/text2d/mod.rs
+++ b/crates/bevy_sprite_render/src/text2d/mod.rs
@@ -6,7 +6,7 @@ use bevy_camera::visibility::ViewVisibility;
 use bevy_color::LinearRgba;
 use bevy_ecs::{
     entity::Entity,
-    query::With,
+    query::Has,
     system::{Commands, Query, Res, ResMut},
 };
 use bevy_image::prelude::*;
@@ -16,7 +16,7 @@ use bevy_render::Extract;
 use bevy_sprite::{Anchor, Text2dShadow};
 use bevy_text::{
     ComputedTextBlock, PositionedGlyph, Strikethrough, TextBackgroundColor, TextBounds, TextColor,
-    TextLayoutInfo,
+    TextLayoutInfo, Underline,
 };
 use bevy_transform::prelude::GlobalTransform;
 
@@ -41,7 +41,7 @@ pub fn extract_text2d_sprite(
     >,
     text_colors: Extract<Query<&TextColor>>,
     text_background_colors_query: Extract<Query<&TextBackgroundColor>>,
-    strikethrough_query: Extract<Query<&TextColor, With<Strikethrough>>>,
+    decoration_query: Extract<Query<(&TextColor, Has<Strikethrough>, Has<Underline>)>>,
 ) {
     let mut start = extracted_slices.slices.len();
     let mut end = start + 1;
@@ -71,7 +71,7 @@ pub fn extract_text2d_sprite(
 
         let top_left = (Anchor::TOP_LEFT.0 - anchor.as_vec()) * size;
 
-        for &(section_index, rect, _, _) in text_layout_info.section_geometry.iter() {
+        for &(section_index, rect, _, _, _) in text_layout_info.section_geometry.iter() {
             let section_entity = computed_block.entities()[section_index].entity;
             let Ok(text_background_color) = text_background_colors_query.get(section_entity) else {
                 continue;
@@ -149,32 +149,59 @@ pub fn extract_text2d_sprite(
                 end += 1;
             }
 
-            for &(section_index, rect, strikethrough_y, stroke) in
+            for &(section_index, rect, strikethrough_y, stroke, underline_y) in
                 text_layout_info.section_geometry.iter()
             {
                 let section_entity = computed_block.entities()[section_index].entity;
-                let Ok(_) = strikethrough_query.get(section_entity) else {
+                let Ok((_, has_strikethrough, has_underline)) =
+                    decoration_query.get(section_entity)
+                else {
                     continue;
                 };
-                let render_entity = commands.spawn(TemporaryRenderEntity).id();
-                let offset = Vec2::new(rect.center().x, -strikethrough_y - 0.5 * stroke);
-                let transform =
-                    shadow_transform * GlobalTransform::from_translation(offset.extend(0.));
-                extracted_sprites.sprites.push(ExtractedSprite {
-                    main_entity,
-                    render_entity,
-                    transform,
-                    color,
-                    image_handle_id: AssetId::default(),
-                    flip_x: false,
-                    flip_y: false,
-                    kind: ExtractedSpriteKind::Single {
-                        anchor: Vec2::ZERO,
-                        rect: None,
-                        scaling_mode: None,
-                        custom_size: Some(Vec2::new(rect.size().x, stroke)),
-                    },
-                });
+
+                if has_strikethrough {
+                    let render_entity = commands.spawn(TemporaryRenderEntity).id();
+                    let offset = Vec2::new(rect.center().x, -strikethrough_y - 0.5 * stroke);
+                    let transform =
+                        shadow_transform * GlobalTransform::from_translation(offset.extend(0.));
+                    extracted_sprites.sprites.push(ExtractedSprite {
+                        main_entity,
+                        render_entity,
+                        transform,
+                        color,
+                        image_handle_id: AssetId::default(),
+                        flip_x: false,
+                        flip_y: false,
+                        kind: ExtractedSpriteKind::Single {
+                            anchor: Vec2::ZERO,
+                            rect: None,
+                            scaling_mode: None,
+                            custom_size: Some(Vec2::new(rect.size().x, stroke)),
+                        },
+                    });
+                }
+
+                if has_underline {
+                    let render_entity = commands.spawn(TemporaryRenderEntity).id();
+                    let offset = Vec2::new(rect.center().x, -underline_y - 0.5 * stroke);
+                    let transform =
+                        shadow_transform * GlobalTransform::from_translation(offset.extend(0.));
+                    extracted_sprites.sprites.push(ExtractedSprite {
+                        main_entity,
+                        render_entity,
+                        transform,
+                        color,
+                        image_handle_id: AssetId::default(),
+                        flip_x: false,
+                        flip_y: false,
+                        kind: ExtractedSpriteKind::Single {
+                            anchor: Vec2::ZERO,
+                            rect: None,
+                            scaling_mode: None,
+                            custom_size: Some(Vec2::new(rect.size().x, stroke)),
+                        },
+                    });
+                }
             }
         }
 
@@ -239,34 +266,62 @@ pub fn extract_text2d_sprite(
             end += 1;
         }
 
-        for &(section_index, rect, strikethrough_y, stroke) in
+        for &(section_index, rect, strikethrough_y, stroke, underline_y) in
             text_layout_info.section_geometry.iter()
         {
             let section_entity = computed_block.entities()[section_index].entity;
-            let Ok(text_color) = strikethrough_query.get(section_entity) else {
+            let Ok((text_color, has_strike_through, has_underline)) =
+                decoration_query.get(section_entity)
+            else {
                 continue;
             };
-            let render_entity = commands.spawn(TemporaryRenderEntity).id();
-            let offset = Vec2::new(rect.center().x, -strikethrough_y - 0.5 * stroke);
-            let transform = *global_transform
-                * GlobalTransform::from_translation(top_left.extend(0.))
-                * scaling
-                * GlobalTransform::from_translation(offset.extend(0.));
-            extracted_sprites.sprites.push(ExtractedSprite {
-                main_entity,
-                render_entity,
-                transform,
-                color: text_color.0.into(),
-                image_handle_id: AssetId::default(),
-                flip_x: false,
-                flip_y: false,
-                kind: ExtractedSpriteKind::Single {
-                    anchor: Vec2::ZERO,
-                    rect: None,
-                    scaling_mode: None,
-                    custom_size: Some(Vec2::new(rect.size().x, stroke)),
-                },
-            });
+            if has_strike_through {
+                let render_entity = commands.spawn(TemporaryRenderEntity).id();
+                let offset = Vec2::new(rect.center().x, -strikethrough_y - 0.5 * stroke);
+                let transform = *global_transform
+                    * GlobalTransform::from_translation(top_left.extend(0.))
+                    * scaling
+                    * GlobalTransform::from_translation(offset.extend(0.));
+                extracted_sprites.sprites.push(ExtractedSprite {
+                    main_entity,
+                    render_entity,
+                    transform,
+                    color: text_color.0.into(),
+                    image_handle_id: AssetId::default(),
+                    flip_x: false,
+                    flip_y: false,
+                    kind: ExtractedSpriteKind::Single {
+                        anchor: Vec2::ZERO,
+                        rect: None,
+                        scaling_mode: None,
+                        custom_size: Some(Vec2::new(rect.size().x, stroke)),
+                    },
+                });
+            }
+
+            if has_underline {
+                let render_entity = commands.spawn(TemporaryRenderEntity).id();
+                let offset = Vec2::new(rect.center().x, -underline_y - 0.5 * stroke);
+                let transform = *global_transform
+                    * GlobalTransform::from_translation(top_left.extend(0.))
+                    * scaling
+                    * GlobalTransform::from_translation(offset.extend(0.));
+                extracted_sprites.sprites.push(ExtractedSprite {
+                    main_entity,
+                    render_entity,
+                    transform,
+                    color: text_color.0.into(),
+                    image_handle_id: AssetId::default(),
+                    flip_x: false,
+                    flip_y: false,
+                    kind: ExtractedSpriteKind::Single {
+                        anchor: Vec2::ZERO,
+                        rect: None,
+                        scaling_mode: None,
+                        custom_size: Some(Vec2::new(rect.size().x, stroke)),
+                    },
+                });
+            }
         }
     }
 }
diff --git a/crates/bevy_text/src/lib.rs b/crates/bevy_text/src/lib.rs
index 1c6756e28db95..55f92098c0917 100644
--- a/crates/bevy_text/src/lib.rs
+++ b/crates/bevy_text/src/lib.rs
@@ -60,7 +60,7 @@ pub mod prelude {
     #[doc(hidden)]
     pub use crate::{
         Font, Justify, LineBreak, Strikethrough, TextColor, TextError, TextFont, TextLayout,
-        TextSpan,
+        TextSpan, Underline,
     };
 }
 
diff --git a/crates/bevy_text/src/pipeline.rs b/crates/bevy_text/src/pipeline.rs
index ae67c1a27063f..7f267e52020c6 100644
--- a/crates/bevy_text/src/pipeline.rs
+++ b/crates/bevy_text/src/pipeline.rs
@@ -77,7 +77,7 @@ pub struct TextPipeline {
     /// See [this dark magic](https://users.rust-lang.org/t/how-to-cache-a-vectors-capacity/94478/10).
     spans_buffer: Vec<(usize, &'static str, &'static TextFont, FontFaceInfo)>,
     /// Buffered vec for collecting info for glyph assembly.
-    glyph_info: Vec<(AssetId<Font>, FontSmoothing, f32, f32, f32)>,
+    glyph_info: Vec<(AssetId<Font>, FontSmoothing, f32, f32, f32, f32)>,
 }
 
 impl TextPipeline {
@@ -254,6 +254,7 @@ impl TextPipeline {
                 text_font.font_size,
                 0.,
                 0.,
+                0.,
             ));
         });
 
@@ -272,7 +273,9 @@ impl TextPipeline {
 
         update_result?;
 
-        for (font, _, size, strike_offset, stroke) in self.glyph_info.iter_mut() {
+        for (font, _, size, strikethrough_offset, stroke, underline_offset) in
+            self.glyph_info.iter_mut()
+        {
             let Some((id, _)) = self.map_handle_to_font_id.get(font) else {
                 continue;
             };
@@ -281,8 +284,9 @@ impl TextPipeline {
                 let metrics = swash.metrics(&[]);
                 let upem = metrics.units_per_em as f32;
                 let scalar = *size * scale_factor as f32 / upem;
-                *strike_offset = (metrics.strikeout_offset * scalar).round();
+                *strikethrough_offset = (metrics.strikeout_offset * scalar).round();
                 *stroke = (metrics.stroke_size * scalar).round().max(1.);
+                *underline_offset = (metrics.underline_offset * scalar).round();
             }
         }
 
@@ -311,6 +315,7 @@ impl TextPipeline {
                                     ),
                                     (run.line_y - self.glyph_info[section].3).round(),
                                     self.glyph_info[section].4,
+                                    (run.line_y - self.glyph_info[section].5).round(),
                                 ));
                                 start = end.max(layout_glyph.x);
                                 current_section = Some(layout_glyph.metadata);
@@ -401,6 +406,7 @@ impl TextPipeline {
                     Rect::new(start, run.line_top, end, run.line_top + run.line_height),
                     (run.line_y - self.glyph_info[section].3).round(),
                     self.glyph_info[section].4,
+                    (run.line_y - self.glyph_info[section].5).round(),
                 ));
             }
 
@@ -481,9 +487,9 @@ pub struct TextLayoutInfo {
     pub scale_factor: f32,
     /// Scaled and positioned glyphs in screenspace
     pub glyphs: Vec<PositionedGlyph>,
-    /// Geometry of each text segment: (section index, bounding rect, strikeout offset, strikeout stroke thickness)
+    /// Geometry of each text segment: (section index, bounding rect, strikethrough offset, stroke thickness, underline offset)
     /// A text section spanning more than one line will have multiple segments.
-    pub section_geometry: Vec<(usize, Rect, f32, f32)>,
+    pub section_geometry: Vec<(usize, Rect, f32, f32, f32)>,
     /// The glyphs resulting size
     pub size: Vec2,
 }
diff --git a/crates/bevy_text/src/text.rs b/crates/bevy_text/src/text.rs
index 83c0cb00bf4db..b9b98b1277bdb 100644
--- a/crates/bevy_text/src/text.rs
+++ b/crates/bevy_text/src/text.rs
@@ -430,6 +430,11 @@ pub enum LineBreak {
 #[reflect(Serialize, Deserialize, Clone, Default)]
 pub struct Strikethrough;
 
+/// Add to a text entity to draw its text with underline.
+#[derive(Component, Copy, Clone, Debug, Reflect, Default, Serialize, Deserialize)]
+#[reflect(Serialize, Deserialize, Clone, Default)]
+pub struct Underline;
+
 /// Determines which antialiasing method to use when rendering text. By default, text is
 /// rendered with grayscale antialiasing, but this can be changed to achieve a pixelated look.
 ///
diff --git a/crates/bevy_ui_render/src/lib.rs b/crates/bevy_ui_render/src/lib.rs
index e794c69a0e346..209dc84a9eec9 100644
--- a/crates/bevy_ui_render/src/lib.rs
+++ b/crates/bevy_ui_render/src/lib.rs
@@ -61,7 +61,7 @@ use gradient::GradientPlugin;
 use bevy_platform::collections::{HashMap, HashSet};
 use bevy_text::{
     ComputedTextBlock, PositionedGlyph, Strikethrough, TextBackgroundColor, TextColor,
-    TextLayoutInfo,
+    TextLayoutInfo, Underline,
 };
 use bevy_transform::components::GlobalTransform;
 use box_shadow::BoxShadowPlugin;
@@ -1021,7 +1021,7 @@ pub fn extract_text_shadows(
             &ComputedTextBlock,
         )>,
     >,
-    text_decoration_query: Extract<Query<&Strikethrough>>,
+    text_decoration_query: Extract<Query<(Has<Strikethrough>, Has<Underline>)>>,
     camera_map: Extract<UiCameraMap>,
 ) {
     let mut start = extracted_uinodes.glyphs.len();
@@ -1094,40 +1094,72 @@ pub fn extract_text_shadows(
             end += 1;
         }
 
-        for &(section_index, rect, strikethrough_y, stroke) in
+        for &(section_index, rect, strikethrough_y, stroke, underline_y) in
             text_layout_info.section_geometry.iter()
         {
             let section_entity = computed_block.entities()[section_index].entity;
-            if !text_decoration_query.contains(section_entity) {
+            let Ok((has_strikethrough, has_underline)) = text_decoration_query.get(section_entity)
+            else {
                 continue;
+            };
+
+            if has_strikethrough {
+                extracted_uinodes.uinodes.push(ExtractedUiNode {
+                    z_order: uinode.stack_index as f32 + stack_z_offsets::TEXT,
+                    render_entity: commands.spawn(TemporaryRenderEntity).id(),
+                    clip: clip.map(|clip| clip.clip),
+                    image: AssetId::default(),
+                    extracted_camera_entity,
+                    transform: node_transform
+                        * Affine2::from_translation(Vec2::new(
+                            rect.center().x,
+                            strikethrough_y + 0.5 * stroke,
+                        )),
+                    item: ExtractedUiItem::Node {
+                        color: shadow.color.into(),
+                        rect: Rect {
+                            min: Vec2::ZERO,
+                            max: Vec2::new(rect.size().x, stroke),
+                        },
+                        atlas_scaling: None,
+                        flip_x: false,
+                        flip_y: false,
+                        border: BorderRect::ZERO,
+                        border_radius: ResolvedBorderRadius::ZERO,
+                        node_type: NodeType::Rect,
+                    },
+                    main_entity: entity.into(),
+                });
             }
 
-            extracted_uinodes.uinodes.push(ExtractedUiNode {
-                z_order: uinode.stack_index as f32 + stack_z_offsets::TEXT,
-                render_entity: commands.spawn(TemporaryRenderEntity).id(),
-                clip: clip.map(|clip| clip.clip),
-                image: AssetId::default(),
-                extracted_camera_entity,
-                transform: node_transform
-                    * Affine2::from_translation(Vec2::new(
-                        rect.center().x,
-                        strikethrough_y + 0.5 * stroke,
-                    )),
-                item: ExtractedUiItem::Node {
-                    color: shadow.color.into(),
-                    rect: Rect {
-                        min: Vec2::ZERO,
-                        max: Vec2::new(rect.size().x, stroke),
+            if has_underline {
+                extracted_uinodes.uinodes.push(ExtractedUiNode {
+                    z_order: uinode.stack_index as f32 + stack_z_offsets::TEXT,
+                    render_entity: commands.spawn(TemporaryRenderEntity).id(),
+                    clip: clip.map(|clip| clip.clip),
+                    image: AssetId::default(),
+                    extracted_camera_entity,
+                    transform: node_transform
+                        * Affine2::from_translation(Vec2::new(
+                            rect.center().x,
+                            underline_y + 0.5 * stroke,
+                        )),
+                    item: ExtractedUiItem::Node {
+                        color: shadow.color.into(),
+                        rect: Rect {
+                            min: Vec2::ZERO,
+                            max: Vec2::new(rect.size().x, stroke),
+                        },
+                        atlas_scaling: None,
+                        flip_x: false,
+                        flip_y: false,
+                        border: BorderRect::ZERO,
+                        border_radius: ResolvedBorderRadius::ZERO,
+                        node_type: NodeType::Rect,
                     },
-                    atlas_scaling: None,
-                    flip_x: false,
-                    flip_y: false,
-                    border: BorderRect::ZERO,
-                    border_radius: ResolvedBorderRadius::ZERO,
-                    node_type: NodeType::Rect,
-                },
-                main_entity: entity.into(),
-            });
+                    main_entity: entity.into(),
+                });
+            }
         }
     }
 }
@@ -1148,7 +1180,10 @@ pub fn extract_text_decorations(
         )>,
     >,
     text_background_colors_query: Extract<
-        Query<(AnyOf<(&TextBackgroundColor, &Strikethrough)>, &TextColor)>,
+        Query<(
+            AnyOf<(&TextBackgroundColor, &Strikethrough, &Underline)>,
+            &TextColor,
+        )>,
     >,
     camera_map: Extract<UiCameraMap>,
 ) {
@@ -1176,11 +1211,11 @@ pub fn extract_text_decorations(
         let transform =
             Affine2::from(global_transform) * Affine2::from_translation(-0.5 * uinode.size());
 
-        for &(section_index, rect, strikethrough_y, stroke) in
+        for &(section_index, rect, strikethrough_y, stroke, underline_y) in
             text_layout_info.section_geometry.iter()
         {
             let section_entity = computed_block.entities()[section_index].entity;
-            let Ok(((text_background_color, maybe_strikethrough), text_color)) =
+            let Ok(((text_background_color, maybe_strikethrough, maybe_underline), text_color)) =
                 text_background_colors_query.get(section_entity)
             else {
                 continue;
@@ -1239,6 +1274,35 @@ pub fn extract_text_decorations(
                     main_entity: entity.into(),
                 });
             }
+
+            if maybe_underline.is_some() {
+                extracted_uinodes.uinodes.push(ExtractedUiNode {
+                    z_order: uinode.stack_index as f32 + stack_z_offsets::TEXT_STRIKETHROUGH,
+                    render_entity: commands.spawn(TemporaryRenderEntity).id(),
+                    clip: clip.map(|clip| clip.clip),
+                    image: AssetId::default(),
+                    extracted_camera_entity,
+                    transform: transform
+                        * Affine2::from_translation(Vec2::new(
+                            rect.center().x,
+                            underline_y + 0.5 * stroke,
+                        )),
+                    item: ExtractedUiItem::Node {
+                        color: text_color.0.to_linear(),
+                        rect: Rect {
+                            min: Vec2::ZERO,
+                            max: Vec2::new(rect.size().x, stroke),
+                        },
+                        atlas_scaling: None,
+                        flip_x: false,
+                        flip_y: false,
+                        border: BorderRect::ZERO,
+                        border_radius: ResolvedBorderRadius::ZERO,
+                        node_type: NodeType::Rect,
+                    },
+                    main_entity: entity.into(),
+                });
+            }
         }
     }
 }
diff --git a/examples/2d/text2d.rs b/examples/2d/text2d.rs
index c51be59a1d1ac..6a961a43df9d3 100644
--- a/examples/2d/text2d.rs
+++ b/examples/2d/text2d.rs
@@ -96,6 +96,7 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                 color: text_shadow_color,
                 ..default()
             },
+            Underline,
         )],
     ));
 
diff --git a/examples/ui/strikethrough.rs b/examples/ui/strikethrough.rs
index 2dfeb81630c12..2c5112e9ddcc9 100644
--- a/examples/ui/strikethrough.rs
+++ b/examples/ui/strikethrough.rs
@@ -48,13 +48,13 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                 Strikethrough,
                 TextBackgroundColor(GREEN.into()),
             ),
-            Text::new("normal"),
+            (Text::new("underline"), Underline),
             (
                 Text::new("struck"),
                 Strikethrough,
                 TextBackgroundColor(GREEN.into()),
                 children![
-                    TextSpan::new("normal"),
+                    (TextSpan::new("underline"), Underline),
                     (TextSpan::new("struck"), Strikethrough,)
                 ],
             ),
@@ -90,7 +90,8 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                         TextBackgroundColor(Color::BLACK)
                     ),
                     (
-                        TextSpan::new("\nnormal"),
+                        TextSpan::new("\nunderline"),
+                        Underline,
                         TextFont {
                             font_size: 30.,
                             ..default()
@@ -109,12 +110,13 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                         TextBackgroundColor(NAVY.into())
                     ),
                     (
-                        TextSpan::new("struck"),
+                        TextSpan::new("underlined and struck"),
                         TextFont {
                             font_size: 70.,
                             ..default()
                         },
                         Strikethrough,
+                        Underline,
                         TextColor(RED.into()),
                         TextBackgroundColor(NAVY.into())
                     )
diff --git a/examples/ui/text.rs b/examples/ui/text.rs
index ec0f6185efc04..5f4add3d7c646 100644
--- a/examples/ui/text.rs
+++ b/examples/ui/text.rs
@@ -7,6 +7,7 @@ use bevy::{
     color::palettes::css::GOLD,
     diagnostic::{DiagnosticsStore, FrameTimeDiagnosticsPlugin},
     prelude::*,
+    text::Underline,
 };
 
 fn main() {
@@ -32,6 +33,7 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
     commands.spawn((
         // Accepts a `String` or any type that converts into a `String`, such as `&str`
         Text::new("hello\nbevy!"),
+        Underline,
         TextFont {
             // This font is loaded and will be used instead of the default font.
             font: asset_server.load("fonts/FiraSans-Bold.ttf"),
diff --git a/release-content/release-notes/text_strikeout_and_underline.md b/release-content/release-notes/text_strikeout_and_underline.md
new file mode 100644
index 0000000000000..f8e7692f11924
--- /dev/null
+++ b/release-content/release-notes/text_strikeout_and_underline.md
@@ -0,0 +1,7 @@
+---
+title: Text strikethrough and underline support
+authors: ["@ickshonpe"]
+pull_requests: [21555, 21559]
+---
+
+`bevy_text` now supports strikethrough and underline. To display text with strikethrough or underline, just add the `Strikethrough` or `Underline` components to any `Text`, `Text2d`, or `TextSpan` entity.
