+++
title = "#21690 Add `From` for `Hashed`"
date = "2025-11-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-11/pr-21690-en-20251130" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-11/pr-21690-zh-cn-20251130" }}
labels = ["D-Trivial", "A-Utils", "X-Contentious"]
+++

# Title
Add `From` for `Hashed`

## Basic Information
- **Title**: Add `From` for `Hashed`
- **PR Link**: https://github.com/bevyengine/bevy/pull/21690
- **Author**: Shatur
- **Status**: MERGED
- **Labels**: D-Trivial, S-Ready-For-Final-Review, A-Utils, X-Contentious
- **Created**: 2025-10-29T20:57:12Z
- **Merged**: 2025-11-30T20:23:16Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- Calling `Hashed::new` could be annoying if a function accepts it.

## Solution

- Add `From` impl to allow creating functions that accepts `impl From<V>`.

## The Story of This Pull Request

This PR addresses an ergonomic issue with the `Hashed` type in Bevy's utility system. The `Hashed` struct is designed to store a value along with its precomputed hash, which is useful for performance optimization when the same value needs to be hashed multiple times.

The problem was straightforward: when writing functions that accept `Hashed` values, developers had to explicitly call `Hashed::new()` to wrap their values. This created unnecessary boilerplate and made APIs less flexible. For example, if you had a function that processed hashed values, you couldn't pass regular values directly - they had to be explicitly wrapped first.

The solution implemented is a classic Rust pattern - adding a `From` trait implementation. This allows automatic conversion from the base type `V` to `Hashed<V, H>` using Rust's `into()` method or through type coercion. The implementation is minimal and leverages the existing `Hashed::new()` functionality:

```rust
impl<V: Hash, H: BuildHasher + Default> From<V> for Hashed<V, H> {
    fn from(value: V) -> Self {
        Self::new(value)
    }
}
```

This change follows Rust's zero-cost abstraction principle - the conversion happens at compile time with no runtime overhead. The trait bounds ensure type safety: `V` must implement `Hash` (so it can be hashed) and `H` must implement both `BuildHasher` (to create hashers) and `Default` (to create default hasher instances).

The impact of this change is primarily about API ergonomics. Functions can now be written to accept `impl Into<Hashed<V, H>>` parameters, making them more flexible and reducing boilerplate for callers. This pattern is common throughout the Rust ecosystem and aligns with Rust's philosophy of making common patterns convenient.

The implementation is technically sound because it doesn't change any existing behavior - it only adds new capabilities. The `From` implementation delegates to the existing, well-tested `Hashed::new()` method, ensuring consistency.

## Visual Representation

```mermaid
graph LR
    A[Value V] --> B[From<V> implementation]
    B --> C[Hashed<V, H>]
    C --> D[Function accepting Hashed]
    
    E[Value V] --> F[Direct usage with into()]
    F --> D
```

## Key Files Changed

**File**: `crates/bevy_platform/src/hash.rs` (+6/-0)

This file contains the core implementation of the `Hashed` type. The change adds a `From` trait implementation that enables automatic conversion from values to their hashed counterparts.

**Key Changes**:
```rust
// Added implementation:
impl<V: Hash, H: BuildHasher + Default> From<V> for Hashed<V, H> {
    fn from(value: V) -> Self {
        Self::new(value)
    }
}
```

This implementation allows:
- Direct conversion: `Hashed::from(value)`
- Using `into()`: `value.into()`
- Function parameters accepting `impl Into<Hashed<V, H>>`

**Before the change**, usage required explicit wrapping:
```rust
fn process_hashed(hashed: Hashed<String>) { /* ... */ }

// Had to explicitly wrap:
process_hashed(Hashed::new(my_string));
```

**After the change**, usage is more ergonomic:
```rust
fn process_hashed(hashed: impl Into<Hashed<String>>) { /* ... */ }

// Can use any of these:
process_hashed(Hashed::new(my_string));
process_hashed(my_string.into());
process_hashed(my_string); // with Into parameter
```

## Further Reading

- [Rust `From` and `Into` Traits](https://doc.rust-lang.org/std/convert/trait.From.html)
- [Rust Trait Bounds](https://doc.rust-lang.org/book/ch10-02-traits.html#trait-bounds)
- [Zero-Cost Abstractions in Rust](https://blog.rust-lang.org/2015/05/11/traits.html)
- [Bevy Engine Documentation](https://bevyengine.org/learn/)

# Full Code Diff
```diff
diff --git a/crates/bevy_platform/src/hash.rs b/crates/bevy_platform/src/hash.rs
index 66814bc583623..812b88cd10572 100644
--- a/crates/bevy_platform/src/hash.rs
+++ b/crates/bevy_platform/src/hash.rs
@@ -66,6 +66,12 @@ impl<V, H> Hash for Hashed<V, H> {
     }
 }
 
+impl<V: Hash, H: BuildHasher + Default> From<V> for Hashed<V, H> {
+    fn from(value: V) -> Self {
+        Self::new(value)
+    }
+}
+
 impl<V, H> Deref for Hashed<V, H> {
     type Target = V;
 
```