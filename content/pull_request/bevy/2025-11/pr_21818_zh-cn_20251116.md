+++
title = "#21818 Allow deprecated `heapless::mpmc` to fix no_std builds"
date = "2025-11-16T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-11/pr-21818-en-20251116" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-11/pr-21818-zh-cn-20251116" }}
labels = ["C-Bug", "P-High", "O-Embedded"]
+++

# Allow deprecated `heapless::mpmc` to fix no_std builds

## Basic Information
- **Title**: Allow deprecated `heapless::mpmc` to fix no_std builds
- **PR Link**: https://github.com/bevyengine/bevy/pull/21818
- **Author**: cart
- **Status**: MERGED
- **Labels**: C-Bug, P-High, S-Ready-For-Final-Review, O-Embedded
- **Created**: 2025-11-12T21:26:43Z
- **Merged**: 2025-11-16T07:14:47Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

`heapless` 在他们的次要版本中刚刚弃用了 `mpmc` 模块，这破坏了我们的 `no_std` 构建（因为我们选择在有警告时中断构建）。

https://github.com/rust-embedded/heapless/issues/583
https://docs.rs/heapless/latest/heapless/mpmc/index.html

## Solution

短期解决方案是通过允许使用这个已弃用的函数来修复我们的构建。但值得调查：https://github.com/bevyengine/bevy/issues/21819

## The Story of This Pull Request

这个PR解决了一个直接的构建问题：由于外部依赖项`heapless`在次要版本更新中弃用了`mpmc`模块，导致Bevy的`no_std`构建失败。问题的根源在于Bevy项目配置了在出现警告时中断构建，而新引入的弃用警告触发了这一机制。

从技术角度看，`heapless`是一个为嵌入式和无标准库(no_std)环境设计的Rust集合库，其`mpmc`模块提供了多生产者多消费者队列。虽然该模块已被标记为弃用，但Bevy的`edge_executor`仍然依赖它来构建任务执行器。

开发者选择了最直接的解决方案：在代码中使用`#[allow(deprecated)]`属性来显式允许使用已弃用的API。这是一个典型的临时修复策略，在保持现有功能的同时避免立即进行大规模的代码重构。

从工程角度看，这种处理方式有几个优点：
1. 快速解决问题，避免阻塞开发流程
2. 保持向后兼容性
3. 为更彻底的解决方案争取时间

在实现细节上，PR做了两个关键修改。首先在`State`结构的`new`方法中添加了弃用允许属性，这直接解决了构建失败的问题。其次对测试模块中的导入进行了格式化调整，虽然这看起来是次要的代码风格改进，但体现了维护代码质量的良好实践。

值得注意的是，PR作者明确指出了这是一个短期解决方案，并创建了后续问题(#21819)来跟踪长期的替代方案。这种处理方式显示了良好的工程纪律：既快速解决问题，又为技术债务的清理建立了明确的跟踪机制。

## Visual Representation

```mermaid
graph TD
    A[heapless 0.8.x] --> B[弃用 mpmc 模块]
    B --> C[Bevy no_std 构建失败]
    C --> D[添加 allow(deprecated) 属性]
    D --> E[构建恢复]
    D --> F[创建长期解决方案跟踪]
```

## Key Files Changed

### `crates/bevy_tasks/src/edge_executor.rs` (+5/-1)

这个文件包含了任务执行器的核心实现，主要修改涉及处理`heapless`库的API弃用问题。

**关键修改：**

```rust
// 在 State 结构的 new 方法中添加弃用允许
#[cfg(not(any(
    target_has_atomic = "8",
    target_has_atomic = "16", 
    target_has_atomic = "32",
    target_has_atomic = "64",
    target_has_atomic = "ptr"
)))]
#[allow(deprecated)]
queue: heapless::mpmc::Queue::new(),
```

这个修改位于条件编译块内，只在没有原子操作支持的目标平台上生效，这正是`no_std`环境的特点。通过添加`#[allow(deprecated)]`属性，编译器不再将使用已弃用的`heapless::mpmc::Queue::new()`视为错误。

**次要的代码风格改进：**

```rust
// 修改前：
use bevy_tasks::{block_on, futures_lite::{pending, poll_once}};

// 修改后：
use bevy_tasks::{
    block_on,
    futures_lite::{pending, poll_once},
};
```

这个格式化调整提高了代码的可读性，特别是在处理嵌套导入时。

## Further Reading

- [Rust 属性文档](https://doc.rust-lang.org/reference/attributes.html) - 了解 `#[allow]` 和其他属性的用法
- [heapless crate 文档](https://docs.rs/heapless) - 嵌入式环境下的无堆分配集合库
- [Rust 无标准库编程](https://rust-embedded.github.io/book/intro/no-std.html) - no_std 开发指南
- [语义化版本控制](https://semver.org/) - 理解库版本管理的最佳实践

# Full Code Diff
```diff
diff --git a/crates/bevy_tasks/src/edge_executor.rs b/crates/bevy_tasks/src/edge_executor.rs
index 1437ad6b42011..c40d812d81aa0 100644
--- a/crates/bevy_tasks/src/edge_executor.rs
+++ b/crates/bevy_tasks/src/edge_executor.rs
@@ -471,6 +471,7 @@ impl<const C: usize> State<C> {
                 target_has_atomic = "64",
                 target_has_atomic = "ptr"
             )))]
+            #[allow(deprecated)]
             queue: heapless::mpmc::Queue::new(),
             waker: AtomicWaker::new(),
         }
@@ -481,7 +482,10 @@ impl<const C: usize> State<C> {
 mod different_executor_tests {
     use core::cell::Cell;
 
-    use bevy_tasks::{block_on, futures_lite::{pending, poll_once}};
+    use bevy_tasks::{
+        block_on,
+        futures_lite::{pending, poll_once},
+    };
     use futures_lite::pin;
 
     use super::LocalExecutor;
```