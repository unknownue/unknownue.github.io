diff --git a/crates/bevy_math/Cargo.toml b/crates/bevy_math/Cargo.toml
index 783370fd59b14..c6b080c897926 100644
--- a/crates/bevy_math/Cargo.toml
+++ b/crates/bevy_math/Cargo.toml
@@ -24,7 +24,7 @@ libm = { version = "0.2", optional = true }
 approx = { version = "0.5", default-features = false, optional = true }
 rand = { version = "0.9", default-features = false, optional = true }
 rand_distr = { version = "0.5", optional = true }
-smallvec = { version = "1", default-features = false }
+arrayvec = { version = "0.7", default-features = false }
 bevy_reflect = { path = "../bevy_reflect", version = "0.18.0-dev", default-features = false, features = [
   "glam",
 ], optional = true }
diff --git a/crates/bevy_math/src/bounding/bounded2d/primitive_impls.rs b/crates/bevy_math/src/bounding/bounded2d/primitive_impls.rs
index dc18589a5aa73..8e45e645bfeb5 100644
--- a/crates/bevy_math/src/bounding/bounded2d/primitive_impls.rs
+++ b/crates/bevy_math/src/bounding/bounded2d/primitive_impls.rs
@@ -14,7 +14,7 @@ use core::f32::consts::{FRAC_PI_2, PI, TAU};
 #[cfg(feature = "alloc")]
 use crate::primitives::{ConvexPolygon, Polygon, Polyline2d};
 
-use smallvec::SmallVec;
+use arrayvec::ArrayVec;
 
 use super::{Aabb2d, Bounded2d, BoundingCircle};
 
@@ -33,10 +33,10 @@ impl Bounded2d for Circle {
 // Compute the axis-aligned bounding points of a rotated arc, used for computing the AABB of arcs and derived shapes.
 // The return type has room for 7 points so that the CircularSector code can add an additional point.
 #[inline]
-fn arc_bounding_points(arc: Arc2d, rotation: impl Into<Rot2>) -> SmallVec<[Vec2; 7]> {
+fn arc_bounding_points(arc: Arc2d, rotation: impl Into<Rot2>) -> ArrayVec<Vec2, 7> {
     // Otherwise, the extreme points will always be either the endpoints or the axis-aligned extrema of the arc's circle.
     // We need to compute which axis-aligned extrema are actually contained within the rotated arc.
-    let mut bounds = SmallVec::<[Vec2; 7]>::new();
+    let mut bounds = ArrayVec::<Vec2, 7>::new();
     let rotation = rotation.into();
     bounds.push(rotation * arc.left_endpoint());
     bounds.push(rotation * arc.right_endpoint());
diff --git a/crates/bevy_math/src/primitives/dim2.rs b/crates/bevy_math/src/primitives/dim2.rs
index a798811886be6..572ff1473ce97 100644
--- a/crates/bevy_math/src/primitives/dim2.rs
+++ b/crates/bevy_math/src/primitives/dim2.rs
@@ -1727,13 +1727,14 @@ impl Triangle2d {
         let ca = a - c;
 
         // a^2 + b^2 < c^2 for an acute triangle
-        let mut side_lengths = [
+        let side_lengths = [
             ab.length_squared(),
             bc.length_squared(),
             ca.length_squared(),
         ];
-        side_lengths.sort_by(|a, b| a.partial_cmp(b).unwrap());
-        side_lengths[0] + side_lengths[1] > side_lengths[2]
+        let sum = side_lengths[0] + side_lengths[1] + side_lengths[2];
+        let max = side_lengths[0].max(side_lengths[1]).max(side_lengths[2]);
+        sum - max > max
     }
 
     /// Checks if the triangle is obtuse, meaning one angle is greater than 90 degrees
@@ -1745,13 +1746,14 @@ impl Triangle2d {
         let ca = a - c;
 
         // a^2 + b^2 > c^2 for an obtuse triangle
-        let mut side_lengths = [
+        let side_lengths = [
             ab.length_squared(),
             bc.length_squared(),
             ca.length_squared(),
         ];
-        side_lengths.sort_by(|a, b| a.partial_cmp(b).unwrap());
-        side_lengths[0] + side_lengths[1] < side_lengths[2]
+        let sum = side_lengths[0] + side_lengths[1] + side_lengths[2];
+        let max = side_lengths[0].max(side_lengths[1]).max(side_lengths[2]);
+        sum - max < max
     }
 
     /// Reverse the [`WindingOrder`] of the triangle
diff --git a/crates/bevy_math/src/primitives/dim3.rs b/crates/bevy_math/src/primitives/dim3.rs
index abfc778d7f947..bdeb4db83810b 100644
--- a/crates/bevy_math/src/primitives/dim3.rs
+++ b/crates/bevy_math/src/primitives/dim3.rs
@@ -1235,13 +1235,14 @@ impl Triangle3d {
         let ca = a - c;
 
         // a^2 + b^2 < c^2 for an acute triangle
-        let mut side_lengths = [
+        let side_lengths = [
             ab.length_squared(),
             bc.length_squared(),
             ca.length_squared(),
         ];
-        side_lengths.sort_by(|a, b| a.partial_cmp(b).unwrap());
-        side_lengths[0] + side_lengths[1] > side_lengths[2]
+        let sum = side_lengths[0] + side_lengths[1] + side_lengths[2];
+        let max = side_lengths[0].max(side_lengths[1]).max(side_lengths[2]);
+        sum - max > max
     }
 
     /// Checks if the triangle is obtuse, meaning one angle is greater than 90 degrees
@@ -1253,13 +1254,14 @@ impl Triangle3d {
         let ca = a - c;
 
         // a^2 + b^2 > c^2 for an obtuse triangle
-        let mut side_lengths = [
+        let side_lengths = [
             ab.length_squared(),
             bc.length_squared(),
             ca.length_squared(),
         ];
-        side_lengths.sort_by(|a, b| a.partial_cmp(b).unwrap());
-        side_lengths[0] + side_lengths[1] < side_lengths[2]
+        let sum = side_lengths[0] + side_lengths[1] + side_lengths[2];
+        let max = side_lengths[0].max(side_lengths[1]).max(side_lengths[2]);
+        sum - max < max
     }
 
     /// Reverse the triangle by swapping the first and last vertices.
