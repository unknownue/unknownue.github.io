+++
title = "#21718 Improve Local SystemParam text, examples"
date = "2025-11-05T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-11/pr-21718-en-20251105" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-11/pr-21718-zh-cn-20251105" }}
labels = ["C-Docs", "A-ECS", "D-Straightforward"]
+++

# Title
Improve Local SystemParam text, examples

## Basic Information
- **Title**: Improve Local SystemParam text, examples
- **PR Link**: https://github.com/bevyengine/bevy/pull/21718
- **Author**: isHavvy
- **Status**: MERGED
- **Labels**: C-Docs, A-ECS, S-Ready-For-Final-Review, X-Uncontroversial, D-Straightforward
- **Created**: 2025-11-02T07:10:33Z
- **Merged**: 2025-11-05T03:39:21Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

Explain `Local<T>` better to newbies.

## Solution

Add more examples of how to use `Local<T>` and document how `T` is initialized for this type.

I tried to order the examples from basic information to more niche information.

I have no clue if the configuration example is useful or even what it's trying to convey. The blame log shows that there was some configuration thing that was removed.

Furthermore, I added a doc comment to the SystemParam impl giving a very short description of what it provides as a system parameter. I think all non-tuple impls should provide such a blurb so that looking at the implementations for the trait itself provides useful information besides just the name. If that is wanted, an issue should be opened for it. If it is not, either I or the reviewer who commits this can remove the line.

## Testing

I ran the doctests. I also built the docs and checked that the links work.

## The Story of This Pull Request

This PR addresses a common learning gap for developers new to Bevy's ECS system: understanding how `Local<T>` system parameters work. The existing documentation was sparse and didn't adequately explain the behavior and use cases for this important system parameter type.

The core problem was that `Local<T>` serves a unique role in Bevy's ECS - it provides system-private state that persists across system executions but isn't shared between systems. This concept can be confusing for developers coming from other ECS frameworks or those unfamiliar with system-local state management patterns.

The solution approach focused on comprehensive documentation improvements through practical examples. The author organized the examples from basic to advanced usage, creating a natural learning progression. They started with a simple counter example to demonstrate the fundamental behavior:

```rust
fn counter(mut count: Local<u32>) -> u32 {
    *count += 1;
    *count
}
```

This example clearly shows how `Local<u32>` maintains state between system calls, starting from the default value of 0 and incrementing with each execution.

The implementation then builds on this foundation with more complex scenarios. One key insight was demonstrating how to provide custom initialization values using `Option` wrappers:

```rust
fn counter_from_10(mut count: Local<Option<u32>>) -> u32 {
    let count = count.get_or_insert(10);
    *count += 1;
    *count
}
```

This pattern is particularly valuable because it shows developers how to work around the limitation that `Local<T>` always initializes with `T::default()` when using `FromWorld`.

Another important clarification was showing that multiple `Local` parameters of the same type in the same system are distinct:

```rust
fn double_counter(mut count: Local<u32>, mut double_count: Local<u32>) -> (u32, u32) {
    *count += 1;
    *double_count += 2;
    (*count, *double_count)
}
```

The author also included a crucial example demonstrating that different systems using the same `Local<T>` type get independent instances:

```rust
fn write_to_local(mut local: Local<usize>) {
    *local = 42;
}
fn read_from_local(local: Local<usize>) -> usize {
    *local
}
```

This addresses a common misconception about `Local` sharing between systems.

For performance-conscious developers, the PR added an example showing how `Local` can be used to avoid repeated memory allocations:

```rust
fn some_system(mut vec: Local<Vec<u32>>) {
    // System logic using vec
    vec.clear(); // Reuse for next call
}
```

The technical insights from this PR reveal several important patterns in Bevy's ECS design. The `Local<T>` system parameter fills a specific niche between global resources and temporary local variables - it provides persistent state that's scoped to a single system's lifetime across multiple executions. This is particularly useful for caching, counters, and temporary storage that needs to persist between frames but shouldn't be globally accessible.

The documentation improvements follow established best practices for API documentation by providing:
- Clear explanation of initialization behavior
- Progressive examples from simple to complex
- Clarification of common misconceptions
- Performance optimization patterns

The impact of these changes is significant for developer experience. New Bevy users will encounter fewer stumbling blocks when working with system-local state, and the comprehensive examples provide immediate, copy-paste solutions for common patterns. The improved documentation also reduces the likelihood of developers misusing `Local<T>` or creating workarounds for behavior that's already supported.

## Visual Representation

```mermaid
graph TD
    A[System Execution] --> B[Local<T> Initialization]
    B --> C{T: Default?}
    C -->|Yes| D[Use T::default()]
    C -->|No| E[Use FromWorld::from_world]
    D --> F[System Logic]
    E --> F
    F --> G[State Persists]
    G --> A
    
    H[System A] --> I[Local<Counter> A]
    J[System B] --> K[Local<Counter> B]
    I -.->|Independent| K
```

## Key Files Changed

**File: `crates/bevy_ecs/src/system/system_param.rs`**

This file contains the core implementation and documentation for Bevy's system parameters. The changes focus exclusively on improving the documentation for the `Local<T>` system parameter.

**Key Changes:**

1. **Enhanced struct documentation** - Added clear explanation of persistence and initialization:
```rust
// Before:
/// A system local [`SystemParam`].

// After:
/// A [`SystemParam`] that provides a system-private value of `T` that persists across system calls.
///
/// The initial value is created by calling `T`'s [`FromWorld::from_world`] (or [`Default::default`] if `T: Default`).
```

2. **Improved primary example** - Replaced complex two-system example with simple counter:
```rust
// Before example showed two systems with confusing interaction
fn write_to_local(mut local: Local<usize>) {
    *local = 42;
}
fn read_from_local(local: Local<usize>) -> usize {
    *local
}

// After shows clear single-system behavior
fn counter(mut count: Local<u32>) -> u32 {
    *count += 1;
    *count
}
```

3. **Added comprehensive examples** - Multiple new examples covering:
   - Custom initialization with `Option`
   - Multiple locals of same type
   - Independent locals across systems
   - Memory reuse patterns

4. **SystemParam implementation documentation** - Added brief description:
```rust
unsafe impl<'s, T: FromWorld + Send + 'static> SystemParam for Local<T> {
    // ... existing code ...
}
```

These changes transform the `Local<T>` documentation from minimal to comprehensive, providing developers with clear guidance and practical examples for using this system parameter effectively.

## Further Reading

- [Bevy ECS System Parameters Documentation](https://bevyengine.org/learn/quick-start/ecs/#system-parameters)
- [Bevy Cheatbook - System Parameters](https://bevy-cheatbook.github.io/programming/system-params.html)
- [Rust API Guidelines on Documentation](https://rust-lang.github.io/api-guidelines/documentation.html)
- [Bevy SystemParam Trait Documentation](https://docs.rs/bevy_ecs/latest/bevy_ecs/system/trait.SystemParam.html)

# Full Code Diff
```diff
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index 909e434c19242..6e6c4deadff3f 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -972,7 +972,9 @@ unsafe impl<'w> SystemParam for DeferredWorld<'w> {
     }
 }
 
-/// A system local [`SystemParam`].
+/// A [`SystemParam`] that provides a system-private value of `T` that persists across system calls.
+///
+/// The initial value is created by calling `T`'s [`FromWorld::from_world`] (or [`Default::default`] if `T: Default`).
 ///
 /// A local may only be accessed by the system itself and is therefore not visible to other systems.
 /// If two or more systems specify the same local type each will have their own unique local.
@@ -986,21 +988,17 @@ unsafe impl<'w> SystemParam for DeferredWorld<'w> {
 /// ```
 /// # use bevy_ecs::prelude::*;
 /// # let world = &mut World::default();
-/// fn write_to_local(mut local: Local<usize>) {
-///     *local = 42;
-/// }
-/// fn read_from_local(local: Local<usize>) -> usize {
-///     *local
+/// fn counter(mut count: Local<u32>) -> u32 {
+///     *count += 1;
+///     *count
 /// }
-/// let mut write_system = IntoSystem::into_system(write_to_local);
-/// let mut read_system = IntoSystem::into_system(read_from_local);
-/// write_system.initialize(world);
-/// read_system.initialize(world);
+/// let mut counter_system = IntoSystem::into_system(counter);
+/// counter_system.initialize(world);
 ///
-/// assert_eq!(read_system.run((), world).unwrap(), 0);
-/// write_system.run((), world);
-/// // Note how the read local is still 0 due to the locals not being shared.
-/// assert_eq!(read_system.run((), world).unwrap(), 0);
+/// // Counter is initialized to u32's default value of 0, and increases to 1 on first run.
+/// assert_eq!(counter_system.run((), world).unwrap(), 1);
+/// // Counter gets the same value and increases to 2 on its second call.
+/// assert_eq!(counter_system.run((), world).unwrap(), 2);
 /// ```
 ///
 /// A simple way to set a different default value for a local is by wrapping the value with an Option.
@@ -1008,7 +1006,7 @@ unsafe impl<'w> SystemParam for DeferredWorld<'w> {
 /// ```
 /// # use bevy_ecs::prelude::*;
 /// # let world = &mut World::default();
-/// fn counter_from_10(mut count: Local<Option<usize>>) -> usize {
+/// fn counter_from_10(mut count: Local<Option<u32>>) -> u32 {
 ///     let count = count.get_or_insert(10);
 ///     *count += 1;
 ///     *count
@@ -1022,6 +1020,58 @@ unsafe impl<'w> SystemParam for DeferredWorld<'w> {
 /// assert_eq!(counter_system.run((), world).unwrap(), 12);
 /// ```
 ///
+/// A system can have multiple `Local` values with the same type, each with distinct values.
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// # let world = &mut World::default();
+/// fn double_counter(mut count: Local<u32>, mut double_count: Local<u32>) -> (u32, u32) {
+///     *count += 1;
+///     *double_count += 2;
+///     (*count, *double_count)
+/// }
+/// let mut counter_system = IntoSystem::into_system(double_counter);
+/// counter_system.initialize(world);
+///
+/// assert_eq!(counter_system.run((), world).unwrap(), (1, 2));
+/// assert_eq!(counter_system.run((), world).unwrap(), (2, 4));
+/// ```
+///
+/// This example shows that two systems using the same type for their own `Local` get distinct locals.
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// # let world = &mut World::default();
+/// fn write_to_local(mut local: Local<usize>) {
+///     *local = 42;
+/// }
+/// fn read_from_local(local: Local<usize>) -> usize {
+///     *local
+/// }
+/// let mut write_system = IntoSystem::into_system(write_to_local);
+/// let mut read_system = IntoSystem::into_system(read_from_local);
+/// write_system.initialize(world);
+/// read_system.initialize(world);
+///
+/// assert_eq!(read_system.run((), world).unwrap(), 0);
+/// write_system.run((), world);
+/// // The read local is still 0 due to the locals not being shared.
+/// assert_eq!(read_system.run((), world).unwrap(), 0);
+/// ```
+///
+/// You can use a `Local` to avoid reallocating memory every system call.
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// fn some_system(mut vec: Local<Vec<u32>>) {
+///     // Do your regular system logic, using the vec, as normal.
+///
+///     // At end of function, clear the vec's contents so its empty for next system call.
+///     // If it's possible the capacity could get too large, you may want to check and resize that as well.
+///     vec.clear();
+/// }
+/// ```
+///
 /// N.B. A [`Local`]s value cannot be read or written to outside of the containing system.
 /// To add configuration to a system, convert a capturing closure into the system instead:
 ///
```