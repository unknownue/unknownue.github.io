diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index d73f70f48ba1e..043da966e9c5f 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -336,7 +336,7 @@ jobs:
     steps:
       - uses: actions/checkout@v5
       - name: Check for typos
-        uses: crate-ci/typos@v1.38.1
+        uses: crate-ci/typos@v1.39.0
       - name: Typos info
         if: failure()
         run: |
diff --git a/crates/bevy_ecs/src/component/info.rs b/crates/bevy_ecs/src/component/info.rs
index 50691d990d282..9ab6127b01293 100644
--- a/crates/bevy_ecs/src/component/info.rs
+++ b/crates/bevy_ecs/src/component/info.rs
@@ -363,7 +363,7 @@ pub struct Components {
     pub(super) components: Vec<Option<ComponentInfo>>,
     pub(super) indices: TypeIdMap<ComponentId>,
     pub(super) resource_indices: TypeIdMap<ComponentId>,
-    // This is kept internal and local to verify that no deadlocks can occor.
+    // This is kept internal and local to verify that no deadlocks can occur.
     pub(super) queued: bevy_platform::sync::RwLock<QueuedComponents>,
 }
 
diff --git a/crates/bevy_ecs/src/entity_disabling.rs b/crates/bevy_ecs/src/entity_disabling.rs
index dd116e882278e..a899eb2575273 100644
--- a/crates/bevy_ecs/src/entity_disabling.rs
+++ b/crates/bevy_ecs/src/entity_disabling.rs
@@ -83,7 +83,7 @@
 //! app starts.
 //!
 //! Because filters are applied to all queries they can have performance implication for
-//! the enire [`World`], especially when they cause queries to mix sparse and table components.
+//! the entire [`World`], especially when they cause queries to mix sparse and table components.
 //! See [`Query` performance] for more info.
 //!
 //! Custom disabling components can cause significant interoperability issues within the ecosystem,
diff --git a/crates/bevy_ecs/src/storage/table/mod.rs b/crates/bevy_ecs/src/storage/table/mod.rs
index 592449975d16b..5dbb3e3914602 100644
--- a/crates/bevy_ecs/src/storage/table/mod.rs
+++ b/crates/bevy_ecs/src/storage/table/mod.rs
@@ -242,7 +242,7 @@ impl Table {
         if is_last {
             None
         } else {
-            // SAFETY: This was sawp removed and was not last, so it must be in bounds.
+            // SAFETY: This was swap removed and was not last, so it must be in bounds.
             unsafe { Some(*self.entities.get_unchecked(row.index())) }
         }
     }
@@ -286,7 +286,7 @@ impl Table {
             swapped_entity: if is_last {
                 None
             } else {
-                // SAFETY: This was sawp removed and was not last, so it must be in bounds.
+                // SAFETY: This was swap removed and was not last, so it must be in bounds.
                 unsafe { Some(*self.entities.get_unchecked(row.index())) }
             },
         }
@@ -328,7 +328,7 @@ impl Table {
             swapped_entity: if is_last {
                 None
             } else {
-                // SAFETY: This was sawp removed and was not last, so it must be in bounds.
+                // SAFETY: This was swap removed and was not last, so it must be in bounds.
                 unsafe { Some(*self.entities.get_unchecked(row.index())) }
             },
         }
@@ -365,7 +365,7 @@ impl Table {
             swapped_entity: if is_last {
                 None
             } else {
-                // SAFETY: This was sawp removed and was not last, so it must be in bounds.
+                // SAFETY: This was swap removed and was not last, so it must be in bounds.
                 unsafe { Some(*self.entities.get_unchecked(row.index())) }
             },
         }
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index 6da22b1328b5e..115a66f576ad6 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -2279,7 +2279,7 @@ impl<'a> EntityCommands<'a> {
     ///
     ///
     /// fn trigger_via_constructor(mut commands: Commands) {
-    ///     // The fact that `Epxlode` is a single-field tuple struct
+    ///     // The fact that `Explode` is a single-field tuple struct
     ///     // ensures that `Explode(entity)` is a function that generates
     ///     // an EntityEvent, meeting the trait bounds for `event_fn`.
     ///     commands.spawn_empty().trigger(Explode);
diff --git a/crates/bevy_pbr/src/medium.rs b/crates/bevy_pbr/src/medium.rs
index edaf145cc5f83..be17252c7477b 100644
--- a/crates/bevy_pbr/src/medium.rs
+++ b/crates/bevy_pbr/src/medium.rs
@@ -158,7 +158,7 @@ impl ScatteringMedium {
 /// which are denser but lie closer to the ground.
 #[derive(Default, Clone)]
 pub struct ScatteringTerm {
-    /// This term's optical obsorption density, or how much light of each wavelength
+    /// This term's optical absorption density, or how much light of each wavelength
     /// it absorbs per meter.
     ///
     /// units: m^-1
diff --git a/crates/bevy_ptr/src/lib.rs b/crates/bevy_ptr/src/lib.rs
index 99cd38b6ab4ca..d4db3462d6af9 100644
--- a/crates/bevy_ptr/src/lib.rs
+++ b/crates/bevy_ptr/src/lib.rs
@@ -624,7 +624,7 @@ impl<'a, T, A: IsAligned> MovingPtr<'a, T, A> {
     ///    for the same field, without first calling [`forget`] on it first.
     ///
     /// A result of the above invariants means that any operation that could cause `self` to be dropped while
-    /// the pointers to the fields are held will result in undefined behavior. This requires exctra caution
+    /// the pointers to the fields are held will result in undefined behavior. This requires extra caution
     /// around code that may panic. See the example below for an example of how to safely use this function.
     ///
     /// # Example
diff --git a/crates/bevy_render/src/texture/manual_texture_view.rs b/crates/bevy_render/src/texture/manual_texture_view.rs
index 57cb5e2d15056..b9faa84ab78f6 100644
--- a/crates/bevy_render/src/texture/manual_texture_view.rs
+++ b/crates/bevy_render/src/texture/manual_texture_view.rs
@@ -42,7 +42,7 @@ impl ManualTextureView {
 /// const MANUAL_VIEW_HANDLE: ManualTextureViewHandle = ManualTextureViewHandle::new(42);
 /// manual_views.insert(MANUAL_VIEW_HANDLE, manual_view);
 ///
-/// // Now you can spawn a Cemera that renders to the manual view:
+/// // Now you can spawn a Camera that renders to the manual view:
 /// # use bevy_camera::{Camera, RenderTarget};
 /// world.spawn(Camera {
 ///     target: RenderTarget::TextureView(MANUAL_VIEW_HANDLE),
diff --git a/crates/bevy_tasks/src/edge_executor.rs b/crates/bevy_tasks/src/edge_executor.rs
index 2bf719029d621..1437ad6b42011 100644
--- a/crates/bevy_tasks/src/edge_executor.rs
+++ b/crates/bevy_tasks/src/edge_executor.rs
@@ -188,7 +188,7 @@ impl<'a, const C: usize> Executor<'a, C> {
     ///
     /// Returns
     /// - `None` - if no task was scheduled for execution
-    /// - `Some(Runnnable)` - the first task scheduled for execution. Calling `Runnable::run` will
+    /// - `Some(Runnable)` - the first task scheduled for execution. Calling `Runnable::run` will
     ///   execute the task. In other words, it will poll its future.
     fn try_runnable(&self) -> Option<Runnable> {
         let runnable;
