diff --git a/crates/bevy_light/src/lib.rs b/crates/bevy_light/src/lib.rs
index a7673ce7bbea3..06dc5ac7ca3eb 100644
--- a/crates/bevy_light/src/lib.rs
+++ b/crates/bevy_light/src/lib.rs
@@ -27,7 +27,7 @@ use cluster::{
 mod ambient_light;
 pub use ambient_light::AmbientLight;
 mod probe;
-pub use probe::{EnvironmentMapLight, IrradianceVolume, LightProbe};
+pub use probe::{EnvironmentMapLight, GeneratedEnvironmentMapLight, IrradianceVolume, LightProbe};
 mod volumetric;
 pub use volumetric::{FogVolume, VolumetricFog, VolumetricLight};
 pub mod cascade;
diff --git a/crates/bevy_light/src/probe.rs b/crates/bevy_light/src/probe.rs
index 5683daa562f21..29963e11f863f 100644
--- a/crates/bevy_light/src/probe.rs
+++ b/crates/bevy_light/src/probe.rs
@@ -108,6 +108,38 @@ impl Default for EnvironmentMapLight {
     }
 }
 
+/// A generated environment map that is filtered at runtime.
+///
+/// See `bevy_pbr::light_probe::generate` for detailed information.
+#[derive(Clone, Component, Reflect)]
+#[reflect(Component, Default, Clone)]
+pub struct GeneratedEnvironmentMapLight {
+    /// Source cubemap to be filtered on the GPU, size must be a power of two.
+    pub environment_map: Handle<Image>,
+
+    /// Scale factor applied to the diffuse and specular light generated by this
+    /// component. Expressed in cd/m² (candela per square meter).
+    pub intensity: f32,
+
+    /// World-space rotation applied to the cubemap.
+    pub rotation: Quat,
+
+    /// Whether this light contributes diffuse lighting to meshes that already
+    /// have baked lightmaps.
+    pub affects_lightmapped_mesh_diffuse: bool,
+}
+
+impl Default for GeneratedEnvironmentMapLight {
+    fn default() -> Self {
+        GeneratedEnvironmentMapLight {
+            environment_map: Handle::default(),
+            intensity: 0.0,
+            rotation: Quat::IDENTITY,
+            affects_lightmapped_mesh_diffuse: true,
+        }
+    }
+}
+
 /// The component that defines an irradiance volume.
 ///
 /// See `bevy_pbr::irradiance_volume` for detailed information.
diff --git a/crates/bevy_pbr/src/lib.rs b/crates/bevy_pbr/src/lib.rs
index f5d84fb8e8427..2e3cd468cea5a 100644
--- a/crates/bevy_pbr/src/lib.rs
+++ b/crates/bevy_pbr/src/lib.rs
@@ -88,8 +88,8 @@ pub mod prelude {
     };
     #[doc(hidden)]
     pub use bevy_light::{
-        light_consts, AmbientLight, DirectionalLight, EnvironmentMapLight, LightProbe, PointLight,
-        SpotLight,
+        light_consts, AmbientLight, DirectionalLight, EnvironmentMapLight,
+        GeneratedEnvironmentMapLight, LightProbe, PointLight, SpotLight,
     };
 }
 
@@ -133,7 +133,7 @@ pub mod graph {
 
 use crate::{deferred::DeferredPbrLightingPlugin, graph::NodePbr};
 use bevy_app::prelude::*;
-use bevy_asset::{AssetApp, AssetPath, Assets, Handle};
+use bevy_asset::{embedded_asset, load_embedded_asset, AssetApp, AssetPath, Assets, Handle};
 use bevy_core_pipeline::core_3d::graph::{Core3d, Node3d};
 use bevy_ecs::prelude::*;
 use bevy_image::Image;
@@ -185,6 +185,13 @@ impl Default for PbrPlugin {
     }
 }
 
+/// A resource that stores the spatio-temporal blue noise texture.
+#[derive(Resource)]
+pub struct Bluenoise {
+    /// Texture handle for spatio-temporal blue noise
+    pub texture: Handle<Image>,
+}
+
 impl Plugin for PbrPlugin {
     fn build(&self, app: &mut App) {
         load_shader_library!(app, "render/pbr_types.wgsl");
@@ -273,12 +280,19 @@ impl Plugin for PbrPlugin {
                 },
             );
 
+        // Load the Spatio-temporal blue noise texture
+        embedded_asset!(app, "stbn.ktx2");
+        let bluenoise_texture = load_embedded_asset!(app, "stbn.ktx2");
+
         let Some(render_app) = app.get_sub_app_mut(RenderApp) else {
             return;
         };
 
         // Extract the required data from the main world
         render_app
+            .insert_resource(Bluenoise {
+                texture: bluenoise_texture,
+            })
             .add_systems(
                 RenderStartup,
                 (
diff --git a/crates/bevy_pbr/src/light_probe/copy.wgsl b/crates/bevy_pbr/src/light_probe/copy.wgsl
new file mode 100644
index 0000000000000..9140562240497
--- /dev/null
+++ b/crates/bevy_pbr/src/light_probe/copy.wgsl
@@ -0,0 +1,21 @@
+// Copy the base mip (level 0) from a source cubemap to a destination cubemap,
+// performing format conversion if needed (the destination is always rgba16float).
+// The alpha channel is filled with 1.0.
+
+@group(0) @binding(0) var src_cubemap: texture_2d_array<f32>;
+@group(0) @binding(1) var dst_cubemap: texture_storage_2d_array<rgba16float, write>;
+
+@compute
+@workgroup_size(8, 8, 1)
+fn copy(@builtin(global_invocation_id) global_id: vec3u) {
+    let size = textureDimensions(src_cubemap).xy;
+
+    // Bounds check
+    if (any(global_id.xy >= size)) {
+        return;
+    }
+
+    let color = textureLoad(src_cubemap, vec2u(global_id.xy), global_id.z, 0);
+
+    textureStore(dst_cubemap, vec2u(global_id.xy), global_id.z, vec4f(color.rgb, 1.0));
+} 
\ No newline at end of file
diff --git a/crates/bevy_pbr/src/light_probe/downsample.wgsl b/crates/bevy_pbr/src/light_probe/downsample.wgsl
new file mode 100644
index 0000000000000..57a0615c87c1d
--- /dev/null
+++ b/crates/bevy_pbr/src/light_probe/downsample.wgsl
@@ -0,0 +1,460 @@
+// Single pass downsampling shader for creating the mip chain for an array texture
+// Ported from https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/c16b1d286b5b438b75da159ab51ff426bacea3d1/sdk/include/FidelityFX/gpu/spd/ffx_spd.h
+
+@group(0) @binding(0) var sampler_linear_clamp: sampler;
+@group(0) @binding(1) var<uniform> constants: Constants;
+#ifdef COMBINE_BIND_GROUP
+@group(0) @binding(2) var mip_0: texture_2d_array<f32>;
+@group(0) @binding(3) var mip_1: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(4) var mip_2: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(5) var mip_3: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(6) var mip_4: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(7) var mip_5: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(8) var mip_6: texture_storage_2d_array<rgba16float, read_write>;
+@group(0) @binding(9) var mip_7: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(10) var mip_8: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(11) var mip_9: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(12) var mip_10: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(13) var mip_11: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(14) var mip_12: texture_storage_2d_array<rgba16float, write>;
+#endif
+
+#ifdef FIRST_PASS
+@group(0) @binding(2) var mip_0: texture_2d_array<f32>;
+@group(0) @binding(3) var mip_1: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(4) var mip_2: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(5) var mip_3: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(6) var mip_4: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(7) var mip_5: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(8) var mip_6: texture_storage_2d_array<rgba16float, write>;
+#endif
+
+#ifdef SECOND_PASS
+@group(0) @binding(2) var mip_6: texture_2d_array<f32>;
+@group(0) @binding(3) var mip_7: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(4) var mip_8: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(5) var mip_9: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(6) var mip_10: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(7) var mip_11: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(8) var mip_12: texture_storage_2d_array<rgba16float, write>;
+#endif
+
+struct Constants { mips: u32, inverse_input_size: vec2f }
+
+var<workgroup> spd_intermediate_r: array<array<f32, 16>, 16>;
+var<workgroup> spd_intermediate_g: array<array<f32, 16>, 16>;
+var<workgroup> spd_intermediate_b: array<array<f32, 16>, 16>;
+var<workgroup> spd_intermediate_a: array<array<f32, 16>, 16>;
+
+@compute
+@workgroup_size(256, 1, 1)
+fn downsample_first(
+    @builtin(workgroup_id) workgroup_id: vec3u,
+    @builtin(local_invocation_index) local_invocation_index: u32,
+#ifdef SUBGROUP_SUPPORT
+    @builtin(subgroup_invocation_id) subgroup_invocation_id: u32,
+#endif
+) {
+#ifndef SUBGROUP_SUPPORT
+    let subgroup_invocation_id = 0u;
+#endif
+
+    let sub_xy = remap_for_wave_reduction(local_invocation_index % 64u);
+    let x = sub_xy.x + 8u * ((local_invocation_index >> 6u) % 2u);
+    let y = sub_xy.y + 8u * (local_invocation_index >> 7u);
+
+    spd_downsample_mips_0_1(x, y, workgroup_id.xy, local_invocation_index, constants.mips, workgroup_id.z, subgroup_invocation_id);
+
+    spd_downsample_next_four(x, y, workgroup_id.xy, local_invocation_index, 2u, constants.mips, workgroup_id.z, subgroup_invocation_id);
+}
+
+// TODO: Once wgpu supports globallycoherent buffers, make it actually a single pass
+@compute
+@workgroup_size(256, 1, 1)
+fn downsample_second(
+    @builtin(workgroup_id) workgroup_id: vec3u,
+    @builtin(local_invocation_index) local_invocation_index: u32,
+#ifdef SUBGROUP_SUPPORT
+    @builtin(subgroup_invocation_id) subgroup_invocation_id: u32,
+#endif
+) {
+#ifndef SUBGROUP_SUPPORT
+    let subgroup_invocation_id = 0u;
+#endif
+
+    let sub_xy = remap_for_wave_reduction(local_invocation_index % 64u);
+    let x = sub_xy.x + 8u * ((local_invocation_index >> 6u) % 2u);
+    let y = sub_xy.y + 8u * (local_invocation_index >> 7u);
+
+    spd_downsample_mips_6_7(x, y, constants.mips, workgroup_id.z);
+
+    spd_downsample_next_four(x, y, vec2(0u), local_invocation_index, 8u, constants.mips, workgroup_id.z, subgroup_invocation_id);
+}
+
+fn spd_downsample_mips_0_1(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, mips: u32, slice: u32, subgroup_invocation_id: u32) {
+    var v: array<vec4f, 4>;
+
+    var tex = (workgroup_id * 64u) + vec2(x * 2u, y * 2u);
+    var pix = (workgroup_id * 32u) + vec2(x, y);
+    v[0] = spd_reduce_load_source_image(tex, slice);
+    spd_store(pix, v[0], 0u, slice);
+
+    tex = (workgroup_id * 64u) + vec2(x * 2u + 32u, y * 2u);
+    pix = (workgroup_id * 32u) + vec2(x + 16u, y);
+    v[1] = spd_reduce_load_source_image(tex, slice);
+    spd_store(pix, v[1], 0u, slice);
+
+    tex = (workgroup_id * 64u) + vec2(x * 2u, y * 2u + 32u);
+    pix = (workgroup_id * 32u) + vec2(x, y + 16u);
+    v[2] = spd_reduce_load_source_image(tex, slice);
+    spd_store(pix, v[2], 0u, slice);
+
+    tex = (workgroup_id * 64u) + vec2(x * 2u + 32u, y * 2u + 32u);
+    pix = (workgroup_id * 32u) + vec2(x + 16u, y + 16u);
+    v[3] = spd_reduce_load_source_image(tex, slice);
+    spd_store(pix, v[3], 0u, slice);
+
+    if mips <= 1u { return; }
+
+#ifdef SUBGROUP_SUPPORT
+    v[0] = spd_reduce_quad(v[0], subgroup_invocation_id);
+    v[1] = spd_reduce_quad(v[1], subgroup_invocation_id);
+    v[2] = spd_reduce_quad(v[2], subgroup_invocation_id);
+    v[3] = spd_reduce_quad(v[3], subgroup_invocation_id);
+
+    if local_invocation_index % 4u == 0u {
+        spd_store((workgroup_id * 16u) + vec2(x / 2u, y / 2u), v[0], 1u, slice);
+        spd_store_intermediate(x / 2u, y / 2u, v[0]);
+
+        spd_store((workgroup_id * 16u) + vec2(x / 2u + 8u, y / 2u), v[1], 1u, slice);
+        spd_store_intermediate(x / 2u + 8u, y / 2u, v[1]);
+
+        spd_store((workgroup_id * 16u) + vec2(x / 2u, y / 2u + 8u), v[2], 1u, slice);
+        spd_store_intermediate(x / 2u, y / 2u + 8u, v[2]);
+
+        spd_store((workgroup_id * 16u) + vec2(x / 2u + 8u, y / 2u + 8u), v[3], 1u, slice);
+        spd_store_intermediate(x / 2u + 8u, y / 2u + 8u, v[3]);
+    }
+#else
+    for (var i = 0u; i < 4u; i++) {
+        spd_store_intermediate(x, y, v[i]);
+        workgroupBarrier();
+        if local_invocation_index < 64u {
+            v[i] = spd_reduce_intermediate(
+                vec2(x * 2u + 0u, y * 2u + 0u),
+                vec2(x * 2u + 1u, y * 2u + 0u),
+                vec2(x * 2u + 0u, y * 2u + 1u),
+                vec2(x * 2u + 1u, y * 2u + 1u),
+            );
+            spd_store(vec2(workgroup_id * 16) + vec2(x + (i % 2u) * 8u, y + (i / 2u) * 8u), v[i], 1u, slice);
+        }
+        workgroupBarrier();
+    }
+
+    if local_invocation_index < 64u {
+        spd_store_intermediate(x + 0u, y + 0u, v[0]);
+        spd_store_intermediate(x + 8u, y + 0u, v[1]);
+        spd_store_intermediate(x + 0u, y + 8u, v[2]);
+        spd_store_intermediate(x + 8u, y + 8u, v[3]);
+    }
+#endif
+}
+
+fn spd_downsample_next_four(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, mips: u32, slice: u32, subgroup_invocation_id: u32) {
+    if mips <= base_mip { return; }
+    workgroupBarrier();
+    spd_downsample_mip_2(x, y, workgroup_id, local_invocation_index, base_mip, slice, subgroup_invocation_id);
+
+    if mips <= base_mip + 1u { return; }
+    workgroupBarrier();
+    spd_downsample_mip_3(x, y, workgroup_id, local_invocation_index, base_mip + 1u, slice, subgroup_invocation_id);
+
+    if mips <= base_mip + 2u { return; }
+    workgroupBarrier();
+    spd_downsample_mip_4(x, y, workgroup_id, local_invocation_index, base_mip + 2u, slice, subgroup_invocation_id);
+
+    if mips <= base_mip + 3u { return; }
+    workgroupBarrier();
+    spd_downsample_mip_5(x, y, workgroup_id, local_invocation_index, base_mip + 3u, slice, subgroup_invocation_id);
+}
+
+fn spd_downsample_mip_2(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+#ifdef SUBGROUP_SUPPORT
+    var v = spd_load_intermediate(x, y);
+    v = spd_reduce_quad(v, subgroup_invocation_id);
+    if local_invocation_index % 4u == 0u {
+        spd_store((workgroup_id * 8u) + vec2(x / 2u, y / 2u), v, base_mip, slice);
+        spd_store_intermediate(x + (y / 2u) % 2u, y, v);
+    }
+#else
+    if local_invocation_index < 64u {
+        let v = spd_reduce_intermediate(
+            vec2(x * 2u + 0u, y * 2u + 0u),
+            vec2(x * 2u + 1u, y * 2u + 0u),
+            vec2(x * 2u + 0u, y * 2u + 1u),
+            vec2(x * 2u + 1u, y * 2u + 1u),
+        );
+        spd_store((workgroup_id * 8u) + vec2(x, y), v, base_mip, slice);
+        spd_store_intermediate(x * 2u + y % 2u, y * 2u, v);
+    }
+#endif
+}
+
+fn spd_downsample_mip_3(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+#ifdef SUBGROUP_SUPPORT
+    if local_invocation_index < 64u {
+        var v = spd_load_intermediate(x * 2u + y % 2u, y * 2u);
+        v = spd_reduce_quad(v, subgroup_invocation_id);
+        if local_invocation_index % 4u == 0u {
+            spd_store((workgroup_id * 4u) + vec2(x / 2u, y / 2u), v, base_mip, slice);
+            spd_store_intermediate(x * 2u + y / 2u, y * 2u, v);
+        }
+    }
+#else
+    if local_invocation_index < 16u {
+        let v = spd_reduce_intermediate(
+            vec2(x * 4u + 0u + 0u, y * 4u + 0u),
+            vec2(x * 4u + 2u + 0u, y * 4u + 0u),
+            vec2(x * 4u + 0u + 1u, y * 4u + 2u),
+            vec2(x * 4u + 2u + 1u, y * 4u + 2u),
+        );
+        spd_store((workgroup_id * 4u) + vec2(x, y), v, base_mip, slice);
+        spd_store_intermediate(x * 4u + y, y * 4u, v);
+    }
+#endif
+}
+
+fn spd_downsample_mip_4(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+#ifdef SUBGROUP_SUPPORT
+    if local_invocation_index < 16u {
+        var v = spd_load_intermediate(x * 4u + y, y * 4u);
+        v = spd_reduce_quad(v, subgroup_invocation_id);
+        if local_invocation_index % 4u == 0u {
+            spd_store((workgroup_id * 2u) + vec2(x / 2u, y / 2u), v, base_mip, slice);
+            spd_store_intermediate(x / 2u + y, 0u, v);
+        }
+    }
+#else
+    if local_invocation_index < 4u {
+        let v = spd_reduce_intermediate(
+            vec2(x * 8u + 0u + 0u + y * 2u, y * 8u + 0u),
+            vec2(x * 8u + 4u + 0u + y * 2u, y * 8u + 0u),
+            vec2(x * 8u + 0u + 1u + y * 2u, y * 8u + 4u),
+            vec2(x * 8u + 4u + 1u + y * 2u, y * 8u + 4u),
+        );
+        spd_store((workgroup_id * 2u) + vec2(x, y), v, base_mip, slice);
+        spd_store_intermediate(x + y * 2u, 0u, v);
+    }
+#endif
+}
+
+fn spd_downsample_mip_5(x: u32, y: u32, workgroup_id: vec2u, local_invocation_index: u32, base_mip: u32, slice: u32, subgroup_invocation_id: u32) {
+#ifdef SUBGROUP_SUPPORT
+    if local_invocation_index < 4u {
+        var v = spd_load_intermediate(local_invocation_index, 0u);
+        v = spd_reduce_quad(v, subgroup_invocation_id);
+        if local_invocation_index % 4u == 0u {
+            spd_store(workgroup_id, v, base_mip, slice);
+        }
+    }
+#else
+    if local_invocation_index < 1u {
+        let v = spd_reduce_intermediate(vec2(0u, 0u), vec2(1u, 0u), vec2(2u, 0u), vec2(3u, 0u));
+        spd_store(workgroup_id, v, base_mip, slice);
+    }
+#endif
+}
+
+fn spd_downsample_mips_6_7(x: u32, y: u32, mips: u32, slice: u32) {
+    var tex = vec2(x * 4u + 0u, y * 4u + 0u);
+    var pix = vec2(x * 2u + 0u, y * 2u + 0u);
+    let v0 = spd_reduce_load_4(
+        vec2(x * 4u + 0u, y * 4u + 0u),
+        vec2(x * 4u + 1u, y * 4u + 0u),
+        vec2(x * 4u + 0u, y * 4u + 1u),
+        vec2(x * 4u + 1u, y * 4u + 1u),
+        slice
+    );
+    spd_store(pix, v0, 6u, slice);
+
+    tex = vec2(x * 4u + 2u, y * 4u + 0u);
+    pix = vec2(x * 2u + 1u, y * 2u + 0u);
+    let v1 = spd_reduce_load_4(
+        vec2(x * 4u + 2u, y * 4u + 0u),
+        vec2(x * 4u + 3u, y * 4u + 0u),
+        vec2(x * 4u + 2u, y * 4u + 1u),
+        vec2(x * 4u + 3u, y * 4u + 1u),
+        slice
+    );
+    spd_store(pix, v1, 6u, slice);
+
+    tex = vec2(x * 4u + 0u, y * 4u + 2u);
+    pix = vec2(x * 2u + 0u, y * 2u + 1u);
+    let v2 = spd_reduce_load_4(
+        vec2(x * 4u + 0u, y * 4u + 2u),
+        vec2(x * 4u + 1u, y * 4u + 2u),
+        vec2(x * 4u + 0u, y * 4u + 3u),
+        vec2(x * 4u + 1u, y * 4u + 3u),
+        slice
+    );
+    spd_store(pix, v2, 6u, slice);
+
+    tex = vec2(x * 4u + 2u, y * 4u + 2u);
+    pix = vec2(x * 2u + 1u, y * 2u + 1u);
+    let v3 = spd_reduce_load_4(
+        vec2(x * 4u + 2u, y * 4u + 2u),
+        vec2(x * 4u + 3u, y * 4u + 2u),
+        vec2(x * 4u + 2u, y * 4u + 3u),
+        vec2(x * 4u + 3u, y * 4u + 3u),
+        slice
+    );
+    spd_store(pix, v3, 6u, slice);
+
+    if mips < 7u { return; }
+
+    let v = spd_reduce_4(v0, v1, v2, v3);
+    spd_store(vec2(x, y), v, 7u, slice);
+    spd_store_intermediate(x, y, v);
+}
+
+fn remap_for_wave_reduction(a: u32) -> vec2u {
+    // This function maps linear thread IDs to 2D coordinates in a special pattern
+    // to ensure that neighboring threads process neighboring pixels
+    // For example, this transforms linear thread IDs 0,1,2,3 into a 2×2 square
+    
+    // Extract bits to form the X and Y coordinates
+    let x = insertBits(extractBits(a, 2u, 3u), a, 0u, 1u);
+    let y = insertBits(extractBits(a, 3u, 3u), extractBits(a, 1u, 2u), 0u, 2u);
+    
+    return vec2u(x, y);
+}
+
+fn spd_reduce_load_source_image(uv: vec2u, slice: u32) -> vec4f {
+    let texture_coord = (vec2f(uv) + 0.5) * constants.inverse_input_size;
+
+    #ifdef COMBINE_BIND_GROUP
+    let result = textureSampleLevel(mip_0, sampler_linear_clamp, texture_coord, slice, 0.0);
+    #endif
+    #ifdef FIRST_PASS
+    let result = textureSampleLevel(mip_0, sampler_linear_clamp, texture_coord, slice, 0.0);
+    #endif
+    #ifdef SECOND_PASS
+    let result = textureSampleLevel(mip_6, sampler_linear_clamp, texture_coord, slice, 0.0);
+    #endif
+
+#ifdef SRGB_CONVERSION
+    return vec4(
+        srgb_from_linear(result.r),
+        srgb_from_linear(result.g),
+        srgb_from_linear(result.b),
+        result.a
+    );
+#else
+    return result;
+#endif
+
+}
+
+fn spd_store(pix: vec2u, value: vec4f, mip: u32, slice: u32) {
+    if mip >= constants.mips { return; }
+    switch mip {
+        #ifdef COMBINE_BIND_GROUP
+        case 0u: { textureStore(mip_1, pix, slice, value); }
+        case 1u: { textureStore(mip_2, pix, slice, value); }
+        case 2u: { textureStore(mip_3, pix, slice, value); }
+        case 3u: { textureStore(mip_4, pix, slice, value); }
+        case 4u: { textureStore(mip_5, pix, slice, value); }
+        case 5u: { textureStore(mip_6, pix, slice, value); }
+        case 6u: { textureStore(mip_7, pix, slice, value); }
+        case 7u: { textureStore(mip_8, pix, slice, value); }
+        case 8u: { textureStore(mip_9, pix, slice, value); }
+        case 9u: { textureStore(mip_10, pix, slice, value); }
+        case 10u: { textureStore(mip_11, pix, slice, value); }
+        case 11u: { textureStore(mip_12, pix, slice, value); }
+        #endif
+        #ifdef FIRST_PASS
+        case 0u: { textureStore(mip_1, pix, slice, value); }
+        case 1u: { textureStore(mip_2, pix, slice, value); }
+        case 2u: { textureStore(mip_3, pix, slice, value); }
+        case 3u: { textureStore(mip_4, pix, slice, value); }
+        case 4u: { textureStore(mip_5, pix, slice, value); }
+        case 5u: { textureStore(mip_6, pix, slice, value); }
+        #endif
+        #ifdef SECOND_PASS
+        case 6u: { textureStore(mip_7, pix, slice, value); }
+        case 7u: { textureStore(mip_8, pix, slice, value); }
+        case 8u: { textureStore(mip_9, pix, slice, value); }
+        case 9u: { textureStore(mip_10, pix, slice, value); }
+        case 10u: { textureStore(mip_11, pix, slice, value); }
+        case 11u: { textureStore(mip_12, pix, slice, value); }
+        #endif
+        default: {}
+    }
+}
+
+fn spd_store_intermediate(x: u32, y: u32, value: vec4f) {
+    spd_intermediate_r[x][y] = value.x;
+    spd_intermediate_g[x][y] = value.y;
+    spd_intermediate_b[x][y] = value.z;
+    spd_intermediate_a[x][y] = value.w;
+}
+
+fn spd_load_intermediate(x: u32, y: u32) -> vec4f {
+    return vec4(spd_intermediate_r[x][y], spd_intermediate_g[x][y], spd_intermediate_b[x][y], spd_intermediate_a[x][y]);
+}
+
+fn spd_reduce_intermediate(i0: vec2u, i1: vec2u, i2: vec2u, i3: vec2u) -> vec4f {
+    let v0 = spd_load_intermediate(i0.x, i0.y);
+    let v1 = spd_load_intermediate(i1.x, i1.y);
+    let v2 = spd_load_intermediate(i2.x, i2.y);
+    let v3 = spd_load_intermediate(i3.x, i3.y);
+    return spd_reduce_4(v0, v1, v2, v3);
+}
+
+fn spd_reduce_load_4(i0: vec2u, i1: vec2u, i2: vec2u, i3: vec2u, slice: u32) -> vec4f {
+    #ifdef COMBINE_BIND_GROUP
+    let v0 = textureLoad(mip_6, i0, slice);
+    let v1 = textureLoad(mip_6, i1, slice);
+    let v2 = textureLoad(mip_6, i2, slice);
+    let v3 = textureLoad(mip_6, i3, slice);
+    return spd_reduce_4(v0, v1, v2, v3);
+    #endif
+    #ifdef FIRST_PASS
+    return vec4(0.0, 0.0, 0.0, 0.0);
+    #endif
+    #ifdef SECOND_PASS
+    let v0 = textureLoad(mip_6, i0, slice, 0);
+    let v1 = textureLoad(mip_6, i1, slice, 0);
+    let v2 = textureLoad(mip_6, i2, slice, 0);
+    let v3 = textureLoad(mip_6, i3, slice, 0);
+    return spd_reduce_4(v0, v1, v2, v3);
+    #endif
+}
+
+fn spd_reduce_4(v0: vec4f, v1: vec4f, v2: vec4f, v3: vec4f) -> vec4f {
+    return (v0 + v1 + v2 + v3) * 0.25;
+}
+
+#ifdef SUBGROUP_SUPPORT
+fn spd_reduce_quad(v: vec4f, subgroup_invocation_id: u32) -> vec4f {
+    let quad = subgroup_invocation_id & (~0x3u);
+    let v0 = v;
+    let v1 = subgroupBroadcast(v, quad | 1u);
+    let v2 = subgroupBroadcast(v, quad | 2u);
+    let v3 = subgroupBroadcast(v, quad | 3u);
+    return spd_reduce_4(v0, v1, v2, v3);
+
+    // TODO: Use subgroup quad operations once wgpu supports them
+    // let v0 = v;
+    // let v1 = quadSwapX(v);
+    // let v2 = quadSwapY(v);
+    // let v3 = quadSwapDiagonal(v);
+    // return spd_reduce_4(v0, v1, v2, v3);
+}
+#endif
+
+fn srgb_from_linear(value: f32) -> f32 {
+    let j = vec3(0.0031308 * 12.92, 12.92, 1.0 / 2.4);
+    let k = vec2(1.055, -0.055);
+    return clamp(j.x, value * j.y, pow(value, j.z) * k.x + k.y);
+}
\ No newline at end of file
diff --git a/crates/bevy_pbr/src/light_probe/environment_filter.wgsl b/crates/bevy_pbr/src/light_probe/environment_filter.wgsl
new file mode 100644
index 0000000000000..390a66537f319
--- /dev/null
+++ b/crates/bevy_pbr/src/light_probe/environment_filter.wgsl
@@ -0,0 +1,176 @@
+#import bevy_render::maths::PI
+#import bevy_pbr::{
+    lighting,
+    utils::{sample_cosine_hemisphere, dir_to_cube_uv, sample_cube_dir, hammersley_2d}
+}
+
+struct FilteringConstants {
+    mip_level: f32,
+    sample_count: u32,
+    roughness: f32,
+    noise_size_bits: vec2u,
+}
+
+@group(0) @binding(0) var input_texture: texture_2d_array<f32>;
+@group(0) @binding(1) var input_sampler: sampler;
+@group(0) @binding(2) var output_texture: texture_storage_2d_array<rgba16float, write>;
+@group(0) @binding(3) var<uniform> constants: FilteringConstants;
+@group(0) @binding(4) var blue_noise_texture: texture_2d_array<f32>;
+
+// Sample an environment map with a specific LOD
+fn sample_environment(dir: vec3f, level: f32) -> vec4f {
+    let cube_uv = dir_to_cube_uv(dir);
+    return textureSampleLevel(input_texture, input_sampler, cube_uv.uv, cube_uv.face, level);
+}
+
+// Blue noise randomization
+fn sample_noise(pixel_coords: vec2u) -> vec4f {
+    let noise_size = vec2u(1) << constants.noise_size_bits;
+    let noise_size_mask = noise_size - vec2u(1u);
+    let noise_coords = pixel_coords & noise_size_mask;
+    let uv = vec2f(noise_coords) / vec2f(noise_size);
+    return textureSampleLevel(blue_noise_texture, input_sampler, uv, 0u, 0.0);
+}
+
+// Calculate LOD for environment map lookup using filtered importance sampling
+fn calculate_environment_map_lod(pdf: f32, width: f32, samples: f32) -> f32 {
+    // Solid angle of current sample
+    let omega_s = 1.0 / (samples * pdf);
+    
+    // Solid angle of a texel in the environment map
+    let omega_p = 4.0 * PI / (6.0 * width * width);
+    
+    // Filtered importance sampling: compute the correct LOD
+    return 0.5 * log2(omega_s / omega_p);
+}
+
+@compute
+@workgroup_size(8, 8, 1)
+fn generate_radiance_map(@builtin(global_invocation_id) global_id: vec3u) {
+    let size = textureDimensions(output_texture).xy;
+    let invSize = 1.0 / vec2f(size);
+    
+    let coords = vec2u(global_id.xy);
+    let face = global_id.z;
+    
+    if (any(coords >= size)) {
+        return;
+    }
+    
+    // Convert texture coordinates to direction vector
+    let uv = (vec2f(coords) + 0.5) * invSize;
+    let normal = sample_cube_dir(uv, face);
+    
+    // For radiance map, view direction = normal for perfect reflection
+    let view = normal;
+    
+    // Convert perceptual roughness to physical microfacet roughness
+    let perceptual_roughness = constants.roughness;
+    let roughness = lighting::perceptualRoughnessToRoughness(perceptual_roughness);
+    
+    // Get blue noise offset for stratification
+    let vector_noise = sample_noise(coords);
+    
+    var radiance = vec3f(0.0);
+    var total_weight = 0.0;
+    
+    // Skip sampling for mirror reflection (roughness = 0)
+    if (roughness < 0.01) {
+        radiance = sample_environment(normal, 0.0).rgb;
+        textureStore(output_texture, coords, face, vec4f(radiance, 1.0));
+        return;
+    }
+    
+    // For higher roughness values, use importance sampling
+    let sample_count = constants.sample_count;
+    
+    for (var i = 0u; i < sample_count; i++) {
+        // Get sample coordinates from Hammersley sequence with blue noise offset
+        var xi = hammersley_2d(i, sample_count);
+        xi = fract(xi + vector_noise.rg); // Apply Cranley-Patterson rotation
+        
+        // Sample the GGX distribution with the spherical-cap VNDF method
+        let light_dir = lighting::sample_visible_ggx(xi, roughness, normal, view);
+        
+        // Calculate weight (N·L)
+        let NdotL = dot(normal, light_dir);
+        
+        if (NdotL > 0.0) {
+            // Reconstruct the microfacet half-vector from view and light and compute PDF terms
+            let half_vector = normalize(view + light_dir);
+            let NdotH = dot(normal, half_vector);
+            let NdotV = dot(normal, view);
+            
+            // Get the geometric shadowing term
+            let G = lighting::G_Smith(NdotV, NdotL, roughness);
+            
+            // PDF that matches the bounded-VNDF sampling
+            let pdf = lighting::ggx_vndf_pdf(view, NdotH, roughness);
+            
+            // Calculate LOD using filtered importance sampling
+            // This is crucial to avoid fireflies and improve quality
+            let width = f32(size.x);
+            let lod = calculate_environment_map_lod(pdf, width, f32(sample_count));
+            
+            // Get source mip level - ensure we don't go negative
+            let source_mip = max(0.0, lod);
+            
+            // Sample environment map with the light direction
+            var sample_color = sample_environment(light_dir, source_mip).rgb;
+            
+            // Accumulate weighted sample, including geometric term
+            radiance += sample_color * NdotL * G;
+            total_weight += NdotL * G;
+        }
+    }
+    
+    // Normalize by total weight
+    if (total_weight > 0.0) {
+        radiance = radiance / total_weight;
+    }
+    
+    // Write result to output texture
+    textureStore(output_texture, coords, face, vec4f(radiance, 1.0));
+}
+
+@compute
+@workgroup_size(8, 8, 1)
+fn generate_irradiance_map(@builtin(global_invocation_id) global_id: vec3u) {
+    let size = textureDimensions(output_texture).xy;
+    let invSize = 1.0 / vec2f(size);
+    
+    let coords = vec2u(global_id.xy);
+    let face = global_id.z;
+    
+    if (any(coords >= size)) {
+        return;
+    }
+    
+    // Convert texture coordinates to direction vector
+    let uv = (vec2f(coords) + 0.5) * invSize;
+    let normal = sample_cube_dir(uv, face);
+    
+    var irradiance = vec3f(0.0);
+    
+    // Use uniform sampling on a hemisphere
+    for (var i = 0u; i < constants.sample_count; i++) {
+        // Build a deterministic RNG seed for this pixel / sample
+        // 4 randomly chosen 32-bit primes
+        var rng: u32 = (coords.x * 2131358057u) ^ (coords.y * 3416869721u) ^ (face * 1199786941u) ^ (i * 566200673u);
+
+        // Sample a direction from the upper hemisphere around the normal
+        var sample_dir = sample_cosine_hemisphere(normal, &rng);
+
+        // Sample environment with level 0 (no mip)
+        var sample_color = sample_environment(sample_dir, 0.0).rgb;
+        
+        // Accumulate the contribution
+        irradiance += sample_color;
+    }
+
+    // Normalize by number of samples (cosine-weighted sampling already accounts for PDF)
+    irradiance = irradiance / f32(constants.sample_count);
+    
+    // Write result to output texture
+    textureStore(output_texture, coords, face, vec4f(irradiance, 1.0));
+}
diff --git a/crates/bevy_pbr/src/light_probe/generate.rs b/crates/bevy_pbr/src/light_probe/generate.rs
new file mode 100644
index 0000000000000..04eab3df6e794
--- /dev/null
+++ b/crates/bevy_pbr/src/light_probe/generate.rs
@@ -0,0 +1,1097 @@
+//! Like [`EnvironmentMapLight`], but filtered in realtime from a cubemap.
+//!
+//! An environment map needs to be processed to be able to support uses beyond a simple skybox,
+//! such as reflections, and ambient light contribution.
+//! This process is called filtering, and can either be done ahead of time (prefiltering), or
+//! in realtime, although at a reduced quality. Prefiltering is preferred, but not always possible:
+//! sometimes you only gain access to an environment map at runtime, for whatever reason.
+//! Typically this is from realtime reflection probes, but can also be from other sources.
+//!
+//! In any case, Bevy supports both modes of filtering.
+//! This module provides realtime filtering via [`bevy_light::GeneratedEnvironmentMapLight`].
+//! For prefiltered environment maps, see [`bevy_light::EnvironmentMapLight`].
+//! These components are intended to be added to a camera.
+use bevy_asset::{load_embedded_asset, AssetServer, Assets};
+use bevy_ecs::{
+    component::Component,
+    entity::Entity,
+    query::{QueryState, With, Without},
+    resource::Resource,
+    system::{lifetimeless::Read, Commands, Query, Res, ResMut},
+    world::{FromWorld, World},
+};
+use bevy_image::Image;
+use bevy_math::{Quat, UVec2, Vec2};
+use bevy_render::{
+    diagnostic::RecordDiagnostics,
+    render_asset::{RenderAssetUsages, RenderAssets},
+    render_graph::{Node, NodeRunError, RenderGraphContext, RenderLabel},
+    render_resource::{
+        binding_types::*, AddressMode, BindGroup, BindGroupEntries, BindGroupLayout,
+        BindGroupLayoutEntries, CachedComputePipelineId, ComputePassDescriptor,
+        ComputePipelineDescriptor, Extent3d, FilterMode, PipelineCache, Sampler,
+        SamplerBindingType, SamplerDescriptor, ShaderDefVal, ShaderStages, ShaderType,
+        StorageTextureAccess, Texture, TextureAspect, TextureDescriptor, TextureDimension,
+        TextureFormat, TextureFormatFeatureFlags, TextureSampleType, TextureUsages, TextureView,
+        TextureViewDescriptor, TextureViewDimension, UniformBuffer,
+    },
+    renderer::{RenderAdapter, RenderContext, RenderDevice, RenderQueue},
+    settings::WgpuFeatures,
+    sync_world::RenderEntity,
+    texture::{CachedTexture, GpuImage, TextureCache},
+    Extract,
+};
+
+// Implementation: generate diffuse and specular cubemaps required by PBR
+// from a given high-res cubemap by
+//
+// 1. Copying the base mip (level 0) of the source cubemap into an intermediate
+//    storage texture.
+// 2. Generating mipmaps using [single-pass down-sampling] (SPD).
+// 3. Convolving the mip chain twice:
+//    * a [Lambertian convolution] for the 32 × 32 diffuse cubemap
+//    * a [GGX convolution], once per mip level, for the specular cubemap.
+//
+// [single-pass down-sampling]: https://gpuopen.com/fidelityfx-spd/
+// [Lambertian convolution]: https://bruop.github.io/ibl/#:~:text=Lambertian%20Diffuse%20Component
+// [GGX convolution]: https://gpuopen.com/download/Bounded_VNDF_Sampling_for_Smith-GGX_Reflections.pdf
+
+use bevy_light::{EnvironmentMapLight, GeneratedEnvironmentMapLight};
+use core::cmp::min;
+
+use crate::Bluenoise;
+
+/// Labels for the environment map generation nodes
+#[derive(PartialEq, Eq, Debug, Copy, Clone, Hash, RenderLabel)]
+pub enum GeneratorNode {
+    Downsampling,
+    Filtering,
+}
+
+/// Stores the bind group layouts for the environment map generation pipelines
+#[derive(Resource)]
+pub struct GeneratorBindGroupLayouts {
+    pub downsampling_first: BindGroupLayout,
+    pub downsampling_second: BindGroupLayout,
+    pub radiance: BindGroupLayout,
+    pub irradiance: BindGroupLayout,
+    pub copy: BindGroupLayout,
+}
+
+/// Samplers for the environment map generation pipelines
+#[derive(Resource)]
+pub struct GeneratorSamplers {
+    pub linear: Sampler,
+}
+
+/// Pipelines for the environment map generation pipelines
+#[derive(Resource)]
+pub struct GeneratorPipelines {
+    pub downsample_first: CachedComputePipelineId,
+    pub downsample_second: CachedComputePipelineId,
+    pub copy: CachedComputePipelineId,
+    pub radiance: CachedComputePipelineId,
+    pub irradiance: CachedComputePipelineId,
+}
+
+/// Configuration for downsampling strategy based on device limits
+#[derive(Resource, Clone, Copy, Debug, PartialEq, Eq)]
+pub struct DownsamplingConfig {
+    // can bind ≥12 storage textures and use read-write storage textures
+    pub combine_bind_group: bool,
+}
+
+// The number of storage textures required to combine the bind group
+const REQUIRED_STORAGE_TEXTURES: u32 = 12;
+
+/// Initializes all render-world resources used by the environment-map generator once on
+/// [`bevy_render::RenderStartup`].
+pub fn initialize_generated_environment_map_resources(
+    mut commands: Commands,
+    render_device: Res<RenderDevice>,
+    render_adapter: Res<RenderAdapter>,
+    pipeline_cache: Res<PipelineCache>,
+    asset_server: Res<AssetServer>,
+) {
+    // Determine whether we can use a single, large bind group for all mip outputs
+    let storage_texture_limit = render_device.limits().max_storage_textures_per_shader_stage;
+
+    // Determine whether we can read and write to the same rgba16f storage texture
+    let read_write_support = render_adapter
+        .get_texture_format_features(TextureFormat::Rgba16Float)
+        .flags
+        .contains(TextureFormatFeatureFlags::STORAGE_READ_WRITE);
+
+    // Combine the bind group and use read-write storage if it is supported
+    let combine_bind_group =
+        storage_texture_limit >= REQUIRED_STORAGE_TEXTURES && read_write_support;
+
+    // Output mips are write-only
+    let mips =
+        texture_storage_2d_array(TextureFormat::Rgba16Float, StorageTextureAccess::WriteOnly);
+
+    // Bind group layouts
+    let (downsampling_first, downsampling_second) = if combine_bind_group {
+        // One big bind group layout containing all outputs 1–12
+        let downsampling = render_device.create_bind_group_layout(
+            "downsampling_bind_group_layout_combined",
+            &BindGroupLayoutEntries::sequential(
+                ShaderStages::COMPUTE,
+                (
+                    sampler(SamplerBindingType::Filtering),
+                    uniform_buffer::<DownsamplingConstants>(false),
+                    texture_2d_array(TextureSampleType::Float { filterable: true }),
+                    mips, // 1
+                    mips, // 2
+                    mips, // 3
+                    mips, // 4
+                    mips, // 5
+                    texture_storage_2d_array(
+                        TextureFormat::Rgba16Float,
+                        StorageTextureAccess::ReadWrite,
+                    ), // 6
+                    mips, // 7
+                    mips, // 8
+                    mips, // 9
+                    mips, // 10
+                    mips, // 11
+                    mips, // 12
+                ),
+            ),
+        );
+
+        (downsampling.clone(), downsampling)
+    } else {
+        // Split layout: first pass outputs 1–6, second pass outputs 7–12 (input mip6 read-only)
+
+        let downsampling_first = render_device.create_bind_group_layout(
+            "downsampling_first_bind_group_layout",
+            &BindGroupLayoutEntries::sequential(
+                ShaderStages::COMPUTE,
+                (
+                    sampler(SamplerBindingType::Filtering),
+                    uniform_buffer::<DownsamplingConstants>(false),
+                    // Input mip 0
+                    texture_2d_array(TextureSampleType::Float { filterable: true }),
+                    mips, // 1
+                    mips, // 2
+                    mips, // 3
+                    mips, // 4
+                    mips, // 5
+                    mips, // 6
+                ),
+            ),
+        );
+
+        let downsampling_second = render_device.create_bind_group_layout(
+            "downsampling_second_bind_group_layout",
+            &BindGroupLayoutEntries::sequential(
+                ShaderStages::COMPUTE,
+                (
+                    sampler(SamplerBindingType::Filtering),
+                    uniform_buffer::<DownsamplingConstants>(false),
+                    // Input mip 6
+                    texture_2d_array(TextureSampleType::Float { filterable: true }),
+                    mips, // 7
+                    mips, // 8
+                    mips, // 9
+                    mips, // 10
+                    mips, // 11
+                    mips, // 12
+                ),
+            ),
+        );
+
+        (downsampling_first, downsampling_second)
+    };
+    let radiance = render_device.create_bind_group_layout(
+        "radiance_bind_group_layout",
+        &BindGroupLayoutEntries::sequential(
+            ShaderStages::COMPUTE,
+            (
+                // Source environment cubemap
+                texture_2d_array(TextureSampleType::Float { filterable: true }),
+                sampler(SamplerBindingType::Filtering), // Source sampler
+                // Output specular map
+                texture_storage_2d_array(
+                    TextureFormat::Rgba16Float,
+                    StorageTextureAccess::WriteOnly,
+                ),
+                uniform_buffer::<FilteringConstants>(false), // Uniforms
+                texture_2d_array(TextureSampleType::Float { filterable: true }), // Blue noise texture
+            ),
+        ),
+    );
+
+    let irradiance = render_device.create_bind_group_layout(
+        "irradiance_bind_group_layout",
+        &BindGroupLayoutEntries::sequential(
+            ShaderStages::COMPUTE,
+            (
+                // Source environment cubemap
+                texture_2d_array(TextureSampleType::Float { filterable: true }),
+                sampler(SamplerBindingType::Filtering), // Source sampler
+                // Output irradiance map
+                texture_storage_2d_array(
+                    TextureFormat::Rgba16Float,
+                    StorageTextureAccess::WriteOnly,
+                ),
+                uniform_buffer::<FilteringConstants>(false), // Uniforms
+                texture_2d_array(TextureSampleType::Float { filterable: true }), // Blue noise texture
+            ),
+        ),
+    );
+
+    let copy = render_device.create_bind_group_layout(
+        "copy_bind_group_layout",
+        &BindGroupLayoutEntries::sequential(
+            ShaderStages::COMPUTE,
+            (
+                // Source cubemap
+                texture_2d_array(TextureSampleType::Float { filterable: true }),
+                // Destination mip0
+                texture_storage_2d_array(
+                    TextureFormat::Rgba16Float,
+                    StorageTextureAccess::WriteOnly,
+                ),
+            ),
+        ),
+    );
+
+    let layouts = GeneratorBindGroupLayouts {
+        downsampling_first,
+        downsampling_second,
+        radiance,
+        irradiance,
+        copy,
+    };
+
+    // Samplers
+    let linear = render_device.create_sampler(&SamplerDescriptor {
+        label: Some("generator_linear_sampler"),
+        address_mode_u: AddressMode::ClampToEdge,
+        address_mode_v: AddressMode::ClampToEdge,
+        address_mode_w: AddressMode::ClampToEdge,
+        mag_filter: FilterMode::Linear,
+        min_filter: FilterMode::Linear,
+        mipmap_filter: FilterMode::Linear,
+        ..Default::default()
+    });
+
+    let samplers = GeneratorSamplers { linear };
+
+    // Pipelines
+    let features = render_device.features();
+    let mut shader_defs = vec![];
+    if features.contains(WgpuFeatures::SUBGROUP) {
+        shader_defs.push(ShaderDefVal::Int("SUBGROUP_SUPPORT".into(), 1));
+    }
+    if combine_bind_group {
+        shader_defs.push(ShaderDefVal::Int("COMBINE_BIND_GROUP".into(), 1));
+    }
+
+    let downsampling_shader = load_embedded_asset!(asset_server.as_ref(), "downsample.wgsl");
+    let env_filter_shader = load_embedded_asset!(asset_server.as_ref(), "environment_filter.wgsl");
+    let copy_shader = load_embedded_asset!(asset_server.as_ref(), "copy.wgsl");
+
+    // First pass for base mip Levels (0-5)
+    let downsample_first = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
+        label: Some("downsampling_first_pipeline".into()),
+        layout: vec![layouts.downsampling_first.clone()],
+        push_constant_ranges: vec![],
+        shader: downsampling_shader.clone(),
+        shader_defs: {
+            let mut defs = shader_defs.clone();
+            if !combine_bind_group {
+                defs.push(ShaderDefVal::Int("FIRST_PASS".into(), 1));
+            }
+            defs
+        },
+        entry_point: Some("downsample_first".into()),
+        zero_initialize_workgroup_memory: false,
+    });
+
+    let downsample_second = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
+        label: Some("downsampling_second_pipeline".into()),
+        layout: vec![layouts.downsampling_second.clone()],
+        push_constant_ranges: vec![],
+        shader: downsampling_shader,
+        shader_defs: {
+            let mut defs = shader_defs.clone();
+            if !combine_bind_group {
+                defs.push(ShaderDefVal::Int("SECOND_PASS".into(), 1));
+            }
+            defs
+        },
+        entry_point: Some("downsample_second".into()),
+        zero_initialize_workgroup_memory: false,
+    });
+
+    // Radiance map for specular environment maps
+    let radiance = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
+        label: Some("radiance_pipeline".into()),
+        layout: vec![layouts.radiance.clone()],
+        push_constant_ranges: vec![],
+        shader: env_filter_shader.clone(),
+        shader_defs: vec![],
+        entry_point: Some("generate_radiance_map".into()),
+        zero_initialize_workgroup_memory: false,
+    });
+
+    // Irradiance map for diffuse environment maps
+    let irradiance = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
+        label: Some("irradiance_pipeline".into()),
+        layout: vec![layouts.irradiance.clone()],
+        push_constant_ranges: vec![],
+        shader: env_filter_shader,
+        shader_defs: vec![],
+        entry_point: Some("generate_irradiance_map".into()),
+        zero_initialize_workgroup_memory: false,
+    });
+
+    // Copy pipeline handles format conversion and populates mip0 when formats differ
+    let copy_pipeline = pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
+        label: Some("copy_pipeline".into()),
+        layout: vec![layouts.copy.clone()],
+        push_constant_ranges: vec![],
+        shader: copy_shader,
+        shader_defs: vec![],
+        entry_point: Some("copy".into()),
+        zero_initialize_workgroup_memory: false,
+    });
+
+    let pipelines = GeneratorPipelines {
+        downsample_first,
+        downsample_second,
+        radiance,
+        irradiance,
+        copy: copy_pipeline,
+    };
+
+    // Insert all resources into the render world
+    commands.insert_resource(layouts);
+    commands.insert_resource(samplers);
+    commands.insert_resource(pipelines);
+    commands.insert_resource(DownsamplingConfig { combine_bind_group });
+}
+
+pub fn extract_generated_environment_map_entities(
+    query: Extract<
+        Query<(
+            RenderEntity,
+            &GeneratedEnvironmentMapLight,
+            &EnvironmentMapLight,
+        )>,
+    >,
+    mut commands: Commands,
+    render_images: Res<RenderAssets<GpuImage>>,
+) {
+    for (entity, filtered_env_map, env_map_light) in query.iter() {
+        let env_map = render_images
+            .get(&filtered_env_map.environment_map)
+            .expect("Environment map not found");
+
+        let diffuse_map = render_images.get(&env_map_light.diffuse_map);
+        let specular_map = render_images.get(&env_map_light.specular_map);
+
+        // continue if the diffuse map is not found
+        if diffuse_map.is_none() || specular_map.is_none() {
+            continue;
+        }
+
+        let diffuse_map = diffuse_map.unwrap();
+        let specular_map = specular_map.unwrap();
+
+        let render_filtered_env_map = RenderEnvironmentMap {
+            environment_map: env_map.clone(),
+            diffuse_map: diffuse_map.clone(),
+            specular_map: specular_map.clone(),
+            intensity: filtered_env_map.intensity,
+            rotation: filtered_env_map.rotation,
+            affects_lightmapped_mesh_diffuse: filtered_env_map.affects_lightmapped_mesh_diffuse,
+        };
+        commands
+            .get_entity(entity)
+            .expect("Entity not synced to render world")
+            .insert(render_filtered_env_map);
+    }
+}
+
+// A render-world specific version of FilteredEnvironmentMapLight that uses CachedTexture
+#[derive(Component, Clone)]
+pub struct RenderEnvironmentMap {
+    pub environment_map: GpuImage,
+    pub diffuse_map: GpuImage,
+    pub specular_map: GpuImage,
+    pub intensity: f32,
+    pub rotation: Quat,
+    pub affects_lightmapped_mesh_diffuse: bool,
+}
+
+#[derive(Component)]
+pub struct IntermediateTextures {
+    pub environment_map: CachedTexture,
+}
+
+/// Returns the total number of mip levels for the provided square texture size.
+/// `size` must be a power of two greater than zero. For example, `size = 512` → `9`.
+#[inline]
+fn compute_mip_count(size: u32) -> u32 {
+    debug_assert!(size.is_power_of_two());
+    32 - size.leading_zeros()
+}
+
+/// Prepares textures needed for single pass downsampling
+pub fn prepare_generated_environment_map_intermediate_textures(
+    light_probes: Query<(Entity, &RenderEnvironmentMap)>,
+    render_device: Res<RenderDevice>,
+    mut texture_cache: ResMut<TextureCache>,
+    mut commands: Commands,
+) {
+    for (entity, env_map_light) in &light_probes {
+        let base_size = env_map_light.environment_map.size.width;
+        let mip_level_count = compute_mip_count(base_size);
+
+        let environment_map = texture_cache.get(
+            &render_device,
+            TextureDescriptor {
+                label: Some("intermediate_environment_map"),
+                size: Extent3d {
+                    width: base_size,
+                    height: base_size,
+                    depth_or_array_layers: 6, // Cubemap faces
+                },
+                mip_level_count,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rgba16Float,
+                usage: TextureUsages::TEXTURE_BINDING
+                    | TextureUsages::STORAGE_BINDING
+                    | TextureUsages::COPY_DST,
+                view_formats: &[],
+            },
+        );
+
+        commands
+            .entity(entity)
+            .insert(IntermediateTextures { environment_map });
+    }
+}
+
+/// Shader constants for downsampling algorithm
+#[derive(Clone, Copy, ShaderType)]
+#[repr(C)]
+pub struct DownsamplingConstants {
+    mips: u32,
+    inverse_input_size: Vec2,
+    _padding: u32,
+}
+
+/// Constants for filtering
+#[derive(Clone, Copy, ShaderType)]
+#[repr(C)]
+pub struct FilteringConstants {
+    mip_level: f32,
+    sample_count: u32,
+    roughness: f32,
+    noise_size_bits: UVec2,
+}
+
+/// Stores bind groups for the environment map generation pipelines
+#[derive(Component)]
+pub struct GeneratorBindGroups {
+    pub downsampling_first: BindGroup,
+    pub downsampling_second: BindGroup,
+    pub radiance: Vec<BindGroup>, // One per mip level
+    pub irradiance: BindGroup,
+    pub copy: BindGroup,
+}
+
+/// Prepares bind groups for environment map generation pipelines
+pub fn prepare_generated_environment_map_bind_groups(
+    light_probes: Query<
+        (Entity, &IntermediateTextures, &RenderEnvironmentMap),
+        With<RenderEnvironmentMap>,
+    >,
+    render_device: Res<RenderDevice>,
+    queue: Res<RenderQueue>,
+    layouts: Res<GeneratorBindGroupLayouts>,
+    samplers: Res<GeneratorSamplers>,
+    render_images: Res<RenderAssets<GpuImage>>,
+    bluenoise: Res<Bluenoise>,
+    config: Res<DownsamplingConfig>,
+    mut commands: Commands,
+) {
+    // Skip until the blue-noise texture is available to avoid panicking.
+    // The system will retry next frame once the asset has loaded.
+    let Some(stbn_texture) = render_images.get(&bluenoise.texture) else {
+        return;
+    };
+
+    assert!(stbn_texture.size.width.is_power_of_two());
+    assert!(stbn_texture.size.height.is_power_of_two());
+    let noise_size_bits = UVec2::new(
+        stbn_texture.size.width.trailing_zeros(),
+        stbn_texture.size.height.trailing_zeros(),
+    );
+
+    for (entity, textures, env_map_light) in &light_probes {
+        // Determine mip chain based on input size
+        let base_size = env_map_light.environment_map.size.width;
+        let mip_count = compute_mip_count(base_size);
+        let last_mip = mip_count - 1;
+        let env_map_texture = env_map_light.environment_map.texture.clone();
+
+        // Create downsampling constants
+        let downsampling_constants = DownsamplingConstants {
+            mips: mip_count - 1, // Number of mips we are generating (excluding mip 0)
+            inverse_input_size: Vec2::new(1.0 / base_size as f32, 1.0 / base_size as f32),
+            _padding: 0,
+        };
+
+        let mut downsampling_constants_buffer = UniformBuffer::from(downsampling_constants);
+        downsampling_constants_buffer.write_buffer(&render_device, &queue);
+
+        let input_env_map_first = env_map_texture.clone().create_view(&TextureViewDescriptor {
+            dimension: Some(TextureViewDimension::D2Array),
+            ..Default::default()
+        });
+
+        // Utility closure to get a unique storage view for a given mip level.
+        let mip_storage = |level: u32| {
+            if level <= last_mip {
+                create_storage_view(&textures.environment_map.texture, level, &render_device)
+            } else {
+                // Return a fresh 1×1 placeholder view so each binding has its own sub-resource and cannot alias.
+                create_placeholder_storage_view(&render_device)
+            }
+        };
+
+        // Depending on device limits, build either a combined or split bind group layout
+        let (downsampling_first_bind_group, downsampling_second_bind_group) =
+            if config.combine_bind_group {
+                // Combined layout expects destinations 1–12 in both bind groups
+                let bind_group = render_device.create_bind_group(
+                    "downsampling_bind_group_combined_first",
+                    &layouts.downsampling_first,
+                    &BindGroupEntries::sequential((
+                        &samplers.linear,
+                        &downsampling_constants_buffer,
+                        &input_env_map_first,
+                        &mip_storage(1),
+                        &mip_storage(2),
+                        &mip_storage(3),
+                        &mip_storage(4),
+                        &mip_storage(5),
+                        &mip_storage(6),
+                        &mip_storage(7),
+                        &mip_storage(8),
+                        &mip_storage(9),
+                        &mip_storage(10),
+                        &mip_storage(11),
+                        &mip_storage(12),
+                    )),
+                );
+
+                (bind_group.clone(), bind_group)
+            } else {
+                // Split path requires a separate view for mip6 input
+                let input_env_map_second = env_map_texture.create_view(&TextureViewDescriptor {
+                    dimension: Some(TextureViewDimension::D2Array),
+                    base_mip_level: min(6, last_mip),
+                    mip_level_count: Some(1),
+                    ..Default::default()
+                });
+
+                // Split layout (current behavior)
+                let first = render_device.create_bind_group(
+                    "downsampling_first_bind_group",
+                    &layouts.downsampling_first,
+                    &BindGroupEntries::sequential((
+                        &samplers.linear,
+                        &downsampling_constants_buffer,
+                        &input_env_map_first,
+                        &mip_storage(1),
+                        &mip_storage(2),
+                        &mip_storage(3),
+                        &mip_storage(4),
+                        &mip_storage(5),
+                        &mip_storage(6),
+                    )),
+                );
+
+                let second = render_device.create_bind_group(
+                    "downsampling_second_bind_group",
+                    &layouts.downsampling_second,
+                    &BindGroupEntries::sequential((
+                        &samplers.linear,
+                        &downsampling_constants_buffer,
+                        &input_env_map_second,
+                        &mip_storage(7),
+                        &mip_storage(8),
+                        &mip_storage(9),
+                        &mip_storage(10),
+                        &mip_storage(11),
+                        &mip_storage(12),
+                    )),
+                );
+
+                (first, second)
+            };
+
+        // Create radiance map bind groups for each mip level
+        let num_mips = mip_count as usize;
+        let mut radiance_bind_groups = Vec::with_capacity(num_mips);
+
+        for mip in 0..num_mips {
+            // Calculate roughness from 0.0 (mip 0) to 0.889 (mip 8)
+            // We don't need roughness=1.0 as a mip level because it's handled by the separate diffuse irradiance map
+            let roughness = mip as f32 / (num_mips - 1) as f32;
+            let sample_count = 32u32 * 2u32.pow((roughness * 4.0) as u32);
+
+            let radiance_constants = FilteringConstants {
+                mip_level: mip as f32,
+                sample_count,
+                roughness,
+                noise_size_bits,
+            };
+
+            let mut radiance_constants_buffer = UniformBuffer::from(radiance_constants);
+            radiance_constants_buffer.write_buffer(&render_device, &queue);
+
+            let mip_storage_view = create_storage_view(
+                &env_map_light.specular_map.texture,
+                mip as u32,
+                &render_device,
+            );
+            let bind_group = render_device.create_bind_group(
+                Some(format!("radiance_bind_group_mip_{mip}").as_str()),
+                &layouts.radiance,
+                &BindGroupEntries::sequential((
+                    &textures.environment_map.default_view,
+                    &samplers.linear,
+                    &mip_storage_view,
+                    &radiance_constants_buffer,
+                    &stbn_texture.texture_view,
+                )),
+            );
+
+            radiance_bind_groups.push(bind_group);
+        }
+
+        // Create irradiance bind group
+        let irradiance_constants = FilteringConstants {
+            mip_level: 0.0,
+            // 32 phi, 32 theta = 1024 samples total
+            sample_count: 1024,
+            roughness: 1.0,
+            noise_size_bits,
+        };
+
+        let mut irradiance_constants_buffer = UniformBuffer::from(irradiance_constants);
+        irradiance_constants_buffer.write_buffer(&render_device, &queue);
+
+        // create a 2d array view
+        let irradiance_map =
+            env_map_light
+                .diffuse_map
+                .texture
+                .create_view(&TextureViewDescriptor {
+                    dimension: Some(TextureViewDimension::D2Array),
+                    ..Default::default()
+                });
+
+        let irradiance_bind_group = render_device.create_bind_group(
+            "irradiance_bind_group",
+            &layouts.irradiance,
+            &BindGroupEntries::sequential((
+                &textures.environment_map.default_view,
+                &samplers.linear,
+                &irradiance_map,
+                &irradiance_constants_buffer,
+                &stbn_texture.texture_view,
+            )),
+        );
+
+        // Create copy bind group (source env map → destination mip0)
+        let src_view = env_map_light
+            .environment_map
+            .texture
+            .create_view(&TextureViewDescriptor {
+                dimension: Some(TextureViewDimension::D2Array),
+                ..Default::default()
+            });
+
+        let dst_view = create_storage_view(&textures.environment_map.texture, 0, &render_device);
+
+        let copy_bind_group = render_device.create_bind_group(
+            "copy_bind_group",
+            &layouts.copy,
+            &BindGroupEntries::with_indices(((0, &src_view), (1, &dst_view))),
+        );
+
+        commands.entity(entity).insert(GeneratorBindGroups {
+            downsampling_first: downsampling_first_bind_group,
+            downsampling_second: downsampling_second_bind_group,
+            radiance: radiance_bind_groups,
+            irradiance: irradiance_bind_group,
+            copy: copy_bind_group,
+        });
+    }
+}
+
+/// Helper function to create a storage texture view for a specific mip level
+fn create_storage_view(texture: &Texture, mip: u32, _render_device: &RenderDevice) -> TextureView {
+    texture.create_view(&TextureViewDescriptor {
+        label: Some(format!("storage_view_mip_{mip}").as_str()),
+        format: Some(texture.format()),
+        dimension: Some(TextureViewDimension::D2Array),
+        aspect: TextureAspect::All,
+        base_mip_level: mip,
+        mip_level_count: Some(1),
+        base_array_layer: 0,
+        array_layer_count: Some(texture.depth_or_array_layers()),
+        usage: Some(TextureUsages::STORAGE_BINDING),
+    })
+}
+
+/// To ensure compatibility in web browsers, each call returns a unique resource so that multiple missing mip
+/// bindings in the same bind-group never alias.
+fn create_placeholder_storage_view(render_device: &RenderDevice) -> TextureView {
+    let tex = render_device.create_texture(&TextureDescriptor {
+        label: Some("lightprobe_placeholder"),
+        size: Extent3d {
+            width: 1,
+            height: 1,
+            depth_or_array_layers: 6,
+        },
+        mip_level_count: 1,
+        sample_count: 1,
+        dimension: TextureDimension::D2,
+        format: TextureFormat::Rgba16Float,
+        usage: TextureUsages::STORAGE_BINDING | TextureUsages::TEXTURE_BINDING,
+        view_formats: &[],
+    });
+
+    tex.create_view(&TextureViewDescriptor::default())
+}
+
+/// Downsampling node implementation that handles all parts of the mip chain
+pub struct DownsamplingNode {
+    query: QueryState<(
+        Entity,
+        Read<GeneratorBindGroups>,
+        Read<RenderEnvironmentMap>,
+    )>,
+}
+
+impl FromWorld for DownsamplingNode {
+    fn from_world(world: &mut World) -> Self {
+        Self {
+            query: QueryState::new(world),
+        }
+    }
+}
+
+impl Node for DownsamplingNode {
+    fn update(&mut self, world: &mut World) {
+        self.query.update_archetypes(world);
+    }
+
+    fn run(
+        &self,
+        _graph: &mut RenderGraphContext,
+        render_context: &mut RenderContext,
+        world: &World,
+    ) -> Result<(), NodeRunError> {
+        let pipeline_cache = world.resource::<PipelineCache>();
+        let pipelines = world.resource::<GeneratorPipelines>();
+
+        let Some(downsample_first_pipeline) =
+            pipeline_cache.get_compute_pipeline(pipelines.downsample_first)
+        else {
+            return Ok(());
+        };
+
+        let Some(downsample_second_pipeline) =
+            pipeline_cache.get_compute_pipeline(pipelines.downsample_second)
+        else {
+            return Ok(());
+        };
+
+        let diagnostics = render_context.diagnostic_recorder();
+
+        for (_, bind_groups, env_map_light) in self.query.iter_manual(world) {
+            // Copy base mip using compute shader with pre-built bind group
+            let Some(copy_pipeline) = pipeline_cache.get_compute_pipeline(pipelines.copy) else {
+                return Ok(());
+            };
+
+            {
+                let mut compute_pass =
+                    render_context
+                        .command_encoder()
+                        .begin_compute_pass(&ComputePassDescriptor {
+                            label: Some("lightprobe_copy_pass"),
+                            timestamp_writes: None,
+                        });
+
+                let pass_span = diagnostics.pass_span(&mut compute_pass, "lightprobe_copy_pass");
+
+                compute_pass.set_pipeline(copy_pipeline);
+                compute_pass.set_bind_group(0, &bind_groups.copy, &[]);
+
+                let tex_size = env_map_light.environment_map.size;
+                let wg_x = tex_size.width.div_ceil(8);
+                let wg_y = tex_size.height.div_ceil(8);
+                compute_pass.dispatch_workgroups(wg_x, wg_y, 6);
+
+                pass_span.end(&mut compute_pass);
+            }
+
+            // First pass - process mips 0-5
+            {
+                let mut compute_pass =
+                    render_context
+                        .command_encoder()
+                        .begin_compute_pass(&ComputePassDescriptor {
+                            label: Some("lightprobe_downsampling_first_pass"),
+                            timestamp_writes: None,
+                        });
+
+                let pass_span =
+                    diagnostics.pass_span(&mut compute_pass, "lightprobe_downsampling_first_pass");
+
+                compute_pass.set_pipeline(downsample_first_pipeline);
+                compute_pass.set_bind_group(0, &bind_groups.downsampling_first, &[]);
+
+                let tex_size = env_map_light.environment_map.size;
+                let wg_x = tex_size.width.div_ceil(64);
+                let wg_y = tex_size.height.div_ceil(64);
+                compute_pass.dispatch_workgroups(wg_x, wg_y, 6); // 6 faces
+
+                pass_span.end(&mut compute_pass);
+            }
+
+            // Second pass - process mips 6-12
+            {
+                let mut compute_pass =
+                    render_context
+                        .command_encoder()
+                        .begin_compute_pass(&ComputePassDescriptor {
+                            label: Some("lightprobe_downsampling_second_pass"),
+                            timestamp_writes: None,
+                        });
+
+                let pass_span =
+                    diagnostics.pass_span(&mut compute_pass, "lightprobe_downsampling_second_pass");
+
+                compute_pass.set_pipeline(downsample_second_pipeline);
+                compute_pass.set_bind_group(0, &bind_groups.downsampling_second, &[]);
+
+                let tex_size = env_map_light.environment_map.size;
+                let wg_x = tex_size.width.div_ceil(256);
+                let wg_y = tex_size.height.div_ceil(256);
+                compute_pass.dispatch_workgroups(wg_x, wg_y, 6);
+
+                pass_span.end(&mut compute_pass);
+            }
+        }
+
+        Ok(())
+    }
+}
+
+/// Radiance map node for generating specular environment maps
+pub struct FilteringNode {
+    query: QueryState<(
+        Entity,
+        Read<GeneratorBindGroups>,
+        Read<RenderEnvironmentMap>,
+    )>,
+}
+
+impl FromWorld for FilteringNode {
+    fn from_world(world: &mut World) -> Self {
+        Self {
+            query: QueryState::new(world),
+        }
+    }
+}
+
+impl Node for FilteringNode {
+    fn update(&mut self, world: &mut World) {
+        self.query.update_archetypes(world);
+    }
+
+    fn run(
+        &self,
+        _graph: &mut RenderGraphContext,
+        render_context: &mut RenderContext,
+        world: &World,
+    ) -> Result<(), NodeRunError> {
+        let pipeline_cache = world.resource::<PipelineCache>();
+        let pipelines = world.resource::<GeneratorPipelines>();
+
+        let Some(radiance_pipeline) = pipeline_cache.get_compute_pipeline(pipelines.radiance)
+        else {
+            return Ok(());
+        };
+        let Some(irradiance_pipeline) = pipeline_cache.get_compute_pipeline(pipelines.irradiance)
+        else {
+            return Ok(());
+        };
+
+        let diagnostics = render_context.diagnostic_recorder();
+
+        for (_, bind_groups, env_map_light) in self.query.iter_manual(world) {
+            let mut compute_pass =
+                render_context
+                    .command_encoder()
+                    .begin_compute_pass(&ComputePassDescriptor {
+                        label: Some("lightprobe_radiance_map_pass"),
+                        timestamp_writes: None,
+                    });
+
+            let pass_span =
+                diagnostics.pass_span(&mut compute_pass, "lightprobe_radiance_map_pass");
+
+            compute_pass.set_pipeline(radiance_pipeline);
+
+            let base_size = env_map_light.specular_map.size.width;
+
+            // Radiance convolution pass
+            // Process each mip at different roughness levels
+            for (mip, bind_group) in bind_groups.radiance.iter().enumerate() {
+                compute_pass.set_bind_group(0, bind_group, &[]);
+
+                // Calculate dispatch size based on mip level
+                let mip_size = base_size >> mip;
+                let workgroup_count = mip_size.div_ceil(8);
+
+                // Dispatch for all 6 faces
+                compute_pass.dispatch_workgroups(workgroup_count, workgroup_count, 6);
+            }
+            pass_span.end(&mut compute_pass);
+            // End the compute pass before starting the next one
+            drop(compute_pass);
+
+            // Irradiance convolution pass
+            // Generate the diffuse environment map
+            {
+                let mut compute_pass =
+                    render_context
+                        .command_encoder()
+                        .begin_compute_pass(&ComputePassDescriptor {
+                            label: Some("lightprobe_irradiance_map_pass"),
+                            timestamp_writes: None,
+                        });
+
+                let irr_span =
+                    diagnostics.pass_span(&mut compute_pass, "lightprobe_irradiance_map_pass");
+
+                compute_pass.set_pipeline(irradiance_pipeline);
+                compute_pass.set_bind_group(0, &bind_groups.irradiance, &[]);
+
+                // 32×32 texture processed with 8×8 workgroups for all 6 faces
+                compute_pass.dispatch_workgroups(4, 4, 6);
+
+                irr_span.end(&mut compute_pass);
+            }
+        }
+
+        Ok(())
+    }
+}
+
+/// System that generates an `EnvironmentMapLight` component based on the `GeneratedEnvironmentMapLight` component
+pub fn generate_environment_map_light(
+    mut commands: Commands,
+    mut images: ResMut<Assets<Image>>,
+    query: Query<(Entity, &GeneratedEnvironmentMapLight), Without<EnvironmentMapLight>>,
+) {
+    for (entity, filtered_env_map) in &query {
+        // Validate and fetch the source cubemap so we can size our targets correctly
+        let Some(src_image) = images.get(&filtered_env_map.environment_map) else {
+            // Texture not ready yet – try again next frame
+            continue;
+        };
+
+        let base_size = src_image.texture_descriptor.size.width;
+
+        // Sanity checks – square, power-of-two, ≤ 8192
+        if src_image.texture_descriptor.size.height != base_size
+            || !base_size.is_power_of_two()
+            || base_size > 8192
+        {
+            panic!(
+                "GeneratedEnvironmentMapLight source cubemap must be square power-of-two ≤ 8192, got {}×{}",
+                base_size, src_image.texture_descriptor.size.height
+            );
+        }
+
+        let mip_count = compute_mip_count(base_size);
+
+        // Create a placeholder for the irradiance map
+        let mut diffuse = Image::new_fill(
+            Extent3d {
+                width: 32,
+                height: 32,
+                depth_or_array_layers: 6,
+            },
+            TextureDimension::D2,
+            &[0; 8],
+            TextureFormat::Rgba16Float,
+            RenderAssetUsages::all(),
+        );
+
+        diffuse.texture_descriptor.usage =
+            TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING;
+
+        diffuse.texture_view_descriptor = Some(TextureViewDescriptor {
+            dimension: Some(TextureViewDimension::Cube),
+            ..Default::default()
+        });
+
+        let diffuse_handle = images.add(diffuse);
+
+        // Create a placeholder for the specular map. It matches the input cubemap resolution.
+        let mut specular = Image::new_fill(
+            Extent3d {
+                width: base_size,
+                height: base_size,
+                depth_or_array_layers: 6,
+            },
+            TextureDimension::D2,
+            &[0; 8],
+            TextureFormat::Rgba16Float,
+            RenderAssetUsages::all(),
+        );
+
+        // Set up for mipmaps
+        specular.texture_descriptor.usage =
+            TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING;
+        specular.texture_descriptor.mip_level_count = mip_count;
+
+        // When setting mip_level_count, we need to allocate appropriate data size
+        // For GPU-generated mipmaps, we can set data to None since the GPU will generate the data
+        specular.data = None;
+
+        specular.texture_view_descriptor = Some(TextureViewDescriptor {
+            dimension: Some(TextureViewDimension::Cube),
+            mip_level_count: Some(mip_count),
+            ..Default::default()
+        });
+
+        let specular_handle = images.add(specular);
+
+        // Add the EnvironmentMapLight component with the placeholder handles
+        commands.entity(entity).insert(EnvironmentMapLight {
+            diffuse_map: diffuse_handle,
+            specular_map: specular_handle,
+            intensity: filtered_env_map.intensity,
+            rotation: filtered_env_map.rotation,
+            affects_lightmapped_mesh_diffuse: filtered_env_map.affects_lightmapped_mesh_diffuse,
+        });
+    }
+}
diff --git a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
index 95ed8dcbd91d9..e1931d30b82aa 100644
--- a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
+++ b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
@@ -127,7 +127,7 @@
 //!
 //! [Blender]: http://blender.org/
 //!
-//! [baking tool]: https://docs.blender.org/manual/en/latest/render/eevee/render_settings/indirect_lighting.html
+//! [baking tool]: https://docs.blender.org/manual/en/latest/render/eevee/light_probes/volume.html
 //!
 //! [`bevy-baked-gi`]: https://github.com/pcwalton/bevy-baked-gi
 //!
diff --git a/crates/bevy_pbr/src/light_probe/mod.rs b/crates/bevy_pbr/src/light_probe/mod.rs
index 3c2da1f52101e..ffbaf21b89138 100644
--- a/crates/bevy_pbr/src/light_probe/mod.rs
+++ b/crates/bevy_pbr/src/light_probe/mod.rs
@@ -1,8 +1,11 @@
 //! Light probes for baked global illumination.
 
-use bevy_app::{App, Plugin};
-use bevy_asset::AssetId;
-use bevy_core_pipeline::core_3d::Camera3d;
+use bevy_app::{App, Plugin, Update};
+use bevy_asset::{embedded_asset, AssetId};
+use bevy_core_pipeline::core_3d::{
+    graph::{Core3d, Node3d},
+    Camera3d,
+};
 use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::{
     component::Component,
@@ -13,7 +16,7 @@ use bevy_ecs::{
     system::{Commands, Local, Query, Res, ResMut},
 };
 use bevy_image::Image;
-use bevy_light::{EnvironmentMapLight, LightProbe};
+use bevy_light::{EnvironmentMapLight, GeneratedEnvironmentMapLight, LightProbe};
 use bevy_math::{Affine3A, FloatOrd, Mat4, Vec3A, Vec4};
 use bevy_platform::collections::HashMap;
 use bevy_render::{
@@ -21,24 +24,36 @@ use bevy_render::{
     load_shader_library,
     primitives::{Aabb, Frustum},
     render_asset::RenderAssets,
+    render_graph::RenderGraphExt,
     render_resource::{DynamicUniformBuffer, Sampler, ShaderType, TextureView},
     renderer::{RenderAdapter, RenderDevice, RenderQueue},
     settings::WgpuFeatures,
+    sync_component::SyncComponentPlugin,
     sync_world::RenderEntity,
     texture::{FallbackImage, GpuImage},
     view::ExtractedView,
-    Extract, ExtractSchedule, Render, RenderApp, RenderSystems,
+    Extract, ExtractSchedule, Render, RenderApp, RenderStartup, RenderSystems,
 };
 use bevy_transform::{components::Transform, prelude::GlobalTransform};
 use tracing::error;
 
 use core::{hash::Hash, ops::Deref};
 
-use crate::light_probe::environment_map::EnvironmentMapIds;
+use crate::{
+    generate::{
+        extract_generated_environment_map_entities, generate_environment_map_light,
+        initialize_generated_environment_map_resources,
+        prepare_generated_environment_map_bind_groups,
+        prepare_generated_environment_map_intermediate_textures, DownsamplingNode, FilteringNode,
+        GeneratorNode,
+    },
+    light_probe::environment_map::EnvironmentMapIds,
+};
 
 use self::irradiance_volume::IrradianceVolume;
 
 pub mod environment_map;
+pub mod generate;
 pub mod irradiance_volume;
 
 /// The maximum number of each type of light probe that each view will consider.
@@ -288,7 +303,13 @@ impl Plugin for LightProbePlugin {
         load_shader_library!(app, "environment_map.wgsl");
         load_shader_library!(app, "irradiance_volume.wgsl");
 
-        app.add_plugins(ExtractInstancesPlugin::<EnvironmentMapIds>::new());
+        embedded_asset!(app, "environment_filter.wgsl");
+        embedded_asset!(app, "downsample.wgsl");
+        embedded_asset!(app, "copy.wgsl");
+
+        app.add_plugins(ExtractInstancesPlugin::<EnvironmentMapIds>::new())
+            .add_plugins(SyncComponentPlugin::<GeneratedEnvironmentMapLight>::default())
+            .add_systems(Update, generate_environment_map_light);
 
         let Some(render_app) = app.get_sub_app_mut(RenderApp) else {
             return;
@@ -297,13 +318,41 @@ impl Plugin for LightProbePlugin {
         render_app
             .init_resource::<LightProbesBuffer>()
             .init_resource::<EnvironmentMapUniformBuffer>()
+            .add_render_graph_node::<DownsamplingNode>(Core3d, GeneratorNode::Downsampling)
+            .add_render_graph_node::<FilteringNode>(Core3d, GeneratorNode::Filtering)
+            .add_render_graph_edges(
+                Core3d,
+                (
+                    Node3d::EndPrepasses,
+                    GeneratorNode::Downsampling,
+                    GeneratorNode::Filtering,
+                    Node3d::StartMainPass,
+                ),
+            )
             .add_systems(ExtractSchedule, gather_environment_map_uniform)
             .add_systems(ExtractSchedule, gather_light_probes::<EnvironmentMapLight>)
             .add_systems(ExtractSchedule, gather_light_probes::<IrradianceVolume>)
+            .add_systems(
+                ExtractSchedule,
+                extract_generated_environment_map_entities.after(generate_environment_map_light),
+            )
             .add_systems(
                 Render,
-                (upload_light_probes, prepare_environment_uniform_buffer)
+                prepare_generated_environment_map_bind_groups
+                    .in_set(RenderSystems::PrepareBindGroups),
+            )
+            .add_systems(
+                Render,
+                (
+                    upload_light_probes,
+                    prepare_environment_uniform_buffer,
+                    prepare_generated_environment_map_intermediate_textures,
+                )
                     .in_set(RenderSystems::PrepareResources),
+            )
+            .add_systems(
+                RenderStartup,
+                initialize_generated_environment_map_resources,
             );
     }
 }
diff --git a/crates/bevy_pbr/src/render/pbr_lighting.wgsl b/crates/bevy_pbr/src/render/pbr_lighting.wgsl
index 09329b900750b..7496dea4fc050 100644
--- a/crates/bevy_pbr/src/render/pbr_lighting.wgsl
+++ b/crates/bevy_pbr/src/render/pbr_lighting.wgsl
@@ -201,6 +201,91 @@ fn V_GGX_anisotropic(
     return saturate(v);
 }
 
+// Probability-density function that matches the bounded VNDF sampler
+// https://gpuopen.com/download/Bounded_VNDF_Sampling_for_Smith-GGX_Reflections.pdf (Listing 2)
+fn ggx_vndf_pdf(i: vec3<f32>, NdotH: f32, roughness: f32) -> f32 {
+    let ndf = D_GGX(roughness, NdotH);
+
+    // Common terms
+    let ai = roughness * i.xy;
+    let len2 = dot(ai, ai);
+    let t = sqrt(len2 + i.z * i.z);
+    if i.z >= 0.0 {
+        let a = roughness;
+        let s = 1.0 + length(i.xy);
+        let a2 = a * a;
+        let s2 = s * s;
+        let k = (1.0 - a2) * s2 / (s2 + a2 * i.z * i.z);
+        return ndf / (2.0 * (k * i.z + t));
+    }
+
+    // Backfacing case
+    return ndf * (t - i.z) / (2.0 * len2);
+}
+
+// https://gpuopen.com/download/Bounded_VNDF_Sampling_for_Smith-GGX_Reflections.pdf (Listing 1)
+fn sample_visible_ggx(
+    xi: vec2<f32>,
+    roughness: f32,
+    normal: vec3<f32>,
+    view: vec3<f32>,
+) -> vec3<f32> {
+    let n = normal;
+    let alpha = roughness;
+
+    // Decompose view into components parallel/perpendicular to the normal
+    let wi_n = dot(view, n);
+    let wi_z = -n * wi_n;
+    let wi_xy = view + wi_z;
+
+    // Warp view vector to the unit-roughness configuration
+    let wi_std = -normalize(alpha * wi_xy + wi_z);
+
+    // Compute wi_std.z once for reuse
+    let wi_std_z = dot(wi_std, n);
+
+    // Bounded VNDF sampling
+    // Compute the bound parameter k (Eq. 5) and the scaled z–limit b (Eq. 6)
+    let s = 1.0 + length(wi_xy);
+    let a = clamp(alpha, 0.0, 1.0);
+    let a2 = a * a;
+    let s2 = s * s;
+    let k = (1.0 - a2) * s2 / (s2 + a2 * wi_n * wi_n);
+    let b = select(wi_std_z, k * wi_std_z, wi_n > 0.0);
+
+    // Sample a spherical cap in (-b, 1]
+    let z = 1.0 - xi.y * (1.0 + b);
+    let sin_theta = sqrt(max(0.0, 1.0 - z * z));
+    let phi = 2.0 * PI * xi.x - PI;
+    let x = sin_theta * cos(phi);
+    let y = sin_theta * sin(phi);
+    let c_std = vec3f(x, y, z);
+
+    // Reflect the sample so that the normal aligns with +Z
+    let up = vec3f(0.0, 0.0, 1.0);
+    let wr = n + up;
+    let c = dot(wr, c_std) * wr / wr.z - c_std;
+
+    // Half-vector in the standard frame
+    let wm_std = c + wi_std;
+    let wm_std_z = n * dot(n, wm_std);
+    let wm_std_xy = wm_std_z - wm_std;
+
+    // Unwarp back to original roughness and compute microfacet normal
+    let H = normalize(alpha * wm_std_xy + wm_std_z);
+
+    // Reflect view to obtain the outgoing (light) direction
+    return reflect(-view, H);
+}
+
+// Smith geometric shadowing function
+fn G_Smith(NdotV: f32, NdotL: f32, roughness: f32) -> f32 {
+    let k = roughness / 2.0;
+    let GGXL = NdotL / (NdotL * (1.0 - k) + k);
+    let GGXV = NdotV / (NdotV * (1.0 - k) + k);
+    return GGXL * GGXV;
+}
+
 // A simpler, but nonphysical, alternative to Smith-GGX. We use this for
 // clearcoat, per the Filament spec.
 //
diff --git a/crates/bevy_pbr/src/render/utils.wgsl b/crates/bevy_pbr/src/render/utils.wgsl
index b474b1a50ef12..097b5ae4c203c 100644
--- a/crates/bevy_pbr/src/render/utils.wgsl
+++ b/crates/bevy_pbr/src/render/utils.wgsl
@@ -1,6 +1,7 @@
 #define_import_path bevy_pbr::utils
 
 #import bevy_pbr::rgb9e5
+#import bevy_render::maths::{PI, PI_2, orthonormalize}
 
 // Generates a random u32 in range [0, u32::MAX].
 //
@@ -73,6 +74,13 @@ fn interleaved_gradient_noise(pixel_coordinates: vec2<f32>, frame: u32) -> f32 {
     return fract(52.9829189 * fract(0.06711056 * xy.x + 0.00583715 * xy.y));
 }
 
+// Hammersley sequence for quasi-random points
+fn hammersley_2d(i: u32, n: u32) -> vec2f {
+    let inv_n = 1.0 / f32(n);
+    let vdc = f32(reverseBits(i)) * 2.3283064365386963e-10; // 1/2^32
+    return vec2f(f32(i) * inv_n, vdc);
+}
+
 // https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare (slides 120-135)
 // TODO: Use an array here instead of a bunch of constants, once arrays work properly under DX12.
 // NOTE: The names have a final underscore to avoid the following error:
@@ -85,3 +93,109 @@ const SPIRAL_OFFSET_4_ = vec2<f32>( 0.3536, -0.3536);
 const SPIRAL_OFFSET_5_ = vec2<f32>(-0.0000,  0.3750);
 const SPIRAL_OFFSET_6_ = vec2<f32>(-0.1768, -0.1768);
 const SPIRAL_OFFSET_7_ = vec2<f32>( 0.1250,  0.0000);
+
+// https://www.realtimerendering.com/raytracinggems/unofficial_RayTracingGems_v1.9.pdf#0004286901.INDD%3ASec28%3A303
+fn sample_cosine_hemisphere(normal: vec3<f32>, rng: ptr<function, u32>) -> vec3<f32> {
+    let cos_theta = 1.0 - 2.0 * rand_f(rng);
+    let phi = PI_2 * rand_f(rng);
+    let sin_theta = sqrt(max(1.0 - cos_theta * cos_theta, 0.0));
+    let x = normal.x + sin_theta * cos(phi);
+    let y = normal.y + sin_theta * sin(phi);
+    let z = normal.z + cos_theta;
+    return vec3(x, y, z);
+}
+// https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations#UniformlySamplingaHemisphere
+fn sample_uniform_hemisphere(normal: vec3<f32>, rng: ptr<function, u32>) -> vec3<f32> {
+    let cos_theta = rand_f(rng);
+    let phi = PI_2 * rand_f(rng);
+    let sin_theta = sqrt(max(1.0 - cos_theta * cos_theta, 0.0));
+    let x = sin_theta * cos(phi);
+    let y = sin_theta * sin(phi);
+    let z = cos_theta;
+    return orthonormalize(normal) * vec3(x, y, z);
+}
+
+// https://www.realtimerendering.com/raytracinggems/unofficial_RayTracingGems_v1.9.pdf#0004286901.INDD%3ASec19%3A294
+fn sample_disk(disk_radius: f32, rng: ptr<function, u32>) -> vec2<f32> {
+    let ab = 2.0 * rand_vec2f(rng) - 1.0;
+    let a = ab.x;
+    var b = ab.y;
+    if (b == 0.0) { b = 1.0; }
+
+    var phi: f32;
+    var r: f32;
+    if (a * a > b * b) {
+        r = disk_radius * a;
+        phi = (PI / 4.0) * (b / a);
+    } else {
+        r = disk_radius * b;
+        phi = (PI / 2.0) - (PI / 4.0) * (a / b);
+    }
+
+    let x = r * cos(phi);
+    let y = r * sin(phi);
+    return vec2(x, y);
+}
+
+// Convert UV and face index to direction vector
+fn sample_cube_dir(uv: vec2f, face: u32) -> vec3f {
+    // Convert from [0,1] to [-1,1]
+    let uvc = 2.0 * uv - 1.0;
+    
+    // Generate direction based on the cube face
+    var dir: vec3f;
+    switch(face) {
+        case 0u: { dir = vec3f( 1.0,  -uvc.y, -uvc.x); } // +X
+        case 1u: { dir = vec3f(-1.0,  -uvc.y,  uvc.x); } // -X
+        case 2u: { dir = vec3f( uvc.x,  1.0,   uvc.y); } // +Y
+        case 3u: { dir = vec3f( uvc.x, -1.0,  -uvc.y); } // -Y
+        case 4u: { dir = vec3f( uvc.x, -uvc.y,  1.0);  } // +Z
+        case 5u: { dir = vec3f(-uvc.x, -uvc.y, -1.0);  } // -Z
+        default: { dir = vec3f(0.0); }
+    }
+    return normalize(dir);
+}
+
+// Convert direction vector to cube face UV
+struct CubeUV {
+    uv: vec2f,
+    face: u32,
+}
+fn dir_to_cube_uv(dir: vec3f) -> CubeUV {
+    let abs_dir = abs(dir);
+    var face: u32 = 0u;
+    var uv: vec2f = vec2f(0.0);
+    
+    // Find the dominant axis to determine face
+    if (abs_dir.x >= abs_dir.y && abs_dir.x >= abs_dir.z) {
+        // X axis is dominant
+        if (dir.x > 0.0) {
+            face = 0u; // +X
+            uv = vec2f(-dir.z, -dir.y) / dir.x;
+        } else {
+            face = 1u; // -X
+            uv = vec2f(dir.z, -dir.y) / abs_dir.x;
+        }
+    } else if (abs_dir.y >= abs_dir.x && abs_dir.y >= abs_dir.z) {
+        // Y axis is dominant
+        if (dir.y > 0.0) {
+            face = 2u; // +Y
+            uv = vec2f(dir.x, dir.z) / dir.y;
+        } else {
+            face = 3u; // -Y
+            uv = vec2f(dir.x, -dir.z) / abs_dir.y;
+        }
+    } else {
+        // Z axis is dominant
+        if (dir.z > 0.0) {
+            face = 4u; // +Z
+            uv = vec2f(dir.x, -dir.y) / dir.z;
+        } else {
+            face = 5u; // -Z
+            uv = vec2f(-dir.x, -dir.y) / abs_dir.z;
+        }
+    }
+    
+    // Convert from [-1,1] to [0,1]
+    return CubeUV(uv * 0.5 + 0.5, face);
+}
diff --git a/crates/bevy_pbr/src/stbn.ktx2 b/crates/bevy_pbr/src/stbn.ktx2
new file mode 100644
index 0000000000000..bd5ca539c9e6f
Binary files /dev/null and b/crates/bevy_pbr/src/stbn.ktx2 differ
diff --git a/crates/bevy_solari/src/pathtracer/pathtracer.wgsl b/crates/bevy_solari/src/pathtracer/pathtracer.wgsl
index be92b67bfae9f..45c5e519594f0 100644
--- a/crates/bevy_solari/src/pathtracer/pathtracer.wgsl
+++ b/crates/bevy_solari/src/pathtracer/pathtracer.wgsl
@@ -1,8 +1,8 @@
 #import bevy_core_pipeline::tonemapping::tonemapping_luminance as luminance
-#import bevy_pbr::utils::{rand_f, rand_vec2f}
+#import bevy_pbr::utils::{rand_f, rand_vec2f, sample_cosine_hemisphere}
 #import bevy_render::maths::PI
 #import bevy_render::view::View
-#import bevy_solari::sampling::{sample_random_light, sample_cosine_hemisphere}
+#import bevy_solari::sampling::sample_random_light
 #import bevy_solari::scene_bindings::{trace_ray, resolve_ray_hit_full, RAY_T_MIN, RAY_T_MAX}
 
 @group(1) @binding(0) var accumulation_texture: texture_storage_2d<rgba32float, read_write>;
diff --git a/crates/bevy_solari/src/realtime/restir_di.wgsl b/crates/bevy_solari/src/realtime/restir_di.wgsl
index 175b9ded96c09..bea79ef42ccb5 100644
--- a/crates/bevy_solari/src/realtime/restir_di.wgsl
+++ b/crates/bevy_solari/src/realtime/restir_di.wgsl
@@ -5,11 +5,11 @@
 #import bevy_pbr::pbr_deferred_types::unpack_24bit_normal
 #import bevy_pbr::prepass_bindings::PreviousViewUniforms
 #import bevy_pbr::rgb9e5::rgb9e5_to_vec3_
-#import bevy_pbr::utils::{rand_f, rand_range_u, octahedral_decode}
+#import bevy_pbr::utils::{rand_f, rand_range_u, octahedral_decode, sample_disk}
 #import bevy_render::maths::PI
 #import bevy_render::view::View
 #import bevy_solari::presample_light_tiles::{ResolvedLightSamplePacked, unpack_resolved_light_sample}
-#import bevy_solari::sampling::{LightSample, calculate_resolved_light_contribution, resolve_and_calculate_light_contribution, resolve_light_sample, trace_light_visibility, sample_disk}
+#import bevy_solari::sampling::{LightSample, calculate_resolved_light_contribution, resolve_and_calculate_light_contribution, resolve_light_sample, trace_light_visibility}
 #import bevy_solari::scene_bindings::{light_sources, previous_frame_light_id_translations, LIGHT_NOT_PRESENT_THIS_FRAME}
 
 @group(1) @binding(0) var view_output: texture_storage_2d<rgba16float, read_write>;
diff --git a/crates/bevy_solari/src/realtime/restir_gi.wgsl b/crates/bevy_solari/src/realtime/restir_gi.wgsl
index 2be5e8554dba9..9c4b0347050ef 100644
--- a/crates/bevy_solari/src/realtime/restir_gi.wgsl
+++ b/crates/bevy_solari/src/realtime/restir_gi.wgsl
@@ -4,10 +4,10 @@
 #import bevy_pbr::pbr_deferred_types::unpack_24bit_normal
 #import bevy_pbr::prepass_bindings::PreviousViewUniforms
 #import bevy_pbr::rgb9e5::rgb9e5_to_vec3_
-#import bevy_pbr::utils::{rand_f, octahedral_decode}
+#import bevy_pbr::utils::{rand_f, sample_uniform_hemisphere, sample_disk, octahedral_decode}
 #import bevy_render::maths::{PI, PI_2}
 #import bevy_render::view::View
-#import bevy_solari::sampling::{sample_uniform_hemisphere, sample_random_light, trace_point_visibility, sample_disk}
+#import bevy_solari::sampling::{sample_random_light, trace_point_visibility}
 #import bevy_solari::scene_bindings::{trace_ray, resolve_ray_hit_full, RAY_T_MIN, RAY_T_MAX}
 
 @group(1) @binding(0) var view_output: texture_storage_2d<rgba16float, read_write>;
diff --git a/crates/bevy_solari/src/scene/sampling.wgsl b/crates/bevy_solari/src/scene/sampling.wgsl
index 677d2649a8cac..298cf8ad679a0 100644
--- a/crates/bevy_solari/src/scene/sampling.wgsl
+++ b/crates/bevy_solari/src/scene/sampling.wgsl
@@ -1,53 +1,9 @@
 #define_import_path bevy_solari::sampling
 
 #import bevy_pbr::utils::{rand_f, rand_vec2f, rand_u, rand_range_u}
-#import bevy_render::maths::{PI, PI_2, orthonormalize}
+#import bevy_render::maths::PI_2
 #import bevy_solari::scene_bindings::{trace_ray, RAY_T_MIN, RAY_T_MAX, light_sources, directional_lights, LightSource, LIGHT_SOURCE_KIND_DIRECTIONAL, resolve_triangle_data_full}
 
-// https://www.realtimerendering.com/raytracinggems/unofficial_RayTracingGems_v1.9.pdf#0004286901.INDD%3ASec28%3A303
-fn sample_cosine_hemisphere(normal: vec3<f32>, rng: ptr<function, u32>) -> vec3<f32> {
-    let cos_theta = 1.0 - 2.0 * rand_f(rng);
-    let phi = PI_2 * rand_f(rng);
-    let sin_theta = sqrt(max(1.0 - cos_theta * cos_theta, 0.0));
-    let x = normal.x + sin_theta * cos(phi);
-    let y = normal.y + sin_theta * sin(phi);
-    let z = normal.z + cos_theta;
-    return vec3(x, y, z);
-}
-
-// https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations#UniformlySamplingaHemisphere
-fn sample_uniform_hemisphere(normal: vec3<f32>, rng: ptr<function, u32>) -> vec3<f32> {
-    let cos_theta = rand_f(rng);
-    let phi = PI_2 * rand_f(rng);
-    let sin_theta = sqrt(max(1.0 - cos_theta * cos_theta, 0.0));
-    let x = sin_theta * cos(phi);
-    let y = sin_theta * sin(phi);
-    let z = cos_theta;
-    return orthonormalize(normal) * vec3(x, y, z);
-}
-
-// https://www.realtimerendering.com/raytracinggems/unofficial_RayTracingGems_v1.9.pdf#0004286901.INDD%3ASec19%3A294
-fn sample_disk(disk_radius: f32, rng: ptr<function, u32>) -> vec2<f32> {
-    let ab = 2.0 * rand_vec2f(rng) - 1.0;
-    let a = ab.x;
-    var b = ab.y;
-    if (b == 0.0) { b = 1.0; }
-
-    var phi: f32;
-    var r: f32;
-    if (a * a > b * b) {
-        r = disk_radius * a;
-        phi = (PI / 4.0) * (b / a);
-    } else {
-        r = disk_radius * b;
-        phi = (PI / 2.0) - (PI / 4.0) * (a / b);
-    }
-
-    let x = r * cos(phi);
-    let y = r * sin(phi);
-    return vec2(x, y);
-}
-
 struct LightSample {
     light_id: u32,
     seed: u32,
diff --git a/examples/3d/reflection_probes.rs b/examples/3d/reflection_probes.rs
index 6b2db9d39ca2c..75094bb57fd01 100644
--- a/examples/3d/reflection_probes.rs
+++ b/examples/3d/reflection_probes.rs
@@ -1,12 +1,22 @@
 //! This example shows how to place reflection probes in the scene.
 //!
-//! Press Space to switch between no reflections, environment map reflections
-//! (i.e. the skybox only, not the cubes), and a full reflection probe that
-//! reflects the skybox and the cubes. Press Enter to pause rotation.
+//! Press Space to cycle through the reflection modes:
+//!
+//! 1. A pre-generated [`EnvironmentMapLight`] acting as a reflection probe, with both the skybox and cubes
+//! 2. A runtime-generated [`GeneratedEnvironmentMapLight`] acting as a reflection probe with just the skybox
+//! 3. A pre-generated [`EnvironmentMapLight`] with just the skybox
+//!
+//! Press Enter to pause or resume rotation.
 //!
 //! Reflection probes don't work on WebGL 2 or WebGPU.
 
-use bevy::{core_pipeline::Skybox, prelude::*, render::view::Hdr};
+use bevy::{
+    camera::Exposure,
+    core_pipeline::{tonemapping::Tonemapping, Skybox},
+    pbr::generate::generate_environment_map_light,
+    prelude::*,
+    render::{render_resource::TextureUsages, view::Hdr},
+};
 
 use std::{
     f32::consts::PI,
@@ -25,37 +35,33 @@ struct AppStatus {
     reflection_mode: ReflectionMode,
     // Whether the user has requested the scene to rotate.
     rotating: bool,
+    // The current roughness of the central sphere
+    sphere_roughness: f32,
 }
 
 // Which environment maps the user has requested to display.
-#[derive(Clone, Copy)]
+#[derive(Clone, Copy, PartialEq)]
 enum ReflectionMode {
-    // No environment maps are shown.
-    None = 0,
     // Only a world environment map is shown.
-    EnvironmentMap = 1,
+    EnvironmentMap = 0,
     // Both a world environment map and a reflection probe are present. The
     // reflection probe is shown in the sphere.
-    ReflectionProbe = 2,
+    ReflectionProbe = 1,
+    // A generated environment map is shown.
+    GeneratedEnvironmentMap = 2,
 }
 
 // The various reflection maps.
 #[derive(Resource)]
 struct Cubemaps {
-    // The blurry diffuse cubemap. This is used for both the world environment
-    // map and the reflection probe. (In reality you wouldn't do this, but this
-    // reduces complexity of this example a bit.)
-    diffuse: Handle<Image>,
+    // The blurry diffuse cubemap that reflects the world, but not the cubes.
+    diffuse_environment_map: Handle<Image>,
 
-    // The specular cubemap that reflects the world, but not the cubes.
+    // The specular cubemap mip chain that reflects the world, but not the cubes.
     specular_environment_map: Handle<Image>,
 
-    // The specular cubemap that reflects both the world and the cubes.
+    // The specular cubemap mip chain that reflects both the world and the cubes.
     specular_reflection_probe: Handle<Image>,
-
-    // The skybox cubemap image. This is almost the same as
-    // `specular_environment_map`.
-    skybox: Handle<Image>,
 }
 
 fn main() {
@@ -66,8 +72,12 @@ fn main() {
         .init_resource::<Cubemaps>()
         .add_systems(Startup, setup)
         .add_systems(PreUpdate, add_environment_map_to_camera)
-        .add_systems(Update, change_reflection_type)
+        .add_systems(
+            Update,
+            change_reflection_type.before(generate_environment_map_light),
+        )
         .add_systems(Update, toggle_rotation)
+        .add_systems(Update, change_sphere_roughness)
         .add_systems(
             Update,
             rotate_camera
@@ -75,6 +85,7 @@ fn main() {
                 .after(change_reflection_type),
         )
         .add_systems(Update, update_text.after(rotate_camera))
+        .add_systems(Update, setup_environment_map_usage)
         .run();
 }
 
@@ -87,17 +98,18 @@ fn setup(
     app_status: Res<AppStatus>,
     cubemaps: Res<Cubemaps>,
 ) {
-    spawn_scene(&mut commands, &asset_server);
     spawn_camera(&mut commands);
-    spawn_sphere(&mut commands, &mut meshes, &mut materials);
+    spawn_sphere(&mut commands, &mut meshes, &mut materials, &app_status);
     spawn_reflection_probe(&mut commands, &cubemaps);
+    spawn_scene(&mut commands, &asset_server);
     spawn_text(&mut commands, &app_status);
 }
 
 // Spawns the cubes, light, and camera.
 fn spawn_scene(commands: &mut Commands, asset_server: &AssetServer) {
-    commands.spawn(SceneRoot(
-        asset_server.load(GltfAssetLabel::Scene(0).from_asset("models/cubes/Cubes.glb")),
+    commands.spawn((
+        SceneRoot(asset_server.load(GltfAssetLabel::Scene(0).from_asset("models/cubes/Cubes.glb"))),
+        CubesScene,
     ));
 }
 
@@ -105,8 +117,10 @@ fn spawn_scene(commands: &mut Commands, asset_server: &AssetServer) {
 fn spawn_camera(commands: &mut Commands) {
     commands.spawn((
         Camera3d::default(),
-        Transform::from_xyz(-6.483, 0.325, 4.381).looking_at(Vec3::ZERO, Vec3::Y),
         Hdr,
+        Exposure { ev100: 11.0 },
+        Tonemapping::AcesFitted,
+        Transform::from_xyz(-3.883, 0.325, 2.781).looking_at(Vec3::ZERO, Vec3::Y),
     ));
 }
 
@@ -115,6 +129,7 @@ fn spawn_sphere(
     commands: &mut Commands,
     meshes: &mut Assets<Mesh>,
     materials: &mut Assets<StandardMaterial>,
+    app_status: &AppStatus,
 ) {
     // Create a sphere mesh.
     let sphere_mesh = meshes.add(Sphere::new(1.0).mesh().ico(7).unwrap());
@@ -123,11 +138,12 @@ fn spawn_sphere(
     commands.spawn((
         Mesh3d(sphere_mesh.clone()),
         MeshMaterial3d(materials.add(StandardMaterial {
-            base_color: Srgba::hex("#ffd891").unwrap().into(),
+            base_color: Srgba::hex("#ffffff").unwrap().into(),
             metallic: 1.0,
-            perceptual_roughness: 0.0,
+            perceptual_roughness: app_status.sphere_roughness,
             ..StandardMaterial::default()
         })),
+        SphereMaterial,
     ));
 }
 
@@ -136,7 +152,7 @@ fn spawn_reflection_probe(commands: &mut Commands, cubemaps: &Cubemaps) {
     commands.spawn((
         LightProbe,
         EnvironmentMapLight {
-            diffuse_map: cubemaps.diffuse.clone(),
+            diffuse_map: cubemaps.diffuse_environment_map.clone(),
             specular_map: cubemaps.specular_reflection_probe.clone(),
             intensity: 5000.0,
             ..default()
@@ -173,7 +189,7 @@ fn add_environment_map_to_camera(
             .entity(camera_entity)
             .insert(create_camera_environment_map_light(&cubemaps))
             .insert(Skybox {
-                image: cubemaps.skybox.clone(),
+                image: cubemaps.specular_environment_map.clone(),
                 brightness: 5000.0,
                 ..default()
             });
@@ -184,40 +200,65 @@ fn add_environment_map_to_camera(
 fn change_reflection_type(
     mut commands: Commands,
     light_probe_query: Query<Entity, With<LightProbe>>,
+    cubes_scene_query: Query<Entity, With<CubesScene>>,
     camera_query: Query<Entity, With<Camera3d>>,
     keyboard: Res<ButtonInput<KeyCode>>,
     mut app_status: ResMut<AppStatus>,
     cubemaps: Res<Cubemaps>,
+    asset_server: Res<AssetServer>,
 ) {
     // Only do anything if space was pressed.
     if !keyboard.just_pressed(KeyCode::Space) {
         return;
     }
 
-    // Switch reflection mode.
+    // Advance to the next reflection mode.
     app_status.reflection_mode =
         ReflectionMode::try_from((app_status.reflection_mode as u32 + 1) % 3).unwrap();
 
-    // Add or remove the light probe.
+    // Remove light probes
     for light_probe in light_probe_query.iter() {
         commands.entity(light_probe).despawn();
     }
+    // Remove existing cube scenes
+    for scene_entity in cubes_scene_query.iter() {
+        commands.entity(scene_entity).despawn();
+    }
     match app_status.reflection_mode {
-        ReflectionMode::None | ReflectionMode::EnvironmentMap => {}
-        ReflectionMode::ReflectionProbe => spawn_reflection_probe(&mut commands, &cubemaps),
+        ReflectionMode::EnvironmentMap | ReflectionMode::GeneratedEnvironmentMap => {}
+        ReflectionMode::ReflectionProbe => {
+            spawn_reflection_probe(&mut commands, &cubemaps);
+            spawn_scene(&mut commands, &asset_server);
+        }
     }
 
-    // Add or remove the environment map from the camera.
+    // Update the environment-map components on the camera entity/entities
     for camera in camera_query.iter() {
+        // Remove any existing environment-map components
+        commands
+            .entity(camera)
+            .remove::<(EnvironmentMapLight, GeneratedEnvironmentMapLight)>();
+
         match app_status.reflection_mode {
-            ReflectionMode::None => {
-                commands.entity(camera).remove::<EnvironmentMapLight>();
-            }
+            // A baked or reflection-probe environment map
             ReflectionMode::EnvironmentMap | ReflectionMode::ReflectionProbe => {
                 commands
                     .entity(camera)
                     .insert(create_camera_environment_map_light(&cubemaps));
             }
+
+            // GPU-filtered environment map generated at runtime
+            ReflectionMode::GeneratedEnvironmentMap => {
+                commands
+                    .entity(camera)
+                    .insert(GeneratedEnvironmentMapLight {
+                        environment_map: cubemaps.specular_environment_map.clone(),
+                        // compensate for the energy loss of the reverse tonemapping
+                        // during filtering by using a higher intensity
+                        intensity: 5000.0,
+                        ..default()
+                    });
+            }
         }
     }
 }
@@ -241,9 +282,9 @@ impl TryFrom<u32> for ReflectionMode {
 
     fn try_from(value: u32) -> Result<Self, Self::Error> {
         match value {
-            0 => Ok(ReflectionMode::None),
-            1 => Ok(ReflectionMode::EnvironmentMap),
-            2 => Ok(ReflectionMode::ReflectionProbe),
+            0 => Ok(ReflectionMode::EnvironmentMap),
+            1 => Ok(ReflectionMode::ReflectionProbe),
+            2 => Ok(ReflectionMode::GeneratedEnvironmentMap),
             _ => Err(()),
         }
     }
@@ -252,9 +293,9 @@ impl TryFrom<u32> for ReflectionMode {
 impl Display for ReflectionMode {
     fn fmt(&self, formatter: &mut Formatter<'_>) -> FmtResult {
         let text = match *self {
-            ReflectionMode::None => "No reflections",
             ReflectionMode::EnvironmentMap => "Environment map",
             ReflectionMode::ReflectionProbe => "Reflection probe",
+            ReflectionMode::GeneratedEnvironmentMap => "Generated environment map",
         };
         formatter.write_str(text)
     }
@@ -271,8 +312,11 @@ impl AppStatus {
         };
 
         format!(
-            "{}\n{}\n{}",
-            self.reflection_mode, rotation_help_text, REFLECTION_MODE_HELP_TEXT
+            "{}\n{}\nRoughness: {:.2}\n{}\nUp/Down arrows to change roughness",
+            self.reflection_mode,
+            rotation_help_text,
+            self.sphere_roughness,
+            REFLECTION_MODE_HELP_TEXT
         )
         .into()
     }
@@ -282,7 +326,7 @@ impl AppStatus {
 // probe is applicable to a mesh.
 fn create_camera_environment_map_light(cubemaps: &Cubemaps) -> EnvironmentMapLight {
     EnvironmentMapLight {
-        diffuse_map: cubemaps.diffuse.clone(),
+        diffuse_map: cubemaps.diffuse_environment_map.clone(),
         specular_map: cubemaps.specular_environment_map.clone(),
         intensity: 5000.0,
         ..default()
@@ -311,17 +355,25 @@ fn rotate_camera(
 // Loads the cubemaps from the assets directory.
 impl FromWorld for Cubemaps {
     fn from_world(world: &mut World) -> Self {
-        // Just use the specular map for the skybox since it's not too blurry.
-        // In reality you wouldn't do this--you'd use a real skybox texture--but
-        // reusing the textures like this saves space in the Bevy repository.
-        let specular_map = world.load_asset("environment_maps/pisa_specular_rgb9e5_zstd.ktx2");
-
         Cubemaps {
-            diffuse: world.load_asset("environment_maps/pisa_diffuse_rgb9e5_zstd.ktx2"),
+            diffuse_environment_map: world
+                .load_asset("environment_maps/pisa_diffuse_rgb9e5_zstd.ktx2"),
+            specular_environment_map: world
+                .load_asset("environment_maps/pisa_specular_rgb9e5_zstd.ktx2"),
             specular_reflection_probe: world
                 .load_asset("environment_maps/cubes_reflection_probe_specular_rgb9e5_zstd.ktx2"),
-            specular_environment_map: specular_map.clone(),
-            skybox: specular_map,
+        }
+    }
+}
+
+fn setup_environment_map_usage(cubemaps: Res<Cubemaps>, mut images: ResMut<Assets<Image>>) {
+    if let Some(image) = images.get_mut(&cubemaps.specular_environment_map) {
+        if !image
+            .texture_descriptor
+            .usage
+            .contains(TextureUsages::COPY_SRC)
+        {
+            image.texture_descriptor.usage |= TextureUsages::COPY_SRC;
         }
     }
 }
@@ -330,7 +382,43 @@ impl Default for AppStatus {
     fn default() -> Self {
         Self {
             reflection_mode: ReflectionMode::ReflectionProbe,
-            rotating: true,
+            rotating: false,
+            sphere_roughness: 0.2,
+        }
+    }
+}
+
+#[derive(Component)]
+struct SphereMaterial;
+
+#[derive(Component)]
+struct CubesScene;
+
+// A system that changes the sphere's roughness with up/down arrow keys
+fn change_sphere_roughness(
+    keyboard: Res<ButtonInput<KeyCode>>,
+    mut app_status: ResMut<AppStatus>,
+    mut materials: ResMut<Assets<StandardMaterial>>,
+    sphere_query: Query<&MeshMaterial3d<StandardMaterial>, With<SphereMaterial>>,
+) {
+    let roughness_delta = if keyboard.pressed(KeyCode::ArrowUp) {
+        0.01 // Decrease roughness
+    } else if keyboard.pressed(KeyCode::ArrowDown) {
+        -0.01 // Increase roughness
+    } else {
+        0.0 // No change
+    };
+
+    if roughness_delta != 0.0 {
+        // Update the app status
+        app_status.sphere_roughness =
+            (app_status.sphere_roughness + roughness_delta).clamp(0.0, 1.0);
+
+        // Update the sphere material
+        for material_handle in sphere_query.iter() {
+            if let Some(material) = materials.get_mut(&material_handle.0) {
+                material.perceptual_roughness = app_status.sphere_roughness;
+            }
         }
     }
 }
diff --git a/release-content/release-notes/realtime-environment-map-filtering.md b/release-content/release-notes/realtime-environment-map-filtering.md
new file mode 100644
index 0000000000000..e608df3095150
--- /dev/null
+++ b/release-content/release-notes/realtime-environment-map-filtering.md
@@ -0,0 +1,23 @@
+---
+title: Realtime-filtered environment maps
+authors: ["@mate-h"]
+pull_requests: [19076]
+---
+
+An environment map needs to be processed to be able to support uses beyond a simple skybox,
+such as reflections at different roughness levels, and ambient light contribution.
+This process is called filtering, and can either be done ahead of time (prefiltering), or
+in realtime, although at a reduced quality.
+
+Bevy already supported prefiltering, but its not always possible to prefilter: sometimes,
+you only gain access to an environment map at runtime, for whatever reason.
+Typically this is from realtime reflection probes, but can also be from other sources
+for example, from a procedural skybox.
+
+Now, Bevy supports both modes of filtering!
+Adding a `GeneratedEnvironmentMapLight` to a `Camera` entity lets you use any environment map
+with Bevy's renderer, and enjoy all the benefits of prefiltering with none of the asset processing.
+
+(TODO: Embed screenshot of realtime filtering)
+
+Special thanks to @JMS55 for the feedback and @atlv24 for contributing and helping the PR get over the finish line!
