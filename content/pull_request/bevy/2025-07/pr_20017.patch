diff --git a/benches/benches/bevy_ecs/events/iter.rs b/benches/benches/bevy_ecs/events/iter.rs
index 9ad17ed8c8536..5f85633312c43 100644
--- a/benches/benches/bevy_ecs/events/iter.rs
+++ b/benches/benches/bevy_ecs/events/iter.rs
@@ -10,7 +10,7 @@ impl<const SIZE: usize> Benchmark<SIZE> {
         let mut events = Events::default();
 
         for _ in 0..count {
-            events.send(BenchEvent([0u8; SIZE]));
+            events.write(BenchEvent([0u8; SIZE]));
         }
 
         Self(events)
diff --git a/benches/benches/bevy_ecs/events/mod.rs b/benches/benches/bevy_ecs/events/mod.rs
index c2c7f3ee28056..fcc807c96856d 100644
--- a/benches/benches/bevy_ecs/events/mod.rs
+++ b/benches/benches/bevy_ecs/events/mod.rs
@@ -1,5 +1,5 @@
 mod iter;
-mod send;
+mod write;
 
 use criterion::{criterion_group, Criterion};
 
@@ -11,19 +11,19 @@ fn send(c: &mut Criterion) {
     group.measurement_time(core::time::Duration::from_secs(4));
     for count in [100, 1_000, 10_000] {
         group.bench_function(format!("size_4_events_{count}"), |b| {
-            let mut bench = send::Benchmark::<4>::new(count);
+            let mut bench = write::Benchmark::<4>::new(count);
             b.iter(move || bench.run());
         });
     }
     for count in [100, 1_000, 10_000] {
         group.bench_function(format!("size_16_events_{count}"), |b| {
-            let mut bench = send::Benchmark::<16>::new(count);
+            let mut bench = write::Benchmark::<16>::new(count);
             b.iter(move || bench.run());
         });
     }
     for count in [100, 1_000, 10_000] {
         group.bench_function(format!("size_512_events_{count}"), |b| {
-            let mut bench = send::Benchmark::<512>::new(count);
+            let mut bench = write::Benchmark::<512>::new(count);
             b.iter(move || bench.run());
         });
     }
diff --git a/benches/benches/bevy_ecs/events/send.rs b/benches/benches/bevy_ecs/events/write.rs
similarity index 86%
rename from benches/benches/bevy_ecs/events/send.rs
rename to benches/benches/bevy_ecs/events/write.rs
index be8934e789152..8095aee738677 100644
--- a/benches/benches/bevy_ecs/events/send.rs
+++ b/benches/benches/bevy_ecs/events/write.rs
@@ -21,7 +21,7 @@ impl<const SIZE: usize> Benchmark<SIZE> {
         // Force both internal buffers to be allocated.
         for _ in 0..2 {
             for _ in 0..count {
-                events.send(BenchEvent([0u8; SIZE]));
+                events.write(BenchEvent([0u8; SIZE]));
             }
             events.update();
         }
@@ -32,7 +32,7 @@ impl<const SIZE: usize> Benchmark<SIZE> {
     pub fn run(&mut self) {
         for _ in 0..self.count {
             self.events
-                .send(core::hint::black_box(BenchEvent([0u8; SIZE])));
+                .write(core::hint::black_box(BenchEvent([0u8; SIZE])));
         }
         self.events.update();
     }
diff --git a/crates/bevy_app/src/app.rs b/crates/bevy_app/src/app.rs
index 05f3de27b116f..a9057c787dc53 100644
--- a/crates/bevy_app/src/app.rs
+++ b/crates/bevy_app/src/app.rs
@@ -1864,7 +1864,7 @@ mod tests {
         app.update();
 
         // Sending one event
-        app.world_mut().send_event(TestEvent);
+        app.world_mut().write_event(TestEvent);
 
         let test_events = app.world().resource::<Events<TestEvent>>();
         assert_eq!(test_events.len(), 1);
@@ -1872,8 +1872,8 @@ mod tests {
         app.update();
 
         // Sending two events on the next frame
-        app.world_mut().send_event(TestEvent);
-        app.world_mut().send_event(TestEvent);
+        app.world_mut().write_event(TestEvent);
+        app.world_mut().write_event(TestEvent);
 
         let test_events = app.world().resource::<Events<TestEvent>>();
         assert_eq!(test_events.len(), 3); // Events are double-buffered, so we see 1 + 2 = 3
diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs
index 0b64fe74e0afb..69dc8428da87d 100644
--- a/crates/bevy_asset/src/server/mod.rs
+++ b/crates/bevy_asset/src/server/mod.rs
@@ -167,7 +167,7 @@ impl AssetServer {
         fn sender<A: Asset>(world: &mut World, id: UntypedAssetId) {
             world
                 .resource_mut::<Events<AssetEvent<A>>>()
-                .send(AssetEvent::LoadedWithDependencies { id: id.typed() });
+                .write(AssetEvent::LoadedWithDependencies { id: id.typed() });
         }
         fn failed_sender<A: Asset>(
             world: &mut World,
@@ -177,7 +177,7 @@ impl AssetServer {
         ) {
             world
                 .resource_mut::<Events<AssetLoadFailedEvent<A>>>()
-                .send(AssetLoadFailedEvent {
+                .write(AssetLoadFailedEvent {
                     id: id.typed(),
                     path,
                     error,
@@ -1685,7 +1685,7 @@ pub fn handle_internal_asset_events(world: &mut World) {
         }
 
         if !untyped_failures.is_empty() {
-            world.send_event_batch(untyped_failures);
+            world.write_event_batch(untyped_failures);
         }
 
         fn queue_ancestors(
diff --git a/crates/bevy_dev_tools/src/ci_testing/systems.rs b/crates/bevy_dev_tools/src/ci_testing/systems.rs
index ae7a2a774e44e..8e0b502aa095d 100644
--- a/crates/bevy_dev_tools/src/ci_testing/systems.rs
+++ b/crates/bevy_dev_tools/src/ci_testing/systems.rs
@@ -18,7 +18,7 @@ pub(crate) fn send_events(world: &mut World, mut current_frame: Local<u32>) {
         debug!("Handling event: {:?}", event);
         match event {
             CiTestingEvent::AppExit => {
-                world.send_event(AppExit::Success);
+                world.write_event(AppExit::Success);
                 info!("Exiting after {} frames. Test successful!", *current_frame);
             }
             CiTestingEvent::ScreenshotAndExit => {
@@ -53,7 +53,7 @@ pub(crate) fn send_events(world: &mut World, mut current_frame: Local<u32>) {
             }
             // Custom events are forwarded to the world.
             CiTestingEvent::Custom(event_string) => {
-                world.send_event(CiTestingCustomEvent(event_string));
+                world.write_event(CiTestingCustomEvent(event_string));
             }
         }
     }
diff --git a/crates/bevy_ecs/src/bundle.rs b/crates/bevy_ecs/src/bundle.rs
index 78948f81b1d5e..75c2c89ff852b 100644
--- a/crates/bevy_ecs/src/bundle.rs
+++ b/crates/bevy_ecs/src/bundle.rs
@@ -1584,7 +1584,7 @@ impl<'w> BundleRemover<'w> {
         // Handle sparse set removes
         for component_id in self.bundle_info.as_ref().iter_explicit_components() {
             if self.old_archetype.as_ref().contains(component_id) {
-                world.removed_components.send(component_id, entity);
+                world.removed_components.write(component_id, entity);
 
                 // Make sure to drop components stored in sparse sets.
                 // Dense components are dropped later in `move_to_and_drop_missing_unchecked`.
diff --git a/crates/bevy_ecs/src/event/collections.rs b/crates/bevy_ecs/src/event/collections.rs
index 7d1854149ecbe..5175efb03ae4c 100644
--- a/crates/bevy_ecs/src/event/collections.rs
+++ b/crates/bevy_ecs/src/event/collections.rs
@@ -54,8 +54,8 @@ use {
 /// // run this once per update/frame
 /// events.update();
 ///
-/// // somewhere else: send an event
-/// events.send(MyEvent { value: 1 });
+/// // somewhere else: write an event
+/// events.write(MyEvent { value: 1 });
 ///
 /// // somewhere else: read the events
 /// for event in cursor.read(&events) {
@@ -118,22 +118,22 @@ impl<E: BufferedEvent> Events<E> {
         self.events_a.start_event_count
     }
 
-    /// "Sends" an `event` by writing it to the current event buffer.
+    /// Writes an `event` to the current event buffer.
     /// [`EventReader`](super::EventReader)s can then read the event.
-    /// This method returns the [ID](`EventId`) of the sent `event`.
+    /// This method returns the [ID](`EventId`) of the written `event`.
     #[track_caller]
-    pub fn send(&mut self, event: E) -> EventId<E> {
-        self.send_with_caller(event, MaybeLocation::caller())
+    pub fn write(&mut self, event: E) -> EventId<E> {
+        self.write_with_caller(event, MaybeLocation::caller())
     }
 
-    pub(crate) fn send_with_caller(&mut self, event: E, caller: MaybeLocation) -> EventId<E> {
+    pub(crate) fn write_with_caller(&mut self, event: E, caller: MaybeLocation) -> EventId<E> {
         let event_id = EventId {
             id: self.event_count,
             caller,
             _marker: PhantomData,
         };
         #[cfg(feature = "detailed_trace")]
-        tracing::trace!("Events::send() -> id: {}", event_id);
+        tracing::trace!("Events::write() -> id: {}", event_id);
 
         let event_instance = EventInstance { event_id, event };
 
@@ -143,30 +143,59 @@ impl<E: BufferedEvent> Events<E> {
         event_id
     }
 
-    /// Sends a list of `events` all at once, which can later be read by [`EventReader`](super::EventReader)s.
-    /// This is more efficient than sending each event individually.
-    /// This method returns the [IDs](`EventId`) of the sent `events`.
+    /// Writes a list of `events` all at once, which can later be read by [`EventReader`](super::EventReader)s.
+    /// This is more efficient than writing each event individually.
+    /// This method returns the [IDs](`EventId`) of the written `events`.
     #[track_caller]
-    pub fn send_batch(&mut self, events: impl IntoIterator<Item = E>) -> SendBatchIds<E> {
+    pub fn write_batch(&mut self, events: impl IntoIterator<Item = E>) -> WriteBatchIds<E> {
         let last_count = self.event_count;
 
         self.extend(events);
 
-        SendBatchIds {
+        WriteBatchIds {
             last_count,
             event_count: self.event_count,
             _marker: PhantomData,
         }
     }
 
+    /// Writes the default value of the event. Useful when the event is an empty struct.
+    /// This method returns the [ID](`EventId`) of the written `event`.
+    #[track_caller]
+    pub fn write_default(&mut self) -> EventId<E>
+    where
+        E: Default,
+    {
+        self.write(Default::default())
+    }
+
+    /// "Sends" an `event` by writing it to the current event buffer.
+    /// [`EventReader`](super::EventReader)s can then read the event.
+    /// This method returns the [ID](`EventId`) of the sent `event`.
+    #[deprecated(since = "0.17.0", note = "Use `Events<E>::write` instead.")]
+    #[track_caller]
+    pub fn send(&mut self, event: E) -> EventId<E> {
+        self.write(event)
+    }
+
+    /// Sends a list of `events` all at once, which can later be read by [`EventReader`](super::EventReader)s.
+    /// This is more efficient than sending each event individually.
+    /// This method returns the [IDs](`EventId`) of the sent `events`.
+    #[deprecated(since = "0.17.0", note = "Use `Events<E>::write_batch` instead.")]
+    #[track_caller]
+    pub fn send_batch(&mut self, events: impl IntoIterator<Item = E>) -> WriteBatchIds<E> {
+        self.write_batch(events)
+    }
+
     /// Sends the default value of the event. Useful when the event is an empty struct.
     /// This method returns the [ID](`EventId`) of the sent `event`.
+    #[deprecated(since = "0.17.0", note = "Use `Events<E>::write_default` instead.")]
     #[track_caller]
     pub fn send_default(&mut self) -> EventId<E>
     where
         E: Default,
     {
-        self.send(Default::default())
+        self.write_default()
     }
 
     /// Gets a new [`EventCursor`]. This will include all events already in the event buffers.
@@ -351,14 +380,18 @@ impl<E: BufferedEvent> DerefMut for EventSequence<E> {
     }
 }
 
-/// [`Iterator`] over sent [`EventIds`](`EventId`) from a batch.
-pub struct SendBatchIds<E> {
+/// [`Iterator`] over written [`EventIds`](`EventId`) from a batch.
+pub struct WriteBatchIds<E> {
     last_count: usize,
     event_count: usize,
     _marker: PhantomData<E>,
 }
 
-impl<E: BufferedEvent> Iterator for SendBatchIds<E> {
+/// [`Iterator`] over sent [`EventIds`](`EventId`) from a batch.
+#[deprecated(since = "0.17.0", note = "Use `WriteBatchIds` instead.")]
+pub type SendBatchIds<E> = WriteBatchIds<E>;
+
+impl<E: BufferedEvent> Iterator for WriteBatchIds<E> {
     type Item = EventId<E>;
 
     fn next(&mut self) -> Option<Self::Item> {
@@ -378,7 +411,7 @@ impl<E: BufferedEvent> Iterator for SendBatchIds<E> {
     }
 }
 
-impl<E: BufferedEvent> ExactSizeIterator for SendBatchIds<E> {
+impl<E: BufferedEvent> ExactSizeIterator for WriteBatchIds<E> {
     fn len(&self) -> usize {
         self.event_count.saturating_sub(self.last_count)
     }
@@ -400,22 +433,22 @@ mod tests {
         assert_eq!(test_events.iter_current_update_events().count(), 0);
         test_events.update();
 
-        // Sending one event
-        test_events.send(TestEvent);
+        // Writing one event
+        test_events.write(TestEvent);
 
         assert_eq!(test_events.len(), 1);
         assert_eq!(test_events.iter_current_update_events().count(), 1);
         test_events.update();
 
-        // Sending two events on the next frame
-        test_events.send(TestEvent);
-        test_events.send(TestEvent);
+        // Writing two events on the next frame
+        test_events.write(TestEvent);
+        test_events.write(TestEvent);
 
         assert_eq!(test_events.len(), 3); // Events are double-buffered, so we see 1 + 2 = 3
         assert_eq!(test_events.iter_current_update_events().count(), 2);
         test_events.update();
 
-        // Sending zero events
+        // Writing zero events
         assert_eq!(test_events.len(), 2); // Events are double-buffered, so we see 2 + 0 = 2
         assert_eq!(test_events.iter_current_update_events().count(), 0);
     }
diff --git a/crates/bevy_ecs/src/event/event_cursor.rs b/crates/bevy_ecs/src/event/event_cursor.rs
index 70e19a732c3df..f0460a942410e 100644
--- a/crates/bevy_ecs/src/event/event_cursor.rs
+++ b/crates/bevy_ecs/src/event/event_cursor.rs
@@ -41,7 +41,7 @@ use core::marker::PhantomData;
 ///     }
 ///
 ///     for event in events_to_resend {
-///         events.send(MyEvent);
+///         events.write(MyEvent);
 ///     }
 /// }
 ///
diff --git a/crates/bevy_ecs/src/event/mod.rs b/crates/bevy_ecs/src/event/mod.rs
index ec930cd269eee..77741a47abc62 100644
--- a/crates/bevy_ecs/src/event/mod.rs
+++ b/crates/bevy_ecs/src/event/mod.rs
@@ -13,7 +13,8 @@ mod writer;
 pub(crate) use base::EventInstance;
 pub use base::{BufferedEvent, EntityEvent, Event, EventId, EventKey};
 pub use bevy_ecs_macros::{BufferedEvent, EntityEvent, Event};
-pub use collections::{Events, SendBatchIds};
+#[expect(deprecated, reason = "`SendBatchIds` was renamed to `WriteBatchIds`.")]
+pub use collections::{Events, SendBatchIds, WriteBatchIds};
 pub use event_cursor::EventCursor;
 #[cfg(feature = "multi_threaded")]
 pub use iterators::EventParIter;
@@ -68,7 +69,7 @@ mod tests {
 
         let mut reader_a: EventCursor<TestEvent> = events.get_cursor();
 
-        events.send(event_0);
+        events.write(event_0);
 
         assert_eq!(
             get_events(&events, &mut reader_a),
@@ -94,7 +95,7 @@ mod tests {
             "second iteration of reader_b created after event results in zero events"
         );
 
-        events.send(event_1);
+        events.write(event_1);
 
         let mut reader_c = events.get_cursor();
 
@@ -119,7 +120,7 @@ mod tests {
 
         let mut reader_d = events.get_cursor();
 
-        events.send(event_2);
+        events.write(event_2);
 
         assert_eq!(
             get_events(&events, &mut reader_a),
@@ -153,17 +154,17 @@ mod tests {
 
         assert!(reader.read(&events).next().is_none());
 
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         assert_eq!(*reader.read(&events).next().unwrap(), TestEvent { i: 0 });
         assert_eq!(reader.read(&events).next(), None);
 
-        events.send(TestEvent { i: 1 });
+        events.write(TestEvent { i: 1 });
         clear_func(&mut events);
         assert!(reader.read(&events).next().is_none());
 
-        events.send(TestEvent { i: 2 });
+        events.write(TestEvent { i: 2 });
         events.update();
-        events.send(TestEvent { i: 3 });
+        events.write(TestEvent { i: 3 });
 
         assert!(reader
             .read(&events)
@@ -185,22 +186,22 @@ mod tests {
     }
 
     #[test]
-    fn test_events_send_default() {
+    fn test_events_write_default() {
         let mut events = Events::<EmptyTestEvent>::default();
-        events.send_default();
+        events.write_default();
 
         let mut reader = events.get_cursor();
         assert_eq!(get_events(&events, &mut reader), vec![EmptyTestEvent]);
     }
 
     #[test]
-    fn test_send_events_ids() {
+    fn test_write_events_ids() {
         let mut events = Events::<TestEvent>::default();
         let event_0 = TestEvent { i: 0 };
         let event_1 = TestEvent { i: 1 };
         let event_2 = TestEvent { i: 2 };
 
-        let event_0_id = events.send(event_0);
+        let event_0_id = events.write(event_0);
 
         assert_eq!(
             events.get_event(event_0_id.id),
@@ -208,7 +209,7 @@ mod tests {
             "Getting a sent event by ID should return the original event"
         );
 
-        let mut event_ids = events.send_batch([event_1, event_2]);
+        let mut event_ids = events.write_batch([event_1, event_2]);
 
         let event_id = event_ids.next().expect("Event 1 must have been sent");
 
@@ -253,14 +254,14 @@ mod tests {
         let mut events = Events::<TestEvent>::default();
         let mut reader = events.get_cursor();
 
-        events.send(TestEvent { i: 0 });
-        events.send(TestEvent { i: 1 });
+        events.write(TestEvent { i: 0 });
+        events.write(TestEvent { i: 1 });
         assert_eq!(reader.read(&events).count(), 2);
 
         let mut old_events = Vec::from_iter(events.update_drain());
         assert!(old_events.is_empty());
 
-        events.send(TestEvent { i: 2 });
+        events.write(TestEvent { i: 2 });
         assert_eq!(reader.read(&events).count(), 1);
 
         old_events.extend(events.update_drain());
@@ -278,7 +279,7 @@ mod tests {
         let mut events = Events::<TestEvent>::default();
         assert!(events.is_empty());
 
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         assert!(!events.is_empty());
 
         events.update();
@@ -308,12 +309,12 @@ mod tests {
         let mut cursor = events.get_cursor();
         assert!(cursor.read(&events).next().is_none());
 
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         let sent_event = cursor.read(&events).next().unwrap();
         assert_eq!(sent_event, &TestEvent { i: 0 });
         assert!(cursor.read(&events).next().is_none());
 
-        events.send(TestEvent { i: 2 });
+        events.write(TestEvent { i: 2 });
         let sent_event = cursor.read(&events).next().unwrap();
         assert_eq!(sent_event, &TestEvent { i: 2 });
         assert!(cursor.read(&events).next().is_none());
@@ -330,7 +331,7 @@ mod tests {
         assert!(write_cursor.read_mut(&mut events).next().is_none());
         assert!(read_cursor.read(&events).next().is_none());
 
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         let sent_event = write_cursor.read_mut(&mut events).next().unwrap();
         assert_eq!(sent_event, &mut TestEvent { i: 0 });
         *sent_event = TestEvent { i: 1 }; // Mutate whole event
@@ -340,7 +341,7 @@ mod tests {
         );
         assert!(read_cursor.read(&events).next().is_none());
 
-        events.send(TestEvent { i: 2 });
+        events.write(TestEvent { i: 2 });
         let sent_event = write_cursor.read_mut(&mut events).next().unwrap();
         assert_eq!(sent_event, &mut TestEvent { i: 2 });
         sent_event.i = 3; // Mutate sub value
@@ -360,7 +361,7 @@ mod tests {
         let mut events = Events::<TestEvent>::default();
         let mut reader = events.get_cursor();
 
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         assert_eq!(reader.len(&events), 1);
         reader.clear(&events);
         assert_eq!(reader.len(&events), 0);
@@ -369,12 +370,12 @@ mod tests {
     #[test]
     fn test_event_cursor_len_update() {
         let mut events = Events::<TestEvent>::default();
-        events.send(TestEvent { i: 0 });
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         let reader = events.get_cursor();
         assert_eq!(reader.len(&events), 2);
         events.update();
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         assert_eq!(reader.len(&events), 3);
         events.update();
         assert_eq!(reader.len(&events), 1);
@@ -385,10 +386,10 @@ mod tests {
     #[test]
     fn test_event_cursor_len_current() {
         let mut events = Events::<TestEvent>::default();
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         let reader = events.get_cursor_current();
         assert!(reader.is_empty(&events));
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         assert_eq!(reader.len(&events), 1);
         assert!(!reader.is_empty(&events));
     }
@@ -396,9 +397,9 @@ mod tests {
     #[test]
     fn test_event_cursor_iter_len_updated() {
         let mut events = Events::<TestEvent>::default();
-        events.send(TestEvent { i: 0 });
-        events.send(TestEvent { i: 1 });
-        events.send(TestEvent { i: 2 });
+        events.write(TestEvent { i: 0 });
+        events.write(TestEvent { i: 1 });
+        events.write(TestEvent { i: 2 });
         let mut reader = events.get_cursor();
         let mut iter = reader.read(&events);
         assert_eq!(iter.len(), 3);
@@ -420,7 +421,7 @@ mod tests {
     #[test]
     fn test_event_cursor_len_filled() {
         let mut events = Events::<TestEvent>::default();
-        events.send(TestEvent { i: 0 });
+        events.write(TestEvent { i: 0 });
         assert_eq!(events.get_cursor().len(&events), 1);
         assert!(!events.get_cursor().is_empty(&events));
     }
@@ -437,7 +438,7 @@ mod tests {
         let mut world = World::new();
         world.init_resource::<Events<TestEvent>>();
         for _ in 0..100 {
-            world.send_event(TestEvent { i: 1 });
+            world.write_event(TestEvent { i: 1 });
         }
 
         let mut schedule = Schedule::default();
@@ -479,7 +480,7 @@ mod tests {
         let mut world = World::new();
         world.init_resource::<Events<TestEvent>>();
         for _ in 0..100 {
-            world.send_event(TestEvent { i: 1 });
+            world.write_event(TestEvent { i: 1 });
         }
         let mut schedule = Schedule::default();
         schedule.add_systems(
@@ -531,13 +532,13 @@ mod tests {
         let last = reader.run((), &mut world).unwrap();
         assert!(last.is_none(), "EventReader should be empty");
 
-        world.send_event(TestEvent { i: 0 });
+        world.write_event(TestEvent { i: 0 });
         let last = reader.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 0 }));
 
-        world.send_event(TestEvent { i: 1 });
-        world.send_event(TestEvent { i: 2 });
-        world.send_event(TestEvent { i: 3 });
+        world.write_event(TestEvent { i: 1 });
+        world.write_event(TestEvent { i: 2 });
+        world.write_event(TestEvent { i: 3 });
         let last = reader.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 3 }));
 
@@ -561,13 +562,13 @@ mod tests {
         let last = mutator.run((), &mut world).unwrap();
         assert!(last.is_none(), "EventMutator should be empty");
 
-        world.send_event(TestEvent { i: 0 });
+        world.write_event(TestEvent { i: 0 });
         let last = mutator.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 0 }));
 
-        world.send_event(TestEvent { i: 1 });
-        world.send_event(TestEvent { i: 2 });
-        world.send_event(TestEvent { i: 3 });
+        world.write_event(TestEvent { i: 1 });
+        world.write_event(TestEvent { i: 2 });
+        world.write_event(TestEvent { i: 3 });
         let last = mutator.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 3 }));
 
@@ -582,11 +583,11 @@ mod tests {
         let mut world = World::new();
         world.init_resource::<Events<TestEvent>>();
 
-        world.send_event(TestEvent { i: 0 });
-        world.send_event(TestEvent { i: 1 });
-        world.send_event(TestEvent { i: 2 });
-        world.send_event(TestEvent { i: 3 });
-        world.send_event(TestEvent { i: 4 });
+        world.write_event(TestEvent { i: 0 });
+        world.write_event(TestEvent { i: 1 });
+        world.write_event(TestEvent { i: 2 });
+        world.write_event(TestEvent { i: 3 });
+        world.write_event(TestEvent { i: 4 });
 
         let mut schedule = Schedule::default();
         schedule.add_systems(|mut events: EventReader<TestEvent>| {
@@ -608,11 +609,11 @@ mod tests {
         let mut world = World::new();
         world.init_resource::<Events<TestEvent>>();
 
-        world.send_event(TestEvent { i: 0 });
-        world.send_event(TestEvent { i: 1 });
-        world.send_event(TestEvent { i: 2 });
-        world.send_event(TestEvent { i: 3 });
-        world.send_event(TestEvent { i: 4 });
+        world.write_event(TestEvent { i: 0 });
+        world.write_event(TestEvent { i: 1 });
+        world.write_event(TestEvent { i: 2 });
+        world.write_event(TestEvent { i: 3 });
+        world.write_event(TestEvent { i: 4 });
 
         let mut schedule = Schedule::default();
         schedule.add_systems(|mut events: EventReader<TestEvent>| {
diff --git a/crates/bevy_ecs/src/event/mutator.rs b/crates/bevy_ecs/src/event/mutator.rs
index a9c9459119b63..847cbf3e16ce9 100644
--- a/crates/bevy_ecs/src/event/mutator.rs
+++ b/crates/bevy_ecs/src/event/mutator.rs
@@ -89,7 +89,7 @@ impl<'w, 's, E: BufferedEvent> EventMutator<'w, 's, E> {
     ///     });
     /// });
     /// for value in 0..100 {
-    ///     world.send_event(MyEvent { value });
+    ///     world.write_event(MyEvent { value });
     /// }
     /// schedule.run(&mut world);
     /// let Counter(counter) = world.remove_resource::<Counter>().unwrap();
diff --git a/crates/bevy_ecs/src/event/reader.rs b/crates/bevy_ecs/src/event/reader.rs
index e15b3ea9e75d5..2e135eab2f7fe 100644
--- a/crates/bevy_ecs/src/event/reader.rs
+++ b/crates/bevy_ecs/src/event/reader.rs
@@ -61,7 +61,7 @@ impl<'w, 's, E: BufferedEvent> EventReader<'w, 's, E> {
     ///     });
     /// });
     /// for value in 0..100 {
-    ///     world.send_event(MyEvent { value });
+    ///     world.write_event(MyEvent { value });
     /// }
     /// schedule.run(&mut world);
     /// let Counter(counter) = world.remove_resource::<Counter>().unwrap();
diff --git a/crates/bevy_ecs/src/event/writer.rs b/crates/bevy_ecs/src/event/writer.rs
index 4c38401eb4567..015e59891c008 100644
--- a/crates/bevy_ecs/src/event/writer.rs
+++ b/crates/bevy_ecs/src/event/writer.rs
@@ -1,9 +1,9 @@
 use bevy_ecs::{
-    event::{BufferedEvent, EventId, Events, SendBatchIds},
+    event::{BufferedEvent, EventId, Events, WriteBatchIds},
     system::{ResMut, SystemParam},
 };
 
-/// Sends [`BufferedEvent`]s of type `T`.
+/// Writes [`BufferedEvent`]s of type `T`.
 ///
 /// # Usage
 ///
@@ -34,14 +34,14 @@ use bevy_ecs::{
 ///
 /// `EventWriter` can only write events of one specific type, which must be known at compile-time.
 /// This is not a problem most of the time, but you may find a situation where you cannot know
-/// ahead of time every kind of event you'll need to send. In this case, you can use the "type-erased event" pattern.
+/// ahead of time every kind of event you'll need to write. In this case, you can use the "type-erased event" pattern.
 ///
 /// ```
 /// # use bevy_ecs::{prelude::*, event::Events};
 /// # #[derive(Event, BufferedEvent)]
 /// # pub struct MyEvent;
-/// fn send_untyped(mut commands: Commands) {
-///     // Send an event of a specific type without having to declare that
+/// fn write_untyped(mut commands: Commands) {
+///     // Write an event of a specific type without having to declare that
 ///     // type as a SystemParam.
 ///     //
 ///     // Effectively, we're just moving the type parameter from the /type/ to the /method/,
@@ -51,7 +51,7 @@ use bevy_ecs::{
 ///     // NOTE: the event won't actually be sent until commands get applied during
 ///     // apply_deferred.
 ///     commands.queue(|w: &mut World| {
-///         w.send_event(MyEvent);
+///         w.write_event(MyEvent);
 ///     });
 /// }
 /// ```
@@ -72,18 +72,18 @@ impl<'w, E: BufferedEvent> EventWriter<'w, E> {
     #[doc(alias = "send")]
     #[track_caller]
     pub fn write(&mut self, event: E) -> EventId<E> {
-        self.events.send(event)
+        self.events.write(event)
     }
 
-    /// Sends a list of `events` all at once, which can later be read by [`EventReader`](super::EventReader)s.
-    /// This is more efficient than sending each event individually.
+    /// Writes a list of `events` all at once, which can later be read by [`EventReader`](super::EventReader)s.
+    /// This is more efficient than writing each event individually.
     /// This method returns the [IDs](`EventId`) of the written `events`.
     ///
     /// See [`Events`] for details.
     #[doc(alias = "send_batch")]
     #[track_caller]
-    pub fn write_batch(&mut self, events: impl IntoIterator<Item = E>) -> SendBatchIds<E> {
-        self.events.send_batch(events)
+    pub fn write_batch(&mut self, events: impl IntoIterator<Item = E>) -> WriteBatchIds<E> {
+        self.events.write_batch(events)
     }
 
     /// Writes the default value of the event. Useful when the event is an empty struct.
@@ -96,6 +96,6 @@ impl<'w, E: BufferedEvent> EventWriter<'w, E> {
     where
         E: Default,
     {
-        self.events.send_default()
+        self.events.write_default()
     }
 }
diff --git a/crates/bevy_ecs/src/lifecycle.rs b/crates/bevy_ecs/src/lifecycle.rs
index 08f178eda133e..7c3f1ffa4a7d5 100644
--- a/crates/bevy_ecs/src/lifecycle.rs
+++ b/crates/bevy_ecs/src/lifecycle.rs
@@ -465,10 +465,16 @@ impl RemovedComponentEvents {
     }
 
     /// Sends a removal event for the specified component.
+    #[deprecated(since = "0.17.0", note = "Use `RemovedComponentEvents:write` instead.")]
     pub fn send(&mut self, component_id: impl Into<ComponentId>, entity: Entity) {
+        self.write(component_id, entity);
+    }
+
+    /// Writes a removal event for the specified component.
+    pub fn write(&mut self, component_id: impl Into<ComponentId>, entity: Entity) {
         self.event_sets
             .get_or_insert_with(component_id.into(), Default::default)
-            .send(RemovedComponentEntity(entity));
+            .write(RemovedComponentEntity(entity));
     }
 }
 
diff --git a/crates/bevy_ecs/src/schedule/condition.rs b/crates/bevy_ecs/src/schedule/condition.rs
index 1a4a7a8101797..2cd71db9b4d53 100644
--- a/crates/bevy_ecs/src/schedule/condition.rs
+++ b/crates/bevy_ecs/src/schedule/condition.rs
@@ -875,7 +875,7 @@ pub mod common_conditions {
     /// app.run(&mut world);
     /// assert_eq!(world.resource::<Counter>().0, 0);
     ///
-    /// world.resource_mut::<Events<MyEvent>>().send(MyEvent);
+    /// world.resource_mut::<Events<MyEvent>>().write(MyEvent);
     ///
     /// // A `MyEvent` event has been pushed so `my_system` will run
     /// app.run(&mut world);
diff --git a/crates/bevy_ecs/src/system/commands/command.rs b/crates/bevy_ecs/src/system/commands/command.rs
index 164758cca8b3e..83dad342a803c 100644
--- a/crates/bevy_ecs/src/system/commands/command.rs
+++ b/crates/bevy_ecs/src/system/commands/command.rs
@@ -229,12 +229,19 @@ pub fn trigger_targets(
     }
 }
 
-/// A [`Command`] that sends an arbitrary [`BufferedEvent`].
+/// A [`Command`] that writes an arbitrary [`BufferedEvent`].
 #[track_caller]
-pub fn send_event<E: BufferedEvent>(event: E) -> impl Command {
+pub fn write_event<E: BufferedEvent>(event: E) -> impl Command {
     let caller = MaybeLocation::caller();
     move |world: &mut World| {
         let mut events = world.resource_mut::<Events<E>>();
-        events.send_with_caller(event, caller);
+        events.write_with_caller(event, caller);
     }
 }
+
+/// A [`Command`] that writes an arbitrary [`BufferedEvent`].
+#[track_caller]
+#[deprecated(since = "0.17.0", note = "Use `write_event` instead.")]
+pub fn send_event<E: BufferedEvent>(event: E) -> impl Command {
+    write_event(event)
+}
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index d345368ab28ed..5c2077faf3779 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -1124,9 +1124,9 @@ impl<'w, 's> Commands<'w, 's> {
         self.spawn(Observer::new(observer))
     }
 
-    /// Sends an arbitrary [`BufferedEvent`].
+    /// Writes an arbitrary [`BufferedEvent`].
     ///
-    /// This is a convenience method for sending events
+    /// This is a convenience method for writing events
     /// without requiring an [`EventWriter`](crate::event::EventWriter).
     ///
     /// # Performance
@@ -1137,11 +1137,29 @@ impl<'w, 's> Commands<'w, 's> {
     /// If these events are performance-critical or very frequently sent,
     /// consider using a typed [`EventWriter`](crate::event::EventWriter) instead.
     #[track_caller]
-    pub fn send_event<E: BufferedEvent>(&mut self, event: E) -> &mut Self {
-        self.queue(command::send_event(event));
+    pub fn write_event<E: BufferedEvent>(&mut self, event: E) -> &mut Self {
+        self.queue(command::write_event(event));
         self
     }
 
+    /// Writes an arbitrary [`BufferedEvent`].
+    ///
+    /// This is a convenience method for writing events
+    /// without requiring an [`EventWriter`](crate::event::EventWriter).
+    ///
+    /// # Performance
+    ///
+    /// Since this is a command, exclusive world access is used, which means that it will not profit from
+    /// system-level parallelism on supported platforms.
+    ///
+    /// If these events are performance-critical or very frequently sent,
+    /// consider using a typed [`EventWriter`](crate::event::EventWriter) instead.
+    #[track_caller]
+    #[deprecated(since = "0.17.0", note = "Use `Commands::write_event` instead.")]
+    pub fn send_event<E: BufferedEvent>(&mut self, event: E) -> &mut Self {
+        self.write_event(event)
+    }
+
     /// Runs the schedule corresponding to the given [`ScheduleLabel`].
     ///
     /// Calls [`World::try_run_schedule`](World::try_run_schedule).
diff --git a/crates/bevy_ecs/src/world/deferred_world.rs b/crates/bevy_ecs/src/world/deferred_world.rs
index 0734aa9d8c83f..64f1fa409f9aa 100644
--- a/crates/bevy_ecs/src/world/deferred_world.rs
+++ b/crates/bevy_ecs/src/world/deferred_world.rs
@@ -7,7 +7,7 @@ use crate::{
     change_detection::{MaybeLocation, MutUntyped},
     component::{ComponentId, Mutable},
     entity::Entity,
-    event::{BufferedEvent, EntityEvent, Event, EventId, EventKey, Events, SendBatchIds},
+    event::{BufferedEvent, EntityEvent, Event, EventId, EventKey, Events, WriteBatchIds},
     lifecycle::{HookContext, INSERT, REPLACE},
     observer::{Observers, TriggerTargets},
     prelude::{Component, QueryState},
@@ -507,30 +507,51 @@ impl<'w> DeferredWorld<'w> {
         unsafe { self.world.get_non_send_resource_mut() }
     }
 
-    /// Sends a [`BufferedEvent`].
-    /// This method returns the [ID](`EventId`) of the sent `event`,
-    /// or [`None`] if the `event` could not be sent.
+    /// Writes a [`BufferedEvent`].
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
     #[inline]
+    pub fn write_event<E: BufferedEvent>(&mut self, event: E) -> Option<EventId<E>> {
+        self.write_event_batch(core::iter::once(event))?.next()
+    }
+
+    /// Writes a [`BufferedEvent`].
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
+    #[inline]
+    #[deprecated(since = "0.17.0", note = "Use `DeferredWorld::write_event` instead.")]
     pub fn send_event<E: BufferedEvent>(&mut self, event: E) -> Option<EventId<E>> {
-        self.send_event_batch(core::iter::once(event))?.next()
+        self.write_event(event)
     }
 
-    /// Sends the default value of the [`BufferedEvent`] of type `E`.
-    /// This method returns the [ID](`EventId`) of the sent `event`,
-    /// or [`None`] if the `event` could not be sent.
+    /// Writes the default value of the [`BufferedEvent`] of type `E`.
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
     #[inline]
+    pub fn write_event_default<E: BufferedEvent + Default>(&mut self) -> Option<EventId<E>> {
+        self.write_event(E::default())
+    }
+
+    /// Writes the default value of the [`BufferedEvent`] of type `E`.
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
+    #[inline]
+    #[deprecated(
+        since = "0.17.0",
+        note = "Use `DeferredWorld::write_event_default` instead."
+    )]
     pub fn send_event_default<E: BufferedEvent + Default>(&mut self) -> Option<EventId<E>> {
-        self.send_event(E::default())
+        self.write_event_default::<E>()
     }
 
-    /// Sends a batch of [`BufferedEvent`]s from an iterator.
-    /// This method returns the [IDs](`EventId`) of the sent `events`,
-    /// or [`None`] if the `event` could not be sent.
+    /// Writes a batch of [`BufferedEvent`]s from an iterator.
+    /// This method returns the [IDs](`EventId`) of the written `events`,
+    /// or [`None`] if the `event` could not be written.
     #[inline]
-    pub fn send_event_batch<E: BufferedEvent>(
+    pub fn write_event_batch<E: BufferedEvent>(
         &mut self,
         events: impl IntoIterator<Item = E>,
-    ) -> Option<SendBatchIds<E>> {
+    ) -> Option<WriteBatchIds<E>> {
         let Some(mut events_resource) = self.get_resource_mut::<Events<E>>() else {
             log::error!(
                 "Unable to send event `{}`\n\tEvent must be added to the app with `add_event()`\n\thttps://docs.rs/bevy/*/bevy/app/struct.App.html#method.add_event ",
@@ -538,7 +559,22 @@ impl<'w> DeferredWorld<'w> {
             );
             return None;
         };
-        Some(events_resource.send_batch(events))
+        Some(events_resource.write_batch(events))
+    }
+
+    /// Writes a batch of [`BufferedEvent`]s from an iterator.
+    /// This method returns the [IDs](`EventId`) of the written `events`,
+    /// or [`None`] if the `event` could not be written.
+    #[inline]
+    #[deprecated(
+        since = "0.17.0",
+        note = "Use `DeferredWorld::write_event_batch` instead."
+    )]
+    pub fn send_event_batch<E: BufferedEvent>(
+        &mut self,
+        events: impl IntoIterator<Item = E>,
+    ) -> Option<WriteBatchIds<E>> {
+        self.write_event_batch(events)
     }
 
     /// Gets a pointer to the resource with the id [`ComponentId`] if it exists.
diff --git a/crates/bevy_ecs/src/world/entity_ref.rs b/crates/bevy_ecs/src/world/entity_ref.rs
index 9b7f8eb551133..90438b8d6e1e6 100644
--- a/crates/bevy_ecs/src/world/entity_ref.rs
+++ b/crates/bevy_ecs/src/world/entity_ref.rs
@@ -2418,7 +2418,7 @@ impl<'w> EntityWorldMut<'w> {
         }
 
         for component_id in archetype.components() {
-            world.removed_components.send(component_id, self.entity);
+            world.removed_components.write(component_id, self.entity);
         }
 
         // Observers and on_remove hooks may reserve new entities, which
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index fbdf0c04afd09..e77b348c9605d 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -50,7 +50,7 @@ use crate::{
     },
     entity::{Entities, Entity, EntityDoesNotExistError},
     entity_disabling::DefaultQueryFilters,
-    event::{Event, EventId, Events, SendBatchIds},
+    event::{Event, EventId, Events, WriteBatchIds},
     lifecycle::RemovedComponentEvents,
     observer::Observers,
     query::{DebugCheckedUnwrap, QueryData, QueryFilter, QueryState},
@@ -2626,30 +2626,48 @@ impl World {
         Some(result)
     }
 
-    /// Sends a [`BufferedEvent`].
-    /// This method returns the [ID](`EventId`) of the sent `event`,
-    /// or [`None`] if the `event` could not be sent.
+    /// Writes a [`BufferedEvent`].
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
     #[inline]
+    pub fn write_event<E: BufferedEvent>(&mut self, event: E) -> Option<EventId<E>> {
+        self.write_event_batch(core::iter::once(event))?.next()
+    }
+
+    /// Writes a [`BufferedEvent`].
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
+    #[inline]
+    #[deprecated(since = "0.17.0", note = "Use `World::write_event` instead.")]
     pub fn send_event<E: BufferedEvent>(&mut self, event: E) -> Option<EventId<E>> {
-        self.send_event_batch(core::iter::once(event))?.next()
+        self.write_event(event)
     }
 
-    /// Sends the default value of the [`BufferedEvent`] of type `E`.
-    /// This method returns the [ID](`EventId`) of the sent `event`,
-    /// or [`None`] if the `event` could not be sent.
+    /// Writes the default value of the [`BufferedEvent`] of type `E`.
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
     #[inline]
+    pub fn write_event_default<E: BufferedEvent + Default>(&mut self) -> Option<EventId<E>> {
+        self.write_event(E::default())
+    }
+
+    /// Writes the default value of the [`BufferedEvent`] of type `E`.
+    /// This method returns the [ID](`EventId`) of the written `event`,
+    /// or [`None`] if the `event` could not be written.
+    #[inline]
+    #[deprecated(since = "0.17.0", note = "Use `World::write_event_default` instead.")]
     pub fn send_event_default<E: BufferedEvent + Default>(&mut self) -> Option<EventId<E>> {
-        self.send_event(E::default())
+        self.write_event_default::<E>()
     }
 
-    /// Sends a batch of [`BufferedEvent`]s from an iterator.
-    /// This method returns the [IDs](`EventId`) of the sent `events`,
-    /// or [`None`] if the `event` could not be sent.
+    /// Writes a batch of [`BufferedEvent`]s from an iterator.
+    /// This method returns the [IDs](`EventId`) of the written `events`,
+    /// or [`None`] if the `event` could not be written.
     #[inline]
-    pub fn send_event_batch<E: BufferedEvent>(
+    pub fn write_event_batch<E: BufferedEvent>(
         &mut self,
         events: impl IntoIterator<Item = E>,
-    ) -> Option<SendBatchIds<E>> {
+    ) -> Option<WriteBatchIds<E>> {
         let Some(mut events_resource) = self.get_resource_mut::<Events<E>>() else {
             log::error!(
                 "Unable to send event `{}`\n\tEvent must be added to the app with `add_event()`\n\thttps://docs.rs/bevy/*/bevy/app/struct.App.html#method.add_event ",
@@ -2657,7 +2675,19 @@ impl World {
             );
             return None;
         };
-        Some(events_resource.send_batch(events))
+        Some(events_resource.write_batch(events))
+    }
+
+    /// Writes a batch of [`BufferedEvent`]s from an iterator.
+    /// This method returns the [IDs](`EventId`) of the written `events`,
+    /// or [`None`] if the `event` could not be written.
+    #[inline]
+    #[deprecated(since = "0.17.0", note = "Use `World::write_event_batch` instead.")]
+    pub fn send_event_batch<E: BufferedEvent>(
+        &mut self,
+        events: impl IntoIterator<Item = E>,
+    ) -> Option<WriteBatchIds<E>> {
+        self.write_event_batch(events)
     }
 
     /// Inserts a new resource with the given `value`. Will replace the value if it already existed.
diff --git a/crates/bevy_input/src/gamepad.rs b/crates/bevy_input/src/gamepad.rs
index a448ec3d488c5..aaef46b3e832e 100644
--- a/crates/bevy_input/src/gamepad.rs
+++ b/crates/bevy_input/src/gamepad.rs
@@ -2223,7 +2223,7 @@ mod tests {
             self.app
                 .world_mut()
                 .resource_mut::<Events<GamepadConnectionEvent>>()
-                .send(GamepadConnectionEvent::new(
+                .write(GamepadConnectionEvent::new(
                     gamepad,
                     Connected {
                         name: "Test gamepad".to_string(),
@@ -2238,14 +2238,14 @@ mod tests {
             self.app
                 .world_mut()
                 .resource_mut::<Events<GamepadConnectionEvent>>()
-                .send(GamepadConnectionEvent::new(gamepad, Disconnected));
+                .write(GamepadConnectionEvent::new(gamepad, Disconnected));
         }
 
         pub fn send_raw_gamepad_event(&mut self, event: RawGamepadEvent) {
             self.app
                 .world_mut()
                 .resource_mut::<Events<RawGamepadEvent>>()
-                .send(event);
+                .write(event);
         }
 
         pub fn send_raw_gamepad_event_batch(
@@ -2255,7 +2255,7 @@ mod tests {
             self.app
                 .world_mut()
                 .resource_mut::<Events<RawGamepadEvent>>()
-                .send_batch(events);
+                .write_batch(events);
         }
     }
 
@@ -2449,7 +2449,7 @@ mod tests {
         ctx.app
             .world_mut()
             .resource_mut::<Events<RawGamepadEvent>>()
-            .send_batch([
+            .write_batch([
                 RawGamepadEvent::Axis(RawGamepadAxisChangedEvent::new(
                     entity,
                     GamepadAxis::LeftStickY,
@@ -2513,7 +2513,7 @@ mod tests {
         ctx.app
             .world_mut()
             .resource_mut::<Events<RawGamepadEvent>>()
-            .send_batch(events);
+            .write_batch(events);
         ctx.update();
         assert_eq!(
             ctx.app
@@ -2550,7 +2550,7 @@ mod tests {
         ctx.app
             .world_mut()
             .resource_mut::<Events<RawGamepadEvent>>()
-            .send_batch(events);
+            .write_batch(events);
         ctx.update();
         assert_eq!(
             ctx.app
@@ -2598,7 +2598,7 @@ mod tests {
         ctx.app
             .world_mut()
             .resource_mut::<Events<RawGamepadEvent>>()
-            .send_batch(events);
+            .write_batch(events);
         ctx.update();
 
         let events = ctx
@@ -2654,7 +2654,7 @@ mod tests {
         ctx.app
             .world_mut()
             .resource_mut::<Events<RawGamepadEvent>>()
-            .send_batch(events);
+            .write_batch(events);
         ctx.update();
         assert_eq!(
             ctx.app
@@ -2692,7 +2692,7 @@ mod tests {
         ctx.app
             .world_mut()
             .resource_mut::<Events<RawGamepadEvent>>()
-            .send_batch(events);
+            .write_batch(events);
         ctx.update();
 
         let events = ctx
@@ -2728,7 +2728,7 @@ mod tests {
         ctx.app
             .world_mut()
             .resource_mut::<Events<RawGamepadEvent>>()
-            .send_batch(events);
+            .write_batch(events);
         ctx.update();
 
         assert_eq!(
diff --git a/crates/bevy_input_focus/src/lib.rs b/crates/bevy_input_focus/src/lib.rs
index df7690ef26fca..b9aa9ffcbb702 100644
--- a/crates/bevy_input_focus/src/lib.rs
+++ b/crates/bevy_input_focus/src/lib.rs
@@ -546,7 +546,7 @@ mod tests {
         assert!(!app.world().is_focus_visible(child_of_b));
 
         // entity_a should receive this event
-        app.world_mut().send_event(key_a_event());
+        app.world_mut().write_event(key_a_event());
         app.update();
 
         assert_eq!(get_gathered(&app, entity_a), "A");
@@ -559,7 +559,7 @@ mod tests {
         assert!(!app.world().is_focus_visible(entity_a));
 
         // This event should be lost
-        app.world_mut().send_event(key_a_event());
+        app.world_mut().write_event(key_a_event());
         app.update();
 
         assert_eq!(get_gathered(&app, entity_a), "A");
@@ -580,7 +580,7 @@ mod tests {
 
         // These events should be received by entity_b and child_of_b
         app.world_mut()
-            .send_event_batch(core::iter::repeat_n(key_a_event(), 4));
+            .write_event_batch(core::iter::repeat_n(key_a_event(), 4));
         app.update();
 
         assert_eq!(get_gathered(&app, entity_a), "A");
diff --git a/crates/bevy_render/src/pipelined_rendering.rs b/crates/bevy_render/src/pipelined_rendering.rs
index efe728e7c7882..00dfc4ba0e19c 100644
--- a/crates/bevy_render/src/pipelined_rendering.rs
+++ b/crates/bevy_render/src/pipelined_rendering.rs
@@ -197,7 +197,7 @@ fn renderer_extract(app_world: &mut World, _world: &mut World) {
                 render_channels.send_blocking(render_app);
             } else {
                 // Renderer thread panicked
-                world.send_event(AppExit::error());
+                world.write_event(AppExit::error());
             }
         });
     });
diff --git a/crates/bevy_state/src/app.rs b/crates/bevy_state/src/app.rs
index c13abceeb91dd..27bfd826e1e30 100644
--- a/crates/bevy_state/src/app.rs
+++ b/crates/bevy_state/src/app.rs
@@ -107,7 +107,7 @@ impl AppExtStates for SubApp {
             );
             S::register_state(schedule);
             let state = self.world().resource::<State<S>>().get().clone();
-            self.world_mut().send_event(StateTransitionEvent {
+            self.world_mut().write_event(StateTransitionEvent {
                 exited: None,
                 entered: Some(state),
             });
@@ -132,7 +132,7 @@ impl AppExtStates for SubApp {
                 "The `StateTransition` schedule is missing. Did you forget to add StatesPlugin or DefaultPlugins before calling insert_state?"
             );
             S::register_state(schedule);
-            self.world_mut().send_event(StateTransitionEvent {
+            self.world_mut().write_event(StateTransitionEvent {
                 exited: None,
                 entered: Some(state),
             });
@@ -145,7 +145,7 @@ impl AppExtStates for SubApp {
             self.world_mut()
                 .resource_mut::<Events<StateTransitionEvent<S>>>()
                 .clear();
-            self.world_mut().send_event(StateTransitionEvent {
+            self.world_mut().write_event(StateTransitionEvent {
                 exited: None,
                 entered: Some(state),
             });
@@ -169,7 +169,7 @@ impl AppExtStates for SubApp {
                 .world()
                 .get_resource::<State<S>>()
                 .map(|s| s.get().clone());
-            self.world_mut().send_event(StateTransitionEvent {
+            self.world_mut().write_event(StateTransitionEvent {
                 exited: None,
                 entered: state,
             });
@@ -200,7 +200,7 @@ impl AppExtStates for SubApp {
                 .world()
                 .get_resource::<State<S>>()
                 .map(|s| s.get().clone());
-            self.world_mut().send_event(StateTransitionEvent {
+            self.world_mut().write_event(StateTransitionEvent {
                 exited: None,
                 entered: state,
             });
diff --git a/crates/bevy_state/src/state_scoped_events.rs b/crates/bevy_state/src/state_scoped_events.rs
index adba1ca6b68c3..a84490f64c71c 100644
--- a/crates/bevy_state/src/state_scoped_events.rs
+++ b/crates/bevy_state/src/state_scoped_events.rs
@@ -213,8 +213,8 @@ mod tests {
         app.add_event::<StateScopedEvent>()
             .clear_events_on_exit_state::<StateScopedEvent>(TestState::A);
 
-        app.world_mut().send_event(StandardEvent).unwrap();
-        app.world_mut().send_event(StateScopedEvent).unwrap();
+        app.world_mut().write_event(StandardEvent).unwrap();
+        app.world_mut().write_event(StateScopedEvent).unwrap();
         assert!(!app.world().resource::<Events<StandardEvent>>().is_empty());
         assert!(!app
             .world()
@@ -243,8 +243,8 @@ mod tests {
         app.add_event::<StateScopedEvent>()
             .clear_events_on_enter_state::<StateScopedEvent>(TestState::B);
 
-        app.world_mut().send_event(StandardEvent).unwrap();
-        app.world_mut().send_event(StateScopedEvent).unwrap();
+        app.world_mut().write_event(StandardEvent).unwrap();
+        app.world_mut().write_event(StateScopedEvent).unwrap();
         assert!(!app.world().resource::<Events<StandardEvent>>().is_empty());
         assert!(!app
             .world()
diff --git a/crates/bevy_time/src/lib.rs b/crates/bevy_time/src/lib.rs
index c4118b876cca1..ff2e70b1db476 100644
--- a/crates/bevy_time/src/lib.rs
+++ b/crates/bevy_time/src/lib.rs
@@ -343,15 +343,15 @@ mod tests {
         let fixed_update_timestep = Time::<Fixed>::default().timestep();
         let time_step = fixed_update_timestep / 2 + Duration::from_millis(1);
 
-        fn send_event(mut events: ResMut<Events<DummyEvent>>) {
-            events.send(DummyEvent);
+        fn write_event(mut events: ResMut<Events<DummyEvent>>) {
+            events.write(DummyEvent);
         }
 
         let mut app = App::new();
         app.add_plugins(TimePlugin)
             .add_event::<DummyEvent>()
             .init_resource::<FixedUpdateCounter>()
-            .add_systems(Startup, send_event)
+            .add_systems(Startup, write_event)
             .add_systems(FixedUpdate, count_fixed_updates)
             .insert_resource(TimeUpdateStrategy::ManualDuration(time_step));
 
diff --git a/crates/bevy_ui/src/widget/viewport.rs b/crates/bevy_ui/src/widget/viewport.rs
index 120c3335c2a21..5002813cd4de9 100644
--- a/crates/bevy_ui/src/widget/viewport.rs
+++ b/crates/bevy_ui/src/widget/viewport.rs
@@ -147,7 +147,7 @@ pub fn viewport_picking(
             };
             viewport_pointer_location.location = Some(location.clone());
 
-            commands.send_event(PointerInput {
+            commands.write_event(PointerInput {
                 location,
                 pointer_id: viewport_pointer_id,
                 action: input.action,
diff --git a/crates/bevy_winit/src/state.rs b/crates/bevy_winit/src/state.rs
index 5b873d462039a..97c26db7d8562 100644
--- a/crates/bevy_winit/src/state.rs
+++ b/crates/bevy_winit/src/state.rs
@@ -240,7 +240,7 @@ impl<T: BufferedEvent> ApplicationHandler<T> for WinitAppRunnerState<T> {
     fn user_event(&mut self, _event_loop: &ActiveEventLoop, event: T) {
         self.user_event_received = true;
 
-        self.world_mut().send_event(event);
+        self.world_mut().write_event(event);
         self.redraw_requested = true;
     }
 
@@ -790,91 +790,91 @@ impl<T: BufferedEvent> WinitAppRunnerState<T> {
         if !raw_winit_events.is_empty() {
             world
                 .resource_mut::<Events<RawWinitWindowEvent>>()
-                .send_batch(raw_winit_events);
+                .write_batch(raw_winit_events);
         }
 
         for winit_event in buffered_events.iter() {
             match winit_event.clone() {
                 BevyWindowEvent::AppLifecycle(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::CursorEntered(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::CursorLeft(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::CursorMoved(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::FileDragAndDrop(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::Ime(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::RequestRedraw(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowBackendScaleFactorChanged(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowCloseRequested(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowCreated(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowDestroyed(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowFocused(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowMoved(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowOccluded(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowResized(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowScaleFactorChanged(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::WindowThemeChanged(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::MouseButtonInput(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::MouseMotion(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::MouseWheel(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::PinchGesture(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::RotationGesture(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::DoubleTapGesture(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::PanGesture(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::TouchInput(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::KeyboardInput(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
                 BevyWindowEvent::KeyboardFocusLost(e) => {
-                    world.send_event(e);
+                    world.write_event(e);
                 }
             }
         }
@@ -882,7 +882,7 @@ impl<T: BufferedEvent> WinitAppRunnerState<T> {
         if !buffered_events.is_empty() {
             world
                 .resource_mut::<Events<BevyWindowEvent>>()
-                .send_batch(buffered_events);
+                .write_batch(buffered_events);
         }
     }
 
diff --git a/examples/3d/clustered_decals.rs b/examples/3d/clustered_decals.rs
index 60a445b483270..a0593af0e08cd 100644
--- a/examples/3d/clustered_decals.rs
+++ b/examples/3d/clustered_decals.rs
@@ -165,7 +165,7 @@ fn setup(
     // Error out if clustered decals aren't supported on the current platform.
     if !decal::clustered::clustered_decals_are_usable(&render_device, &render_adapter) {
         error!("Clustered decals aren't usable on this platform.");
-        commands.send_event(AppExit::error());
+        commands.write_event(AppExit::error());
     }
 
     spawn_cube(&mut commands, &mut meshes, &mut materials);
diff --git a/examples/3d/light_textures.rs b/examples/3d/light_textures.rs
index babaa9b8a88a3..c7cfb86f88b4e 100644
--- a/examples/3d/light_textures.rs
+++ b/examples/3d/light_textures.rs
@@ -151,7 +151,7 @@ fn setup(
     // Error out if clustered decals (and so light textures) aren't supported on the current platform.
     if !decal::clustered::clustered_decals_are_usable(&render_device, &render_adapter) {
         error!("Light textures aren't usable on this platform.");
-        commands.send_event(AppExit::error());
+        commands.write_event(AppExit::error());
     }
 
     spawn_cubes(&mut commands, &mut meshes, &mut materials);
diff --git a/examples/ecs/component_hooks.rs b/examples/ecs/component_hooks.rs
index 7a97bf454c47c..a50452a11ed0a 100644
--- a/examples/ecs/component_hooks.rs
+++ b/examples/ecs/component_hooks.rs
@@ -95,7 +95,7 @@ fn setup(world: &mut World) {
                     .resource_mut::<MyComponentIndex>()
                     .insert(value, entity);
                 // Or send events
-                world.send_event(MyEvent);
+                world.write_event(MyEvent);
             },
         )
         // `on_insert` will trigger when a component is inserted onto an entity,
diff --git a/examples/ecs/send_and_receive_events.rs b/examples/ecs/send_and_receive_events.rs
index 78dd5b240b048..7a376529f5644 100644
--- a/examples/ecs/send_and_receive_events.rs
+++ b/examples/ecs/send_and_receive_events.rs
@@ -160,6 +160,6 @@ fn send_and_receive_manual_event_reader(
 
     for mut event in events_to_resend {
         event.times_sent += 1;
-        events.send(event);
+        events.write(event);
     }
 }
diff --git a/release-content/migration-guides/send_event_rename.md b/release-content/migration-guides/send_event_rename.md
new file mode 100644
index 0000000000000..aceba50140d07
--- /dev/null
+++ b/release-content/migration-guides/send_event_rename.md
@@ -0,0 +1,23 @@
+---
+title: Rename `send_event` and similar methods to `write_event`
+pull_requests: [20017]
+---
+
+Following up on the `EventWriter::send` being renamed to `EventWriter::write` in 0.16, many similar methods have been renamed.
+This includes both the `World` and `Commands` event methods. The old methods have been depreciated.
+
+| Old                                 | New                                  |
+|-------------------------------------|--------------------------------------|
+| `World::send_event`                 | `World::write_event`                 |
+| `World::send_event_default`         | `World::write_event_default`         |
+| `World::send_event_batch`           | `World::write_event_batch`           |
+| `DeferredWorld::send_event`         | `DeferredWorld::write_event`         |
+| `DeferredWorld::send_event_default` | `DeferredWorld::write_event_default` |
+| `DeferredWorld::send_event_batch`   | `DeferredWorld::write_event_batch`   |
+| `Commands::send_event`              | `Commands::write_event`              |
+| `Events::send`                      | `Events::write`                      |
+| `Events::send_default`              | `Events::write_default`              |
+| `Events::send_batch`                | `Events::write_batch`                |
+| `RemovedComponentEvents::send`      | `RemovedComponentEvents::write`      |
+| `command::send_event`               | `command::write_event`               |
+| `SendBatchIds`                      | `WriteBatchIds`                      |
diff --git a/tests/how_to_test_systems.rs b/tests/how_to_test_systems.rs
index f6b2b15500b12..d17753b346ed8 100644
--- a/tests/how_to_test_systems.rs
+++ b/tests/how_to_test_systems.rs
@@ -161,10 +161,10 @@ fn update_score_on_event() {
     // Add our systems
     app.add_systems(Update, update_score);
 
-    // Send an `EnemyDied` event
+    // Write an `EnemyDied` event
     app.world_mut()
         .resource_mut::<Events<EnemyDied>>()
-        .send(EnemyDied(3));
+        .write(EnemyDied(3));
 
     // Run systems
     app.update();
