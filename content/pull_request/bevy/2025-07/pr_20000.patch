diff --git a/crates/bevy_light/src/lib.rs b/crates/bevy_light/src/lib.rs
index cf7e19ed81d95..655171da6328f 100644
--- a/crates/bevy_light/src/lib.rs
+++ b/crates/bevy_light/src/lib.rs
@@ -27,7 +27,7 @@ use cluster::{
 mod ambient_light;
 pub use ambient_light::AmbientLight;
 mod probe;
-pub use probe::{EnvironmentMapLight, LightProbe};
+pub use probe::{EnvironmentMapLight, IrradianceVolume, LightProbe};
 mod volumetric;
 pub use volumetric::{FogVolume, VolumetricFog, VolumetricLight};
 pub mod cascade;
@@ -121,6 +121,7 @@ impl Plugin for LightPlugin {
             .register_type::<PointLight>()
             .register_type::<LightProbe>()
             .register_type::<EnvironmentMapLight>()
+            .register_type::<IrradianceVolume>()
             .register_type::<VolumetricFog>()
             .register_type::<VolumetricLight>()
             .register_type::<PointLightShadowMap>()
diff --git a/crates/bevy_light/src/probe.rs b/crates/bevy_light/src/probe.rs
index 7cd7e2f634689..5683daa562f21 100644
--- a/crates/bevy_light/src/probe.rs
+++ b/crates/bevy_light/src/probe.rs
@@ -107,3 +107,50 @@ impl Default for EnvironmentMapLight {
         }
     }
 }
+
+/// The component that defines an irradiance volume.
+///
+/// See `bevy_pbr::irradiance_volume` for detailed information.
+///
+/// This component requires the [`LightProbe`] component, and is typically used with
+/// [`bevy_transform::components::Transform`] to place the volume appropriately.
+#[derive(Clone, Reflect, Component, Debug)]
+#[reflect(Component, Default, Debug, Clone)]
+#[require(LightProbe)]
+pub struct IrradianceVolume {
+    /// The 3D texture that represents the ambient cubes, encoded in the format
+    /// described in `bevy_pbr::irradiance_volume`.
+    pub voxels: Handle<Image>,
+
+    /// Scale factor applied to the diffuse and specular light generated by this component.
+    ///
+    /// After applying this multiplier, the resulting values should
+    /// be in units of [cd/m^2](https://en.wikipedia.org/wiki/Candela_per_square_metre).
+    ///
+    /// See also <https://google.github.io/filament/Filament.html#lighting/imagebasedlights/iblunit>.
+    pub intensity: f32,
+
+    /// Whether the light from this irradiance volume has an effect on meshes
+    /// with lightmaps.
+    ///
+    /// Set this to false if your lightmap baking tool bakes the light from this
+    /// irradiance volume into the lightmaps in order to avoid counting the
+    /// irradiance twice. Frequently, applications use irradiance volumes as a
+    /// lower-quality alternative to lightmaps for capturing indirect
+    /// illumination on dynamic objects, and such applications will want to set
+    /// this value to false.
+    ///
+    /// By default, this is set to true.
+    pub affects_lightmapped_meshes: bool,
+}
+
+impl Default for IrradianceVolume {
+    #[inline]
+    fn default() -> Self {
+        IrradianceVolume {
+            voxels: Handle::default(),
+            intensity: 0.0,
+            affects_lightmapped_meshes: true,
+        }
+    }
+}
diff --git a/crates/bevy_pbr/src/lib.rs b/crates/bevy_pbr/src/lib.rs
index 994cb72b25a06..45aa6297d2998 100644
--- a/crates/bevy_pbr/src/lib.rs
+++ b/crates/bevy_pbr/src/lib.rs
@@ -51,9 +51,9 @@ use bevy_light::SimulationLightSystems;
 pub use bevy_light::{
     light_consts, AmbientLight, CascadeShadowConfig, CascadeShadowConfigBuilder, Cascades,
     ClusteredDecal, DirectionalLight, DirectionalLightShadowMap, DirectionalLightTexture,
-    FogVolume, LightPlugin, LightProbe, NotShadowCaster, NotShadowReceiver, PointLight,
-    PointLightShadowMap, PointLightTexture, ShadowFilteringMethod, SpotLight, SpotLightTexture,
-    TransmittedShadowReceiver, VolumetricFog, VolumetricLight,
+    FogVolume, IrradianceVolume, LightPlugin, LightProbe, NotShadowCaster, NotShadowReceiver,
+    PointLight, PointLightShadowMap, PointLightTexture, ShadowFilteringMethod, SpotLight,
+    SpotLightTexture, TransmittedShadowReceiver, VolumetricFog, VolumetricLight,
 };
 pub use cluster::*;
 pub use components::*;
diff --git a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
index 49fa9185d37cf..95ed8dcbd91d9 100644
--- a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
+++ b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
@@ -133,9 +133,8 @@
 //!
 //! [Why ambient cubes?]: #why-ambient-cubes
 
-use bevy_ecs::{component::Component, reflect::ReflectComponent};
 use bevy_image::Image;
-use bevy_light::LightProbe;
+pub use bevy_light::IrradianceVolume;
 use bevy_render::{
     render_asset::RenderAssets,
     render_resource::{
@@ -145,11 +144,9 @@ use bevy_render::{
     renderer::{RenderAdapter, RenderDevice},
     texture::{FallbackImage, GpuImage},
 };
-use bevy_utils::default;
 use core::{num::NonZero, ops::Deref};
 
-use bevy_asset::{AssetId, Handle};
-use bevy_reflect::{std_traits::ReflectDefault, Reflect};
+use bevy_asset::AssetId;
 
 use crate::{
     add_cubemap_texture_view, binding_arrays_are_usable, RenderViewLightProbes,
@@ -163,53 +160,6 @@ use super::LightProbeComponent;
 /// (see issue #11885).
 pub(crate) const IRRADIANCE_VOLUMES_ARE_USABLE: bool = cfg!(not(target_arch = "wasm32"));
 
-/// The component that defines an irradiance volume.
-///
-/// See [`crate::irradiance_volume`] for detailed information.
-///
-/// This component requires the [`LightProbe`] component, and is typically used with
-/// [`bevy_transform::components::Transform`] to place the volume appropriately.
-#[derive(Clone, Reflect, Component, Debug)]
-#[reflect(Component, Default, Debug, Clone)]
-#[require(LightProbe)]
-pub struct IrradianceVolume {
-    /// The 3D texture that represents the ambient cubes, encoded in the format
-    /// described in [`crate::irradiance_volume`].
-    pub voxels: Handle<Image>,
-
-    /// Scale factor applied to the diffuse and specular light generated by this component.
-    ///
-    /// After applying this multiplier, the resulting values should
-    /// be in units of [cd/m^2](https://en.wikipedia.org/wiki/Candela_per_square_metre).
-    ///
-    /// See also <https://google.github.io/filament/Filament.html#lighting/imagebasedlights/iblunit>.
-    pub intensity: f32,
-
-    /// Whether the light from this irradiance volume has an effect on meshes
-    /// with lightmaps.
-    ///
-    /// Set this to false if your lightmap baking tool bakes the light from this
-    /// irradiance volume into the lightmaps in order to avoid counting the
-    /// irradiance twice. Frequently, applications use irradiance volumes as a
-    /// lower-quality alternative to lightmaps for capturing indirect
-    /// illumination on dynamic objects, and such applications will want to set
-    /// this value to false.
-    ///
-    /// By default, this is set to true.
-    pub affects_lightmapped_meshes: bool,
-}
-
-impl Default for IrradianceVolume {
-    #[inline]
-    fn default() -> Self {
-        IrradianceVolume {
-            voxels: default(),
-            intensity: 0.0,
-            affects_lightmapped_meshes: true,
-        }
-    }
-}
-
 /// All the bind group entries necessary for PBR shaders to access the
 /// irradiance volumes exposed to a view.
 pub(crate) enum RenderViewIrradianceVolumeBindGroupEntries<'a> {
diff --git a/crates/bevy_pbr/src/light_probe/mod.rs b/crates/bevy_pbr/src/light_probe/mod.rs
index 2884c86a2f574..bce844bb21a18 100644
--- a/crates/bevy_pbr/src/light_probe/mod.rs
+++ b/crates/bevy_pbr/src/light_probe/mod.rs
@@ -288,8 +288,7 @@ impl Plugin for LightProbePlugin {
         load_shader_library!(app, "environment_map.wgsl");
         load_shader_library!(app, "irradiance_volume.wgsl");
 
-        app.register_type::<IrradianceVolume>()
-            .add_plugins(ExtractInstancesPlugin::<EnvironmentMapIds>::new());
+        app.add_plugins(ExtractInstancesPlugin::<EnvironmentMapIds>::new());
     }
 
     fn finish(&self, app: &mut App) {
