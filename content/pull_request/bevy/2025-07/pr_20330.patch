diff --git a/crates/bevy_render/Cargo.toml b/crates/bevy_render/Cargo.toml
index 537f940922fc3..0a610f693aa85 100644
--- a/crates/bevy_render/Cargo.toml
+++ b/crates/bevy_render/Cargo.toml
@@ -19,7 +19,7 @@ keywords = ["bevy"]
 # wgpu-core = { git = "https://github.com/gfx-rs/wgpu", rev = "..." }
 # wgpu-hal = { git = "https://github.com/gfx-rs/wgpu", rev = "..." }
 # wgpu-types = { git = "https://github.com/gfx-rs/wgpu", rev = "..." }
-decoupled_naga = []
+decoupled_naga = ["bevy_shader/decoupled_naga"]
 
 # Enables compressed KTX2 UASTC texture output on the asset processor
 compressed_image_saver = ["bevy_image/compressed_image_saver"]
@@ -32,9 +32,9 @@ ktx2 = ["bevy_image/ktx2"]
 
 multi_threaded = ["bevy_tasks/multi_threaded"]
 
-shader_format_glsl = ["naga/glsl-in", "naga/wgsl-out", "naga_oil/glsl"]
-shader_format_spirv = ["wgpu/spirv", "naga/spv-in", "naga/spv-out"]
-shader_format_wesl = ["wesl"]
+shader_format_glsl = ["bevy_shader/shader_format_glsl"]
+shader_format_spirv = ["bevy_shader/shader_format_spirv", "wgpu/spirv"]
+shader_format_wesl = ["bevy_shader/shader_format_wesl"]
 
 # Enable SPIR-V shader passthrough
 spirv_shader_passthrough = ["wgpu/spirv"]
@@ -75,6 +75,7 @@ bevy_tasks = { path = "../bevy_tasks", version = "0.17.0-dev" }
 bevy_image = { path = "../bevy_image", version = "0.17.0-dev" }
 bevy_mesh = { path = "../bevy_mesh", version = "0.17.0-dev" }
 bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
+bevy_shader = { path = "../bevy_shader", version = "0.17.0-dev" }
 bevy_light = { path = "../bevy_light", optional = true, version = "0.17.0-dev" }
 bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev", default-features = false, features = [
   "std",
diff --git a/crates/bevy_render/src/render_resource/mod.rs b/crates/bevy_render/src/render_resource/mod.rs
index f156b0ecb0feb..30d1821a9abec 100644
--- a/crates/bevy_render/src/render_resource/mod.rs
+++ b/crates/bevy_render/src/render_resource/mod.rs
@@ -11,12 +11,12 @@ mod pipeline;
 mod pipeline_cache;
 mod pipeline_specializer;
 pub mod resource_macros;
-mod shader;
 mod specializer;
 mod storage_buffer;
 mod texture;
 mod uniform_buffer;
 
+pub use bevy_shader::*;
 pub use bind_group::*;
 pub use bind_group_entries::*;
 pub use bind_group_layout::*;
@@ -28,7 +28,6 @@ pub use gpu_array_buffer::*;
 pub use pipeline::*;
 pub use pipeline_cache::*;
 pub use pipeline_specializer::*;
-pub use shader::*;
 pub use specializer::*;
 pub use storage_buffer::*;
 pub use texture::*;
diff --git a/crates/bevy_render/src/render_resource/pipeline_cache.rs b/crates/bevy_render/src/render_resource/pipeline_cache.rs
index bcb8e0dcf3131..3b69e3331d232 100644
--- a/crates/bevy_render/src/render_resource/pipeline_cache.rs
+++ b/crates/bevy_render/src/render_resource/pipeline_cache.rs
@@ -11,20 +11,13 @@ use bevy_ecs::{
     resource::Resource,
     system::{Res, ResMut},
 };
-use bevy_platform::collections::{hash_map::EntryRef, HashMap, HashSet};
+use bevy_platform::collections::{HashMap, HashSet};
 use bevy_tasks::Task;
 use bevy_utils::default;
 use core::{future::Future, hash::Hash, mem};
-use naga::valid::Capabilities;
 use std::sync::{Mutex, PoisonError};
-use thiserror::Error;
-use tracing::{debug, error};
-#[cfg(feature = "shader_format_spirv")]
-use wgpu::util::make_spirv;
-use wgpu::{
-    DownlevelFlags, Features, PipelineCompilationOptions,
-    VertexBufferLayout as RawVertexBufferLayout,
-};
+use tracing::error;
+use wgpu::{PipelineCompilationOptions, VertexBufferLayout as RawVertexBufferLayout};
 
 /// A descriptor for a [`Pipeline`].
 ///
@@ -44,8 +37,6 @@ pub enum Pipeline {
     ComputePipeline(ComputePipeline),
 }
 
-type CachedPipelineId = usize;
-
 /// Index of a cached render pipeline in a [`PipelineCache`].
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, PartialOrd, Ord)]
 pub struct CachedRenderPipelineId(CachedPipelineId);
@@ -124,415 +115,6 @@ impl CachedPipelineState {
     }
 }
 
-#[derive(Default)]
-struct ShaderData {
-    pipelines: HashSet<CachedPipelineId>,
-    processed_shaders: HashMap<Box<[ShaderDefVal]>, Arc<WgpuWrapper<ShaderModule>>>,
-    resolved_imports: HashMap<ShaderImport, AssetId<Shader>>,
-    dependents: HashSet<AssetId<Shader>>,
-}
-
-struct ShaderCache {
-    data: HashMap<AssetId<Shader>, ShaderData>,
-    #[cfg(feature = "shader_format_wesl")]
-    asset_paths: HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
-    shaders: HashMap<AssetId<Shader>, Shader>,
-    import_path_shaders: HashMap<ShaderImport, AssetId<Shader>>,
-    waiting_on_import: HashMap<ShaderImport, Vec<AssetId<Shader>>>,
-    composer: naga_oil::compose::Composer,
-}
-
-#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Debug, Hash)]
-pub enum ShaderDefVal {
-    Bool(String, bool),
-    Int(String, i32),
-    UInt(String, u32),
-}
-
-impl From<&str> for ShaderDefVal {
-    fn from(key: &str) -> Self {
-        ShaderDefVal::Bool(key.to_string(), true)
-    }
-}
-
-impl From<String> for ShaderDefVal {
-    fn from(key: String) -> Self {
-        ShaderDefVal::Bool(key, true)
-    }
-}
-
-impl ShaderDefVal {
-    pub fn value_as_string(&self) -> String {
-        match self {
-            ShaderDefVal::Bool(_, def) => def.to_string(),
-            ShaderDefVal::Int(_, def) => def.to_string(),
-            ShaderDefVal::UInt(_, def) => def.to_string(),
-        }
-    }
-}
-
-impl ShaderCache {
-    fn new(render_device: &RenderDevice, render_adapter: &RenderAdapter) -> Self {
-        let capabilities = get_capabilities(
-            render_device.features(),
-            render_adapter.get_downlevel_capabilities().flags,
-        );
-
-        #[cfg(debug_assertions)]
-        let composer = naga_oil::compose::Composer::default();
-        #[cfg(not(debug_assertions))]
-        let composer = naga_oil::compose::Composer::non_validating();
-
-        let composer = composer.with_capabilities(capabilities);
-
-        Self {
-            composer,
-            data: Default::default(),
-            #[cfg(feature = "shader_format_wesl")]
-            asset_paths: Default::default(),
-            shaders: Default::default(),
-            import_path_shaders: Default::default(),
-            waiting_on_import: Default::default(),
-        }
-    }
-
-    #[expect(
-        clippy::result_large_err,
-        reason = "See https://github.com/bevyengine/bevy/issues/19220"
-    )]
-    fn add_import_to_composer(
-        composer: &mut naga_oil::compose::Composer,
-        import_path_shaders: &HashMap<ShaderImport, AssetId<Shader>>,
-        shaders: &HashMap<AssetId<Shader>, Shader>,
-        import: &ShaderImport,
-    ) -> Result<(), PipelineCacheError> {
-        // Early out if we've already imported this module
-        if composer.contains_module(&import.module_name()) {
-            return Ok(());
-        }
-
-        // Check if the import is available (this handles the recursive import case)
-        let shader = import_path_shaders
-            .get(import)
-            .and_then(|handle| shaders.get(handle))
-            .ok_or(PipelineCacheError::ShaderImportNotYetAvailable)?;
-
-        // Recurse down to ensure all import dependencies are met
-        for import in &shader.imports {
-            Self::add_import_to_composer(composer, import_path_shaders, shaders, import)?;
-        }
-
-        composer.add_composable_module(shader.into())?;
-        // if we fail to add a module the composer will tell us what is missing
-
-        Ok(())
-    }
-
-    #[expect(
-        clippy::result_large_err,
-        reason = "See https://github.com/bevyengine/bevy/issues/19220"
-    )]
-    fn get(
-        &mut self,
-        render_device: &RenderDevice,
-        pipeline: CachedPipelineId,
-        id: AssetId<Shader>,
-        shader_defs: &[ShaderDefVal],
-    ) -> Result<Arc<WgpuWrapper<ShaderModule>>, PipelineCacheError> {
-        let shader = self
-            .shaders
-            .get(&id)
-            .ok_or(PipelineCacheError::ShaderNotLoaded(id))?;
-
-        let data = self.data.entry(id).or_default();
-        let n_asset_imports = shader
-            .imports()
-            .filter(|import| matches!(import, ShaderImport::AssetPath(_)))
-            .count();
-        let n_resolved_asset_imports = data
-            .resolved_imports
-            .keys()
-            .filter(|import| matches!(import, ShaderImport::AssetPath(_)))
-            .count();
-        if n_asset_imports != n_resolved_asset_imports {
-            return Err(PipelineCacheError::ShaderImportNotYetAvailable);
-        }
-
-        data.pipelines.insert(pipeline);
-
-        // PERF: this shader_defs clone isn't great. use raw_entry_mut when it stabilizes
-        let module = match data.processed_shaders.entry_ref(shader_defs) {
-            EntryRef::Occupied(entry) => entry.into_mut(),
-            EntryRef::Vacant(entry) => {
-                let mut shader_defs = shader_defs.to_vec();
-                #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
-                {
-                    shader_defs.push("NO_ARRAY_TEXTURES_SUPPORT".into());
-                    shader_defs.push("NO_CUBE_ARRAY_TEXTURES_SUPPORT".into());
-                    shader_defs.push("SIXTEEN_BYTE_ALIGNMENT".into());
-                }
-
-                if cfg!(target_abi = "sim") {
-                    shader_defs.push("NO_CUBE_ARRAY_TEXTURES_SUPPORT".into());
-                }
-
-                shader_defs.push(ShaderDefVal::UInt(
-                    String::from("AVAILABLE_STORAGE_BUFFER_BINDINGS"),
-                    render_device.limits().max_storage_buffers_per_shader_stage,
-                ));
-
-                debug!(
-                    "processing shader {}, with shader defs {:?}",
-                    id, shader_defs
-                );
-                let shader_source = match &shader.source {
-                    #[cfg(feature = "shader_format_spirv")]
-                    Source::SpirV(data) => make_spirv(data),
-                    #[cfg(feature = "shader_format_wesl")]
-                    Source::Wesl(_) => {
-                        if let ShaderImport::AssetPath(path) = shader.import_path() {
-                            let shader_resolver =
-                                ShaderResolver::new(&self.asset_paths, &self.shaders);
-                            let module_path = wesl::syntax::ModulePath::from_path(path);
-                            let mut compiler_options = wesl::CompileOptions {
-                                imports: true,
-                                condcomp: true,
-                                lower: true,
-                                ..default()
-                            };
-
-                            for shader_def in shader_defs {
-                                match shader_def {
-                                    ShaderDefVal::Bool(key, value) => {
-                                        compiler_options.features.insert(key.clone(), value);
-                                    }
-                                    _ => debug!(
-                                        "ShaderDefVal::Int and ShaderDefVal::UInt are not supported in wesl",
-                                    ),
-                                }
-                            }
-
-                            let compiled = wesl::compile(
-                                &module_path,
-                                &shader_resolver,
-                                &wesl::EscapeMangler,
-                                &compiler_options,
-                            )
-                            .unwrap();
-
-                            let naga = naga::front::wgsl::parse_str(&compiled.to_string()).unwrap();
-                            ShaderSource::Naga(Cow::Owned(naga))
-                        } else {
-                            panic!("Wesl shaders must be imported from a file");
-                        }
-                    }
-                    #[cfg(not(feature = "shader_format_spirv"))]
-                    Source::SpirV(_) => {
-                        unimplemented!(
-                            "Enable feature \"shader_format_spirv\" to use SPIR-V shaders"
-                        )
-                    }
-                    _ => {
-                        for import in shader.imports() {
-                            Self::add_import_to_composer(
-                                &mut self.composer,
-                                &self.import_path_shaders,
-                                &self.shaders,
-                                import,
-                            )?;
-                        }
-
-                        let shader_defs = shader_defs
-                            .into_iter()
-                            .chain(shader.shader_defs.iter().cloned())
-                            .map(|def| match def {
-                                ShaderDefVal::Bool(k, v) => {
-                                    (k, naga_oil::compose::ShaderDefValue::Bool(v))
-                                }
-                                ShaderDefVal::Int(k, v) => {
-                                    (k, naga_oil::compose::ShaderDefValue::Int(v))
-                                }
-                                ShaderDefVal::UInt(k, v) => {
-                                    (k, naga_oil::compose::ShaderDefValue::UInt(v))
-                                }
-                            })
-                            .collect::<std::collections::HashMap<_, _>>();
-
-                        let naga = self.composer.make_naga_module(
-                            naga_oil::compose::NagaModuleDescriptor {
-                                shader_defs,
-                                ..shader.into()
-                            },
-                        )?;
-
-                        #[cfg(not(feature = "decoupled_naga"))]
-                        {
-                            ShaderSource::Naga(Cow::Owned(naga))
-                        }
-
-                        #[cfg(feature = "decoupled_naga")]
-                        {
-                            let mut validator = naga::valid::Validator::new(
-                                naga::valid::ValidationFlags::all(),
-                                self.composer.capabilities,
-                            );
-                            let module_info = validator.validate(&naga).unwrap();
-                            let wgsl = Cow::Owned(
-                                naga::back::wgsl::write_string(
-                                    &naga,
-                                    &module_info,
-                                    naga::back::wgsl::WriterFlags::empty(),
-                                )
-                                .unwrap(),
-                            );
-                            ShaderSource::Wgsl(wgsl)
-                        }
-                    }
-                };
-
-                let module_descriptor = ShaderModuleDescriptor {
-                    label: None,
-                    source: shader_source,
-                };
-
-                render_device
-                    .wgpu_device()
-                    .push_error_scope(wgpu::ErrorFilter::Validation);
-
-                let shader_module = match shader.validate_shader {
-                    ValidateShader::Enabled => {
-                        render_device.create_and_validate_shader_module(module_descriptor)
-                    }
-                    // SAFETY: we are interfacing with shader code, which may contain undefined behavior,
-                    // such as indexing out of bounds.
-                    // The checks required are prohibitively expensive and a poor default for game engines.
-                    ValidateShader::Disabled => unsafe {
-                        render_device.create_shader_module(module_descriptor)
-                    },
-                };
-
-                let error = render_device.wgpu_device().pop_error_scope();
-
-                // `now_or_never` will return Some if the future is ready and None otherwise.
-                // On native platforms, wgpu will yield the error immediately while on wasm it may take longer since the browser APIs are asynchronous.
-                // So to keep the complexity of the ShaderCache low, we will only catch this error early on native platforms,
-                // and on wasm the error will be handled by wgpu and crash the application.
-                if let Some(Some(wgpu::Error::Validation { description, .. })) =
-                    bevy_tasks::futures::now_or_never(error)
-                {
-                    return Err(PipelineCacheError::CreateShaderModule(description));
-                }
-
-                entry.insert(Arc::new(WgpuWrapper::new(shader_module)))
-            }
-        };
-
-        Ok(module.clone())
-    }
-
-    fn clear(&mut self, id: AssetId<Shader>) -> Vec<CachedPipelineId> {
-        let mut shaders_to_clear = vec![id];
-        let mut pipelines_to_queue = Vec::new();
-        while let Some(handle) = shaders_to_clear.pop() {
-            if let Some(data) = self.data.get_mut(&handle) {
-                data.processed_shaders.clear();
-                pipelines_to_queue.extend(data.pipelines.iter().copied());
-                shaders_to_clear.extend(data.dependents.iter().copied());
-
-                if let Some(Shader { import_path, .. }) = self.shaders.get(&handle) {
-                    self.composer
-                        .remove_composable_module(&import_path.module_name());
-                }
-            }
-        }
-
-        pipelines_to_queue
-    }
-
-    fn set_shader(&mut self, id: AssetId<Shader>, shader: Shader) -> Vec<CachedPipelineId> {
-        let pipelines_to_queue = self.clear(id);
-        let path = shader.import_path();
-        self.import_path_shaders.insert(path.clone(), id);
-        if let Some(waiting_shaders) = self.waiting_on_import.get_mut(path) {
-            for waiting_shader in waiting_shaders.drain(..) {
-                // resolve waiting shader import
-                let data = self.data.entry(waiting_shader).or_default();
-                data.resolved_imports.insert(path.clone(), id);
-                // add waiting shader as dependent of this shader
-                let data = self.data.entry(id).or_default();
-                data.dependents.insert(waiting_shader);
-            }
-        }
-
-        for import in shader.imports() {
-            if let Some(import_id) = self.import_path_shaders.get(import).copied() {
-                // resolve import because it is currently available
-                let data = self.data.entry(id).or_default();
-                data.resolved_imports.insert(import.clone(), import_id);
-                // add this shader as a dependent of the import
-                let data = self.data.entry(import_id).or_default();
-                data.dependents.insert(id);
-            } else {
-                let waiting = self.waiting_on_import.entry(import.clone()).or_default();
-                waiting.push(id);
-            }
-        }
-
-        #[cfg(feature = "shader_format_wesl")]
-        if let Source::Wesl(_) = shader.source {
-            if let ShaderImport::AssetPath(path) = shader.import_path() {
-                self.asset_paths
-                    .insert(wesl::syntax::ModulePath::from_path(path), id);
-            }
-        }
-        self.shaders.insert(id, shader);
-        pipelines_to_queue
-    }
-
-    fn remove(&mut self, id: AssetId<Shader>) -> Vec<CachedPipelineId> {
-        let pipelines_to_queue = self.clear(id);
-        if let Some(shader) = self.shaders.remove(&id) {
-            self.import_path_shaders.remove(shader.import_path());
-        }
-
-        pipelines_to_queue
-    }
-}
-
-#[cfg(feature = "shader_format_wesl")]
-pub struct ShaderResolver<'a> {
-    asset_paths: &'a HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
-    shaders: &'a HashMap<AssetId<Shader>, Shader>,
-}
-
-#[cfg(feature = "shader_format_wesl")]
-impl<'a> ShaderResolver<'a> {
-    pub fn new(
-        asset_paths: &'a HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
-        shaders: &'a HashMap<AssetId<Shader>, Shader>,
-    ) -> Self {
-        Self {
-            asset_paths,
-            shaders,
-        }
-    }
-}
-
-#[cfg(feature = "shader_format_wesl")]
-impl<'a> wesl::Resolver for ShaderResolver<'a> {
-    fn resolve_source(
-        &self,
-        module_path: &wesl::syntax::ModulePath,
-    ) -> Result<Cow<str>, wesl::ResolveError> {
-        let asset_id = self.asset_paths.get(module_path).ok_or_else(|| {
-            wesl::ResolveError::ModuleNotFound(module_path.clone(), "Invalid asset id".to_string())
-        })?;
-
-        let shader = self.shaders.get(asset_id).unwrap();
-        Ok(Cow::Borrowed(shader.source.as_str()))
-    }
-}
-
 type LayoutCacheKey = (Vec<BindGroupLayoutId>, Vec<PushConstantRange>);
 #[derive(Default)]
 struct LayoutCache {
@@ -566,6 +148,62 @@ impl LayoutCache {
     }
 }
 
+#[expect(
+    clippy::result_large_err,
+    reason = "See https://github.com/bevyengine/bevy/issues/19220"
+)]
+fn load_module(
+    render_device: &RenderDevice,
+    shader_source: ShaderCacheSource,
+    validate_shader: &ValidateShader,
+) -> Result<WgpuWrapper<ShaderModule>, PipelineCacheError> {
+    let shader_source = match shader_source {
+        #[cfg(feature = "shader_format_spirv")]
+        ShaderCacheSource::SpirV(data) => wgpu::util::make_spirv(data),
+        #[cfg(not(feature = "shader_format_spirv"))]
+        ShaderCacheSource::SpirV(_) => {
+            unimplemented!("Enable feature \"shader_format_spirv\" to use SPIR-V shaders")
+        }
+        ShaderCacheSource::Wgsl(src) => ShaderSource::Wgsl(Cow::Owned(src)),
+        #[cfg(not(feature = "decoupled_naga"))]
+        ShaderCacheSource::Naga(src) => ShaderSource::Naga(Cow::Owned(src)),
+    };
+    let module_descriptor = ShaderModuleDescriptor {
+        label: None,
+        source: shader_source,
+    };
+
+    render_device
+        .wgpu_device()
+        .push_error_scope(wgpu::ErrorFilter::Validation);
+
+    let shader_module = WgpuWrapper::new(match validate_shader {
+        ValidateShader::Enabled => {
+            render_device.create_and_validate_shader_module(module_descriptor)
+        }
+        // SAFETY: we are interfacing with shader code, which may contain undefined behavior,
+        // such as indexing out of bounds.
+        // The checks required are prohibitively expensive and a poor default for game engines.
+        ValidateShader::Disabled => unsafe {
+            render_device.create_shader_module(module_descriptor)
+        },
+    });
+
+    let error = render_device.wgpu_device().pop_error_scope();
+
+    // `now_or_never` will return Some if the future is ready and None otherwise.
+    // On native platforms, wgpu will yield the error immediately while on wasm it may take longer since the browser APIs are asynchronous.
+    // So to keep the complexity of the ShaderCache low, we will only catch this error early on native platforms,
+    // and on wasm the error will be handled by wgpu and crash the application.
+    if let Some(Some(wgpu::Error::Validation { description, .. })) =
+        bevy_tasks::futures::now_or_never(error)
+    {
+        return Err(PipelineCacheError::CreateShaderModule(description));
+    }
+
+    Ok(shader_module)
+}
+
 /// Cache for render and compute pipelines.
 ///
 /// The cache stores existing render and compute pipelines allocated on the GPU, as well as
@@ -581,11 +219,12 @@ impl LayoutCache {
 #[derive(Resource)]
 pub struct PipelineCache {
     layout_cache: Arc<Mutex<LayoutCache>>,
-    shader_cache: Arc<Mutex<ShaderCache>>,
+    shader_cache: Arc<Mutex<ShaderCache<WgpuWrapper<ShaderModule>, RenderDevice>>>,
     device: RenderDevice,
     pipelines: Vec<CachedPipeline>,
     waiting_pipelines: HashSet<CachedPipelineId>,
     new_pipelines: Mutex<Vec<CachedPipeline>>,
+    global_shader_defs: Vec<ShaderDefVal>,
     /// If `true`, disables asynchronous pipeline compilation.
     /// This has no effect on macOS, wasm, or without the `multi_threaded` feature.
     synchronous_pipeline_compilation: bool,
@@ -608,13 +247,35 @@ impl PipelineCache {
         render_adapter: RenderAdapter,
         synchronous_pipeline_compilation: bool,
     ) -> Self {
+        let mut global_shader_defs = Vec::new();
+        #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
+        {
+            global_shader_defs.push("NO_ARRAY_TEXTURES_SUPPORT".into());
+            global_shader_defs.push("NO_CUBE_ARRAY_TEXTURES_SUPPORT".into());
+            global_shader_defs.push("SIXTEEN_BYTE_ALIGNMENT".into());
+        }
+
+        if cfg!(target_abi = "sim") {
+            global_shader_defs.push("NO_CUBE_ARRAY_TEXTURES_SUPPORT".into());
+        }
+
+        global_shader_defs.push(ShaderDefVal::UInt(
+            String::from("AVAILABLE_STORAGE_BUFFER_BINDINGS"),
+            device.limits().max_storage_buffers_per_shader_stage,
+        ));
+
         Self {
-            shader_cache: Arc::new(Mutex::new(ShaderCache::new(&device, &render_adapter))),
+            shader_cache: Arc::new(Mutex::new(ShaderCache::new(
+                device.features(),
+                render_adapter.get_downlevel_capabilities().flags,
+                load_module,
+            ))),
             device,
             layout_cache: default(),
             waiting_pipelines: default(),
             new_pipelines: default(),
             pipelines: default(),
+            global_shader_defs,
             synchronous_pipeline_compilation,
         }
     }
@@ -785,9 +446,9 @@ impl PipelineCache {
         id
     }
 
-    fn set_shader(&mut self, id: AssetId<Shader>, shader: &Shader) {
+    fn set_shader(&mut self, id: AssetId<Shader>, shader: Shader) {
         let mut shader_cache = self.shader_cache.lock().unwrap();
-        let pipelines_to_queue = shader_cache.set_shader(id, shader.clone());
+        let pipelines_to_queue = shader_cache.set_shader(id, shader);
         for cached_pipeline in pipelines_to_queue {
             self.pipelines[cached_pipeline].state = CachedPipelineState::Queued;
             self.waiting_pipelines.insert(cached_pipeline);
@@ -1069,6 +730,9 @@ impl PipelineCache {
                 // PERF: Instead of blocking waiting for the shader cache lock, try again next frame if the lock is currently held
                 AssetEvent::Added { id } | AssetEvent::Modified { id } => {
                     if let Some(shader) = shaders.get(*id) {
+                        let mut shader = shader.clone();
+                        shader.shader_defs.extend(cache.global_shader_defs.clone());
+
                         cache.set_shader(*id, shader);
                     }
                 }
@@ -1115,138 +779,3 @@ fn create_pipeline_task(
         Err(err) => CachedPipelineState::Err(err),
     }
 }
-
-/// Type of error returned by a [`PipelineCache`] when the creation of a GPU pipeline object failed.
-#[cfg_attr(
-    not(target_arch = "wasm32"),
-    expect(
-        clippy::large_enum_variant,
-        reason = "See https://github.com/bevyengine/bevy/issues/19220"
-    )
-)]
-#[derive(Error, Debug)]
-pub enum PipelineCacheError {
-    #[error(
-        "Pipeline could not be compiled because the following shader could not be loaded: {0:?}"
-    )]
-    ShaderNotLoaded(AssetId<Shader>),
-    #[error(transparent)]
-    ProcessShaderError(#[from] naga_oil::compose::ComposerError),
-    #[error("Shader import not yet available.")]
-    ShaderImportNotYetAvailable,
-    #[error("Could not create shader module: {0}")]
-    CreateShaderModule(String),
-}
-
-// TODO: This needs to be kept up to date with the capabilities in the `create_validator` function in wgpu-core
-// https://github.com/gfx-rs/wgpu/blob/trunk/wgpu-core/src/device/mod.rs#L449
-// We can't use the `wgpu-core` function to detect the device's capabilities because `wgpu-core` isn't included in WebGPU builds.
-/// Get the device's capabilities for use in `naga_oil`.
-fn get_capabilities(features: Features, downlevel: DownlevelFlags) -> Capabilities {
-    let mut capabilities = Capabilities::empty();
-    capabilities.set(
-        Capabilities::PUSH_CONSTANT,
-        features.contains(Features::PUSH_CONSTANTS),
-    );
-    capabilities.set(
-        Capabilities::FLOAT64,
-        features.contains(Features::SHADER_F64),
-    );
-    capabilities.set(
-        Capabilities::PRIMITIVE_INDEX,
-        features.contains(Features::SHADER_PRIMITIVE_INDEX),
-    );
-    capabilities.set(
-        Capabilities::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING,
-        features.contains(Features::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING),
-    );
-    capabilities.set(
-        Capabilities::STORAGE_TEXTURE_ARRAY_NON_UNIFORM_INDEXING,
-        features.contains(Features::STORAGE_TEXTURE_ARRAY_NON_UNIFORM_INDEXING),
-    );
-    capabilities.set(
-        Capabilities::UNIFORM_BUFFER_ARRAY_NON_UNIFORM_INDEXING,
-        features.contains(Features::UNIFORM_BUFFER_BINDING_ARRAYS),
-    );
-    // TODO: This needs a proper wgpu feature
-    capabilities.set(
-        Capabilities::SAMPLER_NON_UNIFORM_INDEXING,
-        features.contains(Features::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING),
-    );
-    capabilities.set(
-        Capabilities::STORAGE_TEXTURE_16BIT_NORM_FORMATS,
-        features.contains(Features::TEXTURE_FORMAT_16BIT_NORM),
-    );
-    capabilities.set(
-        Capabilities::MULTIVIEW,
-        features.contains(Features::MULTIVIEW),
-    );
-    capabilities.set(
-        Capabilities::EARLY_DEPTH_TEST,
-        features.contains(Features::SHADER_EARLY_DEPTH_TEST),
-    );
-    capabilities.set(
-        Capabilities::SHADER_INT64,
-        features.contains(Features::SHADER_INT64),
-    );
-    capabilities.set(
-        Capabilities::SHADER_INT64_ATOMIC_MIN_MAX,
-        features.intersects(
-            Features::SHADER_INT64_ATOMIC_MIN_MAX | Features::SHADER_INT64_ATOMIC_ALL_OPS,
-        ),
-    );
-    capabilities.set(
-        Capabilities::SHADER_INT64_ATOMIC_ALL_OPS,
-        features.contains(Features::SHADER_INT64_ATOMIC_ALL_OPS),
-    );
-    capabilities.set(
-        Capabilities::MULTISAMPLED_SHADING,
-        downlevel.contains(DownlevelFlags::MULTISAMPLED_SHADING),
-    );
-    capabilities.set(
-        Capabilities::RAY_QUERY,
-        features.contains(Features::EXPERIMENTAL_RAY_QUERY),
-    );
-    capabilities.set(
-        Capabilities::DUAL_SOURCE_BLENDING,
-        features.contains(Features::DUAL_SOURCE_BLENDING),
-    );
-    capabilities.set(
-        Capabilities::CUBE_ARRAY_TEXTURES,
-        downlevel.contains(DownlevelFlags::CUBE_ARRAY_TEXTURES),
-    );
-    capabilities.set(
-        Capabilities::SUBGROUP,
-        features.intersects(Features::SUBGROUP | Features::SUBGROUP_VERTEX),
-    );
-    capabilities.set(
-        Capabilities::SUBGROUP_BARRIER,
-        features.intersects(Features::SUBGROUP_BARRIER),
-    );
-    capabilities.set(
-        Capabilities::SUBGROUP_VERTEX_STAGE,
-        features.contains(Features::SUBGROUP_VERTEX),
-    );
-    capabilities.set(
-        Capabilities::SHADER_FLOAT32_ATOMIC,
-        features.contains(Features::SHADER_FLOAT32_ATOMIC),
-    );
-    capabilities.set(
-        Capabilities::TEXTURE_ATOMIC,
-        features.contains(Features::TEXTURE_ATOMIC),
-    );
-    capabilities.set(
-        Capabilities::TEXTURE_INT64_ATOMIC,
-        features.contains(Features::TEXTURE_INT64_ATOMIC),
-    );
-    capabilities.set(
-        Capabilities::SHADER_FLOAT16,
-        features.contains(Features::SHADER_F16),
-    );
-    capabilities.set(
-        Capabilities::RAY_HIT_VERTEX_POSITION,
-        features.intersects(Features::EXPERIMENTAL_RAY_HIT_VERTEX_RETURN),
-    );
-
-    capabilities
-}
diff --git a/crates/bevy_shader/Cargo.toml b/crates/bevy_shader/Cargo.toml
new file mode 100644
index 0000000000000..d89bc0ec77734
--- /dev/null
+++ b/crates/bevy_shader/Cargo.toml
@@ -0,0 +1,58 @@
+[package]
+name = "bevy_shader"
+version = "0.17.0-dev"
+edition = "2024"
+description = "Provides shader asset types and import resolution for Bevy"
+homepage = "https://bevy.org"
+repository = "https://github.com/bevyengine/bevy"
+license = "MIT OR Apache-2.0"
+keywords = ["bevy", "shader"]
+
+[dependencies]
+# bevy
+bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
+bevy_asset = { path = "../bevy_asset", version = "0.17.0-dev" }
+bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
+bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev" }
+
+# other
+wgpu-types = { version = "25", default-features = false }
+naga = { version = "25", features = ["wgsl-in"] }
+serde = { version = "1", features = ["derive"] }
+thiserror = { version = "2", default-features = false }
+wesl = { version = "0.1.2", optional = true }
+tracing = { version = "0.1", default-features = false, features = ["std"] }
+
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+# Omit the `glsl` feature in non-WebAssembly by default.
+naga_oil = { version = "0.18", default-features = false, features = [
+  "test_shader",
+] }
+
+[target.'cfg(target_arch = "wasm32")'.dependencies]
+naga_oil = { version = "0.18" }
+
+[features]
+shader_format_glsl = ["naga/glsl-in", "naga/wgsl-out", "naga_oil/glsl"]
+shader_format_spirv = ["naga/spv-in", "naga/spv-out"]
+shader_format_wesl = ["wesl"]
+
+# Bevy users should _never_ turn this feature on.
+#
+# Bevy/wgpu developers can turn this feature on to test a newer version of wgpu without needing to also update naga_oil.
+#
+# When turning this feature on, you can add the following to bevy/Cargo.toml (not this file), and then run `cargo update`:
+# [patch.crates-io]
+# wgpu = { git = "https://github.com/gfx-rs/wgpu", rev = "..." }
+# wgpu-core = { git = "https://github.com/gfx-rs/wgpu", rev = "..." }
+# wgpu-hal = { git = "https://github.com/gfx-rs/wgpu", rev = "..." }
+# wgpu-types = { git = "https://github.com/gfx-rs/wgpu", rev = "..." }
+decoupled_naga = []
+
+[lints]
+workspace = true
+
+[package.metadata.docs.rs]
+rustdoc-args = ["-Zunstable-options", "--generate-link-to-definition"]
+all-features = true
diff --git a/crates/bevy_shader/LICENSE-APACHE b/crates/bevy_shader/LICENSE-APACHE
new file mode 100644
index 0000000000000..d9a10c0d8e868
--- /dev/null
+++ b/crates/bevy_shader/LICENSE-APACHE
@@ -0,0 +1,176 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
diff --git a/crates/bevy_shader/LICENSE-MIT b/crates/bevy_shader/LICENSE-MIT
new file mode 100644
index 0000000000000..9cf106272ac3b
--- /dev/null
+++ b/crates/bevy_shader/LICENSE-MIT
@@ -0,0 +1,19 @@
+MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/crates/bevy_shader/src/lib.rs b/crates/bevy_shader/src/lib.rs
new file mode 100644
index 0000000000000..539257f94b640
--- /dev/null
+++ b/crates/bevy_shader/src/lib.rs
@@ -0,0 +1,8 @@
+#![expect(missing_docs, reason = "Not all docs are written yet, see #3492.")]
+
+extern crate alloc;
+
+mod shader;
+mod shader_cache;
+pub use shader::*;
+pub use shader_cache::*;
diff --git a/crates/bevy_render/src/render_resource/shader.rs b/crates/bevy_shader/src/shader.rs
similarity index 93%
rename from crates/bevy_render/src/render_resource/shader.rs
rename to crates/bevy_shader/src/shader.rs
index 1be9fd7427568..3470e8c617e09 100644
--- a/crates/bevy_render/src/render_resource/shader.rs
+++ b/crates/bevy_shader/src/shader.rs
@@ -1,12 +1,37 @@
 use super::ShaderDefVal;
-use crate::define_atomic_id;
 use alloc::borrow::Cow;
 use bevy_asset::{io::Reader, Asset, AssetLoader, AssetPath, Handle, LoadContext};
 use bevy_reflect::TypePath;
-use core::marker::Copy;
+use core::{marker::Copy, num::NonZero};
 use thiserror::Error;
 
-define_atomic_id!(ShaderId);
+#[derive(Copy, Clone, Hash, Eq, PartialEq, PartialOrd, Ord, Debug)]
+pub struct ShaderId(NonZero<u32>);
+
+impl ShaderId {
+    #[expect(
+        clippy::new_without_default,
+        reason = "Implementing the `Default` trait on atomic IDs would imply that two `<AtomicIdType>::default()` equal each other. By only implementing `new()`, we indicate that each atomic ID created will be unique."
+    )]
+    pub fn new() -> Self {
+        use core::sync::atomic::{AtomicU32, Ordering};
+        static COUNTER: AtomicU32 = AtomicU32::new(1);
+        let counter = COUNTER.fetch_add(1, Ordering::Relaxed);
+        Self(NonZero::<u32>::new(counter).unwrap_or_else(|| {
+            panic!("The system ran out of unique `{}`s.", stringify!(ShaderId));
+        }))
+    }
+}
+impl From<ShaderId> for NonZero<u32> {
+    fn from(value: ShaderId) -> Self {
+        value.0
+    }
+}
+impl From<NonZero<u32>> for ShaderId {
+    fn from(value: NonZero<u32>) -> Self {
+        Self(value)
+    }
+}
 
 #[derive(Error, Debug)]
 pub enum ShaderReflectError {
@@ -45,8 +70,7 @@ pub enum ValidateShader {
     Enabled,
 }
 
-/// A shader, as defined by its [`ShaderSource`](wgpu::ShaderSource) and [`ShaderStage`](naga::ShaderStage)
-/// This is an "unprocessed" shader. It can contain preprocessor directives.
+/// An "unprocessed" shader. It can contain preprocessor directives.
 #[derive(Asset, TypePath, Debug, Clone)]
 pub struct Shader {
     pub path: String,
diff --git a/crates/bevy_shader/src/shader_cache.rs b/crates/bevy_shader/src/shader_cache.rs
new file mode 100644
index 0000000000000..89926c856ce0b
--- /dev/null
+++ b/crates/bevy_shader/src/shader_cache.rs
@@ -0,0 +1,547 @@
+use crate::shader::*;
+use alloc::sync::Arc;
+use bevy_asset::AssetId;
+use bevy_platform::collections::{hash_map::EntryRef, HashMap, HashSet};
+use core::hash::Hash;
+use naga::valid::Capabilities;
+use thiserror::Error;
+use tracing::{debug, error};
+use wgpu_types::{DownlevelFlags, Features};
+
+/// Source of a shader module.
+///
+/// The source will be parsed and validated.
+///
+/// Any necessary shader translation (e.g. from WGSL to SPIR-V or vice versa)
+/// will be done internally by wgpu.
+///
+/// This type is unique to the Rust API of `wgpu`. In the WebGPU specification,
+/// only WGSL source code strings are accepted.
+///
+/// This is roughly equivalent to `wgpu::ShaderSource`
+#[cfg_attr(
+    not(feature = "decoupled_naga"),
+    expect(
+        clippy::large_enum_variant,
+        reason = "naga modules are the most common use, and are large"
+    )
+)]
+#[derive(Clone, Debug)]
+pub enum ShaderCacheSource<'a> {
+    /// SPIR-V module represented as a slice of words.
+    SpirV(&'a [u8]),
+    /// WGSL module as a string slice.
+    Wgsl(String),
+    /// Naga module.
+    #[cfg(not(feature = "decoupled_naga"))]
+    Naga(naga::Module),
+}
+
+pub type CachedPipelineId = usize;
+
+struct ShaderData<ShaderModule> {
+    pipelines: HashSet<CachedPipelineId>,
+    processed_shaders: HashMap<Box<[ShaderDefVal]>, Arc<ShaderModule>>,
+    resolved_imports: HashMap<ShaderImport, AssetId<Shader>>,
+    dependents: HashSet<AssetId<Shader>>,
+}
+
+impl<T> Default for ShaderData<T> {
+    fn default() -> Self {
+        Self {
+            pipelines: Default::default(),
+            processed_shaders: Default::default(),
+            resolved_imports: Default::default(),
+            dependents: Default::default(),
+        }
+    }
+}
+
+pub struct ShaderCache<ShaderModule, RenderDevice> {
+    data: HashMap<AssetId<Shader>, ShaderData<ShaderModule>>,
+    load_module: fn(
+        &RenderDevice,
+        ShaderCacheSource,
+        &ValidateShader,
+    ) -> Result<ShaderModule, PipelineCacheError>,
+    #[cfg(feature = "shader_format_wesl")]
+    asset_paths: HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
+    shaders: HashMap<AssetId<Shader>, Shader>,
+    import_path_shaders: HashMap<ShaderImport, AssetId<Shader>>,
+    waiting_on_import: HashMap<ShaderImport, Vec<AssetId<Shader>>>,
+    pub composer: naga_oil::compose::Composer,
+}
+
+#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Debug, Hash)]
+pub enum ShaderDefVal {
+    Bool(String, bool),
+    Int(String, i32),
+    UInt(String, u32),
+}
+
+impl From<&str> for ShaderDefVal {
+    fn from(key: &str) -> Self {
+        ShaderDefVal::Bool(key.to_string(), true)
+    }
+}
+
+impl From<String> for ShaderDefVal {
+    fn from(key: String) -> Self {
+        ShaderDefVal::Bool(key, true)
+    }
+}
+
+impl ShaderDefVal {
+    pub fn value_as_string(&self) -> String {
+        match self {
+            ShaderDefVal::Bool(_, def) => def.to_string(),
+            ShaderDefVal::Int(_, def) => def.to_string(),
+            ShaderDefVal::UInt(_, def) => def.to_string(),
+        }
+    }
+}
+
+impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
+    pub fn new(
+        features: Features,
+        downlevel: DownlevelFlags,
+        load_module: fn(
+            &RenderDevice,
+            ShaderCacheSource,
+            &ValidateShader,
+        ) -> Result<ShaderModule, PipelineCacheError>,
+    ) -> Self {
+        let capabilities = get_capabilities(features, downlevel);
+        #[cfg(debug_assertions)]
+        let composer = naga_oil::compose::Composer::default();
+        #[cfg(not(debug_assertions))]
+        let composer = naga_oil::compose::Composer::non_validating();
+
+        let composer = composer.with_capabilities(capabilities);
+
+        Self {
+            composer,
+            load_module,
+            data: Default::default(),
+            #[cfg(feature = "shader_format_wesl")]
+            asset_paths: Default::default(),
+            shaders: Default::default(),
+            import_path_shaders: Default::default(),
+            waiting_on_import: Default::default(),
+        }
+    }
+
+    #[expect(
+        clippy::result_large_err,
+        reason = "See https://github.com/bevyengine/bevy/issues/19220"
+    )]
+    fn add_import_to_composer(
+        composer: &mut naga_oil::compose::Composer,
+        import_path_shaders: &HashMap<ShaderImport, AssetId<Shader>>,
+        shaders: &HashMap<AssetId<Shader>, Shader>,
+        import: &ShaderImport,
+    ) -> Result<(), PipelineCacheError> {
+        // Early out if we've already imported this module
+        if composer.contains_module(&import.module_name()) {
+            return Ok(());
+        }
+
+        // Check if the import is available (this handles the recursive import case)
+        let shader = import_path_shaders
+            .get(import)
+            .and_then(|handle| shaders.get(handle))
+            .ok_or(PipelineCacheError::ShaderImportNotYetAvailable)?;
+
+        // Recurse down to ensure all import dependencies are met
+        for import in &shader.imports {
+            Self::add_import_to_composer(composer, import_path_shaders, shaders, import)?;
+        }
+
+        composer.add_composable_module(shader.into())?;
+        // if we fail to add a module the composer will tell us what is missing
+
+        Ok(())
+    }
+
+    #[expect(
+        clippy::result_large_err,
+        reason = "See https://github.com/bevyengine/bevy/issues/19220"
+    )]
+    pub fn get(
+        &mut self,
+        render_device: &RenderDevice,
+        pipeline: CachedPipelineId,
+        id: AssetId<Shader>,
+        shader_defs: &[ShaderDefVal],
+    ) -> Result<Arc<ShaderModule>, PipelineCacheError> {
+        let shader = self
+            .shaders
+            .get(&id)
+            .ok_or(PipelineCacheError::ShaderNotLoaded(id))?;
+
+        let data = self.data.entry(id).or_default();
+        let n_asset_imports = shader
+            .imports()
+            .filter(|import| matches!(import, ShaderImport::AssetPath(_)))
+            .count();
+        let n_resolved_asset_imports = data
+            .resolved_imports
+            .keys()
+            .filter(|import| matches!(import, ShaderImport::AssetPath(_)))
+            .count();
+        if n_asset_imports != n_resolved_asset_imports {
+            return Err(PipelineCacheError::ShaderImportNotYetAvailable);
+        }
+
+        data.pipelines.insert(pipeline);
+
+        // PERF: this shader_defs clone isn't great. use raw_entry_mut when it stabilizes
+        let module = match data.processed_shaders.entry_ref(shader_defs) {
+            EntryRef::Occupied(entry) => entry.into_mut(),
+            EntryRef::Vacant(entry) => {
+                debug!(
+                    "processing shader {}, with shader defs {:?}",
+                    id, shader_defs
+                );
+                let shader_source = match &shader.source {
+                    Source::SpirV(data) => ShaderCacheSource::SpirV(data.as_ref()),
+                    #[cfg(feature = "shader_format_wesl")]
+                    Source::Wesl(_) => {
+                        if let ShaderImport::AssetPath(path) = shader.import_path() {
+                            let shader_resolver =
+                                ShaderResolver::new(&self.asset_paths, &self.shaders);
+                            let module_path = wesl::syntax::ModulePath::from_path(path);
+                            let mut compiler_options = wesl::CompileOptions {
+                                imports: true,
+                                condcomp: true,
+                                lower: true,
+                                ..Default::default()
+                            };
+
+                            for shader_def in shader_defs {
+                                match shader_def {
+                                    ShaderDefVal::Bool(key, value) => {
+                                        compiler_options.features.insert(key.clone(), *value);
+                                    }
+                                    _ => debug!(
+                                        "ShaderDefVal::Int and ShaderDefVal::UInt are not supported in wesl",
+                                    ),
+                                }
+                            }
+
+                            let compiled = wesl::compile(
+                                &module_path,
+                                &shader_resolver,
+                                &wesl::EscapeMangler,
+                                &compiler_options,
+                            )
+                            .unwrap();
+
+                            ShaderCacheSource::Wgsl(compiled.to_string())
+                        } else {
+                            panic!("Wesl shaders must be imported from a file");
+                        }
+                    }
+                    _ => {
+                        for import in shader.imports() {
+                            Self::add_import_to_composer(
+                                &mut self.composer,
+                                &self.import_path_shaders,
+                                &self.shaders,
+                                import,
+                            )?;
+                        }
+
+                        let shader_defs = shader_defs
+                            .iter()
+                            .chain(shader.shader_defs.iter())
+                            .map(|def| match def.clone() {
+                                ShaderDefVal::Bool(k, v) => {
+                                    (k, naga_oil::compose::ShaderDefValue::Bool(v))
+                                }
+                                ShaderDefVal::Int(k, v) => {
+                                    (k, naga_oil::compose::ShaderDefValue::Int(v))
+                                }
+                                ShaderDefVal::UInt(k, v) => {
+                                    (k, naga_oil::compose::ShaderDefValue::UInt(v))
+                                }
+                            })
+                            .collect::<std::collections::HashMap<_, _>>();
+
+                        let naga = self.composer.make_naga_module(
+                            naga_oil::compose::NagaModuleDescriptor {
+                                shader_defs,
+                                ..shader.into()
+                            },
+                        )?;
+
+                        #[cfg(not(feature = "decoupled_naga"))]
+                        {
+                            ShaderCacheSource::Naga(naga)
+                        }
+
+                        #[cfg(feature = "decoupled_naga")]
+                        {
+                            let mut validator = naga::valid::Validator::new(
+                                naga::valid::ValidationFlags::all(),
+                                self.composer.capabilities,
+                            );
+                            let module_info = validator.validate(&naga).unwrap();
+                            let wgsl = naga::back::wgsl::write_string(
+                                &naga,
+                                &module_info,
+                                naga::back::wgsl::WriterFlags::empty(),
+                            )
+                            .unwrap();
+                            ShaderCacheSource::Wgsl(wgsl)
+                        }
+                    }
+                };
+
+                let shader_module =
+                    (self.load_module)(render_device, shader_source, &shader.validate_shader)?;
+
+                entry.insert(Arc::new(shader_module))
+            }
+        };
+
+        Ok(module.clone())
+    }
+
+    fn clear(&mut self, id: AssetId<Shader>) -> Vec<CachedPipelineId> {
+        let mut shaders_to_clear = vec![id];
+        let mut pipelines_to_queue = Vec::new();
+        while let Some(handle) = shaders_to_clear.pop() {
+            if let Some(data) = self.data.get_mut(&handle) {
+                data.processed_shaders.clear();
+                pipelines_to_queue.extend(data.pipelines.iter().copied());
+                shaders_to_clear.extend(data.dependents.iter().copied());
+
+                if let Some(Shader { import_path, .. }) = self.shaders.get(&handle) {
+                    self.composer
+                        .remove_composable_module(&import_path.module_name());
+                }
+            }
+        }
+
+        pipelines_to_queue
+    }
+
+    pub fn set_shader(&mut self, id: AssetId<Shader>, shader: Shader) -> Vec<CachedPipelineId> {
+        let pipelines_to_queue = self.clear(id);
+        let path = shader.import_path();
+        self.import_path_shaders.insert(path.clone(), id);
+        if let Some(waiting_shaders) = self.waiting_on_import.get_mut(path) {
+            for waiting_shader in waiting_shaders.drain(..) {
+                // resolve waiting shader import
+                let data = self.data.entry(waiting_shader).or_default();
+                data.resolved_imports.insert(path.clone(), id);
+                // add waiting shader as dependent of this shader
+                let data = self.data.entry(id).or_default();
+                data.dependents.insert(waiting_shader);
+            }
+        }
+
+        for import in shader.imports() {
+            if let Some(import_id) = self.import_path_shaders.get(import).copied() {
+                // resolve import because it is currently available
+                let data = self.data.entry(id).or_default();
+                data.resolved_imports.insert(import.clone(), import_id);
+                // add this shader as a dependent of the import
+                let data = self.data.entry(import_id).or_default();
+                data.dependents.insert(id);
+            } else {
+                let waiting = self.waiting_on_import.entry(import.clone()).or_default();
+                waiting.push(id);
+            }
+        }
+
+        #[cfg(feature = "shader_format_wesl")]
+        if let Source::Wesl(_) = shader.source {
+            if let ShaderImport::AssetPath(path) = shader.import_path() {
+                self.asset_paths
+                    .insert(wesl::syntax::ModulePath::from_path(path), id);
+            }
+        }
+        self.shaders.insert(id, shader);
+        pipelines_to_queue
+    }
+
+    pub fn remove(&mut self, id: AssetId<Shader>) -> Vec<CachedPipelineId> {
+        let pipelines_to_queue = self.clear(id);
+        if let Some(shader) = self.shaders.remove(&id) {
+            self.import_path_shaders.remove(shader.import_path());
+        }
+
+        pipelines_to_queue
+    }
+}
+
+#[cfg(feature = "shader_format_wesl")]
+pub struct ShaderResolver<'a> {
+    asset_paths: &'a HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
+    shaders: &'a HashMap<AssetId<Shader>, Shader>,
+}
+
+#[cfg(feature = "shader_format_wesl")]
+impl<'a> ShaderResolver<'a> {
+    pub fn new(
+        asset_paths: &'a HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
+        shaders: &'a HashMap<AssetId<Shader>, Shader>,
+    ) -> Self {
+        Self {
+            asset_paths,
+            shaders,
+        }
+    }
+}
+
+#[cfg(feature = "shader_format_wesl")]
+impl<'a> wesl::Resolver for ShaderResolver<'a> {
+    fn resolve_source(
+        &self,
+        module_path: &wesl::syntax::ModulePath,
+    ) -> Result<alloc::borrow::Cow<str>, wesl::ResolveError> {
+        let asset_id = self.asset_paths.get(module_path).ok_or_else(|| {
+            wesl::ResolveError::ModuleNotFound(module_path.clone(), "Invalid asset id".to_string())
+        })?;
+
+        let shader = self.shaders.get(asset_id).unwrap();
+        Ok(alloc::borrow::Cow::Borrowed(shader.source.as_str()))
+    }
+}
+
+/// Type of error returned by a `PipelineCache` when the creation of a GPU pipeline object failed.
+#[cfg_attr(
+    not(target_arch = "wasm32"),
+    expect(
+        clippy::large_enum_variant,
+        reason = "See https://github.com/bevyengine/bevy/issues/19220"
+    )
+)]
+#[derive(Error, Debug)]
+pub enum PipelineCacheError {
+    #[error(
+        "Pipeline could not be compiled because the following shader could not be loaded: {0:?}"
+    )]
+    ShaderNotLoaded(AssetId<Shader>),
+    #[error(transparent)]
+    ProcessShaderError(#[from] naga_oil::compose::ComposerError),
+    #[error("Shader import not yet available.")]
+    ShaderImportNotYetAvailable,
+    #[error("Could not create shader module: {0}")]
+    CreateShaderModule(String),
+}
+
+// TODO: This needs to be kept up to date with the capabilities in the `create_validator` function in wgpu-core
+// https://github.com/gfx-rs/wgpu/blob/trunk/wgpu-core/src/device/mod.rs#L449
+// We can't use the `wgpu-core` function to detect the device's capabilities because `wgpu-core` isn't included in WebGPU builds.
+/// Get the device's capabilities for use in `naga_oil`.
+fn get_capabilities(features: Features, downlevel: DownlevelFlags) -> Capabilities {
+    let mut capabilities = Capabilities::empty();
+    capabilities.set(
+        Capabilities::PUSH_CONSTANT,
+        features.contains(Features::PUSH_CONSTANTS),
+    );
+    capabilities.set(
+        Capabilities::FLOAT64,
+        features.contains(Features::SHADER_F64),
+    );
+    capabilities.set(
+        Capabilities::PRIMITIVE_INDEX,
+        features.contains(Features::SHADER_PRIMITIVE_INDEX),
+    );
+    capabilities.set(
+        Capabilities::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING,
+        features.contains(Features::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING),
+    );
+    capabilities.set(
+        Capabilities::STORAGE_TEXTURE_ARRAY_NON_UNIFORM_INDEXING,
+        features.contains(Features::STORAGE_TEXTURE_ARRAY_NON_UNIFORM_INDEXING),
+    );
+    capabilities.set(
+        Capabilities::UNIFORM_BUFFER_ARRAY_NON_UNIFORM_INDEXING,
+        features.contains(Features::UNIFORM_BUFFER_BINDING_ARRAYS),
+    );
+    // TODO: This needs a proper wgpu feature
+    capabilities.set(
+        Capabilities::SAMPLER_NON_UNIFORM_INDEXING,
+        features.contains(Features::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING),
+    );
+    capabilities.set(
+        Capabilities::STORAGE_TEXTURE_16BIT_NORM_FORMATS,
+        features.contains(Features::TEXTURE_FORMAT_16BIT_NORM),
+    );
+    capabilities.set(
+        Capabilities::MULTIVIEW,
+        features.contains(Features::MULTIVIEW),
+    );
+    capabilities.set(
+        Capabilities::EARLY_DEPTH_TEST,
+        features.contains(Features::SHADER_EARLY_DEPTH_TEST),
+    );
+    capabilities.set(
+        Capabilities::SHADER_INT64,
+        features.contains(Features::SHADER_INT64),
+    );
+    capabilities.set(
+        Capabilities::SHADER_INT64_ATOMIC_MIN_MAX,
+        features.intersects(
+            Features::SHADER_INT64_ATOMIC_MIN_MAX | Features::SHADER_INT64_ATOMIC_ALL_OPS,
+        ),
+    );
+    capabilities.set(
+        Capabilities::SHADER_INT64_ATOMIC_ALL_OPS,
+        features.contains(Features::SHADER_INT64_ATOMIC_ALL_OPS),
+    );
+    capabilities.set(
+        Capabilities::MULTISAMPLED_SHADING,
+        downlevel.contains(DownlevelFlags::MULTISAMPLED_SHADING),
+    );
+    capabilities.set(
+        Capabilities::RAY_QUERY,
+        features.contains(Features::EXPERIMENTAL_RAY_QUERY),
+    );
+    capabilities.set(
+        Capabilities::DUAL_SOURCE_BLENDING,
+        features.contains(Features::DUAL_SOURCE_BLENDING),
+    );
+    capabilities.set(
+        Capabilities::CUBE_ARRAY_TEXTURES,
+        downlevel.contains(DownlevelFlags::CUBE_ARRAY_TEXTURES),
+    );
+    capabilities.set(
+        Capabilities::SUBGROUP,
+        features.intersects(Features::SUBGROUP | Features::SUBGROUP_VERTEX),
+    );
+    capabilities.set(
+        Capabilities::SUBGROUP_BARRIER,
+        features.intersects(Features::SUBGROUP_BARRIER),
+    );
+    capabilities.set(
+        Capabilities::SUBGROUP_VERTEX_STAGE,
+        features.contains(Features::SUBGROUP_VERTEX),
+    );
+    capabilities.set(
+        Capabilities::SHADER_FLOAT32_ATOMIC,
+        features.contains(Features::SHADER_FLOAT32_ATOMIC),
+    );
+    capabilities.set(
+        Capabilities::TEXTURE_ATOMIC,
+        features.contains(Features::TEXTURE_ATOMIC),
+    );
+    capabilities.set(
+        Capabilities::TEXTURE_INT64_ATOMIC,
+        features.contains(Features::TEXTURE_INT64_ATOMIC),
+    );
+    capabilities.set(
+        Capabilities::SHADER_FLOAT16,
+        features.contains(Features::SHADER_F16),
+    );
+    capabilities.set(
+        Capabilities::RAY_HIT_VERTEX_POSITION,
+        features.intersects(Features::EXPERIMENTAL_RAY_HIT_VERTEX_RETURN),
+    );
+
+    capabilities
+}
