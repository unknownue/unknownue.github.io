+++
title = "#22847 Small `EasyScreenRecordingPlugin` Usability Improvements: expose system set, more helpful `info`’s"
date = "2026-02-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22847-en-20260208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22847-zh-cn-20260208" }}
+++

# Title

## 基本资料
- **标题**: Small `EasyScreenRecordingPlugin` Usability Improvements: expose system set, more helpful `info`’s
- **PR链接**: https://github.com/bevyengine/bevy/pull/22847
- **作者**: kfc35
- **状态**: 已合并
- **标签**: C-Usability, S-Ready-For-Review, A-Dev-Tools, D-Straightforward
- **创建时间**: 2026-02-07T05:55:55Z
- **合并时间**: 2026-02-08T01:14:54Z
- **合并者**: mockersf

## 描述翻译
# 目标

- 修复 #22736

## 解决方案

- 为 `EasyScreenRecordingPlugin` 中运行的 `Update` 系统新增并暴露一个系统集 (`EasyScreenRecordSystems`)。对于应用行为依赖于虚拟时间 (`virtual time`)，并且希望该行为被录制下来的用户，他们应该让自己的 `Update` 系统在 `EasyScreenRecordSystems` 之后运行。
- 在测试录制功能时，我发现 `info` 日志信息可以稍作改进，因此我新增了一条并修改了另一条。

## 测试

- 我测试了 #22736 中的复现示例，并非常耐心地等待视频处理完成（一个6秒的视频花了5分钟来保存！不确定是不是只有我遇到这种情况... 可能值得为此提一个issue）。我使用 ffmpeg 将 h264 文件处理成 mp4 格式，最终结果符合我的预期。

## PR的故事

这个PR解决了一个在使用 `EasyScreenRecordingPlugin` 进行屏幕录制时可能遇到的微妙但重要的问题。当开发者尝试录制依赖于游戏内部“虚拟时间” (`virtual time`) 逻辑的应用时，如果录制系统与应用系统在调度顺序上处理不当，录制结果可能无法准确反映应用行为。

**问题与背景**
用户报告了一个问题（#22736），在录制过程中，某些依赖于 `Time<Virtual>` 的系统行为没有被正确捕获。`EasyScreenRecordingPlugin` 的工作原理是通过接管虚拟时间的推进来控制帧的捕获节奏。为了录制稳定的帧率视频，插件会暂停游戏主循环使用的虚拟时间，并以固定间隔手动推进它来生成帧。这个机制意味着，如果应用逻辑系统在录制系统之前运行，它们会看到一个“暂停”的时间，从而无法执行依赖于时间推进的行为。这些行为在最终录制的视频中就会丢失。

**解决方案思路**
根本原因在于调度顺序的确定性。Bevy的调度器允许开发者通过系统集 (`SystemSet`) 和顺序约束（如 `.before()` 或 `.after()`）来精确控制系统的执行顺序。原插件内部的系统被添加到调度中，但没有暴露给用户一个明确的“锚点”（hook），使得用户无法可靠地将自己的系统安排在录制系统之后执行。

最直接的解决方案就是定义一个公开的系统集，将插件的核心系统归入其中。这样，用户就可以通过 `.after(EasyScreenRecordSystems)` 来明确指定他们的系统应在录制逻辑完成后运行。这种方法非侵入性，保持了插件的封装性，同时提供了必要的灵活性。

**实现细节**
实现非常简单，主要分为两步：
1.  **定义并暴露系统集**：新增了一个名为 `EasyScreenRecordSystems` 的单元结构体，并使用 `#[derive(SystemSet, ...)]` 宏将其定义为系统集。为其添加了详细的文档注释，解释了它的用途和开发者应如何使用它。
2.  **将插件系统归入该集合**：在 `app.add_systems(Update, ...)` 的链式调用末尾，添加了 `.in_set(EasyScreenRecordSystems)`。这确保了插件所有用于控制录制和发送帧的系统都属于这个集合。

此外，作者在测试过程中发现，插件在停止录制时打印的日志信息 (`"stopping recording"`) 可能具有误导性。因为停止指令发出后，视频编码和文件写入操作（这是一个可能耗时的过程）仍在后台线程进行。为了提供更准确的用户反馈，作者改进了日志：
- 将原 `"stopping recording"` 信息移到了停止指令发送和虚拟时间恢复之后，并改为 `"stopped recording. still processing video"`，明确告知用户录制已停止但视频正在处理。
- 在后台线程完成所有数据写入并关闭文件后，新增了一条 `"finished processing video"` 的日志，为用户提供一个明确的完成信号。

**技术影响与意义**
这个改动虽然很小，但体现了良好的API设计原则：**提供明确的扩展点**。它解决了插件“黑盒”化导致用户无法与调度器集成的痛点。现在，依赖于精确时序逻辑的模拟、动画或游戏机制，在录制时可以得到正确的表现。

从工程模式来看，这是一个典型的“暴露控制系统执行顺序的句柄”的模式。当编写一个包含复杂内部状态的插件或模块时，如果这些内部状态会影响全局环境（如时间），那么提供一个让外部系统能够安排在正确时机运行的机制是至关重要的。这避免了用户需要 fork 或深度修改插件代码，提升了代码的可维护性和生态的友好性。

## 可视化表示

```mermaid
graph TD
    subgraph “Update Schedule”
        A[用户自定义系统 (默认顺序)] --> B;
        B[EasyScreenRecordSystems] --> C[用户自定义系统 (依赖虚拟时间)];
    end

    subgraph “EasyScreenRecordSystems 内部”
        B1[处理录制开始/停止指令] --> B2[控制 Virtual Time] --> B3[向编码线程发送帧];
    end

    subgraph “后台线程”
        B3 --> D[视频编码与文件写入];
    end

    C -.->|依赖| B2;
```
*图示说明：在 `Update` 调度阶段，`EasyScreenRecordSystems` 系统集作为中间节点。需要被正确录制的、依赖虚拟时间的用户系统，必须被配置在此系统集之后运行。*

## 关键文件更改

- **文件**: `crates/bevy_dev_tools/src/easy_screenshot.rs` (+19 行, -2 行)

1.  **更改描述与原因**:
    - **主要更改 (新增系统集)**: 定义了 `EasyScreenRecordSystems` 系统集并将其暴露给用户。这允许用户精确控制其系统相对于屏幕录制系统的执行顺序，确保依赖虚拟时间的行为能被正确录制。
    - **次要更改 (改进日志)**: 调整了两条 `info!` 日志的信息，使其更准确地反映录制状态（“已停止录制，正在处理” vs “处理完成”），提升了用户体验。

2.  **关键代码片段**:
    ```rust
    // 文件: crates/bevy_dev_tools/src/easy_screenshot.rs
    // 新增: 定义并暴露系统集
    #[cfg(feature = "screenrecording")]
    /// The [`Update`] systems that the [`EasyScreenRecordPlugin`] runs
    /// to start and stop recording on user command and
    /// to send frames to the thread that manages video file creation.
    /// These systems manipulate [`virtual`](bevy_time::Virtual)
    /// [`time`](bevy_time::Time) in order to capture frames for video.
    ///
    /// If any application [`Update`] systems have behavior that depend
    /// on virtual time and must be recorded, ensure that these systems run
    /// [`after(EasyScreenRecordSystems)`](bevy_ecs::schedule::IntoScheduleConfigs::after).
    /// The application may run slower on screen during recording,
    /// but the video playback will be at normal speed.
    #[derive(SystemSet, Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct EasyScreenRecordSystems;

    // 在插件构建方法内部，将系统添加到调度器时，将其归入新创建的系统集
    app.add_systems(Update,
        (/* ... 一系列系统函数 ... */)
            .chain()
            .in_set(EasyScreenRecordSystems), // 新增此行
    );
    ```
    ```rust
    // 改进日志信息
    // 之前 (在`RecordCommand::Stop`匹配分支):
    // info!("stopping recording");
    
    // 之后:
    // 在停止指令处理逻辑中（恢复虚拟时间后）:
    info!("stopped recording. still processing video");
    
    // 在后台线程完成文件写入后:
    info!("finished processing video");
    ```

3.  **与PR目标的关联**:
    - 新增的 `EasyScreenRecordSystems` 直接解决了 #22736 的问题，为用户提供了控制调度顺序的明确手段。
    - 改进的日志信息是对PR描述中“可用性改进” (`Usability Improvements`) 的补充，使插件的状态反馈更加清晰，尤其在处理可能耗时的视频编码时。

## 进一步阅读

- **Bevy 官方文档 - 调度 (Scheduling)**: 了解系统、系统集、阶段和运行条件的核心概念。
- **Bevy 官方文档 - 时间 (Time)**: 理解虚拟时间 (`Virtual`)、实时 (`Real`) 和固定更新时间 (`FixedUpdate`) 的区别与用途。
- **GitHub Issue #22736**: 查看这个PR要解决的具体问题及其复现代码，以获得更具体的上下文。
- **Rust 宏 `#[derive(SystemSet)]`**: 了解 Bevy ECS 如何利用 Rust 的派生宏来简化系统集的定义。