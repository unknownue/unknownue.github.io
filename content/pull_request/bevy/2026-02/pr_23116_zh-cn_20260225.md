+++
title = "#23116 Create an example to show generating assets at runtime."
date = "2026-02-25T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23116-en-20260225" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23116-zh-cn-20260225" }}
+++

# Title
## 基本 Information
- **标题**: Create an example to show generating assets at runtime.
- **PR 链接**: https://github.com/bevyengine/bevy/pull/23116
- **作者**: andriyDev
- **状态**: 已合并 (MERGED)
- **标签**: C-Examples, A-Assets, S-Ready-For-Final-Review, X-Uncontroversial, D-Straightforward
- **创建时间**: 2026-02-23T03:06:19Z
- **合并时间**: 2026-02-25T08:17:01Z
- **合并人**: alice-i-cecile

## Description Translation
**目标**
- 展示如何在运行时创建资产。
- https://discord.com/channels/691052431525675048/691052431974465548/1475244907047424236

**解决方案**
- 创建一个示例。

**测试**
- 示例运行正常！

## The Story of This Pull Request

这个 Pull Request 源于社区的一个具体需求。在 Bevy 引擎的 Discord 频道中，有开发者询问如何在运行时生成资产（assets）。Bevy 的资产系统是其核心功能之一，它通常用于加载和管理来自文件（如图片、模型）的静态资源。然而，在游戏或应用运行时动态创建资产也是一个常见需求，例如程序化生成地形网格（mesh）、创建动态材质，或者根据用户输入合成纹理。

尽管 Bevy 的 API 已经支持这些操作，但当时缺少一个清晰、集中的示例来演示实现模式。没有官方示例意味着开发者需要自己钻研 `Assets<T>`、`Handle<T>` 和 `AssetServer` 等类型的文档来拼凑解决方案，这增加了学习成本和出错的可能性。

PR 作者 andriyDev 识别到这个缺口，并决定提供一个实用的、可直接运行的示例来填补它。这个示例的目的不是引入新功能，而是充当一份“烹饪指南”，将分散在 API 中的功能组合起来，展示几种不同的、惯用的运行时资产生成方法。

解决方案非常直接：在 `examples/asset/` 目录下创建一个名为 `generated_assets.rs` 的新示例。这个示例程序在场景中生成三个 3D 物体，每个物体都使用一种不同的运行时资产生成策略来创建其网格。

让我们深入看代码实现。示例从一个典型的 3D 场景设置开始：添加摄像机、方向光，以及用于所有物体的共享默认材质。关键在于生成网格的三种方式：

1.  **直接插入（Direct Insertion）**：这是最简单的方法。代码直接获取 `ResMut<Assets<Mesh>>` 资源，并调用其 `add` 方法。这个方法接受一个 `Mesh` 实例，将其添加到资产存储中，并立即返回一个 `Handle<Mesh>`。这种方式是同步且即时的，适合生成过程简单快速的资产。

    ```rust
    // 在 setup 系统中
    let material_handle = materials.add(StandardMaterial::default());
    ```

2.  **异步生成（Async Generation）**：有些资产的生成过程可能很耗时（例如，从网络下载或复杂的计算）。Bevy 的 `AssetServer` 提供了 `add_async` 函数来处理这种情况。你传递给它一个返回 `Future<Output = Result<T, std::io::Error>>` 的异步函数。这个任务会在后台执行，当 `Future` 完成时，其结果会被添加到资产存储中。文档注释特别指出，这是“延迟的”（deferred），意味着资产可能在任务完成后的下一帧才可用。这对于保持主线程响应性非常重要。

    ```rust
    Mesh3d(asset_server.add_async(generate_mesh_async())),
    ...
    async fn generate_mesh_async() -> Result<Mesh, std::io::Error> {
        Ok(Mesh::from(Cone::new(1.0, 2.0)))
    }
    ```

3.  **预留句柄与后续填充（Reserved Handle with Delayed Insertion）**：第三种方法展示了更高级的控制流程。首先，使用 `Assets::reserve_handle` 方法预先分配一个 `Handle<Mesh>`，但这个句柄此时并未关联任何实际数据。这个句柄可以被立即使用，例如添加到实体中。然后，我们将这个句柄存储在一个自定义的 `Resource`（`HandleToGenerate`）中。最后，一个单独的系统（`generate_mesh_system`）在后续的更新循环中运行，它获取这个资源中的句柄和可变的 `Assets<Mesh>` 资源，并使用 `insert` 方法将实际生成的 `Mesh` 数据与预留的句柄关联起来。这种模式的强大之处在于，生成资产的系统可以访问 `World` 中的其他数据来决定如何生成资产，实现了数据驱动的资产创建。

    ```rust
    let mesh_handle = meshes.reserve_handle();
    commands.insert_resource(HandleToGenerate(mesh_handle.clone()));
    ...
    fn generate_mesh_system(
        handle_to_generate: Res<HandleToGenerate>,
        mut meshes: ResMut<Assets<Mesh>>,
    ) {
        let mesh = Mesh::from(Torus::new(0.8, 1.2));
        meshes.insert(&handle_to_generate.0, mesh).unwrap();
    }
    ```

这个示例在技术上的一个精妙之处是 `generate_mesh_system` 使用了 `.run_if(run_once)` 条件。`run_once` 是一个内置的条件，确保该系统仅执行一次。这对于“初始化”类型的任务非常合适，避免了每帧都尝试插入资产（这会导致错误，因为句柄在插入一次后就会被填充）。

最终，这个 PR 成功地将一个常见的开发问题转化为一个自包含的、文档齐全的解决方案。它没有修改引擎的核心逻辑，而是通过添加教育性内容来增强项目。代码清晰、注释详尽，并演示了关键概念：`Assets<T>` 作为存储、`Handle<T>` 作为引用、`AssetServer` 用于管理生命周期，以及如何将资源（Resources）和系统（Systems）协调起来完成动态任务。合并这个示例后，任何寻找“如何在 Bevy 中运行时创建网格？”的开发者都能快速找到一个权威答案。

## Visual Representation

```mermaid
graph TD
    subgraph “初始化 (Startup)”
        S[setup 系统]
        S --> D[直接添加材质]
        S --> A[AssetServer.add_async]
        S --> R[meshes.reserve_handle]
        R --> H[创建 HandleToGenerate 资源]
    end

    subgraph “运行时”
        A --> |后台任务| GA[generate_mesh_async 函数]
        GA --> |完成| AS[AssetStorage]
    end

    subgraph “首次更新 (First Update)”
        G[generate_mesh_system]
        H --> |提供句柄| G
        G --> |插入网格| AS
    end

    AS --> |被句柄引用| E[实体渲染]
```

## Key Files Changed

1.  **文件**: `examples/asset/generated_assets.rs` (+71/-0)
    *   **描述**: 这是本次 PR 创建的核心示例文件。它完整地演示了三种在运行时生成并存储资产的方法。
    *   **关键代码片段**:
        ```rust
        // 1. 直接添加
        let material_handle = materials.add(StandardMaterial::default());

        // 2. 异步添加
        Mesh3d(asset_server.add_async(generate_mesh_async())),

        // 3. 预留句柄并后续填充
        let mesh_handle = meshes.reserve_handle();
        commands.insert_resource(HandleToGenerate(mesh_handle.clone()));
        // ... 在另一个系统中 ...
        meshes.insert(&handle_to_generate.0, mesh).unwrap();
        ```

2.  **文件**: `Cargo.toml` (+11/-0)
    *   **描述**: 在 Bevy 工作区的 `Cargo.toml` 中添加了新示例的配置项，使其可以通过 `cargo run --example generated_assets` 命令运行，并设置了相关的元数据（如分类、描述）。
    *   **关键代码片段**:
        ```toml
        [[example]]
        name = "generated_assets"
        path = "examples/asset/generated_assets.rs"
        doc-scrape-examples = true

        [package.metadata.example.generated_assets]
        name = "Generated Assets"
        description = "Shows how to generate and store assets at runtime"
        category = "Assets"
        wasm = true
        ```

3.  **文件**: `examples/README.md` (+1/-0)
    *   **描述**: 在示例目录的 README 文件中添加了新示例的条目和链接，确保文档的完整性，方便用户浏览发现。
    *   **关键代码片段**:
        ```markdown
        | [Generated Assets](../examples/asset/generated_assets.rs) | Shows how to generate and store assets at runtime
        ```

## Further Reading
*   **Bevy 官方文档 - Assets**: 深入了解 Bevy 资产系统的核心概念、`AssetServer` 和 `Handle` 的工作原理。
*   **Bevy 示例 - `custom_asset_io.rs`**: 了解如何实现自定义的资产读写逻辑，是资产系统更底层的扩展。
*   **Bevy 示例 - `hot_asset_reloading.rs`**: 学习 Bevy 强大的热重载机制，与运行时生成结合可以构建动态内容管道。
*   **Rust 异步编程 (Async/Await)**: 理解示例中 `add_async` 方法背后所使用的 Rust 异步编程模型，对于处理 I/O 密集型资产生成任务至关重要。

# Full Code Diff
（已在上述“关键文件更改”部分包含主要差异，完整差异请参见 PR 链接。）