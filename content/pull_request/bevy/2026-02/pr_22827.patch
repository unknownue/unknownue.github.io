diff --git a/crates/bevy_core_pipeline/src/oit/resolve/oit_resolve.wgsl b/crates/bevy_core_pipeline/src/oit/resolve/oit_resolve.wgsl
index ae5e5264e7025..a47d6e8d0a7dc 100644
--- a/crates/bevy_core_pipeline/src/oit/resolve/oit_resolve.wgsl
+++ b/crates/bevy_core_pipeline/src/oit/resolve/oit_resolve.wgsl
@@ -82,13 +82,8 @@ fn resolve(head: u32, opaque_depth: f32) -> vec4<f32> {
             // There is still room in the sorted list.
             // Insert the fragment so that the list stay sorted.
             var i = sorted_frag_count;
-            for(; i > 0; i -= 1) {
-                // short-circuit can't be used in for(;;;), https://github.com/gfx-rs/wgpu/issues/4394
-                if fragment_node.depth_alpha > fragment_list[i - 1].depth_alpha {
-                    fragment_list[i] = fragment_list[i - 1];
-                } else {
-                    break;
-                }
+            for (; i > 0 && fragment_node.depth_alpha > fragment_list[i - 1].depth_alpha; i -= 1) {
+                fragment_list[i] = fragment_list[i - 1];
             }
             fragment_list[i].color = fragment_node.color;
             fragment_list[i].depth_alpha = fragment_node.depth_alpha;
@@ -102,13 +97,8 @@ fn resolve(head: u32, opaque_depth: f32) -> vec4<f32> {
             let nearest_alpha = packed_depth_alpha_get_alpha(fragment_list[0].depth_alpha);
             final_color = blend(final_color, vec4f(nearest_color * nearest_alpha, nearest_alpha));
             var i = 0u;
-            for(; i < SORTED_FRAGMENT_MAX_COUNT - 1; i += 1) {
-                // short-circuit can't be used in for(;;;), https://github.com/gfx-rs/wgpu/issues/4394
-                if fragment_node.depth_alpha < fragment_list[i + 1].depth_alpha {
-                    fragment_list[i] = fragment_list[i + 1];
-                } else {
-                    break;
-                }
+            for (; i < SORTED_FRAGMENT_MAX_COUNT - 1 && fragment_node.depth_alpha < fragment_list[i + 1].depth_alpha; i += 1) {
+                fragment_list[i] = fragment_list[i + 1];
             }
             fragment_list[i].color = fragment_node.color;
             fragment_list[i].depth_alpha = fragment_node.depth_alpha;
diff --git a/crates/bevy_pbr/src/render/mesh_preprocess.wgsl b/crates/bevy_pbr/src/render/mesh_preprocess.wgsl
index aec0226cf7bbf..4145e1af0eea8 100644
--- a/crates/bevy_pbr/src/render/mesh_preprocess.wgsl
+++ b/crates/bevy_pbr/src/render/mesh_preprocess.wgsl
@@ -187,10 +187,7 @@ fn main(@builtin(global_invocation_id) global_invocation_id: vec3<u32>) {
     // `MeshInput` into the appropriate slot so that the indirect parameters
     // building shader can access it.
 #ifndef LATE_PHASE
-    // https://github.com/gfx-rs/wgpu/issues/4394
-    if (instance_index == 0u) {
-        indirect_parameters_gpu_metadata[indirect_parameters_index].mesh_index = input_index;
-    } else if (work_items[instance_index - 1].output_or_indirect_parameters_index != indirect_parameters_index) {
+    if (instance_index == 0u) || (work_items[instance_index - 1].output_or_indirect_parameters_index != indirect_parameters_index) {
         indirect_parameters_gpu_metadata[indirect_parameters_index].mesh_index = input_index;
     }
 #endif  // LATE_PHASE
