+++
title = "#22832 SystemBuffer` `apply()` delegates to `queue()`, which now must be implemented"
date = "2026-02-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22832-en-20260207" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22832-zh-cn-20260207" }}
+++

# SystemBuffer `apply()` delegates to `queue()`, which now must be implemented

## 基本信息
- **标题**: `SystemBuffer` `apply()` delegates to `queue()`, which now must be implemented
- **PR链接**: https://github.com/bevyengine/bevy/pull/22832
- **作者**: kfc35
- **状态**: MERGED
- **标签**: A-ECS, C-Usability, S-Ready-For-Final-Review, M-Migration-Guide, D-Straightforward
- **创建时间**: 2026-02-06T21:23:31Z
- **合并时间**: 2026-02-07T19:50:40Z
- **合并者**: alice-i-cecile

## 描述翻译
### 目标
- 防止在 Observer（观察者）模式及相关模式中使用 `SystemBuffer` 时因未实现 `queue()` 而导致的陷阱（footguns）。如果未实现，将导致对世界的更改不被应用，这可能会造成混淆，并且用户不容易意识到他们还需要实现 `queue()` 来解决这个问题。
- 解决部分 #14597 中提到的问题。

### 解决方案
- `SystemBuffer` trait 现在将其 `apply()` 的默认实现委托给 `queue()`。这应该覆盖了大多数用户希望 `apply()` 和 `queue()` 行为相同的情况，特别是当 `apply()` 不应用任何 ECS 结构更改时。
- `queue()` 移除了其空的默认实现，要求实现者必须实现它。
- 代码库中的其他 `SystemBuffer` 已根据我的能力和对 ECS 的理解进行了更新。

### 测试
CI，并运行了以下示例：`bloom_3d`、`3d_gizmos` 和 `lighting` 以确保渲染正常（它们看起来正常）。

## 这个Pull Request的故事

这个 PR 源于 Bevy ECS 中 `SystemBuffer` 的一个设计缺陷，该缺陷在 Observer（观察者）模式中尤其明显。`SystemBuffer` 是用于延迟世界修改的系统参数，它有两个关键方法：`apply()` 用于立即应用更改，`queue()` 用于将更改排队到稍后应用。

问题的核心在于，当 `SystemBuffer` 在 Observer 模式下使用时，系统会调用 `queue()` 而不是 `apply()`。然而，`queue()` 方法有一个空的默认实现。如果一个开发者只实现了 `apply()` 而没有实现 `queue()`，他们的系统在 Observer 上下文中将无声无息地失败 - 更改不会被排队，因此永远不会被应用。

这个缺陷在 issue #14597 中被提出。开发者可能会花费大量时间调试为什么他们的更改没有生效，而问题根源并不明显。

为了解决这个问题，作者采用了两个关键修改。首先，将 `SystemBuffer` trait 中的 `apply()` 改为默认实现，该实现直接委托给 `queue()` 方法。这意味着现在 `queue()` 成为了必须实现的主要方法。其次，移除了 `queue()` 的默认实现，强制所有实现者必须提供具体的实现。

这个设计的合理性在于，大多数 `SystemBuffer` 实现并不需要改变 ECS 的结构（如添加/移除组件），它们只是修改现有的资源或组件数据。对于这些情况，`apply()` 和 `queue()` 可以执行相同的操作，只是参数类型不同：`apply()` 接收 `&mut World`，而 `queue()` 接收 `DeferredWorld`。

对于那些确实需要改变 ECS 结构的 `SystemBuffer`，现在需要显式实现 `apply()` 来执行结构更改，同时实现 `queue()` 来通过命令队列排队这些结构更改。这通过编译时检查确保了正确性。

在具体实现上，作者更新了 Bevy 代码库中所有现有的 `SystemBuffer` 实现。这些更新展示了如何将现有的 `apply()` 实现迁移到 `queue()` 实现。例如，在 `DiagnosticsBuffer` 中，原来的 `apply()` 方法被重命名为 `queue()`，参数类型从 `&mut World` 改为 `DeferredWorld`。类似地，`ParallelCommandQueue` 现在同时实现了 `apply()` 和 `queue()`，其中 `queue()` 使用 `world.commands().append(cq)` 来排队命令。

这些更改确保了当 `SystemBuffer` 用于 Observer 模式时，更改会被正确排队和应用。通过将潜在的错误从运行时转移到编译时，这个 PR 显著提高了 API 的健壮性。开发者现在在实现 `SystemBuffer` 时必须考虑 `queue()` 方法，这避免了 Observer 模式下无声失败的陷阱。

从架构角度看，这个修改使 `SystemBuffer` 的设计更加一致和直观。`queue()` 现在成为了主要的扩展点，而 `apply()` 提供了向后兼容的默认行为。迁移指南清楚地解释了如何更新现有的实现，包括处理结构更改的特殊情况。

这个 PR 展示了良好的 API 设计原则：通过编译时检查防止常见错误，提供清晰的迁移路径，以及在保持向后兼容性的同时改进设计。它解决了实际开发中的痛点，使 Bevy ECS 更加可靠和用户友好。

## 视觉表示

```mermaid
graph TD
    A[SystemBuffer Trait] --> B[apply() 方法]
    A --> C[queue() 方法]
    B --> D[默认实现委托给 queue()]
    C --> E[必须被实现]
    E --> F[Observer 模式使用]
    D --> G[普通系统使用]
    
    H[Existing Implementations] --> I[DiagnosticsBuffer]
    H --> J[ParallelCommandQueue]
    H --> K[GizmoBuffer]
    H --> L[RenderContextState]
    
    I --> M[更新为实现 queue()]
    J --> N[添加 queue() 实现]
    K --> O[更新为实现 queue()]
    L --> P[更新为实现 queue()]
```

## 关键文件更改

1. **`crates/bevy_ecs/src/system/system_param.rs`** (+9/-3)
   - 修改了 `SystemBuffer` trait 的定义，使 `apply()` 默认委托给 `queue()`，并移除 `queue()` 的默认实现
   - 添加了关于如何使用 `DeferredWorld` 的命令队列进行结构更改的文档

```rust
// 修改前:
pub trait SystemBuffer: FromWorld + Send + 'static {
    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World);
    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld) {}
}

// 修改后:
pub trait SystemBuffer: FromWorld + Send + 'static {
    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
        self.queue(system_meta, world.into());
    }
    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld);
}
```

2. **`crates/bevy_diagnostic/src/diagnostic.rs`** (+2/-2)
   - 将 `DiagnosticsBuffer` 从实现 `apply()` 改为实现 `queue()`
   - 参数类型从 `&mut World` 改为 `DeferredWorld`

```rust
// 修改前:
impl SystemBuffer for DiagnosticsBuffer {
    fn apply(
        &mut self,
        _system_meta: &bevy_ecs::system::SystemMeta,
        world: &mut bevy_ecs::world::World,
    ) { /* ... */ }
}

// 修改后:
impl SystemBuffer for DiagnosticsBuffer {
    fn queue(
        &mut self,
        _system_meta: &bevy_ecs::system::SystemMeta,
        mut world: bevy_ecs::world::DeferredWorld,
    ) { /* ... */ }
}
```

3. **`crates/bevy_ecs/src/system/commands/parallel_scope.rs`** (+10/-0)
   - 为 `ParallelCommandQueue` 添加了 `queue()` 实现
   - 使用 `world.commands().append(cq)` 来排队命令

```rust
impl SystemBuffer for ParallelCommandQueue {
    #[inline]
    fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
        #[cfg(feature = "trace")]
        let _system_span = _system_meta.commands_span.enter();
        for cq in self.thread_queues.iter_mut() {
            world.commands().append(cq);
        }
    }
}
```

4. **`crates/bevy_gizmos/src/gizmos.rs`** (+2/-2)
   - 将 `GizmoBuffer` 的 `apply()` 方法改为 `queue()`
   - 参数类型相应更改

5. **`release-content/migration-guides/system_buffer_queue.md`** (+33/-0)
   - 新增迁移指南，解释如何更新 `SystemBuffer` 实现
   - 提供了代码示例和两种情况的处理方式

## 进一步阅读

1. [Bevy ECS 系统文档](https://docs.rs/bevy_ecs/latest/bevy_ecs/system/index.html) - 了解 Bevy ECS 系统的工作原理
2. [Observer 模式文档](https://docs.rs/bevy_ecs/latest/bevy_ecs/observer/index.html) - 了解 Observer 模式在 Bevy 中的应用
3. [DeferredWorld API 文档](https://docs.rs/bevy_ecs/latest/bevy_ecs/world/struct.DeferredWorld.html) - 理解 `DeferredWorld` 的工作原理
4. [Issue #14597](https://github.com/bevyengine/bevy/issues/14597) - 这个 PR 解决的原问题

## 完整代码差异

```diff
diff --git a/crates/bevy_diagnostic/src/diagnostic.rs b/crates/bevy_diagnostic/src/diagnostic.rs
index 17943ae60d308..0a8ed6a73c0bf 100644
--- a/crates/bevy_diagnostic/src/diagnostic.rs
+++ b/crates/bevy_diagnostic/src/diagnostic.rs
@@ -376,10 +376,10 @@ impl<'w, 's> Diagnostics<'w, 's> {
 struct DiagnosticsBuffer(HashMap<DiagnosticPath, DiagnosticMeasurement, PassHash>);
 
 impl SystemBuffer for DiagnosticsBuffer {
-    fn apply(
+    fn queue(
         &mut self,
         _system_meta: &bevy_ecs::system::SystemMeta,
-        world: &mut bevy_ecs::world::World,
+        mut world: bevy_ecs::world::DeferredWorld,
     ) {
         let Some(mut diagnostics) = world.get_resource_mut::<DiagnosticsStore>() else {
             // `SystemBuffer::apply` is called even if the system never runs. If a user uses
diff --git a/crates/bevy_ecs/src/system/commands/parallel_scope.rs b/crates/bevy_ecs/src/system/commands/parallel_scope.rs
index f5ad7a69a3d57..5fb2dbeddecec 100644
--- a/crates/bevy_ecs/src/system/commands/parallel_scope.rs
+++ b/crates/bevy_ecs/src/system/commands/parallel_scope.rs
@@ -4,6 +4,7 @@ use crate::{
     entity::{Entities, EntityAllocator},
     prelude::World,
     system::{Deferred, SystemBuffer, SystemMeta, SystemParam},
+    world::DeferredWorld,
 };
 
 use super::{CommandQueue, Commands};
@@ -64,6 +65,15 @@ impl SystemBuffer for ParallelCommandQueue {
             cq.apply(world);
         }
     }
+
+    #[inline]
+    fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
+        #[cfg(feature = "trace")]
+        let _system_span = _system_meta.commands_span.enter();
+        for cq in self.thread_queues.iter_mut() {
+            world.commands().append(cq);
+        }
+    }
 }
 
 impl<'w, 's> ParallelCommands<'w, 's> {
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index dd1c116c3c731..8b756b0d92045 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -1179,9 +1179,14 @@ unsafe impl<'a, T: FromWorld + Send + 'static> SystemParam for Local<'a, T> {
 /// so you should try to minimize the time spent in [`SystemBuffer::apply`].
 pub trait SystemBuffer: FromWorld + Send + 'static {
     /// Applies any deferred mutations to the [`World`].
-    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World);
+    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+        self.queue(system_meta, world.into());
+    }
     /// Queues any deferred mutations to be applied at the next [`ApplyDeferred`](crate::prelude::ApplyDeferred).
-    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld) {}
+    ///
+    /// To queue structural changes to [`DeferredWorld`], a command queue of the [`DeferredWorld`]
+    /// should be used via [`commands`](crate::world::DeferredWorld::commands).
+    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld);
 }
 
 /// A [`SystemParam`] that stores a buffer which gets applied to the [`World`] during
@@ -1202,6 +1207,7 @@ pub trait SystemBuffer: FromWorld + Send + 'static {
 ///
 /// ```
 /// # use bevy_ecs::prelude::*;
+/// # use bevy_ecs::world::DeferredWorld;
 /// // Tracks whether or not there is a threat the player should be aware of.
 /// #[derive(Resource, Default)]
 /// pub struct Alarm(bool);
@@ -1237,7 +1243,7 @@ pub trait SystemBuffer: FromWorld + Send + 'static {
 /// impl SystemBuffer for AlarmFlag {
 ///     // When `AlarmFlag` is used in a system, this function will get
 ///     // called the next time buffers are applied via ApplyDeferred.
-///     fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+///     fn queue(&mut self, system_meta: &SystemMeta, mut world: DeferredWorld) {
 ///         if self.0 {
 ///             world.resource_mut::<Alarm>().0 = true;
 ///             self.0 = false;
diff --git a/crates/bevy_gizmos/src/gizmos.rs b/crates/bevy_gizmos/src/gizmos.rs
index b16ed88f3ebc0..cb368561787a5 100644
--- a/crates/bevy_gizmos/src/gizmos.rs
+++ b/crates/bevy_gizmos/src/gizmos.rs
@@ -16,7 +16,7 @@ use bevy_ecs::{
         Deferred, ReadOnlySystemParam, Res, SystemBuffer, SystemMeta, SystemParam,
         SystemParamValidationError,
     },
-    world::{unsafe_world_cell::UnsafeWorldCell, World},
+    world::{unsafe_world_cell::UnsafeWorldCell, DeferredWorld, World},
 };
 use bevy_math::{bounding::Aabb3d, Isometry2d, Isometry3d, Vec2, Vec3};
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
@@ -347,7 +347,7 @@ where
     Config: GizmoConfigGroup,
     Clear: 'static + Send + Sync,
 {
-    fn apply(&mut self, _system_meta: &SystemMeta, world: &mut World) {
+    fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
         let mut storage = world.resource_mut::<GizmoStorage<Config, Clear>>();
         storage.list_positions.append(&mut self.list_positions);
         storage.list_colors.append(&mut self.list_colors);
diff --git a/crates/bevy_render/src/renderer/render_context.rs b/crates/bevy_render/src/renderer/render_context.rs
index 6ace7d63cc2d4..850091ddfb06e 100644
--- a/crates/bevy_render/src/renderer/render_context.rs
+++ b/crates/bevy_render/src/renderer/render_context.rs
@@ -103,7 +103,7 @@ impl RenderContextState {
 }
 
 impl SystemBuffer for RenderContextState {
-    fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+    fn queue(&mut self, system_meta: &SystemMeta, mut world: DeferredWorld) {
         let _span = info_span!("RenderContextState::apply", system = %system_meta.name()).entered();
 
         let inner = &mut *self.0;
@@ -120,8 +120,6 @@ impl SystemBuffer for RenderContextState {
 
         inner.render_device = None;
     }
-
-    fn queue(&mut self, _system_meta: &SystemMeta, _world: DeferredWorld) {}
 }
 
 /// A system parameter that provides access to a command encoder and render device for issuing
diff --git a/release-content/migration-guides/system_buffer_queue.md b/release-content/migration-guides/system_buffer_queue.md
new file mode 100644
index 0000000000000..41e4db02d4b9f
--- /dev/null
+++ b/release-content/migration-guides/system_buffer_queue.md
@@ -0,0 +1,33 @@
+---
+title: "`SystemBuffer` requires `queue()` to be implemented"
+pull_requests: [22832]
+---
+
+`SystemBuffer` now requires `queue()` to be implemented, instead of `apply().`
+`apply()`'s default implementation now delegates to `queue()`.
+
+This is to ensure that a `SystemBuffer` used in an Observer context applies its changes.
+In most cases, if `apply()` does not change the `World` structurally,
+`apply()` and `queue()` can mutate the `World` directly in the same way.
+
+If `apply()` does not change the `World` structurally, `apply()` should be changed to `queue()`:
+
+```rust
+// 0.18
+impl SystemBuffer for MySystemBuffer {
+  fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
+    // your impl here
+  }
+}
+
+// 0.19
+impl SystemBuffer for MySystemBuffer {
+  fn queue(&mut self, system_meta: &SystemMeta, mut world: DeferredWorld) {
+    // your impl here, using a DeferredWorld instead
+  }
+}
+```
+
+If `apply()` does change the `World` structurally, implement both `apply()` and `queue()`.
+To queue structural changes to a `DeferredWorld`, add the structural changes to its command queue,
+accessible via `world.commands()`.
```