+++
title = "#22989 Allow accessing subassets using their handle"
date = "2026-02-20T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22989-en-20260220" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22989-zh-cn-20260220" }}
labels = ["C-Feature", "A-Assets", "D-Straightforward"]
+++

# Title: Allow accessing subassets using their handle

## Basic Information
- **Title**: Allow accessing subassets using their handle.
- **PR Link**: https://github.com/bevyengine/bevy/pull/22989
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: C-Feature, A-Assets, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-02-17T04:27:30Z
- **Merged**: 2026-02-20T01:53:56Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- Fixes #11595.

## Solution

- Change our labeled asset storage to be a `Vec` of labeled assets, and then a `HashMap` from label to index.
- Add an `AssetId` -> index mapping.
- Provide methods to do that lookup.
- Fixed an annoying TODO in our asset saving example.

This is all managed by the asset loading stuff internally - so no migration guide!

## Testing

- Ran the `asset_saving` example and it still works!

## The Story of This Pull Request

The problem this PR addresses is a straightforward but important limitation in Bevy's asset system. Developers working with labeled subassets (subassets within a main asset) could only access them by label, not by their handles. This created an inconsistency since handles are the primary way to reference assets elsewhere in Bevy, but for subassets, developers had to maintain separate label information.

The issue #11595 documented this limitation, where someone trying to use subasset handles couldn't easily retrieve the corresponding asset data. This was particularly problematic in asset saving scenarios where you might have handles to subassets but need to access the actual asset data during the save process.

The solution takes a pragmatic approach: rather than just adding handle-based lookups to the existing HashMap structure, the implementation reorganizes the storage to support multiple efficient lookup methods. The key insight is that labeled assets need to be accessible by both label and asset ID (from the handle), and using a single HashMap keyed by label doesn't support the latter.

The implementation changes the data structure from a simple `HashMap<CowArc<'static, str>, LabeledAsset>` to a more complex but versatile structure:
- A `Vec<LabeledAsset>` for ordered storage
- A `HashMap<CowArc<'static, str>, usize>` for label-to-index lookups
- A `HashMap<UntypedAssetId, usize>` for asset-ID-to-index lookups

This three-part structure provides O(1) lookups by both label and asset ID while maintaining the ability to iterate over all labeled assets. The comment in the code acknowledges that the asset ID mapping is "entirely redundant" with the labeled assets vector, but necessary for efficient handle-based lookups.

The changes propagate consistently through Bevy's asset system components: `LoadedAsset`, `ErasedLoadedAsset`, `LoadContext`, `SavedAsset`, `ErasedSavedAsset`, `TransformedAsset`, and `TransformedSubAsset`. Each of these structs gets the same three-field structure and corresponding lookup methods. This consistency ensures that handle-based lookups work uniformly across asset loading, saving, and transformation contexts.

One notable implementation detail is in the `add_labeled_asset` method in `LoadContext`. When adding a labeled asset, the code now handles the case where a label might already exist (an "occupied" entry in the HashMap). The comment notes that this should probably be treated as an error since replacing a subasset is likely accidental, but the current implementation allows replacement while properly updating the asset ID mapping.

The PR also fixes a TODO comment in the `asset_saving` example, where the previous code had to work around the limitation by extracting labels from handles and then doing label-based lookups. The new code can directly use `get_labeled_by_id`, which is cleaner and more reliable.

From a performance perspective, the changes add some memory overhead (two additional HashMaps per asset with labeled subassets) but maintain O(1) lookups. The trade-off is reasonable given that labeled assets are typically used for complex assets like scenes or glTF files with embedded textures, where the convenience and correctness of handle-based access outweighs the modest memory cost.

The implementation demonstrates good software engineering practices: it solves the immediate problem while maintaining API consistency, it doesn't break existing code (no migration needed), and it fixes related TODOs in the codebase. The changes are localized to the asset system internals, so users only see the new capabilities without having to change their code unless they want to use the new handle-based lookups.

## Visual Representation

```mermaid
graph TB
    subgraph "Asset with Subassets"
        A[LoadedAsset/TransformedAsset/SavedAsset]
        
        subgraph "Storage Structure"
            B[Vec<LabeledAsset>]
            C[HashMap<Label, Index>]
            D[HashMap<AssetId, Index>]
        end
        
        subgraph "Lookup Methods"
            E[get_labeled("label")]
            F[get_labeled_by_id(handle)]
            G[iter_labels()]
        end
    end
    
    A --> B
    A --> C
    A --> D
    
    C --> E
    D --> F
    B --> G
```

## Key Files Changed

### `crates/bevy_asset/src/loader.rs` (+185/-19)
This file contains the core changes to the asset loading system. The `LoadedAsset`, `ErasedLoadedAsset`, and `LoadContext` structs were updated to use the new three-part storage structure.

Key changes:
```rust
// Before:
pub(crate) labeled_assets: HashMap<CowArc<'static, str>, LabeledAsset>,

// After:
pub(crate) labeled_assets: Vec<LabeledAsset>,
pub(crate) label_to_asset_index: HashMap<CowArc<'static, str>, usize>,
pub(crate) asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,
```

New methods added:
```rust
pub fn get_labeled_by_id(&self, id: impl Into<UntypedAssetId>) -> Option<&ErasedLoadedAsset> {
    let index = self.asset_id_to_asset_index.get(&id.into())?;
    let labeled = &self.labeled_assets[*index];
    Some(&labeled.asset)
}
```

### `crates/bevy_asset/src/saver.rs` (+126/-32)
The asset saving system was updated to match the new structure. `SavedAsset`, `ErasedSavedAsset`, and `SavedAssetBuilder` now support handle-based lookups.

Key changes:
```rust
// Before:
labeled_assets: Moo<'b, HashMap<CowArc<'a, str>, LabeledSavedAsset<'a>>>,

// After:
labeled_assets: Moo<'b, Vec<LabeledSavedAsset<'a>>>,
label_to_asset_index: Moo<'b, HashMap<CowArc<'a, str>, usize>>,
asset_id_to_asset_index: Moo<'b, HashMap<UntypedAssetId, usize>>,
```

New methods added:
```rust
pub fn get_labeled_by_id<B: Asset>(
    &self,
    id: impl Into<AssetId<B>>,
) -> Option<SavedAsset<'a, '_, B>> {
    let index = self.asset_id_to_asset_index.get(&id.into().untyped())?;
    let labeled = &self.labeled_assets[*index];
    labeled.asset.downcast()
}
```

### `crates/bevy_asset/src/transformer.rs` (+185/-19)
The asset transformation system was updated for consistency. `TransformedAsset` and `TransformedSubAsset` now support the same lookup patterns.

Key changes:
```rust
// Before:
pub(crate) labeled_assets: HashMap<CowArc<'static, str>, LabeledAsset>,

// After:
pub(crate) labeled_assets: Vec<LabeledAsset>,
pub(crate) label_to_asset_index: HashMap<CowArc<'static, str>, usize>,
pub(crate) asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,
```

New methods added:
```rust
pub fn get_labeled_by_id<B: Asset, Q>(
    &mut self,
    id: impl Into<AssetId<B>>,
) -> Option<TransformedSubAsset<'_, B>>
where
    CowArc<'static, str>: Borrow<Q>,
    Q: ?Sized + Hash + Eq,
{
    let index = self.asset_id_to_asset_index.get(&id.into().untyped())?;
    let labeled = &mut self.labeled_assets[*index];
    let value = labeled.asset.value.downcast_mut::<B>()?;
    Some(TransformedSubAsset {
        value,
        labeled_assets: &mut labeled.asset.labeled_assets,
        label_to_asset_index: &mut labeled.asset.label_to_asset_index,
        asset_id_to_asset_index: &mut labeled.asset.asset_id_to_asset_index,
    })
}
```

### `examples/asset/asset_saving.rs` (+5/-9)
The example was updated to use the new handle-based lookup instead of the workaround that extracted labels from handles.

Key change:
```rust
// Before (with TODO comment):
// TODO: We should have a better to get the asset for a subasset handle.
let label = handle
    .path()
    .and_then(|path| path.label())
    .ok_or_else(|| format!("Failed to get label for handle {handle:?}"))?;
asset
    .get_labeled::<OneBox>(label)
    .map(|subasset| subasset.get().clone())
    .ok_or_else(|| format!("Failed to find labeled asset for label {label}"))

// After (simplified):
asset
    .get_labeled_by_id::<OneBox>(handle)
    .unwrap()
    .get()
    .clone()
```

### `crates/bevy_asset/src/server/mod.rs` (+3/-2)
Minor updates to use the new structure when looking up labeled assets by label in the asset server.

## Further Reading

1. [Bevy Assets Documentation](https://docs.rs/bevy_asset/latest/bevy_asset/) - Official documentation for Bevy's asset system
2. [Handles and Assets in Bevy](https://bevy-cheatbook.github.io/features/assets.html) - Cheat sheet for working with assets in Bevy
3. [Issue #11595](https://github.com/bevyengine/bevy/issues/11595) - The original issue that motivated this PR
4. [HashMap vs Vec for lookups](https://doc.rust-lang.org/std/collections/index.html) - Rust documentation on collection performance characteristics
5. [Asset Pipelines in Game Engines](https://www.gameenginebook.com/) - General concepts about asset management in game engines