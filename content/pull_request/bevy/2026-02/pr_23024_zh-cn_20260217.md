+++
title = "#23024 在atmosphere功能落地后修复 `WGPU_SETTINGS_PRIO=\"webgl2\""
date = "2026-02-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23024-en-20260217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23024-zh-cn-20260217" }}
+++

# Title
Fix `WGPU_SETTINGS_PRIO="webgl2"` after atmosphere landed.

## Basic Information
- **标题**: 在atmosphere功能落地后修复 `WGPU_SETTINGS_PRIO="webgl2"`
- **PR链接**: https://github.com/bevyengine/bevy/pull/23024
- **作者**: pcwalton
- **状态**: 已合并 (MERGED)
- **标签**: D-Trivial, A-Rendering, P-Crash, S-Ready-For-Final-Review, A-Diagnostics
- **创建时间**: 2026-02-17T22:39:23Z
- **合并时间**: 2026-02-17T23:40:36Z
- **合并者**: alice-i-cecile

## Description Translation
atmosphere 插件仅检查 `RenderAdapter` 以确定运行是否安全，而不检查 `RenderDevice`。正如 PR #18113 所发现的，这会导致 `WGPU_SETTINGS_PRIO="webgl2"` 失败，因为该环境变量只影响 `RenderDevice`，而不影响 `RenderAdapter`。与该PR类似，本PR通过让 atmosphere 在检查 `RenderAdapter` 之外也检查 `RenderDevice` 来修复此问题。

## The Story of This Pull Request

这个问题始于一个特定的渲染功能——atmosphere（大气效果）——与一个用于控制后端优先级的环境变量 `WGPU_SETTINGS_PRIO` 之间的冲突。

Bevy 的渲染系统通过两个核心结构来抽象GPU：`RenderAdapter` 和 `RenderDevice`。`RenderAdapter` 大致对应于物理GPU硬件及其支持的特性。而 `RenderDevice` 是实际创建的、用于执行渲染命令的逻辑设备。在某些情况下，用户可能希望通过 `WGPU_SETTINGS_PRIO` 环境变量（例如设为 `"webgl2"`）来强制使用特定的、能力可能较低的图形后端（如WebGL2），即使系统适配器本身支持更高级的功能（如Vulkan或Metal）。这个环境变量会直接影响创建的 `RenderDevice` 的能力限制，但不会改变底层 `RenderAdapter` 报告的原始能力。

atmosphere 渲染效果依赖于存储纹理（storage textures）这一GPU特性。为了安全起见，atmosphere 插件在初始化时需要检查当前环境是否支持此特性。在引入此PR的修复之前，插件的检查逻辑只查询了 `RenderAdapter` 的 `downlevel_capabilities`。

这里就出现了问题。当 `WGPU_SETTINGS_PRIO="webgl2"` 被设置时，系统创建的 `RenderDevice` 其能力会被限制为WebGL2级别，通常这意味着 `max_storage_textures_per_shader_stage` 限制为0，即不支持存储纹理。然而，底层的 `RenderAdapter`（例如一个支持Vulkan的独立显卡）仍然会报告它**确实**支持存储纹理（`downlevel_capabilities.flags` 包含 `DownlevelFlags::STORAGE_TEXTURES`）。这导致插件基于错误的乐观判断而加载，但在尝试创建或使用需要存储纹理的GPU资源时，底层wgpu库会因为设备能力不足而抛出错误，导致程序崩溃。

解决方案非常直接且遵循了既有的修复模式。开发者参考了之前解决类似问题的 PR #18113。修复的核心思想是：进行双重检查。不仅要询问适配器“你**能**做什么？”，还要询问设备“你当前**允许**我做什么？”。

因此，实现就是在 `AtmospherePlugin` 的 `build` 方法中，在已有的 `RenderAdapter` 检查之后，新增一段对 `RenderDevice` 的检查代码。

```rust
// 检查 `RenderDevice` 以及 `RenderAdapter`。前者会考虑 `WGPU_SETTINGS_PRIO` 环境变量，而后者不会。
let render_device = render_app.world().resource::<RenderDevice>();
if render_device.limits().max_storage_textures_per_shader_stage == 0 {
    warn!("AtmospherePlugin not loaded. GPU lacks support: `max_storage_textures_per_shader_stage` is 0");
    return;
}
```

这段代码从渲染子应用（`render_app`）中获取 `RenderDevice` 资源，并直接查询其 `limits` 中的 `max_storage_textures_per_shader_stage` 值。如果该值为0，说明当前配置的逻辑设备不支持存储纹理，插件会记录一条警告信息并安全地中止加载，从而避免了后续的运行时崩溃。

从工程角度看，这是一个防御性编程和准确理解抽象层级之间差异的典型案例。`RenderAdapter` 代表潜在能力，`RenderDevice` 代表实际可用的、受运行时配置约束的能力。任何依赖于特定GPU特性的插件或系统，如果其可用性会受到像 `WGPU_SETTINGS_PRIO` 这样的用户配置的影响，都必须对这两者进行检查。

此PR的改动很小（仅增加约10行代码），但有效地解决了一个导致程序崩溃的边界情况。它确保了atmosphere插件在用户强制使用能力较低的后端时，能够优雅地降级（即不启用），而不是强行运行导致失败。这种修复也增强了Bevy在不同目标平台（如Web与原生）上行为的一致性。

## Visual Representation

```mermaid
graph TD
    User[用户/环境变量<br/>WGPU_SETTINGS_PRIO="webgl2"] --> RenderDevice
    Hardware[GPU硬件 / Adapter 适配器] --> RenderAdapter

    RenderAdapter -- 查询原始能力<br/>(支持STORAGE_TEXTURES) --> AtmospherePlugin
    RenderDevice -- 查询实际限制<br/>(max_storage_textures=0) --> AtmospherePlugin

    AtmospherePlugin{决策逻辑}
    AtmospherePlugin -- 双重检查通过 --> Load[成功加载插件]
    AtmospherePlugin -- Device检查失败 --> Abort[中止加载，避免崩溃]
```

## Key Files Changed

- `crates/bevy_pbr/src/atmosphere/mod.rs` (+10/-0)

这是此PR中唯一被修改的文件。改动位于 `AtmospherePlugin` 的 `build` 方法内。在已有的、从 `RenderApp` 资源中检查 `RenderAdapter` 是否支持存储纹理的代码块之后，新增了一段对 `RenderDevice` 的类似检查。

**关键代码片段**:
```rust
// 新增的检查代码块
// Check the `RenderDevice` in addition to the `RenderAdapter`. The
// former takes the `WGPU_SETTINGS_PRIO` environment variable into
// account, and the latter doesn't.
let render_device = render_app.world().resource::<RenderDevice>();
if render_device.limits().max_storage_textures_per_shader_stage == 0 {
    warn!("AtmospherePlugin not loaded. GPU lacks support: `max_storage_textures_per_shader_stage` is 0");
    return;
}
```

**代码作用**:
1.  **获取资源**: `render_app.world().resource::<RenderDevice>()` 从渲染子应用的世界中获取当前的 `RenderDevice` 实例。
2.  **查询限制**: `render_device.limits().max_storage_textures_per_shader_stage` 查询该逻辑设备允许每个着色器阶段使用的最大存储纹理数量。
3.  **条件判断**: 如果该限制为0，意味着设备完全不支持存储纹理。
4.  **安全退出**: 在这种情况下，插件记录一条警告日志并直接 `return`，跳过后续所有的资源初始化和系统注册步骤，从而确保插件不会在不可用的环境下被激活。

**与PR目的的关系**:
这个新增的检查直接解决了PR描述中概述的问题。它确保了当用户通过 `WGPU_SETTINGS_PRIO` 环境变量选择了一个不支持存储纹理的后端（如WebGL2）时，atmosphere插件能够基于**实际生效的设备能力**做出正确的禁用决定，而不是依赖于可能过高的适配器能力报告。这避免了在运行时因创建不支持的资源而导致的panic或崩溃。

## Further Reading
1.  **关联的PR #18113**: 该PR为其他渲染功能（可能是光照或阴影）应用了完全相同的 `RenderDevice` 检查模式。阅读此PR可以了解此问题的历史背景以及它在代码库其他部分的应用。
2.  **Bevy 官方文档 - 渲染**: 了解 `RenderAdapter`、`RenderDevice` 以及 Bevy 渲染架构的整体设计。
3.  **wgpu 仓库的 `DownlevelFlags` 和 `Limits`**: 深入了解 `STORAGE_TEXTURES` 标志和 `max_storage_textures_per_shader_stage` 限制的具体含义，以及它们在 WebGL、Vulkan、Metal 等不同后端下的表现差异。
4.  **Bevy 诊断标签 (A-Diagnostics)**: 了解 Bevy 中如何处理功能检测和诊断信息，例如本PR中添加的警告日志就属于诊断信息。