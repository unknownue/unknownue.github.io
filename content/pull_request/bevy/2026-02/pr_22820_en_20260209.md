+++
title = "#22820 Add glTF scene name loading"
date = "2026-02-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22820-en-20260209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22820-zh-cn-20260209" }}
labels = ["C-Feature", "A-Assets", "A-glTF"]
+++

# Title
Add glTF scene name loading

## Basic Information
- **Title**: Add glTF scene name loading
- **PR Link**: https://github.com/bevyengine/bevy/pull/22820
- **Author**: ChristopherBiscardi
- **Status**: MERGED
- **Labels**: C-Feature, A-Assets, S-Ready-For-Final-Review, A-glTF
- **Created**: 2026-02-05T20:01:09Z
- **Merged**: 2026-02-09T22:24:31Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

glTF scenes often have names. Our loader code does not insert them. This results in tools like bevy_inspector_egui showing `Entity` on the scene's root entity instead of "MyPlayerScene" or whatever it was named in blender, etc.

## Solution

Use names if they exist, otherwise use a default name based on the glTF index of the scene which mirrors other usage.

## Testing

I loaded `models/FlightHelmet/FlightHelmet.gltf` and `models/cube/cube.gltf` into the `3d_scene` example and wrote a small system to check for the existence of `Name` components. With this patch, the `Scene` and `Scene0` names will log out (`FlightHelmet` doesn't have a name, so will print `Scene0` while `cube` has a name, which is `Scene` without the index).

```rust
fn update(query: Query<&Name>) {
    for item in &query {
        dbg!(item);
    }
}
```

---

`GltfSceneName` is now also inserted to mirror `GltfMeshName` and `GltfMaterialName`.

## The Story of This Pull Request

This PR addresses a usability issue in Bevy's glTF loader where scene names from glTF files weren't being applied to the spawned entities. When importing glTF assets created in tools like Blender, developers would see generic `Entity` labels in debugging tools like `bevy_inspector_egui` instead of meaningful scene names like "MyPlayerScene" or "Environment."

The core problem was that while Bevy's glTF loader already handled names for individual components like meshes and materials through dedicated components (`GltfMeshName` and `GltfMaterialName`), it didn't provide the same treatment for entire scenes. This made scene hierarchy debugging and entity identification more difficult than necessary.

The solution follows a pattern already established elsewhere in the glTF loader. When spawning the root entity for a glTF scene, the code now checks if the glTF scene has a name field. If it does, that name is used for the entity's `Name` component. If not, it falls back to a default naming convention using the scene's index (e.g., "Scene0", "Scene1"), which matches how unnamed meshes and materials are handled.

The implementation adds a new component type `GltfSceneName` to store the original glTF scene name, maintaining consistency with the existing `GltfMeshName` and `GltfMaterialName` components. This allows developers to access the original glTF metadata if needed, separate from the entity's display name.

The changes are minimal and focused. In the scene loading code, when creating the root entity, a `Name` component is now always inserted with either the scene's name or a generated default. Additionally, if the scene has a name in the glTF file, a `GltfSceneName` component is added containing that original name. This dual approach provides both usability (entities have readable names in tools) and data preservation (the original glTF metadata is accessible).

From an engineering perspective, this change improves the developer experience without introducing breaking changes. The fallback naming ensures backward compatibility for unnamed scenes, and the new component follows the same pattern as existing glTF metadata components. The implementation also properly handles the coordinate conversion step by placing the naming logic after the world root transform is created but before children are spawned.

The testing approach described by the author is practical - loading existing glTF models and verifying the name components appear as expected. The two test cases (a scene with a name and one without) cover both code paths and ensure the fallback mechanism works correctly.

## Visual Representation

```mermaid
graph TD
    A[glTF Scene Loading] --> B{Scene has name?}
    B -->|Yes| C[Insert Name component with scene name]
    B -->|No| D[Insert Name component with "Scene{index}"]
    C --> E[Insert GltfSceneName component]
    D --> F[Skip GltfSceneName component]
    
    G[Existing Pattern] --> H[GltfMeshName component]
    G --> I[GltfMaterialName component]
    E --> J[New: GltfSceneName component]
```

## Key Files Changed

**File: `crates/bevy_gltf/src/assets.rs` (+15/-0)**

This file defines the new `GltfSceneName` component that stores the original glTF scene name. The component follows the same pattern as existing glTF metadata components with `Deref` implementation for string access and proper reflection setup.

```rust
// Added component definition
#[derive(Clone, Debug, Reflect, Default, Component)]
#[reflect(Component, Clone)]
pub struct GltfSceneName(pub String);

impl Deref for GltfSceneName {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        self.0.as_ref()
    }
}
```

**File: `crates/bevy_gltf/src/loader/mod.rs` (+17/-2)**

This file contains the loader logic that was modified to include scene names. The changes occur in the scene spawning code where the root entity is created.

```rust
// Before: (simplified)
let world_root_id = world
    .spawn((world_root_transform, Visibility::default()))
    .with_children(|parent| {
        // ... spawn child nodes
    })
    .id();

// After:
let world_root_id = world
    .spawn((
        world_root_transform,
        Visibility::default(),
        Name::new(
            scene
                .name()
                .map(ToOwned::to_owned)
                .unwrap_or_else(|| format!("Scene{}", scene.index())),
        ),
    ))
    .with_children(|parent| {
        // ... spawn child nodes
    })
    .id();

// Additional code to insert GltfSceneName if the scene has a name
if let Some(scene_name) = scene.name() {
    world
        .entity_mut(world_root_id)
        .insert(GltfSceneName(scene_name.to_owned()));
};
```

The key changes are:
1. Always inserting a `Name` component with either the scene's name or a generated default
2. Conditionally inserting a `GltfSceneName` component when the scene has a name in the glTF file
3. Importing the new `GltfSceneName` type at the top of the file

## Further Reading

1. [glTF 2.0 Specification - Scene Reference](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-scene)
2. [Bevy ECS Components Documentation](https://docs.rs/bevy_ecs/latest/bevy_ecs/component/trait.Component.html)
3. [Bevy glTF Loader Source Code](https://github.com/bevyengine/bevy/tree/main/crates/bevy_gltf)
4. [Bevy Inspector Egui - Entity Inspector](https://github.com/jakobhellermann/bevy-inspector-egui)

# Full Code Diff
```diff
diff --git a/crates/bevy_gltf/src/assets.rs b/crates/bevy_gltf/src/assets.rs
index 62cea475f226f..07eebcc552003 100644
--- a/crates/bevy_gltf/src/assets.rs
+++ b/crates/bevy_gltf/src/assets.rs
@@ -288,6 +288,21 @@ pub struct GltfSceneExtras {
     pub value: String,
 }
 
+/// The name of a glTF scene.
+///
+/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-scene).
+#[derive(Clone, Debug, Reflect, Default, Component)]
+#[reflect(Component, Clone)]
+pub struct GltfSceneName(pub String);
+
+impl Deref for GltfSceneName {
+    type Target = str;
+
+    fn deref(&self) -> &Self::Target {
+        self.0.as_ref()
+    }
+}
+
 /// Additional untyped data that can be present on most glTF types at the mesh level.
 ///
 /// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).
diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
index ac9af452a6e0e..d764d38f10c78 100644
--- a/crates/bevy_gltf/src/loader/mod.rs
+++ b/crates/bevy_gltf/src/loader/mod.rs
@@ -57,7 +57,7 @@ use tracing::{error, info_span, warn};
 use crate::{
     convert_coordinates::ConvertCoordinates as _, vertex_attributes::convert_attribute, Gltf,
     GltfAssetLabel, GltfExtras, GltfMaterial, GltfMaterialExtras, GltfMaterialName, GltfMeshExtras,
-    GltfMeshName, GltfNode, GltfSceneExtras, GltfSkin, GltfSkinnedMeshBoundsPolicy,
+    GltfMeshName, GltfNode, GltfSceneExtras, GltfSceneName, GltfSkin, GltfSkinnedMeshBoundsPolicy,
 };
 
 #[cfg(feature = "bevy_animation")]
@@ -999,7 +999,16 @@ impl GltfLoader {
             let world_root_transform = convert_coordinates.scene_conversion_transform();
 
             let world_root_id = world
-                .spawn((world_root_transform, Visibility::default()))
+                .spawn((
+                    world_root_transform,
+                    Visibility::default(),
+                    Name::new(
+                        scene
+                            .name()
+                            .map(ToOwned::to_owned)
+                            .unwrap_or_else(|| format!("Scene{}", scene.index())),
+                    ),
+                ))
                 .with_children(|parent| {
                     for node in scene.nodes() {
                         let result = load_node(
@@ -1029,6 +1038,12 @@ impl GltfLoader {
                 })
                 .id();
 
+            if let Some(scene_name) = scene.name() {
+                world
+                    .entity_mut(world_root_id)
+                    .insert(GltfSceneName(scene_name.to_owned()));
+            };
+
             if let Some(extras) = scene.extras().as_ref() {
                 world.entity_mut(world_root_id).insert(GltfSceneExtras {
                     value: extras.get().to_string(),
```