+++
title = "#22659 Benchmark remote allocation"
date = "2026-02-02T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22659-en-20260202" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22659-zh-cn-20260202" }}
labels = ["D-Trivial", "A-ECS", "C-Benchmarks"]
+++

# Benchmark remote allocation

## Basic Information
- **Title**: Benchmark remote allocation
- **PR Link**: https://github.com/bevyengine/bevy/pull/22659
- **Author**: ElliottjPierce
- **Status**: MERGED
- **Labels**: D-Trivial, A-ECS, S-Ready-For-Review, C-Benchmarks
- **Created**: 2026-01-23T05:16:36Z
- **Merged**: 2026-02-02T23:26:53Z
- **Merged By**: alice-i-cecile

## Description Translation
在 #18670 之后，我们有了一个 `RemoteAllocator`，但我们没有将其与非远程分配器进行比较的基准测试。这个 PR 只是添加了那些基准测试。

我不知道我们是否真的需要这些基准测试，但拥有它们似乎是合理的，而且制作它没有花费时间，所以我想把它发出来。

### 解决方案
添加 `entity_allocator_allocate_fresh_remote` 和 `entity_allocator_allocate_reused_remote` 基准测试组。

### 测试
- CI, benchmarks

---

### 展示
```txt
entity_allocator_allocate_fresh/10000_entities            1.00     22.8±0.29µs        ? ?/sec
entity_allocator_allocate_fresh/100_entities              1.00    227.9±6.37ns        ? ?/sec
entity_allocator_allocate_fresh/1_entities                1.00      6.2±3.83ns        ? ?/sec
entity_allocator_allocate_fresh_bulk/10000_entities       1.00     19.9±0.25µs        ? ?/sec
entity_allocator_allocate_fresh_bulk/100_entities         1.00    227.5±6.95ns        ? ?/sec
entity_allocator_allocate_fresh_bulk/1_entities           1.00     11.5±4.69ns        ? ?/sec
entity_allocator_allocate_fresh_remote/10000_entities     1.00     19.4±0.32µs        ? ?/sec
entity_allocator_allocate_fresh_remote/100_entities       1.00    174.2±3.63ns        ? ?/sec
entity_allocator_allocate_fresh_remote/1_entities         1.00      3.5±3.02ns        ? ?/sec
entity_allocator_allocate_reused/10000_entities           1.00     21.5±0.37µs        ? ?/sec
entity_allocator_allocate_reused/100_entities             1.00   233.3±11.77ns        ? ?/sec
entity_allocator_allocate_reused/1_entities               1.00      8.3±3.70ns        ? ?/sec
entity_allocator_allocate_reused_bulk/10000_entities      1.00     20.4±0.64µs        ? ?/sec
entity_allocator_allocate_reused_bulk/100_entities        1.00   261.5±45.59ns        ? ?/sec
entity_allocator_allocate_reused_bulk/1_entities          1.00    19.7±10.77ns        ? ?/sec
entity_allocator_allocate_reused_remote/10000_entities    1.00     77.9±1.53µs        ? ?/sec
entity_allocator_allocate_reused_remote/100_entities      1.00   774.9±16.28ns        ? ?/sec
entity_allocator_allocate_reused_remote/1_entities        1.00      7.3±3.60ns        ? ?/sec
```

长话短说，远程分配比非远程分配慢大约3倍。综合考虑，我认为这相当不错。

## The Story of This Pull Request

这个 PR 始于一个简单的观察：在 Bevy 的 ECS（实体组件系统）中，PR #18670 引入了一个新组件——`RemoteAllocator`。这个分配器允许在不需要持有对整个 `World` 的引用（例如在异步上下文中）的情况下分配实体（Entity）。虽然功能已经实现，但代码库中缺少一个关键信息：它的性能表现如何？与非远程分配器相比，它的开销有多大？为了填补这个空白，作者提交了这个 PR，为 `RemoteAllocator` 添加了基准测试。

性能基准测试对于理解系统的开销和做出明智的工程决策至关重要。缺少对 `RemoteAllocator` 的基准测试意味着开发者无法量化使用它所带来的性能影响。添加这些基准测试的目的很直接：提供客观数据，帮助开发者在需要远程实体分配的场合（如异步任务）评估其成本效益。

解决方案的实现遵循了现有基准测试的模式，保持了代码的一致性。在 `entity_allocator.rs` 基准测试文件中，作者添加了两个新的基准测试组：
1.  **`entity_allocator_allocate_fresh_remote`**：测试从远程分配器分配全新的实体。
2.  **`entity_allocator_allocate_reused_remote`**：测试从远程分配器重用之前释放的实体ID。

这两个组分别对应了 `EntityAllocator` 已有的 `allocate_fresh` 和 `allocate_reused` 基准测试，形成了清晰的对比。每个基准测试组都使用标准的 `criterion` 库设置，循环测试 1、100 和 10000 个实体分配，以观察不同规模下的性能。

一个关键的技术细节体现在基准测试的设置代码中。对于重用分配的测试，需要先创建并释放一批实体，以填充分配器的“空闲列表”，模拟重用场景。这通过以下步骤实现：
```rust
let mut entities = Vec::from_iter(world.entity_allocator().alloc_many(entity_count));
entities
    .drain(..)
    .for_each(|e| world.entity_allocator_mut().free(e));
```
之后，才构建远程分配器进行测试。

此外，为了顺利编写基准测试，需要对 `EntityAllocator::build_remote_allocator` 方法进行一个微小的、但重要的签名变更。原来的方法需要 `&mut self` 的可变引用：
```rust
pub fn build_remote_allocator(&mut self) -> RemoteAllocator {
```
然而，在基准测试的闭包中，我们通常只持有对 `EntityAllocator` 的不可变引用（通过 `world.entity_allocator()`）。由于构建 `RemoteAllocator` 本质上只是获取一个内部结构的共享引用（`&self.inner`）来创建新实例，并不需要修改原分配器本身，因此将其签名改为接受不可变引用是合理的：
```rust
pub fn build_remote_allocator(&self) -> RemoteAllocator {
```
这一行修改（在 `crates/bevy_ecs/src/entity/mod.rs` 中）虽然微小，但确保了 API 的易用性和逻辑正确性，使得在只读上下文中创建远程分配器成为可能，这与其设计初衷（在异步等无法获得可变引用的场景中使用）是吻合的。

运行基准测试后得到的数据揭示了明确的性能特征。如 PR 描述中的结果所示，对于“全新分配”（fresh allocation），远程和非远程分配器的性能非常接近，远程分配器甚至在某些情况下略快（可能是测量波动）。然而，对于“重用分配”（reused allocation），远程分配器的开销变得明显，大约是非远程分配器的 3 倍（例如，10000 个实体分配耗时 77.9µs 对比 21.5µs）。

这个性能差异是预期的。`RemoteAllocator` 需要通过内部同步机制（如原子操作或锁）与主 `EntityAllocator` 协调，特别是在回收和分配已释放的 ID 时，这比直接访问拥有所有权的分配器有更高的开销。作者得出的结论——“综合考虑，我认为这相当不错”——是合理的。对于一个用于特定场景（如异步）的工具，3倍的开销在许多情况下是可以接受的，尤其是考虑到它提供的便利性。

最终，这个 PR 以一种轻量、非侵入性的方式，为 Bevy ECS 的一个关键基础设施组件补充了重要的性能度量。它没有改变任何核心逻辑，只是增加了观察和评估的手段。这些基准测试现在将成为项目持续集成的一部分，帮助防止未来更改导致 `RemoteAllocator` 性能意外回归，并为所有开发者提供了关于其成本的确切数据，以便在架构设计时做出更明智的选择。

## Visual Representation

```mermaid
graph TD
    subgraph “基准测试 (Benchmarks)”
        B_Fresh[entity_allocator_allocate_fresh]
        B_Reused[entity_allocator_allocate_reused]
        B_FreshRemote[entity_allocator_allocate_fresh_remote]
        B_ReusedRemote[entity_allocator_allocate_reused_remote]
    end

    EA[EntityAllocator] -->|build_remote_allocator| RA[RemoteAllocator]
    
    B_Fresh -->|测试| EA
    B_Reused -->|测试| EA
    B_FreshRemote -->|测试| RA
    B_ReusedRemote -->|测试| RA
```

## Key Files Changed

### 1. `benches/benches/bevy_ecs/world/entity_allocator.rs` (+53/-0)
**描述**：此文件是 ECS 实体分配器基准测试的入口。PR 在此添加了两个新的基准测试组，用于测量 `RemoteAllocator` 的性能。
**关键修改**：
```rust
// 添加了“远程分配-全新实体”基准测试组
let mut group = criterion.benchmark_group("entity_allocator_allocate_fresh_remote");
// ... 基准测试配置 ...
for entity_count in ENTITY_COUNTS {
    group.bench_function(format!("{entity_count}_entities"), |bencher| {
        bencher.iter_batched_ref(
            || {
                let world = World::new();
                world.entity_allocator().build_remote_allocator() // 使用不可变引用构建
            },
            |remote| {
                for _ in 0..entity_count {
                    let entity = remote.alloc(); // 执行远程分配
                    black_box(entity);
                }
            },
            BatchSize::SmallInput,
        );
    });
}

// 添加了“远程分配-重用实体”基准测试组
let mut group = criterion.benchmark_group("entity_allocator_allocate_reused_remote");
// ... 基准测试配置 ...
for entity_count in ENTITY_COUNTS {
    group.bench_function(format!("{entity_count}_entities"), |bencher| {
        bencher.iter_batched_ref(
            || {
                let mut world = World::new();
                // 预分配并释放实体，以填充重用池
                let mut entities = Vec::from_iter(world.entity_allocator().alloc_many(entity_count));
                entities.drain(..).for_each(|e| world.entity_allocator_mut().free(e));
                world.entity_allocator().build_remote_allocator() // 使用不可变引用构建
            },
            |remote| {
                for _ in 0..entity_count {
                    let entity = remote.alloc(); // 执行远程分配（期望重用ID）
                    black_box(entity);
                }
            },
            BatchSize::SmallInput,
        );
    });
}
```
**与PR目的的关系**：这些新增的代码块直接实现了 PR 的目标——为 `RemoteAllocator` 创建基准测试，使其能够与现有的非远程分配基准测试进行对比。

### 2. `crates/bevy_ecs/src/entity/mod.rs` (+1/-1)
**描述**：此文件包含 `EntityAllocator` 的定义。PR 修改了 `build_remote_allocator` 方法的签名，使其接受不可变引用 `&self` 而非可变引用 `&mut self`。
**关键修改**：
```rust
// Before:
pub fn build_remote_allocator(&mut self) -> RemoteAllocator {
    RemoteAllocator::new(&self.inner)
}

// After:
pub fn build_remote_allocator(&self) -> RemoteAllocator {
    RemoteAllocator::new(&self.inner)
}
```
**与PR目的的关系**：这一修改是功能性的，它使基准测试（以及其他任何只持有不可变引用的代码）能够创建 `RemoteAllocator`。同时，它也提升了 API 的易用性和逻辑一致性，因为构建一个远程视图并不需要改变原始分配器的状态。

## Further Reading
1.  **PR #18670**: 原始引入了 `RemoteAllocator` 的 PR。阅读它可以理解 `RemoteAllocator` 的设计动机、实现细节和使用场景。
2.  **Criterion.rs Documentation**: 本 PR 使用的 Rust 基准测试库。了解其 API 可以帮助你理解基准测试的设置和运行原理。
3.  **Bevy ECS 官方文档**: 查看关于实体（Entity）和 `EntityAllocator` 的章节，以深入了解 Bevy ECS 的核心数据结构和其分配机制。
4.  **《Systems Performance: Enterprise and the Cloud》**: 对于想深入理解性能分析与基准测试的工程师，这是一本经典的资源。