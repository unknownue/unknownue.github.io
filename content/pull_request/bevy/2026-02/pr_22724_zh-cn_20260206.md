+++
title = "#22724 Add padding for color_plane widget for wasm/webgl compat"
date = "2026-02-06T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22724-en-20260206" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22724-zh-cn-20260206" }}
+++

# Title

## 基本资料
- **标题**: Add padding for color_plane widget for wasm/webgl compat
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22724
- **作者**: mitchty
- **状态**: 已合并
- **标签**: C-Bug, A-Rendering, A-UI, S-Ready-For-Final-Review, D-Straightforward
- **创建时间**: 2026-01-27T14:51:05Z
- **合并时间**: 2026-02-06T20:08:32Z
- **合并者**: alice-i-cecile

## 描述翻译

# 目标
- 描述此PR旨在解决的目标或问题。
- 如果你正在修复一个特定问题，请说“修复 #X”。

新的 bevy feathers 颜色平面控件（color plane widget）在使用的 f32 上引发了 wgpu 对齐问题。为了让 wasm 构建能够使用这个控件，添加类似于现有着色器/材质的填充（padding）。

注意，这是我的第一次贡献，我对名字之类的都很随意，所以如果我起的名字很糟糕，我可以更改，我并不过分执着于这些名字。

## 解决方案
- 描述用于实现上述目标的解决方案。

在 uniform 和材质结构中添加一个 Vec3 填充，以便在 wasm 构建上填充到 16 字节。

## 测试
- 你测试了这些更改吗？如果是，是如何测试的？

是的，在 Linux（Wayland，但如果需要我也可以测试 X）、macOS 和 Windows 上构建了修改前和修改后的版本。这些都像之前一样继续正常工作。并在 Safari/Firefox/Chrome（大多是这些浏览器的最新版本）的 wasm 上进行了测试，这3个浏览器在通过 cargo patch 应用此修复后，都无法渲染着色器控件，现在都正常了，并且工作方式与本机构建相同。

- 是否有任何部分需要更多测试？
也许？我不确定我是否足够了解，可以对此发表权威意见。我从未为 web 编程，这对我来说只是 wasm 上一个有趣的项目，老实说，我不知道我做的这些是否正确。真正的 web 程序员应该对这些内容表示赞成/反对，我只是个游客。

- 其他人（审阅者）如何测试你的更改？他们需要了解什么特别的信息吗？
只需在 wasm 上使用颜色控件进行测试/构建。我所做的就是使用 cargo patch 指向修复后的版本，如下所示：

针对 0.18.1 发布分支的相同补丁：
```toml
bevy = { git = "https://github.com/mitchty/bevy", branch = "colorplane-wasm" }
```

此分支：
```toml
bevy = { git = "https://github.com/mitchty/bevy", branch = "colorplane-wasm-fix" }
```

- 如果相关，你在哪些平台上测试了这些更改，有哪些重要的平台你无法测试？
我尝试在我设置交叉编译的所有系统上进行测试，我想/希望这包括了大部分系统。

## 本次PR的来龙去脉

这个PR源于一个典型的跨平台渲染兼容性问题。Bevy的feathers UI库引入了一个新的`color_plane`控件，它允许用户通过二维平面选择颜色。在本地平台（Windows、macOS、Linux）上，这个控件工作正常，但在通过WebAssembly（WASM）在浏览器中运行时，特别是在WebGL后端下，这个控件无法渲染，并且控制台会报告着色器相关的wgpu对齐错误。

问题的核心在于内存布局和对齐要求。在WGSL（WebGPU Shading Language）中，标量类型`f32`的字节对齐要求通常是其大小（4字节）。然而，当结构体用作uniform缓冲区时，某些平台和API（尤其是WebGL 2）对uniform块内的成员有更严格的对齐限制。通常，为了性能和兼容性，uniform缓冲区成员需要对齐到16字节边界。如果不满足这个要求，WebGL驱动可能会拒绝编译着色器或在运行时产生未定义行为。

具体到这个`color_plane`控件，它的着色器最初定义了一个单独的`fixed_channel: f32` uniform变量。在CPU端的Rust代码中，对应的材质结构体`ColorPlaneMaterial`也只包含一个`fixed_channel: f32`字段。这个结构体的大小是4字节。当这个数据被上传到GPU作为uniform缓冲区时，在WebGL环境下，它可能没有满足16字节对齐的要求，从而导致了错误。

开发者`mitchty`采取的解决方案是标准的“填充（padding）”技术。这个方案不是首创，在Bevy代码库的其他部分（如其他着色器和材质）已经有先例。解决思路很直接：通过在数据结构中添加一个无用的填充字段，强制将整个结构体的大小和对齐扩展到目标平台（这里是16字节）的要求。

实现分为两个部分，需要在CPU（Rust）和GPU（WGSL）两边保持同步。

首先，在WGSL着色器文件（`color_plane.wgsl`）中，开发者将单独的`fixed_channel` uniform变量包装进一个名为`ColorPlaneUniform`的结构体中。然后，他们使用预处理器指令`#ifdef SIXTEEN_BYTE_ALIGNMENT`来条件性地添加一个`vec3<f32>`类型的填充字段`_webgl2_padding_12b`。一个`vec3<f32>`占用12字节（3个f32）。加上原有的4字节`fixed_channel`，总大小正好是16字节，满足了对齐要求。着色器代码中所有使用`fixed_channel`的地方都改为通过结构体访问`uniform_data.fixed_channel`。这个`SIXTEEN_BYTE_ALIGNMENT`标志预计由Bevy的着色器预处理系统在针对WebGL构建时自动定义。

其次，在Rust端的材质结构体`ColorPlaneMaterial`中，也需要添加相应的填充字段。这里使用了Rust的条件编译属性（`#[cfg(...)]`）来精确控制字段的存在。该字段仅在同时满足三个条件时添加：
1. 启用了`"webgl"`特性（`feature = "webgl"`）。
2. 目标架构是`wasm32`（`target_arch = "wasm32"`）。
3. **没有**启用`"webgpu"`特性（`not(feature = "webgpu")`）。

这个逻辑非常关键。它确保了填充只会在以WebAssembly为目标、并且使用WebGL后端（而不是更新的WebGPU后端）时添加。在原生平台或使用WebGPU时，则不需要这个填充，避免了不必要的内存开销。填充字段被命名为`_webgl2_padding_12b`（下划线开头表示有意未使用），类型为`Vec3`。在创建材质实例的`update_plane_color`系统函数中，也相应地使用`#[cfg(...)]`来初始化这个字段为默认值（`Default::default()`）。

除了核心的代码修改，这个PR还做了两项必要的配套更改：
1. 在`bevy_feathers`的`Cargo.toml`中声明了`webgl`和`webgpu`这两个特性。这两个特性最初可能是空的，但它们的声明使得其他crate（如`bevy_internal`）可以条件性地依赖它们。
2. 在`bevy_internal`的`Cargo.toml`中，将`bevy_feathers`的可选依赖（`bevy_feathers?`）添加到了`webgl`和`webgpu`特性列表中。这使得当用户启用Bevy的`webgl`或`webgpu`特性时，会自动启用`bevy_feathers` crate的相应特性，从而触发条件编译代码路径。

这个解决方案的影响是立竿见影且积极的。它修复了`color_plane`控件在浏览器中的渲染问题，使其行为与本地平台一致。从工程角度看，这个PR展示了几个重要的实践：
*   **平台特定的兼容性处理**：通过条件编译，优雅地处理了不同图形后端（WebGL vs WebGPU vs 原生）的不同内存对齐要求。
*   **保持代码清晰**：填充字段的命名清晰地表明了其目的和适用环境（`_webgl2_padding_12b`）。
*   **最小化变更**：只添加了必要的填充，没有改动控件的核心逻辑或着色器算法。
*   **遵循现有模式**：解决方案借鉴了代码库中已有的处理方式，保持了一致性。

值得一提的是，作者`mitchty`在描述中谦称自己是“web编程的游客”，但其实现非常精准和专业，直接命中了WebGL uniform缓冲区对齐这个经典问题，并给出了正确的解决方案。

## 视觉图示

```mermaid
graph TD
    subgraph “构建配置层”
        BEVY_INTERNAL_Cargo[bevy_internal/Cargo.toml]
        BFEATURES_Cargo[bevy_feathers/Cargo.toml]
    end

    subgraph “运行时/着色器层”
        BFEATURES_RS[bevy_feathers/src/controls/color_plane.rs]
        BFEATURES_WGSL[bevy_feathers/src/assets/shaders/color_plane.wgsl]
    end

    BFEATURES_Cargo -- “声明 webgl/webgpu features” --> BFEATURES_RS
    BFEATURES_Cargo -- “声明 webgl/webgpu features” --> BFEATURES_WGSL
    BEVY_INTERNAL_Cargo -- “传递 features” --> BFEATURES_Cargo
    BFEATURES_RS -- “CPU端结构体定义与填充” --> BFEATURES_WGSL
    BFEATURES_WGSL -- “GPU端Uniform结构体定义与填充” --> BFEATURES_RS
```

## 关键文件变更

1.  **`crates/bevy_feathers/src/assets/shaders/color_plane.wgsl`**
    *   **变更描述**: 修改了WGSL着色器代码，将独立的uniform变量包装进一个结构体，并条件性地添加一个`vec3<f32>`填充字段以满足16字节对齐。这是修复WebGL兼容性的核心。
    *   **关键代码片段**:
        ```wgsl
        // 修改后：
        struct ColorPlaneUniform {
          fixed_channel : f32,
        #ifdef SIXTEEN_BYTE_ALIGNMENT
          _webgl2_padding_12b : vec3<f32>,
        #endif
        }

        @group(1) @binding(0) var<uniform> uniform_data : ColorPlaneUniform;
        ```
    *   **与PR目的的关系**: 确保在GPU端，uniform缓冲区的数据布局符合WebGL的严格对齐要求。

2.  **`crates/bevy_feathers/src/controls/color_plane.rs`**
    *   **变更描述**: 在Rust的材质结构体`ColorPlaneMaterial`中条件性地添加了一个`Vec3`填充字段，并在材质创建时初始化它。这确保了从CPU上传到GPU的数据结构与着色器的期望布局完全匹配。
    *   **关键代码片段**:
        ```rust
        // 在 ColorPlaneMaterial 结构体内添加：
        #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
        #[uniform(0)]
        _webgl2_padding_12b: Vec3,

        // 在创建材质时初始化：
        let material = r_materials.add(ColorPlaneMaterial {
            plane: *plane,
            fixed_channel: plane_value.0.z,
            #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
            _webgl2_padding_12b: Default::default(),
        });
        ```
    *   **与PR目的的关系**: 在CPU端提供与WGSL着色器对应的填充数据，并精确控制其只在需要的平台（WASM+WebGL）上存在。

3.  **`crates/bevy_feathers/Cargo.toml` 和 `crates/bevy_internal/Cargo.toml`**
    *   **变更描述**: 这两个文件添加了特性声明和传递。`bevy_feathers`声明了`webgl`和`webgpu`特性，`bevy_internal`则将这些特性链接到主crate的特性集上。
    *   **关键代码片段**:
        ```toml
        # bevy_feathers/Cargo.toml
        [features]
        webgl = []
        webgpu = []

        # bevy_internal/Cargo.toml
        webgl = [
          ...,
          "bevy_feathers?/webgl", # 新增
        ]
        webgpu = [
          ...,
          "bevy_feathers?/webgpu", # 新增
        ]
        ```
    *   **与PR目的的关系**: 建立起条件编译的通道。当用户使用`cargo build --features bevy/webgl`时，会最终启用`bevy_feathers/webgl`特性，从而激活上述Rust代码中的条件编译块。

## 延伸阅读

- **[WGSL Specification - Memory Layout](https://www.w3.org/TR/WGSL/#memory-layout)**: 官方WGSL规范中关于内存布局、结构体成员对齐和尺寸的详细说明。
- **[WebGL 2.0 Specification - Uniform Buffer Layout](https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.23)**: 关于WebGL 2.0中Uniform Buffer Object（UBO）布局和std140布局规则的官方文档。
- **Bevy 官方文档 - 着色器**: 了解Bevy如何处理和预处理着色器，以及如何定义材质和uniform。
- **文章：[《WebGL 2 Uniform Buffer Objects》](https://webgl2fundamentals.org/webgl/lessons/webgl2-uniform-blocks.html)**: 关于WebGL 2中Uniform Buffer Objects的实用教程，涵盖了std140布局规则。

# Full Code Diff
（此处按用户要求，完整附上了PR的diff内容）
```
diff --git a/crates/bevy_feathers/Cargo.toml b/crates/bevy_feathers/Cargo.toml
index 5d2ee7860aeda..0247e9690fc9e 100644
--- a/crates/bevy_feathers/Cargo.toml
+++ b/crates/bevy_feathers/Cargo.toml
@@ -40,6 +40,8 @@ accesskit = "0.23"
 [features]
 default = []
 custom_cursor = ["bevy_window/custom_cursor"]
+webgl = []
+webgpu = []
 
 [lints]
 workspace = true
diff --git a/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl b/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl
index 738c74937c29e..9a808be46b6ad 100644
--- a/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl
+++ b/crates/bevy_feathers/src/assets/shaders/color_plane.wgsl
@@ -5,21 +5,28 @@
     hsl_to_linear_rgb,
 }
 
-@group(1) @binding(0) var<uniform> fixed_channel: f32;
+struct ColorPlaneUniform {
+  fixed_channel : f32,
+#ifdef SIXTEEN_BYTE_ALIGNMENT
+  _webgl2_padding_12b : vec3<f32>,
+#endif
+}
+
+@group(1) @binding(0) var<uniform> uniform_data : ColorPlaneUniform;
 
 @fragment
 fn fragment(in: UiVertexOutput) -> @location(0) vec4<f32> {
     let uv = in.uv;
 #ifdef PLANE_RG
-    return vec4(srgb_to_linear_rgb(vec3(uv.x, uv.y, fixed_channel)), 1.0);
+    return vec4(srgb_to_linear_rgb(vec3(uv.x, uv.y, uniform_data.fixed_channel)), 1.0);
 #else ifdef PLANE_RB
-    return vec4(srgb_to_linear_rgb(vec3(uv.x, fixed_channel, uv.y)), 1.0);
+    return vec4(srgb_to_linear_rgb(vec3(uv.x, uniform_data.fixed_channel, uv.y)), 1.0);
 #else ifdef PLANE_GB
-    return vec4(srgb_to_linear_rgb(vec3(fixed_channel, uv.x, uv.y)), 1.0);
+    return vec4(srgb_to_linear_rgb(vec3(uniform_data.fixed_channel, uv.x, uv.y)), 1.0);
 #else ifdef PLANE_HS
-    return vec4(hsl_to_linear_rgb(vec3(uv.x, 1.0 - uv.y, fixed_channel)), 1.0);
+    return vec4(hsl_to_linear_rgb(vec3(uv.x, 1.0 - uv.y, uniform_data.fixed_channel)), 1.0);
 #else ifdef PLANE_HL
-    return vec4(hsl_to_linear_rgb(vec3(uv.x, fixed_channel, 1.0 - uv.y)), 1.0);
+    return vec4(hsl_to_linear_rgb(vec3(uv.x, uniform_data.fixed_channel, 1.0 - uv.y)), 1.0);
 #else
     // Error color
     return vec4(1.0, 0.0, 1.0, 1.0);
diff --git a/crates/bevy_feathers/src/controls/color_plane.rs b/crates/bevy_feathers/src/controls/color_plane.rs
index c0398fe8b47cb..8051a74748124 100644
--- a/crates/bevy_feathers/src/controls/color_plane.rs
+++ b/crates/bevy_feathers/src/controls/color_plane.rs
@@ -84,6 +84,10 @@ struct ColorPlaneMaterial {
 
     #[uniform(0)]
     fixed_channel: f32,
+
+    #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
+    #[uniform(0)]
+    _webgl2_padding_12b: Vec3,
 }
 
 impl From<&ColorPlaneMaterial> for ColorPlaneMaterialKey {
@@ -207,6 +211,8 @@ fn update_plane_color(
             let material = r_materials.add(ColorPlaneMaterial {
                 plane: *plane,
                 fixed_channel: plane_value.0.z,
+                #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
+                _webgl2_padding_12b: Default::default(),
             });
             commands.entity(*inner_ent).insert(MaterialNode(material));
         }
diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index 25fe37c361b53..49271579c6c85 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -191,6 +191,7 @@ webgl = [
   "bevy_gizmos_render?/webgl",
   "bevy_sprite_render?/webgl",
   "bevy_dev_tools?/webgl",
+  "bevy_feathers?/webgl",
 ]
 
 webgpu = [
@@ -201,6 +202,7 @@ webgpu = [
   "bevy_gizmos_render?/webgpu",
   "bevy_sprite_render?/webgpu",
   "bevy_dev_tools?/webgpu",
+  "bevy_feathers?/webgpu",
 ]
 
 # Enable systems that allow for automated testing on CI
```