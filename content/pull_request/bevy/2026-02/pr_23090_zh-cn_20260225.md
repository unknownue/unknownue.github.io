+++
title = "#23090 Add a `DelayedCommands` helper to support arbitrary delayed commands"
date = "2026-02-25T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23090-en-20260225" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23090-zh-cn-20260225" }}
labels = ["C-Feature", "A-ECS", "A-Time", "M-Release-Note", "D-Modest"]
+++

# Title

## Basic Information
- **Title**: Add a `DelayedCommands` helper to support arbitrary delayed commands
- **PR Link**: https://github.com/bevyengine/bevy/pull/23090
- **Author**: Runi-c
- **Status**: MERGED
- **Labels**: C-Feature, A-ECS, S-Ready-For-Final-Review, A-Time, M-Release-Note, D-Modest
- **Created**: 2026-02-21T00:42:37Z
- **Merged**: 2026-02-25T00:04:33Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

- 一个通用的"稍后做某事"机制对于许多游戏来说是可取的，尤其是在涉及游戏逻辑和视觉效果时。
- 修复了 https://github.com/bevyengine/bevy/issues/15129
- 关闭了 #20155

## Solution

- 基于 https://github.com/bevyengine/bevy/pull/20155#issuecomment-3702483127 的工作构建，特别是 @laundmo 的评论。
- 添加一个可通过 `commands.delayed()` 获得的 `DelayedCommands` 辅助器，它拥有 `CommandQueue` 并分发绑定到它们的新 `Commands`。
- 当 `DelayedCommands` 辅助器被丢弃时，将生成命令推送到主 `Commands` 上，以将队列作为 `DelayedCommandQueue` 实体生成。
- 这些实体由 `TimePlugin` 添加的新系统进行计时。当计时器触发时，队列将被提交到该系统的 `Commands` 中。

## Testing

- 在 `bevy_time` 中添加了一个新测试，它似乎可以工作。
- 我对像这样使用 `Drop` 等技巧并不熟悉，因此如果需要更改，请仔细审查并提供指导。

---

## Showcase

```rust
fn my_cool_system(mut commands: Commands) {
    // 相当简洁的一行延迟生成
    commands.delayed().secs(0.1).spawn(DummyComponent);

    // 可以存储 DelayedCommands 以便更简洁地重用
    let mut delayed = commands.delayed();
    // 分配立即发生，因此您甚至可以排队
    // 进一步操作尚未生成的实体
    let entity = delayed.secs(0.5).spawn_empty().id();
    delayed.secs(0.7).entity(entity).insert(DummyComponent);

    // `delayed.secs` 和 `delayed.duration` 都只是返回一个
    // 重新绑定到存储的 `CommandQueue` 的 `Commands`，因此您可以额外
    // 存储它并重用以使用相同的延迟排队多个命令
    let mut in_1_sec = delayed.duration(Duration::from_secs_f32(1.0));
    in_1_sec.spawn(DummyComponent);
    in_1_sec.spawn(DummyComponent);
    in_1_sec.spawn(DummyComponent);
}
```

## The Story of This Pull Request

### The Problem and Context

在游戏开发中，经常需要延迟执行某些操作——比如在1秒后生成一个实体、在特效结束后播放声音，或者在一段动画后触发游戏逻辑事件。之前的 Bevy 中，开发者需要手动管理定时器和命令队列，或者使用现有的 `Timer` 组件结合自定义系统来实现延迟效果。这种分散的实现方式导致了代码重复，并且缺乏一个统一、简洁的 API。

issue #15129 和 PR #20155 都探讨了这个问题，寻求一个通用的延迟命令解决方案。特别是，@laundmo 在 PR #20155 的评论中提出了一个关键的见解：通过创建一个持有 `CommandQueue` 的结构体，并在特定时间后将其提交到世界（world）中。这个思路成为了本 PR 实现的基础。

### The Solution Approach

本 PR 的核心思想是创建一个 `DelayedCommands` 辅助器，它作为 `Commands` 的扩展。这个辅助器允许开发者将命令（commands）排队到不同的 `CommandQueue` 中，每个队列关联一个特定的延迟时间。当 `DelayedCommands` 被丢弃时（通常是在系统函数结束时），这些队列会作为 `DelayedCommandQueue` 实体生成到世界中。然后，一个专门的系统（`check_delayed_command_queues`）会监视这些实体，在时间到达时执行队列中的命令。

这种方法有几个优点：
1. **API 简洁**：通过 `commands.delayed()` 和 `secs(delay)` 链式调用，代码可读性高。
2. **实体分配提前**：即使实体是延迟生成的，其 ID 也会立即分配，允许在生成前就对它进行其他延迟操作。
3. **队列复用**：相同延迟的命令可以共享同一个 `CommandQueue`，减少内存分配。

### The Implementation

实现主要集中在三个部分：`DelayedCommands` 结构体、`DelayedCommandsExt` 扩展 trait，以及处理延迟队列的系统。

首先，在 `crates/bevy_ecs/src/system/commands/mod.rs` 中添加了 `rebound_to` 方法，这是实现的关键基础：

```rust
pub fn rebound_to<'q>(&self, queue: &'q mut CommandQueue) -> Commands<'w, 'q> {
    Commands::new_from_entities(queue, self.allocator, self.entities)
}
```

这个方法允许创建一个新的 `Commands` 实例，将其绑定到指定的 `CommandQueue`，而不是默认的世界队列。这使得我们可以将命令写入一个临时队列，稍后再提交。

接下来，在新建的 `crates/bevy_time/src/delayed_commands.rs` 中定义了核心结构体：

```rust
pub struct DelayedCommands<'w, 's> {
    queues: HashMap<Duration, CommandQueue>,
    commands: Commands<'w, 's>,
}
```

`DelayedCommands` 内部使用 `HashMap` 按延迟时间组织队列。当调用 `duration` 或 `secs` 方法时，会获取或创建对应延迟时间的队列，并返回一个通过 `rebound_to` 绑定到该队列的 `Commands` 实例。

一个关键的设计是 `DelayedCommands` 实现了 `Drop` trait：

```rust
impl<'w, 's> Drop for DelayedCommands<'w, 's> {
    fn drop(&mut self) {
        self.submit();
    }
}
```

当 `DelayedCommands` 离开作用域时，`submit` 方法会将所有队列转换为 `DelayedCommandQueue` 组件并生成实体。这里使用了 `spawn_batch` 来批量生成，并将相对延迟时间转换为基于默认时钟的绝对时间。

最后，`check_delayed_command_queues` 系统在 `PreUpdate` 阶段运行，检查每个 `DelayedCommandQueue` 实体的 `submit_at` 时间是否已经到达。如果到达，就将队列中的命令提交到世界，并销毁该实体：

```rust
pub fn check_delayed_command_queues(
    queues: Query<(Entity, &mut DelayedCommandQueue)>,
    time: Res<Time>,
    mut commands: Commands,
) {
    let elapsed = time.elapsed();
    for (e, mut queue) in queues {
        if queue.submit_at <= elapsed {
            commands.append(&mut queue.queue);
            commands.entity(e).despawn();
        }
    }
}
```

### Technical Insights

这个实现展示了几个值得注意的技术点：

1. **使用 `Drop` 实现自动提交**：通过为 `DelayedCommands` 实现 `Drop` trait，确保了即使开发者忘记显式提交，命令队列也会在结构体销毁时自动处理。这是一种 RAII（Resource Acquisition Is Initialization）模式的应用。

2. **时间处理的抽象**：延迟时间以 `Duration` 表示，在提交时转换为基于 `Time` 资源的绝对时间。这使得系统可以统一处理不同来源的时间更新。

3. **命令队列的生命周期管理**：`CommandQueue` 被安全地封装在组件中，通过 ECS 系统进行管理，避免了手动内存管理的复杂性。

4. **API 的灵活性**：通过返回 `Commands` 实例而不是直接接受闭包，API 保持了与现有命令系统的一致性，开发者可以使用熟悉的 `spawn`、`insert`、`entity` 等方法。

需要注意的是，当前的实现有一个明确限制：所有延迟命令都使用默认时钟（`Time<()>`），并在 `PreUpdate` 阶段检查。这意味着不支持自定义时钟或更精细的时间控制。PR 作者在文档中明确指出，对于更复杂的需求，开发者需要实现自己的延迟系统。

### The Impact

这个 PR 为 Bevy 添加了一个实用的延迟命令机制，解决了游戏中常见的定时执行需求。它的主要影响包括：

1. **简化了延迟操作的实现**：开发者不再需要为每个延迟任务编写自定义系统和定时器管理代码。
2. **提供了统一的 API**：通过扩展 `Commands`，保持了 Bevy ECS API 的一致性。
3. **提高了代码可读性**：链式调用使得延迟命令的意图更加清晰。
4. **为社区提供了基础**：这个实现可以作为更复杂时间相关功能的基础。

从技术债务的角度看，这个实现相对简洁，没有过度设计，专注于解决最常见的用例。通过明确标注限制条件，也为未来的扩展留下了空间。

## Visual Representation

```mermaid
graph TD
    A[System调用 commands.delayed()] --> B[创建 DelayedCommands]
    B --> C[使用 secs/duration 获取 Commands]
    C --> D[向 CommandQueue 写入命令]
    B --> E[DelayedCommands Drop]
    E --> F[生成 DelayedCommandQueue 实体]
    F --> G[check_delayed_command_queues 系统]
    G --> H{时间是否到达?}
    H -->|是| I[提交 CommandQueue]
    H -->|是| J[销毁实体]
    I --> K[命令生效]
```

## Key Files Changed

1. **`crates/bevy_time/src/delayed_commands.rs` (+224/-0)**
   - 新建文件，包含了 `DelayedCommands`、`DelayedCommandQueue` 的定义和相关系统
   - 实现了核心的延迟命令逻辑和测试

2. **`examples/ecs/delayed_commands.rs` (+60/-0)**
   - 新增示例，展示如何使用延迟命令创建点击涟漪效果
   - 演示了根据距离计算不同延迟时间的实用场景

3. **`release-content/release-notes/delayed_commands.md` (+28/-0)**
   - 发布说明文档，介绍新功能和使用方法

4. **`crates/bevy_ecs/src/system/commands/mod.rs` (+14/-0)**
   - 添加了 `rebound_to` 方法，允许将 `Commands` 重新绑定到不同的 `CommandQueue`
   ```rust
   // 关键添加
   pub fn rebound_to<'q>(&self, queue: &'q mut CommandQueue) -> Commands<'w, 'q> {
       Commands::new_from_entities(queue, self.allocator, self.entities)
   }
   ```

5. **`Cargo.toml` (+11/-0)**
   - 添加了 `delayed_commands` 示例的配置
   ```toml
   [[example]]
   name = "delayed_commands"
   path = "examples/ecs/delayed_commands.rs"
   doc-scrape-examples = true
   ```

## Further Reading

1. **Bevy ECS Commands 系统**：了解 Bevy 的命令缓冲和执行机制
2. **RAII 模式**：资源获取即初始化，C++和Rust中常用的资源管理模式
3. **Entity Component System 模式**：游戏开发中常用的架构模式
4. **Rust 的 Drop trait**：理解资源清理和析构过程
5. **Bevy Time 系统**：Bevy 中的时间管理和时钟概念