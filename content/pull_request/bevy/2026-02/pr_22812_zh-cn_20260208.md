+++
title = "#22812 Fixes panic when using Option<Gizmos>"
date = "2026-02-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22812-en-20260208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22812-zh-cn-20260208" }}
+++

# Fixes panic when using Option<Gizmos>

## 基本信息
- **标题**: Fixes panic when using Option<Gizmos>
- **PR链接**: https://github.com/bevyengine/bevy/pull/22812
- **作者**: kfc35
- **状态**: 已合并
- **标签**: C-Bug, A-ECS, P-Crash, S-Ready-For-Final-Review, A-Gizmos, D-Straightforward
- **创建时间**: 2026-02-05T06:29:59Z
- **合并时间**: 2026-02-08T19:06:58Z
- **合并者**: alice-i-cecile

## 描述翻译

# 目标
- 修复 #14949
- 目前，当支持 `Gizmos` 的配置组（config group）尚未初始化时，一个 `Option<Gizmos>` 会导致 panic。当然，期望的行为是使其为 `None`。

## 解决方案
`Gizmos` 是一个非 `#[derive]` 的 `SystemParam`，它要求：
- 其 `GizmoConfigGroup` 在 `GizmoConfigStore` 中有对应的条目
- 各种 `GizmoStorage` 资源被插入到世界中。

为了以对用户非侵入性的方式支持一个不会 panic 的 `Option<Gizmos>` `SystemParam`（当 Gizmo 配置组没有被有意设置时），这个 PR：
- 向 `GizmoConfigStore` 添加了符合人体工程学的、可失败地获取组配置的方法
- 修改 `Gizmos` 的 `validate_param` 方法，使其在无法从 `GizmoConfigStore` 中找到自身配置时返回错误
- 修改 `GizmoBuffer` 的 `apply` 方法，使其仅在对应配置组的 `GizmoStorage` 存在时才应用更改。

## 测试
我修改了 2d gizmos 示例 (`cargo run --example 2d_gizmos`)，具体操作如下：
- 注释掉自定义 gizmo 组的初始化代码 `// .init_gizmo_group::<MyRoundGizmos>()`
- 在 `draw_example_collection` 中的两个 `Gizmos` 系统参数上使用 `Option`（即 `Option<Gizmos>` 和 `Option<Gizmos<MyRoundGizmos>>`），并且在使用解包后的 `my_gizmos` 绘制内容之前，要求 `my_gizmos_option.is_some()`。
- 当尝试获取 `MyRoundGizmos` 的配置时，使用新的 `GizmoConfigStore` 方法 `try_config_mut`，并且仅在 `my_config_option.is_some()` 时继续修改其设置。

没有崩溃发生。默认的 Gizmos 继续被绘制，而 `MyRoundGizmos` 不被绘制。修改设置对于默认 gizmos 仍然有效，即使它们被应用于 `MyRoundGizmos` 也没有效果。示例的性能似乎没有下降。

## 本次PR的技术叙事

这个问题源于 Bevy 引擎中 Gizmos 系统的设计。`Gizmos` 是一个用于在调试时绘制简单图形（如线条、球体）的系统参数（SystemParam）。用户可以创建自定义的 gizmo 配置组。当开发者尝试将 `Gizmos` 包装在 `Option` 中时（这是一种常见的 ECS 模式，用于处理可选功能），如果对应的 gizmo 配置组没有初始化，系统会在参数提取时发生 panic，而不是优雅地返回 `None`。

问题的核心在于 `Gizmos` 是一个手动实现的 `SystemParam`，其验证逻辑（`validate_param`）假设它所需的配置和资源总是存在的。这与 `Option<Gizmos>` 的预期行为相矛盾，`Option` 应该优雅地处理参数不存在的情况。

开发者采取的解决方案分为三个关键部分，以非破坏性（non-breaking）的方式增强了系统的健壮性。

首先，在 `config.rs` 中，重构了 `GizmoConfigStore` 的 API。原有的 `config()` 和 `config_mut()` 方法在配置不存在时会 panic。PR 保持了这些方法的原有行为（因为它们被广泛使用），但将它们的内部逻辑提取出来。然后，新增了对应的 `get_config()` 和 `get_config_mut()` 方法，这些方法返回 `Option`，允许调用者安全地检查配置是否存在。这是一个清晰、向后兼容的 API 演进。

```rust
// File: crates/bevy_gizmos/src/config.rs
// 修改前: `config` 方法直接 panic
pub fn config<T: GizmoConfigGroup>(&self) -> (&GizmoConfig, &T) {
    let Some((config, ext)) = self.get_config_dyn(&TypeId::of::<T>()) else {
        panic!("Requested config {} does not exist...");
    };
    // ... 向下转换等操作
}

// 修改后: `config` 方法调用新的 `get_config`，但保持 panic 行为
pub fn config<T: GizmoConfigGroup>(&self) -> (&GizmoConfig, &T) {
    let Some(configs) = self.get_config() else { // 调用新方法
        panic!("Requested config {} does not exist...");
    };
    configs
}

// 新增: 可失败的方法
pub fn get_config<T: GizmoConfigGroup>(&self) -> Option<(&GizmoConfig, &T)> {
    let (config, ext) = self.get_config_dyn(&TypeId::of::<T>())?; // 使用 `?` 操作符
    let ext = ext.as_any().downcast_ref().unwrap();
    Some((config, ext))
}
```

其次，在 `gizmos.rs` 中，改动了 `Gizmos` 系统参数实现的 `validate_param` 方法。这是支持 `Option<Gizmos>` 的核心。`validate_param` 在系统运行前被调用，用于验证参数是否可用。修改后的逻辑在内部状态验证通过后，会尝试获取一次配置。如果配置不存在（使用新增的 `get_config` 方法检查），它就返回一个 `SystemParamValidationError`。对于常规的 `Gizmos` 参数，这个错误会导致系统无法运行（这是期望的）。然而，对于 `Option<Gizmos>`，Bevy 的 ECS 框架会将此验证错误解释为“参数无效”，从而将 `Option<Gizmos>` 设置为 `None`。这正好实现了预期的行为。

```rust
// File: crates/bevy_gizmos/src/gizmos.rs
fn validate_param(...) -> Result<(), SystemParamValidationError> {
    // ... 原有状态验证
    unsafe { GizmosState::<Config, Clear>::validate_param(...)?; }

    // 新增的配置检查逻辑
    let (_, f1) = unsafe { GizmosState::<Config, Clear>::get_param(...) };
    // 使用新的 `get_config` 方法进行安全检查
    if f1.get_config::<Config>().is_none() {
        // 返回错误，这会使 `Option<Gizmos>` 变为 `None`
        Err(SystemParamValidationError::invalid::<Self>(...))
    } else {
        Ok(())
    }
}
```

第三，修改了 `GizmoBuffer`（负责存储图形数据）的 `queue` 方法。这是防御性编程。如果某个配置组的 `GizmoStorage` 资源没有被初始化（可能是因为配置组未初始化），但它的 `GizmoBuffer` 仍然被填充了数据，那么在 `queue` 阶段尝试获取该资源就会失败。修改后的逻辑使用 `world.get_resource_mut`（返回 `Option`）来安全地获取资源。如果资源存在，则追加数据；如果不存在，则清空缓冲区，防止其无限增长（内存泄漏）。这确保了系统的资源安全。

```rust
// File: crates/bevy_gizmos/src/gizmos.rs
fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
    // 安全地尝试获取资源
    if let Some(mut storage) = world.get_resource_mut::<GizmoStorage<Config, Clear>>() {
        // 资源存在，正常追加数据
        storage.list_positions.append(&mut self.list_positions);
        // ...
    } else {
        // 资源不存在，清空缓冲区避免内存泄漏
        self.list_positions.clear();
        // ...
    }
}
```

从技术角度来看，这个 PR 展示了如何增强一个现有的、非派生的 `SystemParam` 以支持 `Option` 包装器，这是 Bevy ECS 中一个强大的模式。关键洞察在于利用 `validate_param` 的返回错误机制，该机制是 `Option<SystemParam>` 能够工作的基础。同时，它也演示了如何通过添加可失败的方法（fallible methods）来扩展现有 API 而不破坏现有代码。性能方面，新增的检查开销很小，且只在参数验证阶段发生一次，因此对运行时性能没有显著影响，正如测试所验证的那样。

总的来说，这个修复提高了 `Gizmos` 系统的健壮性和开发者体验。它允许代码更灵活地处理可选的可视化调试功能，同时保持了与现有代码的完全兼容性。这种模式——在验证阶段进行存在性检查并为资源操作添加防御性逻辑——对于设计可靠的手动实现 `SystemParam` 是一个很好的参考。

## 视觉表示

```mermaid
graph TD
    subgraph “系统执行前”
        A[Option<Gizmos<MyGroup>> 参数提取] --> B[调用 validate_param]
        B --> C{配置组 MyGroup 已初始化？}
        C -- 是 --> D[验证成功，Option 变为 Some(Gizmos)]
        C -- 否 --> E[返回 SystemParamValidationError]
        E --> F[Option 保持为 None]
    end

    subgraph “系统执行中/后”
        G[GizmoBuffer 填充数据] --> H[调用 queue 方法]
        H --> I{GizmoStorage<MyGroup> 资源存在？}
        I -- 是 --> J[数据追加到存储]
        I -- 否 --> K[缓冲区被清空，防止泄露]
    end
```

## 关键文件更改

### `crates/bevy_gizmos/src/config.rs` (+40/-4)
**目的**：为 `GizmoConfigStore` 添加可安全失败（fallible）的配置获取方法，作为支持 `Option<Gizmos>` 的基础。
**关键修改**：
1.  重构了 `config()` 和 `config_mut()` 方法，使其调用新的 `get_config()` 和 `get_config_mut()` 方法，但保持 panic 行为以维持向后兼容性。
2.  新增了 `get_config()` 和 `get_config_mut()` 方法，它们返回 `Option`，允许调用者检查配置是否存在而不引发 panic。

```rust
// 关键新增方法示例
pub fn get_config<T: GizmoConfigGroup>(&self) -> Option<(&GizmoConfig, &T)> {
    let (config, ext) = self.get_config_dyn(&TypeId::of::<T>())?;
    let ext = ext.as_any().downcast_ref().unwrap();
    Some((config, ext))
}
```

### `crates/bevy_gizmos/src/gizmos.rs` (+34/-7)
**目的**：修改 `Gizmos` 系统参数的验证逻辑和缓冲区排队逻辑，以优雅处理配置或资源缺失的情况。
**关键修改**：
1.  在 `Gizmos::validate_param` 中，在完成基础状态验证后，增加了对配置存在性的检查。如果配置不存在，则返回错误，这将导致 `Option<Gizmos>` 被设为 `None`。
2.  在 `GizmoBuffer::queue` 中，将直接获取资源改为先尝试获取 `Option`。如果资源存在则追加数据，否则清空自身缓冲区，这是一种防御性措施，防止内存泄漏。

```rust
// validate_param 中的新增检查逻辑（片段）
if f1.get_config::<Config>().is_none() {
    Err(SystemParamValidationError::invalid::<Self>(
        format!("Requested config {} does not exist...", Config::type_path())))
} else {
    Ok(())
}

// queue 方法中的防御性逻辑
if let Some(mut storage) = world.get_resource_mut::<GizmoStorage<Config, Clear>>() {
    // 正常操作...
} else {
    // 清空缓冲区
    self.list_positions.clear();
    // ...
}
```

## 进一步阅读
1.  Bevy 官方文档中的 [SystemParam](https://docs.rs/bevy/latest/bevy/ecs/system/trait.SystemParam.html) trait 说明，了解自定义系统参数的工作原理。
2.  Bevy 官方示例中的 [System Parameter](https://github.com/bevyengine/bevy/blob/main/examples/ecs/system_param.rs) 示例，展示了包括 `Option` 在内的各种系统参数用法。
3.  GitHub Issue [#14949](https://github.com/bevyengine/bevy/issues/14949)，这是本 PR 所要解决的原问题，包含了更多的背景和讨论。
4.  Rust 编程中的 [Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html) 章节，理解 `Result` 和 `Option` 类型在处理潜在错误时的最佳实践。