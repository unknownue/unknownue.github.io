+++
title = "#22800 Fix Gizmos not drawing `On<Pointer<Drag>>`, Observers generally, and Triggered Systems"
date = "2026-02-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22800-en-20260209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22800-zh-cn-20260209" }}
+++

# 标题

## 基本信息
- **标题**: Fix Gizmos not drawing `On<Pointer<Drag>>`, Observers generally, and Triggered Systems
- **PR链接**: https://github.com/bevyengine/bevy/pull/22800
- **作者**: kfc35
- **状态**: 已合并
- **标签**: C-Bug, A-ECS, S-Ready-For-Final-Review, A-Gizmos, D-Straightforward
- **创建时间**: 2026-02-04T02:42:02Z
- **合并时间**: 2026-02-09T02:36:30Z
- **合并者**: alice-i-cecile

## 描述翻译
### 目标
- 修复 #22485
- 修复 #14566
- 修复 #19119

### 解决方案
- 为 `Gizmos` `SystemParam` 实现 `queue()` 方法。
- 经过大量调试，我发现当 `Gizmos` 系统参数在观察器（observer）内部使用时，从未在其上调用过 `apply()` 方法，这就是为什么其内部的 `SystemBuffer`（`GizmoBuffer`）会无限增长的原因。我看到 `SystemParam` 还有一个 `queue()` 函数，并且想知道是否反而调用了那个函数……结果确实是！因此，我以与 `apply()` 相同的方式实现了 `queue()`（在确认以这种方式使用 `DeferredWorld` 是可以的之后……看起来是可行的），这解决了问题。
- 编辑：我想这个问题在 #14597 中已经被描述过，那里描述的解决方案也是实现 `apply()`。
- 免责声明：本人并非 ECS 专家，因此请精通 ECS 的人士确认我写的内容是否合理。

### 测试
现在 #22485 中的重现示例可以工作了。如果你在窗口内拖动，中心会绘制一个白色的方形 Gizmo。
我还针对 #14566（两个示例）和 #19119 中的示例进行了测试，之前缺失的 Gizmo 现在都能绘制了。

## 本 Pull Request 的故事

这个 PR 解决了一个存在于 Bevy 引擎中相当长一段时间的 Bug。多个 issue（#22485、#14566、#19119）报告了相同的问题：当 Gizmo 的绘制逻辑被放置在观察器（例如 `On<Pointer<Drag>>`）或使用触发器的系统内时，它们不会按预期绘制。这个问题影响了用户交互反馈的可视化调试功能。

问题的根源在于 `Gizmos` 系统参数的内部生命周期管理。在 Bevy 的 ECS 中，`SystemParam` 有两种方式来将其缓存的数据刷新回世界（World）：`apply()` 和 `queue()`。`apply()` 方法在系统正常运行后被调用，负责将参数内部缓冲区（如 `GizmoBuffer`）的数据提交到主世界。然而，当系统作为观察器或触发器执行时，Bevy 的调度器会调用 `queue()` 方法，这个方法将缓冲操作排队到 `DeferredWorld`（一个用于延迟执行操作的世界代理）中，而不是直接应用到主世界。

作者 kfc35 通过调试发现，当 `Gizmos` 在观察器上下文中使用时，只有 `queue()` 方法被调用。由于 `Gizmos` 只实现了 `apply()` 方法而没有实现 `queue()`，这导致其内部的 `GizmoBuffer` 从未被清空。每次系统执行时，新的绘制命令都被追加到缓冲区中，但从未被提交或重置，导致缓冲区无限增长，并且最终没有绘制任何内容（因为命令从未被处理）。

解决方案直接而有效：为 `Gizmos` 系统参数实现 `queue()` 方法。新的实现委托给底层的 `GizmosState::queue` 函数，这与现有的 `apply()` 方法的模式相同。这种委托确保了无论系统是通过常规调度还是作为观察器/触发器运行，`Gizmos` 的缓冲区都能被正确管理。作者谨慎地确认了在 `queue()` 方法中使用 `DeferredWorld` 是安全的，因为这是其标准用途。

从技术角度看，这个修复凸显了 Bevy ECS 中 `SystemParam` 生命周期的两个阶段的重要性：`queue()` 用于在延迟上下文中缓冲操作，而 `apply()` 用于在系统正常执行后立即应用它们。`Gizmos` 之前只处理了其中一种情况，这就是导致不一致行为的原因。

这个修复的影响是立即且显著的：
1.  Gizmo 现在可以在观察器系统（如 `On<Pointer<Drag>>`）中正确绘制。
2.  修复了使用触发器的系统中的 Gizmo 绘制问题。
3.  防止了 `GizmoBuffer` 的内存泄漏（无限增长）。

一个值得注意的技术见解是，这个问题在 issue #14597 中已经被预见到，该问题建议为类似的系统参数实现 `apply()` 方法。有趣的是，`Gizmos` 已经有了 `apply()`，但问题在于某些执行路径调用了 `queue()`。这表明，对于任何需要维护跨系统执行状态的 `SystemParam`，同时实现 `apply()` 和 `queue()` 可能是一个最佳实践，以确保在所有调度场景下行为一致。

## 视觉表示

```mermaid
graph TD
    A[用户系统调用 Gizmos 绘制] --> B[GizmoBuffer 存储命令]
    B --> C{系统执行模式}
    C -->|常规调度| D[调用 apply() 方法]
    C -->|观察器/触发器| E[调用 queue() 方法]
    D --> F[数据应用到主世界]
    E --> G[操作排队到 DeferredWorld]
    F --> H[Gizmo 正确渲染]
    G --> H
    
    I[修复前缺失 queue()] --> J[Buffer 无限增长]
    J --> K[无 Gizmo 渲染]
```

## 关键文件变更

### `crates/bevy_gizmos/src/gizmos.rs`
**变更描述**：为 `Gizmos` 系统参数添加了缺失的 `queue()` 方法实现。

**代码片段**：
```rust
// 文件: crates/bevy_gizmos/src/gizmos.rs
// 在 impl<Config, Clear> SystemParam for Gizmos<'_, '_, Config, Clear> 块中

fn queue(state: &mut Self::State, system_meta: &SystemMeta, world: DeferredWorld) {
    GizmosState::<Config, Clear>::queue(&mut state.state, system_meta, world);
}
```

**关联性**：这个四行代码的添加是修复的核心。它确保了当包含 `Gizmos` 参数的系统作为观察器或触发器运行时，其缓冲区操作能够通过 `DeferredWorld` 被正确排队和处理。该实现遵循了与现有 `apply()` 方法相同的模式，只是传递了一个 `DeferredWorld` 引用，保持了代码的一致性和简洁性。

## 延伸阅读

1.  **Bevy 官方文档：SystemParam**
    - 链接：https://docs.rs/bevy/latest/bevy/ecs/system/trait.SystemParam.html
    - 描述：深入了解 `SystemParam` 特征及其方法（`apply`, `queue`, `init_state` 等）。

2.  **Bevy 官方示例：Gizmos**
    - 链接：https://github.com/bevyengine/bevy/tree/main/examples/2d 和 https://github.com/bevyengine/bevy/tree/main/examples/3d
    - 描述：查看使用 Gizmos 进行调试绘制的官方示例。

3.  **相关 Issue 和 PR**
    - #14597：早期关于类似问题的讨论，建议为系统参数实现 `apply()`。
    - #19119, #14566, #22485：报告此 Bug 的具体 issue，包含重现步骤和讨论。

4.  **Bevy 观察器（Observer）文档**
    - 链接：https://docs.rs/bevy/latest/bevy/ecs/observer/index.html
    - 描述：了解观察器模式及其在 Bevy ECS 中的工作原理，这有助于理解 `queue()` 方法的调用上下文。

5.  **《Rust 编程语言》**
    - 链接：https://doc.rust-lang.org/book/
    - 描述：巩固 Rust 基础，特别是特征（traits）和泛型（generics），这对于理解 `SystemParam` 的实现至关重要。

# 完整代码差异
```
diff --git a/crates/bevy_gizmos/src/gizmos.rs b/crates/bevy_gizmos/src/gizmos.rs
index 7ebd14669a5d4..efe24bdfa35bd 100644
--- a/crates/bevy_gizmos/src/gizmos.rs
+++ b/crates/bevy_gizmos/src/gizmos.rs
@@ -224,6 +224,10 @@ where
         GizmosState::<Config, Clear>::apply(&mut state.state, system_meta, world);
     }
 
+    fn queue(state: &mut Self::State, system_meta: &SystemMeta, world: DeferredWorld) {
+        GizmosState::<Config, Clear>::queue(&mut state.state, system_meta, world);
+    }
+
     #[inline]
     unsafe fn validate_param(
         state: &mut Self::State,
```