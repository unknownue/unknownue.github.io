+++
title = "#23023 Batch meshes with morph targets."
date = "2026-02-28T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23023-en-20260228" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23023-zh-cn-20260228" }}
labels = ["A-Rendering", "C-Performance", "M-Migration-Guide"]
+++

# Title
Batch meshes with morph targets.

## Basic Information
- **Title**: Batch meshes with morph targets.
- **PR Link**: https://github.com/bevyengine/bevy/pull/23023
- **Author**: pcwalton
- **Status**: MERGED
- **Labels**: A-Rendering, C-Performance, S-Ready-For-Final-Review, M-Migration-Guide
- **Created**: 2026-02-17T22:32:42Z
- **Merged**: 2026-02-28T21:41:57Z
- **Merged By**: alice-i-cecile

## Description Translation
Right now, Bevy can't batch meshes with morph targets together, because the morph targets are packed into a morph texture, which is non-bindless. To fix this, this PR adds support for batching morph targets together on platforms with storage buffers. Morph displacements are allocated using the mesh allocator, just like vertex and index buffers are.

This PR also improves the API for supplying morph targets to a mesh. Today, the application must create a `MorphTargetImage` explicitly to store the morph targets, which is cumbersome. This patch changes the `Mesh` API to instead take morph targets as a flat vector. Internally, if the platform doesn't support storage buffers, the morph targets are converted to a morph target image; if the platform does support storage buffers, however, the morph targets are packed in the mesh allocator.

This patch is a prerequisite for skin caching, because skin caching also applies to morph targets, and skin caching wants to skin many meshes at a time. Using a morph target image would either require batch breaking logic or bindless, neither of which are desirable for a feature that be simple and work on WebGPU, so I opted to make morph targets batchable instead.

On the `many_morph_targets` example, I went from 5.55 ms/frame to 2.80 ms/frame, a 1.98x speedup.

## The Story of This Pull Request

### The Problem and Context
Before this PR, Bevy's rendering system had a significant performance limitation when dealing with meshes that used morph targets. Morph targets, which allow for vertex-level animations by blending between different mesh shapes, were stored in 3D textures called `MorphTargetImage`. Each mesh with morph targets required its own texture, and because these textures weren't bindless, the rendering engine couldn't batch multiple morphed meshes together in a single draw call. This forced the renderer to issue separate draw calls for each morphed mesh, creating substantial CPU overhead and reducing rendering performance.

The API for setting up morph targets was also cumbersome. Developers had to manually create a `MorphTargetImage` from their morph data and pass it to the mesh, adding unnecessary complexity to asset loading pipelines. This was particularly problematic for features like skin caching, which needed to process many meshes simultaneously and couldn't afford the overhead of per-mesh texture bindings.

### The Solution Approach
The core solution was to make morph target data batchable by storing it in storage buffers on platforms that support them, similar to how vertex and index data are already managed. The mesh allocator, which previously only handled vertex and index buffers, was extended to also allocate storage for morph target displacement data. On platforms without storage buffer support (where bindless textures aren't available), the implementation falls back to the existing texture-based approach.

The API was simplified: instead of requiring developers to create a `MorphTargetImage`, they can now pass morph targets as a flat vector of `MorphAttributes` directly to the mesh. The system automatically handles the conversion to the appropriate storage format based on platform capabilities.

This approach provides several key benefits:
1. **Batching**: Meshes with morph targets can now be batched together when using storage buffers, significantly reducing draw calls
2. **Simplified API**: Developers work with straightforward vector data instead of texture assets
3. **Platform compatibility**: The system automatically chooses the optimal storage method for each platform
4. **Foundation for skin caching**: The same batching mechanism enables efficient skin caching for morphed meshes

### The Implementation
The implementation required changes across multiple subsystems in Bevy's rendering pipeline:

**Mesh Data Storage Changes**
The `Mesh` struct was modified to store morph targets as a `Vec<MorphAttributes>` instead of a `Handle<Image>`. The `MorphAttributes` struct was expanded with padding fields to ensure proper memory alignment for GPU storage:

```rust
#[derive(Copy, Clone, PartialEq, Debug, Reflect, ShaderType, Pod, Zeroable, Default)]
#[repr(C)]
pub struct MorphAttributes {
    pub position: Vec3,
    pub pad_a: f32,
    pub normal: Vec3,
    pub pad_b: f32,
    pub tangent: Vec3,
    pub pad_c: f32,
}
```

**Mesh Allocator Extension**
The mesh allocator was extended to handle morph target data as a new element class alongside vertices and indices. A new `MORPH_ATTRIBUTE_ELEMENT_LAYOUT` was added, and the allocator now tracks morph target slabs separately:

```rust
#[cfg(feature = "morph")]
static MORPH_ATTRIBUTE_ELEMENT_LAYOUT: ElementLayout = ElementLayout {
    class: ElementClass::MorphTarget,
    size: size_of::<MorphAttributes>() as u64,
    elements_per_slot: 1,
};
```

The `MeshSlabs` struct was introduced to bundle all slab IDs associated with a mesh:

```rust
#[derive(Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub struct MeshSlabs {
    pub vertex_slab_id: SlabId,
    pub index_slab_id: Option<SlabId>,
    pub morph_target_slab_id: Option<SlabId>,
}
```

**Dual-Path Rendering Pipeline**
The rendering system now has two distinct paths for handling morph targets, selected based on platform capabilities:

1. **Storage Buffer Path** (for platforms with storage buffer support): Morph data is stored in buffers managed by the mesh allocator, allowing batching
2. **Texture Path** (for platforms without storage buffer support): Morph data is packed into `MorphTargetImage` textures, maintaining compatibility but without batching

The `RenderMorphTargetAllocator` resource manages this duality:
```rust
#[derive(Resource)]
pub enum RenderMorphTargetAllocator {
    Image {
        mesh_id_to_image: HashMap<AssetId<Mesh>, MorphTargetImage>,
    },
    Storage,
}
```

**Shader Changes**
The shaders were updated to handle both storage buffer and texture-based morph targets. New functions like `morph_position`, `morph_normal`, and `morph_tangent` were added to abstract the data access method:

```wgsl
// For storage buffers:
fn morph_position(vertex_index: u32, weight_index: u32, instance_index: u32) -> vec3<f32> {
    return get_morph_target(vertex_index, weight_index, instance_index).position;
}

// For textures:
fn morph_position(vertex_index: u32, weight_index: u32, instance_index: u32) -> vec3<f32> {
    return morph(vertex_index, position_offset, weight_index);
}
```

**Batch Key Updates**
Batch keys throughout the rendering pipeline were updated to use `MeshSlabs` instead of separate vertex and index slab fields. This consolidated approach ensures all mesh data (vertices, indices, and morph targets) are considered together during batching.

### Technical Insights
**Memory Alignment Considerations**
The `MorphAttributes` struct includes explicit padding fields (`pad_a`, `pad_b`, `pad_c`) to ensure each `Vec3` starts on a 16-byte boundary. This is crucial for GPU performance and compatibility, as misaligned data can cause significant performance penalties or even runtime errors on some hardware.

**Dynamic Offset Management**
When using uniform buffers (the fallback path for platforms without storage buffers), the system manages dynamic offsets for both skinning and morph weight data. The `SetMeshBindGroup` render command was updated to handle these offsets correctly for both storage buffer and uniform buffer paths.

**Descriptor-Based GPU Data Management**
For the storage buffer path, the system introduces `GpuMorphDescriptor` structs that contain metadata about each mesh's morph targets:

```rust
#[derive(Clone, Copy, Default, ShaderType, Pod, Zeroable)]
#[repr(C)]
pub struct GpuMorphDescriptor {
    pub current_weights_offset: u32,
    pub prev_weights_offset: u32,
    pub targets_offset: u32,
    pub vertex_count: u32,
    pub weight_count: u32,
}
```

These descriptors are stored in a buffer and indexed by the `morph_descriptor_index` field in the `MeshUniform` struct, allowing the GPU to efficiently locate morph data for each mesh instance.

**Backwards Compatibility**
The PR maintains full backwards compatibility by automatically converting the new vector-based morph target data to the old texture format when running on platforms without storage buffer support. This ensures existing content continues to work while allowing new content to benefit from batching on capable hardware.

### The Impact
The performance impact is substantial: the `many_morph_targets` example shows a 1.98x speedup, dropping from 5.55 ms/frame to 2.80 ms/frame. This improvement comes primarily from the ability to batch multiple morphed meshes together, reducing CPU overhead and draw call counts.

The API simplification makes morph targets more accessible to developers, removing the need to understand texture packing for morph data. This aligns with Bevy's goal of providing ergonomic APIs that don't sacrifice performance.

The changes also lay the groundwork for future optimizations like skin caching, which can now leverage the same batching infrastructure for morphed meshes. This is particularly important for character rendering where both skinning and morph targets are commonly used together.

The implementation demonstrates a pattern for handling platform-specific optimizations in a clean, maintainable way, providing a template for future rendering optimizations that need to balance performance with broad hardware compatibility.

## Visual Representation

```mermaid
graph TB
    subgraph "CPU Side"
        A[Mesh with MorphAttributes vector] --> B{Mesh Allocator}
        B -->|Storage buffers supported| C[Allocate in storage buffer]
        B -->|No storage buffers| D[Create MorphTargetImage texture]
        C --> E[GPU Storage Buffer]
        D --> F[GPU Texture]
    end

    subgraph "GPU Side"
        E --> G{Shader Path Selection}
        F --> G
        G -->|Storage Buffer Path| H[Access via storage buffer]
        G -->|Texture Path| I[Access via texture sampling]
        H --> J[Morphed Vertex]
        I --> J
    end

    subgraph "Rendering Pipeline"
        K[Batch Key with MeshSlabs] --> L{Batching System}
        M[Mesh without morphs] --> L
        N[Mesh with morphs (storage)] --> L
        O[Mesh with morphs (texture)] --> L
        L -->|Can batch together| P[Meshes with storage buffer morphs]
        L -->|Cannot batch| Q[Separate draw calls for texture morphs]
    end
```

## Key Files Changed

### `crates/bevy_pbr/src/render/mesh.rs` (+460/-96)
This file contains the core changes to mesh rendering, including:
- Updated `MeshUniform` and `MeshInputUniform` to include `morph_descriptor_index`
- Modified `MeshPhaseBindGroups` to handle both uniform and storage buffer morph target bind groups
- Added new enum `MeshMorphTargetBindGroups` to manage bind groups based on storage buffer support
- Updated batching logic to consider morph target slab IDs

Key changes:
```rust
// Before: Separate vertex and index slab fields
pub struct Opaque3dBatchSetKey {
    pub vertex_slab: SlabId,
    pub index_slab: Option<SlabId>,
}

// After: Consolidated MeshSlabs
pub struct Opaque3dBatchSetKey {
    pub slabs: MeshSlabs,
}
```

### `crates/bevy_pbr/src/render/morph.rs` (+322/-34)
This file handles morph target extraction and preparation:
- Replaced the simple `MorphIndices` struct with an enum that supports both uniform and storage buffer paths
- Added `GpuMorphDescriptor` struct for GPU-side morph target metadata
- Implemented `prepare_morph_descriptors` system for storage buffer path
- Updated `extract_morphs` to handle both storage buffer and uniform buffer cases

Key changes:
```rust
// Before: Simple hash maps for indices
#[derive(Default, Resource)]
pub struct MorphIndices {
    pub current: MainEntityHashMap<MorphIndex>,
    pub prev: MainEntityHashMap<MorphIndex>,
}

// After: Enum with separate paths for uniform vs storage
#[derive(Resource)]
pub enum MorphIndices {
    Uniform {
        current: MainEntityHashMap<MorphIndex>,
        prev: MainEntityHashMap<MorphIndex>,
    },
    Storage {
        morph_weights_info: MainEntityHashMap<MorphWeightsInfo>,
        gpu_descriptor_indices: MainEntityHashMap<MorphDescriptorIndex>,
        gpu_descriptor_free_list: Vec<MorphDescriptorIndex>,
    },
}
```

### `crates/bevy_pbr/src/render/mesh_bindings.rs` (+198/-99)
This file contains bind group layout definitions:
- Updated bind group layouts to conditionally include storage buffer bindings
- Modified `MeshLayouts` to handle both texture and storage buffer paths for morph targets
- Added support for morph descriptor buffers in storage buffer path

Key changes:
```rust
// Updated layout creation to conditionally include storage buffer bindings
fn morphed_layout(render_device: &RenderDevice) -> BindGroupLayoutDescriptor {
    let limits = render_device.limits();
    let mut entries: ArrayVec<BindGroupLayoutEntry, 4> = ArrayVec::new();
    
    entries.extend([
        (0, layout_entry::model(&limits)),
        (2, layout_entry::weights(&limits)),
        (3, layout_entry::targets(&limits)),
    ].iter().map(|(binding, entry)| entry.build(*binding, ShaderStages::VERTEX)));
    
    if !skin::skins_use_uniform_buffers(&render_device.limits()) {
        entries.push(layout_entry::morph_descriptors().build(8, ShaderStages::VERTEX));
    }
    
    BindGroupLayoutDescriptor::new("morphed_mesh_layout", &entries)
}
```

### `crates/bevy_render/src/mesh/morph.rs` (+274/-0)
This is a new file that consolidates morph target rendering logic:
- Defines `MorphTargetImage` for texture-based morph targets
- Implements `RenderMorphTargetAllocator` to manage morph target storage based on platform capabilities
- Provides `MorphTargetsResource` enum to abstract texture vs buffer access

Key code:
```rust
#[derive(Resource)]
pub enum RenderMorphTargetAllocator {
    Image {
        mesh_id_to_image: HashMap<AssetId<Mesh>, MorphTargetImage>,
    },
    Storage,
}

impl RenderMorphTargetAllocator {
    pub fn allocate(
        &mut self,
        render_device: &RenderDevice,
        render_queue: &RenderQueue,
        mesh_id: AssetId<Mesh>,
        targets: &[MorphAttributes],
        vertex_count: usize,
    ) {
        match *self {
            RenderMorphTargetAllocator::Image { ref mut mesh_id_to_image } => {
                if let Ok(morph_target_image) =
                    MorphTargetImage::new(render_device, render_queue, targets, vertex_count)
                {
                    mesh_id_to_image.insert(mesh_id, morph_target_image);
                }
            }
            RenderMorphTargetAllocator::Storage => {
                // Do nothing. Morph target displacements are managed by the
                // mesh allocator in this case.
            }
        }
    }
}
```

### `examples/stress_tests/many_morph_targets.rs` (+200/-53)
The example was updated to demonstrate the new API and test performance:
- Simplified morph target setup using the new vector-based API
- Added various spawning patterns to test different batching scenarios
- Improved animation variation to better stress test the system

Key changes:
```rust
// Before: Manual MorphTargetImage creation
let morph_target_image = MorphTargetImage::new(...);
mesh.set_morph_targets(handle);

// After: Direct vector assignment
mesh.set_morph_targets(
    morph_target_reader
        .flat_map(|i| PrimitiveMorphAttributesIter { ... })
        .collect()
);
```

## Further Reading

1. **WebGPU Storage Buffers**: Understanding storage buffers is crucial for this PR. The [WebGPU specification](https://gpuweb.github.io/gpuweb/#storage-buffer) provides details on storage buffer usage and limitations.

2. **Morph Target Animation**: For background on morph target animation techniques, the [Wikipedia article on morph target animation](https://en.wikipedia.org/wiki/Morph_target_animation) provides a good overview.

3. **Bevy Mesh Allocator**: The existing mesh allocator documentation in Bevy's source code (`crates/bevy_render/src/mesh/allocator.rs`) provides context for how vertex and index data are managed.

4. **WGSL Shader Language**: The [WGSL specification](https://www.w3.org/TR/WGSL/) is useful for understanding the shader changes made in this PR, particularly around storage buffer access patterns.

5. **GPU-Driven Rendering**: This PR moves Bevy further toward GPU-driven rendering architectures. Resources like [GPU-Driven Rendering](https://advances.realtimerendering.com/s2021/index.html) from Advances in Real-Time Rendering provide context for why batching is important.

6. **Bevy Rendering Architecture**: The [Bevy Render Graph documentation](https://bevyengine.org/learn/quick-start/rendering/render-graph/) helps understand how this PR fits into Bevy's overall rendering pipeline.