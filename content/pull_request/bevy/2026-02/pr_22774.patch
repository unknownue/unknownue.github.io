diff --git a/crates/bevy_render/src/render_resource/pipeline_cache.rs b/crates/bevy_render/src/render_resource/pipeline_cache.rs
index ca5de7160d514..a7cc9907d98c1 100644
--- a/crates/bevy_render/src/render_resource/pipeline_cache.rs
+++ b/crates/bevy_render/src/render_resource/pipeline_cache.rs
@@ -249,6 +249,7 @@ impl PipelineCache {
 
         Self {
             shader_cache: Arc::new(Mutex::new(ShaderCache::new(
+                device.clone(),
                 device.features(),
                 render_adapter.get_downlevel_capabilities().flags,
                 load_module,
@@ -481,7 +482,6 @@ impl PipelineCache {
                 let mut layout_cache = layout_cache.lock().unwrap();
 
                 let vertex_module = match shader_cache.get(
-                    &device,
                     id,
                     descriptor.vertex.shader.id(),
                     &descriptor.vertex.shader_defs,
@@ -492,12 +492,7 @@ impl PipelineCache {
 
                 let fragment_module = match &descriptor.fragment {
                     Some(fragment) => {
-                        match shader_cache.get(
-                            &device,
-                            id,
-                            fragment.shader.id(),
-                            &fragment.shader_defs,
-                        ) {
+                        match shader_cache.get(id, fragment.shader.id(), &fragment.shader_defs) {
                             Ok(module) => Some(module),
                             Err(err) => return Err(err),
                         }
@@ -594,15 +589,11 @@ impl PipelineCache {
                 let mut shader_cache = shader_cache.lock().unwrap();
                 let mut layout_cache = layout_cache.lock().unwrap();
 
-                let compute_module = match shader_cache.get(
-                    &device,
-                    id,
-                    descriptor.shader.id(),
-                    &descriptor.shader_defs,
-                ) {
-                    Ok(module) => module,
-                    Err(err) => return Err(err),
-                };
+                let compute_module =
+                    match shader_cache.get(id, descriptor.shader.id(), &descriptor.shader_defs) {
+                        Ok(module) => module,
+                        Err(err) => return Err(err),
+                    };
 
                 let layout = if descriptor.layout.is_empty() && descriptor.immediate_size == 0 {
                     None
diff --git a/crates/bevy_shader/src/lib.rs b/crates/bevy_shader/src/lib.rs
index 3208ea469f993..d31bc94e5d8cc 100644
--- a/crates/bevy_shader/src/lib.rs
+++ b/crates/bevy_shader/src/lib.rs
@@ -1,4 +1,4 @@
-#![expect(missing_docs, reason = "Not all docs are written yet, see #3492.")]
+//! Provides [`Shader`] assets for Bevy.
 
 extern crate alloc;
 
diff --git a/crates/bevy_shader/src/shader.rs b/crates/bevy_shader/src/shader.rs
index fdf7177da65f2..5288945f72c9c 100644
--- a/crates/bevy_shader/src/shader.rs
+++ b/crates/bevy_shader/src/shader.rs
@@ -7,20 +7,6 @@ use thiserror::Error;
 
 define_atomic_id!(ShaderId);
 
-#[derive(Error, Debug)]
-pub enum ShaderReflectError {
-    #[error(transparent)]
-    WgslParse(#[from] naga::front::wgsl::ParseError),
-    #[cfg(feature = "shader_format_glsl")]
-    #[error("GLSL Parse Error: {0:?}")]
-    GlslParse(Vec<naga::front::glsl::Error>),
-    #[cfg(feature = "shader_format_spirv")]
-    #[error(transparent)]
-    SpirVParse(#[from] naga::front::spv::Error),
-    #[error(transparent)]
-    Validation(#[from] naga::WithSpan<naga::valid::ValidationError>),
-}
-
 /// Describes whether or not to perform runtime checks on shaders.
 /// Runtime checks can be enabled for safety at the cost of speed.
 /// By default no runtime checks will be performed.
@@ -44,19 +30,23 @@ pub enum ValidateShader {
     Enabled,
 }
 
-/// An "unprocessed" shader. It can contain preprocessor directives.
+/// An "unprocessed" shader. It can contain preprocessor directives and imports.
 #[derive(Asset, TypePath, Debug, Clone)]
 pub struct Shader {
+    /// The asset path of the shader.
     pub path: String,
+    /// The raw source code of the shader.
     pub source: Source,
+    /// The path from which this shader can be imported by other shaders.
     pub import_path: ShaderImport,
+    /// The import paths this shader depends on.
     pub imports: Vec<ShaderImport>,
-    // extra imports not specified in the source string
+    /// Extra imports not specified in the source string.
     pub additional_imports: Vec<naga_oil::compose::ImportDefinition>,
-    // any shader defs that will be included when this module is used
+    /// Any shader defs that should be included when this module is used.
     pub shader_defs: Vec<ShaderDefVal>,
-    // we must store strong handles to our dependencies to stop them
-    // from being immediately dropped if we are the only user.
+    /// Strong handles to this shader's dependencies, to prevent them
+    /// from being immediately dropped if this shader is the only user.
     pub file_dependencies: Vec<Handle<Shader>>,
     /// Enable or disable runtime shader validation, trading safety against speed.
     ///
@@ -92,6 +82,7 @@ impl Shader {
         (import_path, imports)
     }
 
+    /// Creates a new WGSL shader.
     pub fn from_wgsl(source: impl Into<Cow<'static, str>>, path: impl Into<String>) -> Shader {
         let source = source.into();
         let path = path.into();
@@ -108,6 +99,7 @@ impl Shader {
         }
     }
 
+    /// Creates a new WGSL shader with some given shader defs.
     pub fn from_wgsl_with_defs(
         source: impl Into<Cow<'static, str>>,
         path: impl Into<String>,
@@ -119,6 +111,7 @@ impl Shader {
         }
     }
 
+    /// Creates a new GLSL shader.
     pub fn from_glsl(
         source: impl Into<Cow<'static, str>>,
         stage: naga::ShaderStage,
@@ -139,6 +132,7 @@ impl Shader {
         }
     }
 
+    /// Creates a new SPIR-V shader.
     pub fn from_spirv(source: impl Into<Cow<'static, [u8]>>, path: impl Into<String>) -> Shader {
         let path = path.into();
         Shader {
@@ -153,6 +147,7 @@ impl Shader {
         }
     }
 
+    /// Creates a new Wesl shader.
     #[cfg(feature = "shader_format_wesl")]
     pub fn from_wesl(source: impl Into<Cow<'static, str>>, path: impl Into<String>) -> Shader {
         let source = source.into();
@@ -188,25 +183,6 @@ impl Shader {
             }
         }
     }
-
-    pub fn set_import_path<P: Into<String>>(&mut self, import_path: P) {
-        self.import_path = ShaderImport::Custom(import_path.into());
-    }
-
-    #[must_use]
-    pub fn with_import_path<P: Into<String>>(mut self, import_path: P) -> Self {
-        self.set_import_path(import_path);
-        self
-    }
-
-    #[inline]
-    pub fn import_path(&self) -> &ShaderImport {
-        &self.import_path
-    }
-
-    pub fn imports(&self) -> impl ExactSizeIterator<Item = &ShaderImport> {
-        self.imports.iter()
-    }
 }
 
 impl<'a> From<&'a Shader> for naga_oil::compose::ComposableModuleDescriptor<'a> {
@@ -227,6 +203,7 @@ impl<'a> From<&'a Shader> for naga_oil::compose::ComposableModuleDescriptor<'a>
             })
             .collect();
 
+        // It is beyond me why this doesn't just use `shader.import_path.module_name()`.
         let as_name = match &shader.import_path {
             ShaderImport::AssetPath(asset_path) => Some(format!("\"{asset_path}\"")),
             ShaderImport::Custom(_) => None,
@@ -254,6 +231,8 @@ impl<'a> From<&'a Shader> for naga_oil::compose::NagaModuleDescriptor<'a> {
     }
 }
 
+/// Raw shader source code.
+#[expect(missing_docs, reason = "The variants are self-explanatory.")]
 #[derive(Debug, Clone)]
 pub enum Source {
     Wgsl(Cow<'static, str>),
@@ -266,6 +245,7 @@ pub enum Source {
 }
 
 impl Source {
+    /// The underlying source code string, unless it is SPIR-V.
     pub fn as_str(&self) -> &str {
         match self {
             Source::Wgsl(s) | Source::Wesl(s) | Source::Glsl(s, _) => s,
@@ -312,11 +292,14 @@ impl From<&Source> for naga_oil::compose::ShaderType {
     }
 }
 
+/// The [`AssetLoader`] responsible for loading unprocessed shader assets.
 #[derive(Default, TypePath)]
 pub struct ShaderLoader;
 
+/// An error encountered while loading a shader's source.
 #[non_exhaustive]
 #[derive(Debug, Error)]
+#[expect(missing_docs, reason = "The variants are self-explanatory.")]
 pub enum ShaderLoaderError {
     #[error("Could not load shader: {0}")]
     Io(#[from] std::io::Error),
@@ -327,7 +310,7 @@ pub enum ShaderLoaderError {
 /// Settings for loading shaders.
 #[derive(serde::Serialize, serde::Deserialize, Debug, Default)]
 pub struct ShaderSettings {
-    /// The `#define` specified for this shader.
+    /// The `#define`s specified for this shader.
     pub shader_defs: Vec<ShaderDefVal>,
 }
 
@@ -393,13 +376,17 @@ impl AssetLoader for ShaderLoader {
     }
 }
 
+/// A shader import, described as either an asset path or an import path.
 #[derive(Debug, PartialEq, Eq, Clone, Hash)]
 pub enum ShaderImport {
+    /// An asset path to a shader.
     AssetPath(String),
+    /// An import path from which a shader may be imported.
     Custom(String),
 }
 
 impl ShaderImport {
+    /// A name for a shader import.
     pub fn module_name(&self) -> Cow<'_, String> {
         match self {
             ShaderImport::AssetPath(s) => Cow::Owned(format!("\"{s}\"")),
@@ -414,9 +401,9 @@ pub enum ShaderRef {
     /// Use the "default" shader for the current context.
     #[default]
     Default,
-    /// A handle to a shader stored in the [`Assets<Shader>`](bevy_asset::Assets) resource
+    /// A handle to a shader stored in the [`Assets<Shader>`](bevy_asset::Assets) resource.
     Handle(Handle<Shader>),
-    /// An asset path leading to a shader
+    /// An asset path leading to a shader.
     Path(AssetPath<'static>),
 }
 
diff --git a/crates/bevy_shader/src/shader_cache.rs b/crates/bevy_shader/src/shader_cache.rs
index 37e7164cce8b1..d5693b3056269 100644
--- a/crates/bevy_shader/src/shader_cache.rs
+++ b/crates/bevy_shader/src/shader_cache.rs
@@ -8,17 +8,15 @@ use thiserror::Error;
 use tracing::debug;
 use wgpu_types::{DownlevelFlags, Features};
 
-/// Source of a shader module.
+/// Fully composed source code of a shader module, with all shader defs applied.
 ///
-/// The source will be parsed and validated.
+/// This is roughly equivalent to [`wgpu::ShaderSource`](https://docs.rs/wgpu/latest/wgpu/enum.ShaderSource.html),
+/// but with less variants and more concrete types instead of [`Cow`](alloc::borrow::Cow).
 ///
-/// Any necessary shader translation (e.g. from WGSL to SPIR-V or vice versa)
-/// will be done internally by wgpu.
-///
-/// This type is unique to the Rust API of `wgpu`. In the WebGPU specification,
-/// only WGSL source code strings are accepted.
+/// This source will be parsed and validated by the renderer.
 ///
-/// This is roughly equivalent to `wgpu::ShaderSource`
+/// Any necessary shader translation (e.g. from WGSL to SPIR-V or vice versa)
+/// must be done internally by the renderer.
 #[cfg_attr(
     not(feature = "decoupled_naga"),
     expect(
@@ -37,6 +35,8 @@ pub enum ShaderCacheSource<'a> {
     Naga(naga::Module),
 }
 
+/// An id of a pipeline, typically in the [`PipelineCache`](https://docs.rs/bevy/latest/bevy/render/render_resource/struct.PipelineCache.html)
+/// Typically corresponds to a unique combination of [`Shader`] and [`ShaderDefVal`]s.
 pub type CachedPipelineId = usize;
 
 struct ShaderData<ShaderModule> {
@@ -57,7 +57,15 @@ impl<T> Default for ShaderData<T> {
     }
 }
 
+/// A cache for shaders and shader imports, with asset state-tracking for
+/// waiting to load shaders until all imports are resolved.
+///
+/// Note that the `RenderDevice` generic parameter is a means by which
+/// to avoid a cyclic dependency with `bevy_render`, while also permitting
+/// alternative rendering implementations. The actual processing of the
+/// shader source into a usable compiled module is left to the renderer.
 pub struct ShaderCache<ShaderModule, RenderDevice> {
+    device: RenderDevice,
     data: HashMap<AssetId<Shader>, ShaderData<ShaderModule>>,
     load_module: fn(
         &RenderDevice,
@@ -69,9 +77,14 @@ pub struct ShaderCache<ShaderModule, RenderDevice> {
     shaders: HashMap<AssetId<Shader>, Shader>,
     import_path_shaders: HashMap<ShaderImport, AssetId<Shader>>,
     waiting_on_import: HashMap<ShaderImport, Vec<AssetId<Shader>>>,
+    // The naga composer is only public for providing error messages and should not be touched.
+    #[doc(hidden)]
     pub composer: naga_oil::compose::Composer,
 }
 
+/// A compile time shader value definition to be inlined into the shader source.
+/// Variant tuples contain the name of the definition, and the value.
+#[expect(missing_docs, reason = "Enum variants are self-explanatory")]
 #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Debug, Hash)]
 pub enum ShaderDefVal {
     Bool(String, bool),
@@ -92,6 +105,7 @@ impl From<String> for ShaderDefVal {
 }
 
 impl ShaderDefVal {
+    /// Returns the value of the define as a string.
     pub fn value_as_string(&self) -> String {
         match self {
             ShaderDefVal::Bool(_, def) => def.to_string(),
@@ -102,7 +116,11 @@ impl ShaderDefVal {
 }
 
 impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
+    /// Creates a new [`ShaderCache`] with the given features and shader
+    /// module loading function. `load_module` is responsible for actually
+    /// compiling shader source into a module usable by the render device.
     pub fn new(
+        device: RenderDevice,
         features: Features,
         downlevel: DownlevelFlags,
         load_module: fn(
@@ -120,6 +138,7 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
         let composer = composer.with_capabilities(capabilities);
 
         Self {
+            device,
             composer,
             load_module,
             data: Default::default(),
@@ -161,9 +180,18 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
         Ok(())
     }
 
+    /// Attempts to retrieve or create a compiled shader module for the given
+    /// shader id and shader definitions.
+    ///
+    /// The provided `pipeline` is tracked so it may later be reported "dirty"
+    /// when a shader is removed or replaced.
+    ///
+    /// Note that the cache is keyed by `id` and `shader_defs`, meaning providing
+    /// the same `shader_defs` in a different order, or with redundancies, will
+    /// not result in cache hits, and thus require re-composing the module and
+    /// calling `load_module` again.
     pub fn get(
         &mut self,
-        render_device: &RenderDevice,
         pipeline: CachedPipelineId,
         id: AssetId<Shader>,
         shader_defs: &[ShaderDefVal],
@@ -175,7 +203,8 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
 
         let data = self.data.entry(id).or_default();
         let n_asset_imports = shader
-            .imports()
+            .imports
+            .iter()
             .filter(|import| matches!(import, ShaderImport::AssetPath(_)))
             .count();
         let n_resolved_asset_imports = data
@@ -189,7 +218,6 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
 
         data.pipelines.insert(pipeline);
 
-        // PERF: this shader_defs clone isn't great. use raw_entry_mut when it stabilizes
         let module = match data.processed_shaders.entry_ref(shader_defs) {
             EntryRef::Occupied(entry) => entry.into_mut(),
             EntryRef::Vacant(entry) => {
@@ -201,7 +229,7 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
                     Source::SpirV(data) => ShaderCacheSource::SpirV(data.as_ref()),
                     #[cfg(feature = "shader_format_wesl")]
                     Source::Wesl(_) => {
-                        if let ShaderImport::AssetPath(path) = shader.import_path() {
+                        if let ShaderImport::AssetPath(path) = &shader.import_path {
                             let shader_resolver =
                                 ShaderResolver::new(&self.module_path_to_asset_id, &self.shaders);
                             let module_path = wesl::syntax::ModulePath::from_path(path);
@@ -237,7 +265,7 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
                         }
                     }
                     _ => {
-                        for import in shader.imports() {
+                        for import in shader.imports.iter() {
                             Self::add_import_to_composer(
                                 &mut self.composer,
                                 &self.import_path_shaders,
@@ -294,7 +322,7 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
                 };
 
                 let shader_module =
-                    (self.load_module)(render_device, shader_source, &shader.validate_shader)?;
+                    (self.load_module)(&self.device, shader_source, &shader.validate_shader)?;
 
                 entry.insert(Arc::new(shader_module))
             }
@@ -322,9 +350,13 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
         pipelines_to_queue
     }
 
+    /// Inserts and possibly replaces a shader at the given asset id.
+    ///
+    /// Returns a vec of which cached pipelines depended on it
+    /// (directly or indirectly via a shader import) and thus must be recompiled.
     pub fn set_shader(&mut self, id: AssetId<Shader>, shader: Shader) -> Vec<CachedPipelineId> {
         let pipelines_to_queue = self.clear(id);
-        let path = shader.import_path();
+        let path = &shader.import_path;
         self.import_path_shaders.insert(path.clone(), id);
         if let Some(waiting_shaders) = self.waiting_on_import.get_mut(path) {
             for waiting_shader in waiting_shaders.drain(..) {
@@ -337,7 +369,7 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
             }
         }
 
-        for import in shader.imports() {
+        for import in shader.imports.iter() {
             if let Some(import_id) = self.import_path_shaders.get(import).copied() {
                 // resolve import because it is currently available
                 let data = self.data.entry(id).or_default();
@@ -353,7 +385,7 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
 
         #[cfg(feature = "shader_format_wesl")]
         if let Source::Wesl(_) = shader.source
-            && let ShaderImport::AssetPath(path) = shader.import_path()
+            && let ShaderImport::AssetPath(path) = &shader.import_path
         {
             self.module_path_to_asset_id
                 .insert(wesl::syntax::ModulePath::from_path(path), id);
@@ -362,16 +394,21 @@ impl<ShaderModule, RenderDevice> ShaderCache<ShaderModule, RenderDevice> {
         pipelines_to_queue
     }
 
+    /// Removes the shader with the given asset id.
+    ///
+    /// Returns a vec of which cached pipelines depended on it
+    /// (directly or indirectly via a shader import) and thus must be recompiled.
     pub fn remove(&mut self, id: AssetId<Shader>) -> Vec<CachedPipelineId> {
         let pipelines_to_queue = self.clear(id);
         if let Some(shader) = self.shaders.remove(&id) {
-            self.import_path_shaders.remove(shader.import_path());
+            self.import_path_shaders.remove(&shader.import_path);
         }
 
         pipelines_to_queue
     }
 }
 
+/// A Wesl import resolver. Maps module paths to actual Wesl shader source.
 #[cfg(feature = "shader_format_wesl")]
 pub struct ShaderResolver<'a> {
     module_path_to_asset_id: &'a HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
@@ -380,6 +417,9 @@ pub struct ShaderResolver<'a> {
 
 #[cfg(feature = "shader_format_wesl")]
 impl<'a> ShaderResolver<'a> {
+    /// Creates a shader resolver with the given map of module paths to shader asset ids,
+    /// and map of shader asset ids to shader source. This resolver is not meant to be
+    /// long living.
     pub fn new(
         module_path_to_asset_id: &'a HashMap<wesl::syntax::ModulePath, AssetId<Shader>>,
         shaders: &'a HashMap<AssetId<Shader>, Shader>,
@@ -413,6 +453,7 @@ impl<'a> wesl::Resolver for ShaderResolver<'a> {
 }
 
 /// Type of error returned by a `PipelineCache` when the creation of a GPU pipeline object failed.
+#[expect(missing_docs, reason = "Enum variants are self-explanatory")]
 #[derive(Error, Debug)]
 pub enum ShaderCacheError {
     #[error(
diff --git a/crates/bevy_utils/src/atomic_id.rs b/crates/bevy_utils/src/atomic_id.rs
index 4832bff74b968..6d57f50989f98 100644
--- a/crates/bevy_utils/src/atomic_id.rs
+++ b/crates/bevy_utils/src/atomic_id.rs
@@ -1,11 +1,19 @@
-/// Defines an id type which guarantees global uniqueness via atomics on a static global.
+/// Defines a 32-bit id type which guarantees global uniqueness via atomics on a static global.
+///
+/// Note that this means the id space is process-wide, as such it may potentially be exhausted
+/// by a combination of long-running processes and multiple bevy `World`s, at which point we panic.
 #[macro_export]
 macro_rules! define_atomic_id {
     ($atomic_id_type:ident) => {
+        /// Globally unique 32-bit id, guaranteed via atomics on a static global.
+        ///
+        /// Note that this means the id space is process-wide, as such it may potentially be exhausted
+        /// by a combination of long-running processes and multiple bevy `World`s, at which point we panic.
         #[derive(Copy, Clone, Hash, Eq, PartialEq, PartialOrd, Ord, Debug)]
         pub struct $atomic_id_type(core::num::NonZero<u32>);
 
         impl $atomic_id_type {
+            /// Creates a new id via fetch_add atomic on a static global.
             #[expect(
                 clippy::new_without_default,
                 reason = "Implementing the `Default` trait on atomic IDs would imply that two `<AtomicIdType>::default()` equal each other. By only implementing `new()`, we indicate that each atomic ID created will be unique."
diff --git a/release-content/migration-guides/bevy_shader.md b/release-content/migration-guides/bevy_shader.md
new file mode 100644
index 0000000000000..8fb90c78e30d3
--- /dev/null
+++ b/release-content/migration-guides/bevy_shader.md
@@ -0,0 +1,10 @@
+---
+title: "`bevy_shader` cleanups"
+pull_requests: [22774]
+---
+
+`ShaderReflectError` has been deleted, as it was unused.
+
+`ShaderCache::new` now accepts a `RenderDevice`, and `ShaderCache::get` does not. This is to reflect the fact that a `ShaderCache` must only be used with one `RenderDevice` for it to be valid.
+
+The `set_import_path`, `with_import_path`, `import_path`, and `imports` methods on `Shader` have been removed. Just access the fields directly, these were superfluous getter methods.
