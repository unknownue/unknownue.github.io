+++
title = "#22785 Fix off-by-one in alloc_many unintentionally allocating fresh indices"
date = "2026-02-04T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22785-en-20260204" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22785-zh-cn-20260204" }}
labels = ["C-Bug", "A-ECS", "P-Regression"]
+++

# Fix off-by-one in alloc_many unintentionally allocating fresh indices

## Basic Information
- **Title**: Fix off-by-one in alloc_many unintentionally allocating fresh indices
- **PR Link**: https://github.com/bevyengine/bevy/pull/22785
- **Author**: nickbabcock
- **Status**: MERGED
- **Labels**: C-Bug, A-ECS, S-Ready-For-Final-Review, P-Regression
- **Created**: 2026-02-03T00:10:34Z
- **Merged**: 2026-02-04T00:21:34Z
- **Merged By**: alice-i-cecile

## Description Translation
The PR description remains in English as per the instructions:

# Objective

Currently there is an off-by-one bug in `alloc_many`. `spawn_batch` would allocate fresh indices instead of reusing freed ones when current_len == free.len(). 

I don't believe this bug exists on `main`, hence why this PR is targeting 0.18.1. Please let me know if there is a better way to land this change.

## Testing

- The unit test covers the bug (ie: reverting the change will cause the test to fail).

## The Story of This Pull Request

This PR addresses a subtle but important bug in Bevy's Entity Component System (ECS) that affected entity index reuse. The issue occurred in the `EntityAllocator` implementation, specifically in the `alloc_many` method used for batch entity allocation. When systems like `spawn_batch` needed to allocate multiple entities at once, there was a boundary condition where freed entity indices wouldn't be properly reused, causing unnecessary allocation of fresh indices instead.

The core problem was an off-by-one error in a conditional check. When the number of entities requested for allocation (`count`) exactly matched the number of available free indices (`free.len()`), the system would incorrectly default to allocating fresh indices rather than reusing the available ones. This happened because the comparison operator in the conditional was strict (`<`) rather than inclusive (`<=`).

From an engineering perspective, this bug had several implications. First, it could lead to inefficient memory usage by not reusing available entity slots. Second, it could cause unexpected performance characteristics in systems that frequently allocated and freed entities in batches. Third, for long-running applications, this could potentially lead to faster exhaustion of the entity index space than necessary.

The fix itself is minimal but important. The `alloc_many` method uses atomic operations to manage concurrent access to the free list. When allocating multiple entities, it first decrements the `free_len` counter atomically to reserve slots, then checks whether there are enough free slots available. The bug was in this boundary check:

```rust
let current_len = if current_len < self.free.len() {
    current_len
} else {
    0
};
```

The issue occurs when `current_len == self.free.len()`. In this case, the condition `current_len < self.free.len()` evaluates to `false`, causing the code to fall through to the else branch and set `current_len` to 0. This tells the system that there are no free indices available, when in fact there are exactly enough to satisfy the request.

The corrected version uses `<=` instead:

```rust
let current_len = if current_len <= self.free.len() {
    current_len
} else {
    0
};
```

This ensures that when `current_len` equals `self.free.len()`, the system correctly recognizes that free indices are available and should be used.

The implementation includes a comprehensive unit test that clearly demonstrates the issue and verifies the fix. The test follows a clean pattern:
1. Allocate a batch of entities
2. Free all those entities
3. Allocate the same number of entities again
4. Verify that all indices are reused

The test uses `index_u32()` to compare entity indices directly, which is appropriate since entity reuse should manifest as index reuse. The assertion checks that the intersection between the first batch's indices and the second batch's indices equals the batch size (5), confirming complete reuse.

What's interesting about this bug is its regression nature. The author notes that this bug doesn't exist on `main`, suggesting it was introduced during development for the 0.18.1 release. This highlights the importance of thorough testing for boundary conditions, especially in concurrent data structures like entity allocators that use atomic operations.

The fix is targeted specifically at the 0.18.1 release branch, which is a responsible approach to bug fixing in a versioned release system. This ensures that the stable release gets the fix without introducing potential instability from `main` branch changes.

From an architectural perspective, this fix maintains the existing design pattern of the entity allocator. The `alloc_many` method returns an iterator (`AllocEntitiesIterator`) that handles the actual allocation logic, and this fix ensures that the iterator receives the correct information about available free slots.

The simplicity of the fix belies its importance. Off-by-one errors are classic bugs that can have significant consequences in systems programming, especially in resource management components like entity allocators. The fact that this was caught and fixed with a targeted unit test demonstrates good software engineering practices: identify the bug, write a test that reproduces it, fix the bug, and verify the test passes.

## Visual Representation

```mermaid
graph TD
    A[spawn_batch requests entities] --> B[EntityAllocator.alloc_many]
    B --> C{Check free slots}
    C -->|current_len <= free.len()| D[Use free indices]
    C -->|current_len > free.len()| E[Allocate fresh indices]
    D --> F[AllocEntitiesIterator processes indices]
    E --> F
    F --> G[Entities returned to spawn_batch]
    
    H[Original Bug: current_len == free.len()] --> I[Falls through to fresh allocation]
    J[Fixed: current_len == free.len()] --> D[Correctly uses free indices]
```

## Key Files Changed

### `crates/bevy_ecs/src/entity/mod.rs` (+31/-1)

This file contains the `EntityAllocator` implementation and the bug fix. The change is minimal but crucial for correct entity index reuse.

**Key changes:**

1. **Bug fix in `alloc_many` method:**
```rust
// Before:
let current_len = if current_len < self.free.len() {
    current_len
} else {
    0
};

// After:
let current_len = if current_len <= self.free.len() {
    current_len
} else {
    0
};
```

2. **Unit test added to verify the fix:**
```rust
#[test]
fn alloc_many_reuses_freed_entities() {
    let mut allocator = EntityAllocator::default();

    // Allocate 5 entities
    let first_batch: Vec<_> = allocator.alloc_many(5).collect();
    assert_eq!(first_batch.len(), 5);

    // Record the indices
    let first_indices: Vec<_> = first_batch.iter().map(|e| e.index_u32()).collect();

    // Free all entities
    for e in &first_batch {
        allocator.free(*e);
    }

    // Allocate 5 entities again - this should reuse all freed indices
    let second_batch: Vec<_> = allocator.alloc_many(5).collect();
    assert_eq!(second_batch.len(), 5);

    // Compute intersection between the two batches
    let intersection = first_indices
        .iter()
        .filter(|idx| second_batch.iter().any(|e| e.index_u32() == **idx))
        .count();

    // All 5 indices should be reused
    assert_eq!(intersection, 5);
}
```

The test follows a clear pattern: allocate, record indices, free, reallocate, and verify reuse. This is an effective test because it directly tests the bug scenario and provides clear failure conditions.

## Further Reading

1. **Rust Atomic Operations**: Understanding `Ordering::Relaxed` and other memory orderings used in concurrent Rust code
2. **Entity Component System Architecture**: How ECS systems manage entity lifecycles and resource allocation
3. **Off-by-One Errors**: Common programming mistakes and strategies for avoiding them
4. **Boundary Condition Testing**: Techniques for testing edge cases in software systems
5. **Regression Testing**: Strategies for preventing reintroduction of fixed bugs in versioned software