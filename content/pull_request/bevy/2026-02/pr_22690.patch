diff --git a/crates/bevy_ecs/src/schedule/condition.rs b/crates/bevy_ecs/src/schedule/condition.rs
index dde82d6551024..28a3310b37b13 100644
--- a/crates/bevy_ecs/src/schedule/condition.rs
+++ b/crates/bevy_ecs/src/schedule/condition.rs
@@ -76,10 +76,23 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     IntoSystem<In, bool, Marker, System: ReadOnlySystem>
 {
     /// Returns a new run condition that only returns `true`
-    /// if both this one and the passed `and` return `true`.
+    /// if both this one and the passed `then_run` return `true`.
     ///
     /// The returned run condition is short-circuiting, meaning
-    /// `and` will only be invoked if `self` returns `true`.
+    /// `then_run` will only be invoked if `self` returns `true`.
+    ///
+    /// Short-circuiting may not be desired in all cases; when utilizing change detection,
+    /// the `then_run` condition will react to changes since the last time that _`self` returned `true`_,
+    /// which may introduce subtle inconsistencies if short-circuiting was not intended. Similar issues
+    /// may arise for run conditions that rely on internal state, such as those using [`Local<T>`] parameters
+    /// or [`MessageReader<T>`], as they may not be updated every time the combined condition is evaluated.
+    ///
+    /// [`Local<T>`]: crate::system::Local
+    /// [`MessageReader<T>`]: crate::message::MessageReader
+    ///
+    /// See also [`and_eager`], which always evaluates both conditions.
+    ///
+    /// [`and_eager`]: SystemCondition::and_eager
     ///
     /// # Examples
     ///
@@ -89,100 +102,277 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     /// #[derive(Resource, PartialEq)]
     /// struct R(u32);
     ///
-    /// # let mut app = Schedule::default();
+    /// # let mut schedule = Schedule::default();
     /// # let mut world = World::new();
     /// # fn my_system() {}
-    /// app.add_systems(
+    /// schedule.add_systems(
     ///     // The `resource_equals` run condition will panic since we don't initialize `R`,
     ///     // just like if we used `Res<R>` in a system.
     ///     my_system.run_if(resource_equals(R(0))),
     /// );
-    /// # app.run(&mut world);
+    /// # schedule.run(&mut world);
     /// ```
     ///
-    /// Use `.and()` to avoid checking the condition.
+    /// Use `.and_then()` to avoid checking the condition.
     ///
     /// ```
     /// # use bevy_ecs::prelude::*;
     /// # #[derive(Resource, PartialEq)]
     /// # struct R(u32);
-    /// # let mut app = Schedule::default();
+    /// # let mut schedule = Schedule::default();
     /// # let mut world = World::new();
-    /// # fn my_system() {}
-    /// app.add_systems(
+    /// # fn my_system() { unreachable!() }
+    /// schedule.add_systems(
     ///     // `resource_equals` will only get run if the resource `R` exists.
-    ///     my_system.run_if(resource_exists::<R>.and(resource_equals(R(0)))),
+    ///     my_system.run_if(resource_exists::<R>.and_then(resource_equals(R(0)))),
     /// );
-    /// # app.run(&mut world);
+    /// # schedule.run(&mut world);
     /// ```
     ///
-    /// Note that in this case, it's better to just use the run condition [`resource_exists_and_equals`].
+    /// Note that in this specific case, it's better to just use the run condition [`resource_exists_and_equals`].
     ///
     /// [`resource_exists_and_equals`]: common_conditions::resource_exists_and_equals
-    fn and<M, C: SystemCondition<M, In>>(self, and: C) -> And<Self::System, C::System> {
+    fn and_then<M, C: SystemCondition<M, In>>(
+        self,
+        then_run: C,
+    ) -> AndThen<Self::System, C::System> {
+        let a = IntoSystem::into_system(self);
+        let b = IntoSystem::into_system(then_run);
+        let name = format!("{} && {}", a.name(), b.name());
+        CombinatorSystem::new(a, b, DebugName::owned(name))
+    }
+
+    /// Returns a new run condition that only returns `true`
+    /// if both this one and the passed `then_run` return `true`.
+    ///
+    /// The returned run condition is eagerly evaluated, meaning
+    /// it will always execute both run conditions in order.
+    ///
+    /// When applied directly to a system using [`run_if`], the use of this combinator
+    /// is behaviorally identical to simply calling `run_if` multiple times. However,
+    /// `.and_eager` may be more efficient, as it does not erase the types of the inner conditions
+    /// when evaluating them, which may allow for compiler optimizations that are not possible
+    /// with separate calls to `run_if`.
+    ///
+    /// See also [`and_then`], which short-circuits if `self` returns `false`.
+    ///
+    /// [`run_if`]: crate::schedule::IntoScheduleConfigs::run_if
+    /// [`and_then`]: SystemCondition::and_then
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use bevy_ecs::prelude::*;
+    /// # use std::sync::atomic::AtomicBool;
+    /// # use std::sync::atomic::Ordering;
+    /// # #[derive(Resource, PartialEq)]
+    /// # struct R(u32);
+    /// # let mut schedule = Schedule::default();
+    /// # let mut world = World::new();
+    /// # fn my_system() { unreachable!() }
+    /// # static CONDITION_A_RAN: AtomicBool = AtomicBool::new(false);
+    /// # static CONDITION_B_RAN: AtomicBool = AtomicBool::new(false);
+    /// # fn returns_false() -> bool {
+    /// #   CONDITION_A_RAN.store(true, Ordering::Relaxed);
+    /// #   false
+    /// # }
+    /// # fn returns_true() -> bool {
+    /// #   CONDITION_B_RAN.store(true, Ordering::Relaxed);
+    /// #   true
+    /// # }
+    /// schedule.add_systems(
+    ///     // both conditions will execute, even though the first one returned false
+    ///     my_system.run_if(returns_false.and_eager(returns_true)),
+    /// );
+    /// # schedule.run(&mut world);
+    /// # assert!(CONDITION_A_RAN.load(Ordering::Relaxed));
+    /// # assert!(CONDITION_B_RAN.load(Ordering::Relaxed));
+    /// ```
+    fn and_eager<M, C: SystemCondition<M, In>>(
+        self,
+        other: C,
+    ) -> AndEager<Self::System, C::System> {
         let a = IntoSystem::into_system(self);
-        let b = IntoSystem::into_system(and);
+        let b = IntoSystem::into_system(other);
+        let name = format!("{} & {}", a.name(), b.name());
+        CombinatorSystem::new(a, b, DebugName::owned(name))
+    }
+
+    /// Returns a new run condition that only returns `true`
+    /// if both this one and the passed `then_run` return `true`.
+    #[deprecated(
+        since = "0.19.0",
+        note = "use `.and_then(...)` instead, or `.and_eager(...)` to evaluate the conditions eagerly"
+    )]
+    fn and<M, C: SystemCondition<M, In>>(self, then_run: C) -> AndThen<Self::System, C::System> {
+        let a = IntoSystem::into_system(self);
+        let b = IntoSystem::into_system(then_run);
         let name = format!("{} && {}", a.name(), b.name());
         CombinatorSystem::new(a, b, DebugName::owned(name))
     }
 
     /// Returns a new run condition that only returns `false`
-    /// if both this one and the passed `nand` return `true`.
+    /// if both this one and the passed `then_run` return `true`.
     ///
     /// The returned run condition is short-circuiting, meaning
-    /// `nand` will only be invoked if `self` returns `true`.
+    /// `then_run` will only be invoked if `self` returns `true`.
     ///
-    /// # Examples
+    /// Short-circuiting may not be desired in all cases; when utilizing change detection,
+    /// the `then_run` condition will react to changes since the last time that _`self` returned `true`_,
+    /// which may introduce subtle inconsistencies if short-circuiting was not intended. Similar issues
+    /// may arise for run conditions that rely on internal state, such as those using [`Local<T>`] parameters
+    /// or [`MessageReader<T>`], as they may not be updated every time the combined condition is evaluated.
     ///
-    /// ```compile_fail
-    /// use bevy::prelude::*;
+    /// [`Local<T>`]: crate::system::Local
+    /// [`MessageReader<T>`]: crate::message::MessageReader
     ///
-    /// #[derive(States, Debug, Clone, PartialEq, Eq, Hash)]
-    /// pub enum PlayerState {
-    ///     Alive,
-    ///     Dead,
-    /// }
+    /// See also [`nand_eager`], which always evaluates both conditions.
     ///
-    /// #[derive(States, Debug, Clone, PartialEq, Eq, Hash)]
-    /// pub enum EnemyState {
-    ///     Alive,
-    ///     Dead,
-    /// }
+    /// [`nand_eager`]: SystemCondition::nand_eager
     ///
-    /// # let mut app = Schedule::default();
+    /// # Examples
+    ///
+    /// ```
+    /// # use bevy_ecs::prelude::*;
+    /// #
+    /// # #[derive(Resource, Debug, Clone, PartialEq, Eq, Hash)]
+    /// # pub enum PlayerState {
+    /// #     Alive,
+    /// #     Dead,
+    /// # }
+    /// # #[derive(Resource, Debug, Clone, PartialEq, Eq, Hash)]
+    /// # pub enum EnemyState {
+    /// #     Alive,
+    /// #     Dead,
+    /// # }
+    /// #
+    /// # use std::sync::atomic::AtomicUsize;
+    /// # use std::sync::atomic::Ordering;
+    /// # static IN_STATE_RUN_COUNT: AtomicUsize = AtomicUsize::new(0);
+    /// # fn in_state<R: Resource + PartialEq>(state: R) -> impl Fn(Res<R>) -> bool {
+    /// #   move |current_state| {
+    /// #       IN_STATE_RUN_COUNT.fetch_add(1, Ordering::Relaxed);
+    /// #       state == *current_state
+    /// #   }
+    /// # }
+    /// #
+    /// # #[derive(Resource)]
+    /// # struct RanGameOver(bool);
+    /// # fn game_over_credits(mut commands: Commands) { commands.insert_resource(RanGameOver(true)); }
+    /// # let mut schedule = Schedule::default();
     /// # let mut world = World::new();
-    /// # fn game_over_credits() {}
-    /// app.add_systems(
+    /// # world.insert_resource(PlayerState::Dead);
+    /// schedule.add_systems(
     ///     // The game_over_credits system will only execute if either the `in_state(PlayerState::Alive)`
     ///     // run condition or `in_state(EnemyState::Alive)` run condition evaluates to `false`.
     ///     game_over_credits.run_if(
-    ///         in_state(PlayerState::Alive).nand(in_state(EnemyState::Alive))
+    ///         in_state(PlayerState::Alive).nand_then(in_state(EnemyState::Alive)),
     ///     ),
     /// );
-    /// # app.run(&mut world);
+    /// # schedule.run(&mut world);
+    /// # assert_eq!(IN_STATE_RUN_COUNT.load(Ordering::Relaxed), 1);
+    /// # assert!(world.resource::<RanGameOver>().0);
+    /// # IN_STATE_RUN_COUNT.store(0, Ordering::Relaxed);
+    /// # world.insert_resource(RanGameOver(false));
+    /// # world.insert_resource(PlayerState::Alive);
+    /// # world.insert_resource(EnemyState::Dead);
+    /// # schedule.run(&mut world);
+    /// # assert_eq!(IN_STATE_RUN_COUNT.load(Ordering::Relaxed), 2);
+    /// # assert!(world.resource::<RanGameOver>().0);
+    /// # IN_STATE_RUN_COUNT.store(0, Ordering::Relaxed);
+    /// # world.insert_resource(RanGameOver(false));
+    /// # world.insert_resource(EnemyState::Alive);
+    /// # schedule.run(&mut world);
+    /// # assert_eq!(IN_STATE_RUN_COUNT.load(Ordering::Relaxed), 2);
+    /// # assert!(!world.resource::<RanGameOver>().0);
     /// ```
     ///
-    /// Equivalent logic can be achieved by using `not` in concert with `and`:
+    /// Equivalent logic can be achieved by using `not` in concert with `and_then`:
     ///
-    /// ```compile_fail
-    /// app.add_systems(
+    /// ```
+    /// # use bevy_ecs::prelude::*;
+    /// # #[derive(Resource, Debug, Clone, PartialEq, Eq, Hash)]
+    /// # pub enum PlayerState {
+    /// #     Alive,
+    /// #     Dead,
+    /// # }
+    /// # #[derive(Resource, Debug, Clone, PartialEq, Eq, Hash)]
+    /// # pub enum EnemyState {
+    /// #     Alive,
+    /// #     Dead,
+    /// # }
+    /// # fn in_state<R: Resource + PartialEq>(state: R) -> impl Fn(Res<R>) -> bool {
+    /// #   move |current_state| state == *current_state
+    /// # }
+    /// # fn game_over_credits() { unreachable!() }
+    /// # let mut schedule = Schedule::default();
+    /// # let mut world = World::new();
+    /// # world.insert_resource(PlayerState::Alive);
+    /// # world.insert_resource(EnemyState::Alive);
+    /// schedule.add_systems(
     ///     game_over_credits.run_if(
-    ///         not(in_state(PlayerState::Alive).and(in_state(EnemyState::Alive)))
+    ///         not(in_state(PlayerState::Alive).and_then(in_state(EnemyState::Alive))),
     ///     ),
     /// );
+    /// # schedule.run(&mut world);
     /// ```
-    fn nand<M, C: SystemCondition<M, In>>(self, nand: C) -> Nand<Self::System, C::System> {
+    fn nand_then<M, C: SystemCondition<M, In>>(
+        self,
+        then_run: C,
+    ) -> NandThen<Self::System, C::System> {
         let a = IntoSystem::into_system(self);
-        let b = IntoSystem::into_system(nand);
+        let b = IntoSystem::into_system(then_run);
         let name = format!("!({} && {})", a.name(), b.name());
         CombinatorSystem::new(a, b, DebugName::owned(name))
     }
 
+    /// Returns a new run condition that only returns `false`
+    /// if both this one and the passed `then_run` return `true`.
+    ///
+    /// The returned run condition is eagerly evaluated, meaning
+    /// it will always execute both run conditions in order.
+    ///
+    /// See also [`nand_then`], which short-circuits if `self` returns `false`.
+    ///
+    /// [`nand_then`]: SystemCondition::nand_then
+    fn nand_eager<M, C: SystemCondition<M, In>>(
+        self,
+        other: C,
+    ) -> NandEager<Self::System, C::System> {
+        let a = IntoSystem::into_system(self);
+        let b = IntoSystem::into_system(other);
+        let name = format!("!({} & {})", a.name(), b.name());
+        CombinatorSystem::new(a, b, DebugName::owned(name))
+    }
+
+    /// Returns a new run condition that only returns `false`
+    /// if both this one and the passed `then_run` return `true`.
+    #[deprecated(
+        since = "0.19.0",
+        note = "use `.nand_then(...) instead, or `.nand_eager(...)` to evaluate the conditions eagerly"
+    )]
+    fn nand<M, C: SystemCondition<M, In>>(self, nand: C) -> NandThen<Self::System, C::System> {
+        self.nand_then(nand)
+    }
+
     /// Returns a new run condition that only returns `true`
-    /// if both this one and the passed `nor` return `false`.
+    /// if both this one and the passed `else_run` return `false`.
     ///
     /// The returned run condition is short-circuiting, meaning
-    /// `nor` will only be invoked if `self` returns `false`.
+    /// `else_run` will only be invoked if `self` returns `true`.
+    ///
+    /// Short-circuiting may not be desired in all cases; when utilizing change detection,
+    /// the `else_run` condition will react to changes since the last time that _`self` returned `true`_,
+    /// which may introduce subtle inconsistencies if short-circuiting was not intended. Similar issues
+    /// may arise for run conditions that rely on internal state, such as those using [`Local<T>`] parameters
+    /// or [`MessageReader<T>`], as they may not be updated every time the combined condition is evaluated.
+    ///
+    /// [`Local<T>`]: crate::system::Local
+    /// [`MessageReader<T>`]: crate::message::MessageReader
+    ///
+    /// See also [`nor_eager`], which always evaluates both conditions.
+    ///
+    /// [`nor_eager`]: SystemCondition::nor_eager
     ///
     /// # Examples
     ///
@@ -208,7 +398,7 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     ///     // The slow_plant_growth system will only execute if both the `in_state(WeatherState::Sunny)`
     ///     // run condition and `in_state(SoilState::Fertilized)` run condition evaluate to `false`.
     ///     slow_plant_growth.run_if(
-    ///         in_state(WeatherState::Sunny).nor(in_state(SoilState::Fertilized))
+    ///         in_state(WeatherState::Sunny).nor_else(in_state(SoilState::Fertilized)),
     ///     ),
     /// );
     /// # app.run(&mut world);
@@ -219,23 +409,68 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     /// ```compile_fail
     /// app.add_systems(
     ///     slow_plant_growth.run_if(
-    ///         not(in_state(WeatherState::Sunny).or(in_state(SoilState::Fertilized)))
+    ///         not(in_state(WeatherState::Sunny).or_else(in_state(SoilState::Fertilized))),
     ///     ),
     /// );
     /// ```
-    fn nor<M, C: SystemCondition<M, In>>(self, nor: C) -> Nor<Self::System, C::System> {
+    fn nor_else<M, C: SystemCondition<M, In>>(
+        self,
+        else_run: C,
+    ) -> NorElse<Self::System, C::System> {
         let a = IntoSystem::into_system(self);
-        let b = IntoSystem::into_system(nor);
+        let b = IntoSystem::into_system(else_run);
         let name = format!("!({} || {})", a.name(), b.name());
         CombinatorSystem::new(a, b, DebugName::owned(name))
     }
 
+    /// Returns a new run condition that only returns `true`
+    /// if both this one and the passed `else_run` return `false`.
+    ///
+    /// The returned run condition is eagerly evaluated, meaning
+    /// it will always execute both run conditions in order.
+    ///
+    /// See also [`nor_else`], which short-circuits if `self` returns `true`.
+    ///
+    /// [`nor_else`]: SystemCondition::nor_else
+    fn nor_eager<M, C: SystemCondition<M, In>>(
+        self,
+        other: C,
+    ) -> NorEager<Self::System, C::System> {
+        let a = IntoSystem::into_system(self);
+        let b = IntoSystem::into_system(other);
+        let name = format!("!({} | {})", a.name(), b.name());
+        CombinatorSystem::new(a, b, DebugName::owned(name))
+    }
+
+    /// Returns a new run condition that only returns `true`
+    /// if both this one and the passed `else_run` return `false`.
+    #[deprecated(
+        since = "0.19.0",
+        note = "use `.nor_else(...)` instead, or `.nor_eager(...)` to evaluate the conditions eagerly"
+    )]
+    fn nor<M, C: SystemCondition<M, In>>(self, else_run: C) -> NorElse<Self::System, C::System> {
+        self.nor_else(else_run)
+    }
+
     /// Returns a new run condition that returns `true`
     /// if either this one or the passed `or` return `true`.
     ///
     /// The returned run condition is short-circuiting, meaning
     /// `or` will only be invoked if `self` returns `false`.
     ///
+    /// Short-circuiting may not be desired in all cases; when utilizing change detection,
+    /// the `else_run` condition will react to changes since the last time that _`self` returned `false`_,
+    /// which may introduce subtle inconsistencies if short-circuiting was not intended. Similar issues
+    /// may arise for run conditions that rely on internal state, such as those using [`Local<T>`] parameters
+    /// or [`MessageReader<T>`], as they may not be updated every time the combined condition is evaluated.
+    ///
+    /// [`Local<T>`]: crate::system::Local
+    /// [`MessageReader<T>`]: crate::message::MessageReader
+    ///
+    /// See also [`or_eager`], which always evaluates both conditions.
+    ///
+    /// [`or_eager`]: SystemCondition::or_eager
+    ///
     /// # Examples
     ///
     /// ```
@@ -270,16 +505,45 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     /// # app.run(&mut world);
     /// # assert!(world.resource::<C>().0);
     /// ```
-    fn or<M, C: SystemCondition<M, In>>(self, or: C) -> Or<Self::System, C::System> {
+    fn or_else<M, C: SystemCondition<M, In>>(self, else_run: C) -> OrElse<Self::System, C::System> {
         let a = IntoSystem::into_system(self);
-        let b = IntoSystem::into_system(or);
+        let b = IntoSystem::into_system(else_run);
         let name = format!("{} || {}", a.name(), b.name());
         CombinatorSystem::new(a, b, DebugName::owned(name))
     }
 
+    /// Returns a new run condition that returns `true`
+    /// if either this one or the passed `or` return `true`.
+    ///
+    /// The returned run condition is eagerly evaluated, meaning
+    /// it will always execute both run conditions in order.
+    ///
+    /// See also [`or_else`], which short-circuits if `self` returns `true`.
+    ///
+    /// [`or_else`]: SystemCondition::or_else
+    fn or_eager<M, C: SystemCondition<M, In>>(self, other: C) -> OrEager<Self::System, C::System> {
+        let a = IntoSystem::into_system(self);
+        let b = IntoSystem::into_system(other);
+        let name = format!("{} | {}", a.name(), b.name());
+        CombinatorSystem::new(a, b, DebugName::owned(name))
+    }
+
+    /// Returns a new run condition that returns `true`
+    /// if either this one or the passed `or` return `true`.
+    #[deprecated(
+        since = "0.19.0",
+        note = "use `.or_else(...)` instead, or `.or_eager(...)` to eagerly evaluate both conditions"
+    )]
+    fn or<M, C: SystemCondition<M, In>>(self, else_run: C) -> OrElse<Self::System, C::System> {
+        self.or_else(else_run)
+    }
+
     /// Returns a new run condition that only returns `true`
     /// if `self` and `xnor` **both** return `false` or **both** return `true`.
     ///
+    /// The returned run condition is eagerly evaluated, meaning
+    /// it will always execute both run conditions in order.
+    ///
     /// # Examples
     ///
     /// ```compile_fail
@@ -322,9 +586,9 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     ///     ),
     /// );
     /// ```
-    fn xnor<M, C: SystemCondition<M, In>>(self, xnor: C) -> Xnor<Self::System, C::System> {
+    fn xnor<M, C: SystemCondition<M, In>>(self, other: C) -> Xnor<Self::System, C::System> {
         let a = IntoSystem::into_system(self);
-        let b = IntoSystem::into_system(xnor);
+        let b = IntoSystem::into_system(other);
         let name = format!("!({} ^ {})", a.name(), b.name());
         CombinatorSystem::new(a, b, DebugName::owned(name))
     }
@@ -332,6 +596,9 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     /// Returns a new run condition that only returns `true`
     /// if either `self` or `xor` return `true`, but not both.
     ///
+    /// The returned run condition is eagerly evaluated, meaning
+    /// it will always execute both run conditions in order.
+    ///
     /// # Examples
     ///
     /// ```compile_fail
@@ -364,9 +631,9 @@ pub trait SystemCondition<Marker, In: SystemInput = ()>:
     /// );
     /// # app.run(&mut world);
     /// ```
-    fn xor<M, C: SystemCondition<M, In>>(self, xor: C) -> Xor<Self::System, C::System> {
+    fn xor<M, C: SystemCondition<M, In>>(self, other: C) -> Xor<Self::System, C::System> {
         let a = IntoSystem::into_system(self);
-        let b = IntoSystem::into_system(xor);
+        let b = IntoSystem::into_system(other);
         let name = format!("({} ^ {})", a.name(), b.name());
         CombinatorSystem::new(a, b, DebugName::owned(name))
     }
@@ -1114,28 +1381,40 @@ impl<S: System<Out: Not>> Adapt<S> for NotMarker {
     }
 }
 
-/// Combines the outputs of two systems using the `&&` operator.
-pub type And<A, B> = CombinatorSystem<AndMarker, A, B>;
+/// Combines the outputs of two systems using the `&&` operator (short-circuiting).
+pub type AndThen<A, B> = CombinatorSystem<AndThenMarker, A, B>;
+
+/// Combines the outputs of two systems using the `&` operator (eagerly evaluated).
+pub type AndEager<A, B> = CombinatorSystem<AndEagerMarker, A, B>;
 
-/// Combines and inverts the outputs of two systems using the `&&` and `!` operators.
-pub type Nand<A, B> = CombinatorSystem<NandMarker, A, B>;
+/// Combines and inverts the outputs of two systems using the `&&` and `!` operators (short-circuiting).
+pub type NandThen<A, B> = CombinatorSystem<NandThenMarker, A, B>;
 
-/// Combines and inverts the outputs of two systems using the `||` and `!` operators.
-pub type Nor<A, B> = CombinatorSystem<NorMarker, A, B>;
+/// Combines and inverts the outputs of two systems using the `&` and `!` operators (eagerly evaluated).
+pub type NandEager<A, B> = CombinatorSystem<NandEagerMarker, A, B>;
 
-/// Combines the outputs of two systems using the `||` operator.
-pub type Or<A, B> = CombinatorSystem<OrMarker, A, B>;
+/// Combines and inverts the outputs of two systems using the `||` and `!` operators (short-circuiting).
+pub type NorElse<A, B> = CombinatorSystem<NorElseMarker, A, B>;
 
-/// Combines and inverts the outputs of two systems using the `^` and `!` operators.
+/// Combines and inverts the outputs of two systems using the `|` and `!` operators (eagerly evaluated).
+pub type NorEager<A, B> = CombinatorSystem<NorEagerMarker, A, B>;
+
+/// Combines the outputs of two systems using the `||` operator (short-circuiting).
+pub type OrElse<A, B> = CombinatorSystem<OrElseMarker, A, B>;
+
+/// Combines the outputs of two systems using the `|` operator (short-circuiting).
+pub type OrEager<A, B> = CombinatorSystem<OrEagerMarker, A, B>;
+
+/// Combines and inverts the outputs of two systems using the `^` and `!` operators (eagerly evaluated).
 pub type Xnor<A, B> = CombinatorSystem<XnorMarker, A, B>;
 
-/// Combines the outputs of two systems using the `^` operator.
+/// Combines the outputs of two systems using the `^` operator (eagerly evaluated).
 pub type Xor<A, B> = CombinatorSystem<XorMarker, A, B>;
 
 #[doc(hidden)]
-pub struct AndMarker;
+pub struct AndThenMarker;
 
-impl<In, A, B> Combine<A, B> for AndMarker
+impl<In, A, B> Combine<A, B> for AndThenMarker
 where
     for<'a> In: SystemInput<Inner<'a>: Copy>,
     A: System<In = In, Out = bool>,
@@ -1155,9 +1434,31 @@ where
 }
 
 #[doc(hidden)]
-pub struct NandMarker;
+pub struct AndEagerMarker;
+
+impl<In, A, B> Combine<A, B> for AndEagerMarker
+where
+    for<'a> In: SystemInput<Inner<'a>: Copy>,
+    A: System<In = In, Out = bool>,
+    B: System<In = In, Out = bool>,
+{
+    type In = In;
+    type Out = bool;
+
+    fn combine<T>(
+        input: <Self::In as SystemInput>::Inner<'_>,
+        data: &mut T,
+        a: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(a(input, data).unwrap_or(false) & b(input, data).unwrap_or(false))
+    }
+}
+
+#[doc(hidden)]
+pub struct NandThenMarker;
 
-impl<In, A, B> Combine<A, B> for NandMarker
+impl<In, A, B> Combine<A, B> for NandThenMarker
 where
     for<'a> In: SystemInput<Inner<'a>: Copy>,
     A: System<In = In, Out = bool>,
@@ -1177,9 +1478,31 @@ where
 }
 
 #[doc(hidden)]
-pub struct NorMarker;
+pub struct NandEagerMarker;
 
-impl<In, A, B> Combine<A, B> for NorMarker
+impl<In, A, B> Combine<A, B> for NandEagerMarker
+where
+    for<'a> In: SystemInput<Inner<'a>: Copy>,
+    A: System<In = In, Out = bool>,
+    B: System<In = In, Out = bool>,
+{
+    type In = In;
+    type Out = bool;
+
+    fn combine<T>(
+        input: <Self::In as SystemInput>::Inner<'_>,
+        data: &mut T,
+        a: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(!(a(input, data).unwrap_or(false) & b(input, data).unwrap_or(false)))
+    }
+}
+
+#[doc(hidden)]
+pub struct NorElseMarker;
+
+impl<In, A, B> Combine<A, B> for NorElseMarker
 where
     for<'a> In: SystemInput<Inner<'a>: Copy>,
     A: System<In = In, Out = bool>,
@@ -1199,9 +1522,31 @@ where
 }
 
 #[doc(hidden)]
-pub struct OrMarker;
+pub struct NorEagerMarker;
 
-impl<In, A, B> Combine<A, B> for OrMarker
+impl<In, A, B> Combine<A, B> for NorEagerMarker
+where
+    for<'a> In: SystemInput<Inner<'a>: Copy>,
+    A: System<In = In, Out = bool>,
+    B: System<In = In, Out = bool>,
+{
+    type In = In;
+    type Out = bool;
+
+    fn combine<T>(
+        input: <Self::In as SystemInput>::Inner<'_>,
+        data: &mut T,
+        a: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(!(a(input, data).unwrap_or(false) | b(input, data).unwrap_or(false)))
+    }
+}
+
+#[doc(hidden)]
+pub struct OrElseMarker;
+
+impl<In, A, B> Combine<A, B> for OrElseMarker
 where
     for<'a> In: SystemInput<Inner<'a>: Copy>,
     A: System<In = In, Out = bool>,
@@ -1220,6 +1565,28 @@ where
     }
 }
 
+#[doc(hidden)]
+pub struct OrEagerMarker;
+
+impl<In, A, B> Combine<A, B> for OrEagerMarker
+where
+    for<'a> In: SystemInput<Inner<'a>: Copy>,
+    A: System<In = In, Out = bool>,
+    B: System<In = In, Out = bool>,
+{
+    type In = In;
+    type Out = bool;
+
+    fn combine<T>(
+        input: <Self::In as SystemInput>::Inner<'_>,
+        data: &mut T,
+        a: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>, &mut T) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(a(input, data).unwrap_or(false) | b(input, data).unwrap_or(false))
+    }
+}
+
 #[doc(hidden)]
 pub struct XnorMarker;
 
@@ -1404,7 +1771,7 @@ mod tests {
         // ensure there are no `Vacant` entities
         assert!(world.query::<&Vacant>().iter(&world).next().is_none());
         assert!(matches!(
-            world.run_system_once((|| true).or(vacant)),
+            world.run_system_once((|| true).or_else(vacant)),
             Ok(true)
         ));
 
@@ -1446,10 +1813,10 @@ mod tests {
             );
         }
 
-        assert_system(&mut world, is_true_inc.or(vacant), |c| {
+        assert_system(&mut world, is_true_inc.or_else(vacant), |c| {
             test_true(c) || false
         });
-        assert_system(&mut world, is_true_inc.nor(vacant), |c| {
+        assert_system(&mut world, is_true_inc.nor_else(vacant), |c| {
             !(test_true(c) || false)
         });
         assert_system(&mut world, is_true_inc.xor(vacant), |c| {
@@ -1458,20 +1825,20 @@ mod tests {
         assert_system(&mut world, is_true_inc.xnor(vacant), |c| {
             !(test_true(c) ^ false)
         });
-        assert_system(&mut world, is_true_inc.and(vacant), |c| {
+        assert_system(&mut world, is_true_inc.and_then(vacant), |c| {
             test_true(c) && false
         });
-        assert_system(&mut world, is_true_inc.nand(vacant), |c| {
+        assert_system(&mut world, is_true_inc.nand_then(vacant), |c| {
             !(test_true(c) && false)
         });
 
         // even if `vacant` fails as the first condition, where applicable (or,
         // xor), `is_true_inc` should still be called. `and` and `nand` short
         // circuit on an initial `false`.
-        assert_system(&mut world, vacant.or(is_true_inc), |c| {
+        assert_system(&mut world, vacant.or_else(is_true_inc), |c| {
             false || test_true(c)
         });
-        assert_system(&mut world, vacant.nor(is_true_inc), |c| {
+        assert_system(&mut world, vacant.nor_else(is_true_inc), |c| {
             !(false || test_true(c))
         });
         assert_system(&mut world, vacant.xor(is_true_inc), |c| {
@@ -1480,18 +1847,18 @@ mod tests {
         assert_system(&mut world, vacant.xnor(is_true_inc), |c| {
             !(false ^ test_true(c))
         });
-        assert_system(&mut world, vacant.and(is_true_inc), |c| {
+        assert_system(&mut world, vacant.and_then(is_true_inc), |c| {
             false && test_true(c)
         });
-        assert_system(&mut world, vacant.nand(is_true_inc), |c| {
+        assert_system(&mut world, vacant.nand_then(is_true_inc), |c| {
             !(false && test_true(c))
         });
 
         // the same logic ought to be the case with a condition that runs, but yields `false`:
-        assert_system(&mut world, is_true_inc.or(is_false_inc), |c| {
+        assert_system(&mut world, is_true_inc.or_else(is_false_inc), |c| {
             test_true(c) || test_false(c)
         });
-        assert_system(&mut world, is_true_inc.nor(is_false_inc), |c| {
+        assert_system(&mut world, is_true_inc.nor_else(is_false_inc), |c| {
             !(test_true(c) || test_false(c))
         });
         assert_system(&mut world, is_true_inc.xor(is_false_inc), |c| {
@@ -1500,18 +1867,18 @@ mod tests {
         assert_system(&mut world, is_true_inc.xnor(is_false_inc), |c| {
             !(test_true(c) ^ test_false(c))
         });
-        assert_system(&mut world, is_true_inc.and(is_false_inc), |c| {
+        assert_system(&mut world, is_true_inc.and_then(is_false_inc), |c| {
             test_true(c) && test_false(c)
         });
-        assert_system(&mut world, is_true_inc.nand(is_false_inc), |c| {
+        assert_system(&mut world, is_true_inc.nand_then(is_false_inc), |c| {
             !(test_true(c) && test_false(c))
         });
 
         // and where one condition yields `false` and the other fails:
-        assert_system(&mut world, is_false_inc.or(vacant), |c| {
+        assert_system(&mut world, is_false_inc.or_else(vacant), |c| {
             test_false(c) || false
         });
-        assert_system(&mut world, is_false_inc.nor(vacant), |c| {
+        assert_system(&mut world, is_false_inc.nor_else(vacant), |c| {
             !(test_false(c) || false)
         });
         assert_system(&mut world, is_false_inc.xor(vacant), |c| {
@@ -1520,18 +1887,18 @@ mod tests {
         assert_system(&mut world, is_false_inc.xnor(vacant), |c| {
             !(test_false(c) ^ false)
         });
-        assert_system(&mut world, is_false_inc.and(vacant), |c| {
+        assert_system(&mut world, is_false_inc.and_then(vacant), |c| {
             test_false(c) && false
         });
-        assert_system(&mut world, is_false_inc.nand(vacant), |c| {
+        assert_system(&mut world, is_false_inc.nand_then(vacant), |c| {
             !(test_false(c) && false)
         });
 
         // and where both conditions yield `true`:
-        assert_system(&mut world, is_true_inc.or(is_true_inc), |c| {
+        assert_system(&mut world, is_true_inc.or_else(is_true_inc), |c| {
             test_true(c) || test_true(c)
         });
-        assert_system(&mut world, is_true_inc.nor(is_true_inc), |c| {
+        assert_system(&mut world, is_true_inc.nor_else(is_true_inc), |c| {
             !(test_true(c) || test_true(c))
         });
         assert_system(&mut world, is_true_inc.xor(is_true_inc), |c| {
@@ -1540,18 +1907,18 @@ mod tests {
         assert_system(&mut world, is_true_inc.xnor(is_true_inc), |c| {
             !(test_true(c) ^ test_true(c))
         });
-        assert_system(&mut world, is_true_inc.and(is_true_inc), |c| {
+        assert_system(&mut world, is_true_inc.and_then(is_true_inc), |c| {
             test_true(c) && test_true(c)
         });
-        assert_system(&mut world, is_true_inc.nand(is_true_inc), |c| {
+        assert_system(&mut world, is_true_inc.nand_then(is_true_inc), |c| {
             !(test_true(c) && test_true(c))
         });
 
         // and where both conditions yield `false`:
-        assert_system(&mut world, is_false_inc.or(is_false_inc), |c| {
+        assert_system(&mut world, is_false_inc.or_else(is_false_inc), |c| {
             test_false(c) || test_false(c)
         });
-        assert_system(&mut world, is_false_inc.nor(is_false_inc), |c| {
+        assert_system(&mut world, is_false_inc.nor_else(is_false_inc), |c| {
             !(test_false(c) || test_false(c))
         });
         assert_system(&mut world, is_false_inc.xor(is_false_inc), |c| {
@@ -1560,10 +1927,10 @@ mod tests {
         assert_system(&mut world, is_false_inc.xnor(is_false_inc), |c| {
             !(test_false(c) ^ test_false(c))
         });
-        assert_system(&mut world, is_false_inc.and(is_false_inc), |c| {
+        assert_system(&mut world, is_false_inc.and_then(is_false_inc), |c| {
             test_false(c) && test_false(c)
         });
-        assert_system(&mut world, is_false_inc.nand(is_false_inc), |c| {
+        assert_system(&mut world, is_false_inc.nand_then(is_false_inc), |c| {
             !(test_false(c) && test_false(c))
         });
     }
@@ -1576,14 +1943,14 @@ mod tests {
 
         schedule.add_systems(
             (
-                increment_counter.run_if(every_other_time.and(|| true)), // Run every odd cycle.
-                increment_counter.run_if(every_other_time.nand(|| false)), // Always run.
-                double_counter.run_if(every_other_time.nor(|| false)),   // Run every even cycle.
-                increment_counter.run_if(every_other_time.or(|| true)),  // Always run.
-                increment_counter.run_if(every_other_time.xnor(|| true)), // Run every odd cycle.
-                double_counter.run_if(every_other_time.xnor(|| false)),  // Run every even cycle.
+                increment_counter.run_if(every_other_time.and_eager(|| true)), // Run every odd cycle.
+                increment_counter.run_if(every_other_time.nand_eager(|| false)), // Always run.
+                double_counter.run_if(every_other_time.nor_eager(|| false)), // Run every even cycle.
+                increment_counter.run_if(every_other_time.or_eager(|| true)), // Always run.
+                increment_counter.run_if(every_other_time.xnor(|| true)),    // Run every odd cycle.
+                double_counter.run_if(every_other_time.xnor(|| false)), // Run every even cycle.
                 increment_counter.run_if(every_other_time.xor(|| false)), // Run every odd cycle.
-                double_counter.run_if(every_other_time.xor(|| true)),    // Run every even cycle.
+                double_counter.run_if(every_other_time.xor(|| true)),   // Run every even cycle.
             )
                 .chain(),
         );
diff --git a/crates/bevy_ecs/src/system/combinator.rs b/crates/bevy_ecs/src/system/combinator.rs
index 41fa5c57481db..bbf38cbcc4fc2 100644
--- a/crates/bevy_ecs/src/system/combinator.rs
+++ b/crates/bevy_ecs/src/system/combinator.rs
@@ -495,7 +495,7 @@ mod tests {
     use bevy_utils::prelude::DebugName;
 
     use crate::{
-        schedule::OrMarker,
+        schedule::OrElseMarker,
         system::{assert_system_does_not_conflict, CombinatorSystem},
     };
 
@@ -513,7 +513,7 @@ mod tests {
         let mut world = World::new();
         world.insert_resource(DefaultErrorHandler::default());
 
-        let system = CombinatorSystem::<OrMarker, _, _>::new(
+        let system = CombinatorSystem::<OrElseMarker, _, _>::new(
             IntoSystem::into_system(a),
             IntoSystem::into_system(b),
             DebugName::borrowed("a OR b"),
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index 840b00251aca0..786725372af04 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -1873,7 +1873,7 @@ mod tests {
                     res.0 += 2;
                 },
             )
-                .distributive_run_if(resource_exists::<A>.or(resource_exists::<B>)),
+                .distributive_run_if(resource_exists::<A>.or_eager(resource_exists::<B>)),
         );
         sched.initialize(&mut world).unwrap();
         sched.run(&mut world);
diff --git a/crates/bevy_state/src/condition.rs b/crates/bevy_state/src/condition.rs
index 4d9acb8cfe819..78973dddaf268 100644
--- a/crates/bevy_state/src/condition.rs
+++ b/crates/bevy_state/src/condition.rs
@@ -191,7 +191,7 @@ mod tests {
         Schedule::default().add_systems(
             (test_system, test_system)
                 .distributive_run_if(state_exists::<TestState>)
-                .distributive_run_if(in_state(TestState::A).or(in_state(TestState::B)))
+                .distributive_run_if(in_state(TestState::A).or_eager(in_state(TestState::B)))
                 .distributive_run_if(state_changed::<TestState>),
         );
     }
diff --git a/examples/diagnostics/log_diagnostics.rs b/examples/diagnostics/log_diagnostics.rs
index af6a39c269016..f3049e7d92d3b 100644
--- a/examples/diagnostics/log_diagnostics.rs
+++ b/examples/diagnostics/log_diagnostics.rs
@@ -48,7 +48,7 @@ fn main() {
             Update,
             update_commands.run_if(
                 resource_exists_and_changed::<LogDiagnosticsStatus>
-                    .or(resource_exists_and_changed::<LogDiagnosticsFilters>),
+                    .or_eager(resource_exists_and_changed::<LogDiagnosticsFilters>),
             ),
         )
         .run();
diff --git a/examples/ecs/run_conditions.rs b/examples/ecs/run_conditions.rs
index 47c4c76d818e1..a362bed023808 100644
--- a/examples/ecs/run_conditions.rs
+++ b/examples/ecs/run_conditions.rs
@@ -18,22 +18,22 @@ fn main() {
                     // The common_conditions module has a few useful run conditions
                     // for checking resources and states. These are included in the prelude.
                     .run_if(resource_exists::<InputCounter>)
-                    // `.or()` is a run condition combinator that only evaluates the second condition
+                    // `.or_else()` is a run condition combinator that only evaluates the second condition
                     // if the first condition returns `false`. This behavior is known as "short-circuiting",
                     // and is how the `||` operator works in Rust (as well as most C-family languages).
                     // In this case, the `has_user_input` run condition will be evaluated since the `Unused` resource has not been initialized.
-                    .run_if(resource_exists::<Unused>.or(
+                    .run_if(resource_exists::<Unused>.or_else(
                         // This is a custom run condition, defined using a system that returns
                         // a `bool` and which has read-only `SystemParam`s.
                         // Only a single run condition must return `true` in order for the system to run.
                         has_user_input,
                     )),
                 print_input_counter
-                    // `.and()` is a run condition combinator that only evaluates the second condition
+                    // `.and_then()` is a run condition combinator that only evaluates the second condition
                     // if the first condition returns `true`, analogous to the `&&` operator.
                     // In this case, the short-circuiting behavior prevents the second run condition from
                     // panicking if the `InputCounter` resource has not been initialized.
-                    .run_if(resource_exists::<InputCounter>.and(
+                    .run_if(resource_exists::<InputCounter>.and_then(
                         // This is a custom run condition in the form of a closure.
                         // This is useful for small, simple run conditions you don't need to reuse.
                         // All the normal rules still apply: all parameters must be read only except for local parameters.
diff --git a/examples/math/render_primitives.rs b/examples/math/render_primitives.rs
index 61047422aae6c..3bd088345806e 100644
--- a/examples/math/render_primitives.rs
+++ b/examples/math/render_primitives.rs
@@ -41,8 +41,9 @@ fn main() {
                 switch_to_previous_primitive.run_if(input_just_pressed(KeyCode::ArrowDown)),
                 draw_gizmos_2d.run_if(in_mode(CameraActive::Dim2)),
                 draw_gizmos_3d.run_if(in_mode(CameraActive::Dim3)),
-                update_primitive_meshes
-                    .run_if(state_changed::<PrimitiveSelected>.or(state_changed::<CameraActive>)),
+                update_primitive_meshes.run_if(
+                    state_changed::<PrimitiveSelected>.or_eager(state_changed::<CameraActive>),
+                ),
                 rotate_primitive_2d_meshes,
                 rotate_primitive_3d_meshes,
             ),
