+++
title = "#22922 Fix culling for negative sized UI elements"
date = "2026-02-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22922-en-20260217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22922-zh-cn-20260217" }}
labels = ["C-Bug", "A-Rendering", "A-UI", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Fix culling for negative sized UI elements
- **PR Link**: https://github.com/bevyengine/bevy/pull/22922
- **Author**: GiantBlargg
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, A-UI, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-02-12T03:21:52Z
- **Merged**: 2026-02-17T01:47:20Z
- **Merged By**: alice-i-cecile

## Description Translation
The original description is in English, so it is included as-is:

# Objective

Fixes #22906

## Solution

A similar solution had already been implemented for glyphs so I just copied that.

## Testing

See #22906 for a reproduction of the bug. After applying this fix, the result matches the expected.

## The Story of This Pull Request

This PR addresses a culling bug that affected UI elements with negative scales. The issue was that when UI nodes were transformed with negative scaling values, their culling calculations incorrectly interpreted negative dimensions as being outside the visible area, causing valid elements to be incorrectly culled.

The root cause was in how transformed rectangle sizes were calculated for culling. When a UI element has a negative scale (e.g., `scale: Vec2::new(-1.0, 1.0)`), the transformation produces negative size components. The original culling logic didn't account for this properly, treating negative dimensions as if they represented rectangles with no visible area.

The fix is straightforward: take the absolute value of transformed rectangle sizes before using them in culling calculations. This approach was already implemented for glyph rendering, so the solution simply extended this same pattern to other UI rendering components. The implementation demonstrates good engineering practice by identifying and reusing an existing proven solution rather than creating new approaches.

The changes affect multiple UI rendering pipelines:
1. Standard UI nodes
2. Box shadows
3. Gradients
4. UI materials
5. Texture slices

Each of these components uses similar culling logic, so the same fix needed to be applied consistently across the codebase. The implementation shows attention to consistency and thoroughness in addressing the issue across all affected systems.

From a technical perspective, the fix ensures that culling decisions are based on the absolute dimensions of transformed UI elements, regardless of whether the transformation includes negative scaling. This is mathematically correct because a rectangle with negative scale still occupies the same spatial extent as one with positive scale - the negative scale only affects the orientation or mirroring of the content, not whether it should be visible.

The impact of this fix is that UI elements with negative scales now render correctly instead of being incorrectly culled. This is important for various UI effects that might use negative scaling for visual transformations, such as mirroring or certain animation effects.

## Visual Representation

```mermaid
graph TD
    A[UI Rendering System] --> B[prepare_uinodes]
    A --> C[prepare_shadows]
    A --> D[prepare_gradient]
    A --> E[prepare_uimaterial_nodes]
    A --> F[prepare_ui_slices]
    
    B --> G[transformed_rect_size.abs()]
    C --> G
    D --> G
    E --> G
    F --> G
    
    G --> H[Correct Culling]
```

## Key Files Changed

### `crates/bevy_ui_render/src/lib.rs` (+7/-6)

This file contains the main UI node preparation logic. The changes fix culling calculations for standard UI nodes:

```rust
// Before (line 1571):
let transformed_rect_size = transform.transform_vector2(rect_size);

// After:
let transformed_rect_size = transform.transform_vector2(rect_size).abs();
```

```rust
// Before (lines 1714-1720):
let transformed_rect_size =
    extracted_uinode.transform.transform_vector2(rect_size);
if positions_diff[0].x - positions_diff[1].x
    >= transformed_rect_size.x.abs()
    || positions_diff[1].y - positions_diff[2].y
        >= transformed_rect_size.y.abs()

// After:
let transformed_rect_size = extracted_uinode
    .transform
    .transform_vector2(rect_size)
    .abs();
if positions_diff[0].x - positions_diff[1].x >= transformed_rect_size.x
    || positions_diff[1].y - positions_diff[2].y
        >= transformed_rect_size.y
```

The first change ensures the transformed size is always positive. The second change simplifies the culling condition by using the already-absolute value instead of calling `.abs()` inline.

### `crates/bevy_ui_render/src/box_shadow.rs` (+1/-1)

Fixes culling for box shadow elements:

```rust
// Before:
let transformed_rect_size = box_shadow.transform.transform_vector2(rect_size);

// After:
let transformed_rect_size = box_shadow.transform.transform_vector2(rect_size).abs();
```

### `crates/bevy_ui_render/src/gradient.rs` (+2/-1)

Fixes culling for gradient elements:

```rust
// Before:
let transformed_rect_size = gradient.transform.transform_vector2(rect_size);

// After:
let transformed_rect_size =
    gradient.transform.transform_vector2(rect_size).abs();
```

### `crates/bevy_ui_render/src/ui_material_pipeline.rs` (+4/-2)

Fixes culling for UI material nodes:

```rust
// Before:
let transformed_rect_size =
    extracted_uinode.transform.transform_vector2(rect_size);

// After:
let transformed_rect_size = extracted_uinode
    .transform
    .transform_vector2(rect_size)
    .abs();
```

### `crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs` (+1/-1)

Fixes culling for UI texture slice elements:

```rust
// Before:
let transformed_rect_size =
    texture_slices.transform.transform_vector2(rect_size);

// After:
let transformed_rect_size =
    texture_slices.transform.transform_vector2(rect_size).abs();
```

Each change follows the same pattern: calling `.abs()` on the transformed rectangle size to ensure negative dimensions from negative scaling don't cause incorrect culling.

## Further Reading

1. [Bevy UI Rendering Documentation](https://docs.rs/bevy_ui_render/latest/bevy_ui_render/) - Official documentation for Bevy's UI rendering system
2. [Affine Transformations in Computer Graphics](https://en.wikipedia.org/wiki/Affine_transformation) - Background on transformations including scaling
3. [Frustum Culling Algorithms](https://en.wikipedia.org/wiki/Viewing_frustum) - General concepts of culling in computer graphics
4. [Issue #22906](https://github.com/bevyengine/bevy/issues/22906) - The original issue that reported the bug