diff --git a/crates/bevy_picking/src/events.rs b/crates/bevy_picking/src/events.rs
index c418323bc01c5..b552bc524d5b7 100644
--- a/crates/bevy_picking/src/events.rs
+++ b/crates/bevy_picking/src/events.rs
@@ -30,7 +30,7 @@
 //! # Events Types
 //!
 //! The events this module defines fall into a few broad categories:
-//! + Hovering and movement: [`Over`], [`Move`], and [`Out`].
+//! + Hovering and movement: [`Over`], [`Enter`], [`Move`], [`Leave`], and [`Out`].
 //! + Clicking and pressing: [`Press`], [`Release`], and [`Click`].
 //! + Dragging and dropping: [`DragStart`], [`Drag`], [`DragEnd`], [`DragEnter`], [`DragOver`], [`DragDrop`], [`DragLeave`].
 //!
@@ -38,8 +38,10 @@
 //! general metadata about the pointer event.
 
 use core::{fmt::Debug, time::Duration};
+use std::collections::HashSet;
 
 use bevy_camera::NormalizedRenderTarget;
+use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::{prelude::*, query::QueryData, system::SystemParam, traversal::Traversal};
 use bevy_input::mouse::MouseScrollUnit;
 use bevy_math::Vec2;
@@ -51,7 +53,7 @@ use tracing::debug;
 
 use crate::{
     backend::{prelude::PointerLocation, HitData},
-    hover::{HoverMap, PreviousHoverMap},
+    hover::{get_hovered_entities, is_directly_hovered, HoverMap, PreviousHoverMap},
     pointer::{Location, PointerAction, PointerButton, PointerId, PointerInput, PointerMap},
 };
 
@@ -72,12 +74,16 @@ pub struct Pointer<E: Debug + Clone + Reflect> {
     /// Additional event-specific data. [`DragDrop`] for example, has an additional field to describe
     /// the `Entity` that is being dropped on the target.
     pub event: E,
+    /// Whether to propagate the event via `PointerTraversal`
+    /// For [`Enter`] and [`Leave`] events, this is set to false.
+    pub(crate) propagate: bool,
 }
 
 /// A traversal query (i.e. it implements [`Traversal`]) intended for use with [`Pointer`] events.
 ///
-/// This will always traverse to the parent, if the entity being visited has one. Otherwise, it
-/// propagates to the pointer's window and stops there.
+/// Unless shortcircuited out by the [`Pointer`] event itself, this will always traverse to the
+/// parent if the entity being visited has one. Otherwise, it propagates to the pointer's
+/// window and stops there.
 #[derive(QueryData)]
 pub struct PointerTraversal {
     child_of: Option<&'static ChildOf>,
@@ -89,6 +95,10 @@ where
     E: Debug + Clone + Reflect,
 {
     fn traverse(item: Self::Item<'_, '_>, pointer: &Pointer<E>) -> Option<Entity> {
+        if !pointer.propagate {
+            return None;
+        }
+
         let PointerTraversalItem { child_of, window } = item;
 
         // Send event to parent, if it has one.
@@ -125,13 +135,34 @@ impl<E: Debug + Clone + Reflect> core::ops::Deref for Pointer<E> {
 }
 
 impl<E: Debug + Clone + Reflect> Pointer<E> {
-    /// Construct a new `Pointer<E>` event.
+    /// Construct a new `Pointer<E>` event that propagates
     pub fn new(id: PointerId, location: Location, event: E, entity: Entity) -> Self {
+        Self::new_inner(id, location, event, entity, true)
+    }
+
+    /// Construct a new `Pointer<E>` event that does not propagate
+    pub fn new_without_propagate(
+        id: PointerId,
+        location: Location,
+        event: E,
+        entity: Entity,
+    ) -> Self {
+        Self::new_inner(id, location, event, entity, false)
+    }
+
+    fn new_inner(
+        id: PointerId,
+        location: Location,
+        event: E,
+        entity: Entity,
+        propagate: bool,
+    ) -> Self {
         Self {
             pointer_id: id,
             pointer_location: location,
             event,
             entity,
+            propagate,
         }
     }
 }
@@ -144,7 +175,11 @@ pub struct Cancel {
     pub hit: HitData,
 }
 
-/// Fires when a pointer crosses into the bounds of the [target entity](EntityEvent::event_target).
+/// Fires when a pointer crosses into the bounds of a [target entity](EntityEvent::event_target).
+/// Unlike [`Enter`], this event bubbles up to all of the
+/// [target entity's](EntityEvent::event_target) ancestors (traversed via the [`ChildOf`] relationship)
+/// without restriction. Refer to [`pointer_events`] for more information on how these events are triggered.
+/// Refer to [`PointerTraversal`] for how [`Pointer`] events are propagated.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Over {
@@ -152,7 +187,49 @@ pub struct Over {
     pub hit: HitData,
 }
 
-/// Fires when a pointer crosses out of the bounds of the [target entity](EntityEvent::event_target).
+/// Fires when a pointer crosses into the bounds of a [target entity](EntityEvent::event_target).
+/// Unlike [`Over`], this event bubbles up through a subset of the
+/// [target entity's](EntityEvent::event_target) ancestors
+/// (traversed via the [`ChildOf`] relationship).
+///
+/// ### Event Propagation
+/// An ancestor of a [target entity](EntityEvent::event_target) will receive an [`Enter`] event
+/// when the ancestor does not have a direct relation to any entity hovered by the
+/// pointer in the previous frame. For example, for a given pointer:
+///
+/// If the previously hovered entity C has the following entity ancestry: A -> B -> C
+///
+/// And the currently hovered entity E has the following entity ancestry: A -> D -> E
+///
+/// [`Enter`] events would be sent for both E and its direct ancestor D.
+/// An [`Enter`] event would not be sent for A because it is a shared ancestor of both C and E.
+///
+/// Note: An [`Enter`] event may be fired for an ancestor even if the pointer does not enter
+/// within the ancestor's bounds. More concretely, if a child's bounds extend beyond the parent's,
+/// and the pointer enters the child's bounds without crossing into the parent's,
+/// two [`Enter`] events are still emitted for both the child and the parent.
+/// This matches the triggering behavior of `mouseenter` events on the web.
+/// To find out whether a pointer is within an entity's bounds upon entering,
+/// check the value of [`is_in_bounds`](Enter::is_in_bounds).
+///
+/// Refer to [`pointer_events`] for more information on how these events are triggered.
+#[derive(Clone, PartialEq, Debug, Reflect)]
+#[reflect(Clone, PartialEq)]
+pub struct Enter {
+    /// Information about the picking intersection.
+    pub hit: HitData,
+    /// Whether this pointer directly entered into the target entity's bounds at the
+    /// time of the event.
+    /// This may be false if this entity's child's bounds extended beyond the entity and
+    /// the pointer entered within the child's bounds only.
+    pub is_in_bounds: bool,
+}
+
+/// Fires when a pointer crosses out of the bounds of a [target entity](EntityEvent::event_target).
+/// Unlike [`Leave`], this event bubbles up to all of the
+/// [target entity's](EntityEvent::event_target) ancestors (traversed via the [`ChildOf`] relationship)
+/// without restriction. Refer to [`pointer_events`] for more information on how these events are triggered.
+/// Refer to [`PointerTraversal`] for how [`Pointer`] events are propagated.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Out {
@@ -160,6 +237,44 @@ pub struct Out {
     pub hit: HitData,
 }
 
+/// Fires when a pointer crosses out of the bounds of a [target entity](EntityEvent::event_target).
+/// Unlike [`Out`], this event bubbles up through a subset of the
+/// [target entity's](EntityEvent::event_target) ancestors
+/// (traversed via the [`ChildOf`] relationship).
+///
+/// ### Event Propagation
+/// An ancestor of a [target entity](EntityEvent::event_target) will receive a [`Leave`] event
+/// when the ancestor does not have a direct relation to any entity hovered by the
+/// pointer in the current frame. For example, for a given pointer:
+///
+/// If the previously hovered entity C has the following entity ancestry: A -> B -> C
+///
+/// And the currently hovered entity E has the following entity ancestry: A -> D -> E
+///
+/// [`Leave`] events would be sent for both C and its direct ancestor B.
+/// A [`Leave`] event would not be sent for A because it is a shared ancestor of both C and E.
+///
+/// Note: An [`Leave`] event may be fired for an ancestor even if the pointer does not leave
+/// the ancestor's bounds. More concretely, if a child's bounds extend beyond the parent's,
+/// and the pointer enters the child's bounds without crossing into the parent's,
+/// two [`Enter`] events are still emitted for both the child and the parent.
+/// This matches the triggering behavior of `mouseleave` events on the web.
+/// To find out whether the pointer was within an entity's bounds before leaving,
+/// check the value of [`was_in_bounds`](Leave::was_in_bounds).
+///
+/// Refer to [`pointer_events`] for more information on how these events are triggered.
+#[derive(Clone, PartialEq, Debug, Reflect)]
+#[reflect(Clone, PartialEq)]
+pub struct Leave {
+    /// Information about the latest prior picking intersection.
+    pub hit: HitData,
+    /// Whether this pointer directly exited out of the target entity's bounds
+    /// at the time of the event.
+    /// This may be false if this entity's child's bounds extended beyond the entity and
+    /// the pointer exited out of the child's bounds only.
+    pub was_in_bounds: bool,
+}
+
 /// Fires when a pointer button is pressed over the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
@@ -360,11 +475,66 @@ impl PointerButtonState {
     }
 }
 
+/// A cache map containing the ancestry of hovered entities
+#[derive(Debug, Clone, Default, Deref, DerefMut)]
+pub struct HoveredEntityAncestors(HashMap<Entity, HashSet<Entity>>);
+
+impl HoveredEntityAncestors {
+    /// Clears self and rebuilds a map of every hovered entity to its ancestors.
+    ///
+    /// This map is used to calculate which entities should receive [`Enter`] or [`Leave`] events.
+    pub fn rebuild(
+        &mut self,
+        hover_map: &HoverMap,
+        pointer_state: &PointerState,
+        ancestors_query: &Query<&ChildOf>,
+    ) {
+        self.clear();
+        for hovered_entity in hover_map
+            .iter()
+            .flat_map(|(_, hashmap)| hashmap.iter().map(|data| *data.0))
+        {
+            // If the ancestors were already added into the map, do not re-fetch
+            if self.contains_key(&hovered_entity) {
+                continue;
+            }
+            // If the ancestors were previously fetched, just re-use the entry.
+            if let Some(previous_entry) =
+                pointer_state.hovered_entity_ancestors.get(&hovered_entity)
+            {
+                self.insert(hovered_entity, previous_entry.clone());
+            } else {
+                let mut ancestors = HashSet::new();
+                for member in ancestors_query.iter_ancestors(hovered_entity) {
+                    ancestors.insert(member);
+                }
+                self.insert(hovered_entity, ancestors);
+            }
+        }
+    }
+
+    /// Returns a new combined `HashSet` of ancestors for the provided `hover_entities`
+    pub fn get_ancestors_union(&self, hover_entities: &HashSet<Entity>) -> HashSet<Entity> {
+        hover_entities
+            .iter()
+            .flat_map(|entity| self.get(entity))
+            .flat_map(|set| set.iter().copied())
+            .collect::<HashSet<Entity>>()
+    }
+
+    /// Returns the ancestors for the provided `hover_entity`, if it has been created
+    pub fn get_ancestors(&self, hover_entity: &Entity) -> Option<&HashSet<Entity>> {
+        self.get(hover_entity)
+    }
+}
+
 /// State for all pointers.
 #[derive(Debug, Clone, Default, Resource)]
 pub struct PointerState {
     /// Pressing and dragging state, organized by pointer and button.
     pub pointer_buttons: HashMap<(PointerId, PointerButton), PointerButtonState>,
+    /// A cache map providing the set of an entity's ancestors for a given hovered entity.
+    pub hovered_entity_ancestors: HoveredEntityAncestors,
 }
 
 impl PointerState {
@@ -384,6 +554,17 @@ impl PointerState {
             .or_default()
     }
 
+    /// Retrieves the ancestors for a given hovered entity
+    pub fn get_ancestors(&self, hovered_entity: &Entity) -> Option<&HashSet<Entity>> {
+        self.hovered_entity_ancestors.get_ancestors(hovered_entity)
+    }
+
+    /// Retrieves the union of ancestors for the given hovered entities
+    pub fn get_ancestors_union(&self, hovered_entities: &HashSet<Entity>) -> HashSet<Entity> {
+        self.hovered_entity_ancestors
+            .get_ancestors_union(hovered_entities)
+    }
+
     /// Clears all the data associated with all of the buttons on a pointer. Does not free the underlying memory.
     pub fn clear(&mut self, pointer_id: PointerId) {
         for button in PointerButton::iter() {
@@ -411,14 +592,16 @@ pub struct PickingMessageWriters<'w> {
     move_events: MessageWriter<'w, Pointer<Move>>,
     out_events: MessageWriter<'w, Pointer<Out>>,
     over_events: MessageWriter<'w, Pointer<Over>>,
+    leave_events: MessageWriter<'w, Pointer<Leave>>,
+    enter_events: MessageWriter<'w, Pointer<Enter>>,
     released_events: MessageWriter<'w, Pointer<Release>>,
 }
 
 /// Dispatches interaction events to the target entities.
 ///
 /// Within a single frame, events are dispatched in the following order:
-/// + [`Out`] → [`DragLeave`].
-/// + [`DragEnter`] → [`Over`].
+/// + [`Out`] → [`Leave`] → [`DragLeave`].
+/// + [`DragEnter`] → [`Enter`] → [`Over`].
 /// + Any number of any of the following:
 ///   + For each movement: [`DragStart`] → [`Drag`] → [`DragOver`] → [`Move`].
 ///   + For each button press: [`Press`] or [`Click`] → [`Release`] → [`DragDrop`] → [`DragEnd`] → [`DragLeave`].
@@ -427,7 +610,7 @@ pub struct PickingMessageWriters<'w> {
 /// Additionally, across multiple frames, the following are also strictly
 /// ordered by the interaction state machine:
 /// + When a pointer moves over the target:
-///   [`Over`], [`Move`], [`Out`].
+///   [`Over`], [`Enter`], [`Move`], [`Leave`], [`Out`].
 /// + When a pointer presses buttons on the target:
 ///   [`Press`], [`Click`], [`Release`].
 /// + When a pointer drags the target:
@@ -437,19 +620,21 @@ pub struct PickingMessageWriters<'w> {
 /// + When a pointer is canceled:
 ///   No other events will follow the [`Cancel`] event for that pointer.
 ///
-/// Two events -- [`Over`] and [`Out`] -- are driven only by the [`HoverMap`].
+/// Four events -- [`Over`], [`Enter`], [`Leave`] and [`Out`] -- are driven only by the [`HoverMap`].
 /// The rest rely on additional data from the [`PointerInput`] event stream. To
 /// receive these events for a custom pointer, you must add [`PointerInput`]
 /// events.
 ///
 /// When the pointer goes from hovering entity A to entity B, entity A will
-/// receive [`Out`] and then entity B will receive [`Over`]. No entity will ever
-/// receive both an [`Over`] and an [`Out`] event during the same frame.
+/// receive [`Out`] and [`Enter`] and then entity B will receive [`Leave`] and [`Over`].
+/// No entity will ever receive both an [`Over`] and an [`Out`] or
+/// an [`Enter`] and a [`Leave`] event during the same frame.
 ///
-/// When we account for event bubbling, this is no longer true. When the hovering focus shifts
-/// between children, parent entities may receive redundant [`Out`] → [`Over`] pairs.
-/// In the context of UI, this is especially problematic. Additional hierarchy-aware
-/// events will be added in a future release.
+/// When we account for event bubbling, the two pairs of events,
+/// [`Out`] [`Over`] and [`Enter`] [`Leave`], behave differently. When the hovering focus shifts
+/// between children, parent entities may receive redundant [`Out`] → [`Over`] pairs. In
+/// the case of [`Enter`] → [`Leave`], shared parent entities will not receive [`Enter`]
+/// or [`Leave`].
 ///
 /// Both [`Click`] and [`Release`] target the entity hovered in the *previous frame*,
 /// rather than the current frame. This is because touch pointers hover nothing
@@ -467,10 +652,14 @@ pub fn pointer_events(
     mut input_events: MessageReader<PointerInput>,
     // ECS State
     pointers: Query<&PointerLocation>,
+    ancestors_query: Query<&ChildOf>,
     pointer_map: Res<PointerMap>,
     hover_map: Res<HoverMap>,
     previous_hover_map: Res<PreviousHoverMap>,
     mut pointer_state: ResMut<PointerState>,
+    mut hovered_entity_ancestors: Local<HoveredEntityAncestors>,
+    mut sent_leave: Local<HashSet<(PointerId, Entity)>>,
+    mut sent_enter: Local<HashSet<(PointerId, Entity)>>,
     // Output
     mut commands: Commands,
     mut message_writers: PickingMessageWriters,
@@ -483,6 +672,9 @@ pub fn pointer_events(
             .and_then(|entity| pointers.get(entity).ok())
             .and_then(|pointer| pointer.location.clone())
     };
+    hovered_entity_ancestors.rebuild(&hover_map, &pointer_state, &ancestors_query);
+    sent_leave.clear();
+    sent_enter.clear();
 
     // If the entity was hovered by a specific pointer last frame...
     for (pointer_id, hovered_entity, hit) in previous_hover_map
@@ -513,6 +705,55 @@ pub fn pointer_events(
             commands.trigger(out_event.clone());
             message_writers.out_events.write(out_event);
 
+            // Potentially send `Leave` events to the entity and all of its ancestors
+            let mut entities_to_send_leave =
+                pointer_state.get_ancestors(&hovered_entity).map_or_else(
+                    || {
+                        ancestors_query
+                            .iter_ancestors(hovered_entity)
+                            .collect::<HashSet<Entity>>()
+                    },
+                    Clone::clone,
+                );
+            entities_to_send_leave.insert(hovered_entity);
+            // Ensure we do not double send to any other entities that have already been sent to during this loop
+            entities_to_send_leave.retain(|entity| !sent_leave.contains(&(pointer_id, *entity)));
+            if !entities_to_send_leave.is_empty() {
+                // Fetch the currently hovered entities and their ancestors
+                let new_hovered_entities = get_hovered_entities(&hover_map, &pointer_id);
+                let new_hovered_ancestors =
+                    hovered_entity_ancestors.get_ancestors_union(&new_hovered_entities);
+                let union = new_hovered_entities
+                    .union(&new_hovered_ancestors)
+                    .copied()
+                    .collect::<HashSet<Entity>>();
+                // Keep entities and ancestors that are not going to continue to be hovered over
+                entities_to_send_leave.retain(|entity| !union.contains(entity));
+                // Send `Leave` events for those entities.
+                // Note that `Leave` events send without propagation; we manually calculated
+                // which ancestors should receive one.
+                for leave_event in entities_to_send_leave.iter().map(|entity| {
+                    Pointer::new_without_propagate(
+                        pointer_id,
+                        location.clone(),
+                        Leave {
+                            hit: hit.clone(),
+                            was_in_bounds: is_directly_hovered(
+                                &previous_hover_map.0,
+                                &pointer_id,
+                                entity,
+                            ),
+                        },
+                        *entity,
+                    )
+                }) {
+                    let entity = leave_event.entity;
+                    commands.trigger(leave_event.clone());
+                    message_writers.leave_events.write(leave_event);
+                    sent_leave.insert((pointer_id, entity));
+                }
+            }
+
             // Possibly send DragLeave events
             for button in PointerButton::iter() {
                 let state = pointer_state.get_mut(pointer_id, button);
@@ -578,12 +819,60 @@ pub fn pointer_events(
             }
         }
 
-        // Emit an Over event if the `hovered_entity` was not hovered by the same pointer the previous frame.
+        // If the `hovered_entity` was not hovered by the same pointer the previous frame...
         if !previous_hover_map
             .get(&pointer_id)
             .iter()
             .any(|e| e.contains_key(&hovered_entity))
         {
+            // Potentially send `Enter` events to the entity and all of its ancestors
+            let mut entities_to_send_enter = hovered_entity_ancestors
+                .get_ancestors(&hovered_entity)
+                .map_or_else(
+                    || {
+                        ancestors_query
+                            .iter_ancestors(hovered_entity)
+                            .collect::<HashSet<Entity>>()
+                    },
+                    Clone::clone,
+                );
+            entities_to_send_enter.insert(hovered_entity);
+            // Ensure we do not double send to any other entities that have already been sent to during this loop
+            entities_to_send_enter
+                .retain(|entity: &Entity| !sent_enter.contains(&(pointer_id, *entity)));
+            if !entities_to_send_enter.is_empty() {
+                // Fetch the previously hovered entities and their ancestors
+                let prev_hovered_entities = get_hovered_entities(&previous_hover_map, &pointer_id);
+                let prev_hovered_ancestors =
+                    pointer_state.get_ancestors_union(&prev_hovered_entities);
+                let union = prev_hovered_entities
+                    .union(&prev_hovered_ancestors)
+                    .copied()
+                    .collect::<HashSet<Entity>>();
+                // Keep entities and ancestors that were not hovered over previously
+                entities_to_send_enter.retain(|entity| !union.contains(entity));
+                // Send `Enter` events for those entities.
+                // Note that `Enter` events send without propagation; we manually calculated
+                // which ancestors should receive one.
+                for enter_event in entities_to_send_enter.iter().map(|entity| {
+                    Pointer::new_without_propagate(
+                        pointer_id,
+                        location.clone(),
+                        Enter {
+                            hit: hit.clone(),
+                            is_in_bounds: is_directly_hovered(&hover_map.0, &pointer_id, entity),
+                        },
+                        *entity,
+                    )
+                }) {
+                    let entity = enter_event.entity;
+                    commands.trigger(enter_event.clone());
+                    message_writers.enter_events.write(enter_event);
+                    sent_enter.insert((pointer_id, entity));
+                }
+            }
+
+            // Always send Over events
             let over_event = Pointer::new(
                 pointer_id,
                 location.clone(),
@@ -595,6 +884,14 @@ pub fn pointer_events(
         }
     }
 
+    // Update pointer_state with the current hovered entity ancestors
+    // We swap with the Local SystemParam's map, which will be rebuilt
+    // on the next invocation of `pointer_events`
+    core::mem::swap(
+        &mut hovered_entity_ancestors.0,
+        &mut pointer_state.hovered_entity_ancestors,
+    );
+
     // Dispatch input events...
     for PointerInput {
         pointer_id,
@@ -879,3 +1176,263 @@ pub fn pointer_events(
         }
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use bevy_app::App;
+    use bevy_camera::{Camera, ManualTextureViewHandle};
+
+    use crate::pointer::update_pointer_map;
+
+    use super::*;
+
+    const POINTER_ID: PointerId = PointerId::Mouse;
+    const STUB_LOCATION: Location = Location {
+        target: NormalizedRenderTarget::TextureView(ManualTextureViewHandle(5)),
+        position: Vec2::new(3., 4.),
+    };
+
+    fn initialize_app_for_test(app: &mut App) {
+        // Init all the resources and messages necessary to run `pointer_events`
+        app.init_resource::<HoverMap>()
+            .init_resource::<PreviousHoverMap>()
+            .init_resource::<PointerState>()
+            .add_message::<PointerInput>()
+            .add_message::<Pointer<Cancel>>()
+            .add_message::<Pointer<Click>>()
+            .add_message::<Pointer<Press>>()
+            .add_message::<Pointer<DragDrop>>()
+            .add_message::<Pointer<DragEnd>>()
+            .add_message::<Pointer<DragEnter>>()
+            .add_message::<Pointer<Drag>>()
+            .add_message::<Pointer<DragLeave>>()
+            .add_message::<Pointer<DragOver>>()
+            .add_message::<Pointer<DragStart>>()
+            .add_message::<Pointer<Scroll>>()
+            .add_message::<Pointer<Move>>()
+            .add_message::<Pointer<Out>>()
+            .add_message::<Pointer<Over>>()
+            .add_message::<Pointer<Leave>>()
+            .add_message::<Pointer<Enter>>()
+            .add_message::<Pointer<Release>>();
+
+        // Initialize the pointer map resource manually with a stub location for the mouse
+        app.world_mut()
+            .spawn((POINTER_ID, PointerLocation::new(STUB_LOCATION)));
+        app.world_mut().insert_resource(PointerMap::default());
+        assert!(app
+            .world_mut()
+            .run_system_cached(update_pointer_map)
+            .is_ok());
+    }
+
+    fn update_hover_map_with_hovered_entities(app: &mut App, camera: Entity, entities: &[Entity]) {
+        let mut hover_map = HoverMap::default();
+        let mut entity_map = HashMap::default();
+        for entity in entities {
+            entity_map.insert(
+                *entity,
+                HitData {
+                    depth: 0.0,
+                    camera,
+                    position: None,
+                    normal: None,
+                },
+            );
+        }
+        hover_map.insert(PointerId::Mouse, entity_map);
+
+        let previous_hover_map = app.world().resource::<HoverMap>().0.clone();
+        app.world_mut()
+            .insert_resource(PreviousHoverMap(previous_hover_map));
+        app.world_mut().insert_resource(hover_map);
+    }
+
+    #[test]
+    fn enter_leave_events() {
+        // the bool distinguishes between different *_in_bounds bool vals
+        #[derive(Resource, Default)]
+        struct EnterEventCounts(HashMap<(Entity, bool), usize>);
+
+        #[derive(Resource, Default)]
+        struct LeaveEventCounts(HashMap<(Entity, bool), usize>);
+
+        fn observe_enter(event: On<Pointer<Enter>>, mut counts: ResMut<EnterEventCounts>) {
+            *counts
+                .0
+                .entry((event.entity, event.event().is_in_bounds))
+                .or_insert(0_usize) += 1;
+        }
+
+        fn observe_leave(event: On<Pointer<Leave>>, mut counts: ResMut<LeaveEventCounts>) {
+            *counts
+                .0
+                .entry((event.entity, event.event().was_in_bounds))
+                .or_insert(0_usize) += 1;
+        }
+
+        fn assert_msg_event_counts(app: &App, enter_count: usize, leave_count: usize) {
+            let enter_messages = app.world().resource::<Messages<Pointer<Enter>>>();
+            let leave_messages = app.world().resource::<Messages<Pointer<Leave>>>();
+            assert_eq!(enter_messages.len(), enter_count);
+            assert_eq!(leave_messages.len(), leave_count);
+        }
+
+        fn assert_observer_event_counts(
+            app: &App,
+            entity: Entity,
+            enter_in_bounds_counts: usize,
+            enter_out_of_bounds_counts: usize,
+            leave_in_bounds_counts: usize,
+            leave_out_of_bounds_counts: usize,
+        ) {
+            assert_eq!(
+                *app.world()
+                    .resource::<EnterEventCounts>()
+                    .0
+                    .get(&(entity, true))
+                    .unwrap_or(&0),
+                enter_in_bounds_counts
+            );
+            assert_eq!(
+                *app.world()
+                    .resource::<EnterEventCounts>()
+                    .0
+                    .get(&(entity, false))
+                    .unwrap_or(&0),
+                enter_out_of_bounds_counts
+            );
+            assert_eq!(
+                *app.world()
+                    .resource::<LeaveEventCounts>()
+                    .0
+                    .get(&(entity, true))
+                    .unwrap_or(&0),
+                leave_in_bounds_counts
+            );
+            assert_eq!(
+                *app.world()
+                    .resource::<LeaveEventCounts>()
+                    .0
+                    .get(&(entity, false))
+                    .unwrap_or(&0),
+                leave_out_of_bounds_counts
+            );
+        }
+
+        let mut app = App::new();
+        initialize_app_for_test(&mut app);
+        app.init_resource::<EnterEventCounts>()
+            .init_resource::<LeaveEventCounts>();
+        let enter_messages = app.world().resource::<Messages<Pointer<Enter>>>();
+        let leave_messages = app.world().resource::<Messages<Pointer<Leave>>>();
+        assert_eq!(enter_messages.len(), 0);
+        assert_eq!(leave_messages.len(), 0);
+        // Setup test entities
+        let camera = app.world_mut().spawn(Camera::default()).id();
+        let child_one = app
+            .world_mut()
+            .spawn_empty()
+            .observe(observe_enter)
+            .observe(observe_leave)
+            .id();
+        let child_two = app
+            .world_mut()
+            .spawn_empty()
+            .observe(observe_enter)
+            .observe(observe_leave)
+            .id();
+        let parent = app
+            .world_mut()
+            .spawn_empty()
+            .add_children(&[child_one, child_two])
+            .observe(observe_enter)
+            .observe(observe_leave)
+            .id();
+
+        // FIRST: child_one is hovered over
+        update_hover_map_with_hovered_entities(&mut app, camera, &[child_one]);
+
+        assert!(app.world_mut().run_system_cached(pointer_events).is_ok());
+
+        // child_one received an in_bounds `Enter` event
+        // The parent received an indirect `Enter` event because its child was hovered into
+        assert_msg_event_counts(&app, 2, 0);
+        assert_observer_event_counts(&app, parent, 0, 1, 0, 0);
+        assert_observer_event_counts(&app, child_one, 1, 0, 0, 0);
+        assert_observer_event_counts(&app, child_two, 0, 0, 0, 0);
+        app.world_mut().increment_change_tick();
+        // ---
+
+        // SECOND: child_one is hovered out of, child_two and parent are directly hovered over
+        update_hover_map_with_hovered_entities(&mut app, camera, &[child_two, parent]);
+
+        assert!(app.world_mut().run_system_cached(pointer_events).is_ok());
+
+        // child_one received an in_bounds `Leave` event.
+        // child_two received an in_bounds `Enter` event.
+        // The parent did not receive any events because it is a shared ancestor
+        assert_msg_event_counts(&app, 3, 1);
+        assert_observer_event_counts(&app, parent, 0, 1, 0, 0);
+        assert_observer_event_counts(&app, child_one, 1, 0, 1, 0);
+        assert_observer_event_counts(&app, child_two, 1, 0, 0, 0);
+        app.world_mut().increment_change_tick();
+        // ---
+
+        // THIRD: child_two is hovered out of, parent is still hovered
+        update_hover_map_with_hovered_entities(&mut app, camera, &[parent]);
+
+        assert!(app.world_mut().run_system_cached(pointer_events).is_ok());
+
+        // child_two received an in_bounds `Leave` event.
+        assert_msg_event_counts(&app, 3, 2);
+        assert_observer_event_counts(&app, parent, 0, 1, 0, 0);
+        assert_observer_event_counts(&app, child_one, 1, 0, 1, 0);
+        assert_observer_event_counts(&app, child_two, 1, 0, 1, 0);
+        app.world_mut().increment_change_tick();
+        // ---
+
+        // FOURTH: child_two is hovered back into, parent is no longer directly hovered
+        update_hover_map_with_hovered_entities(&mut app, camera, &[child_two]);
+
+        assert!(app.world_mut().run_system_cached(pointer_events).is_ok());
+
+        // child_two received an in_bounds `Enter` event
+        // The parent did not receive an `Leave` event because its child is still hovered
+        assert_msg_event_counts(&app, 4, 2);
+        assert_observer_event_counts(&app, parent, 0, 1, 0, 0);
+        assert_observer_event_counts(&app, child_one, 1, 0, 1, 0);
+        assert_observer_event_counts(&app, child_two, 2, 0, 1, 0);
+        app.world_mut().increment_change_tick();
+        // ---
+
+        // FIFTH: child_two is hovered out of
+        update_hover_map_with_hovered_entities(&mut app, camera, &[]);
+
+        assert!(app.world_mut().run_system_cached(pointer_events).is_ok());
+
+        // child_two received one in_bounds `Leave` event
+        // The parent received one indirect `Leave` event because the pointer is no longer hovering
+        // any of its children
+        assert_msg_event_counts(&app, 4, 4);
+        assert_observer_event_counts(&app, parent, 0, 1, 0, 1);
+        assert_observer_event_counts(&app, child_one, 1, 0, 1, 0);
+        assert_observer_event_counts(&app, child_two, 2, 0, 2, 0);
+        app.world_mut().increment_change_tick();
+        // ---
+
+        // FINAL: parent and child_one are directly hovered into
+        update_hover_map_with_hovered_entities(&mut app, camera, &[parent, child_one]);
+
+        assert!(app.world_mut().run_system_cached(pointer_events).is_ok());
+
+        // The parent received one in_bounds `Enter` event
+        // child_one received one in_bounds `Enter` event
+        assert_msg_event_counts(&app, 6, 4);
+        assert_observer_event_counts(&app, parent, 1, 1, 0, 1);
+        assert_observer_event_counts(&app, child_one, 2, 0, 1, 0);
+        assert_observer_event_counts(&app, child_two, 2, 0, 2, 0);
+        app.world_mut().increment_change_tick();
+        // ---
+    }
+}
diff --git a/crates/bevy_picking/src/hover.rs b/crates/bevy_picking/src/hover.rs
index 62791136366ef..53996286125fa 100644
--- a/crates/bevy_picking/src/hover.rs
+++ b/crates/bevy_picking/src/hover.rs
@@ -60,6 +60,34 @@ pub struct HoverMap(pub HashMap<PointerId, HashMap<Entity, HitData>>);
 #[derive(Debug, Deref, DerefMut, Default, Resource)]
 pub struct PreviousHoverMap(pub HashMap<PointerId, HashMap<Entity, HitData>>);
 
+/// Gets the hovered entities for a `pointer_id` from a provided `HoverMap` inner map
+pub(crate) fn get_hovered_entities(
+    hover_map: &HashMap<PointerId, HashMap<Entity, HitData>>,
+    pointer_id: &PointerId,
+) -> HashSet<Entity> {
+    hover_map
+        .get(pointer_id)
+        .map_or(HashSet::default(), |entity_hit| {
+            entity_hit
+                .iter()
+                .map(|(&entity, _)| entity)
+                .collect::<HashSet<Entity>>()
+        })
+}
+
+/// Returns whether there is hit data for the given `pointer_id` and `entity`
+/// from a provided `HoverMap` inner map. This means that the entity is
+/// "directly hovered" by the `pointer_id` for the given `hover_map`
+pub(crate) fn is_directly_hovered(
+    hover_map: &HashMap<PointerId, HashMap<Entity, HitData>>,
+    pointer_id: &PointerId,
+    entity: &Entity,
+) -> bool {
+    hover_map
+        .get(pointer_id)
+        .is_some_and(|hit_data_map| hit_data_map.contains_key(entity))
+}
+
 /// Coalesces all data from inputs and backends to generate a map of the currently hovered entities.
 /// This is the final focusing step to determine which entity the pointer is hovering over.
 pub fn generate_hovermap(
diff --git a/crates/bevy_picking/src/lib.rs b/crates/bevy_picking/src/lib.rs
index 72b3166f4d687..497eb7c33e460 100644
--- a/crates/bevy_picking/src/lib.rs
+++ b/crates/bevy_picking/src/lib.rs
@@ -430,6 +430,8 @@ impl Plugin for InteractionPlugin {
             .add_message::<Pointer<Move>>()
             .add_message::<Pointer<Out>>()
             .add_message::<Pointer<Over>>()
+            .add_message::<Pointer<Leave>>()
+            .add_message::<Pointer<Enter>>()
             .add_message::<Pointer<Release>>()
             .add_message::<Pointer<Scroll>>()
             .add_systems(
diff --git a/examples/ui/navigation/directional_navigation.rs b/examples/ui/navigation/directional_navigation.rs
index 53b6b12c41b0e..5b6a96fd7b528 100644
--- a/examples/ui/navigation/directional_navigation.rs
+++ b/examples/ui/navigation/directional_navigation.rs
@@ -451,17 +451,16 @@ fn interact_with_focused_button(
         .contains(&DirectionalNavigationAction::Select)
         && let Some(focused_entity) = input_focus.0
     {
-        commands.trigger(Pointer::<Click> {
-            entity: focused_entity,
-            pointer_id: PointerId::Mouse,
-            pointer_location: Location {
+        commands.trigger(Pointer::new(
+            PointerId::Mouse,
+            Location {
                 target: NormalizedRenderTarget::None {
                     width: 0,
                     height: 0,
                 },
                 position: Vec2::ZERO,
             },
-            event: Click {
+            Click {
                 button: PointerButton::Primary,
                 hit: HitData {
                     camera: Entity::PLACEHOLDER,
@@ -471,6 +470,7 @@ fn interact_with_focused_button(
                 },
                 duration: Duration::from_secs_f32(0.1),
             },
-        });
+            focused_entity,
+        ));
     }
 }
diff --git a/examples/ui/navigation/directional_navigation_overrides.rs b/examples/ui/navigation/directional_navigation_overrides.rs
index 43def947e6627..dec3eff4e19eb 100644
--- a/examples/ui/navigation/directional_navigation_overrides.rs
+++ b/examples/ui/navigation/directional_navigation_overrides.rs
@@ -832,17 +832,16 @@ fn interact_with_focused_button(
         .contains(&DirectionalNavigationAction::Select)
         && let Some(focused_entity) = input_focus.0
     {
-        commands.trigger(Pointer::<Click> {
-            entity: focused_entity,
-            pointer_id: PointerId::Mouse,
-            pointer_location: Location {
+        commands.trigger(Pointer::new(
+            PointerId::Mouse,
+            Location {
                 target: NormalizedRenderTarget::None {
                     width: 0,
                     height: 0,
                 },
                 position: Vec2::ZERO,
             },
-            event: Click {
+            Click {
                 button: PointerButton::Primary,
                 hit: HitData {
                     camera: Entity::PLACEHOLDER,
@@ -852,6 +851,7 @@ fn interact_with_focused_button(
                 },
                 duration: Duration::from_secs_f32(0.1),
             },
-        });
+            focused_entity,
+        ));
     }
 }
