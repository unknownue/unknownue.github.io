diff --git a/crates/bevy_pbr/src/render/wireframe.wgsl b/crates/bevy_pbr/src/render/wireframe.wgsl
index 5e155391fbbcc..ee388f58ee531 100644
--- a/crates/bevy_pbr/src/render/wireframe.wgsl
+++ b/crates/bevy_pbr/src/render/wireframe.wgsl
@@ -1,12 +1,263 @@
+#ifdef WIREFRAME_WIDE
+
+#import bevy_pbr::{
+    mesh_bindings::mesh,
+    mesh_view_bindings::view,
+    view_transformations::position_world_to_clip,
+}
+#import bevy_render::maths::affine3_to_square
+
+struct Immediates {
+    color: vec4<f32>,
+    line_width: f32,
+    smoothing: f32,
+#ifdef SIXTEEN_BYTE_ALIGNMENT
+    _pad0: f32,
+    _pad1: f32,
+#endif
+}
+
+var<immediate> immediates: Immediates;
+
+struct VertexPullParams {
+    index_offset: u32,
+    vertex_stride: u32,
+    position_offset: u32,
+}
+
+@group(3) @binding(0) var<storage, read> vertex_data: array<u32>;
+@group(3) @binding(1) var<storage, read> index_data: array<u32>;
+@group(3) @binding(2) var<uniform> vp_params: VertexPullParams;
+
+struct WireframeVertexOutput {
+    @builtin(position) position: vec4<f32>,
+    @location(0) @interpolate(linear) edge_distance: vec4<f32>,
+}
+
+// unsigned perpendicular distance from point p to the infinite line through a and b.
+fn point_line_distance(p: vec2<f32>, a: vec2<f32>, b: vec2<f32>) -> f32 {
+    let edge = b - a;
+    let len = length(edge);
+    if len < 0.001 {
+        return 1e6;
+    }
+    return abs(edge.x * (p.y - a.y) - edge.y * (p.x - a.x)) / len;
+}
+
+// finds the local-space vertex position for a given vertex index by reading from the vertex buffer using the provided
+// parameters. the vertex buffer is interpreted as an array of u32s, so the parameters allow us to calculate the
+// correct offset for the position attribute of the vertex at the given index.
+fn read_local_position(first_vertex: u32, vertex_index: u32) -> vec3<f32> {
+    let base = (first_vertex + vertex_index) * vp_params.vertex_stride
+               + vp_params.position_offset;
+    return vec3<f32>(
+        bitcast<f32>(vertex_data[base]),
+        bitcast<f32>(vertex_data[base + 1u]),
+        bitcast<f32>(vertex_data[base + 2u]),
+    );
+}
+
+@vertex
+fn vertex(
+    @builtin(vertex_index) vertex_index: u32,
+    @builtin(instance_index) instance_index: u32,
+) -> WireframeVertexOutput {
+    var out: WireframeVertexOutput;
+
+    let first_vertex = mesh[instance_index].first_vertex_index;
+    let draw_id = vertex_index - first_vertex;
+    let corner = draw_id % 3u;
+    let tri_base = draw_id - corner;
+
+    let idx0 = index_data[vp_params.index_offset + tri_base];
+    let idx1 = index_data[vp_params.index_offset + tri_base + 1u];
+    let idx2 = index_data[vp_params.index_offset + tri_base + 2u];
+
+    let p0 = read_local_position(first_vertex, idx0);
+    let p1 = read_local_position(first_vertex, idx1);
+    let p2 = read_local_position(first_vertex, idx2);
+
+    let world_from_local = affine3_to_square(mesh[instance_index].world_from_local);
+    let clip0 = position_world_to_clip((world_from_local * vec4(p0, 1.0)).xyz);
+    let clip1 = position_world_to_clip((world_from_local * vec4(p1, 1.0)).xyz);
+    let clip2 = position_world_to_clip((world_from_local * vec4(p2, 1.0)).xyz);
+
+    let viewport_size = view.viewport.zw;
+    let screen0 = (clip0.xy / clip0.w) * viewport_size * 0.5;
+    let screen1 = (clip1.xy / clip1.w) * viewport_size * 0.5;
+    let screen2 = (clip2.xy / clip2.w) * viewport_size * 0.5;
+
+    let area2 = abs((screen1.x - screen0.x) * (screen2.y - screen0.y)
+                   - (screen2.x - screen0.x) * (screen1.y - screen0.y));
+
+    let len01 = length(screen1 - screen0);
+    let len12 = length(screen2 - screen1);
+    let len20 = length(screen0 - screen2);
+
+    // altitudes: h_i = 2 * area / opposite_edge_length
+    // the altitude-based distance field follows Baerentzen et al., "Single-Pass
+    // Wireframe Rendering" (SIGGRAPH 2006) and the NVIDIA "Solid Wireframe"
+    // whitepaper (2007).
+    let h0 = area2 / max(len12, 0.001);
+    let h1 = area2 / max(len20, 0.001);
+    let h2 = area2 / max(len01, 0.001);
+
+#ifdef WIREFRAME_QUADS
+    // detect and suppress the shared diagonal between two triangles forming a quad.
+    let quad_base = (draw_id / 6u) * 6u;
+    let tri_in_quad = (draw_id / 3u) % 2u;
+    let other_tri_base = quad_base + (1u - tri_in_quad) * 3u;
+
+    let j0 = index_data[vp_params.index_offset + other_tri_base];
+    let j1 = index_data[vp_params.index_offset + other_tri_base + 1u];
+    let j2 = index_data[vp_params.index_offset + other_tri_base + 2u];
+
+    let in_other_0 = (idx0 == j0) || (idx0 == j1) || (idx0 == j2);
+    let in_other_1 = (idx1 == j0) || (idx1 == j1) || (idx1 == j2);
+    let in_other_2 = (idx2 == j0) || (idx2 == j1) || (idx2 == j2);
+
+    // edge is diagonal if both endpoints appear in the other triangle
+    let diag_01 = in_other_0 && in_other_1;
+    let diag_12 = in_other_1 && in_other_2;
+    let diag_20 = in_other_2 && in_other_0;
+    let has_diagonal = diag_01 || diag_12 || diag_20;
+
+    // find the extra vertex from the other triangle (the one not shared with ours)
+    // and compute distances to the other triangle's two perimeter edges.
+    // this ensures each fragment sees all 4 quad perimeter edges, not just the 2
+    // belonging to its own triangle. without this, pixels near the diagonal see the
+    // wrong triangle's edges and the wireframe line appears to thin at vertices.
+    var other_d0 = vec2<f32>(1e6);
+    var other_d1 = vec2<f32>(1e6);
+    var other_d2 = vec2<f32>(1e6);
+
+    if has_diagonal {
+        // identify the extra vertex index
+        let j0_shared = (j0 == idx0) || (j0 == idx1) || (j0 == idx2);
+        let j1_shared = (j1 == idx0) || (j1 == idx1) || (j1 == idx2);
+        var extra_idx = j2;
+        if !j0_shared {
+            extra_idx = j0;
+        } else if !j1_shared {
+            extra_idx = j1;
+        }
+
+        let p_extra = read_local_position(first_vertex, extra_idx);
+        let clip_extra = position_world_to_clip((world_from_local * vec4(p_extra, 1.0)).xyz);
+        let screen_extra = (clip_extra.xy / clip_extra.w) * viewport_size * 0.5;
+
+        // the two "other" perimeter edges connect the extra vertex to each diagonal
+        // endpoint. identify the diagonal endpoints from our triangle's vertices.
+        var diag_a = screen0;
+        var diag_b = screen1;
+        if diag_12 {
+            diag_a = screen1;
+            diag_b = screen2;
+        } else if diag_20 {
+            diag_a = screen2;
+            diag_b = screen0;
+        }
+
+        // other edge 1: extra_vertex → diag_a
+        // other edge 2: extra_vertex → diag_b
+        // compute unsigned perpendicular distance at each of our three vertices.
+        other_d0 = vec2<f32>(
+            point_line_distance(screen0, screen_extra, diag_a),
+            point_line_distance(screen0, screen_extra, diag_b),
+        );
+        other_d1 = vec2<f32>(
+            point_line_distance(screen1, screen_extra, diag_a),
+            point_line_distance(screen1, screen_extra, diag_b),
+        );
+        other_d2 = vec2<f32>(
+            point_line_distance(screen2, screen_extra, diag_a),
+            point_line_distance(screen2, screen_extra, diag_b),
+        );
+    }
+
+    let mask = vec3<f32>(
+        select(1.0, 0.0, diag_12),
+        select(1.0, 0.0, diag_20),
+        select(1.0, 0.0, diag_01),
+    );
+    let suppress = vec3<f32>(1.0) - mask;
+
+    // pack all 4 quad perimeter edge distances into edge_distance:
+    // xyz = own triangle's edges (diagonal slot replaced with other_d.x)
+    // w   = other_d.y
+    // taking min(other_d.x, other_d.y) at the vertex level would be wrong
+    // because the diagonal endpoints lie ON the other perimeter edges,
+    // giving min = 0 at both endpoints and 0 along the entire diagonal
+    // after interpolation. keeping them separate ensures the interpolated
+    // values are nonzero at the diagonal's midpoint.
+    if corner == 0u {
+        let ed = vec3<f32>(h0, 0.0, 0.0) * mask + suppress * other_d0.x;
+        out.edge_distance = vec4<f32>(ed.x, ed.y, ed.z, other_d0.y);
+        out.position = clip0;
+    } else if corner == 1u {
+        let ed = vec3<f32>(0.0, h1, 0.0) * mask + suppress * other_d1.x;
+        out.edge_distance = vec4<f32>(ed.x, ed.y, ed.z, other_d1.y);
+        out.position = clip1;
+    } else {
+        let ed = vec3<f32>(0.0, 0.0, h2) * mask + suppress * other_d2.x;
+        out.edge_distance = vec4<f32>(ed.x, ed.y, ed.z, other_d2.y);
+        out.position = clip2;
+    }
+#else // WIREFRAME_QUADS
+    if corner == 0u {
+        out.edge_distance = vec4<f32>(h0, 0.0, 0.0, 1e6);
+        out.position = clip0;
+    } else if corner == 1u {
+        out.edge_distance = vec4<f32>(0.0, h1, 0.0, 1e6);
+        out.position = clip1;
+    } else {
+        out.edge_distance = vec4<f32>(0.0, 0.0, h2, 1e6);
+        out.position = clip2;
+    }
+#endif // WIREFRAME_QUADS
+
+    return out;
+}
+
+@fragment
+fn fragment(in: WireframeVertexOutput) -> @location(0) vec4<f32> {
+    let d = min(min(in.edge_distance.x, in.edge_distance.y),
+               min(in.edge_distance.z, in.edge_distance.w));
+
+    let width = immediates.line_width;
+    let smoothing = immediates.smoothing;
+
+    let effective_width = max(width, 1.0);
+    let alpha_scale = min(width, 1.0);
+
+    let half_width = effective_width * 0.5;
+
+    let alpha = (1.0 - smoothstep(half_width, half_width + smoothing, d))
+              * alpha_scale
+              * immediates.color.a;
+
+    if alpha < 0.01 {
+        discard;
+    }
+
+    return vec4<f32>(immediates.color.rgb, alpha);
+}
+
+#else // WIREFRAME_WIDE
+
+// the fast path for thin wireframes that render as lines
+
 #import bevy_pbr::forward_io::VertexOutput
 
-struct PushConstants {
-    color: vec4<f32>
+struct Immediates {
+    color: vec4<f32>,
 }
 
-var<immediate> push_constants: PushConstants;
+var<immediate> immediates: Immediates;
 
 @fragment
 fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
-    return push_constants.color;
+    return immediates.color;
 }
+
+#endif // WIREFRAME_WIDE
diff --git a/crates/bevy_pbr/src/wireframe.rs b/crates/bevy_pbr/src/wireframe.rs
index 8df1b4a6ff8cb..64b9dc86eab22 100644
--- a/crates/bevy_pbr/src/wireframe.rs
+++ b/crates/bevy_pbr/src/wireframe.rs
@@ -1,4 +1,5 @@
 use crate::{
+    render::{PreprocessBindGroups, PreprocessPipelines},
     DrawMesh, MeshPipeline, MeshPipelineKey, RenderLightmaps, RenderMeshInstanceFlags,
     RenderMeshInstances, SetMeshBindGroup, SetMeshViewBindGroup, SetMeshViewBindingArrayBindGroup,
     ViewKeyCache, ViewSpecializationTicks,
@@ -15,21 +16,25 @@ use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::{
     change_detection::Tick,
     prelude::*,
+    query::ROQueryItem,
     system::{lifetimeless::SRes, SystemChangeTick, SystemParamItem},
 };
-use bevy_mesh::{Mesh3d, MeshVertexBufferLayoutRef};
+use bevy_mesh::{Mesh, Mesh3d, MeshVertexBufferLayoutRef};
 use bevy_platform::{
     collections::{HashMap, HashSet},
     hash::FixedHasher,
 };
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
 use bevy_render::{
-    batching::gpu_preprocessing::{GpuPreprocessingMode, GpuPreprocessingSupport},
+    batching::gpu_preprocessing::{
+        GpuPreprocessingMode, GpuPreprocessingSupport, IndirectBatchSet, IndirectParametersBuffers,
+        IndirectParametersNonIndexed,
+    },
     camera::{extract_cameras, ExtractedCamera},
     extract_resource::ExtractResource,
     mesh::{
         allocator::{MeshAllocator, SlabId},
-        RenderMesh,
+        RenderMesh, RenderMeshBufferInfo,
     },
     prelude::*,
     render_asset::{
@@ -41,8 +46,8 @@ use bevy_render::{
         PhaseItemBatchSetKey, PhaseItemExtraIndex, RenderCommand, RenderCommandResult,
         SetItemPipeline, TrackedRenderPass, ViewBinnedRenderPhases,
     },
-    render_resource::*,
-    renderer::{RenderContext, RenderDevice, ViewQuery},
+    render_resource::{binding_types::*, *},
+    renderer::{RenderContext, RenderDevice, RenderQueue, ViewQuery},
     sync_world::{MainEntity, MainEntityHashMap},
     view::{
         ExtractedView, NoIndirectDrawing, RenderVisibilityRanges, RenderVisibleEntities,
@@ -51,7 +56,8 @@ use bevy_render::{
     Extract, Render, RenderApp, RenderDebugFlags, RenderStartup, RenderSystems,
 };
 use bevy_shader::Shader;
-use core::{hash::Hash, ops::Range};
+use bytemuck::{Pod, Zeroable};
+use core::{any::TypeId, hash::Hash, mem::size_of, ops::Range};
 use tracing::{error, warn};
 
 /// A [`Plugin`] that draws wireframes.
@@ -88,12 +94,16 @@ impl Plugin for WireframePlugin {
         .init_resource::<SpecializedMeshPipelines<Wireframe3dPipeline>>()
         .init_resource::<WireframeConfig>()
         .init_resource::<WireframeEntitiesNeedingSpecialization>()
+        .register_type::<WireframeLineWidth>()
+        .register_type::<WireframeTopology>()
         .add_systems(Startup, setup_global_wireframe_material)
         .add_systems(
             Update,
             (
-                global_color_changed.run_if(resource_changed::<WireframeConfig>),
+                wireframe_config_changed.run_if(resource_changed::<WireframeConfig>),
                 wireframe_color_changed,
+                wireframe_line_width_changed,
+                wireframe_topology_changed,
                 // Run `apply_global_wireframe_material` after `apply_wireframe_material` so that the global
                 // wireframe setting is applied to a mesh on the same frame its wireframe marker component is removed.
                 (apply_wireframe_material, apply_global_wireframe_material).chain(),
@@ -122,12 +132,20 @@ impl Plugin for WireframePlugin {
             return;
         }
 
+        // we need storage for vertex pulling in the wide wireframe path
+        render_app
+            .world_mut()
+            .resource_mut::<MeshAllocator>()
+            .extra_buffer_usages |= BufferUsages::STORAGE;
+
         render_app
             .init_resource::<WireframeEntitySpecializationTicks>()
             .init_resource::<SpecializedWireframePipelineCache>()
             .init_resource::<DrawFunctions<Wireframe3d>>()
-            .add_render_command::<Wireframe3d, DrawWireframe3d>()
+            .add_render_command::<Wireframe3d, DrawWireframe3dThin>()
+            .add_render_command::<Wireframe3d, DrawWireframe3dWide>()
             .init_resource::<RenderWireframeInstances>()
+            .init_resource::<WireframeWideBindGroups>()
             .init_resource::<SpecializedMeshPipelines<Wireframe3dPipeline>>()
             .add_systems(RenderStartup, init_wireframe_3d_pipeline)
             .add_systems(
@@ -151,6 +169,10 @@ impl Plugin for WireframePlugin {
                         .in_set(RenderSystems::PrepareMeshes)
                         .after(prepare_assets::<RenderWireframeMaterial>)
                         .after(prepare_assets::<RenderMesh>),
+                    prepare_wireframe_wide_bind_groups
+                        .in_set(RenderSystems::PrepareBindGroups)
+                        .after(prepare_assets::<RenderWireframeMaterial>)
+                        .after(prepare_assets::<RenderMesh>),
                     queue_wireframes
                         .in_set(RenderSystems::QueueMeshes)
                         .after(prepare_assets::<RenderWireframeMaterial>),
@@ -262,6 +284,11 @@ pub struct Wireframe3dBatchSetKey {
     ///
     /// For non-mesh items, you can safely fill this with `None`.
     pub index_slab: Option<SlabId>,
+
+    /// For the wide wireframe path, the mesh asset ID ensures all draws in one
+    /// batch set share the same vertex-pull params uniform. `None` for the thin
+    /// path, which doesn't need per-mesh bind groups.
+    pub mesh_asset_id: Option<UntypedAssetId>,
 }
 
 impl PhaseItemBatchSetKey for Wireframe3dBatchSetKey {
@@ -279,9 +306,9 @@ pub struct Wireframe3dBinKey {
     pub asset_id: UntypedAssetId,
 }
 
-pub struct SetWireframe3dImmediates;
+pub struct SetWireframe3dThinImmediates;
 
-impl<P: PhaseItem> RenderCommand<P> for SetWireframe3dImmediates {
+impl<P: PhaseItem> RenderCommand<P> for SetWireframe3dThinImmediates {
     type Param = (
         SRes<RenderWireframeInstances>,
         SRes<RenderAssets<RenderWireframeMaterial>>,
@@ -309,47 +336,447 @@ impl<P: PhaseItem> RenderCommand<P> for SetWireframe3dImmediates {
     }
 }
 
-pub type DrawWireframe3d = (
+pub struct SetWireframe3dWideImmediates;
+
+#[derive(Clone, Copy, Pod, Zeroable)]
+#[repr(C)]
+struct WireframeWideImmediates {
+    color: [f32; 4],
+    line_width: f32,
+    smoothing: f32,
+    #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
+    _padding: [f32; 2],
+}
+
+impl<P: PhaseItem> RenderCommand<P> for SetWireframe3dWideImmediates {
+    type Param = (
+        SRes<RenderWireframeInstances>,
+        SRes<RenderAssets<RenderWireframeMaterial>>,
+    );
+    type ViewQuery = ();
+    type ItemQuery = ();
+
+    #[inline]
+    fn render<'w>(
+        item: &P,
+        _view: (),
+        _item_query: Option<()>,
+        (wireframe_instances, wireframe_assets): SystemParamItem<'w, '_, Self::Param>,
+        pass: &mut TrackedRenderPass<'w>,
+    ) -> RenderCommandResult {
+        let Some(wireframe_material) = wireframe_instances.get(&item.main_entity()) else {
+            return RenderCommandResult::Failure("No wireframe material found for entity");
+        };
+        let Some(wireframe_material) = wireframe_assets.get(*wireframe_material) else {
+            return RenderCommandResult::Failure("No wireframe material found for entity");
+        };
+
+        let push = WireframeWideImmediates {
+            color: wireframe_material.color,
+            line_width: wireframe_material.line_width,
+            smoothing: if wireframe_material.line_width <= 1.0 {
+                0.5
+            } else {
+                1.0
+            },
+            #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
+            _padding: [0.0; 2],
+        };
+        pass.set_immediates(0, bytemuck::bytes_of(&push));
+        RenderCommandResult::Success
+    }
+}
+
+#[derive(Clone, Copy, ShaderType, Pod, Zeroable)]
+#[repr(C)]
+pub struct WireframeVertexPullParams {
+    pub index_offset: u32,
+    pub vertex_stride_u32s: u32,
+    pub position_offset_u32s: u32,
+}
+
+#[derive(Resource, Default)]
+pub struct WireframeWideBindGroups {
+    pub params: DynamicUniformBuffer<WireframeVertexPullParams>,
+    pub bind_groups: HashMap<AssetId<Mesh>, (BindGroup, u32)>,
+}
+
+pub fn prepare_wireframe_wide_bind_groups(
+    render_mesh_instances: Res<RenderMeshInstances>,
+    render_meshes: Res<RenderAssets<RenderMesh>>,
+    render_wireframe_instances: Res<RenderWireframeInstances>,
+    render_wireframe_assets: Res<RenderAssets<RenderWireframeMaterial>>,
+    mesh_allocator: Res<MeshAllocator>,
+    pipeline: Res<Wireframe3dPipeline>,
+    render_device: Res<RenderDevice>,
+    render_queue: Res<RenderQueue>,
+    mut wide_bind_groups: ResMut<WireframeWideBindGroups>,
+) {
+    wide_bind_groups.bind_groups.clear();
+
+    struct MeshInfo {
+        mesh_id: AssetId<Mesh>,
+        params: WireframeVertexPullParams,
+        vertex_buffer: Buffer,
+        index_buffer: Buffer,
+    }
+
+    let mut infos: Vec<MeshInfo> = Vec::new();
+    let mut seen: HashSet<AssetId<Mesh>, FixedHasher> = HashSet::default();
+
+    for (entity, wireframe_asset_id) in render_wireframe_instances.iter() {
+        let Some(material) = render_wireframe_assets.get(*wireframe_asset_id) else {
+            continue;
+        };
+        if material.line_width <= 1.0 && material.topology != WireframeTopology::Quads {
+            continue;
+        }
+
+        let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(*entity) else {
+            continue;
+        };
+        let mesh_id = mesh_instance.mesh_asset_id;
+        if !seen.insert(mesh_id) {
+            continue;
+        }
+
+        let Some(mesh) = render_meshes.get(mesh_id) else {
+            continue;
+        };
+        let Some(vertex_slice) = mesh_allocator.mesh_vertex_slice(&mesh_id) else {
+            continue;
+        };
+        let Some(index_slice) = mesh_allocator.mesh_index_slice(&mesh_id) else {
+            continue;
+        };
+
+        let vertex_stride_bytes = mesh.layout.0.layout().array_stride as u32;
+        let position_offset_bytes = mesh
+            .layout
+            .0
+            .layout()
+            .attributes
+            .first()
+            .map(|a| a.offset as u32)
+            .unwrap_or(0);
+
+        infos.push(MeshInfo {
+            mesh_id,
+            params: WireframeVertexPullParams {
+                index_offset: index_slice.range.start,
+                vertex_stride_u32s: vertex_stride_bytes / 4,
+                position_offset_u32s: position_offset_bytes / 4,
+            },
+            vertex_buffer: vertex_slice.buffer.clone(),
+            index_buffer: index_slice.buffer.clone(),
+        });
+    }
+
+    if infos.is_empty() {
+        return;
+    }
+
+    let Some(mut writer) =
+        wide_bind_groups
+            .params
+            .get_writer(infos.len(), &render_device, &render_queue)
+    else {
+        return;
+    };
+
+    let offsets: Vec<u32> = infos
+        .iter()
+        .map(|info| writer.write(&info.params))
+        .collect();
+    drop(writer);
+
+    let WireframeWideBindGroups {
+        ref params,
+        ref mut bind_groups,
+    } = *wide_bind_groups;
+    let Some(params_binding) = params.binding() else {
+        return;
+    };
+
+    for (i, info) in infos.iter().enumerate() {
+        let bind_group = render_device.create_bind_group(
+            "wireframe_wide_bind_group",
+            &pipeline.wide_bind_group_layout,
+            &BindGroupEntries::sequential((
+                info.vertex_buffer.as_entire_buffer_binding(),
+                info.index_buffer.as_entire_buffer_binding(),
+                params_binding.clone(),
+            )),
+        );
+        bind_groups.insert(info.mesh_id, (bind_group, offsets[i]));
+    }
+}
+
+pub struct SetWireframe3dWideBindGroup;
+
+impl<P: PhaseItem> RenderCommand<P> for SetWireframe3dWideBindGroup {
+    type Param = (SRes<RenderMeshInstances>, SRes<WireframeWideBindGroups>);
+    type ViewQuery = ();
+    type ItemQuery = ();
+
+    #[inline]
+    fn render<'w>(
+        item: &P,
+        _view: (),
+        _item_query: Option<()>,
+        (render_mesh_instances, wide_bind_groups): SystemParamItem<'w, '_, Self::Param>,
+        pass: &mut TrackedRenderPass<'w>,
+    ) -> RenderCommandResult {
+        let Some(mesh_instance) = render_mesh_instances.render_mesh_queue_data(item.main_entity())
+        else {
+            return RenderCommandResult::Skip;
+        };
+        let Some((bind_group, dynamic_offset)) = wide_bind_groups
+            .into_inner()
+            .bind_groups
+            .get(&mesh_instance.mesh_asset_id)
+        else {
+            return RenderCommandResult::Skip;
+        };
+
+        pass.set_bind_group(3, bind_group, &[*dynamic_offset]);
+        RenderCommandResult::Success
+    }
+}
+
+pub struct DrawWireframeMeshPulled;
+
+impl<P: PhaseItem> RenderCommand<P> for DrawWireframeMeshPulled {
+    type Param = (
+        SRes<RenderMeshInstances>,
+        SRes<RenderAssets<RenderMesh>>,
+        SRes<MeshAllocator>,
+        SRes<IndirectParametersBuffers>,
+        SRes<PipelineCache>,
+        Option<SRes<PreprocessPipelines>>,
+        SRes<GpuPreprocessingSupport>,
+    );
+    type ViewQuery = Has<PreprocessBindGroups>;
+    type ItemQuery = ();
+
+    #[inline]
+    fn render<'w>(
+        item: &P,
+        has_preprocess_bind_group: ROQueryItem<Self::ViewQuery>,
+        _item_query: Option<()>,
+        (
+            render_mesh_instances,
+            render_meshes,
+            mesh_allocator,
+            indirect_parameters_buffers,
+            pipeline_cache,
+            preprocess_pipelines,
+            preprocessing_support,
+        ): SystemParamItem<'w, '_, Self::Param>,
+        pass: &mut TrackedRenderPass<'w>,
+    ) -> RenderCommandResult {
+        if let Some(preprocess_pipelines) = preprocess_pipelines
+            && (!has_preprocess_bind_group
+                || !preprocess_pipelines
+                    .pipelines_are_loaded(&pipeline_cache, &preprocessing_support))
+        {
+            return RenderCommandResult::Skip;
+        }
+
+        let render_mesh_instances = render_mesh_instances.into_inner();
+        let render_meshes = render_meshes.into_inner();
+        let mesh_allocator = mesh_allocator.into_inner();
+        let indirect_parameters_buffers = indirect_parameters_buffers.into_inner();
+
+        let Some(mesh_asset_id) = render_mesh_instances.mesh_asset_id(item.main_entity()) else {
+            return RenderCommandResult::Skip;
+        };
+        let Some(gpu_mesh) = render_meshes.get(mesh_asset_id) else {
+            return RenderCommandResult::Skip;
+        };
+
+        let index_count = match &gpu_mesh.buffer_info {
+            RenderMeshBufferInfo::Indexed { count, .. } => *count,
+            RenderMeshBufferInfo::NonIndexed => gpu_mesh.vertex_count,
+        };
+
+        match item.extra_index() {
+            PhaseItemExtraIndex::None | PhaseItemExtraIndex::DynamicOffset(_) => {
+                // direct draw: use vertex range starting at first_vertex_index so
+                // the shader can recover draw_id via mesh[instance_index].first_vertex_index.
+                let Some(vertex_slice) = mesh_allocator.mesh_vertex_slice(&mesh_asset_id) else {
+                    return RenderCommandResult::Skip;
+                };
+                let first_vertex = vertex_slice.range.start;
+                pass.draw(
+                    first_vertex..(first_vertex + index_count),
+                    item.batch_range().clone(),
+                );
+            }
+            PhaseItemExtraIndex::IndirectParametersIndex {
+                range: indirect_parameters_range,
+                batch_set_index,
+            } => {
+                // no indexes - the preprocessor sets base_vertex = first_vertex_index.
+                let Some(phase_indirect) = indirect_parameters_buffers.get(&TypeId::of::<P>())
+                else {
+                    warn!("Wireframe wide: indirect parameters buffer missing for phase");
+                    return RenderCommandResult::Skip;
+                };
+                let (Some(indirect_buffer), Some(batch_sets_buffer)) = (
+                    phase_indirect.non_indexed.data_buffer(),
+                    phase_indirect.non_indexed.batch_sets_buffer(),
+                ) else {
+                    warn!("Wireframe wide: non-indexed indirect parameters buffer not ready");
+                    return RenderCommandResult::Skip;
+                };
+
+                let indirect_parameters_offset = indirect_parameters_range.start as u64
+                    * size_of::<IndirectParametersNonIndexed>() as u64;
+                let indirect_parameters_count =
+                    indirect_parameters_range.end - indirect_parameters_range.start;
+
+                match batch_set_index {
+                    Some(batch_set_index) => {
+                        let count_offset =
+                            u32::from(batch_set_index) * (size_of::<IndirectBatchSet>() as u32);
+                        pass.multi_draw_indirect_count(
+                            indirect_buffer,
+                            indirect_parameters_offset,
+                            batch_sets_buffer,
+                            count_offset as u64,
+                            indirect_parameters_count,
+                        );
+                    }
+                    None => {
+                        pass.multi_draw_indirect(
+                            indirect_buffer,
+                            indirect_parameters_offset,
+                            indirect_parameters_count,
+                        );
+                    }
+                }
+            }
+        }
+        RenderCommandResult::Success
+    }
+}
+
+/// Draw wireframes with `PolygonMode::Line`, i.e. the fast path.
+pub type DrawWireframe3dThin = (
     SetItemPipeline,
     SetMeshViewBindGroup<0>,
     SetMeshViewBindingArrayBindGroup<1>,
     SetMeshBindGroup<2>,
-    SetWireframe3dImmediates,
+    SetWireframe3dThinImmediates,
     DrawMesh,
 );
 
+/// Draw wireframes using vertex pulling for wide lines or quad topology.
+pub type DrawWireframe3dWide = (
+    SetItemPipeline,
+    SetMeshViewBindGroup<0>,
+    SetMeshViewBindingArrayBindGroup<1>,
+    SetMeshBindGroup<2>,
+    SetWireframe3dWideBindGroup,
+    SetWireframe3dWideImmediates,
+    DrawWireframeMeshPulled,
+);
+
 #[derive(Resource, Clone)]
 pub struct Wireframe3dPipeline {
     mesh_pipeline: MeshPipeline,
     shader: Handle<Shader>,
+    pub wide_bind_group_layout: BindGroupLayout,
+    pub wide_bind_group_layout_descriptor: BindGroupLayoutDescriptor,
 }
 
 pub fn init_wireframe_3d_pipeline(
     mut commands: Commands,
     mesh_pipeline: Res<MeshPipeline>,
     asset_server: Res<AssetServer>,
+    render_device: Res<RenderDevice>,
 ) {
+    let wide_bgl_entries = BindGroupLayoutEntries::sequential(
+        ShaderStages::VERTEX,
+        (
+            storage_buffer_read_only::<u32>(false), // vertex data
+            storage_buffer_read_only::<u32>(false), // index data
+            uniform_buffer::<WireframeVertexPullParams>(true),
+        ),
+    );
+
+    let wide_bind_group_layout = render_device
+        .create_bind_group_layout("wireframe_wide_bind_group_layout", &wide_bgl_entries);
+
+    let wide_bind_group_layout_descriptor =
+        BindGroupLayoutDescriptor::new("wireframe_wide_bind_group_layout", &wide_bgl_entries);
+
     commands.insert_resource(Wireframe3dPipeline {
         mesh_pipeline: mesh_pipeline.clone(),
         shader: load_embedded_asset!(asset_server.as_ref(), "render/wireframe.wgsl"),
+        wide_bind_group_layout,
+        wide_bind_group_layout_descriptor,
     });
 }
 
+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
+pub struct WireframePipelineKey {
+    pub mesh_key: MeshPipelineKey,
+    pub wide: bool,
+    pub quads: bool,
+    pub line_mode: bool,
+}
+
 impl SpecializedMeshPipeline for Wireframe3dPipeline {
-    type Key = MeshPipelineKey;
+    type Key = WireframePipelineKey;
 
     fn specialize(
         &self,
         key: Self::Key,
         layout: &MeshVertexBufferLayoutRef,
     ) -> Result<RenderPipelineDescriptor, SpecializedMeshPipelineError> {
-        let mut descriptor = self.mesh_pipeline.specialize(key, layout)?;
-        descriptor.label = Some("wireframe_3d_pipeline".into());
-        descriptor.immediate_size = 16;
-        let fragment = descriptor.fragment.as_mut().unwrap();
-        fragment.shader = self.shader.clone();
-        descriptor.primitive.polygon_mode = PolygonMode::Line;
+        let mut descriptor = self.mesh_pipeline.specialize(key.mesh_key, layout)?;
         descriptor.depth_stencil.as_mut().unwrap().bias.slope_scale = 1.0;
+
+        if key.wide {
+            descriptor.label = Some("wireframe_3d_wide_pipeline".into());
+
+            descriptor.vertex.shader = self.shader.clone();
+            descriptor.vertex.shader_defs.push("WIREFRAME_WIDE".into());
+            if key.quads {
+                descriptor.vertex.shader_defs.push("WIREFRAME_QUADS".into());
+            }
+            descriptor.vertex.entry_point = Some("vertex".into());
+            descriptor.vertex.buffers = vec![]; // vertex pulling from storage
+
+            let fragment = descriptor.fragment.as_mut().unwrap();
+            fragment.shader = self.shader.clone();
+            fragment.shader_defs.push("WIREFRAME_WIDE".into());
+            fragment.entry_point = Some("fragment".into());
+
+            for state in fragment.targets.iter_mut().flatten() {
+                state.blend = Some(BlendState::ALPHA_BLENDING);
+            }
+
+            descriptor.primitive.polygon_mode = if key.line_mode {
+                PolygonMode::Line
+            } else {
+                PolygonMode::Fill
+            };
+            descriptor.immediate_size = 32; // color(16) + line_width(4) + smoothing(4) + pad(8)
+
+            descriptor
+                .layout
+                .push(self.wide_bind_group_layout_descriptor.clone());
+        } else {
+            descriptor.label = Some("wireframe_3d_pipeline".into());
+            descriptor.immediate_size = 16;
+            let fragment = descriptor.fragment.as_mut().unwrap();
+            fragment.shader = self.shader.clone();
+            descriptor.primitive.polygon_mode = PolygonMode::Line;
+        }
+
         Ok(descriptor)
     }
 }
@@ -407,9 +834,19 @@ pub struct WireframeColor {
     pub color: Color,
 }
 
-#[derive(Component, Debug, Clone, Default)]
-pub struct ExtractedWireframeColor {
-    pub color: [f32; 4],
+/// Sets the line width (in screen-space pixels) of the wireframe.
+///
+/// Overrides [`WireframeConfig::default_line_width`].
+#[derive(Component, Debug, Clone, Reflect)]
+#[reflect(Component, Default, Debug)]
+pub struct WireframeLineWidth {
+    pub width: f32,
+}
+
+impl Default for WireframeLineWidth {
+    fn default() -> Self {
+        Self { width: 1.0 }
+    }
 }
 
 /// Disables wireframe rendering for any entity it is attached to.
@@ -420,7 +857,18 @@ pub struct ExtractedWireframeColor {
 #[reflect(Component, Default, Debug, PartialEq)]
 pub struct NoWireframe;
 
-#[derive(Resource, Debug, Clone, Default, ExtractResource, Reflect)]
+/// Controls whether wireframe edges follow triangle or quad topology.
+#[derive(Component, Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Reflect)]
+#[reflect(Component, Default, Debug)]
+pub enum WireframeTopology {
+    #[default]
+    Triangles,
+    /// Does a best-effort attempt to detect quads from a triangle mesh. No guarantee of accuracy is made,
+    /// that is, there may be both false positives and false negatives in the rendered output.
+    Quads,
+}
+
+#[derive(Resource, Debug, Clone, ExtractResource, Reflect)]
 #[reflect(Resource, Debug, Default)]
 pub struct WireframeConfig {
     /// Whether to show wireframes for all meshes.
@@ -430,16 +878,45 @@ pub struct WireframeConfig {
     /// wireframes using this color. Otherwise, this will be the fallback color for any entity that has a [`Wireframe`],
     /// but no [`WireframeColor`].
     pub default_color: Color,
+    /// Default line width in screen-space pixels.
+    pub default_line_width: f32,
+    /// Default edge topology.
+    pub default_topology: WireframeTopology,
+}
+
+impl Default for WireframeConfig {
+    fn default() -> Self {
+        Self {
+            global: false,
+            default_color: Color::default(),
+            default_line_width: 1.0,
+            default_topology: WireframeTopology::default(),
+        }
+    }
 }
 
-#[derive(Asset, Reflect, Clone, Debug, Default)]
+#[derive(Asset, Reflect, Clone, Debug)]
 #[reflect(Clone, Default)]
 pub struct WireframeMaterial {
     pub color: Color,
+    pub line_width: f32,
+    pub topology: WireframeTopology,
+}
+
+impl Default for WireframeMaterial {
+    fn default() -> Self {
+        Self {
+            color: Color::default(),
+            line_width: 1.0,
+            topology: WireframeTopology::default(),
+        }
+    }
 }
 
 pub struct RenderWireframeMaterial {
     pub color: [f32; 4],
+    pub line_width: f32,
+    pub topology: WireframeTopology,
 }
 
 #[derive(Component, Clone, Debug, Default, Deref, DerefMut, Reflect, PartialEq, Eq)]
@@ -466,6 +943,8 @@ impl RenderAsset for RenderWireframeMaterial {
     ) -> Result<Self, PrepareAssetError<Self::SourceAsset>> {
         Ok(RenderWireframeMaterial {
             color: source_asset.color.to_linear().to_f32_array(),
+            line_width: source_asset.line_width,
+            topology: source_asset.topology,
         })
     }
 }
@@ -484,16 +963,12 @@ pub struct WireframeEntitySpecializationTicks {
     pub entities: MainEntityHashMap<Tick>,
 }
 
-/// Stores the [`SpecializedWireframeViewPipelineCache`] for each view.
-#[derive(Resource, Deref, DerefMut, Default)]
+#[derive(Resource, Default)]
 pub struct SpecializedWireframePipelineCache {
-    // view entity -> view pipeline cache
-    #[deref]
-    map: HashMap<RetainedViewEntity, SpecializedWireframeViewPipelineCache>,
+    views: HashMap<RetainedViewEntity, SpecializedWireframeViewPipelineCache>,
+    wide: HashMap<(MeshPipelineKey, MeshVertexBufferLayoutRef, bool, bool), CachedRenderPipelineId>,
 }
 
-/// Stores the cached render pipeline ID for each entity in a single view, as
-/// well as the last time it was changed.
 #[derive(Deref, DerefMut, Default)]
 pub struct SpecializedWireframeViewPipelineCache {
     // material entity -> (tick, pipeline_id)
@@ -544,36 +1019,115 @@ fn setup_global_wireframe_material(
     mut materials: ResMut<Assets<WireframeMaterial>>,
     config: Res<WireframeConfig>,
 ) {
-    // Create the handle used for the global material
     commands.insert_resource(GlobalWireframeMaterial {
         handle: materials.add(WireframeMaterial {
             color: config.default_color,
+            line_width: config.default_line_width,
+            topology: config.default_topology,
         }),
     });
 }
 
-/// Updates the wireframe material of all entities without a [`WireframeColor`] or without a [`Wireframe`] component
-fn global_color_changed(
+fn wireframe_config_changed(
     config: Res<WireframeConfig>,
     mut materials: ResMut<Assets<WireframeMaterial>>,
     global_material: Res<GlobalWireframeMaterial>,
+    mut per_entity_wireframes: Query<
+        (
+            &mut Mesh3dWireframe,
+            Option<&WireframeColor>,
+            Option<&WireframeLineWidth>,
+            Option<&WireframeTopology>,
+        ),
+        With<Wireframe>,
+    >,
 ) {
-    if let Some(mut global_material) = materials.get_mut(&global_material.handle) {
-        global_material.color = config.default_color;
+    if let Some(mut mat) = materials.get_mut(&global_material.handle) {
+        mat.color = config.default_color;
+        mat.line_width = config.default_line_width;
+        mat.topology = config.default_topology;
+    }
+
+    for (mut handle, maybe_color, maybe_width, maybe_topology) in &mut per_entity_wireframes {
+        if handle.0 == global_material.handle {
+            continue;
+        }
+        handle.0 = materials.add(WireframeMaterial {
+            color: maybe_color.map(|c| c.color).unwrap_or(config.default_color),
+            line_width: maybe_width
+                .map(|w| w.width)
+                .unwrap_or(config.default_line_width),
+            topology: maybe_topology.copied().unwrap_or(config.default_topology),
+        });
     }
 }
 
-/// Updates the wireframe material when the color in [`WireframeColor`] changes
 fn wireframe_color_changed(
     mut materials: ResMut<Assets<WireframeMaterial>>,
     mut colors_changed: Query<
-        (&mut Mesh3dWireframe, &WireframeColor),
+        (
+            &mut Mesh3dWireframe,
+            &WireframeColor,
+            Option<&WireframeLineWidth>,
+            Option<&WireframeTopology>,
+        ),
         (With<Wireframe>, Changed<WireframeColor>),
     >,
+    config: Res<WireframeConfig>,
 ) {
-    for (mut handle, wireframe_color) in &mut colors_changed {
+    for (mut handle, wireframe_color, maybe_width, maybe_topology) in &mut colors_changed {
         handle.0 = materials.add(WireframeMaterial {
             color: wireframe_color.color,
+            line_width: maybe_width
+                .map(|w| w.width)
+                .unwrap_or(config.default_line_width),
+            topology: maybe_topology.copied().unwrap_or(config.default_topology),
+        });
+    }
+}
+
+fn wireframe_line_width_changed(
+    mut materials: ResMut<Assets<WireframeMaterial>>,
+    mut widths_changed: Query<
+        (
+            &mut Mesh3dWireframe,
+            &WireframeLineWidth,
+            Option<&WireframeColor>,
+            Option<&WireframeTopology>,
+        ),
+        (With<Wireframe>, Changed<WireframeLineWidth>),
+    >,
+    config: Res<WireframeConfig>,
+) {
+    for (mut handle, wireframe_width, maybe_color, maybe_topology) in &mut widths_changed {
+        handle.0 = materials.add(WireframeMaterial {
+            color: maybe_color.map(|c| c.color).unwrap_or(config.default_color),
+            line_width: wireframe_width.width,
+            topology: maybe_topology.copied().unwrap_or(config.default_topology),
+        });
+    }
+}
+
+fn wireframe_topology_changed(
+    mut materials: ResMut<Assets<WireframeMaterial>>,
+    mut topology_changed: Query<
+        (
+            &mut Mesh3dWireframe,
+            &WireframeTopology,
+            Option<&WireframeColor>,
+            Option<&WireframeLineWidth>,
+        ),
+        (With<Wireframe>, Changed<WireframeTopology>),
+    >,
+    config: Res<WireframeConfig>,
+) {
+    for (mut handle, topology, maybe_color, maybe_width) in &mut topology_changed {
+        handle.0 = materials.add(WireframeMaterial {
+            color: maybe_color.map(|c| c.color).unwrap_or(config.default_color),
+            line_width: maybe_width
+                .map(|w| w.width)
+                .unwrap_or(config.default_line_width),
+            topology: *topology,
         });
     }
 }
@@ -584,12 +1138,18 @@ fn apply_wireframe_material(
     mut commands: Commands,
     mut materials: ResMut<Assets<WireframeMaterial>>,
     wireframes: Query<
-        (Entity, Option<&WireframeColor>),
+        (
+            Entity,
+            Option<&WireframeColor>,
+            Option<&WireframeLineWidth>,
+            Option<&WireframeTopology>,
+        ),
         (With<Wireframe>, Without<Mesh3dWireframe>),
     >,
     no_wireframes: Query<Entity, (With<NoWireframe>, With<Mesh3dWireframe>)>,
     mut removed_wireframes: RemovedComponents<Wireframe>,
     global_material: Res<GlobalWireframeMaterial>,
+    config: Res<WireframeConfig>,
 ) {
     for e in removed_wireframes.read().chain(no_wireframes.iter()) {
         if let Ok(mut commands) = commands.get_entity(e) {
@@ -598,8 +1158,15 @@ fn apply_wireframe_material(
     }
 
     let mut material_to_spawn = vec![];
-    for (e, maybe_color) in &wireframes {
-        let material = get_wireframe_material(maybe_color, &mut materials, &global_material);
+    for (e, maybe_color, maybe_width, maybe_topology) in &wireframes {
+        let material = get_wireframe_material(
+            maybe_color,
+            maybe_width,
+            maybe_topology,
+            &mut materials,
+            &global_material,
+            &config,
+        );
         material_to_spawn.push((e, Mesh3dWireframe(material)));
     }
     commands.try_insert_batch(material_to_spawn);
@@ -612,7 +1179,12 @@ fn apply_global_wireframe_material(
     mut commands: Commands,
     config: Res<WireframeConfig>,
     meshes_without_material: Query<
-        (Entity, Option<&WireframeColor>),
+        (
+            Entity,
+            Option<&WireframeColor>,
+            Option<&WireframeLineWidth>,
+            Option<&WireframeTopology>,
+        ),
         (WireframeFilter, Without<Mesh3dWireframe>),
     >,
     meshes_with_global_material: Query<Entity, (WireframeFilter, With<Mesh3dWireframe>)>,
@@ -621,8 +1193,15 @@ fn apply_global_wireframe_material(
 ) {
     if config.global {
         let mut material_to_spawn = vec![];
-        for (e, maybe_color) in &meshes_without_material {
-            let material = get_wireframe_material(maybe_color, &mut materials, &global_material);
+        for (e, maybe_color, maybe_width, maybe_topology) in &meshes_without_material {
+            let material = get_wireframe_material(
+                maybe_color,
+                maybe_width,
+                maybe_topology,
+                &mut materials,
+                &global_material,
+                &config,
+            );
             // We only add the material handle but not the Wireframe component
             // This makes it easy to detect which mesh is using the global material and which ones are user specified
             material_to_spawn.push((e, Mesh3dWireframe(material)));
@@ -638,12 +1217,19 @@ fn apply_global_wireframe_material(
 /// Gets a handle to a wireframe material with a fallback on the default material
 fn get_wireframe_material(
     maybe_color: Option<&WireframeColor>,
+    maybe_width: Option<&WireframeLineWidth>,
+    maybe_topology: Option<&WireframeTopology>,
     wireframe_materials: &mut Assets<WireframeMaterial>,
     global_material: &GlobalWireframeMaterial,
+    config: &WireframeConfig,
 ) -> Handle<WireframeMaterial> {
-    if let Some(wireframe_color) = maybe_color {
+    if maybe_color.is_some() || maybe_width.is_some() || maybe_topology.is_some() {
         wireframe_materials.add(WireframeMaterial {
-            color: wireframe_color.color,
+            color: maybe_color.map(|c| c.color).unwrap_or(config.default_color),
+            line_width: maybe_width
+                .map(|w| w.width)
+                .unwrap_or(config.default_line_width),
+            topology: maybe_topology.copied().unwrap_or(config.default_topology),
         })
     } else {
         // If there's no color specified we can use the global material since it's already set to use the default_color
@@ -692,10 +1278,11 @@ pub fn extract_wireframe_entities_needing_specialization(
 
     for entity in removed_meshes_query.read() {
         for view in &views {
-            if let Some(specialized_wireframe_pipeline_cache) =
-                specialized_wireframe_pipeline_cache.get_mut(&view.retained_view_entity)
+            if let Some(view_cache) = specialized_wireframe_pipeline_cache
+                .views
+                .get_mut(&view.retained_view_entity)
             {
-                specialized_wireframe_pipeline_cache.remove(&MainEntity::from(entity));
+                view_cache.remove(&MainEntity::from(entity));
             }
         }
     }
@@ -709,6 +1296,8 @@ pub fn check_wireframe_entities_needing_specialization(
             AssetChanged<Mesh3d>,
             Changed<Mesh3dWireframe>,
             AssetChanged<Mesh3dWireframe>,
+            Changed<WireframeLineWidth>,
+            Changed<WireframeTopology>,
         )>,
     >,
     mut entities_needing_specialization: ResMut<WireframeEntitiesNeedingSpecialization>,
@@ -723,6 +1312,7 @@ pub fn specialize_wireframes(
     render_meshes: Res<RenderAssets<RenderMesh>>,
     render_mesh_instances: Res<RenderMeshInstances>,
     render_wireframe_instances: Res<RenderWireframeInstances>,
+    render_wireframe_assets: Res<RenderAssets<RenderWireframeMaterial>>,
     render_visibility_ranges: Res<RenderVisibilityRanges>,
     wireframe_phases: Res<ViewBinnedRenderPhases<Wireframe3d>>,
     views: Query<(&ExtractedView, &RenderVisibleEntities)>,
@@ -736,10 +1326,13 @@ pub fn specialize_wireframes(
     render_lightmaps: Res<RenderLightmaps>,
     ticks: SystemChangeTick,
 ) {
-    // Record the retained IDs of all views so that we can expire old
-    // pipeline IDs.
     let mut all_views: HashSet<RetainedViewEntity, FixedHasher> = HashSet::default();
 
+    let SpecializedWireframePipelineCache {
+        views: ref mut views_pipeline_cache,
+        wide: ref mut wide_pipeline_cache,
+    } = *specialized_material_pipeline_cache;
+
     for (view, visible_entities) in &views {
         all_views.insert(view.retained_view_entity);
 
@@ -754,7 +1347,7 @@ pub fn specialize_wireframes(
         let view_tick = view_specialization_ticks
             .get(&view.retained_view_entity)
             .unwrap();
-        let view_specialized_material_pipeline_cache = specialized_material_pipeline_cache
+        let view_specialized_material_pipeline_cache = views_pipeline_cache
             .entry(view.retained_view_entity)
             .or_default();
 
@@ -816,24 +1409,60 @@ pub fn specialize_wireframes(
                 mesh_key |= MeshPipelineKey::LIGHTMAPPED;
             }
 
-            let pipeline_id =
-                pipelines.specialize(&pipeline_cache, &pipeline, mesh_key, &mesh.layout);
-            let pipeline_id = match pipeline_id {
-                Ok(id) => id,
-                Err(err) => {
-                    error!("{}", err);
-                    continue;
+            let mat = render_wireframe_instances
+                .get(visible_entity)
+                .and_then(|asset_id| render_wireframe_assets.get(*asset_id));
+            let quads = mat
+                .map(|m| m.topology == WireframeTopology::Quads)
+                .unwrap_or(false);
+            let thick = mat.map(|m| m.line_width > 1.0).unwrap_or(false);
+            let wide = thick || quads;
+            let line_mode = wide && !thick;
+
+            let pipeline_id = if wide {
+                let cache_key = (mesh_key, mesh.layout.clone(), quads, line_mode);
+                *wide_pipeline_cache.entry(cache_key).or_insert_with(|| {
+                    let wireframe_key = WireframePipelineKey {
+                        mesh_key,
+                        wide: true,
+                        quads,
+                        line_mode,
+                    };
+                    match pipeline.specialize(wireframe_key, &mesh.layout) {
+                        Ok(descriptor) => pipeline_cache.queue_render_pipeline(descriptor),
+                        Err(err) => {
+                            error!("{}", err);
+                            CachedRenderPipelineId::INVALID
+                        }
+                    }
+                })
+            } else {
+                let wireframe_key = WireframePipelineKey {
+                    mesh_key,
+                    wide: false,
+                    quads: false,
+                    line_mode: false,
+                };
+                match pipelines.specialize(&pipeline_cache, &pipeline, wireframe_key, &mesh.layout)
+                {
+                    Ok(id) => id,
+                    Err(err) => {
+                        error!("{}", err);
+                        continue;
+                    }
                 }
             };
 
+            if pipeline_id == CachedRenderPipelineId::INVALID {
+                continue;
+            }
+
             view_specialized_material_pipeline_cache
                 .insert(*visible_entity, (ticks.this_run(), pipeline_id));
         }
     }
 
-    // Delete specialized pipelines belonging to views that have expired.
-    specialized_material_pipeline_cache
-        .retain(|retained_view_entity, _| all_views.contains(retained_view_entity));
+    views_pipeline_cache.retain(|retained_view_entity, _| all_views.contains(retained_view_entity));
 }
 
 fn queue_wireframes(
@@ -843,6 +1472,7 @@ fn queue_wireframes(
     mesh_allocator: Res<MeshAllocator>,
     specialized_wireframe_pipeline_cache: Res<SpecializedWireframePipelineCache>,
     render_wireframe_instances: Res<RenderWireframeInstances>,
+    render_wireframe_assets: Res<RenderAssets<RenderWireframeMaterial>>,
     mut wireframe_3d_phases: ResMut<ViewBinnedRenderPhases<Wireframe3d>>,
     mut views: Query<(&ExtractedView, &RenderVisibleEntities)>,
 ) {
@@ -850,10 +1480,13 @@ fn queue_wireframes(
         let Some(wireframe_phase) = wireframe_3d_phases.get_mut(&view.retained_view_entity) else {
             continue;
         };
-        let draw_wireframe = custom_draw_functions.read().id::<DrawWireframe3d>();
+        let draw_functions = custom_draw_functions.read();
+        let draw_thin = draw_functions.id::<DrawWireframe3dThin>();
+        let draw_wide = draw_functions.id::<DrawWireframe3dWide>();
 
-        let Some(view_specialized_material_pipeline_cache) =
-            specialized_wireframe_pipeline_cache.get(&view.retained_view_entity)
+        let Some(view_specialized_material_pipeline_cache) = specialized_wireframe_pipeline_cache
+            .views
+            .get(&view.retained_view_entity)
         else {
             continue;
         };
@@ -877,6 +1510,13 @@ fn queue_wireframes(
             else {
                 continue;
             };
+
+            let is_wide = render_wireframe_assets
+                .get(*wireframe_instance)
+                .map(|mat| mat.line_width > 1.0 || mat.topology == WireframeTopology::Quads)
+                .unwrap_or(false);
+            let draw_function = if is_wide { draw_wide } else { draw_thin };
+
             let (vertex_slab, index_slab) = mesh_allocator.mesh_slabs(&mesh_instance.mesh_asset_id);
             let bin_key = Wireframe3dBinKey {
                 asset_id: mesh_instance.mesh_asset_id.untyped(),
@@ -884,9 +1524,17 @@ fn queue_wireframes(
             let batch_set_key = Wireframe3dBatchSetKey {
                 pipeline: pipeline_id,
                 asset_id: wireframe_instance.untyped(),
-                draw_function: draw_wireframe,
+                draw_function,
                 vertex_slab: vertex_slab.unwrap_or_default(),
-                index_slab,
+                // wide wireframes use non-indexed draws (vertex pulling from storage),
+                // so set index_slab to None to make the preprocessor emit
+                // IndirectParametersNonIndexed instead of IndirectParametersIndexed.
+                index_slab: if is_wide { None } else { index_slab },
+                mesh_asset_id: if is_wide {
+                    Some(mesh_instance.mesh_asset_id.untyped())
+                } else {
+                    None
+                },
             };
             wireframe_phase.add(
                 batch_set_key,
diff --git a/examples/3d/wireframe.rs b/examples/3d/wireframe.rs
index 63864fd3b409a..74376ab0b4c87 100644
--- a/examples/3d/wireframe.rs
+++ b/examples/3d/wireframe.rs
@@ -10,7 +10,10 @@
 
 use bevy::{
     color::palettes::css::*,
-    pbr::wireframe::{NoWireframe, Wireframe, WireframeColor, WireframeConfig, WireframePlugin},
+    pbr::wireframe::{
+        NoWireframe, Wireframe, WireframeColor, WireframeConfig, WireframeLineWidth,
+        WireframePlugin, WireframeTopology,
+    },
     prelude::*,
     render::{render_resource::WgpuFeatures, settings::WgpuSettings, RenderPlugin},
 };
@@ -39,12 +42,16 @@ fn main() {
             // Controls the default color of all wireframes. Used as the default color for global wireframes.
             // Can be changed per mesh using the `WireframeColor` component.
             default_color: WHITE.into(),
+            ..default()
         })
         .add_systems(Startup, setup)
         .add_systems(Update, update_colors)
         .run();
 }
 
+#[derive(Component)]
+struct ColorToggleCube;
+
 /// set up a simple 3D scene
 fn setup(
     mut commands: Commands,
@@ -55,24 +62,38 @@ fn setup(
     commands.spawn((
         Mesh3d(meshes.add(Cuboid::default())),
         MeshMaterial3d(materials.add(Color::from(RED))),
-        Transform::from_xyz(-1.0, 0.5, -1.0),
+        Transform::from_xyz(-1.5, 0.5, -1.5),
         NoWireframe,
     ));
     // Orange cube: Follows global wireframe setting
     commands.spawn((
         Mesh3d(meshes.add(Cuboid::default())),
         MeshMaterial3d(materials.add(Color::from(ORANGE))),
-        Transform::from_xyz(0.0, 0.5, 0.0),
+        Transform::from_xyz(-0.5, 0.5, -0.5),
     ));
-    // Green cube: Always renders a wireframe
+    // Green cube: Always renders a wireframe with custom color
     commands.spawn((
         Mesh3d(meshes.add(Cuboid::default())),
         MeshMaterial3d(materials.add(Color::from(LIME))),
-        Transform::from_xyz(1.0, 0.5, 1.0),
+        Transform::from_xyz(0.5, 0.5, 0.5),
         Wireframe,
         // This lets you configure the wireframe color of this entity.
         // If not set, this will use the color in `WireframeConfig`
         WireframeColor { color: LIME.into() },
+        ColorToggleCube,
+    ));
+
+    // Purple cube: wireframe with explicit Quads topology override
+    commands.spawn((
+        Mesh3d(meshes.add(Cuboid::default())),
+        MeshMaterial3d(materials.add(Color::from(PURPLE))),
+        Transform::from_xyz(1.5, 0.5, 1.5),
+        Wireframe,
+        WireframeColor {
+            color: YELLOW.into(),
+        },
+        WireframeLineWidth { width: 3.0 },
+        WireframeTopology::Quads,
     ));
 
     // plane
@@ -111,21 +132,30 @@ fn setup(
 fn update_colors(
     keyboard_input: Res<ButtonInput<KeyCode>>,
     mut config: ResMut<WireframeConfig>,
-    mut wireframe_colors: Query<&mut WireframeColor, With<Wireframe>>,
+    mut wireframe_colors: Query<&mut WireframeColor, With<ColorToggleCube>>,
+    mut wireframe_widths: Query<&mut WireframeLineWidth>,
     mut text: Single<&mut Text>,
 ) {
+    let current_width = wireframe_widths
+        .iter()
+        .next()
+        .map(|w| w.width)
+        .unwrap_or(1.0);
+
     text.0 = format!(
         "Controls
 ---------------
 Z - Toggle global
 X - Change global color
 C - Change color of the green cube wireframe
+V - Line width (current: {current_width:.1}px)
+B - Toggle topology (current: {:?})
 
 WireframeConfig
 -------------
 Global: {}
 Color: {:?}",
-        config.global, config.default_color,
+        config.default_topology, config.global, config.default_color,
     );
 
     // Toggle showing a wireframe on all meshes
@@ -152,4 +182,22 @@ Color: {:?}",
             };
         }
     }
+
+    if keyboard_input.just_pressed(KeyCode::KeyV) {
+        for mut width in &mut wireframe_widths {
+            width.width = match width.width as u32 {
+                0..=2 => 3.0,
+                3..=4 => 5.0,
+                5..=7 => 10.0,
+                _ => 2.0,
+            };
+        }
+    }
+
+    if keyboard_input.just_pressed(KeyCode::KeyB) {
+        config.default_topology = match config.default_topology {
+            WireframeTopology::Triangles => WireframeTopology::Quads,
+            WireframeTopology::Quads => WireframeTopology::Triangles,
+        };
+    }
 }
diff --git a/examples/large_scenes/bevy_city/src/main.rs b/examples/large_scenes/bevy_city/src/main.rs
index 81902e94c01eb..fb647dacac05b 100644
--- a/examples/large_scenes/bevy_city/src/main.rs
+++ b/examples/large_scenes/bevy_city/src/main.rs
@@ -64,6 +64,7 @@ fn main() {
         .insert_resource(WireframeConfig {
             global: false,
             default_color: WHITE.into(),
+            ..default()
         })
         .add_systems(
             Startup,
