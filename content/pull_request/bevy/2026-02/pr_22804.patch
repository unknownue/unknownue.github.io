diff --git a/crates/bevy_light/src/ambient_light.rs b/crates/bevy_light/src/ambient_light.rs
index d3c110efe3088..9462761801ea8 100644
--- a/crates/bevy_light/src/ambient_light.rs
+++ b/crates/bevy_light/src/ambient_light.rs
@@ -10,6 +10,7 @@ use bevy_reflect::prelude::*;
 #[reflect(Component, Debug, Default, Clone)]
 #[require(Camera)]
 pub struct AmbientLight {
+    /// The color of the ambient light.
     pub color: Color,
 
     /// A direct scale factor multiplied with `color` before being passed to the shader.
@@ -59,6 +60,7 @@ impl Default for AmbientLight {
 #[derive(Resource, Clone, Debug, Reflect)]
 #[reflect(Resource, Debug, Default, Clone)]
 pub struct GlobalAmbientLight {
+    /// The color of the ambient light.
     pub color: Color,
 
     /// A direct scale factor multiplied with `color` before being passed to the shader.
@@ -88,6 +90,7 @@ impl Default for GlobalAmbientLight {
 }
 
 impl GlobalAmbientLight {
+    /// Convenience constant for turning off global ambient light.
     pub const NONE: GlobalAmbientLight = GlobalAmbientLight {
         color: Color::WHITE,
         brightness: 0.0,
diff --git a/crates/bevy_light/src/atmosphere.rs b/crates/bevy_light/src/atmosphere.rs
index 754401ffd2a64..8425887800f3d 100644
--- a/crates/bevy_light/src/atmosphere.rs
+++ b/crates/bevy_light/src/atmosphere.rs
@@ -1,3 +1,5 @@
+//! Provides types to specify atmosphere lighting, scattering terms, etc.
+
 use alloc::{borrow::Cow, sync::Arc};
 use bevy_asset::{Asset, Handle};
 use bevy_camera::Hdr;
@@ -34,6 +36,7 @@ pub struct Atmosphere {
 }
 
 impl Atmosphere {
+    /// An atmosphere like that of earth; use this with a [`ScatteringMedium::earthlike`] handle.
     pub fn earthlike(medium: Handle<ScatteringMedium>) -> Self {
         const EARTH_BOTTOM_RADIUS: f32 = 6_360_000.0;
         const EARTH_TOP_RADIUS: f32 = 6_460_000.0;
@@ -100,8 +103,8 @@ impl Default for ScatteringMedium {
 }
 
 impl ScatteringMedium {
-    // Returns a scattering medium with a default label and the
-    // specified scattering terms.
+    /// Returns a scattering medium with a default label and the
+    /// specified scattering terms.
     pub fn new(
         falloff_resolution: u32,
         phase_resolution: u32,
@@ -115,7 +118,7 @@ impl ScatteringMedium {
         }
     }
 
-    // Consumes and returns this scattering medium with a new label.
+    /// Consumes and returns this scattering medium with a new label.
     pub fn with_label(self, label: impl Into<Cow<'static, str>>) -> Self {
         Self {
             label: Some(label.into()),
@@ -123,8 +126,8 @@ impl ScatteringMedium {
         }
     }
 
-    // Consumes and returns this scattering medium with each scattering terms'
-    // densities multiplied by `multiplier`.
+    /// Consumes and returns this scattering medium with each scattering terms'
+    /// densities multiplied by `multiplier`.
     pub fn with_density_multiplier(mut self, multiplier: f32) -> Self {
         self.terms.iter_mut().for_each(|term| {
             term.absorption *= multiplier;
@@ -282,6 +285,7 @@ impl Falloff {
         Self::Curve(Arc::new(curve))
     }
 
+    /// Evaluates the falloff function at the given coordinate.
     pub fn sample(&self, p: f32) -> f32 {
         match self {
             Falloff::Linear => p,
@@ -378,6 +382,7 @@ impl PhaseFunction {
         Self::Curve(Arc::new(curve))
     }
 
+    /// Samples the phase function at the given value in [-1, 1], output is in [0, 1].
     pub fn sample(&self, neg_l_dot_v: f32) -> f32 {
         const FRAC_4_PI: f32 = 0.25 / PI;
         const FRAC_3_16_PI: f32 = 0.1875 / PI;
diff --git a/crates/bevy_light/src/cascade.rs b/crates/bevy_light/src/cascade.rs
index cd2058d226719..e2c4e787cadfd 100644
--- a/crates/bevy_light/src/cascade.rs
+++ b/crates/bevy_light/src/cascade.rs
@@ -1,3 +1,5 @@
+//! Provides shadow cascade configuration and construction helpers.
+
 use bevy_camera::{Camera, Projection};
 use bevy_ecs::{entity::EntityHashMap, prelude::*};
 use bevy_math::{ops, Mat4, Vec3A, Vec4};
@@ -161,6 +163,7 @@ impl From<CascadeShadowConfigBuilder> for CascadeShadowConfig {
     }
 }
 
+/// A [`DirectionalLight`]'s per-view list of [`Cascade`]s.
 #[derive(Component, Clone, Debug, Default, Reflect)]
 #[reflect(Component, Debug, Default, Clone)]
 pub struct Cascades {
@@ -168,6 +171,11 @@ pub struct Cascades {
     pub cascades: EntityHashMap<Vec<Cascade>>,
 }
 
+/// A single cascade of a view's shadow map cascade. Several of these are
+/// used to cover most of the view to ensure most geometry gets shadows, with
+/// some overlap for blending at cascade transitions. Farther away cascades
+/// are larger and have a lower effective shadowmap texel per world unit
+/// resolution. All cascades have the same pixel dimensions however.
 #[derive(Clone, Debug, Default, Reflect)]
 #[reflect(Clone, Default)]
 pub struct Cascade {
@@ -183,15 +191,7 @@ pub struct Cascade {
     pub texel_size: f32,
 }
 
-pub fn clear_directional_light_cascades(mut lights: Query<(&DirectionalLight, &mut Cascades)>) {
-    for (directional_light, mut cascades) in lights.iter_mut() {
-        if !directional_light.shadow_maps_enabled {
-            continue;
-        }
-        cascades.cascades.clear();
-    }
-}
-
+/// Sets up [`Cascades`] for all shadow mapped [`DirectionalLight`]s.
 pub fn build_directional_light_cascades(
     directional_light_shadow_map: Res<DirectionalLightShadowMap>,
     views: Query<(Entity, &GlobalTransform, &Projection, &Camera)>,
@@ -217,18 +217,20 @@ pub fn build_directional_light_cascades(
         if !directional_light.shadow_maps_enabled {
             continue;
         }
+        cascades.cascades.clear();
 
         // It is very important to the numerical and thus visual stability of shadows that
-        // light_to_world has orthogonal upper-left 3x3 and zero translation.
+        // `world_from_light` has orthogonal upper-left 3x3 and zero translation.
         // Even though only the direction (i.e. rotation) of the light matters, we don't constrain
         // users to not change any other aspects of the transform - there's no guarantee
         // `transform.to_matrix()` will give us a matrix with our desired properties.
         // Instead, we directly create a good matrix from just the rotation.
         let world_from_light = Mat4::from_quat(transform.rotation());
-        let light_to_world_inverse = world_from_light.transpose();
+        // The transpose is the inverse for orthogonal matrices.
+        let light_from_world = world_from_light.transpose();
 
-        for (view_entity, projection, view_to_world) in views.iter().copied() {
-            let camera_to_light_view = light_to_world_inverse * view_to_world;
+        for (view_entity, projection, world_from_view) in views.iter().copied() {
+            let light_view_from_camera = light_from_world * world_from_view;
             let overlap_factor = 1.0 - cascades_config.overlap_proportion;
             let far_bounds = cascades_config.bounds.iter();
             let near_bounds = [cascades_config.minimum_distance]
@@ -243,7 +245,7 @@ pub fn build_directional_light_cascades(
                         corners,
                         directional_light_shadow_map.size as f32,
                         world_from_light,
-                        camera_to_light_view,
+                        light_view_from_camera,
                     )
                 })
                 .collect();
diff --git a/crates/bevy_light/src/cluster/assign.rs b/crates/bevy_light/src/cluster/assign.rs
index 4c65a02c9bbd6..c8b4fee438c07 100644
--- a/crates/bevy_light/src/cluster/assign.rs
+++ b/crates/bevy_light/src/cluster/assign.rs
@@ -123,7 +123,7 @@ impl ClusterableObjectType {
     }
 }
 
-/// This system runs in the main world.
+/// Clusters point lights, spot lights, light probes, and decals.
 ///
 /// NOTE: Run this before `update_point_light_frusta`!
 pub(crate) fn assign_objects_to_clusters(
@@ -134,7 +134,7 @@ pub(crate) fn assign_objects_to_clusters(
         &GlobalTransform,
         &Camera,
         &Frustum,
-        &ClusterConfig,
+        Option<&ClusterConfig>,
         &mut Clusters,
         Option<&RenderLayers>,
         Option<&mut VisibleClusterableObjects>,
@@ -312,6 +312,7 @@ pub(crate) fn assign_objects_to_clusters(
     {
         let view_layers = maybe_layers.unwrap_or_default();
         let clusters = clusters.into_inner();
+        let config = config.copied().unwrap_or_default();
 
         if matches!(config, ClusterConfig::None) {
             if visible_clusterable_objects.is_some() {
@@ -844,6 +845,8 @@ pub(crate) fn assign_objects_to_clusters(
     }
 }
 
+// TODO: this probably shouldn't return a Vec2 and should probably be named better.
+#[expect(missing_docs, reason = "TODO")]
 pub fn calculate_cluster_factors(
     near: f32,
     far: f32,
diff --git a/crates/bevy_light/src/cluster/mod.rs b/crates/bevy_light/src/cluster/mod.rs
index 582005909956c..7615548471a44 100644
--- a/crates/bevy_light/src/cluster/mod.rs
+++ b/crates/bevy_light/src/cluster/mod.rs
@@ -1,19 +1,11 @@
-//! Spatial clustering of objects, currently just point and spot lights.
+//! Spatial clustering of objects to accelerate rendering performance.
 
 use core::any::TypeId;
 
 use bevy_asset::Handle;
-use bevy_camera::{
-    visibility::{self, Visibility, VisibilityClass},
-    Camera, Camera3d,
-};
+use bevy_camera::visibility::{self, Visibility, VisibilityClass};
 use bevy_ecs::{
-    component::Component,
-    entity::Entity,
-    query::{With, Without},
-    reflect::ReflectComponent,
-    resource::Resource,
-    system::{Commands, Query},
+    component::Component, entity::Entity, reflect::ReflectComponent, resource::Resource,
 };
 use bevy_image::Image;
 use bevy_math::{AspectRatio, UVec2, UVec3, Vec3Swizzles as _};
@@ -39,7 +31,10 @@ mod test;
 // The z-slicing method mentioned in the aortiz article is originally from Tiago Sousa's Siggraph 2016 talk about Doom 2016:
 // http://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf
 
+/// Cluster configuration depends on rendering capabilities, these are exposed here.
+/// They are automatically set by `bevy_pbr`, but a custom renderer may configure these too.
 #[derive(Resource)]
+#[expect(missing_docs, reason = "self explanatory")]
 pub struct GlobalClusterSettings {
     pub supports_storage_buffers: bool,
     pub clustered_decals_are_usable: bool,
@@ -82,7 +77,9 @@ pub enum ClusterConfig {
     Single,
     /// Explicit `X`, `Y` and `Z` counts (may yield non-square `X/Y` clusters depending on the aspect ratio)
     XYZ {
+        /// The dimensions of the cluster grid.
         dimensions: UVec3,
+        /// How to distribute the `Z` slices spatially.
         z_config: ClusterZConfig,
         /// Specify if clusters should automatically resize in `X/Y` if there is a risk of exceeding
         /// the available cluster-object index limit
@@ -94,8 +91,11 @@ pub enum ClusterConfig {
     /// would reduce the number of lights per cluster by distributing more clusters in screen space
     /// `X/Y` which matches how lights are distributed in the scene.
     FixedZ {
+        /// The total number of clusters to distribute.
         total: u32,
+        /// The number of `Z` slices to distribute the clusters over.
         z_slices: u32,
+        /// How to distribute the `Z` slices spatially.
         z_config: ClusterZConfig,
         /// Specify if clusters should automatically resize in `X/Y` if there is a risk of exceeding
         /// the available clusterable object index limit
@@ -103,15 +103,17 @@ pub enum ClusterConfig {
     },
 }
 
+/// The cluster geometry generated by [`ClusterConfig`].
 #[derive(Component, Debug, Default)]
 pub struct Clusters {
-    /// Tile size
+    /// The dimensions of the rectangle the cluster occupies in screen-space, rounded up to the nearest pixel.
     pub tile_size: UVec2,
     /// Number of clusters in `X` / `Y` / `Z` in the view frustum
     pub dimensions: UVec3,
     /// Distance to the far plane of the first depth slice. The first depth slice is special
     /// and explicitly-configured to avoid having unnecessarily many slices close to the camera.
     pub near: f32,
+    /// Distance to the far plane of the last depth slice. This may change depending on [`ClusterZConfig`] used.
     pub far: f32,
     /// All objects within the cluster.
     pub clusterable_objects: Vec<ObjectsInCluster>,
@@ -364,24 +366,6 @@ impl Clusters {
     }
 }
 
-pub fn add_clusters(
-    mut commands: Commands,
-    cameras: Query<(Entity, Option<&ClusterConfig>, &Camera), (Without<Clusters>, With<Camera3d>)>,
-) {
-    for (entity, config, camera) in &cameras {
-        if !camera.is_active {
-            continue;
-        }
-
-        let config = config.copied().unwrap_or_default();
-        // actual settings here don't matter - they will be overwritten in
-        // `assign_objects_to_clusters``
-        commands
-            .entity(entity)
-            .insert((Clusters::default(), config));
-    }
-}
-
 impl ObjectsInCluster {
     /// Clears out all objects in this cluster in preparation for a new frame.
     pub fn clear(&mut self) {
@@ -462,11 +446,13 @@ impl VisibleClusterableObjects {
 }
 
 impl GlobalVisibleClusterableObjects {
+    /// Iterates over all the visible clusterable objects in an arbitrary order.
     #[inline]
     pub fn iter(&self) -> impl Iterator<Item = &Entity> {
         self.entities.iter()
     }
 
+    /// Checks whether the given entity is a visible clusterable object.
     #[inline]
     pub fn contains(&self, entity: Entity) -> bool {
         self.entities.contains(&entity)
diff --git a/crates/bevy_light/src/directional_light.rs b/crates/bevy_light/src/directional_light.rs
index dfa155144ee01..64bec6eb700cc 100644
--- a/crates/bevy_light/src/directional_light.rs
+++ b/crates/bevy_light/src/directional_light.rs
@@ -46,6 +46,8 @@ use super::{
 ///
 /// Source: [Wikipedia](https://en.wikipedia.org/wiki/Lux)
 ///
+/// Some of these are provided as constants in [`light_consts::lux`].
+///
 /// ## Shadows
 ///
 /// To enable shadows, set the `shadow_maps_enabled` property to `true`.
@@ -80,6 +82,7 @@ pub struct DirectionalLight {
     /// more-or-less the same way (depending on the angle of incidence). Lumens
     /// can only be specified for light sources which emit light from a specific
     /// area.
+    /// The default is [`light_consts::lux::AMBIENT_DAYLIGHT`] = 10,000.
     pub illuminance: f32,
 
     /// Whether this light casts shadows.
@@ -158,7 +161,9 @@ impl Default for DirectionalLight {
 }
 
 impl DirectionalLight {
+    /// The default value of [`DirectionalLight::shadow_depth_bias`].
     pub const DEFAULT_SHADOW_DEPTH_BIAS: f32 = 0.02;
+    /// The default value of [`DirectionalLight::shadow_normal_bias`].
     pub const DEFAULT_SHADOW_NORMAL_BIAS: f32 = 1.8;
 }
 
@@ -208,6 +213,7 @@ pub fn validate_shadow_map_size(mut shadow_map: ResMut<DirectionalLightShadowMap
     }
 }
 
+/// Updates the frusta for all visible shadow mapped [`DirectionalLight`]s.
 pub fn update_directional_light_frusta(
     mut views: Query<
         (
diff --git a/crates/bevy_light/src/lib.rs b/crates/bevy_light/src/lib.rs
index b86af42820d41..3486fce14038f 100644
--- a/crates/bevy_light/src/lib.rs
+++ b/crates/bevy_light/src/lib.rs
@@ -1,4 +1,6 @@
-#![expect(missing_docs, reason = "Not all docs are written yet, see #3492.")]
+//! Provides component types for lighting a bevy scene. This includes the usual
+//! directional, point, and spot lights, as well as light probes, atmosphere,
+//! other volumetrics, and shadow configuration.
 
 extern crate alloc;
 
@@ -11,7 +13,7 @@ use bevy_camera::{
         RenderLayers, ViewVisibility, VisibilityRange, VisibilitySystems, VisibleEntityRanges,
         VisibleMeshEntities,
     },
-    CameraUpdateSystems,
+    Camera3d, CameraUpdateSystems,
 };
 use bevy_ecs::{entity::EntityHashSet, prelude::*};
 #[cfg(feature = "bevy_gizmos")]
@@ -26,8 +28,7 @@ use core::ops::DerefMut;
 pub mod cluster;
 pub use cluster::ClusteredDecal;
 use cluster::{
-    add_clusters, assign::assign_objects_to_clusters, GlobalVisibleClusterableObjects,
-    VisibleClusterableObjects,
+    assign::assign_objects_to_clusters, GlobalVisibleClusterableObjects, VisibleClusterableObjects,
 };
 mod ambient_light;
 pub use ambient_light::{AmbientLight, GlobalAmbientLight};
@@ -44,7 +45,7 @@ pub use atmosphere::Atmosphere;
 mod volumetric;
 pub use volumetric::{FogVolume, VolumetricFog, VolumetricLight};
 pub mod cascade;
-use cascade::{build_directional_light_cascades, clear_directional_light_cascades};
+use cascade::build_directional_light_cascades;
 pub use cascade::{CascadeShadowConfig, CascadeShadowConfigBuilder, Cascades};
 mod point_light;
 pub use point_light::{
@@ -60,6 +61,7 @@ pub use directional_light::{
     update_directional_light_frusta, DirectionalLight, DirectionalLightShadowMap,
     DirectionalLightTexture, SunDisk,
 };
+/// Provides gizmo drawing for visualizing light positions.
 #[cfg(feature = "bevy_gizmos")]
 pub mod gizmos;
 
@@ -78,7 +80,9 @@ pub mod prelude {
     pub use crate::gizmos::{LightGizmoColor, LightGizmoConfigGroup, ShowLightGizmo};
 }
 
-use crate::{atmosphere::ScatteringMedium, directional_light::validate_shadow_map_size};
+use crate::{
+    atmosphere::ScatteringMedium, cluster::Clusters, directional_light::validate_shadow_map_size,
+};
 
 /// Constants for operating with the light units: lumens, and lux.
 pub mod light_consts {
@@ -94,11 +98,14 @@ pub mod light_consts {
     /// [visible light]: https://en.wikipedia.org/wiki/Visible_light
     /// [International System of Units]: https://en.wikipedia.org/wiki/International_System_of_Units
     pub mod lumens {
+        /// The conversion factor used to determine how many lumens a typical LED light of a given wattage produces.
         pub const LUMENS_PER_LED_WATTS: f32 = 90.0;
+        /// The conversion factor used to determine how many lumens a typical incandescent light of a given wattage produces.
         pub const LUMENS_PER_INCANDESCENT_WATTS: f32 = 13.8;
+        /// The conversion factor used to determine how many lumens a typical halogen light of a given wattage produces.
         pub const LUMENS_PER_HALOGEN_WATTS: f32 = 19.8;
         /// 1,000,000 lumens is a very large "cinema light" capable of registering brightly at Bevy's
-        /// default "very overcast day" exposure level. For "indoor lighting" with a lower exposure,
+        /// default [`bevy_camera::Exposure::BLENDER`] exposure level. For "indoor lighting" with a lower exposure,
         /// this would be way too bright.
         pub const VERY_LARGE_CINEMA_LIGHT: f32 = 1_000_000.0;
     }
@@ -133,6 +140,7 @@ pub mod light_consts {
         /// The amount of light (lux) on an overcast day; typical TV studio lighting
         pub const OVERCAST_DAY: f32 = 1000.;
         /// The amount of light (lux) from ambient daylight (not direct sunlight).
+        /// This is the default for [`DirectionalLight`](crate::DirectionalLight)s in Bevy.
         pub const AMBIENT_DAYLIGHT: f32 = 10_000.;
         /// The amount of light (lux) in full daylight (not direct sun).
         pub const FULL_DAYLIGHT: f32 = 20_000.;
@@ -143,6 +151,7 @@ pub mod light_consts {
     }
 }
 
+/// Sets up all the light visibility and clustering infrastructure needed for rendering lights.
 #[derive(Default)]
 pub struct LightPlugin;
 
@@ -153,11 +162,7 @@ impl Plugin for LightPlugin {
             .init_resource::<DirectionalLightShadowMap>()
             .init_resource::<PointLightShadowMap>()
             .init_asset::<ScatteringMedium>()
-            .configure_sets(
-                PostUpdate,
-                SimulationLightSystems::UpdateDirectionalLightCascades
-                    .ambiguous_with(SimulationLightSystems::UpdateDirectionalLightCascades),
-            )
+            .register_required_components::<Camera3d, Clusters>()
             .configure_sets(
                 PostUpdate,
                 SimulationLightSystems::CheckLightVisibility
@@ -168,18 +173,11 @@ impl Plugin for LightPlugin {
                 PostUpdate,
                 (
                     validate_shadow_map_size.before(build_directional_light_cascades),
-                    add_clusters
-                        .in_set(SimulationLightSystems::AddClusters)
-                        .after(CameraUpdateSystems),
                     assign_objects_to_clusters
                         .in_set(SimulationLightSystems::AssignLightsToClusters)
                         .after(TransformSystems::Propagate)
                         .after(VisibilitySystems::CheckVisibility)
                         .after(CameraUpdateSystems),
-                    clear_directional_light_cascades
-                        .in_set(SimulationLightSystems::UpdateDirectionalLightCascades)
-                        .after(TransformSystems::Propagate)
-                        .after(CameraUpdateSystems),
                     update_directional_light_frusta
                         .in_set(SimulationLightSystems::UpdateLightFrusta)
                         // This must run after CheckVisibility because it relies on `ViewVisibility`
@@ -221,7 +219,8 @@ impl Plugin for LightPlugin {
                         .before(VisibilitySystems::MarkNewlyHiddenEntitiesInvisible),
                     build_directional_light_cascades
                         .in_set(SimulationLightSystems::UpdateDirectionalLightCascades)
-                        .after(clear_directional_light_cascades),
+                        .after(TransformSystems::Propagate)
+                        .after(CameraUpdateSystems),
                 ),
             );
 
@@ -257,7 +256,7 @@ pub struct NotShadowReceiver;
 #[reflect(Component, Default, Debug)]
 pub struct TransmittedShadowReceiver;
 
-/// Add this component to a [`Camera3d`](bevy_camera::Camera3d)
+/// Add this component to a [`Camera3d`]
 /// to control how to anti-alias shadow edges.
 ///
 /// The different modes use different approaches to
@@ -296,12 +295,11 @@ pub enum ShadowFilteringMethod {
 /// System sets used to run light-related systems.
 #[derive(Debug, Hash, PartialEq, Eq, Clone, SystemSet)]
 pub enum SimulationLightSystems {
-    AddClusters,
+    /// After this set, all lights have been clustered.
     AssignLightsToClusters,
-    /// System order ambiguities between systems in this set are ignored:
-    /// each [`build_directional_light_cascades`] system is independent of the others,
-    /// and should operate on distinct sets of entities.
+    /// After this set, all directional light cascades are up to date.
     UpdateDirectionalLightCascades,
+    /// After this set, the frusta of shadow-casting point lights, spot lights, and directional lights are up to date.
     UpdateLightFrusta,
     /// System order ambiguities between systems in this set are ignored:
     /// the order of systems within this set is irrelevant, as the various visibility-checking systems
@@ -325,6 +323,7 @@ fn shrink_entities(visible_entities: &mut Vec<Entity>) {
     visible_entities.shrink_to(reserved);
 }
 
+/// Updates the visibility for [`DirectionalLight`]s so that shadow map rendering can work.
 pub fn check_dir_light_mesh_visibility(
     mut commands: Commands,
     mut directional_lights: Query<
@@ -489,6 +488,8 @@ pub fn check_dir_light_mesh_visibility(
     });
 }
 
+/// Updates the visibility for [`PointLight`]s and [`SpotLight`]s so that
+/// shadow map rendering can work.
 pub fn check_point_light_mesh_visibility(
     visible_point_lights: Query<&VisibleClusterableObjects>,
     mut point_lights: Query<(
diff --git a/crates/bevy_light/src/point_light.rs b/crates/bevy_light/src/point_light.rs
index 1470633c1a3fd..f667de569755a 100644
--- a/crates/bevy_light/src/point_light.rs
+++ b/crates/bevy_light/src/point_light.rs
@@ -148,8 +148,11 @@ impl Default for PointLight {
 }
 
 impl PointLight {
+    /// The default value of [`PointLight::shadow_depth_bias`].
     pub const DEFAULT_SHADOW_DEPTH_BIAS: f32 = 0.08;
+    /// The default value of [`PointLight::shadow_normal_bias`].
     pub const DEFAULT_SHADOW_NORMAL_BIAS: f32 = 0.6;
+    /// The default value of [`PointLight::shadow_map_near_z`].
     pub const DEFAULT_SHADOW_MAP_NEAR_Z: f32 = 0.1;
 }
 
@@ -190,6 +193,7 @@ impl Default for PointLightShadowMap {
 }
 
 // NOTE: Run this after assign_lights_to_clusters!
+/// Updates the frusta for all visible shadow mapped [`PointLight`]s.
 pub fn update_point_light_frusta(
     global_lights: Res<GlobalVisibleClusterableObjects>,
     mut views: Query<(Entity, &GlobalTransform, &PointLight, &mut CubemapFrusta)>,
diff --git a/crates/bevy_light/src/probe.rs b/crates/bevy_light/src/probe.rs
index 48bbd915fef47..50d9df8202a66 100644
--- a/crates/bevy_light/src/probe.rs
+++ b/crates/bevy_light/src/probe.rs
@@ -214,12 +214,13 @@ impl Default for EnvironmentMapLight {
 /// Adds a skybox to a 3D camera, based on a cubemap texture.
 ///
 /// Note that this component does not (currently) affect the scene's lighting.
-/// To do so, use `EnvironmentMapLight` alongside this component.
+/// To do so, use [`EnvironmentMapLight`] alongside this component.
 ///
 /// See also <https://en.wikipedia.org/wiki/Skybox_(video_games)>.
 #[derive(Component, Clone, Reflect)]
 #[reflect(Component, Default, Clone)]
 pub struct Skybox {
+    /// The cubemap to use.
     pub image: Handle<Image>,
     /// Scale factor applied to the skybox image.
     /// After applying this multiplier to the image samples, the resulting values should
diff --git a/crates/bevy_light/src/spot_light.rs b/crates/bevy_light/src/spot_light.rs
index e4f47532c00f5..1daffd03116e9 100644
--- a/crates/bevy_light/src/spot_light.rs
+++ b/crates/bevy_light/src/spot_light.rs
@@ -130,8 +130,11 @@ pub struct SpotLight {
 }
 
 impl SpotLight {
+    /// The default value of [`SpotLight::shadow_depth_bias`].
     pub const DEFAULT_SHADOW_DEPTH_BIAS: f32 = 0.02;
+    /// The default value of [`SpotLight::shadow_normal_bias`].
     pub const DEFAULT_SHADOW_NORMAL_BIAS: f32 = 1.8;
+    /// The default value of [`SpotLight::shadow_map_near_z`].
     pub const DEFAULT_SHADOW_MAP_NEAR_Z: f32 = 0.1;
 }
 
@@ -189,6 +192,7 @@ pub fn spot_light_world_from_view(transform: &GlobalTransform) -> Affine3A {
     Affine3A::from_mat3_translation(basis, transform.translation())
 }
 
+/// Creates the projection matrix that transforms the light's view space into the light's clip space.
 pub fn spot_light_clip_from_view(angle: f32, near_z: f32) -> Mat4 {
     // spot light projection FOV is 2x the angle from spot light center to outer edge
     Mat4::perspective_infinite_reverse_rh(angle * 2.0, 1.0, near_z)
@@ -206,6 +210,7 @@ pub struct SpotLightTexture {
     pub image: Handle<Image>,
 }
 
+/// Updates the frusta for all visible shadow mapped [`SpotLight`]s.
 pub fn update_spot_light_frusta(
     global_lights: Res<GlobalVisibleClusterableObjects>,
     mut views: Query<
diff --git a/crates/bevy_light/src/volumetric.rs b/crates/bevy_light/src/volumetric.rs
index 080617bfc9469..cde3f9d0310ba 100644
--- a/crates/bevy_light/src/volumetric.rs
+++ b/crates/bevy_light/src/volumetric.rs
@@ -70,6 +70,8 @@ impl Default for VolumetricFog {
     }
 }
 
+/// A unit cube of fog at the origin. Can be positioned and scaled with a [`Transform`].
+/// Only visible by cameras with a [`VolumetricFog`] component when lit by a directional light with [`VolumetricLight`].
 #[derive(Clone, Component, Debug, Reflect)]
 #[reflect(Component, Default, Debug, Clone)]
 #[require(Transform, Visibility)]
diff --git a/crates/bevy_pbr/src/lib.rs b/crates/bevy_pbr/src/lib.rs
index 0b51e43178d01..72a9623fb7504 100644
--- a/crates/bevy_pbr/src/lib.rs
+++ b/crates/bevy_pbr/src/lib.rs
@@ -55,10 +55,7 @@ mod volumetric_fog;
 use bevy_color::{Color, LinearRgba};
 
 pub use atmosphere::*;
-use bevy_light::{
-    AmbientLight, DirectionalLight, PointLight, ShadowFilteringMethod, SimulationLightSystems,
-    SpotLight,
-};
+use bevy_light::{AmbientLight, DirectionalLight, PointLight, ShadowFilteringMethod, SpotLight};
 use bevy_shader::{load_shader_library, ShaderRef};
 pub use cluster::*;
 pub use components::*;
@@ -220,15 +217,7 @@ impl Plugin for PbrPlugin {
                 SyncComponentPlugin::<SpotLight>::default(),
                 SyncComponentPlugin::<AmbientLight>::default(),
             ))
-            .add_plugins((ScatteringMediumPlugin, AtmospherePlugin))
-            .configure_sets(
-                PostUpdate,
-                (
-                    SimulationLightSystems::AddClusters,
-                    SimulationLightSystems::AssignLightsToClusters,
-                )
-                    .chain(),
-            );
+            .add_plugins((ScatteringMediumPlugin, AtmospherePlugin));
 
         if self.add_default_deferred_lighting_plugin {
             app.add_plugins(DeferredPbrLightingPlugin);
