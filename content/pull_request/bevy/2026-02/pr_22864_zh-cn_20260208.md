+++
title = "#22864"
date = "2026-02-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22864-en-20260208" }, "zh-cn" = { name = "ä¸­æ–‡", url = "/pull_request/bevy/2026-02/pr-22864-zh-cn-20260208" }}
+++

# Title
## åŸºæœ¬ä¿¡æ¯
- **Title**: Revive `iter_entities()` when you only have immutable `World` access â¤ï¸â€ğŸ©¹
- **PR Link**: https://github.com/bevyengine/bevy/pull/22864
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: C-Feature, A-ECS, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-02-08T05:58:24Z
- **Merged**: 2026-02-08T18:56:35Z
- **Merged By**: alice-i-cecile

## Description Translation
# ç›®æ ‡

- å…³é—­ #22657

## è§£å†³æ–¹æ¡ˆ

- é‡æ–°å¯ç”¨äº†ä¹‹å‰è¢«å¼ƒç”¨å’Œåˆ é™¤çš„åŠŸèƒ½ ğŸ§Ÿã€‚å½“åªæœ‰ä¸å¯å˜çš„ `World` è®¿é—®æƒé™æ—¶ï¼Œ`iter_entities()` ä½œä¸ºéå†æ‰€æœ‰å®ä½“çš„ç¬¦åˆäººä½“å·¥ç¨‹å­¦çš„æ–¹å¼é‡æ–°å›å½’ã€‚
- æˆ‘æ²¡æœ‰åœ¨ `Entities` ä¸Šå®ç° `iter_entities()`ï¼Œå› ä¸ºä» #6228 ä¸­çš„è®¨è®ºæ¥çœ‹ï¼Œè¿™ä¼¼ä¹æ˜¯æ•…æ„çš„â€¦â€¦ä½†å¦‚æœè®¨è®ºå·²ç»è¿‡æ—¶ï¼Œæˆ‘å¯èƒ½ä¼šè¢«è¯´æœè€Œæ”¹å˜ä¸»æ„ã€‚

## æµ‹è¯•

- æˆ‘æ¢å¤äº†ä¹‹å‰çš„ CI æµ‹è¯•

## The Story of This Pull Request

è¿™ä¸ª PR è§£å†³äº†ä¸€ä¸ªå…·ä½“çš„ä½¿ç”¨åœºæ™¯é—®é¢˜ï¼šå½“å¼€å‘è€…åªæœ‰å¯¹ `World` çš„ä¸å¯å˜å¼•ç”¨ï¼ˆ`&World`ï¼‰æ—¶ï¼Œå¦‚ä½•éå†æ‰€æœ‰å®ä½“ã€‚åœ¨ Bevy çš„ ECS ç³»ç»Ÿä¸­ï¼Œ`World` æ˜¯å®ä½“ã€ç»„ä»¶å’Œèµ„æºçš„ä¸­å¤®å­˜å‚¨ã€‚é€šå¸¸ï¼Œå½“æœ‰å¯å˜è®¿é—®æƒé™æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `World::query()` æ¥æŸ¥è¯¢å®ä½“ï¼Œä½† `query()` æ–¹æ³•éœ€è¦ `&mut self`ï¼Œè¿™åœ¨åªè¯»ä¸Šä¸‹æ–‡ä¸­ä¸å¯ç”¨ã€‚

é—®é¢˜ #22657 æŒ‡å‡ºäº†è¿™ä¸ªåŠŸèƒ½ç¼ºå¤±ï¼šä¹‹å‰å­˜åœ¨çš„ `iter_entities()` æ–¹æ³•è¢«åˆ é™¤äº†ï¼Œå¯¼è‡´åœ¨åªæœ‰ä¸å¯å˜ `World` è®¿é—®æƒé™æ—¶æ²¡æœ‰ç›´æ¥çš„æ–¹æ³•æ¥éå†æ‰€æœ‰å®ä½“ã€‚å¼€å‘è€…ä¸å¾—ä¸ä½¿ç”¨å˜é€šæ–¹æ³•ï¼Œæ¯”å¦‚é€šè¿‡ `Entities` èµ„æºï¼Œä½†è¿™ä¸å¤Ÿç›´è§‚ä¸”éœ€è¦é¢å¤–çš„æ­¥éª¤ã€‚

PR ä½œè€… kfc35 é‡‡å–äº†ç›´æ¥çš„æ–¹æ³•ï¼šæ¢å¤ `iter_entities()` æ–¹æ³•ï¼Œä½†å°†å…¶å®ç°ä¸ºåªè¯»ç‰ˆæœ¬ã€‚è¿™ä¸ªæ–¹æ³•è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œéå†ä¸–ç•Œä¸­çš„æ‰€æœ‰å®ä½“ï¼Œå¹¶ä¸ºæ¯ä¸ªå®ä½“è¿”å›ä¸€ä¸ª `EntityRef<'_>`ã€‚`EntityRef` æ˜¯å®ä½“çš„åªè¯»è§†å›¾ï¼Œå…è®¸è®¿é—®å…¶ç»„ä»¶ï¼Œä½†ä¸èƒ½ä¿®æ”¹å®ƒä»¬ã€‚

å®ç°çš„å…³é”®åœ¨äºå®‰å…¨åœ°åˆ›å»º `EntityRef`ã€‚ä»£ç ä½¿ç”¨ `UnsafeEntityCell` ä½œä¸ºä¸­é—´æ­¥éª¤ï¼Œè¿™æ˜¯ Bevy ECS å†…éƒ¨ç”¨äºå®‰å…¨æŠ½è±¡çš„ä½çº§ç»“æ„ã€‚é€šè¿‡æä¾›æ­£ç¡®çš„å®‰å…¨ä¿è¯ï¼ˆå®ä½“å­˜åœ¨ä¸”ä½ç½®ä¿¡æ¯å‡†ç¡®ï¼Œå¹¶ä¸”è°ƒç”¨è€…æœ‰ä¸–ç•Œçš„åªè¯»è®¿é—®æƒé™ï¼‰ï¼Œå¯ä»¥å®‰å…¨åœ°ä» `UnsafeEntityCell` åˆ›å»º `EntityRef`ã€‚

æ–¹æ³•å®ç°éå†æ‰€æœ‰åŸå‹ï¼ˆarchetypeï¼‰ï¼Œç„¶åéå†æ¯ä¸ªåŸå‹ä¸­çš„å®ä½“ã€‚å¯¹äºæ¯ä¸ªå®ä½“ï¼Œå®ƒä½¿ç”¨å®ä½“ ID å’Œä½ç½®ä¿¡æ¯åˆ›å»º `UnsafeEntityCell`ï¼Œç„¶åå°†å…¶è½¬æ¢ä¸º `EntityRef`ã€‚è¿™ç§æ–¹æ³•ç¡®ä¿äº†æ€§èƒ½ï¼Œå› ä¸ºå®ƒç›´æ¥éå†å†…éƒ¨æ•°æ®ç»“æ„ï¼Œæ²¡æœ‰é¢å¤–çš„åˆ†é…æˆ–å¤åˆ¶ã€‚

ä½œè€…è¿˜æ¢å¤äº†ä¹‹å‰å­˜åœ¨çš„æµ‹è¯•ç”¨ä¾‹ï¼ŒéªŒè¯äº†å„ç§åœºæ™¯ï¼šæ·»åŠ å®ä½“ã€åˆ é™¤å®ä½“ã€æ··åˆæ“ä½œç­‰ã€‚æµ‹è¯•ç¡®ä¿è¿­ä»£å™¨æ­£ç¡®éå†æ‰€æœ‰å­˜åœ¨çš„å®ä½“ï¼Œå¹¶ä¸”ä¸ä¼šåŒ…å«å·²åˆ é™¤çš„å®ä½“ã€‚

å…³äºè®¾è®¡å†³ç­–ï¼Œä½œè€…æåˆ°æ²¡æœ‰åœ¨ `Entities` ç±»å‹ä¸Šå®ç° `iter_entities()`ï¼Œå› ä¸ºä¹‹å‰çš„è®¨è®º (#6228) è¡¨æ˜è¿™æ˜¯æœ‰æ„çš„ã€‚è¿™è¡¨æ˜ä½œè€…åœ¨æ·»åŠ æ–°åŠŸèƒ½æ—¶è€ƒè™‘äº†ç°æœ‰çš„è®¾è®¡å†³ç­–å’Œæ¶æ„ä¸€è‡´æ€§ã€‚

ä»å·¥ç¨‹è§’åº¦çœ‹ï¼Œè¿™ä¸ª PR å±•ç¤ºäº†å¦‚ä½•åœ¨ä¸ç ´åç°æœ‰ API çš„æƒ…å†µä¸‹æ¢å¤æœ‰ç”¨çš„åŠŸèƒ½ã€‚å®ƒä¿æŒäº†å‘åå…¼å®¹æ€§ï¼ŒåŒæ—¶è§£å†³äº†å…·ä½“çš„ç”¨æˆ·ç—›ç‚¹ã€‚å®ç°ç®€æ´æ˜äº†ï¼Œåˆ©ç”¨äº†ç°æœ‰çš„å®‰å…¨æŠ½è±¡ï¼ˆ`UnsafeEntityCell` å’Œ `EntityRef`ï¼‰ï¼Œå¹¶ä¸”åŒ…å«äº†å…¨é¢çš„æµ‹è¯•ã€‚

è¿™ä¸ªæ›´æ”¹çš„å½±å“æ˜¯æ˜¾è‘—çš„ï¼šå®ƒæ¢å¤äº†åœ¨åªè¯»ä¸Šä¸‹æ–‡ä¸­éå†å®ä½“çš„ç›´è§‚æ–¹æ³•ï¼Œä½¿ Bevy ECS API æ›´åŠ å®Œæ•´å’Œç”¨æˆ·å‹å¥½ã€‚å®ƒä¸ä¼šå½±å“æ€§èƒ½ï¼Œå› ä¸ºå®ƒç›´æ¥æš´éœ²äº†å†…éƒ¨è¿­ä»£æœºåˆ¶ï¼Œå¹¶ä¸”ä¿æŒäº†ä¸ç°æœ‰ä»£ç çš„å…¼å®¹æ€§ã€‚

## Visual Representation

```mermaid
graph TD
    A[World::iter_entities()] --> B[éå†æ‰€æœ‰Archetypes]
    B --> C[éå†æ¯ä¸ªArchetypeä¸­çš„å®ä½“]
    C --> D[åˆ›å»ºUnsafeEntityCell]
    D --> E[è½¬æ¢ä¸ºEntityRef]
    E --> F[è¿”å›è¿­ä»£å™¨]
```

## Key Files Changed

### `crates/bevy_ecs/src/world/mod.rs` (+96/-2)

è¿™ä¸ªæ–‡ä»¶åŒ…å«äº† `World` ç±»å‹çš„å®šä¹‰å’Œç›¸å…³æ–¹æ³•ã€‚ä¸»è¦æ›´æ”¹æ˜¯æ·»åŠ äº† `iter_entities()` æ–¹æ³•ï¼Œå¹¶æ¢å¤äº†ç›¸åº”çš„æµ‹è¯•ã€‚

#### å…³é”®ä¿®æ”¹ï¼š

1. **æ·»åŠ  `iter_entities()` æ–¹æ³•**ï¼š
```rust
/// Returns an [`Entity`] iterator of current entities.
///
/// This is useful in contexts where you only have immutable access to the [`World`].
/// If you have mutable access to the [`World`], use
/// [`query()::<EntityRef>().iter(&world)`](World::query()) instead.
#[inline]
pub fn iter_entities(&self) -> impl Iterator<Item = EntityRef<'_>> + '_ {
    self.archetypes.iter().flat_map(|archetype| {
        archetype
            .entities_with_location()
            .map(|(entity, location)| {
                // SAFETY: entity exists and location accurately specifies the archetype where the entity is stored.
                let cell = UnsafeEntityCell::new(
                    self.as_unsafe_world_cell_readonly(),
                    entity,
                    location,
                    self.last_change_tick,
                    self.read_change_tick(),
                );
                // SAFETY: `&self` gives read access to the entire world.
                unsafe { EntityRef::new(cell) }
            })
    })
}
```

2. **æ·»åŠ æµ‹è¯•ç”¨ä¾‹**ï¼š
```rust
#[test]
fn iterate_entities() {
    let mut world = World::new();
    let mut entity_counters = <HashMap<_, _>>::default();

    let iterate_and_count_entities = |world: &World, entity_counters: &mut HashMap<_, _>| {
        entity_counters.clear();
        for entity in world.iter_entities() {
            let counter = entity_counters.entry(entity.id()).or_insert(0);
            *counter += 1;
        }
    };

    // æµ‹è¯•å„ç§åœºæ™¯ï¼šæ·»åŠ å®ä½“ã€åˆ é™¤å®ä½“ã€æ··åˆæ“ä½œ
    // ...
}
```

3. **å¯¼å…¥å¿…è¦çš„ç±»å‹**ï¼š
åœ¨æ–‡ä»¶é¡¶éƒ¨æ·»åŠ äº† `UnsafeEntityCell` çš„å¯¼å…¥ï¼š
```rust
use unsafe_world_cell::{UnsafeEntityCell, UnsafeWorldCell};
```

è¿™äº›æ›´æ”¹ç›´æ¥å…³è”åˆ° PR çš„ç›®æ ‡ï¼šæ¢å¤åœ¨ä¸å¯å˜ `World` è®¿é—®ä¸‹éå†å®ä½“çš„åŠŸèƒ½ã€‚æ–¹æ³•å®ç°é«˜æ•ˆä¸”å®‰å…¨ï¼Œæµ‹è¯•ç¡®ä¿äº†åŠŸèƒ½çš„æ­£ç¡®æ€§ã€‚

## Further Reading

1. **Bevy ECS æ–‡æ¡£**: https://bevyengine.org/learn/book/ecs/
2. **å®ä½“å’Œç»„ä»¶**: https://bevy-cheatbook.github.io/programming/entities-components.html
3. **æŸ¥è¯¢ç³»ç»Ÿ**: https://bevy-cheatbook.github.io/programming/queries.html
4. **UnsafeWorldCell å’Œ UnsafeEntityCell**: Bevy æºä»£ç ä¸­çš„ç›¸å…³æ–‡æ¡£å’Œå®ç°

# Full Code Diff
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index 20107fe2b693e..2019a99c21ad5 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -74,7 +74,7 @@ use bevy_ptr::{move_as_ptr, MovingPtr, OwningPtr, Ptr};
 use bevy_utils::prelude::DebugName;
 use core::{any::TypeId, fmt, mem::ManuallyDrop};
 use log::warn;
-use unsafe_world_cell::UnsafeWorldCell;
+use unsafe_world_cell::{UnsafeEntityCell, UnsafeWorldCell};
 
 /// Stores and exposes operations on [entities](Entity), [components](Component), resources,
 /// and their associated metadata.
@@ -984,6 +984,31 @@ impl World {
         unsafe { entities.fetch_mut(cell) }
     }
 
+    /// Returns an [`Entity`] iterator of current entities.
+    ///
+    /// This is useful in contexts where you only have immutable access to the [`World`].
+    /// If you have mutable access to the [`World`], use
+    /// [`query()::<EntityRef>().iter(&world)`](World::query()) instead.
+    #[inline]
+    pub fn iter_entities(&self) -> impl Iterator<Item = EntityRef<'_>> + '_ {
+        self.archetypes.iter().flat_map(|archetype| {
+            archetype
+                .entities_with_location()
+                .map(|(entity, location)| {
+                    // SAFETY: entity exists and location accurately specifies the archetype where the entity is stored.
+                    let cell = UnsafeEntityCell::new(
+                        self.as_unsafe_world_cell_readonly(),
+                        entity,
+                        location,
+                        self.last_change_tick,
+                        self.read_change_tick(),
+                    );
+                    // SAFETY: `&self` gives read access to the entire world.
+                    unsafe { EntityRef::new(cell) }
+                })
+        })
+    }
+
     /// Simultaneously provides access to entity data and a command queue, which
     /// will be applied when the world is next flushed.
     ///
@@ -3852,7 +3877,7 @@ mod tests {
         vec::Vec,
     };
     use bevy_ecs_macros::Component;
-    use bevy_platform::collections::HashSet;
+    use bevy_platform::collections::{HashMap, HashSet};
     use bevy_utils::prelude::DebugName;
     use core::{
         any::TypeId,
@@ -4266,6 +4291,75 @@ mod tests {
         );
     }
 
+    #[test]
+    fn iterate_entities() {
+        let mut world = World::new();
+        let mut entity_counters = <HashMap<_, _>>::default();
+
+        let iterate_and_count_entities = |world: &World, entity_counters: &mut HashMap<_, _>| {
+            entity_counters.clear();
+            for entity in world.iter_entities() {
+                let counter = entity_counters.entry(entity.id()).or_insert(0);
+                *counter += 1;
+            }
+        };
+
+        // Adding one entity and validating iteration
+        let ent0 = world.spawn((Foo, Bar, Baz)).id();
+
+        iterate_and_count_entities(&world, &mut entity_counters);
+        assert_eq!(entity_counters[&ent0], 1);
+        assert_eq!(entity_counters.len(), 1);
+
+        // Spawning three more entities and then validating iteration
+        let ent1 = world.spawn((Foo, Bar)).id();
+        let ent2 = world.spawn((Bar, Baz)).id();
+        let ent3 = world.spawn((Foo, Baz)).id();
+
+        iterate_and_count_entities(&world, &mut entity_counters);
+
+        assert_eq!(entity_counters[&ent0], 1);
+        assert_eq!(entity_counters[&ent1], 1);
+        assert_eq!(entity_counters[&ent2], 1);
+        assert_eq!(entity_counters[&ent3], 1);
+        assert_eq!(entity_counters.len(), 4);
+
+        // Despawning first entity and then validating the iteration
+        assert!(world.despawn(ent0));
+
+        iterate_and_count_entities(&world, &mut entity_counters);
+
+        assert_eq!(entity_counters[&ent1], 1);
+        assert_eq!(entity_counters[&ent2], 1);
+        assert_eq!(entity_counters[&ent3], 1);
+        assert_eq!(entity_counters.len(), 3);
+
+        // Spawning three more entities, despawning three and then validating the iteration
+        let ent4 = world.spawn(Foo).id();
+        let ent5 = world.spawn(Bar).id();
+        let ent6 = world.spawn(Baz).id();
+
+        assert!(world.despawn(ent2));
+        assert!(world.despawn(ent3));
+        assert!(world.despawn(ent4));
+
+        iterate_and_count_entities(&world, &mut entity_counters);
+
+        assert_eq!(entity_counters[&ent1], 1);
+        assert_eq!(entity_counters[&ent5], 1);
+        assert_eq!(entity_counters[&ent6], 1);
+        assert_eq!(entity_counters.len(), 3);
+
+        // Despawning remaining entities and then validating the iteration
+        assert!(world.despawn(ent1));
+        assert!(world.despawn(ent5));
+        assert!(world.despawn(ent6));
+
+        iterate_and_count_entities(&world, &mut entity_counters);
+
+        assert_eq!(entity_counters.len(), 0);
+    }
+
     #[test]
     fn spawn_empty_bundle() {
         let mut world = World::new();
```