+++
title = "#23091"
date = "2026-02-21T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23091-en-20260221" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23091-zh-cn-20260221" }}
+++

# Title

## 基本信息
- **Title**: Fix `DynamicTextureAtlasBuilder` incorrectly padding added textures.
- **PR链接**: https://github.com/bevyengine/bevy/pull/23091
- **作者**: andriyDev
- **状态**: 已合并
- **标签**: C-Bug, A-UI, S-Ready-For-Final-Review, D-Straightforward, M-Deliberate-Rendering-Change
- **创建时间**: 2026-02-21T01:37:24Z
- **合并时间**: 2026-02-21T21:03:17Z
- **合并者**: alice-i-cecile

## 描述翻译

# 目的

- #22939 在 testbed_ui 的 Text 示例中引入了差异，但唯一改变的是字形(glyphs)被分配到字体图集(font atlas)的顺序。字体图集**应该能够**适应这种情况，并在该情况下不产生差异。
- 另一个 PR 也出现了类似的差异，似乎也是由于字形分配顺序改变引起的。

## 解决方案

- 以前，`DynamicTextureAtlasBuilder` 会分配 `字形大小 + 填充(padding)` 的空间，然后将字形复制到该矩形中——但这意味着复制将从 (0,0) 开始，导致我们与顶部和左侧边缘“混合”（这会破坏渲染效果）。
- 现在我们将内容复制到 (padding, padding) 的位置。
- 从底部和右侧移除 (padding, padding) 的可分配空间，以确保不会意外地将纹理放在右边缘或下边缘。

## 测试

- 添加了单元测试以确保分配正常工作以及填充功能正常。
- 这里的渲染变化非常有趣！https://pixel-eagle.com/project/B04F67C0-C054-4A6F-92EC-F599FEC2FD1D?filter=PR-23091 一些情况，比如 Text 截图里 `black` 中的 `l` 看起来**明显**更好！

请注意，这与 #23056 是正交的，后者是关于 `TextureAtlasBuilder`，而不是 `DynamicTextureAtlasBuilder`。

## The Story of This Pull Request

问题始于一个看似无关的UI测试差异。在另一个PR (#22939) 中，`testbed_ui` 示例的文本渲染出现了不一致的变化。开发者深入调查后发现，差异仅仅源于字形被分配到字体图集(font atlas)的顺序发生了改变。从逻辑上讲，一个健壮的纹理图集系统应该对纹理的分配顺序不敏感，只要内容相同，最终的渲染结果就应该一致。这个问题表明 `DynamicTextureAtlasBuilder` 内部存在缺陷，其填充(padding)逻辑没有正确处理，导致纹理数据可能“污染”了图集的边缘，进而使得渲染结果依赖于分配顺序。

问题的根源在于 `add_texture` 方法的实现。在修复之前，代码的执行流程是这样的：首先，它请求分配一个大小为 `纹理尺寸 + padding` 的矩形。然后，它将纹理数据复制到这个已分配的矩形区域，但复制操作的目标起始坐标是 (0, 0)，也就是该分配矩形的左上角。这意味着纹理的第一个像素会被放置在分配区域的左上角，从而紧邻着（或者覆盖了）为左侧和上方填充预留的空间。此外，在计算最终存入 `TextureAtlasLayout` 的矩形时，代码从 `rect.max` 中减去了填充值，试图“去掉”填充区域。然而，由于复制操作是从(0,0)开始的，这个减法操作并没有准确反映纹理内容在图集中的实际位置。这导致了两个问题：1) 纹理内容可能与相邻纹理的填充区域或图集边界错误地混合（blending），尤其是在使用线性过滤时；2) 纹理在图集中的逻辑位置（记录在layout中的矩形）可能与实际像素数据的物理位置不匹配。

解决方案的核心是重新思考填充的处理模型。正确的模型应该是：每个纹理在图集中占据一个“逻辑内容区域”，这个区域被一个“填充缓冲区”所包围。填充应该完全包围纹理内容，而不仅仅是存在于右侧和下方。因此，在分配时，我们仍需为 `纹理尺寸 + padding` 申请空间。但在放置纹理时，内容不应从分配矩形的(0,0)开始，而应该偏移 `(padding, padding)`，从而为左方和上方留出填充空间。同时，为了确保纹理内容不会触及图集的右边缘和下边缘（这些边缘的填充由下一个纹理的左/上填充提供），我们需要在图集创建时就预留出这部分空间。

实现这一思路需要对 `DynamicTextureAtlasBuilder` 进行三处关键修改。首先，在 `new` 函数中，创建底层 `AtlasAllocator` 时，传入的尺寸是 `size - padding`。这是一个精妙的处理：它从图集的总可用空间中预先扣除了右下边缘的填充空间，使得分配器根本不会分配触及这些边缘的区域。其次，在 `add_texture` 方法中，当从分配器获得一个矩形 (`allocation.rectangle`) 后，我们立即将其 `min` 坐标（左上角）增加 `padding`。这个操作将矩形的起点向内移动，为纹理内容“让”出了左上方的填充空间。此时，这个调整后的矩形恰好就代表了纹理内容应该被复制到的目标区域。最后，`place_texture` 方法被大幅简化：它不再需要调整 `rect.max` 来减去填充，因为它现在接收到的 `allocation.rectangle` 已经是经过 `add_texture` 调整后的、代表内容区域的正确矩形。负责计算并存储到 `TextureAtlasLayout` 的矩形也是这个调整后的矩形，它精确地描述了纹理内容（不包括任何填充）在图集中的位置。

这些改动带来了直接的积极影响。最明显的是视觉质量的提升，特别是在文本渲染中。修复后，字符边缘不再错误地与相邻字符的填充区域混合，使得字形显示更为清晰锐利，链接中的对比图清楚地展示了这一点。此外，系统的健壮性得到了增强。现在，纹理在图集中的布局和渲染结果不再依赖于它们被添加的顺序，这符合一个纹理打包系统的预期行为。为了巩固这次修复并防止回归，PR还包含了全面的单元测试。测试覆盖了无填充和有填充两种情况，验证了纹理被正确分配到预期位置，并且像素数据被准确地复制到了图集纹理的对应区域。

从工程角度看，这个修复展示了处理边界和填充时精确计算的重要性。一个像素的偏差就可能导致渲染瑕疵。同时，它也强调了单元测试在验证底层工具类（如纹理图集构建器）正确性方面的价值，这些工具类的细微错误会在高层（如UI渲染）被放大并难以调试。

## Visual Representation

```mermaid
graph TD
    subgraph “Inputs”
        A[Texture Image]
        P[Padding Value]
    end

    subgraph “DynamicTextureAtlasBuilder”
        B[AtlasAllocator]
        C[add_texture Logic]
    end

    subgraph “Outputs”
        D[Atlas Texture Image]
        E[TextureAtlasLayout]
    end

    A --> C
    P --> B
    P --> C
    B -- “Allocates space (size - padding)” --> C
    C -- “Copies texture data with offset (padding, padding)” --> D
    C -- “Records content rectangle (without padding)” --> E
```

## Key Files Changed

### `crates/bevy_image/src/dynamic_texture_atlas_builder.rs` (+220/-9)

这是本PR修改的唯一文件，包含了核心的bug修复以及新增的单元测试。主要修改集中在 `new`, `add_texture` 和 `place_texture` 方法上，以纠正纹理填充的逻辑。

1. **`new` 方法**: 修改了 `AtlasAllocator` 的初始化尺寸，并添加了断言。
```rust
// 修改前:
pub fn new(size: UVec2, padding: u32) -> Self {
    Self {
        atlas_allocator: AtlasAllocator::new(to_size2(size)),
        padding,
    }
}

// 修改后:
pub fn new(size: UVec2, padding: u32) -> Self {
    // This doesn't need to be >= since `AtlasAllocator` requires non-zero size.
    debug_assert!(size.x > padding && size.y > padding);
    Self {
        // Leave out padding at the right and bottom, so we don't put textures on the edge of
        // atlas.
        atlas_allocator: AtlasAllocator::new(to_size2(size - padding)),
        padding,
    }
}
```

2. **`add_texture` 方法**: 关键修改。在获得分配结果后，调整了矩形的最小坐标以容纳左上填充，并简化了返回矩形的计算。
```rust
// 修改后的关键部分:
if let Some(mut allocation) = allocation {
    // ...
    let rect = &mut allocation.rectangle;
    // Remove the padding from the top and left (bottom and right padding is taken care of
    // by the "next" allocation and the border restriction).
    rect.min.x += self.padding as i32;
    rect.min.y += self.padding as i32;

    self.place_texture(atlas_texture, allocation, texture)?;
    Ok(atlas_layout.add_texture(to_rect(allocation.rectangle))) // 直接使用调整后的矩形
}
```

3. **`place_texture` 方法**: 简化了逻辑，不再需要手动调整 `rect.max`。
```rust
// 修改前:
fn place_texture(...) -> ... {
    let mut rect = allocation.rectangle;
    rect.max.x -= self.padding as i32;
    rect.max.y -= self.padding as i32;
    // ... 使用 rect 进行复制
}

// 修改后:
fn place_texture(...) -> ... {
    let rect = &allocation.rectangle; // 直接使用传入的矩形
    // ... 使用 rect 进行复制
}
```

4. **新增的单元测试**: 添加了两个测试函数 `allocate_textures` 和 `allocate_textures_with_padding`，用于验证无填充和有填充情况下纹理分配和复制的正确性，确保了修复的可靠性并防止未来回归。

## Further Reading

1.  **Guillotiere库**: `DynamicTextureAtlasBuilder` 内部使用的矩形包装库。了解其API有助于理解 `AtlasAllocator` 和 `Allocation` 的行为。
2.  **Bevy 纹理图集文档**: 官方文档中关于 `TextureAtlas` 和 `TextureAtlasLayout` 的部分，以理解该PR修复的组件在整个渲染管线中的作用。
3.  **纹理填充与边缘过滤**: 关于为什么纹理间需要填充（避免纹理过滤时采样到相邻纹理的颜色）的图形学知识。
4.  **PR #23056**: 与本PR提及的、修复 `TextureAtlasBuilder`（静态图集构建器）中类似但不同问题的相关PR，可以进行对比学习。