+++
title = "#22922 Fix culling for negative sized UI elements"
date = "2026-02-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22922-en-20260217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22922-zh-cn-20260217" }}
labels = ["C-Bug", "A-Rendering", "A-UI", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Fix culling for negative sized UI elements
- **PR Link**: https://github.com/bevyengine/bevy/pull/22922
- **Author**: GiantBlargg
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, A-UI, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-02-12T03:21:52Z
- **Merged**: 2026-02-17T01:47:20Z
- **Merged By**: alice-i-cecile

## Description Translation
**目标**
修复 #22906

**解决方案**
字形渲染中已经实现了类似的解决方案，所以我直接复制了它。

**测试**
重现错误的步骤见 #22906。应用此修复后，结果符合预期。

## The Story of This Pull Request

这个故事始于 Bevy 引擎 UI 渲染管道中一个关于性能优化（裁剪 culling）的缺陷。在图形渲染中，裁剪是一个基础优化：如果一个元素完全位于视口（viewport）之外，我们就跳过渲染它，从而节省宝贵的 GPU 时间。在 Bevy 的 UI 渲染系统中，这个逻辑处理各种 UI 节点，包括图像、文本、材质和阴影。

问题的核心出现在处理具有“负尺寸”的 UI 元素时。在 Bevy UI 的坐标系中，一个节点的 `size` 属性为负值是有意义的，通常表示该节点应该在某个轴向上反向拉伸或缩放。然而，在决定是否裁剪一个节点时，系统需要计算该节点在经过变换（如缩放、旋转）后的实际屏幕空间大小。这里的计算逻辑假设变换后的尺寸（`transformed_rect_size`）总是正数，并直接将其绝对值（`.abs()`）用于后续的裁剪比较。但问题在于，**计算 `transformed_rect_size` 的步骤本身可能产生负值**。

具体来说，`transform.transform_vector2(rect_size)` 这一行代码使用变换矩阵对原始尺寸向量进行变换。如果原始 `rect_size` 包含负分量（例如 `Vec2 { x: -100.0, y: 50.0 }`），并且变换矩阵中包含负的缩放因子（例如水平翻转），那么计算结果的分量也可能是负的。在原来的代码中，后续的裁剪条件直接使用了这个可能为负的 `transformed_rect_size` 的分量，与另一个计算出的正数 `positions_diff` 进行比较，导致裁剪逻辑误判。本应渲染的节点被错误地剔除（culled），在屏幕上表现为 UI 元素消失。

开发者 GiantBlargg 在 issue #22906 中发现了这个问题。修复方案非常直接且高效：**在计算完变换后的尺寸后，立即对其取绝对值**。这确保了用于裁剪判断的尺寸值始终是非负的，与用于比较的 `positions_diff` 差值向量的性质一致，从而恢复了正确的裁剪逻辑。

值得注意的是，作者提到这个解决方案“已经为字形（glyphs）实现”，他只是将其复制到其他需要修复的渲染路径中。这体现了良好的代码实践——识别并复用经过验证的解决方案，而不是为每个类似问题重新发明轮子。这也暗示了该 Bug 可能是随着代码的演进而被不一致地引入的：字形渲染路径后来添加了 `.abs()` 调用，但其他类似的渲染路径被遗漏了。

这个修复涉及五个文件，修改模式高度一致，都遵循以下模式：

```rust
// 修改前：
let transformed_rect_size = transform.transform_vector2(rect_size);
// ... 后续可能使用 transformed_rect_size.x.abs() 和 .y.abs()

// 修改后：
let transformed_rect_size = transform.transform_vector2(rect_size).abs();
// ... 后续直接使用 transformed_rect_size.x 和 .y （它们现在已是非负值）
```

在 `crates/bevy_ui_render/src/lib.rs` 中，甚至有两处修改：一处是通用 UI 节点准备逻辑，另一处是处理“完全被裁剪”节点的特定检查。后一处修改特别有启发性，它展示了 `.abs()` 的调用如何简化了后续代码——修改后，代码可以直接使用 `transformed_rect_size.x` 和 `.y`，而不需要再在每个使用点调用 `.abs()`。

这个 PR 的技术影响很明确：它修复了一个渲染错误，确保具有负尺寸或特定变换的 UI 元素能够被正确渲染，而不会被过早剔除。从性能角度看，增加 `.abs()` 调用的开销可以忽略不计，而修复错误剔除带来的收益（避免了本应显示的图像缺失）是显著的。

从工程角度来看，这个 PR 提供了一个简洁的案例：如何定位由数值符号处理不一致导致的边界条件 Bug，以及如何通过应用一个最小、最集中的修复来解决问题。它也提醒我们，在复制粘贴代码或实现相似功能时，保持逻辑的一致性至关重要。最终的解决方案优雅地将符号处理的责任上移，使后续逻辑更清晰、更健壮。

## Visual Representation

```mermaid
graph TD
    subgraph "修复的渲染准备函数"
        A[prepare_uinodes<br/>主UI节点] --> E{使用变换后尺寸进行裁剪判断}
        B[prepare_gradient<br/>渐变] --> E
        C[prepare_shadows<br/>阴影] --> E
        D[prepare_uimaterial_nodes<br/>UI材质] --> E
        F[prepare_ui_slices<br/>纹理切片] --> E
    end
    E --> G[调用 .abs()<br/>确保尺寸非负]
    G --> H[正确裁剪/渲染]
```

## Key Files Changed

1.  **`crates/bevy_ui_render/src/lib.rs` (+7/-6)**
    *   **描述与原因**：这是 UI 渲染的核心准备函数。修改了两处逻辑，确保在计算 UI 节点变换后尺寸后立即取绝对值，以便后续的裁剪判断基于非负值进行。这修复了主 UI 节点和完全裁剪节点的处理逻辑。
    *   **关键代码修改**：
        ```rust
        // 修改前（第1571行附近）：
        let transformed_rect_size = transform.transform_vector2(rect_size);
        // ... 后续条件中使用了 transformed_rect_size.x.abs()

        // 修改后：
        let transformed_rect_size = transform.transform_vector2(rect_size).abs();
        // ... 后续条件中直接使用 transformed_rect_size.x
        ```
        ```rust
        // 修改前（第1714行附近）：
        let transformed_rect_size = extracted_uinode.transform.transform_vector2(rect_size);
        if positions_diff[0].x - positions_diff[1].x >= transformed_rect_size.x.abs()
        // ...

        // 修改后：
        let transformed_rect_size = extracted_uinode.transform.transform_vector2(rect_size).abs();
        if positions_diff[0].x - positions_diff[1].x >= transformed_rect_size.x
        // ...
        ```

2.  **`crates/bevy_ui_render/src/gradient.rs` (+2/-1)**
    *   **描述与原因**：修复渐变 UI 节点的准备函数，模式与主函数一致。
    *   **关键代码修改**：
        ```rust
        // 修改前：
        let transformed_rect_size = gradient.transform.transform_vector2(rect_size);

        // 修改后：
        let transformed_rect_size = gradient.transform.transform_vector2(rect_size).abs();
        ```

3.  **`crates/bevy_ui_render/src/box_shadow.rs` (+1/-1)**
    *   **描述与原因**：修复盒子阴影（box shadow）渲染的准备函数。
    *   **关键代码修改**：
        ```rust
        // 修改前：
        let transformed_rect_size = box_shadow.transform.transform_vector2(rect_size);

        // 修改后：
        let transformed_rect_size = box_shadow.transform.transform_vector2(rect_size).abs();
        ```

4.  **`crates/bevy_ui_render/src/ui_material_pipeline.rs` (+4/-2)**
    *   **描述与原因**：修复自定义 UI 材质节点的准备函数。
    *   **关键代码修改**：
        ```rust
        // 修改前：
        let transformed_rect_size = extracted_uinode.transform.transform_vector2(rect_size);

        // 修改后：
        let transformed_rect_size = extracted_uinode
            .transform
            .transform_vector2(rect_size)
            .abs();
        ```

5.  **`crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs` (+1/-1)**
    *   **描述与原因**：修复使用纹理切片（9-patch 缩放）的 UI 节点的准备函数。
    *   **关键代码修改**：
        ```rust
        // 修改前：
        let transformed_rect_size = texture_slices.transform.transform_vector2(rect_size);

        // 修改后：
        let transformed_rect_size = texture_slices.transform.transform_vector2(rect_size).abs();
        ```

## Further Reading
*   **Bevy 官方文档 - 变换（Transforms）**：了解 `Transform` 组件及其 `transform_vector2` 方法如何工作。
*   **计算机图形学基础 - 视图裁剪（View Frustum Culling）**：理解裁剪在渲染管线中的作用和常见算法。
*   **线性代数在图形学中的应用**：理解向量、矩阵变换以及缩放因子为负时（反射）的几何意义。
*   **GitHub Issue #22906**：查看此修复所解决的具体问题报告和重现步骤。