+++
title = "#23116 PR #23116 - \"Create an example to show generating assets at runtime\""
date = "2026-02-25T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23116-en-20260225" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23116-zh-cn-20260225" }}
labels = ["C-Examples", "A-Assets", "D-Straightforward"]
+++

# Title: PR #23116 - "Create an example to show generating assets at runtime"

## Basic Information
- **Title**: Create an example to show generating assets at runtime.
- **PR Link**: https://github.com/bevyengine/bevy/pull/23116
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: C-Examples, A-Assets, S-Ready-For-Final-Review, X-Uncontroversial, D-Straightforward
- **Created**: 2026-02-23T03:06:19Z
- **Merged**: 2026-02-25T08:17:01Z
- **Merged By**: alice-i-cecile

## Description Translation
The PR description is already in English.

# Objective
- Show how to create assets at runtime.
- https://discord.com/channels/691052431525675048/691052431974465548/1475244907047424236

## Solution
- Create an example.

## Testing
- The example works!

## The Story of This Pull Request

The Bevy engine community identified a gap in their documentation - there wasn't a clear example showing developers how to generate assets dynamically at runtime. While Bevy has robust asset loading systems, the process for programmatically creating assets like meshes, materials, or textures during game execution wasn't well-documented. This PR addresses that by adding a comprehensive example that demonstrates three distinct approaches to runtime asset generation.

The developer started by understanding the core problem: game developers often need to create assets on the fly rather than just loading pre-existing ones. This could be for procedural content generation, dynamic UI creation, or adapting game content based on player choices. The existing examples showed asset loading but not creation.

The solution approach focuses on demonstrating three practical methods for runtime asset generation, each serving different use cases. The first method shows immediate synchronous asset creation by directly inserting into an `Assets` collection. The second demonstrates asynchronous asset generation using Bevy's async task system, which is useful for computationally expensive operations that shouldn't block the main thread. The third method shows handle reservation followed by deferred population, giving developers control over when the asset data becomes available.

The implementation creates a single example file with clear, commented code showing each technique. The example generates three different 3D meshes (a cone, a torus, and another cone) using Bevy's geometric primitives and displays them in a simple 3D scene. This visual demonstration makes it immediately obvious that the runtime generation is working.

From a technical perspective, the example leverages several key Bevy concepts. It demonstrates the use of `Assets<T>` collections, handle management with `Handle<T>`, the asset server's async capabilities, and Bevy's ECS patterns for deferred operations. The comment structure is particularly effective - each code block explains not just what it does, but when you'd choose that approach in a real project.

The impact is straightforward but significant: developers now have a reference implementation for a common game development pattern. The example is appropriately categorized in the assets section and marked as compatible with WebAssembly, indicating it's been tested for cross-platform use. The minimal changes to the codebase (just adding an example) mean there's no risk of breaking existing functionality while providing clear educational value.

## Visual Representation

```mermaid
graph TD
    A[App Startup] --> B[setup system]
    B --> C[Direct Mesh Insertion<br/>materials.add()]
    B --> D[Async Asset Generation<br/>asset_server.add_async()]
    B --> E[Handle Reservation<br/>meshes.reserve_handle()]
    E --> F[generate_mesh_system]
    F --> G[Deferred Mesh Insertion<br/>meshes.insert()]
    
    C --> H[Render Cone Mesh]
    D --> I[Render Cone Mesh<br/>(deferred)]
    G --> J[Render Torus Mesh<br/>(system-populated)]
```

## Key Files Changed

1. **`examples/asset/generated_assets.rs`** (+71/-0)
   - New file: Complete example demonstrating three approaches to runtime asset generation
   - Shows immediate asset creation, async generation, and handle reservation patterns
   - Includes proper ECS setup with systems and resources

Key code sections:
```rust
// Method 1: Direct synchronous insertion
let material_handle = materials.add(StandardMaterial::default());

// Method 2: Async deferred generation
Mesh3d(asset_server.add_async(generate_mesh_async()))

// Method 3: Handle reservation with deferred population
let mesh_handle = meshes.reserve_handle();
// ... later in generate_mesh_system:
meshes.insert(&handle_to_generate.0, mesh).unwrap();
```

2. **`Cargo.toml`** (+11/-0)
   - Added example configuration with proper metadata
   - Enabled documentation scraping for the example
   - Marked as WebAssembly compatible

Key changes:
```toml
[[example]]
name = "generated_assets"
path = "examples/asset/generated_assets.rs"
doc-scrape-examples = true

[package.metadata.example.generated_assets]
name = "Generated Assets"
description = "Shows how to generate and store assets at runtime"
category = "Assets"
wasm = true
```

3. **`examples/README.md`** (+1/-0)
   - Added entry for the new example in the assets section
   - Maintains alphabetical ordering with other asset examples

Key change:
```markdown
[Generated Assets](../examples/asset/generated_assets.rs) | Shows how to generate and store assets at runtime
```

## Further Reading

- Bevy Assets Documentation: https://bevyengine.org/learn/book/assets/
- Bevy ECS Patterns: https://bevyengine.org/learn/book/ecs/
- Async Programming in Bevy: https://bevyengine.org/learn/book/async/
- Procedural Content Generation in Games: Academic literature on runtime asset generation techniques