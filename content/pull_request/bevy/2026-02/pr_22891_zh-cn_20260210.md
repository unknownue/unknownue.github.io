+++
title = "#22891 Add `dirs` module to bevy_platform"
date = "2026-02-10T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22891-en-20260210" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22891-zh-cn-20260210" }}
+++

# Title

## 基本信息
- **标题**: Add `dirs` module to bevy_platform
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22891
- **作者**: viridia
- **状态**: 已合并
- **标签**: C-Feature, A-Utils, M-Release-Note, A-Dev-Tools, X-Blessed, S-Needs-Review
- **创建时间**: 2026-02-10T18:52:56Z
- **合并时间**: 2026-02-10T23:05:22Z
- **合并者**: cart

## 描述翻译

# 目标

添加一个 `dirs` 模块，提供应用程序偏好设置目录的位置。

隶属于：#13311


## 这个 Pull Request 的故事

这个 PR 的故事始于一个常见的跨平台开发需求：应用程序需要知道把配置文件、用户数据或者偏好设置存在哪里。不同的操作系统有不同的惯例。在 Windows 上可能是 `%LOCALAPPDATA%`，在 macOS 上是 `~/Library/Preferences`，在遵循 XDG 标准的 Linux 发行版上则是 `~/.config` 或 `$XDG_CONFIG_HOME`。为了保持代码整洁并避免让每个 Bevy 应用开发者都去重复实现这套平台检测和路径拼接逻辑，`bevy_platform` crate 成为了存放这类与平台交互的底层工具函数的理想场所。

开发者 viridia 选择了一个务实且可扩展的方案来实现这个功能。核心思想是提供一个统一的函数 `preferences_dir()`，它在不同的操作系统上通过条件编译来调用不同的底层实现。这个设计借鉴了 `dirs-dev/dirs-sys-rs` 库的模式，但被集成到 Bevy 自身的生态中，以减少外部依赖。

实现的重点放在了 Windows 平台上，因为它需要调用特定的系统 API。在 `windows.rs` 中，`preferences_dir()` 函数通过调用 `known_folder` 辅助函数，并传入 `FOLDERID_LocalAppData` 这个 GUID 来获取路径。这里的一个关键工程细节是内存安全：`SHGetKnownFolderPath` 这个 Windows API 会分配内存，返回的指针必须用 `CoTaskMemFree` 正确释放。代码用 `unsafe` 块包装了这些操作，并确保在成功和失败两种路径下都释放了内存，这是一个正确的资源管理实践。

对于 macOS 和 Linux，目前的实现是基础版本。它们简单地使用 `std::env::home_dir()` 获取用户家目录，然后拼接上平台约定的子目录路径。值得注意的是，`linux.rs` 中有一个 `TODO` 注释，表明当前的实现（直接使用 `~/.config`）尚未支持完整的 XDG Base Directory 规范（即优先检查 `$XDG_CONFIG_HOME` 环境变量）。这表明了开发者的意图：先提供一个可用的最小实现，未来再根据需求增强。其他未被明确支持的操作系统，`preferences_dir()` 会返回 `None`。

从架构上看，`mod.rs` 文件是整个模块的调度中心。它使用 `#[cfg(...)]` 属性根据目标操作系统来有条件地编译和导出不同平台的具体实现模块。这种模式在 Rust 的跨平台代码中很常见，能保证最终生成的二进制文件中只包含当前平台相关的代码。

这个改动的影响很直接：它为 Bevy 应用程序提供了一个标准化的、跨平台的方式来定位用户偏好设置目录。开发者现在可以调用 `bevy_platform::dirs::preferences_dir()`，而不必自己处理平台差异。虽然当前只实现了这一个目录，但模块的命名 (`dirs`) 和结构为将来添加更多标准目录（如缓存目录、数据目录等）预留了空间，符合 #13311 这个更大目标的方向。

## 视觉表示

```mermaid
graph TD
    A[bevy_platform] --> B[dirs 模块]
    B --> C{目标平台}
    C -->|Windows| D[windows.rs]
    C -->|macOS| E[macos.rs]
    C -->|Linux| F[linux.rs]
    C -->|其他| G[回退实现 None]
    D --> H[调用 SHGetKnownFolderPath API]
    E --> I[拼接 ~/Library/Preferences]
    F --> J[拼接 ~/.config (暂不支持 XDG)]
```

## 关键文件变更

列出了此 PR 中最重要的文件更改：
- `crates/bevy_platform/src/dirs/windows.rs` (+33/-0)
- `crates/bevy_platform/src/dirs/mod.rs` (+28/-0)
- `crates/bevy_platform/Cargo.toml` (+8/-0)
- `release-content/release-notes/platform_dirs.md` (+8/-0)
- `crates/bevy_platform/src/dirs/linux.rs` (+7/-0)

1. **`crates/bevy_platform/src/dirs/windows.rs`**
    *   **变更原因**：实现 Windows 系统上获取 `LocalAppData` 目录的逻辑。这是最复杂的实现，因为它涉及调用 Win32 API 和手动管理内存。
    *   **关键代码**:
        ```rust
        /// Returns the path to the directory used for application settings.
        pub fn preferences_dir() -> Option<PathBuf> {
            known_folder(Shell::FOLDERID_LocalAppData)
        }
        ```
        以及核心的 `known_folder` 函数，它封装了不安全的 Windows API 调用并确保了内存的正确释放。

2. **`crates/bevy_platform/src/dirs/mod.rs`**
    *   **变更原因**：作为 `dirs` 模块的入口点，负责根据编译目标操作系统调度到正确的平台特定实现。
    *   **关键代码**:
        ```rust
        #[cfg(target_os = "windows")]
        mod windows;
        #[cfg(target_os = "windows")]
        pub use windows::preferences_dir;

        #[cfg(target_os = "macos")]
        mod macos;
        #[cfg(target_os = "macos")]
        pub use macos::preferences_dir;

        #[cfg(target_os = "linux")]
        mod linux;
        #[cfg(target_os = "linux")]
        pub use linux::preferences_dir;
        ```
        这段代码清晰地展示了如何使用条件编译来组织跨平台代码。

3. **`crates/bevy_platform/Cargo.toml`**
    *   **变更原因**：为 Windows 平台的实现添加必要的依赖项 `windows-sys` crate，并指定了所需的特定功能（`features`）。
    *   **关键代码**:
        ```toml
        [target.'cfg(windows)'.dependencies]
        windows-sys = { version = ">= 0.59.0", features = [
          "Win32_UI_Shell",
          "Win32_Foundation",
          "Win32_Globalization",
          "Win32_System_Com",
        ] }
        ```
        这确保了依赖仅对 Windows 目标生效，不会影响其他平台的构建。

4. **`crates/bevy_platform/src/lib.rs`**
    *   **变更原因**：将新创建的 `dirs` 模块公开为 `bevy_platform` crate 的公共 API 一部分。
    *   **关键代码**:
        ```rust
        cfg::std! {
            extern crate std;

            pub mod dirs; // 新增这行
        }
        ```

5. **`release-content/release-notes/platform_dirs.md`**
    *   **变更原因**：为新功能添加发布说明文档，以便在版本发布时告知用户。
    *   **内容**：简要说明了 `bevy_platform::dirs` 模块的用途。

## 进一步阅读

*   **Rust 条件编译（`#[cfg]`）**: [The Rust Reference - Conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html) 了解如何根据目标平台或其他条件包含或排除代码。
*   **Windows `SHGetKnownFolderPath` API**: [Microsoft Docs](https://learn.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath) 理解 Windows 上获取标准目录的官方方法。
*   **XDG Base Directory 规范**: [XDG Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html) 了解 Linux 桌面环境下存储用户文件的现代标准。
*   **`dirs-dev` 项目**: [dirs-rs GitHub](https://github.com/dirs-dev/dirs-rs) 这是此 PR 实现所参考的独立库，可以查看其更完整的实现和设计思路。