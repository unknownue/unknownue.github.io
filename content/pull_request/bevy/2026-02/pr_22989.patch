diff --git a/crates/bevy_asset/src/loader.rs b/crates/bevy_asset/src/loader.rs
index 3ec4daf539948..4315f63b58476 100644
--- a/crates/bevy_asset/src/loader.rs
+++ b/crates/bevy_asset/src/loader.rs
@@ -9,7 +9,7 @@ use crate::{
 use alloc::{boxed::Box, string::ToString, vec::Vec};
 use atomicow::CowArc;
 use bevy_ecs::{error::BevyError, world::World};
-use bevy_platform::collections::{HashMap, HashSet};
+use bevy_platform::collections::{hash_map::Entry, HashMap, HashSet};
 use bevy_reflect::TypePath;
 use bevy_tasks::{BoxedFuture, ConditionalSendFuture};
 use core::any::{Any, TypeId};
@@ -141,7 +141,15 @@ pub struct LoadedAsset<A: Asset> {
     pub(crate) value: A,
     pub(crate) dependencies: HashSet<ErasedAssetIndex>,
     pub(crate) loader_dependencies: HashMap<AssetPath<'static>, AssetHash>,
-    pub(crate) labeled_assets: HashMap<CowArc<'static, str>, LabeledAsset>,
+    /// The subassets of this asset.
+    pub(crate) labeled_assets: Vec<LabeledAsset>,
+    /// The mapping from subasset labels to their index in [`Self::labeled_assets`].
+    pub(crate) label_to_asset_index: HashMap<CowArc<'static, str>, usize>,
+    /// The mapping from a subasset asset IDs to their index in [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    pub(crate) asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,
 }
 
 impl<A: Asset> LoadedAsset<A> {
@@ -158,7 +166,9 @@ impl<A: Asset> LoadedAsset<A> {
             value,
             dependencies,
             loader_dependencies: HashMap::default(),
-            labeled_assets: HashMap::default(),
+            labeled_assets: Default::default(),
+            label_to_asset_index: Default::default(),
+            asset_id_to_asset_index: Default::default(),
         }
     }
 
@@ -177,12 +187,25 @@ impl<A: Asset> LoadedAsset<A> {
         &self,
         label: impl Into<CowArc<'static, str>>,
     ) -> Option<&ErasedLoadedAsset> {
-        self.labeled_assets.get(&label.into()).map(|a| &a.asset)
+        self.label_to_asset_index
+            .get(&label.into())
+            .map(|index| self.labeled_assets.get(*index).unwrap())
+            .map(|a| &a.asset)
+    }
+
+    /// Returns the labeled asset given its asset ID if it exists.
+    ///
+    /// This can be used to get the asset from its handle since `&Handle` implements
+    /// [`Into<UntypedAssetId>`].
+    pub fn get_labeled_by_id(&self, id: impl Into<UntypedAssetId>) -> Option<&ErasedLoadedAsset> {
+        let index = self.asset_id_to_asset_index.get(&id.into())?;
+        let labeled = &self.labeled_assets[*index];
+        Some(&labeled.asset)
     }
 
     /// Iterate over all labels for "labeled assets" in the loaded asset
     pub fn iter_labels(&self) -> impl Iterator<Item = &str> {
-        self.labeled_assets.keys().map(|s| &**s)
+        self.label_to_asset_index.keys().map(|s| &**s)
     }
 }
 
@@ -197,7 +220,15 @@ pub struct ErasedLoadedAsset {
     pub(crate) value: Box<dyn AssetContainer>,
     pub(crate) dependencies: HashSet<ErasedAssetIndex>,
     pub(crate) loader_dependencies: HashMap<AssetPath<'static>, AssetHash>,
-    pub(crate) labeled_assets: HashMap<CowArc<'static, str>, LabeledAsset>,
+    /// The subassets of this asset.
+    pub(crate) labeled_assets: Vec<LabeledAsset>,
+    /// The mapping from subasset labels to their index in [`Self::labeled_assets`].
+    pub(crate) label_to_asset_index: HashMap<CowArc<'static, str>, usize>,
+    /// The mapping from subasset asset IDs to their index in [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    pub(crate) asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,
 }
 
 impl<A: Asset> From<LoadedAsset<A>> for ErasedLoadedAsset {
@@ -207,6 +238,8 @@ impl<A: Asset> From<LoadedAsset<A>> for ErasedLoadedAsset {
             dependencies: asset.dependencies,
             loader_dependencies: asset.loader_dependencies,
             labeled_assets: asset.labeled_assets,
+            label_to_asset_index: asset.label_to_asset_index,
+            asset_id_to_asset_index: asset.asset_id_to_asset_index,
         }
     }
 }
@@ -238,16 +271,33 @@ impl ErasedLoadedAsset {
         &self,
         label: impl Into<CowArc<'static, str>>,
     ) -> Option<&ErasedLoadedAsset> {
-        self.labeled_assets.get(&label.into()).map(|a| &a.asset)
+        self.label_to_asset_index
+            .get(&label.into())
+            .map(|index| self.labeled_assets.get(*index).unwrap())
+            .map(|a| &a.asset)
+    }
+
+    /// Returns the labeled asset given its asset ID if it exists.
+    ///
+    /// This can be used to get the asset from its handle since `&Handle` implements
+    /// [`Into<UntypedAssetId>`].
+    pub fn get_labeled_by_id(&self, id: impl Into<UntypedAssetId>) -> Option<&ErasedLoadedAsset> {
+        let index = self.asset_id_to_asset_index.get(&id.into())?;
+        let labeled = &self.labeled_assets[*index];
+        Some(&labeled.asset)
     }
 
     /// Iterate over all labels for "labeled assets" in the loaded asset
     pub fn iter_labels(&self) -> impl Iterator<Item = &str> {
-        self.labeled_assets.keys().map(|s| &**s)
+        self.label_to_asset_index.keys().map(|s| &**s)
     }
 
     /// Cast this loaded asset as the given type. If the type does not match,
     /// the original type-erased asset is returned.
+    #[expect(
+        clippy::result_large_err,
+        reason = "Returning the passed in ErasedLoadedAsset"
+    )]
     pub fn downcast<A: Asset>(mut self) -> Result<LoadedAsset<A>, ErasedLoadedAsset> {
         match self.value.downcast::<A>() {
             Ok(value) => Ok(LoadedAsset {
@@ -255,6 +305,8 @@ impl ErasedLoadedAsset {
                 dependencies: self.dependencies,
                 loader_dependencies: self.loader_dependencies,
                 labeled_assets: self.labeled_assets,
+                label_to_asset_index: self.label_to_asset_index,
+                asset_id_to_asset_index: self.asset_id_to_asset_index,
             }),
             Err(value) => {
                 self.value = value;
@@ -326,7 +378,15 @@ pub struct LoadContext<'a> {
     pub(crate) dependencies: HashSet<ErasedAssetIndex>,
     /// Direct dependencies used by this loader.
     pub(crate) loader_dependencies: HashMap<AssetPath<'static>, AssetHash>,
-    pub(crate) labeled_assets: HashMap<CowArc<'static, str>, LabeledAsset>,
+    /// Stores the subassets added to this context.
+    pub(crate) labeled_assets: Vec<LabeledAsset>,
+    /// Maps the label of a subasset to the index into [`Self::labeled_assets`].
+    pub(crate) label_to_asset_index: HashMap<CowArc<'static, str>, usize>,
+    /// Maps the subasset asset ID to the index into [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    pub(crate) asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,
 }
 
 impl<'a> LoadContext<'a> {
@@ -344,7 +404,9 @@ impl<'a> LoadContext<'a> {
             should_load_dependencies,
             dependencies: HashSet::default(),
             loader_dependencies: HashMap::default(),
-            labeled_assets: HashMap::default(),
+            labeled_assets: Default::default(),
+            label_to_asset_index: Default::default(),
+            asset_id_to_asset_index: Default::default(),
         }
     }
 
@@ -440,13 +502,27 @@ impl<'a> LoadContext<'a> {
         let handle = self
             .asset_server
             .get_or_create_path_handle(labeled_path, None);
-        self.labeled_assets.insert(
-            label,
-            LabeledAsset {
-                asset: loaded_asset,
-                handle: handle.clone().untyped(),
-            },
-        );
+        let asset = LabeledAsset {
+            asset: loaded_asset,
+            handle: handle.clone().untyped(),
+        };
+        match self.label_to_asset_index.entry(label) {
+            Entry::Occupied(entry) => {
+                // TODO: We should probably treat this as an error. It seems unlikely someone wants
+                // to replace a subasset - this is probably accidental.
+                let index = *entry.get();
+                // Note: we don't need to mess with the `asset_id_to_asset_index` here, since we
+                // know the same path to `get_or_create_path_handle` will return the same handle as
+                // long as the handle remains alive, and we hold the handle in `LabeledAsset`.
+                self.labeled_assets[index] = asset;
+            }
+            Entry::Vacant(entry) => {
+                entry.insert(self.labeled_assets.len());
+                self.asset_id_to_asset_index
+                    .insert(handle.id().untyped(), self.labeled_assets.len());
+                self.labeled_assets.push(asset);
+            }
+        }
         handle
     }
 
@@ -480,6 +556,8 @@ impl<'a> LoadContext<'a> {
             dependencies: self.dependencies,
             loader_dependencies: self.loader_dependencies,
             labeled_assets: self.labeled_assets,
+            label_to_asset_index: self.label_to_asset_index,
+            asset_id_to_asset_index: self.asset_id_to_asset_index,
         }
     }
 
@@ -540,6 +618,23 @@ impl<'a> LoadContext<'a> {
         handle
     }
 
+    /// Returns the labeled asset if it exists.
+    pub fn get_labeled(&self, label: impl AsRef<str>) -> Option<&ErasedLoadedAsset> {
+        let index = self.label_to_asset_index.get(label.as_ref())?;
+        let labeled = &self.labeled_assets[*index];
+        Some(&labeled.asset)
+    }
+
+    /// Returns the labeled asset given its asset ID if it exists.
+    ///
+    /// This can be used to get the asset from its handle since `&Handle` implemented
+    /// [`Into<UntypedAssetId>`].
+    pub fn get_labeled_by_id(&self, id: impl Into<UntypedAssetId>) -> Option<&ErasedLoadedAsset> {
+        let index = self.asset_id_to_asset_index.get(&id.into())?;
+        let labeled = &self.labeled_assets[*index];
+        Some(&labeled.asset)
+    }
+
     pub(crate) async fn load_direct_internal(
         &mut self,
         path: AssetPath<'static>,
diff --git a/crates/bevy_asset/src/saver.rs b/crates/bevy_asset/src/saver.rs
index 850bc7801a2ef..5636b8dd2e1ee 100644
--- a/crates/bevy_asset/src/saver.rs
+++ b/crates/bevy_asset/src/saver.rs
@@ -2,13 +2,13 @@ use crate::{
     io::{AssetWriterError, MissingAssetSourceError, MissingAssetWriterError, Writer},
     meta::{AssetAction, AssetMeta, AssetMetaDyn, Settings},
     transformer::TransformedAsset,
-    Asset, AssetContainer, AssetLoader, AssetPath, AssetServer, ErasedLoadedAsset, Handle,
-    LabeledAsset, UntypedHandle,
+    Asset, AssetContainer, AssetId, AssetLoader, AssetPath, AssetServer, ErasedLoadedAsset, Handle,
+    LabeledAsset, UntypedAssetId, UntypedHandle,
 };
-use alloc::{boxed::Box, string::ToString, sync::Arc};
+use alloc::{boxed::Box, string::ToString, sync::Arc, vec::Vec};
 use atomicow::CowArc;
 use bevy_ecs::error::BevyError;
-use bevy_platform::collections::HashMap;
+use bevy_platform::collections::{hash_map::Entry, HashMap};
 use bevy_reflect::TypePath;
 use bevy_tasks::{BoxedFuture, ConditionalSendFuture};
 use core::{any::TypeId, borrow::Borrow, ops::Deref};
@@ -90,7 +90,13 @@ impl<S: AssetSaver> ErasedAssetSaver for S {
 #[derive(Clone)]
 pub struct SavedAsset<'a, 'b, A: Asset> {
     value: &'a A,
-    labeled_assets: Moo<'b, HashMap<CowArc<'a, str>, LabeledSavedAsset<'a>>>,
+    labeled_assets: Moo<'b, Vec<LabeledSavedAsset<'a>>>,
+    label_to_asset_index: Moo<'b, HashMap<CowArc<'a, str>, usize>>,
+    /// The mapping from a subasset asset IDs to their index in [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    asset_id_to_asset_index: Moo<'b, HashMap<UntypedAssetId, usize>>,
 }
 
 impl<A: Asset> Deref for SavedAsset<'_, '_, A> {
@@ -104,31 +110,39 @@ impl<A: Asset> Deref for SavedAsset<'_, '_, A> {
 impl<'a, 'b, A: Asset> SavedAsset<'a, 'b, A> {
     fn from_value_and_labeled_saved_assets(
         value: &'a A,
-        labeled_saved_assets: &'b HashMap<CowArc<'a, str>, LabeledSavedAsset<'a>>,
+        labeled_saved_assets: &'b Vec<LabeledSavedAsset<'a>>,
+        label_to_asset_index: &'b HashMap<CowArc<'a, str>, usize>,
+        asset_id_to_asset_index: &'b HashMap<UntypedAssetId, usize>,
     ) -> Self {
         Self {
             value,
             labeled_assets: Moo::Borrowed(labeled_saved_assets),
+            label_to_asset_index: Moo::Borrowed(label_to_asset_index),
+            asset_id_to_asset_index: Moo::Borrowed(asset_id_to_asset_index),
         }
     }
 
     fn from_value_and_labeled_assets(
         value: &'a A,
-        labeled_assets: &'a HashMap<CowArc<'static, str>, LabeledAsset>,
+        labeled_assets: &'a [LabeledAsset],
+        label_to_asset_index: &'a HashMap<CowArc<'static, str>, usize>,
+        asset_id_to_asset_index: &'a HashMap<UntypedAssetId, usize>,
     ) -> Self {
         Self {
             value,
             labeled_assets: Moo::Owned(
                 labeled_assets
                     .iter()
-                    .map(|(label, labeled_asset)| {
-                        (
-                            CowArc::Borrowed(label.borrow()),
-                            LabeledSavedAsset::from_labeled_asset(labeled_asset),
-                        )
-                    })
+                    .map(LabeledSavedAsset::from_labeled_asset)
+                    .collect(),
+            ),
+            label_to_asset_index: Moo::Owned(
+                label_to_asset_index
+                    .iter()
+                    .map(|(label, &index)| (CowArc::Borrowed(label.borrow()), index))
                     .collect(),
             ),
+            asset_id_to_asset_index: Moo::Borrowed(asset_id_to_asset_index),
         }
     }
 
@@ -138,19 +152,28 @@ impl<'a, 'b, A: Asset> SavedAsset<'a, 'b, A> {
         Some(Self::from_value_and_labeled_assets(
             value,
             &asset.labeled_assets,
+            &asset.label_to_asset_index,
+            &asset.asset_id_to_asset_index,
         ))
     }
 
     /// Creates a new [`SavedAsset`] from the a [`TransformedAsset`]
     pub fn from_transformed(asset: &'a TransformedAsset<A>) -> Self {
-        Self::from_value_and_labeled_assets(&asset.value, &asset.labeled_assets)
+        Self::from_value_and_labeled_assets(
+            &asset.value,
+            &asset.labeled_assets,
+            &asset.label_to_asset_index,
+            &asset.asset_id_to_asset_index,
+        )
     }
 
     /// Creates a new [`SavedAsset`] holding only the provided value with no labeled assets.
     pub fn from_asset(value: &'a A) -> Self {
         Self {
             value,
-            labeled_assets: Moo::Owned(HashMap::default()),
+            labeled_assets: Moo::Owned(Vec::default()),
+            label_to_asset_index: Moo::Owned(HashMap::default()),
+            asset_id_to_asset_index: Moo::Owned(HashMap::default()),
         }
     }
 
@@ -162,6 +185,8 @@ impl<'a, 'b, A: Asset> SavedAsset<'a, 'b, A> {
         ErasedSavedAsset {
             value: self.value,
             labeled_assets: self.labeled_assets,
+            label_to_asset_index: self.label_to_asset_index,
+            asset_id_to_asset_index: self.asset_id_to_asset_index,
         }
     }
 
@@ -173,25 +198,55 @@ impl<'a, 'b, A: Asset> SavedAsset<'a, 'b, A> {
 
     /// Returns the labeled asset, if it exists and matches this type.
     pub fn get_labeled<B: Asset>(&self, label: impl AsRef<str>) -> Option<SavedAsset<'a, '_, B>> {
-        let labeled = self.labeled_assets.get(label.as_ref())?;
+        let index = self.label_to_asset_index.get(label.as_ref())?;
+        let labeled = &self.labeled_assets[*index];
         labeled.asset.downcast()
     }
 
     /// Returns the type-erased labeled asset, if it exists and matches this type.
     pub fn get_erased_labeled(&self, label: impl AsRef<str>) -> Option<&ErasedSavedAsset<'a, '_>> {
-        let labeled = self.labeled_assets.get(label.as_ref())?;
+        let index = self.label_to_asset_index.get(label.as_ref())?;
+        let labeled = &self.labeled_assets[*index];
+        Some(&labeled.asset)
+    }
+
+    /// Returns the labeled asset given its asset ID if it exists and matches the type.
+    ///
+    /// This can be used to get the asset from its handle since `&Handle` implements
+    /// [`Into<AssetId<B>>`].
+    pub fn get_labeled_by_id<B: Asset>(
+        &self,
+        id: impl Into<AssetId<B>>,
+    ) -> Option<SavedAsset<'a, '_, B>> {
+        let index = self.asset_id_to_asset_index.get(&id.into().untyped())?;
+        let labeled = &self.labeled_assets[*index];
+        labeled.asset.downcast()
+    }
+
+    /// Returns the type-erased labeled asset given its asset ID if it exists.
+    ///
+    /// This can be used to get the asset from its handle since `&UntypedHandle` implements
+    /// [`Into<UntypedAssetId>`].
+    pub fn get_erased_labeled_by_id(
+        &self,
+        id: impl Into<UntypedAssetId>,
+    ) -> Option<&ErasedSavedAsset<'a, '_>> {
+        let index = self.asset_id_to_asset_index.get(&id.into())?;
+        let labeled = &self.labeled_assets[*index];
         Some(&labeled.asset)
     }
 
     /// Returns the [`UntypedHandle`] of the labeled asset with the provided 'label', if it exists.
     pub fn get_untyped_handle(&self, label: impl AsRef<str>) -> Option<UntypedHandle> {
-        let labeled = self.labeled_assets.get(label.as_ref())?;
+        let index = self.label_to_asset_index.get(label.as_ref())?;
+        let labeled = &self.labeled_assets[*index];
         Some(labeled.handle.clone())
     }
 
     /// Returns the [`Handle`] of the labeled asset with the provided 'label', if it exists and is an asset of type `B`
     pub fn get_handle<B: Asset>(&self, label: impl AsRef<str>) -> Option<Handle<B>> {
-        let labeled = self.labeled_assets.get(label.as_ref())?;
+        let index = self.label_to_asset_index.get(label.as_ref())?;
+        let labeled = &self.labeled_assets[*index];
         if let Ok(handle) = labeled.handle.clone().try_typed::<B>() {
             return Some(handle);
         }
@@ -200,14 +255,20 @@ impl<'a, 'b, A: Asset> SavedAsset<'a, 'b, A> {
 
     /// Iterate over all labels for "labeled assets" in the loaded asset
     pub fn iter_labels(&self) -> impl Iterator<Item = &str> {
-        self.labeled_assets.keys().map(|s| &**s)
+        self.label_to_asset_index.keys().map(|s| &**s)
     }
 }
 
 #[derive(Clone)]
 pub struct ErasedSavedAsset<'a: 'b, 'b> {
     value: &'a dyn AssetContainer,
-    labeled_assets: Moo<'b, HashMap<CowArc<'a, str>, LabeledSavedAsset<'a>>>,
+    labeled_assets: Moo<'b, Vec<LabeledSavedAsset<'a>>>,
+    label_to_asset_index: Moo<'b, HashMap<CowArc<'a, str>, usize>>,
+    /// The mapping from a subasset asset IDs to their index in [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    asset_id_to_asset_index: Moo<'b, HashMap<UntypedAssetId, usize>>,
 }
 
 impl<'a> ErasedSavedAsset<'a, '_> {
@@ -218,14 +279,17 @@ impl<'a> ErasedSavedAsset<'a, '_> {
                 asset
                     .labeled_assets
                     .iter()
-                    .map(|(label, asset)| {
-                        (
-                            CowArc::Borrowed(label.borrow()),
-                            LabeledSavedAsset::from_labeled_asset(asset),
-                        )
-                    })
+                    .map(LabeledSavedAsset::from_labeled_asset)
+                    .collect(),
+            ),
+            label_to_asset_index: Moo::Owned(
+                asset
+                    .label_to_asset_index
+                    .iter()
+                    .map(|(label, &index)| (CowArc::Borrowed(label.borrow()), index))
                     .collect(),
             ),
+            asset_id_to_asset_index: Moo::Borrowed(&asset.asset_id_to_asset_index),
         }
     }
 }
@@ -239,6 +303,8 @@ impl<'a> ErasedSavedAsset<'a, '_> {
         Some(SavedAsset::from_value_and_labeled_saved_assets(
             value,
             &self.labeled_assets,
+            &self.label_to_asset_index,
+            &self.asset_id_to_asset_index,
         ))
     }
 }
@@ -268,7 +334,14 @@ impl<'a> LabeledSavedAsset<'a> {
 /// This is commonly used in tandem with [`save_using_saver`].
 pub struct SavedAssetBuilder<'a> {
     /// The labeled assets for this saved asset.
-    labeled_assets: HashMap<CowArc<'a, str>, LabeledSavedAsset<'a>>,
+    labeled_assets: Vec<LabeledSavedAsset<'a>>,
+    /// Maps the labels of subassets to their index in [`Self::labeled_assets`].
+    label_to_asset_index: HashMap<CowArc<'a, str>, usize>,
+    /// The mapping from a subasset asset IDs to their index in [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,
     /// The asset path (with no label) that this saved asset is "tied" to.
     ///
     /// All labeled assets will use this asset path (with their substituted labels). Note labeled
@@ -288,6 +361,8 @@ impl<'a> SavedAssetBuilder<'a> {
             asset_server,
             asset_path,
             labeled_assets: Default::default(),
+            label_to_asset_index: Default::default(),
+            asset_id_to_asset_index: Default::default(),
         }
     }
 
@@ -379,8 +454,25 @@ impl<'a> SavedAssetBuilder<'a> {
         handle: UntypedHandle,
     ) {
         // TODO: Check asset and handle have the same type.
-        self.labeled_assets
-            .insert(label.into(), LabeledSavedAsset { asset, handle });
+        let labeled = LabeledSavedAsset { asset, handle };
+        match self.label_to_asset_index.entry(label.into()) {
+            Entry::Occupied(entry) => {
+                let labeled_entry = &mut self.labeled_assets[*entry.get()];
+                if labeled.handle != labeled_entry.handle {
+                    self.asset_id_to_asset_index
+                        .remove(&labeled_entry.handle.id());
+                    self.asset_id_to_asset_index
+                        .insert(labeled.handle.id(), *entry.get());
+                }
+                *labeled_entry = labeled;
+            }
+            Entry::Vacant(entry) => {
+                entry.insert(self.labeled_assets.len());
+                self.asset_id_to_asset_index
+                    .insert(labeled.handle.id(), self.labeled_assets.len());
+                self.labeled_assets.push(labeled);
+            }
+        }
     }
 
     /// Creates the final saved asset from this builder.
@@ -391,6 +483,8 @@ impl<'a> SavedAssetBuilder<'a> {
         SavedAsset {
             value: asset,
             labeled_assets: Moo::Owned(self.labeled_assets),
+            label_to_asset_index: Moo::Owned(self.label_to_asset_index),
+            asset_id_to_asset_index: Moo::Owned(self.asset_id_to_asset_index),
         }
     }
 }
@@ -568,7 +662,7 @@ pub(crate) mod tests {
 
         let saved_asset = saved_asset_builder.build(&main_asset);
         let mut asset_labels = saved_asset
-            .labeled_assets
+            .label_to_asset_index
             .keys()
             .map(|label| label.as_ref().to_string())
             .collect::<Vec<_>>();
@@ -658,7 +752,7 @@ pub(crate) mod tests {
 
         let saved_asset = saved_asset_builder.build(cool_texts.get(&cool_text_handle).unwrap());
         let mut asset_labels = saved_asset
-            .labeled_assets
+            .label_to_asset_index
             .keys()
             .map(|label| label.as_ref().to_string())
             .collect::<Vec<_>>();
diff --git a/crates/bevy_asset/src/server/info.rs b/crates/bevy_asset/src/server/info.rs
index 37f727870be00..4d93e0d93fe4e 100644
--- a/crates/bevy_asset/src/server/info.rs
+++ b/crates/bevy_asset/src/server/info.rs
@@ -406,7 +406,7 @@ impl AssetInfos {
     ) {
         // Process all the labeled assets first so that they don't get skipped due to the "parent"
         // not having its handle alive.
-        for (_, asset) in loaded_asset.labeled_assets {
+        for asset in loaded_asset.labeled_assets {
             let UntypedHandle::Strong(handle) = &asset.handle else {
                 unreachable!("Labeled assets are always strong handles");
             };
diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs
index 92d0cfa677323..1219135275858 100644
--- a/crates/bevy_asset/src/server/mod.rs
+++ b/crates/bevy_asset/src/server/mod.rs
@@ -838,8 +838,9 @@ impl AssetServer {
         {
             Ok(loaded_asset) => {
                 let final_handle = if let Some(label) = path.label_cow() {
-                    match loaded_asset.labeled_assets.get(&label) {
+                    match loaded_asset.label_to_asset_index.get(&label) {
                         Some(labeled_asset) => {
+                            let labeled_asset = &loaded_asset.labeled_assets[*labeled_asset];
                             // If we know the requested type then check it
                             // matches the labeled asset.
                             if let Some(asset_id) = asset_id
@@ -862,7 +863,7 @@ impl AssetServer {
                         }
                         None => {
                             let mut all_labels: Vec<String> = loaded_asset
-                                .labeled_assets
+                                .label_to_asset_index
                                 .keys()
                                 .map(|s| (**s).to_owned())
                                 .collect();
diff --git a/crates/bevy_asset/src/transformer.rs b/crates/bevy_asset/src/transformer.rs
index 575efbfbaa8eb..73b940cfc2187 100644
--- a/crates/bevy_asset/src/transformer.rs
+++ b/crates/bevy_asset/src/transformer.rs
@@ -1,7 +1,10 @@
-use crate::{meta::Settings, Asset, ErasedLoadedAsset, Handle, LabeledAsset, UntypedHandle};
-use alloc::boxed::Box;
+use crate::{
+    meta::Settings, Asset, AssetId, ErasedLoadedAsset, Handle, LabeledAsset, UntypedAssetId,
+    UntypedHandle,
+};
+use alloc::{boxed::Box, vec::Vec};
 use atomicow::CowArc;
-use bevy_platform::collections::HashMap;
+use bevy_platform::collections::{hash_map::Entry, HashMap};
 use bevy_reflect::TypePath;
 use bevy_tasks::ConditionalSendFuture;
 use core::{
@@ -39,7 +42,13 @@ pub trait AssetTransformer: TypePath + Send + Sync + 'static {
 /// An [`Asset`] (and any "sub assets") intended to be transformed
 pub struct TransformedAsset<A: Asset> {
     pub(crate) value: A,
-    pub(crate) labeled_assets: HashMap<CowArc<'static, str>, LabeledAsset>,
+    pub(crate) labeled_assets: Vec<LabeledAsset>,
+    pub(crate) label_to_asset_index: HashMap<CowArc<'static, str>, usize>,
+    /// The mapping from a subasset asset IDs to their index in [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    pub(crate) asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,
 }
 
 impl<A: Asset> Deref for TransformedAsset<A> {
@@ -62,74 +71,135 @@ impl<A: Asset> TransformedAsset<A> {
             return Some(TransformedAsset {
                 value: *value,
                 labeled_assets: asset.labeled_assets,
+                label_to_asset_index: asset.label_to_asset_index,
+                asset_id_to_asset_index: asset.asset_id_to_asset_index,
             });
         }
         None
     }
+
     /// Creates a new [`TransformedAsset`] from `asset`, transferring the `labeled_assets` from this [`TransformedAsset`] to the new one
     pub fn replace_asset<B: Asset>(self, asset: B) -> TransformedAsset<B> {
         TransformedAsset {
             value: asset,
             labeled_assets: self.labeled_assets,
+            label_to_asset_index: self.label_to_asset_index,
+            asset_id_to_asset_index: self.asset_id_to_asset_index,
         }
     }
+
     /// Takes the labeled assets from `labeled_source` and places them in this [`TransformedAsset`]
     pub fn take_labeled_assets<B: Asset>(&mut self, labeled_source: TransformedAsset<B>) {
         self.labeled_assets = labeled_source.labeled_assets;
+        self.label_to_asset_index = labeled_source.label_to_asset_index;
+        self.asset_id_to_asset_index = labeled_source.asset_id_to_asset_index;
     }
+
     /// Retrieves the value of this asset.
     #[inline]
     pub fn get(&self) -> &A {
         &self.value
     }
+
     /// Mutably retrieves the value of this asset.
     #[inline]
     pub fn get_mut(&mut self) -> &mut A {
         &mut self.value
     }
+
     /// Returns the labeled asset, if it exists and matches this type.
     pub fn get_labeled<B: Asset, Q>(&mut self, label: &Q) -> Option<TransformedSubAsset<'_, B>>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get_mut(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &mut self.labeled_assets[*index];
         let value = labeled.asset.value.downcast_mut::<B>()?;
         Some(TransformedSubAsset {
             value,
             labeled_assets: &mut labeled.asset.labeled_assets,
+            label_to_asset_index: &mut labeled.asset.label_to_asset_index,
+            asset_id_to_asset_index: &mut labeled.asset.asset_id_to_asset_index,
         })
     }
-    /// Returns the type-erased labeled asset, if it exists and matches this type.
+
+    /// Returns the type-erased labeled asset, if it exists.
     pub fn get_erased_labeled<Q>(&self, label: &Q) -> Option<&ErasedLoadedAsset>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &self.labeled_assets[*index];
         Some(&labeled.asset)
     }
+
+    /// Returns the labeled asset given its asset ID if it exists and matches the type.
+    ///
+    /// This can be used to get the asset from its handle since `&Handle` implements
+    /// [`Into<AssetId<B>>`].
+    pub fn get_labeled_by_id<B: Asset, Q>(
+        &mut self,
+        id: impl Into<AssetId<B>>,
+    ) -> Option<TransformedSubAsset<'_, B>>
+    where
+        CowArc<'static, str>: Borrow<Q>,
+        Q: ?Sized + Hash + Eq,
+    {
+        let index = self.asset_id_to_asset_index.get(&id.into().untyped())?;
+        let labeled = &mut self.labeled_assets[*index];
+        let value = labeled.asset.value.downcast_mut::<B>()?;
+        Some(TransformedSubAsset {
+            value,
+            labeled_assets: &mut labeled.asset.labeled_assets,
+            label_to_asset_index: &mut labeled.asset.label_to_asset_index,
+            asset_id_to_asset_index: &mut labeled.asset.asset_id_to_asset_index,
+        })
+    }
+
+    /// Returns the type-erased labeled asset, if it exists.
+    ///
+    /// This can be used to get the asset from its handle since `&UntypedHandle` implements
+    /// [`Into<UntypedAssetId>`].
+    pub fn get_erased_labeled_by_id<Q>(
+        &self,
+        id: impl Into<UntypedAssetId>,
+    ) -> Option<&ErasedLoadedAsset>
+    where
+        CowArc<'static, str>: Borrow<Q>,
+        Q: ?Sized + Hash + Eq,
+    {
+        let index = self.asset_id_to_asset_index.get(&id.into())?;
+        let labeled = &self.labeled_assets[*index];
+        Some(&labeled.asset)
+    }
+
     /// Returns the [`UntypedHandle`] of the labeled asset with the provided 'label', if it exists.
     pub fn get_untyped_handle<Q>(&self, label: &Q) -> Option<UntypedHandle>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &self.labeled_assets[*index];
         Some(labeled.handle.clone())
     }
+
     /// Returns the [`Handle`] of the labeled asset with the provided 'label', if it exists and is an asset of type `B`
     pub fn get_handle<Q, B: Asset>(&self, label: &Q) -> Option<Handle<B>>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &self.labeled_assets[*index];
         if let Ok(handle) = labeled.handle.clone().try_typed::<B>() {
             return Some(handle);
         }
         None
     }
+
     /// Adds `asset` as a labeled sub asset using `label` and `handle`
     pub fn insert_labeled(
         &mut self,
@@ -141,18 +211,42 @@ impl<A: Asset> TransformedAsset<A> {
             asset: asset.into(),
             handle: handle.into(),
         };
-        self.labeled_assets.insert(label.into(), labeled);
+        match self.label_to_asset_index.entry(label.into()) {
+            Entry::Occupied(entry) => {
+                let labeled_entry = &mut self.labeled_assets[*entry.get()];
+                if labeled.handle != labeled_entry.handle {
+                    self.asset_id_to_asset_index
+                        .remove(&labeled_entry.handle.id());
+                    self.asset_id_to_asset_index
+                        .insert(labeled.handle.id(), *entry.get());
+                }
+                *labeled_entry = labeled;
+            }
+            Entry::Vacant(entry) => {
+                entry.insert(self.labeled_assets.len());
+                self.asset_id_to_asset_index
+                    .insert(labeled.handle.id(), self.labeled_assets.len());
+                self.labeled_assets.push(labeled);
+            }
+        }
     }
+
     /// Iterate over all labels for "labeled assets" in the loaded asset
     pub fn iter_labels(&self) -> impl Iterator<Item = &str> {
-        self.labeled_assets.keys().map(|s| &**s)
+        self.label_to_asset_index.keys().map(|s| &**s)
     }
 }
 
 /// A labeled sub-asset of [`TransformedAsset`]
 pub struct TransformedSubAsset<'a, A: Asset> {
     value: &'a mut A,
-    labeled_assets: &'a mut HashMap<CowArc<'static, str>, LabeledAsset>,
+    labeled_assets: &'a mut Vec<LabeledAsset>,
+    label_to_asset_index: &'a mut HashMap<CowArc<'static, str>, usize>,
+    /// The mapping from a subasset asset IDs to their index in [`Self::labeled_assets`].
+    ///
+    /// This is entirely redundant with [`Self::labeled_assets`], but it allows looking up the
+    /// labeled asset by its asset ID.
+    asset_id_to_asset_index: &'a mut HashMap<UntypedAssetId, usize>,
 }
 
 impl<'a, A: Asset> Deref for TransformedSubAsset<'a, A> {
@@ -175,61 +269,116 @@ impl<'a, A: Asset> TransformedSubAsset<'a, A> {
         Some(TransformedSubAsset {
             value,
             labeled_assets: &mut asset.labeled_assets,
+            label_to_asset_index: &mut asset.label_to_asset_index,
+            asset_id_to_asset_index: &mut asset.asset_id_to_asset_index,
         })
     }
+
     /// Retrieves the value of this asset.
     #[inline]
     pub fn get(&self) -> &A {
         self.value
     }
+
     /// Mutably retrieves the value of this asset.
     #[inline]
     pub fn get_mut(&mut self) -> &mut A {
         self.value
     }
+
     /// Returns the labeled asset, if it exists and matches this type.
     pub fn get_labeled<B: Asset, Q>(&mut self, label: &Q) -> Option<TransformedSubAsset<'_, B>>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get_mut(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &mut self.labeled_assets[*index];
         let value = labeled.asset.value.downcast_mut::<B>()?;
         Some(TransformedSubAsset {
             value,
             labeled_assets: &mut labeled.asset.labeled_assets,
+            label_to_asset_index: &mut labeled.asset.label_to_asset_index,
+            asset_id_to_asset_index: &mut labeled.asset.asset_id_to_asset_index,
         })
     }
-    /// Returns the type-erased labeled asset, if it exists and matches this type.
+
+    /// Returns the type-erased labeled asset, if it exists.
     pub fn get_erased_labeled<Q>(&self, label: &Q) -> Option<&ErasedLoadedAsset>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &self.labeled_assets[*index];
         Some(&labeled.asset)
     }
+
+    /// Returns the labeled asset given its asset ID if it exists and matches the type.
+    ///
+    /// This can be used to get the asset from its handle since `&Handle` implements
+    /// [`Into<AssetId<B>>`].
+    pub fn get_labeled_by_id<B: Asset, Q>(
+        &mut self,
+        id: impl Into<AssetId<B>>,
+    ) -> Option<TransformedSubAsset<'_, B>>
+    where
+        CowArc<'static, str>: Borrow<Q>,
+        Q: ?Sized + Hash + Eq,
+    {
+        let index = self.asset_id_to_asset_index.get(&id.into().untyped())?;
+        let labeled = &mut self.labeled_assets[*index];
+        let value = labeled.asset.value.downcast_mut::<B>()?;
+        Some(TransformedSubAsset {
+            value,
+            labeled_assets: &mut labeled.asset.labeled_assets,
+            label_to_asset_index: &mut labeled.asset.label_to_asset_index,
+            asset_id_to_asset_index: &mut labeled.asset.asset_id_to_asset_index,
+        })
+    }
+
+    /// Returns the type-erased labeled asset given its asset ID if it exists.
+    ///
+    /// This can be used to get the asset from its handle since `&UntypedHandle` implements
+    /// [`Into<UntypedAssetId>`].
+    pub fn get_erased_labeled_by_id<Q>(
+        &self,
+        id: impl Into<UntypedAssetId>,
+    ) -> Option<&ErasedLoadedAsset>
+    where
+        CowArc<'static, str>: Borrow<Q>,
+        Q: ?Sized + Hash + Eq,
+    {
+        let index = self.asset_id_to_asset_index.get(&id.into())?;
+        let labeled = &self.labeled_assets[*index];
+        Some(&labeled.asset)
+    }
+
     /// Returns the [`UntypedHandle`] of the labeled asset with the provided 'label', if it exists.
     pub fn get_untyped_handle<Q>(&self, label: &Q) -> Option<UntypedHandle>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &self.labeled_assets[*index];
         Some(labeled.handle.clone())
     }
+
     /// Returns the [`Handle`] of the labeled asset with the provided 'label', if it exists and is an asset of type `B`
     pub fn get_handle<Q, B: Asset>(&self, label: &Q) -> Option<Handle<B>>
     where
         CowArc<'static, str>: Borrow<Q>,
         Q: ?Sized + Hash + Eq,
     {
-        let labeled = self.labeled_assets.get(label)?;
+        let index = self.label_to_asset_index.get(label)?;
+        let labeled = &self.labeled_assets[*index];
         if let Ok(handle) = labeled.handle.clone().try_typed::<B>() {
             return Some(handle);
         }
         None
     }
+
     /// Adds `asset` as a labeled sub asset using `label` and `handle`
     pub fn insert_labeled(
         &mut self,
@@ -241,11 +390,28 @@ impl<'a, A: Asset> TransformedSubAsset<'a, A> {
             asset: asset.into(),
             handle: handle.into(),
         };
-        self.labeled_assets.insert(label.into(), labeled);
+        match self.label_to_asset_index.entry(label.into()) {
+            Entry::Occupied(entry) => {
+                let labeled_entry = &mut self.labeled_assets[*entry.get()];
+                if labeled.handle != labeled_entry.handle {
+                    self.asset_id_to_asset_index
+                        .remove(&labeled_entry.handle.id());
+                    self.asset_id_to_asset_index
+                        .insert(labeled.handle.id(), *entry.get());
+                }
+                *labeled_entry = labeled;
+            }
+            Entry::Vacant(entry) => {
+                entry.insert(self.labeled_assets.len());
+                self.asset_id_to_asset_index
+                    .insert(labeled.handle.id(), self.labeled_assets.len());
+                self.labeled_assets.push(labeled);
+            }
+        }
     }
     /// Iterate over all labels for "labeled assets" in the loaded asset
     pub fn iter_labels(&self) -> impl Iterator<Item = &str> {
-        self.labeled_assets.keys().map(|s| &**s)
+        self.label_to_asset_index.keys().map(|s| &**s)
     }
 }
 
diff --git a/examples/asset/asset_saving.rs b/examples/asset/asset_saving.rs
index 4ec5cff19bdb7..6ab540eaab5a2 100644
--- a/examples/asset/asset_saving.rs
+++ b/examples/asset/asset_saving.rs
@@ -176,17 +176,13 @@ impl AssetSaver for ManyBoxesSaver {
             .boxes
             .iter()
             .map(|handle| {
-                // TODO: We should have a better to get the asset for a subasset handle.
-                let label = handle
-                    .path()
-                    .and_then(|path| path.label())
-                    .ok_or_else(|| format!("Failed to get label for handle {handle:?}"))?;
                 asset
-                    .get_labeled::<OneBox>(label)
-                    .map(|subasset| subasset.get().clone())
-                    .ok_or_else(|| format!("Failed to find labeled asset for label {label}"))
+                    .get_labeled_by_id::<OneBox>(handle)
+                    .unwrap()
+                    .get()
+                    .clone()
             })
-            .collect::<Result<Vec<_>, _>>()?;
+            .collect();
 
         // Note: serializing to string isn't ideal since we can't do a streaming write, but this is
         // fine for an example.
