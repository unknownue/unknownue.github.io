+++
title = "#22864 Revive `iter_entities()` when you only have immutable `World` access ‚ù§Ô∏è‚Äçü©π"
date = "2026-02-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22864-en-20260208" }, "zh-cn" = { name = "‰∏≠Êñá", url = "/pull_request/bevy/2026-02/pr-22864-zh-cn-20260208" }}
labels = ["C-Feature", "A-ECS", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Revive `iter_entities()` when you only have immutable `World` access ‚ù§Ô∏è‚Äçü©π 
- **PR Link**: https://github.com/bevyengine/bevy/pull/22864
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: C-Feature, A-ECS, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-02-08T05:58:24Z
- **Merged**: 2026-02-08T18:56:35Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective
- Closes #22657 

## Solution
- Exhumes what was previously deprecated and deleted üßü. `iter_entities()` is back as an ergonomic way to non-fallibly iterate through all the entities when you only have immutable `World` access.
- I didn't implement `iter_entities()` on `Entities` because it seems deliberate from conversation in #6228 ‚Ä¶ although I could be convinced otherwise if the conversation is outdated.

## Testing
- I exhumed the previous ci test

## The Story of This Pull Request

This PR addresses a specific ergonomic issue in Bevy's ECS system: the need for a simple way to iterate over all entities when you only have read-only access to the `World`. The problem originated from issue #22657, where developers were looking for an alternative to the previously deprecated `iter_entities()` method.

The context is straightforward: when working with Bevy's ECS, there are often situations where you need to process all entities in a world, but you only have immutable (read-only) access. Prior to this change, developers would need to use `world.query::<EntityRef>().iter(&world)`, which is more verbose and requires creating a query object. The older `iter_entities()` method had been removed entirely, leaving a gap in the API for this common use case.

The developer took a pragmatic approach to solving this problem by simply reviving the previously existing implementation. The solution involves adding a new method to the `World` struct that returns an iterator over all entities. The implementation efficiently traverses all archetypes in the world, then for each archetype, iterates through its entities and creates `EntityRef` objects for each one.

Here's how the implementation works technically:

```rust
pub fn iter_entities(&self) -> impl Iterator<Item = EntityRef<'_>> + '_ {
    self.archetypes.iter().flat_map(|archetype| {
        archetype
            .entities_with_location()
            .map(|(entity, location)| {
                // SAFETY: entity exists and location accurately specifies the archetype where the entity is stored.
                let cell = UnsafeEntityCell::new(
                    self.as_unsafe_world_cell_readonly(),
                    entity,
                    location,
                    self.last_change_tick,
                    self.read_change_tick(),
                );
                // SAFETY: `&self` gives read access to the entire world.
                unsafe { EntityRef::new(cell) }
            })
    })
}
```

The implementation uses `flat_map` to combine iterators from all archetypes. For each entity, it creates an `UnsafeEntityCell` using the entity's location information, then converts that to an `EntityRef`. The safety comments are important here - they document why the unsafe blocks are justified: the entity exists and the location accurately specifies where it's stored, and we have read access to the entire world.

The developer made a deliberate design choice: they didn't add `iter_entities()` to the `Entities` struct, referencing conversation in PR #6228. This suggests there was a previous decision to keep this functionality at the `World` level rather than the `Entities` level. This maintains consistency with the existing API design patterns.

For testing, the developer reused the previous test from when the method existed before. The test is comprehensive, covering:
- Iterating over a single entity
- Adding multiple entities
- Removing entities via despawning
- Edge cases with empty worlds

The test uses a `HashMap` to count entity occurrences, ensuring each entity appears exactly once in the iteration. This validates that the iterator correctly handles entity lifecycle operations (spawning and despawning).

The impact of this change is primarily ergonomic: it provides a cleaner, more intuitive API for a common operation. Developers can now write `world.iter_entities()` instead of the more verbose `world.query::<EntityRef>().iter(&world)`. This reduces boilerplate and makes code more readable, especially for beginners or in situations where you're just exploring the entities in a world without needing to filter by components.

One technical insight from this implementation is the use of `UnsafeEntityCell` and `EntityRef`. `EntityRef` provides a safe interface to entity data, while `UnsafeEntityCell` handles the unsafe world access. This pattern is common in Bevy's ECS system, separating safety concerns between layers.

The change is minimal and focused - only 96 lines added and 2 lines removed, with most of the addition being the test code. This makes it a low-risk addition to the codebase that restores functionality many developers found useful.

## Visual Representation

```mermaid
graph TD
    A[World.iter_entities()] --> B[Iterate over Archetypes]
    B --> C[For each Archetype]
    C --> D[Iterate entities_with_location]
    D --> E[Create UnsafeEntityCell]
    E --> F[Create EntityRef]
    F --> G[Yield EntityRef]
```

## Key Files Changed

**File: `crates/bevy_ecs/src/world/mod.rs` (+96/-2)**

1. **Added `iter_entities()` method to `World` struct**: The main implementation that returns an iterator over all entities in the world.

```rust
// Added method:
pub fn iter_entities(&self) -> impl Iterator<Item = EntityRef<'_>> + '_ {
    self.archetypes.iter().flat_map(|archetype| {
        archetype
            .entities_with_location()
            .map(|(entity, location)| {
                // SAFETY: entity exists and location accurately specifies the archetype where the entity is stored.
                let cell = UnsafeEntityCell::new(
                    self.as_unsafe_world_cell_readonly(),
                    entity,
                    location,
                    self.last_change_tick,
                    self.read_change_tick(),
                );
                // SAFETY: `&self` gives read access to the entire world.
                unsafe { EntityRef::new(cell) }
            })
    })
}
```

2. **Added import for `UnsafeEntityCell`**: Needed for creating entity references from immutable world access.

```rust
// Changed from:
use unsafe_world_cell::UnsafeWorldCell;

// To:
use unsafe_world_cell::{UnsafeEntityCell, UnsafeWorldCell};
```

3. **Added comprehensive test**: Validates the iterator works correctly with various entity operations.

```rust
#[test]
fn iterate_entities() {
    let mut world = World::new();
    let mut entity_counters = <HashMap<_, _>>::default();

    let iterate_and_count_entities = |world: &World, entity_counters: &mut HashMap<_, _>| {
        entity_counters.clear();
        for entity in world.iter_entities() {
            let counter = entity_counters.entry(entity.id()).or_insert(0);
            *counter += 1;
        }
    };

    // Test cases for spawning and despawning entities
    // ... (rest of test implementation)
}
```

4. **Added import for `HashMap` in tests**: Needed for the test implementation to count entity occurrences.

```rust
// Changed from:
use bevy_platform::collections::HashSet;

// To:
use bevy_platform::collections::{HashMap, HashSet};
```

## Further Reading

- [Bevy ECS Documentation](https://docs.rs/bevy_ecs/latest/bevy_ecs/) - Official documentation for Bevy's Entity Component System
- [Issue #22657](https://github.com/bevyengine/bevy/issues/22657) - The original issue requesting this functionality
- [PR #6228](https://github.com/bevyengine/bevy/pull/6228) - Previous discussion about `iter_entities()` implementation location
- [EntityRef Documentation](https://docs.rs/bevy_ecs/latest/bevy_ecs/world/struct.EntityRef.html) - Details on the `EntityRef` type returned by the iterator
- [UnsafeEntityCell Documentation](https://docs.rs/bevy_ecs/latest/bevy_ecs/world/struct.UnsafeEntityCell.html) - The unsafe building block used internally