+++
title = "#23077 The `testbed_ui` text scene should use a column layout"
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23077-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23077-zh-cn-20260224" }}
+++

# The `testbed_ui` text scene should use a column layout

## 基本信息
- **标题**: The `testbed_ui` text scene should use a column layout
- **PR链接**: https://github.com/bevyengine/bevy/pull/23077
- **作者**: kaio-matos
- **状态**: 已合并
- **标签**: A-UI, S-Ready-For-Final-Review, C-Testing, M-Deliberate-Rendering-Change
- **创建时间**: 2026-02-20T18:19:51Z
- **合并时间**: 2026-02-24T01:58:40Z
- **合并者**: alice-i-cecile

## 描述翻译

### 目标
移除每个文本元素不必要的绝对定位使用
修复 https://github.com/bevyengine/bevy/issues/22976

### 解决方案
使用具有两列的网格显示（display grid）来展示 `testbed_ui` 文本。
除此之外，我从每个文本元素中移除了 `DespawnOnExit(super::Scene::Text)`，只将其添加到父组件中。

### 测试
运行并按下一次空格：
```sh
cargo run --example testbed_ui
```

## 这个Pull Request的故事

这个PR的故事开始于Bevy引擎的UI测试场景（testbed_ui）中的一个实际问题。开发者注意到，在当前的实现中，文本场景使用了大量的绝对定位，每个文本元素都通过硬编码的坐标位置来布局。这种方法存在几个问题：代码重复、难以维护，并且不符合现代UI布局的最佳实践。

具体来说，每个文本元素都使用`Node`组件设置了`left`和`top`属性，通过像素值进行精确的绝对定位。虽然这种方法可以精确控制位置，但导致了大量的重复代码，每个元素都需要单独计算和设置坐标。更重要的是，当UI结构需要调整时，这种硬编码的方式会导致维护困难。

开发者选择的解决方案是采用更现代的布局方式——使用网格布局（grid layout）。通过创建一个父容器，配置为两列的网格（grid template columns），然后将文本元素组织到网格中，可以完全消除对绝对定位的依赖。这种方法的优势在于布局更加灵活，代码更加简洁，且更容易适应不同的屏幕尺寸或UI调整。

从技术实现角度来看，这个重构涉及几个关键变化。首先，创建了一个顶层的容器（container），使用`FlexDirection::Column`进行垂直布局。然后，在这个容器内部创建了一个网格布局（`Display::Grid`），配置为两列（`GridTrack::flex(1.0)`表示两列等宽）。最重要的是，通过`with_children` API将原有的文本元素重新组织到网格结构中。

另一个重要的优化是关于`DespawnOnExit`组件的使用。在原来的代码中，每个独立的文本实体都添加了`DespawnOnExit(super::Scene::Text)`组件。这种设计虽然功能正确，但存在不必要的冗余。开发者将`DespawnOnExit`移到了父容器上，这样当场景退出时，父容器及其所有子元素都会被正确销毁。这种改变符合Bevy的ECS（Entity Component System）哲学，即通过组件继承（component inheritance）或层级关系来管理实体的生命周期。

从代码结构的角度看，重构后的代码更加模块化。原来的代码使用了大量的硬编码位置计算：
```rust
let mut top = 230.;
let left = px(5. + if hinting == FontHinting::Disabled { 650. } else { 0. });
```
重构后，这些计算完全被网格布局所替代，布局逻辑更加清晰和声明式。

这个PR的技术洞察在于展示了Bevy UI系统的高级布局能力。通过使用网格布局，开发者可以利用引擎内置的布局系统来处理元素排列，而不是手动计算像素位置。这不仅提高了代码的可维护性，也为未来可能的UI调整提供了更大的灵活性。

从影响角度来看，这个PR主要改进了代码质量和可维护性，对功能没有实质性改变。用户运行`testbed_ui`示例时看到的效果应该与之前完全一致，但底层的实现更加健壮和现代。这个改变也作为Bevy UI系统最佳实践的一个示例，展示了如何正确使用网格布局和组件层级管理。

值得注意的工程决策是，开发者选择了网格布局而不是其他布局选项（如`FlexDirection::Row`的嵌套）。选择网格布局特别适合这种需要明确列结构的情况，其中需要并排显示两组相关的文本内容（`FontHinting::Enabled`和`FontHinting::Disabled`）。

## 可视化表示

```mermaid
graph TD
    A[Container<br/>FlexDirection: Column] --> B[Main Text<br/>"Hello World"]
    A --> C[Grid Container<br/>Display: Grid, 2 Columns]
    C --> D[Left Column<br/>FontHinting::Enabled]
    C --> E[Right Column<br/>FontHinting::Disabled]
    
    D --> F[Text Group 1]
    D --> G[Text Group 2]
    D --> H[Text Group 3]
    D --> I[...]
    
    E --> J[Text Group 1]
    E --> K[Text Group 2]
    E --> L[Text Group 3]
    E --> M[...]
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style E fill:#fff3e0
```

## 关键文件变更

### `examples/testbed/ui.rs` (+403/-444)

这个文件包含了`testbed_ui`示例中文本场景的所有代码。主要变化是从使用绝对定位改为使用网格布局，并优化了`DespawnOnExit`组件的使用。

**关键修改1：从绝对定位到网格布局**

**重构前**（简化示例）：
```rust
for hinting in [FontHinting::Enabled, FontHinting::Disabled] {
    let mut top = 230.;
    let left = px(5. + if hinting == FontHinting::Disabled { 650. } else { 0. });
    
    commands.spawn((
        Node {
            left,
            top: px(top),
            ..Default::default()
        },
        Text::new(format!("FontHinting::{:?}", hinting)),
        // ... 其他组件
        DespawnOnExit(super::Scene::Text),
    ));
    
    top += 30.;
    // 更多类似的绝对定位元素...
}
```

**重构后**：
```rust
let mut grid = builder.spawn(Node {
    display: Display::Grid,
    grid_template_columns: vec![GridTrack::flex(1.0), GridTrack::flex(1.0)],
    padding: UiRect::horizontal(px(5.)),
    ..default()
});

grid.with_children(|grid| {
    for hinting in [FontHinting::Enabled, FontHinting::Disabled] {
        let mut content = grid.spawn(Node {
            flex_direction: FlexDirection::Column,
            row_gap: px(5.),
            ..default()
        });
        
        content.with_child((
            Text::new(format!("FontHinting::{:?}", hinting)),
            // ... 其他组件
            // 注意：没有DespawnOnExit
        ));
        // ... 更多子元素
    }
});
```

**关键修改2：`DespawnOnExit`组件的优化**

**重构前**：每个文本实体都包含`DespawnOnExit(super::Scene::Text)`
**重构后**：只在父容器上添加一次`DespawnOnExit`

```rust
// 父容器设置
let mut container = commands.spawn((
    Node {
        flex_direction: FlexDirection::Column,
        ..default()
    },
    DespawnOnExit(super::Scene::Text), // 只在这里设置一次
));

// 子元素不再需要单独设置DespawnOnExit
container.with_child((
    Text::new("Hello World."),
    TextFont {
        font: asset_server.load("fonts/FiraSans-Bold.ttf").into(),
        font_size: FontSize::Px(200.),
        ..default()
    },
    // 注意：这里没有DespawnOnExit
));
```

这些变化使代码更简洁、更易于维护，并充分利用了Bevy的UI布局系统和ECS层级功能。

## 进一步阅读

对于想要深入了解相关概念的开发者，建议参考以下资源：

1. **Bevy UI布局文档**: 了解Bevy的UI布局系统，包括Flexbox和Grid布局
2. **ECS层级和继承**: 学习Bevy中实体组件的层级关系和继承机制
3. **Rust中的声明式UI**: 探索现代UI开发的声明式模式
4. **CSS Grid布局**: 虽然Bevy有自己的实现，但CSS Grid的概念对理解网格布局很有帮助

相关链接：
- [Bevy UI指南](https://bevy-cheatbook.github.io/)
- [Bevy ECS层级文档](https://docs.rs/bevy/latest/bevy/ecs/system/commands/struct.Commands.html#method.with_children)
- [网格布局概念](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout)