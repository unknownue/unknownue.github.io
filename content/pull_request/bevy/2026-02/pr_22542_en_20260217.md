+++
title = "#22542 Fix feature gating in `bevy_post_process`"
date = "2026-02-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22542-en-20260217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22542-zh-cn-20260217" }}
labels = ["C-Bug", "A-Rendering", "D-Straightforward"]
+++

# Fix feature gating in `bevy_post_process`

## Basic Information
- **Title**: Fix feature gating in `bevy_post_process`
- **PR Link**: https://github.com/bevyengine/bevy/pull/22542
- **Author**: beicause
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2026-01-16T08:06:03Z
- **Merged**: 2026-02-17T17:23:27Z
- **Merged By**: alice-i-cecile

## Description Translation
The features in `bevy_post_process` is never enabled. ~Bloom texture with mipmaps actually works on WebGL2~

## The Story of This Pull Request

This pull request addresses two related issues in the Bevy engine's post-processing system, specifically focusing on the bloom effect implementation. The problems stemmed from incomplete feature gating and platform-specific texture handling inconsistencies.

The initial problem was straightforward: the `bevy_post_process` crate's features weren't being properly enabled through the main `bevy_internal` crate's feature definitions. In the root `Cargo.toml`, the `trace`, `webgl`, and `webgpu` features didn't propagate to the post-processing module. This meant that when developers enabled these features at the project level, the post-processing system wouldn't receive the corresponding feature flags, potentially causing compilation issues or runtime behavior differences.

Looking deeper, a more subtle bug was discovered in the bloom effect's texture caching system. The bloom implementation uses bind group caching to avoid recreating GPU resources when they haven't changed. The cache key was originally constructed using a single texture ID, but this approach didn't account for WebGL's specific behavior. On WebGL targets without the `webgpu` feature enabled, the bloom system uses multiple textures stored in a vector, requiring a different cache key structure.

The solution involved two complementary fixes. First, the `Cargo.toml` was updated to properly forward the features to `bevy_post_process`. This ensures that feature-dependent code in the post-processing module compiles correctly when those features are enabled at the project level.

Second, the bloom module's cache key logic was refactored to handle platform differences. The `BloomBindGroups` struct and its initialization in `prepare_bloom_bind_groups` were modified with conditional compilation attributes. On non-WebGL platforms or when using WebGPU, the cache key remains a simple tuple of `(TextureId, BufferId)`. However, on WebGL targets without WebGPU, the cache key becomes `(Vec<TextureId>, BufferId)` to properly account for the texture array used in that configuration.

This conditional compilation approach maintains performance on platforms where a single texture ID suffices while providing correctness on WebGL. The implementation uses Rust's `cfg` attributes with feature and target architecture checks, ensuring each platform gets the appropriate data structure without runtime overhead.

The changes are minimal but important for two reasons. First, they ensure feature consistency across the engine - a critical consideration in a modular codebase like Bevy. Second, they fix a potential correctness issue where WebGL builds might use incorrect cached bind groups, leading to rendering artifacts or performance degradation from unnecessary bind group recreation.

From an engineering perspective, this PR demonstrates good practices in handling platform-specific code in graphics systems. The solution avoids runtime branching for performance-critical paths, uses conditional compilation appropriately, and maintains clean separation between different rendering backends. It also highlights the importance of thorough feature propagation in Rust workspace configurations, especially for graphics engines supporting multiple backends.

## Visual Representation

```mermaid
graph TD
    A[bevy_internal Cargo.toml] --> B[Feature Propagation]
    B --> C[trace feature]
    B --> D[webgl feature]
    B --> E[webgpu feature]
    C --> F[bevy_post_process/trace]
    D --> G[bevy_post_process/webgl]
    E --> H[bevy_post_process/webgpu]
    
    I[bevy_post_process bloom module] --> J[Platform Detection]
    J --> K[Non-WebGL/WebGPU]
    J --> L[WebGL without WebGPU]
    K --> M[Cache Key: (TextureId, BufferId)]
    L --> N[Cache Key: (Vec<TextureId>, BufferId)]
```

## Key Files Changed

### `crates/bevy_internal/Cargo.toml`
This file was updated to properly propagate feature flags to the `bevy_post_process` crate. Without these entries, enabling features like `trace`, `webgl`, or `webgpu` at the project level wouldn't activate the corresponding features in the post-processing module.

```toml
# Changes to feature definitions:
trace = [
  # ... existing entries ...
  "bevy_post_process?/trace",  # Added
]

webgl = [
  # ... existing entries ...
  "bevy_post_process?/webgl",  # Added
]

webgpu = [
  # ... existing entries ...
  "bevy_post_process?/webgpu",  # Added
]
```

### `crates/bevy_post_process/src/bloom/mod.rs`
This file contains the main logic fix for WebGL texture caching. The changes ensure that the bloom effect's bind group cache uses the correct key structure for each rendering backend.

1. **BloomBindGroups struct definition** - The cache key field now has two different types depending on platform:

```rust
// Before:
pub struct BloomBindGroups {
    cache_key: (TextureId, BufferId),
    // ... other fields
}

// After:
pub struct BloomBindGroups {
    #[cfg(any(
        not(feature = "webgl"),
        not(target_arch = "wasm32"),
        feature = "webgpu"
    ))]
    cache_key: (TextureId, BufferId),
    #[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
    cache_key: (Vec<TextureId>, BufferId),
    // ... other fields
}
```

2. **prepare_bloom_bind_groups function** - Updated to create the appropriate cache key based on platform:

```rust
// Before:
let cache_key = (
    bloom_texture.texture.texture.id(),
    uniforms.buffer().unwrap().id(),
);

// After:
#[cfg(any(
    not(feature = "webgl"),
    not(target_arch = "wasm32"),
    feature = "webgpu"
))]
let cache_key = (
    bloom_texture.texture.texture.id(),
    uniforms.buffer().unwrap().id(),
);
#[cfg(all(feature = "webgl", target_arch = "wasm32", not(feature = "webgpu")))]
let cache_key = (
    bloom_texture
        .texture
        .iter()
        .map(|tex| tex.texture.id())
        .collect(),
    uniforms.buffer().unwrap().id(),
);
```

These changes work together: the Cargo.toml updates ensure features are properly enabled, while the bloom module changes ensure correct cache key generation for each rendering backend configuration.

## Further Reading

- [Bevy's Rendering Architecture](https://bevyengine.org/learn/book/getting-started/rendering/) - Official documentation on Bevy's rendering system
- [Rust Conditional Compilation](https://doc.rust-lang.org/reference/conditional-compilation.html) - Reference for `#[cfg]` attributes used in this PR
- [WebGL vs WebGPU in Bevy](https://bevyengine.org/learn/book/getting-started/setup/#web-assembly) - Platform targeting in Bevy
- [Bind Groups in Graphics Programming](https://github.com/gfx-rs/wgpu/wiki/BindGroups) - Concept explanation from wgpu documentation