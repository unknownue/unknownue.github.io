+++
title = "#23082 building bevy with only feature bevy_input_focus fails"
date = "2026-02-21T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23082-en-20260221" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23082-zh-cn-20260221" }}
labels = ["C-Bug", "D-Trivial", "A-UI"]
+++

# Title

## Basic Information
- **Title**: building bevy with only feature bevy_input_focus fails
- **PR Link**: https://github.com/bevyengine/bevy/pull/23082
- **Author**: mockersf
- **Status**: MERGED
- **Labels**: C-Bug, D-Trivial, A-UI, S-Ready-For-Final-Review
- **Created**: 2026-02-20T21:12:00Z
- **Merged**: 2026-02-21T01:03:16Z
- **Merged By**: alice-i-cecile

## Description Translation
目标：
- `cargo build --features bevy_input_focus --no-default-features` 构建失败，报错：
```
error[E0599]: no method named `sqrt` found for type `f32` in the current scope
   --> crates/bevy_input_focus/src/navigator.rs:112:40
    |
112 |     let distance = (dx * dx + dy * dy).sqrt();
    |                                        ^^^^ method not found in `f32`
```

解决方案：
- 使用来自 `bevy_math` 的 `sqrt` 函数。

## The Story of This Pull Request

这个PR的故事始于一个具体的构建错误。开发者尝试使用命令 `cargo build --features bevy_input_focus --no-default-features` 编译 Bevy 引擎时，构建过程失败了。这个命令的含义是只启用 `bevy_input_focus` 这一个功能（feature），并禁用所有默认功能。编译器的错误信息直指问题核心：在 `navigator.rs` 文件的第112行，代码试图在 `f32` 类型上调用 `.sqrt()` 方法，但编译器在当前作用域内找不到这个方法。

在Rust中，为基本类型（如 `f32`、`f64`）实现的方法（比如数学运算）通常来自标准库 `std` 或者核心库 `core`。然而，这里的问题与条件编译（conditional compilation）有关。当使用 `--no-default-features` 标志时，`bevy_input_focus` 模块被独立编译，它可能没有引入通常通过其他默认功能（如 `bevy_math`）提供的必要的 trait 实现。具体来说，`f32` 的 `.sqrt()` 方法是通过 `std` 的 `f32` 类型自带的，但在某些严格的 `no_std` 或特定特性配置环境下，其直接的 trait 实现可能不可见或未被引入。更常见且保险的做法是使用 Bevy 自己的数学库 `bevy_math` 提供的函数，它封装了这些操作并确保了跨不同特性配置的一致性。

问题的解决方案非常直接，体现了软件工程中一个常见的模式：当某个功能依赖一个可能因配置不同而变得不可用的隐式实现时，最佳实践是显式地依赖一个稳定的、受控的接口。开发者没有试图去调整复杂的特性依赖或条件编译属性，而是简单地修改了一行代码。将原先对 `f32` 原生方法的调用 `(dx * dx + dy * dy).sqrt()`，替换为对 `bevy_math::ops::sqrt` 函数的显式调用。

这个改动很小，但很重要。它确保了 `bevy_input_focus` 模块在作为独立功能编译时，其功能不依赖于隐式的、可能因编译环境而变化的 trait 实现。`bevy_math::ops::sqrt` 函数被设计为在各种配置下都可用，它提供了 `f32` 平方根运算的一个稳定抽象层。通过这个改动，模块的编译不再依赖于是否通过其他特性间接引入了 `std` 中 `f32` 的完整方法集，而是明确地声明了对 `bevy_math` crate 中特定功能的依赖。

从工程角度看，这次修复强调了在模块化、可配置的大型项目中管理依赖关系的重要性。它展示了如何处理因条件编译导致的“隐式依赖缺失”问题。修复方案是低风险且高效的，仅更改一行代码就解决了构建阻塞问题，没有引入新的逻辑或影响现有功能，因此可以被快速审查和合并。

## Visual Representation

```mermaid
graph TD
    subgraph "Before Fix"
        A[bevy_input_focus] -- Implicitly depends on --> B[std's f32 impl]
        B -- .sqrt() method may be missing under --no-default-features --> C[Build Failure]
    end

    subgraph "After Fix"
        D[bevy_input_focus] -- Explicitly calls --> E[bevy_math::ops::sqrt]
        E -- Provides stable sqrt function --> F[Successful Build]
    end
```

## Key Files Changed

- `crates/bevy_input_focus/src/navigator.rs` (+1/-1)

这个文件包含了修复构建错误的唯一修改。`navigator.rs` 中的 `score_candidate` 函数用于计算UI导航中焦点候选元素的分数，其中需要计算两个矩形之间的欧几里得距离。

1.  **修改内容与原因**：
    修改将距离计算中的平方根操作，从依赖 `f32` 的原生方法改为使用 `bevy_math` crate 提供的显式函数。这确保了在仅启用 `bevy_input_focus` 特性时，必要的数学运算依然可用。

2.  **代码修改对比**：
    ```rust
    // File: crates/bevy_input_focus/src/navigator.rs
    // Before (Line 112):
    let distance = (dx * dx + dy * dy).sqrt();
    
    // After:
    let distance = bevy_math::ops::sqrt(dx * dx + dy * dy);
    ```

3.  **与PR目标的关联**：
    这行代码的修改直接解决了PR描述中提到的构建错误，是本次PR的核心所在。

## Further Reading

1.  **Rust 条件编译（Conditional Compilation）**:
    - Rust 官方文档关于 `#[cfg]` 属性的章节对于理解特性（features）如何控制代码编译很有帮助。

2.  **Bevy 引擎的特性系统**:
    - 查看 Bevy 项目的 `Cargo.toml` 文件可以了解其如何定义默认特性和可选特性，这有助于理解模块间的依赖关系。

3.  **Rust 的 Orphan Rule 和 Trait 实现**:
    - 深入理解 Rust 的 trait 一致性规则（orphan rule）可以解释为何在某些情况下不能轻易地为外部类型（如 `f32`）添加 trait 实现，从而理解为何需要像 `bevy_math` 这样的封装层。

# Full Code Diff
diff --git a/crates/bevy_input_focus/src/navigator.rs b/crates/bevy_input_focus/src/navigator.rs
index 2e984b0088beb..d5504652b1432 100644
--- a/crates/bevy_input_focus/src/navigator.rs
+++ b/crates/bevy_input_focus/src/navigator.rs
@@ -109,7 +109,7 @@ fn score_candidate(
     let dy = (candidate_rect.min.y - origin_rect.max.y)
         .max(origin_rect.min.y - candidate_rect.max.y)
         .max(0.0);
-    let distance = (dx * dx + dy * dy).sqrt();
+    let distance = bevy_math::ops::sqrt(dx * dx + dy * dy);
 
     // Check max distance
     if let Some(max_dist) = config.max_search_distance {