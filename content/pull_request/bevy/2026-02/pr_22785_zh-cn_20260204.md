+++
title = "#22785 Fix off-by-one in alloc_many unintentionally allocating fresh indices"
date = "2026-02-04T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22785-en-20260204" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22785-zh-cn-20260204" }}
+++

# Title

## 基本信息
- **标题**: Fix off-by-one in alloc_many unintentionally allocating fresh indices
- **PR链接**: https://github.com/bevyengine/bevy/pull/22785
- **作者**: nickbabcock
- **状态**: 已合并
- **标签**: C-Bug, A-ECS, S-Ready-For-Final-Review, P-Regression
- **创建时间**: 2026-02-03T00:10:34Z
- **合并时间**: 2026-02-04T00:21:34Z
- **合并人**: alice-i-cecile

## 描述翻译
### 目标

目前 `alloc_many` 方法中存在一个差一错误（off-by-one bug）。当 `current_len == free.len()` 时，`spawn_batch` 会分配新的索引而不是重用已释放的索引。

我认为这个 bug 在 `main` 分支上不存在，因此这个 PR 目标是针对 0.18.1 版本。如果有更好的方法来引入这个修改，请告诉我。

### 测试
- 单元测试覆盖了这个 bug（即：撤销这个修改会导致测试失败）。

---

## 这个Pull Request的故事

这个 PR 修复了 Bevy ECS 中一个关键的 off-by-one 错误，这个错误会影响实体分配器（entity allocator）重用已释放实体索引的能力。问题出现在 `alloc_many` 方法中，这是一个批量分配实体的核心函数。

### 问题和背景

在 Bevy 的 ECS 系统中，实体（entity）是存储和访问组件（component）的唯一标识符。为了提高性能，Bevy 实现了实体分配器，它维护了一个可重用实体索引的列表（free list）。当一个实体被释放时，它的索引会被添加到 free list 中，以便后续重用。

`alloc_many` 方法用于批量分配实体。它首先尝试从 free list 中获取实体索引，如果 free list 中的实体数量不足，则会分配新的索引。问题出现在计算有多少实体可以从 free list 中获取的逻辑上。

原代码使用原子操作 `fetch_sub` 减少 `free_len`（free list 的长度），并返回操作前的值作为 `current_len`。然后，它通过比较 `current_len` 和 `free.len()` 来确定有多少实体可以从 free list 中获取：

```rust
let current_len = if current_len < self.free.len() {
    current_len
} else {
    0
};
```

这里的逻辑是：如果 `current_len` 小于 free list 的实际长度，则可以从 free list 中获取 `current_len` 个实体。否则，说明没有足够的实体可供重用，返回 0。

然而，这个逻辑有一个细微的差一错误。当 `current_len` 正好等于 `free.len()` 时，条件 `current_len < self.free.len()` 为 false，所以 `current_len` 会被设置为 0。这意味着即使 free list 中有足够数量的实体（数量正好匹配请求的数量），分配器也不会使用它们，而是分配全新的实体。

### 解决方案

修复方法很简单但很关键：将 `<` 改为 `<=`。这样，当 `current_len` 等于 `free.len()` 时，我们仍然会从 free list 中获取实体，正确地重用所有可用的实体索引。

```rust
let current_len = if current_len <= self.free.len() {
    current_len
} else {
    0
};
```

这个修改确保了当 free list 中的实体数量足够时，分配器总是优先重用已释放的实体，而不是分配新的实体。

### 实现细节

PR 的修改主要集中在 `crates/bevy_ecs/src/entity/mod.rs` 文件中的 `EntityAllocator::alloc_many` 方法。除了修复这个 off-by-one 错误外，还添加了一个单元测试来验证修复的有效性。

测试 `alloc_many_reuses_freed_entities` 模拟了以下场景：
1. 分配 5 个实体
2. 释放这 5 个实体
3. 再次分配 5 个实体
4. 验证第二次分配的实体全部重用了第一次分配的索引

这个测试是回归测试，确保修复后的代码在边界情况下正常工作，并且未来的修改不会重新引入这个 bug。

### 技术洞察

这个修复涉及几个重要的技术概念：

1. **无锁编程（Lock-free programming）**：`alloc_many` 使用原子操作（`fetch_sub`）来减少 `free_len`，这是一个无锁操作，允许多线程同时分配实体而不会产生竞争条件。

2. **Free list 管理模式**：实体分配器使用 free list 来管理已释放的实体索引，这是一种常见的内存/资源管理技术，可以减少分配新实体的开销。

3. **边界条件测试**：这个 bug 突出了边界条件测试的重要性。当 `current_len` 正好等于 `free.len()` 时，是一个容易被忽略的边界情况。

### 影响

这个修复有以下几个重要的影响：

1. **性能优化**：通过确保实体索引被正确重用，减少了不必要的内存分配，特别是在频繁创建和销毁实体的场景中。

2. **内存效率**：重用实体索引可以防止实体索引的无限增长，特别是在长时间运行的应用程序中。

3. **系统稳定性**：这个 bug 被标记为回归（P-Regression），说明它在某个时间点被引入，可能影响了依赖实体索引稳定性的代码。

这个修复虽然很小，但体现了高质量系统编程的核心原则：正确处理边界条件，确保资源管理的高效性，以及通过单元测试防止回归。

## 可视化表示

```mermaid
graph TD
    A[EntityAllocator::alloc_many] --> B{检查 free list 长度}
    B -->|current_len ≤ free.len()| C[从 free list 获取实体]
    B -->|current_len > free.len()| D[分配新实体]
    C --> E[返回重用实体]
    D --> F[返回新实体]
```

## 主要文件变更

### `crates/bevy_ecs/src/entity/mod.rs`

**变更描述**：修复了 `alloc_many` 方法中的 off-by-one 错误，并添加了单元测试来验证修复。

**关键修改**：
```rust
// 修复前：
let current_len = if current_len < self.free.len() {
    current_len
} else {
    0
};

// 修复后：
let current_len = if current_len <= self.free.len() {
    current_len
} else {
    0
};
```

**新增的单元测试**：
```rust
#[test]
fn alloc_many_reuses_freed_entities() {
    let mut allocator = EntityAllocator::default();

    // Allocate 5 entities
    let first_batch: Vec<_> = allocator.alloc_many(5).collect();
    assert_eq!(first_batch.len(), 5);

    // Record the indices
    let first_indices: Vec<_> = first_batch.iter().map(|e| e.index_u32()).collect();

    // Free all entities
    for e in &first_batch {
        allocator.free(*e);
    }

    // Allocate 5 entities again - this should reuse all freed indices
    let second_batch: Vec<_> = allocator.alloc_many(5).collect();
    assert_eq!(second_batch.len(), 5);

    // Compute intersection between the two batches
    let intersection = first_indices
        .iter()
        .filter(|idx| second_batch.iter().any(|e| e.index_u32() == **idx))
        .count();

    // All 5 indices should be reused
    assert_eq!(intersection, 5);
}
```

**与PR目的的关系**：这个文件包含了修复的核心逻辑和验证测试，确保了实体分配器在边界条件下正确工作。

## 进一步阅读

- [Bevy ECS 架构指南](https://bevyengine.org/learn/book/ecs/) - 了解 Bevy ECS 的整体架构
- [Rust 原子操作和内存顺序](https://doc.rust-lang.org/nomicon/atomics.html) - 理解 `fetch_sub` 和 `Ordering::Relaxed` 的工作原理
- [Free list 内存管理模式](https://en.wikipedia.org/wiki/Free_list) - 学习 free list 模式的基本概念
- [Off-by-one 错误](https://en.wikipedia.org/wiki/Off-by-one_error) - 了解这种常见编程错误的类型和预防方法

---

# 完整代码差异

```diff
diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs
index 280d7a764bf96..10cf13b93b1a5 100644
--- a/crates/bevy_ecs/src/entity/mod.rs
+++ b/crates/bevy_ecs/src/entity/mod.rs
@@ -795,7 +795,7 @@ impl EntityAllocator {
     /// See [`AllocEntitiesIterator`] docs for more.
     pub fn alloc_many(&self, count: u32) -> AllocEntitiesIterator<'_> {
         let current_len = self.free_len.fetch_sub(count as usize, Ordering::Relaxed);
-        let current_len = if current_len < self.free.len() {
+        let current_len = if current_len <= self.free.len() {
             current_len
         } else {
             0
@@ -1552,4 +1552,34 @@ mod tests {
         entities.dedup();
         assert_eq!(pre_len, entities.len());
     }
+
+    #[test]
+    fn alloc_many_reuses_freed_entities() {
+        let mut allocator = EntityAllocator::default();
+
+        // Allocate 5 entities
+        let first_batch: Vec<_> = allocator.alloc_many(5).collect();
+        assert_eq!(first_batch.len(), 5);
+
+        // Record the indices
+        let first_indices: Vec<_> = first_batch.iter().map(|e| e.index_u32()).collect();
+
+        // Free all entities
+        for e in &first_batch {
+            allocator.free(*e);
+        }
+
+        // Allocate 5 entities again - this should reuse all freed indices
+        let second_batch: Vec<_> = allocator.alloc_many(5).collect();
+        assert_eq!(second_batch.len(), 5);
+
+        // Compute intersection between the two batches
+        let intersection = first_indices
+            .iter()
+            .filter(|idx| second_batch.iter().any(|e| e.index_u32() == **idx))
+            .count();
+
+        // All 5 indices should be reused
+        assert_eq!(intersection, 5);
+    }
 }
```