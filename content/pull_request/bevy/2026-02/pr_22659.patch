diff --git a/benches/benches/bevy_ecs/world/entity_allocator.rs b/benches/benches/bevy_ecs/world/entity_allocator.rs
index c954139d9a7f1..b5a962170a6cf 100644
--- a/benches/benches/bevy_ecs/world/entity_allocator.rs
+++ b/benches/benches/bevy_ecs/world/entity_allocator.rs
@@ -128,4 +128,57 @@ pub fn entity_allocator_benches(criterion: &mut Criterion) {
     }
 
     group.finish();
+
+    let mut group = criterion.benchmark_group("entity_allocator_allocate_fresh_remote");
+    group.warm_up_time(core::time::Duration::from_millis(500));
+    group.measurement_time(core::time::Duration::from_secs(4));
+
+    for entity_count in ENTITY_COUNTS {
+        group.bench_function(format!("{entity_count}_entities"), |bencher| {
+            bencher.iter_batched_ref(
+                || {
+                    let world = World::new();
+                    world.entity_allocator().build_remote_allocator()
+                },
+                |remote| {
+                    for _ in 0..entity_count {
+                        let entity = remote.alloc();
+                        black_box(entity);
+                    }
+                },
+                BatchSize::SmallInput,
+            );
+        });
+    }
+
+    group.finish();
+
+    let mut group = criterion.benchmark_group("entity_allocator_allocate_reused_remote");
+    group.warm_up_time(core::time::Duration::from_millis(500));
+    group.measurement_time(core::time::Duration::from_secs(4));
+
+    for entity_count in ENTITY_COUNTS {
+        group.bench_function(format!("{entity_count}_entities"), |bencher| {
+            bencher.iter_batched_ref(
+                || {
+                    let mut world = World::new();
+                    let mut entities =
+                        Vec::from_iter(world.entity_allocator().alloc_many(entity_count));
+                    entities
+                        .drain(..)
+                        .for_each(|e| world.entity_allocator_mut().free(e));
+                    world.entity_allocator().build_remote_allocator()
+                },
+                |remote| {
+                    for _ in 0..entity_count {
+                        let entity = remote.alloc();
+                        black_box(entity);
+                    }
+                },
+                BatchSize::SmallInput,
+            );
+        });
+    }
+
+    group.finish();
 }
diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs
index 9873a40308df8..af97499032ca6 100644
--- a/crates/bevy_ecs/src/entity/mod.rs
+++ b/crates/bevy_ecs/src/entity/mod.rs
@@ -715,7 +715,7 @@ impl EntityAllocator {
 
     /// Builds a new remote allocator that hooks into this [`EntityAllocator`].
     /// This is useful when you need to allocate entities without holding a reference to the world (like in async).
-    pub fn build_remote_allocator(&mut self) -> RemoteAllocator {
+    pub fn build_remote_allocator(&self) -> RemoteAllocator {
         RemoteAllocator::new(&self.inner)
     }
 
