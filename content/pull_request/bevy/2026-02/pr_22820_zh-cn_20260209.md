+++
title = "#22820 use scene names if they exist"
date = "2026-02-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22820-en-20260209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22820-zh-cn-20260209" }}
labels = ["C-Feature", "A-Assets", "A-glTF"]
+++

# Title: use scene names if they exist

## Basic Information
- **Title**: use scene names if they exist
- **PR Link**: https://github.com/bevyengine/bevy/pull/22820
- **Author**: ChristopherBiscardi
- **Status**: MERGED
- **Labels**: C-Feature, A-Assets, S-Ready-For-Final-Review, A-glTF
- **Created**: 2026-02-05T20:01:09Z
- **Merged**: 2026-02-09T22:24:31Z
- **Merged By**: alice-i-cecile

## Description Translation
# 目标

glTF场景通常具有名称。我们的加载器代码没有插入这些名称。这导致工具如bevy_inspector_egui在场景的根实体上显示`Entity`，而不是在Blender中命名的"MyPlayerScene"或其他名称。

## 解决方案

如果名称存在则使用它们，否则使用基于glTF场景索引的默认名称，这与其他用途保持一致。

## 测试

我将`models/FlightHelmet/FlightHelmet.gltf`和`models/cube/cube.gltf`加载到`3d_scene`示例中，并编写了一个小系统来检查`Name`组件的存在性。使用此补丁后，`Scene`和`Scene0`名称将记录输出（`FlightHelmet`没有名称，因此将打印`Scene0`，而`cube`有名称，即不带索引的`Scene`）。

```rust
fn update(query: Query<&Name>) {
    for item in &query {
        dbg!(item);
    }
}
```

---

现在也插入了`GltfSceneName`以镜像`GltfMeshName`和`GltfMaterialName`的行为。

## The Story of This Pull Request

这个PR解决了一个在Bevy的glTF加载器中的可用性问题。当开发者从glTF文件加载场景时，场景的根实体在编辑器工具（如bevy_inspector_egui）中显示为通用的"Entity"，而不是使用glTF文件中定义的实际场景名称。这对于调试和场景管理来说是一个实际问题。

问题的根源在于Bevy的glTF加载器没有将glTF场景的名称传递到Bevy实体的`Name`组件中。glTF规范允许场景拥有可选的名称属性，但加载器代码忽略了这一信息。

解决方案采用了Bevy代码库中已有的模式。对于glTF网格和材质，Bevy已经实现了类似的逻辑：如果原始glTF资产有名称，就使用它；否则使用基于索引的默认名称。这个PR将相同的模式扩展到glTF场景。

在实现方面，修改分为两个主要部分。首先，在`assets.rs`中定义了一个新的组件类型`GltfSceneName`，其结构与现有的`GltfMeshName`和`GltfMaterialName`组件保持一致。这个组件包装了一个字符串，实现了`Deref` trait以方便访问，并标记为可反射的组件。

其次，在加载器代码中，当创建场景的根实体时，现在会添加一个`Name`组件。这个名称的来源是：如果glTF场景有名称，就使用它；否则生成一个像"Scene0"这样的默认名称，其中数字是场景在glTF文件中的索引。这与网格和材质的命名方式保持一致。

此外，如果场景有名称，加载器还会插入`GltfSceneName`组件。这保持了与`GltfMeshName`和`GltfMaterialName`行为的一致性，即使名称已经通过`Name`组件可用，仍然提供专门的结构化访问。

从工程角度看，这个实现是简洁且符合现有代码模式的。它没有引入破坏性变化，只是增加了功能。默认命名方案使用场景索引，确保了即使没有明确名称的场景也能获得有意义的标识符。这种一致性很重要，因为glTF文件可以包含多个场景。

这个修改的影响是直接的：现在当在Bevy中加载glTF场景时，场景的根实体会有一个有意义的名称，使得在编辑器工具中更容易识别和管理。这对于使用Blender或其他3D建模软件创建的场景尤其有用，这些软件通常会给场景命名。

技术上的考虑包括保持`GltfSceneName`组件与`Name`组件分离。虽然这看起来有些冗余，但它提供了类型安全性，并与其他glTF资产类型（网格、材质）的处理方式保持一致。如果需要，开发者可以通过`GltfSceneName`组件明确查询哪些实体代表glTF场景。

## Visual Representation

```mermaid
graph TD
    A[glTF Scene Loading] --> B{Scene has name?}
    B -->|Yes| C[Use glTF scene name]
    B -->|No| D[Use default "Scene{index}"]
    C --> E[Insert Name component]
    D --> E
    C --> F[Insert GltfSceneName component]
    E --> G[Scene Root Entity]
    F --> G
    H[GltfMeshName] --> I[Consistency Pattern]
    J[GltfMaterialName] --> I
    F --> I
```

## Key Files Changed

### 1. `crates/bevy_gltf/src/assets.rs` (+17/-0)
添加了`GltfSceneName`组件定义，与其他glTF资产名称组件保持一致。

```rust
// File: crates/bevy_gltf/src/assets.rs
// 新增的代码：
/// The name of a glTF scene.
///
/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-scene).
#[derive(Clone, Debug, Reflect, Default, Component)]
#[reflect(Component, Clone)]
pub struct GltfSceneName(pub String);

impl Deref for GltfSceneName {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        self.0.as_ref()
    }
}
```

这个新增的结构体与现有的`GltfMeshName`和`GltfMaterialName`保持相同的模式，提供对glTF场景名称的类型安全访问。

### 2. `crates/bevy_gltf/src/loader/mod.rs` (+15/-2)
修改了场景加载逻辑，为场景根实体添加`Name`组件，并在有名称时添加`GltfSceneName`组件。

```rust
// File: crates/bevy_gltf/src/loader/mod.rs
// 修改前的代码（简化）：
let world_root_id = world
    .spawn((world_root_transform, Visibility::default()))
    // ... 其他代码

// 修改后的代码：
let world_root_id = world
    .spawn((
        world_root_transform,
        Visibility::default(),
        Name::new(
            scene
                .name()
                .map(ToOwned::to_owned)
                .unwrap_or_else(|| format!("Scene{}", scene.index())),
        ),
    ))
    // ... 其他代码
    .id();

if let Some(scene_name) = scene.name() {
    world
        .entity_mut(world_root_id)
        .insert(GltfSceneName(scene_name.to_owned()));
};
```

主要修改包括：
1. 在创建场景根实体时添加`Name`组件，使用场景名称或默认名称
2. 如果场景有名称，额外插入`GltfSceneName`组件

## Further Reading

1. [glTF 2.0 Specification - Scenes](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-scene) - glTF场景的官方规范
2. [Bevy Engine ECS Components](https://bevyengine.org/learn/book/next/programming/ecs/components/) - Bevy实体组件系统
3. [Bevy glTF Loader Documentation](https://docs.rs/bevy_gltf/latest/bevy_gltf/) - Bevy glTF加载器的API文档
4. [3D Asset Pipeline Best Practices](https://bevyengine.org/learn/book/next/assets/3d/) - Bevy中3D资产处理的最佳实践