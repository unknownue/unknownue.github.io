+++
title = "#22762 Adds Frustum Gizmo"
date = "2026-02-04T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22762-en-20260204" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22762-zh-cn-20260204" }}
+++

# Title

## 基本信息
- **标题**: Adds Frustum Gizmo
- **PR链接**: https://github.com/bevyengine/bevy/pull/22762
- **作者**: kfc35
- **状态**: 已合并
- **标签**: C-Feature, S-Ready-For-Final-Review, A-Math, A-Gizmos, D-Straightforward
- **创建时间**: 2026-02-01T02:49:48Z
- **合并时间**: 2026-02-04T01:14:37Z
- **合并者**: alice-i-cecile

## 描述翻译
**目标 (Objective)**
- 采纳 (Adopts) @tim-blackbird 的 PR #10038。
- 实现 (Half of) PR #19468 的一部分（不包含相机 Gizmo，仅限视锥体）。
- 完成 (Part 3 of) 并修复 (fixes) PR #13878。

**解决方案 (Solution)**
我站在巨人的肩膀上，将 PR #10038 更新至主分支，主要修改如下：
- 视锥体 (frustum) Gizmo 现在是立即模式 Gizmo (immediate gizmos)，而非保留模式 (retained)。
- 当前视图的视锥体被绘制在屏幕边缘，颜色如下（注意屏幕左、下、右边缘的绿色边框）。
<img width="1286" height="752" alt="Screenshot 2026-01-31 at 9 18 41 PM" src="https://github.com/user-attachments/assets/7ed2b4db-1710-4be1-b6ca-00725d09944f" />

同时感谢 @RCoder01 在原始 PR 中附加的 GitHub Gist；我的更新最终与其基本相同，尽管代码现在更恰当地放置在了其应有的位置。

**测试 (Testing)**
- 我在 bevy 仓库中运行了一些 scene_viewer gltf 文件（例如 `cargo run --example scene_viewer --features "free_camera" -- assets/models/cubes/Cubes.glb`）。我猜它们没有多个相机可以循环切换？但至少这展示了切换视锥体显示会在屏幕周围显示微弱的边框。
- 我运行了 light_gizmos 示例 `cargo run --example light_gizmos`。只有 `SpotLight` 有绘制的 Gizmo（`PointLight` 和 `DirectionalLight` 拥有包裹 `Frustum` 的组件，但本身没有 `Frustum`）。它是下图中黄色的 Gizmo。由于有专用的灯光 Gizmo，对灯光使用视锥体 Gizmo 似乎没有必要。
<img width="1278" height="740" alt="Screenshot 2026-01-31 at 9 36 54 PM" src="https://github.com/user-attachments/assets/6e676bb8-32d4-4d90-9225-ee3a878745a6" />
- 像原始作者一样，我修改了 `split_screen` 示例，以在一个玩家的屏幕上看到另一个玩家相机的视锥体 Gizmo。我移除了玩家 3 和 4，为玩家 2 的相机添加了视锥体 Gizmo，并将玩家 1 的相机移得足够远，以便能看到该视锥体。
<img width="1274" height="740" alt="Screenshot 2026-01-31 at 9 09 46 PM" src="https://github.com/user-attachments/assets/fff38469-9d00-46ba-9098-fdf8418b54fa" />

**展示 (Showcase)**
<details>
  <summary>修改后的 `split_screen` 示例代码</summary>
（代码块保持不变，此处省略以保持响应简洁，详情见原始描述）
</details>

## 本次 Pull Request 的故事

**问题与背景**
在游戏引擎开发中，调试相机视图和剔除（culling）范围是一个常见需求。Bevy 引擎的相机（camera）实体带有一个 `Frustum` 组件，用于表示其可见范围并进行视锥体剔除（frustum culling）。然而，开发者缺乏一种直观的方式在运行时可视化这些视锥体，这增加了调试多相机设置、理解剔除行为或确认相机视野范围的难度。此前，社区已有 PR #10038 尝试添加此功能，但未完成合并。PR #22762 的目标就是解决这个可视化缺失的问题，提供一个集成的、可配置的视锥体调试工具。

**解决方案与实现**
开发者 `kfc35` 选择基于已有的 PR #10038 进行工作，但进行了关键架构调整：将实现从保留模式 (retained) Gizmo 改为 Bevy 更现代和性能友好的立即模式 (immediate-mode) Gizmo。这使得 Gizmo 的绘制逻辑更简洁，每帧按需生成，无需管理长期状态。

整个实现可以分解为三个核心部分：
1.  **数学基础 (`bevy_math`)**：为了绘制视锥体，首先需要计算其八个角点。视锥体由六个平面（半空间，`HalfSpace`）定义。因此，需要计算三个平面的交点。新增的 `HalfSpace::intersection_point` 方法通过求解线性方程组来实现这一计算。基于此，`ViewFrustum::corners()` 方法通过计算所有相关平面的交点，返回近平面和远平面的四个角点。如果视锥体未正确定义（例如平面平行）或远平面未激活（`INACTIVE_HALF_SPACE`），该方法会返回 `None` 或包含 `NaN` 的角点。
    ```rust
    // `HalfSpace::intersection_point` 的核心计算逻辑
    let x = Vec3A::new(an.x, bn.x, cn.x);
    let y = Vec3A::new(an.y, bn.y, cn.y);
    let z = Vec3A::new(an.z, bn.z, cn.z);
    let d = -Vec3A::new(a.d(), b.d(), c.d());
    // ... 计算行列式并求解
    ```
2.  **Gizmo 系统集成 (`bevy_gizmos`)**：这是功能的主体。创建了一个新的 `frustum` 模块，包含：
    *   `FrustumGizmoPlugin`：负责注册系统和配置组。
    *   `FrustumGizmoConfigGroup`：一个 `GizmoConfigGroup`，提供全局配置选项，如 `draw_all`（绘制所有视锥体）和 `default_color`。
    *   `ShowFrustumGizmo` 组件：可附加到任何拥有 `Frustum` 组件的实体上，以启用并自定义其视锥体的可视化。
    *   两个查询系统：`draw_frustum_gizmos` 处理带有 `ShowFrustumGizmo` 组件的实体；`draw_all_frustum_gizmos` 在配置启用时处理所有其他拥有 `Frustum` 的实体。
    *   核心绘制函数 `frustum_inner`：它调用 `frustum.corners()` 获取角点，然后使用 `Gizmos::linestrip` 和 `Gizmos::line` 绘制出视锥体的线框模型。
    ```rust
    // 核心绘制逻辑
    gizmos.linestrip(
        [
            tln, trn, brn, bln, // Near
            tln, tlf, // Top Left Near to Far
            trf, brf, blf, tlf, // Far
        ],
        color,
    );
    gizmos.line(trn, trf, color); // Top Right Near to Far
    // ... 绘制其他边
    ```
3.  **基础设施与示例**：
    *   在 `bevy_gizmos` 的根 `lib.rs` 中，提取并公开了 `color_from_entity` 函数，用于基于实体 ID 生成分散的颜色，确保不同实体的 Gizmo 颜色区分度高。
    *   在 `bevy_light` 中，更新了系统顺序，确保聚光灯 (`SpotLight`) 的视锥体更新发生在 `FrustumGizmoSystems` 之前，这样 Gizmo 才能绘制到正确的、最新的视锥体。
    *   更新了 `scene_viewer` 示例，添加了按 `F` 键切换所有相机视锥体显示的功能，方便用户测试。

**技术考量与影响**
*   **立即模式与性能**：采用立即模式 Gizmo 符合 Bevy 的设计趋势，避免了不必要的状态管理开销。绘制只在启用时发生，对性能影响最小。
*   **灵活的配置**：提供了组件级 (`ShowFrustumGizmo`) 和全局级 (`draw_all`) 两种控制方式，适应不同的调试场景。
*   **颜色生成**：使用 `Oklcha::sequential_dispersed` 基于实体索引生成颜色，确保了不同实体视锥体的视觉区分度，这是一个实用的调试辅助细节。
*   **向后兼容与集成**：该 PR 作为插件实现，对现有代码完全非侵入。它被无缝集成到 Bevy 的 Gizmo 生态系统中，与其他调试 Gizmo（如 AABB）共享配置和绘制管道。

**潜在改进与总结**
此 PR 成功地将一个有用的调试功能引入了 Bevy。一个自然的未来扩展点是添加相机的 Gizmo 可视化（如 PR #19468 的另一半），这可能需要绘制相机的图标或朝向。此外，对于正交投影 (orthographic projection) 的视锥体（实际上是一个轴对齐的盒子），绘制样式或许可以优化以更清晰地表示其特性。

总而言之，PR #22762 是一个设计良好、实现清晰的特性添加。它解决了实际开发中的调试痛点，代码结构模块化，并充分考虑了与现有系统的集成，是 Bevy 社区协作和渐进式改进的一个典型例子。

## 视觉表示

```mermaid
graph TD
    subgraph "crates/bevy_gizmos"
        A[GizmoPlugin] --> B[注册 FrustumGizmoPlugin]
        B --> C[FrustumGizmoPlugin]
        C --> D[提供 FrustumGizmoConfigGroup]
        C --> E[注册系统: draw_frustum_gizmos, draw_all_frustum_gizmos]
        E --> F[依赖 ViewFrustum::corners()]
        E --> G[使用 Gizmos API 绘图]
        H[color_from_entity 函数] --> I[为 Gizmo 提供区分色]
    end

    subgraph "crates/bevy_math"
        J[ViewFrustum] --> K[新增 corners() 方法]
        L[HalfSpace] --> M[新增 intersection_point() 方法]
        M --> K
    end

    subgraph "crates/bevy_light"
        N[SpotLight 系统] --> O[更新视锥体]
        O -- 系统顺序保证 --> E
    end

    subgraph "使用方"
        P[Camera Entity] -- 拥有 --> J
        P -- 添加 --> Q[ShowFrustumGizmo 组件]
        R[开发者] -- 配置 --> D
        S[scene_viewer 示例] -- 调用 --> D
    end

    F -- 调用 --> K
    Q -- 被查询 --> E
```

## 关键文件变更

以下是本次 PR 中修改的最重要的文件：

1.  **`crates/bevy_gizmos/src/frustum.rs` (+149/-0)**
    *   **描述**：新增文件。实现了视锥体 Gizmo 的核心逻辑，包括插件、配置、组件和绘制系统。
    *   **关键代码**：
        ```rust
        // 系统：绘制带有 ShowFrustumGizmo 组件的实体的视锥体
        fn draw_frustum_gizmos(
            query: Query<(Entity, &Frustum, &ShowFrustumGizmo)>,
            mut gizmos: Gizmos<FrustumGizmoConfigGroup>,
        ) {
            for (entity, &frustum, gizmo) in &query {
                let color = gizmo
                    .color
                    .or(gizmos.config_ext.default_color)
                    .unwrap_or_else(|| color_from_entity(entity));

                frustum_inner(&frustum, color, &mut gizmos);
            }
        }
        ```

2.  **`crates/bevy_math/src/primitives/view_frustum.rs` (+165/-0)**
    *   **描述**：为 `ViewFrustum` 结构体添加了 `corners()` 方法，用于计算视锥体的八个角点。这是绘制的数学基础。
    *   **关键代码**：
        ```rust
        pub fn corners(&self) -> Option<[Vec3; 8]> {
            let [left, right, top, bottom, near, far] = self.half_spaces;
            Some([
                HalfSpace::intersection_point(top, left, near)?,
                HalfSpace::intersection_point(top, right, near)?,
                // ... 计算其余角点
            ])
        }
        ```

3.  **`crates/bevy_math/src/primitives/half_space.rs` (+76/-1)**
    *   **描述**：为 `HalfSpace` 结构体添加了 `intersection_point()` 静态方法，用于计算三个半空间的交点。这是 `corners()` 的底层支持。
    *   **关键代码**：
        ```rust
        pub fn intersection_point(a: HalfSpace, b: HalfSpace, c: HalfSpace) -> Option<Vec3> {
            // ... 向量和行列式计算
            let denom = x.dot(u);
            if ops::abs(denom) < f32::EPSILON {
                return None;
            }
            Some(Vec3::new(d.dot(u), z.dot(v), -y.dot(v)) / denom)
        }
        ```

4.  **`crates/bevy_gizmos/src/lib.rs` (+14/-1)**
    *   **描述**：注册新的 `FrustumGizmoPlugin`，并将 `color_from_entity` 函数从 `aabb.rs` 模块提升到库根目录，使其可被其他模块（如 `frustum.rs`）重用。
    *   **关键代码**：
        ```rust
        // 在 Plugin 实现中添加
        app.add_plugins((
            aabb::AabbGizmoPlugin,
            frustum::FrustumGizmoPlugin, // 新增
            global::GlobalGizmosPlugin,
        ));
        // 新增的公共函数
        pub fn color_from_entity(entity: Entity) -> Color {
            Oklcha::sequential_dispersed(entity.index_u32()).into()
        }
        ```

5.  **`crates/bevy_light/src/lib.rs` (+9/-0)**
    *   **描述**：调整了聚光灯 (`SpotLight`) 视锥体更新系统的调度顺序，确保其在 `FrustumGizmoSystems` 之前运行，保证 Gizmo 绘制的是最新数据。
    *   **关键代码**：
        ```rust
        #[cfg(feature = "bevy_gizmos")]
        update_spot_light_frusta
            .in_set(SimulationLightSystems::UpdateLightFrusta)
            .before(FrustumGizmoSystems) // 新增顺序约束
            .after(TransformSystems::Propagate)
            .after(SimulationLightSystems::AssignLightsToClusters),
        ```

6.  **`examples/tools/scene_viewer/scene_viewer_plugin.rs` (+4/-0)**
    *   **描述**：在场景查看器示例中添加了按 `F` 键切换所有相机视锥体显示的功能，方便用户测试新特性。
    *   **关键代码**：
        ```rust
        fn toggle_camera_frusta(mut config: ResMut<GizmoConfigStore>) {
            config.config_mut::<FrustumGizmoConfigGroup>().1.draw_all ^= true;
        }
        ```

## 延伸阅读
*   **Bevy Gizmos 官方文档**: 了解 Bevy 立即模式 Gizmo 系统的整体设计和使用方法。
*   **视锥体剔除 (Frustum Culling)**: 学习计算机图形学中视锥体剔除的基本原理，理解 `Frustum` 组件在渲染管线中的作用。
*   **半空间 (Half-Space) 和平面表示**: 深入理解使用法向量和距离 (`Vec4`) 表示平面的数学原理。
*   **Bevy 调度 (Schedule) 与系统顺序**: 理解如何通过 `.before()` 和 `.after()` 控制系统的执行顺序，这对于确保数据一致性至关重要（如 `bevy_light` 中的修改）。