+++
title = "#22989 Allow accessing subassets using their handle."
date = "2026-02-20T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22989-en-20260220" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22989-zh-cn-20260220" }}
+++

# Title

## 基本资讯
- **标题**: Allow accessing subassets using their handle.
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22989
- **作者**: andriyDev
- **状态**: 已合并
- **标签**: C-Feature, A-Assets, S-Ready-For-Final-Review, D-Straightforward
- **创建时间**: 2026-02-17T04:27:30Z
- **合并时间**: 2026-02-20T01:53:56Z
- **合并者**: alice-i-cecile

## 描述翻译
### Objective
- 修复 #11595.

### Solution
- 将我们带标签的资产存储改为一个带标签资产的 `Vec`，然后是一个从标签到索引的 `HashMap`。
- 添加一个 `AssetId` 到索引的映射。
- 提供执行该查找的方法。
- 修复了资产保存示例中一个烦人的 TODO。

这一切都由资产加载内部管理 - 所以不需要迁移指南！

### Testing
- 运行了 `asset_saving` 示例，它仍然正常工作！

## 本 PR 的故事

这个 PR 的核心目的是解决一个开发者在处理资产（Assets）时可能遇到的痛点：当通过标签（label）向一个资产添加子资产（subasset）后，开发者只能通过该标签来获取子资产的引用。然而，在很多场景下，开发者持有的是子资产的 `Handle`（句柄），而不是它的标签。这就产生了一个不匹配：有句柄，却无法直接通过它来获取对应的已加载资产数据。

具体来说，这个问题记录在 issue #11595 中。在没有这个 PR 之前，`LoadedAsset`、`TransformedAsset` 和 `SavedAsset` 等结构体使用一个 `HashMap<CowArc<'static, str>, LabeledAsset>` 来存储带标签的子资产。查询只能通过标签字符串进行。这在 `asset_saving` 示例中体现得很明显：为了在保存时根据一个 `Handle` 找到对应的 `OneBox` 子资产，代码需要先费力地从 `Handle` 中提取出路径标签，再用标签去查询，并且还需要处理可能出现的错误。作者甚至在代码里留下了一个 “TODO” 注释，说明这是一个已知的痛点。

开发者提出的解决方案在概念上很直接：为子资产建立额外的反向索引。但实现需要兼顾现有 API 的稳定性和性能。他们选择了一个经典的“空间换时间”和“保持兼容性”的策略。具体做法是，在 `LoadedAsset` 及相关结构体中，不再仅用一个 `HashMap`，而是改为用三个数据结构协同工作：
1.  `labeled_assets: Vec<LabeledAsset>`: 按顺序存储所有子资产的实际数据。
2.  `label_to_asset_index: HashMap<CowArc<'static, str>, usize>`: 提供从标签到 `Vec` 中索引的快速查找。
3.  `asset_id_to_asset_index: HashMap<UntypedAssetId, usize>`: 提供从资产 ID（可以从 `Handle` 轻松获得）到 `Vec` 中索引的快速查找。

这样一来，原有的通过标签查询的 API（如 `get_labeled`）得以保留，其内部实现改为先查 `label_to_asset_index` 再索引 `Vec`，性能依然高效。更重要的是，新增了 `get_labeled_by_id` 方法，它接收一个可以转换为 `UntypedAssetId` 的参数（例如 `&Handle`），通过查询 `asset_id_to_asset_index` 来定位子资产，完美解决了最初的问题。

这个改动波及了资产管线的多个核心阶段：加载（`loader.rs`）、转换（`transformer.rs`）和保存（`saver.rs`）。每个阶段的对应结构体（`LoadedAsset`/`ErasedLoadedAsset`、`TransformedAsset`/`TransformedSubAsset`、`SavedAsset`/`ErasedSavedAsset`）都需要进行相同模式的重构。这是本次 PR 中最大量的代码变更，但模式高度一致，降低了审查的认知负担。

在实现细节上，开发者考虑到了边界情况。例如，在 `LoadContext::add_labeled_asset` 方法中，当插入一个已存在标签的子资产时（`Entry::Occupied`），他们选择替换旧的子资产，同时更新 `Vec` 中的对应项。这里有一个重要的优化：由于替换时可能使用了相同资产路径的新 `Handle`（但 `id` 相同），也可能是一个完全不同的 `Handle`（`id` 不同），代码正确地处理了 `asset_id_to_asset_index` 映射的更新，移除了旧句柄的 ID，并插入新句柄的 ID。作者也留下了一个 TODO 注释，指出重复添加标签可能意味着开发者失误，未来或许应该按错误处理。

对于 `SavedAssetBuilder::insert_labeled`，逻辑类似，但更简单，因为构建器完全由用户控制。

最终，这个 PR 的成果是简洁而强大的。现在，在资产保存示例中，那个烦人的 TODO 可以被一个简单、安全、且不会失败的调用所取代：
```rust
asset.get_labeled_by_id::<OneBox>(handle).unwrap().get().clone()
```
从功能上看，开发者现在可以通过 `Handle` 直接访问子资产，提高了 API 的易用性和表达力。从架构上看，这种“主存储（Vec）+ 多索引（HashMap）”的模式是一种常见的数据组织优化，它在保持 O(1) 查询复杂度的同时，提供了多维度的查询能力。由于所有改动都是内部数据表示和新增 API，对现有代码完全兼容，因此如 PR 描述所说，不需要迁移指南。

## 视觉呈现

下图展示了本次 PR 对关键资产结构的数据组织方式的改变：

```mermaid
graph TD
    subgraph “修改前 (Before)”
        A1[LoadedAsset] --> B1[HashMap<br/>label → LabeledAsset]
    end

    subgraph “修改后 (After)”
        A2[LoadedAsset] --> B2[Vec<LabeledAsset>]
        A2 --> C2[HashMap<br/>label → usize]
        A2 --> D2[HashMap<br/>AssetId → usize]
        C2 -->|索引| B2
        D2 -->|索引| B2
    end
```

## 关键文件更改

以下是本次 PR 中最重要的文件变更：

1.  **`crates/bevy_asset/src/loader.rs`** (+185/-17)
    - **变更描述**：修改了 `LoadedAsset`、`ErasedLoadedAsset` 和 `LoadContext` 结构体，将子资产存储从单一的 `HashMap` 重构为 `Vec` 加两个索引 `HashMap` 的模式，并新增了 `get_labeled_by_id` 方法。
    - **关键代码片段**：
        ```rust
        // 之前 (Before):
        pub(crate) labeled_assets: HashMap<CowArc<'static, str>, LabeledAsset>,

        // 之后 (After):
        pub(crate) labeled_assets: Vec<LabeledAsset>,
        pub(crate) label_to_asset_index: HashMap<CowArc<'static, str>, usize>,
        pub(crate) asset_id_to_asset_index: HashMap<UntypedAssetId, usize>,

        // 新增的方法 (New method):
        pub fn get_labeled_by_id(&self, id: impl Into<UntypedAssetId>) -> Option<&ErasedLoadedAsset> {
            let index = self.asset_id_to_asset_index.get(&id.into())?;
            let labeled = &self.labeled_assets[*index];
            Some(&labeled.asset)
        }
        ```
    - **关联性**：这是资产加载阶段的核心数据结构，其改动是本次功能实现的基础。

2.  **`crates/bevy_asset/src/transformer.rs`** (+185/-19)
    - **变更描述**：对 `TransformedAsset` 和 `TransformedSubAsset` 进行了与 `LoadedAsset` 相同的重构，并同样为它们添加了 `get_labeled_by_id` 和 `get_erased_labeled_by_id` 方法。
    - **关键代码片段**：
        ```rust
        // 在 `TransformedAsset` 和 `TransformedSubAsset` 中均增加了类似字段和方法
        pub fn get_labeled_by_id<B: Asset>(
            &mut self,
            id: impl Into<AssetId<B>>,
        ) -> Option<TransformedSubAsset<'_, B>> {
            let index = self.asset_id_to_asset_index.get(&id.into().untyped())?;
            let labeled = &mut self.labeled_assets[*index];
            // ... 返回 TransformedSubAsset
        }
        ```
    - **关联性**：确保了资产在转换（Transformer）阶段也能通过句柄访问子资产，保持了功能在整个管线中的一致性。

3.  **`crates/bevy_asset/src/saver.rs`** (+126/-32)
    - **变更描述**：对 `SavedAsset`、`ErasedSavedAsset` 和 `SavedAssetBuilder` 进行了类似的重构，并添加了对应的 `get_labeled_by_id` 和 `get_erased_labeled_by_id` 方法。
    - **关键代码片段**：
        ```rust
        // `SavedAssetBuilder::insert_labeled` 中处理重复标签的逻辑
        match self.label_to_asset_index.entry(label.into()) {
            Entry::Occupied(entry) => {
                // ... 替换并更新 asset_id_to_asset_index
            }
            Entry::Vacant(entry) => {
                // ... 插入新条目并更新两个索引
            }
        }
        ```
    - **关联性**：确保了资产在保存（Saver）阶段也能通过句柄访问子资产，并更新了构建器的内部逻辑以维护新索引。

4.  **`examples/asset/asset_saving.rs`** (+5/-9)
    - **变更描述**：移除了原本复杂且脆弱的、从 `Handle` 提取标签再查询的逻辑，替换为直接使用新的 `get_labeled_by_id` 方法。
    - **关键代码片段**：
        ```rust
        // 之前 (Before - 有TODO注释):
        let label = handle.path().and_then(|path| path.label())...; // 可能失败
        asset.get_labeled::<OneBox>(label).map(...).ok_or_else(...)

        // 之后 (After):
        asset.get_labeled_by_id::<OneBox>(handle).unwrap().get().clone()
        ```
    - **关联性**：这是本次 PR 解决的痛点在实际代码中的直接体现，展示了新 API 带来的简洁性和可靠性。

5.  **`crates/bevy_asset/src/server/mod.rs`** (+3/-2)
    - **变更描述**：在资产服务器根据路径和标签加载资产的逻辑中，将查询从旧的 `labeled_assets.get(&label)` 更新为通过新的 `label_to_asset_index` 进行查询。
    - **关联性**：这是必要的适配性改动，以确保服务器逻辑与新的内部数据结构保持一致。

## 延伸阅读
- **Bevy Assets 文档**: 了解 Bevy 资产系统的核心概念，如 `Handle`、`AssetServer`、`AssetLoader` 等。
- **Rust HashMap 和 Entry API**: 理解本 PR 中大量使用的 `HashMap::entry` 模式，它是处理“可能插入”场景的惯用方法。
- **空间换时间优化**: 研究这种通过维护额外索引（反向索引）来加速特定查询的常见数据库和数据结构设计模式。
- **Bevy 资产管线**: 深入了解资产从加载 (`Loader`)、转换 (`Transformer`) 到保存 (`Saver`) 的完整生命周期，这有助于理解为何需要在多个结构体中做出相同改动。