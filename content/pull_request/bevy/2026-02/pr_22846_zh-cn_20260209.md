+++
title = "#22846 Stop using `encase` for clusterable lights."
date = "2026-02-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22846-en-20260209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22846-zh-cn-20260209" }}
+++

# Stop using `encase` for clusterable lights.

## Basic Information
- **标题**: Stop using `encase` for clusterable lights.
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22846
- **作者**: pcwalton
- **状态**: 已合并
- **标签**: A-Rendering, C-Performance, S-Ready-For-Final-Review
- **创建时间**: 2026-02-07T05:06:53Z
- **合并时间**: 2026-02-09T06:51:44Z
- **合并者**: superdump

## 描述翻译
`encase` 有大量开销，并且对于 `GpuClusteredLight` 而言，它没有为我们带来任何好处。切换到 `RawBufferVec` 将 `many_lights` 场景中 `prepare_lights` 的性能从 6.27 毫秒提升到了 5.2 毫秒，实现了 20% 的加速。

<img width="2756" height="1800" alt="Screenshot 2026-02-06 210432" src="https://github.com/user-attachments/assets/0f5216b8-d79f-463c-a7d4-2ce430f858f3" />


## 本次 Pull Request 的技术分析

本次 PR 的核心是一个直接且高效的性能优化。它针对 Bevy 渲染引擎中灯光准备阶段的一个已知开销点——`encase` 库的使用——进行了重构。

问题的背景是，在 Bevy 的基于簇的（clustered）前向着色（forward rendering）管线中，CPU 需要将大量点光源和聚光灯的数据打包并上传到 GPU 缓冲区（buffer）。这个缓冲区在着色器中用于光照计算。在此之前，数据的序列化（即将 Rust 结构体转换为字节流）工作是由 `encase` 库完成的。`encase` 提供了一个类型安全、符合 Rust 习惯的接口来操作统一缓冲区对象（UBO）和存储缓冲区对象（SSBO）。然而，这种安全性和便利性带来了运行时开销，包括动态类型检查、边界检查和可能额外的内存复制。

开发者发现，对于 `GpuClusteredLight` 这种特定的、结构固定的数据，`encase` 的抽象带来的开销是不必要的。性能分析显示，在 `many_lights` 基准测试中，灯光准备阶段（`prepare_lights` 系统）有显著的时间花费在这里。

解决方案是绕过 `encase`，直接使用更底层的 `RawBufferVec`。`RawBufferVec` 是 Bevy 渲染模块中的一个组件，它本质上是一个 `Vec<T>`，但专门用于高效地将 `T` 类型的数组上传到 GPU 缓冲区。它要求 `T` 实现 `bytemuck` 库的 `Pod`（“Plain Old Data”）特征，这保证了 `T` 可以被安全地重新解释为字节序列。这种方式的优势是消除了 `encase` 的序列化逻辑，直接进行内存对齐的字节拷贝，从而大幅减少了 CPU 开销。

实现过程主要涉及两个文件的重构。首先，在 `crates/bevy_pbr/src/cluster.rs` 中，核心数据结构 `GpuClusteredLights` 被彻底重写。原先它是一个枚举（`enum`），根据后端支持情况，内部包装 `UniformBuffer<GpuClusteredLightsUniform>` 或 `StorageBuffer<GpuClusteredLightsStorage>`，这两者都依赖 `encase`。现在，它被简化为一个结构体（`struct`），直接包含一个 `RawBufferVec<GpuClusteredLight>` 和一个表示缓冲区类型的布尔标志。

相应地，所有关联方法都被更新。`set` 方法被拆分为 `clear`、`add` 和 `len`，允许调用方逐步添加灯光数据，而不是一次性设置整个数组。`write_buffer` 方法现在直接委托给 `RawBufferVec::write_buffer`。`binding` 和 `min_size` 方法也进行了适配。为了满足 `RawBufferVec` 和 `bytemuck` 的要求，`GpuClusteredLight` 结构体添加了 `#[repr(C)]` 属性以及 `Pod` 和 `Zeroable` 派生宏。

其次，在 `crates/bevy_pbr/src/render/light.rs` 的 `prepare_lights` 函数中，对 `GpuClusteredLights` 的使用方式随之改变。之前，函数会先将所有灯光数据收集到一个本地的 `Vec<GpuClusteredLight>` 中，最后通过 `set` 方法一次性复制到 `GpuClusteredLights` 内部。现在，函数一开始就调用 `clear` 清空缓冲区，然后在循环中为每个灯光构造 `GpuClusteredLight` 实例后，立即通过 `add` 方法将其推入 `RawBufferVec`。这种改变不仅移除了 `encase` 的开销，还消除了一个额外的中间 `Vec` 的分配和复制操作。

这项优化的影响非常直接且正面。根据 PR 描述中的性能测试截图，在 `many_lights` 场景下，`prepare_lights` 系统的执行时间从 **6.27 毫秒降低到 5.2 毫秒**，实现了约 **20%** 的性能提升。这对于每帧都需要执行的渲染准备阶段来说，是一个显著的改进。从代码结构上看，修改后的实现更加简洁和直接，去除了不必要的抽象层，更贴近硬件的操作方式。这也提供了一个很好的范例：当遇到性能关键路径时，评估并替换高开销的通用库，转而使用为特定任务优化的、更底层的工具，往往是有效的优化手段。

## 组件关系图示

```mermaid
graph TD
    subgraph “重构前”
        A[`prepare_lights` 函数] --> B[创建 `Vec<GpuClusteredLight>`]
        B --> C{通过 `encase` 序列化}
        C -->|Uniform| D[`UniformBuffer<...>`]
        C -->|Storage| E[`StorageBuffer<...>`]
        D --> F[GPU 缓冲区]
        E --> F
    end

    subgraph “重构后”
        G[`prepare_lights` 函数] --> H[直接操作 `RawBufferVec<GpuClusteredLight>`]
        H --> I[GPU 缓冲区]
    end

    style C fill:#f9f,stroke:#333
    style H fill:#9f9,stroke:#333
```

## 关键文件更改

- `crates/bevy_pbr/src/cluster.rs` (+47/-48)
- `crates/bevy_pbr/src/render/light.rs` (+31/-31)

**文件：`crates/bevy_pbr/src/cluster.rs`**
**变化原因**：重构 `GpuClusteredLights` 类型，移除对 `encase` 的依赖，改用 `RawBufferVec` 来管理缓冲区数据。同时使 `GpuClusteredLight` 结构与 `bytemuck` 兼容。
**关键修改**：
1.  为 `GpuClusteredLight` 添加 `Pod`, `Zeroable` 特征派生和 `#[repr(C)]` 属性。
    ```rust
    // 之前:
    #[derive(Copy, Clone, ShaderType, Default, Debug)]
    pub struct GpuClusteredLight { ... }

    // 之后:
    #[derive(Copy, Clone, ShaderType, Default, Pod, Zeroable, Debug)]
    #[repr(C)]
    pub struct GpuClusteredLight { ... }
    ```
2.  将 `GpuClusteredLights` 从枚举重构成结构体，内部包含 `RawBufferVec`。
    ```rust
    // 之前:
    pub enum GpuClusteredLights {
        Uniform(UniformBuffer<GpuClusteredLightsUniform>),
        Storage(StorageBuffer<GpuClusteredLightsStorage>),
    }
    // 之后:
    pub struct GpuClusteredLights {
        data: RawBufferVec<GpuClusteredLight>,
        is_storage_buffer: bool,
    }
    ```
3.  核心方法被彻底重写，以操作 `RawBufferVec`。
    ```rust
    // 关键方法示例（新增）:
    pub(crate) fn clear(&mut self) {
        self.data.clear();
    }
    pub(crate) fn add(&mut self, light: GpuClusteredLight) {
        if self.is_storage_buffer || self.data.len() < MAX_UNIFORM_BUFFER_CLUSTERABLE_OBJECTS {
            self.data.push(light);
        }
    }
    pub fn binding(&self) -> Option<BindingResource<'_>> {
        self.data.binding() // 直接委托
    }
    ```

**文件：`crates/bevy_pbr/src/render/light.rs`**
**变化原因**：适配 `cluster.rs` 中的 API 变更，将灯光数据直接增量式地添加到 `GpuClusteredLights` 的 `RawBufferVec` 中，避免中间集合和批量复制。
**关键修改**：
1.  移除用于临时收集数据的 `Vec`，改为直接在循环中调用 `add`。
    ```rust
    // 之前:
    let mut gpu_clustered_lights = Vec::new();
    // ... 在循环中 push 到 gpu_clustered_lights ...
    global_clusterable_object_meta
        .gpu_clustered_lights
        .set(gpu_clustered_lights); // 最后一次性设置

    // 之后:
    global_clusterable_object_meta.gpu_clustered_lights.clear(); // 开始前清空
    // ... 在循环中直接 add ...
    global_clusterable_object_meta
        .gpu_clustered_lights
        .add(GpuClusteredLight { ... }); // 立即添加
    ```
2.  相应地移除了最后的 `set` 调用。

## 进一步阅读

1.  **`bytemuck` crate 文档**：了解 `Pod` 和 `Zeroable` 特征，这是进行安全、零开销字节转换的基础。
    *   https://docs.rs/bytemuck/latest/bytemuck/
2.  **Bevy `RawBufferVec` 源码**：深入理解这个底层缓冲区管理工具的实现。
    *   `crates/bevy_render/src/render_resource/buffer_vec.rs`
3.  **WebGPU / 现代图形 API 中的缓冲区**：理解 Uniform Buffer 和 Storage Buffer 的区别、用途及性能考量。
    *   https://github.com/gpuweb/gpuweb/wiki/Buffer-Usages
4.  **“Data-Oriented Design”资料**：本次优化是数据导向思想的一个体现，即根据数据的访问和使用模式来设计代码结构，以提升性能。