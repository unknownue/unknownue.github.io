+++
title = "#23101 Add the ability to set the number of cubes in `many_cubes`."
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23101-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23101-zh-cn-20260224" }}
+++

# Title

## Basic Information
- **标题**: Add the ability to set the number of cubes in `many_cubes`.
- **PR 链接**: https://github.com/bevyengine/bevy/pull/23101
- **作者**: pcwalton
- **状态**: MERGED
- **标签**: A-Rendering, C-Examples, S-Ready-For-Final-Review
- **创建时间**: 2026-02-21T22:05:05Z
- **合并时间**: 2026-02-24T02:35:54Z
- **合并者**: alice-i-cecile

## 描述翻译
令人意外的是，尽管 `many_cubes` 示例中有许多配置项，却缺少最明显的一个：设置立方体数量。这个提交添加了此功能。它的实现比预期的稍微复杂一些，因为立方体数量从未直接设置，而且示例支持三种不同的布局模式。

## 本次 PR 的技术分析

### 问题背景
`many_cubes` 是 Bevy 引擎的一个压力测试示例，用于测试大量实体下的渲染性能。该示例提供了多种配置选项，如禁用视锥体剔除 (frustum culling)、更改布局模式等。然而，在实际测试中，开发者发现无法直接控制立方体的生成数量。立方体数量由代码中的固定常量（如 `WIDTH * HEIGHT * 4`）决定，这限制了测试灵活性。

### 解决方案设计
PR 作者决定添加一个 `instance_count` 参数，允许用户直接指定立方体数量。由于示例支持三种不同的布局模式（球形、立方体、密集），每个模式的立方体生成逻辑都不同，因此需要分别调整每个模式的实现。

核心挑战在于：
1. 球形布局使用斐波那契螺旋算法在球面上分布点
2. 立方体布局需要处理摩尔纹 (moiré) 模式检查（跳过每第10行/列）
3. 密集布局需要计算三维网格的每边大小

### 具体实现
实现主要集中在 `examples/stress_tests/many_cubes.rs` 文件中，主要改动包括：

1. **添加新参数**：
```rust
/// the number of cubes
#[argh(option, default = "1600000")]
instance_count: usize,
```

2. **球形布局调整**：
将硬编码的 `N_POINTS` 替换为 `args.instance_count`：
```rust
let n_points: usize = args.instance_count;
for i in 0..n_points {
    let spherical_polar_theta_phi =
        fibonacci_spiral_on_sphere(golden_ratio, i, n_points);
    // ...
}
```

3. **立方体布局调整**：
这是最复杂的部分。由于立方体布局会跳过每第10行/列，并且每格生成4个立方体，实际立方体数量与网格尺寸不是线性关系。作者通过以下公式计算缩放因子：
```rust
let factor = (5.0 / 9.0) * sqrt(args.instance_count as f32)
    / (sqrt(HEIGHT as f32) * sqrt(WIDTH as f32));
let dimensions = (vec2(WIDTH as f32, HEIGHT as f32) * factor)
    .ceil()
    .as_uvec2();
```
这个公式确保了调整后的网格能生成近似于 `instance_count` 的立方体数量。

4. **密集布局调整**：
使用立方根计算每边大小，以创建近似立方体的三维网格：
```rust
let count = args.instance_count;
let size = cbrt(count as f32).round();
```

5. **材质初始化优化**：
当 `vary_material_data_per_instance` 启用时，材质容量现在直接使用 `args.instance_count`，而不是根据布局计算：
```rust
let capacity = if args.vary_material_data_per_instance {
    args.instance_count
} else {
    args.material_texture_count
}
```

### 技术细节
- 使用浮点数运算确保精确的立方体分布
- 保持向后兼容性：默认值为 1,600,000（与之前硬编码的数量一致）
- 网格尺寸向上取整 (`.ceil()`) 以确保至少生成请求的立方体数量
- 所有布局模式共享相同的 `instance_count` 参数，简化用户界面

### 影响与改进
这个改动使 `many_cubes` 示例更加灵活，开发者现在可以：
- 精确控制测试的实体数量
- 在不同数量级别进行性能比较
- 更容易复现特定数量的性能测试场景

代码变化虽然不大，但提供了更好的测试控制和更直观的用户体验。保持三种不同布局模式的实现一致性是本次改动的关键设计考虑。

## 可视化表示

```mermaid
graph TD
    A[用户输入 instance_count] --> B{布局模式}
    B --> C[球形布局]
    B --> D[立方体布局]
    B --> E[密集布局]
    
    C --> F[斐波那契螺旋分布<br/>n_points = instance_count]
    D --> G[计算缩放因子 factor<br/>调整网格尺寸 dimensions]
    E --> H[计算立方根 size<br/>size = cbrt(instance_count)]
    
    F --> I[生成指定数量立方体]
    G --> I
    H --> I
```

## 主要文件变更

### `examples/stress_tests/many_cubes.rs` (+39/-14)

1. **参数添加**：
添加 `instance_count` 命令行参数，默认值为 1,600,000。

```rust
// 添加：
/// the number of cubes
#[argh(option, default = "1600000")]
instance_count: usize,
```

2. **球形布局修改**：
将硬编码的立方体数量替换为动态值。

```rust
// 修改前：
const N_POINTS: usize = WIDTH * HEIGHT * 4;
for i in 0..N_POINTS {
    let spherical_polar_theta_phi =
        fibonacci_spiral_on_sphere(golden_ratio, i, N_POINTS);

// 修改后：
let n_points: usize = args.instance_count;
for i in 0..n_points {
    let spherical_polar_theta_phi =
        fibonacci_spiral_on_sphere(golden_ratio, i, n_points);
```

3. **立方体布局修改**：
添加缩放因子计算，动态调整网格尺寸。

```rust
// 添加缩放因子计算：
let factor = (5.0 / 9.0) * sqrt(args.instance_count as f32)
    / (sqrt(HEIGHT as f32) * sqrt(WIDTH as f32));
let dimensions = (vec2(WIDTH as f32, HEIGHT as f32) * factor)
    .ceil()
    .as_uvec2();

// 修改循环边界：
for x in 0..dimensions.x {
    for y in 0..dimensions.y {
        // ...
    }
}

// 调整相机位置计算：
let center = 0.5
    * scale
    * Vec3::new(
        dimensions.x as f32,
        dimensions.y as f32,
        dimensions.x as f32,
    );
```

4. **密集布局修改**：
使用立方根计算网格尺寸。

```rust
// 修改前：
let count = WIDTH * HEIGHT * 2;
let size = cbrt(count as f32).round();

// 修改后：
let count = args.instance_count;
let size = cbrt(count as f32).round();
```

5. **材质初始化优化**：
简化容量计算逻辑。

```rust
// 修改前：
let capacity = if args.vary_material_data_per_instance {
    match args.layout {
        Layout::Cube => (WIDTH - WIDTH / 10) * (HEIGHT - HEIGHT / 10),
        Layout::Sphere => WIDTH * HEIGHT * 4,
        Layout::Dense => WIDTH * HEIGHT * 2,
    }
} else {
    args.material_texture_count
}

// 修改后：
let capacity = if args.vary_material_data_per_instance {
    args.instance_count
} else {
    args.material_texture_count
}
```

## 延伸阅读

- [Bevy 示例文档](https://github.com/bevyengine/bevy/tree/main/examples) - 了解 Bevy 的各种示例
- [压力测试设计模式](https://bevy-cheatbook.github.io/features/stress-tests.html) - 游戏引擎压力测试的最佳实践
- [斐波那契螺旋算法](https://en.wikipedia.org/wiki/Fibonacci_number#Fibonacci_spirals) - 球形布局中使用的点分布算法
- [命令参数解析 (argh)](https://docs.rs/argh/latest/argh/) - Bevy 示例中使用的命令行参数解析库