+++
title = "#23062"
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23062-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23062-zh-cn-20260224" }}
+++

# Title

## 基本資訊
- **標題**: Fix volumetric rendering order problem
- **PR 連結**: https://github.com/bevyengine/bevy/pull/23062
- **作者**: dan-dozen
- **狀態**: MERGED
- **標籤**: C-Bug, D-Trivial, A-Rendering, S-Ready-For-Final-Review
- **建立時間**: 2026-02-19T22:00:00Z
- **合併時間**: 2026-02-24T03:08:28Z
- **合併者**: alice-i-cecile

## 描述翻譯

# Objective
- 修復體積霧（volumetric fog）在其他網格（meshes）後方渲染的問題。修復了 https://github.com/bevyengine/bevy/issues/17429

## Solution
- 更新著色器，使其在位於其他幾何體後方時不進行渲染。

## Testing
- 在 macOS 15.7.3 (24G419) Apple M3 Pro 上測試。
- 需要在其他平台上測試。
- 可透過 patch 這個變更（https://github.com/dan-dozen/bevy/pull/1/changes）並執行 `examples/3d/volumetric_fog.rs` 來測試。如果需要，我也樂意將對範例的修改包含進來。

---

## Showcase

<details>
  <summary>點擊查看展示</summary>

在修改前，可以看到體積霧出現在房屋內部，即使它位於前牆後方：
<img width="1392" height="860" alt="Screenshot 2026-02-19 at 4 59 03 PM" src="https://github.com/user-attachments/assets/a5ab1a19-ca39-453f-b6c4-8a667d8a5a88" />

修改後，體積霧不再可見：
<img width="1392" height="860" alt="Screenshot 2026-02-19 at 4 57 56 PM" src="https://github.com/user-attachments/assets/88d05951-a3fb-4a05-a85c-ddee31884b5c" />

</details>

---

## The Story of This Pull Request

這次的 PR 解決了一個體積渲染中的視覺錯誤。問題的核心在於體積霧的著色器計算深度時，沒有正確處理被不透明（opaque）物體完全遮擋的情況。

**問題與上下文**
在即時渲染中，體積效果（如霧、煙）通常使用射線步進（ray marching）技術，沿著從相機到場景中某點的視線累積顏色和透明度。為了正確渲染，必須知道體積的起點（通常是相機的近平面或第一個透明表面）和終點（第一個不透明表面的深度）。問題發生在 `volumetric_fog.wgsl` 的片段著色器中。原始程式碼使用 `abs(end_depth_view - start_depth_view)` 計算 `ray_length_view`。這會導致一個問題：當體積霧的終點深度（`end_depth_view`）小於起點深度（`start_depth_view`）時，意味著體積霧完全位於當前像素所對應的第一個不透明表面之後，本應被完全遮擋。然而，`abs()` 函數會將負的長度轉為正數，著色器仍會繼續執行射線步進，最終渲染出本不該出現的霧，造成視覺穿幫（如霧出現在實心牆壁的內部或後方）。

**解決方案與實作**
解決方案直接且有效。著色器需要識別何時體積霧被完全遮擋，並提前退出渲染。PR 作者將計算 `ray_length_view` 的公式從 `abs(end_depth_view - start_depth_view)` 改為 `max(0.0, end_depth_view - start_depth_view)`。這個改變確保了射線長度永遠為非負值。如果 `end_depth_view` 小於 `start_depth_view`，表示體積位於不透明表面之後，`max` 函數會將結果設為 0.0。

接著，新增了一個條件判斷：
```wgsl
if (ray_length_view == 0.0) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}
```
如果射線長度為零，意味著體積被完全遮擋，片段著色器會立即返回一個完全透明的顏色（RGBA 均為 0），從而跳過所有後續昂貴的射線步進計算。這不僅修復了視覺錯誤，也提升了在遮擋情況下的效能。

這個修復屬於「D-Trivial」（瑣碎）分類，因為它只修改了幾行程式碼，邏輯清晰，沒有引入複雜的依賴或架構變更。它專注於解決一個具體的渲染管線（rendering pipeline）問題。

**技術洞察**
這個問題凸顯了在體積渲染中深度測試（depth testing）的重要性。對於不透明物體，GPU 的深度緩衝（depth buffer）和深度測試可以自動處理遮擋。但對於像霧這樣的體積效果，它們是使用 alpha 混合在後處理（post-processing）階段繪製的，因此需要手動在著色器中進行深度比較來模擬遮擋。原程式碼的 `abs()` 可能是一個疏忽，或者最初是為了處理某些邊界情況，但它錯誤地處理了最常見的遮擋情況。

**影響**
這個修復的影響非常具體且正面：
1.  **視覺正確性**：消除了體積霧穿過不透明表面的錯誤，使渲染結果更符合物理直覺。
2.  **效能微優化**：在完全遮擋的像素上提前終止著色器執行，節省了不必要的計算。
3.  **程式碼清晰度**：新的邏輯（`max` 和提前返回）比使用 `abs` 更明確地傳達了「僅在前方渲染」的意圖。

總的來說，這是一個小而重要的修正，展示了即使在成熟的渲染引擎中，基礎的數學運算選擇也可能導致明顯的視覺錯誤，而清晰的邏輯和對渲染管線的理解是解決這類問題的關鍵。

## 視覺化表示

```mermaid
graph TD
    A[片段著色器開始] --> B[計算 start_depth_view 和 end_depth_view]
    B --> C{計算 ray_length_view = max(0.0, end - start)}
    C --> D{ray_length_view == 0.0?}
    D -->|是，體積被遮擋| E[提前返回透明顏色 vec4(0.0)]
    D -->|否，體積可見| F[繼續執行射線步進計算體積霧]
    F --> G[返回計算出的霧顏色]
    E --> H[著色器結束]
    G --> H
```

## 關鍵檔案變更

- **`crates/bevy_pbr/src/volumetric_fog/volumetric_fog.wgsl`** (+7/-1)
  這是此次 PR 唯一修改的檔案，包含了修復體積霧渲染順序問題的核心邏輯。

  1.  **變更內容與原因**：修改了射線長度的計算方式，並在射線長度為零（表示完全遮擋）時讓著色器提前退出，以避免渲染本應被遮擋的體積霧。
  2.  **程式碼片段**：
      ```wgsl
      // 修改前：
      let ray_length_view = abs(end_depth_view - start_depth_view);
      ```
      ```wgsl
      // 修改後：
      let ray_length_view = max(0.0, end_depth_view - start_depth_view);
      // If the end is behind the start of the first opaque pixel, then we know it
      // is occluded, and we don't need to render it
      if (ray_length_view == 0.0) {
          return vec4(0.0, 0.0, 0.0, 0.0);
      }
      ```
  3.  **與 PR 目的的關聯**：這兩行改動直接實現了 PR 的目標——防止體積霧在被其他幾何體遮擋時仍然被渲染。`max` 函數確保了可見的射線長度，而 `if` 語句則處理了不可見（被遮擋）的情況。

## Further Reading

若想深入了解此 PR 涉及的相關概念與技術，可以參考以下資源：

1.  **Bevy 渲染手冊 (Bevy Render Book)**：了解 Bevy 的渲染架構與管線。
2.  **WebGPU 與 WGSL 規範**：理解著色器語言語義，特別是座標系統與深度處理。
3.  **體積渲染 (Volume Rendering) 與射線步進 (Ray Marching)** 的基礎理論：
    -   "Real-Time Volume Graphics" 相關論文或教程。
    -   關於如何在後處理階段整合深度緩衝來進行遮蔽測試。
4.  **深度緩衝 (Z-Buffer) 與深度測試 (Depth Test)**：電腦圖學中處理物件前後遮擋關係的標準方法。