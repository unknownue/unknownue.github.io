+++
title = "#21984 Contiguous access"
date = "2026-02-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-21984-en-20260203" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-21984-zh-cn-20260203" }}
labels = ["C-Feature", "A-ECS", "C-Performance", "D-Complex", "M-Release-Note", "D-Unsafe"]
+++

# Title
Contiguous access

## Basic Information
- **Title**: Contiguous access
- **PR Link**: https://github.com/bevyengine/bevy/pull/21984
- **Author**: Jenya705
- **Status**: MERGED
- **Labels**: C-Feature, A-ECS, C-Performance, S-Ready-For-Review, D-Complex, M-Release-Note, D-Unsafe
- **Created**: 2025-11-30T15:04:09Z
- **Merged**: 2026-02-03T00:45:33Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

Enables accessing slices from tables directly via Queries.

Fixes: #21861

## Solution

One new trait:
- `ContiguousQueryData` allows to fetch all values from tables all at once (an implementation for `&T` returns a slice of components in the set table, for `&mut T` returns a mutable slice of components in the set table as well as a struct with methods to set update ticks (to match the `fetch` implementation))

Methods `contiguous_iter`, `contiguous_iter_mut` and similar in `Query` and `QueryState` making possible to iterate using these traits.

Macro `QueryData` was updated to support contiguous items when `contiguous(target)` attribute is added (a target can be `all`, `mutable` and `immutable`, refer to the `custom_query_param` example)

## Testing

- `sparse_set_contiguous_query` test verifies that you can't use `next_contiguous` with sparse set components
- `test_contiguous_query_data` test verifies that returned values are valid
- `base_contiguous` benchmark (file is named `iter_simple_contiguous.rs`)
- `base_no_detection` benchmark (file is named `iter_simple_no_detection.rs`)
- `base_no_detection_contiguous` benchmark (file is named `iter_simple_no_detection_contiguous.rs`)
- `base_contiguous_avx2` benchmark (file is named `iter_simple_contiguous_avx2.rs`)

---

## Showcase

Examples `contiguous_query`, `custom_query_param`

### Example
```rust
// - self.0 is a World
// - self.1 is a QueryState
// - velocity is a slice of components with Vec3 inside.
// - position is a data structure which implements Deref/DerefMut and IntoIterator methods to access the slice
// as well as mechanism to update update ticks (which it does automatically on dereference), 
// which may be bypassed via `bypass_change_detection` methods.
for (velocity, mut position) in self.1.contiguous_iter_mut(&mut self.0).unwrap() {
    assert!(velocity.len() == position.len());
    for (v, p) in velocity.iter().zip(position.iter_mut()) {
        p.0 += v.0;
    }
}
```

### Benchmarks
Code for `base` benchmark:
```rust
#[derive(Component, Copy, Clone)]
struct Transform(Mat4);

#[derive(Component, Copy, Clone)]
struct Position(Vec3);

#[derive(Component, Copy, Clone)]
struct Rotation(Vec3);

#[derive(Component, Copy, Clone)]
struct Velocity(Vec3);

pub struct Benchmark<'w>(World, QueryState<(&'w Velocity, &'w mut Position)>);

impl<'w> Benchmark<'w> {
    pub fn new() -> Self {
        let mut world = World::new();

        world.spawn_batch(core::iter::repeat_n(
            (
                Transform(Mat4::from_scale(Vec3::ONE)),
                Position(Vec3::X),
                Rotation(Vec3::X),
                Velocity(Vec3::X),
            ),
            10_000,
        ));

        let query = world.query::<(&Velocity, &mut Position)>();
        Self(world, query)
    }

    #[inline(never)]
    pub fn run(&mut self) {
        for (velocity, mut position) in self.1.iter_mut(&mut self.0) {
            position.0 += velocity.0;
        }
    }
}
```
Iterating over 10000 entities from **a single** table and increasing a 3-dimensional vector from component `Position` by a 3-dimensional vector from component `Velocity`

| Name                         | Time      | Time (AVX2) | Description                                                        |
|------------------------------|-----------|-------------|--------------------------------------------------------------------|
| base                         | 5.5828 µs | 5.5122 µs   | Iteration over components                                          |
| base_contiguous              | 4.8825 µs | 1.8665 µs   | Iteration over contiguous chunks                                   |
| base_contiguous_avx2         | 2.0740 µs | 1.8665 µs   | Iteration over contiguous chunks with enforced avx2 optimizations  |
| base_no_detection            | 4.8065 µs | 4.7723 µs   | Iteration over components while bypassing change detection through `bypass_change_detection()` method |
| base_no_detection_contiguous | 4.3979 µs | 1.5797 µs   | Iteration over components without registering update ticks         |

Using contiguous 'iterator' makes the program a little bit faster and it can be further vectorized to make it even faster

## The Story of This Pull Request

This PR introduces a new way to iterate over ECS queries in Bevy: contiguous iteration. The core problem being addressed is that standard query iteration processes entities one by one, which can miss optimization opportunities like auto-vectorization when operating on large groups of components stored contiguously in memory.

### The Problem and Context

In Bevy's ECS, components are stored in tables when they use table storage. When iterating over a query with standard methods like `iter()` or `iter_mut()`, the system fetches components entity by entity. This approach works well for general-purpose iteration but doesn't take advantage of the fact that components of the same type within a table are stored in contiguous memory blocks.

The issue #21861 highlighted the need for accessing these contiguous slices directly. Without this capability, developers couldn't leverage SIMD instructions or batch processing optimizations that require operating on arrays of data rather than individual elements. This was particularly relevant for performance-critical systems like physics simulations or particle systems that process thousands of entities with the same component layout.

### The Solution Approach

The solution introduces a new trait called `ContiguousQueryData` that extends the existing query system. Instead of fetching components one entity at a time, implementations of this trait can fetch entire slices of components from a table in one operation. The approach maintains compatibility with existing query patterns while adding new capabilities.

Key engineering decisions included:
1. Creating new iterator types (`QueryContiguousIter`) that operate at the table level rather than the entity level
2. Extending the `QueryData` derive macro to support generating contiguous item types
3. Ensuring the feature only works with "dense" queries (those using table storage, not sparse sets)
4. Maintaining change detection semantics through new types like `ContiguousMut` and `ContiguousRef`

### The Implementation

The implementation adds the `ContiguousQueryData` trait to the query system:

```rust
pub trait ContiguousQueryData: ArchetypeQueryData {
    type Contiguous<'w, 's>;
    
    unsafe fn fetch_contiguous<'w, 's>(
        state: &'s Self::State,
        fetch: &mut Self::Fetch<'w>,
        entities: &'w [Entity],
    ) -> Self::Contiguous<'w, 's>;
}
```

For basic component references, the implementations are straightforward:
- `&T` returns `&[T]` (a slice of immutable components)
- `&mut T` returns `ContiguousMut<T>` (which contains a mutable slice plus change tracking)

The `ContiguousMut` type deserves special attention because it handles change detection correctly:

```rust
pub struct ContiguousMut<'w, T> {
    pub(crate) value: &'w mut [T],
    pub(crate) ticks: ContiguousComponentTicksMut<'w>,
}
```

When you dereference `ContiguousMut` (via `DerefMut`), it automatically marks all components in the slice as changed. This matches the behavior of individual `&mut T` references but does it efficiently in bulk.

The query system gains new methods to use these contiguous iterators:

```rust
impl<'w, 's, D: QueryData, F: QueryFilter> Query<'w, 's, D, F> {
    pub fn contiguous_iter_mut(&mut self) -> Option<QueryContiguousIter<'_, 's, D, F>>
    where
        D: ContiguousQueryData,
        F: ArchetypeFilter,
    {
        self.reborrow().contiguous_iter_inner().ok()
    }
}
```

The `ArchetypeFilter` constraint is important: only filters that work at the archetype level (like `With<T>` and `Without<T>`) can be used with contiguous iteration. Filters that need to check individual entities (like `Changed<T>`) cannot be used because contiguous iteration operates on whole tables at once.

### Technical Insights

The implementation reveals several interesting technical details:

1. **Storage Type Awareness**: Contiguous iteration only works with table storage. The system checks if a query is "dense" (using only table storage) before allowing contiguous iteration. Sparse set components cannot be iterated contiguously because they don't store components in contiguous arrays.

2. **Change Detection at Scale**: The `ContiguousComponentTicksMut` type manages change ticks for entire slices. It provides methods like `mark_all_as_changed()` that efficiently update all ticks in the slice, which is more efficient than updating ticks individually.

3. **Bypassing Change Detection**: Like individual mutable references, `ContiguousMut` provides a `bypass_change_detection()` method that returns a mutable slice without updating change ticks. This is useful for performance when you know change detection isn't needed.

4. **Zero-Cost Abstraction**: When you use contiguous iteration with `&T`, the implementation returns a direct slice reference `&[T]` with no wrapper type. This means there's zero overhead compared to manually accessing the underlying storage.

5. **Filter Constraints**: The requirement for `ArchetypeFilter` ensures that filters can be evaluated at table granularity. This is a compile-time guarantee that prevents using filters that would require per-entity checks.

### The Impact

The benchmarks show significant performance improvements:
- **Standard contiguous iteration**: ~12.5% faster than regular iteration (4.88 µs vs 5.58 µs)
- **AVX2-optimized contiguous iteration**: ~66% faster than regular iteration (1.87 µs vs 5.51 µs)
- **Contiguous without change detection**: ~21% faster than regular iteration without change detection (4.40 µs vs 4.81 µs)

The performance gains come from several factors:
1. Reduced iteration overhead (processing tables instead of entities)
2. Better cache locality when operating on contiguous memory
3. Enabling compiler auto-vectorization
4. Explicit SIMD optimizations (like the AVX2 example)

Beyond performance, this feature enables new patterns in Bevy systems. Developers can now write algorithms that process components in batches, which is particularly useful for:
- Mathematical operations on large datasets
- Physics simulations
- Particle systems
- Any system where the same operation applies to many entities

The implementation maintains full backward compatibility—existing queries continue to work unchanged. Developers can opt into contiguous iteration where it makes sense for their performance requirements.

## Visual Representation

```mermaid
graph TD
    A[Query] --> B{Is dense?}
    B -->|No| C[Regular iteration]
    B -->|Yes| D[Contiguous iteration]
    D --> E[Table 1]
    D --> F[Table 2]
    D --> G[Table N]
    E --> H[&[T] slice]
    F --> I[ContiguousMut<T>]
    G --> J[Other contiguous types]
    H --> K[Auto-vectorization possible]
    I --> K
    J --> K
    C --> L[Entity-by-entity]
```

## Key Files Changed

1. **`crates/bevy_ecs/src/change_detection/params.rs` (+705/-1)**
   - Added new types: `ContiguousComponentTicksRef`, `ContiguousComponentTicksMut`, `ContiguousRef`, `ContiguousMut`
   - These types provide slice-based access to component values and their change ticks
   - Key addition: `ContiguousMut` which combines a mutable slice with change detection

2. **`crates/bevy_ecs/src/query/fetch.rs` (+467/-9)**
   - Added `ContiguousQueryData` trait definition
   - Implemented `ContiguousQueryData` for common query types: `&T`, `&mut T`, `Entity`, `Ref<T>`, `Mut<T>`, `Option<T>`, `Has<T>`, tuples, and `AnyOf`
   - Added comprehensive tests for contiguous query functionality

3. **`crates/bevy_ecs/macros/src/query_data.rs` (+204/-3)**
   - Extended the `QueryData` derive macro to support `#[query_data(contiguous(target))]` attribute
   - Generates additional types for contiguous iteration: `XContiguousItem` and `XReadOnlyContiguousItem`
   - Supports targets: `all`, `mutable`, `immutable`

4. **`crates/bevy_ecs/src/system/query.rs` (+100/-2)**
   - Added new methods to `Query`: `contiguous_iter()`, `contiguous_iter_mut()`, `contiguous_iter_inner()`
   - These methods return `Option<QueryContiguousIter>` (None if query isn't dense)

5. **`crates/bevy_ecs/src/query/iter.rs` (+92/-2)**
   - Added `QueryContiguousIter` struct for iterating over tables contiguously
   - Implemented `Iterator` for `QueryContiguousIter` that yields contiguous chunks

Example of the key change in `fetch.rs`:
```rust
impl<T: Component> ContiguousQueryData for &T {
    type Contiguous<'w, 's> = &'w [T];

    unsafe fn fetch_contiguous<'w, 's>(
        _state: &'s Self::State,
        fetch: &mut Self::Fetch<'w>,
        entities: &'w [Entity],
    ) -> Self::Contiguous<'w, 's> {
        fetch.components.extract(
            |table| {
                // SAFETY: The caller ensures `set_table` was previously called
                let table = unsafe { table.debug_checked_unwrap() };
                // SAFETY: `table` is `entities.len()` long
                unsafe { table.cast().as_slice_unchecked(entities.len()) }
            },
            |_| {
                // Sparse set case - unreachable for dense queries
                core::hint::unreachable_unchecked();
            },
        )
    }
}
```

## Further Reading

1. **Bevy ECS Documentation**: https://bevyengine.org/learn/book/ecs/
2. **SIMD Programming Guide**: https://doc.rust-lang.org/std/simd/index.html
3. **Data-Oriented Design Resources**: https://github.com/dbartolini/data-oriented-design
4. **Change Detection in Bevy**: https://bevyengine.org/learn/book/change-detection/
5. **Rust Performance Book**: https://nnethercote.github.io/perf-book/