+++
title = "#22872 Release-0.18.1: Ensure other half `Gizmos` Observer Fix lands correctly in release branch"
date = "2026-02-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22872-en-20260209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22872-zh-cn-20260209" }}
+++

# 标题

## 基本信息
- **标题**: Release-0.18.1: Ensure other half `Gizmos` Observer Fix lands correctly in release branch
- **PR链接**: https://github.com/bevyengine/bevy/pull/22872
- **作者**: kfc35
- **状态**: 已合并
- **标签**: S-Ready-For-Final-Review, A-Gizmos
- **创建时间**: 2026-02-09T03:00:40Z
- **合并时间**: 2026-02-09T22:35:05Z
- **合并者**: alice-i-cecile

## 描述翻译

> [!重要]
> 此PR将合并到 `release-0.18.1` 分支，而不是 `main` 分支

# 目标

- 确保 #22800（在 0.18.1 里程碑中）的缺失部分（该部分作为 #22832（在 0.19.0 里程碑中）的一部分被合并）仍然能在 0.18.1 版本中应用

## 解决方案

- 确保在 `SystemBuffer` 的 `GizmoBuffer` 中实现 `queue()` 方法，并让 `apply()` 方法委托给 `queue()`

解决方案的另一半，即 #22800，位于 0.18.1 里程碑中，最终会在需要时放入此分支。

（此PR中的代码原本在 #22800 中，但当 #22832 先于它被合并时，这个更改就丢失了）。

## 这个Pull Request的故事

这是一个典型的版本管理问题：一个修复被意外地拆分到了不同的开发分支中，导致发布分支缺少了关键部分。

### 问题背景：Git合并时的代码丢失

整个问题源于两个相关PR的时间线和目标分支差异：
- #22800 是针对 0.18.1 版本的修复
- #22832 是针对 0.19.0（主分支）的修复

当 #22832 在 #22800 之前被合并到主分支时，它包含了 #22800 的部分修复代码。但由于这两个PR针对不同分支，且 #22800 尚未合并到 release-0.18.1 分支，导致了一个分裂状态：主分支有完整的修复，而发布分支只有部分修复。

具体到代码层面，问题是关于 Bevy 的 `Gizmos` 系统和观察者（Observer）模式的兼容性。`GizmoBuffer` 是一个 `SystemBuffer`，需要正确实现两个关键方法：
1. `apply()` - 立即应用更改
2. `queue()` - 将更改排队以供延迟应用

观察者系统需要使用 `queue()` 方法来正确跟踪和处理 gizmo 的绘制操作。如果没有正确实现 `queue()`，观察者可能无法正常工作，导致 gizmo 渲染问题。

### 解决方案：补全缺失的实现

这个PR的解决方案直接且高效：确保 `GizmoBuffer` 正确实现了 `SystemBuffer` 所需的两个方法，并让它们协同工作。

关键的代码更改只有几行，但解决了重要的兼容性问题：

```rust
// 更改前：只有 apply 方法，直接操作 World
fn apply(&mut self, _system_meta: &SystemMeta, world: &mut World) {
    let mut storage = world.resource_mut::<GizmoStorage<Config, Clear>>();
    storage.list_positions.append(&mut self.list_positions);
    // ... 其他字段
}

// 更改后：apply 委托给 queue，queue 使用 DeferredWorld
fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
    self.queue(system_meta, world.into());  // 关键改变：调用 queue 方法
}

fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
    let mut storage = world.resource_mut::<GizmoStorage<Config, Clear>>();
    storage.list_positions.append(&mut self.list_positions);
    // ... 其他字段
}
```

### 技术洞察：DeferredWorld 的角色

这里的核心变化是从直接使用 `World` 切换到使用 `DeferredWorld`。这在 Bevy 的 ECS（Entity Component System）架构中是一个重要模式：

1. **立即执行 vs 延迟执行**：
   - `apply()` 应该立即应用更改
   - `queue()` 应该将更改排队以供稍后应用
   - 通过让 `apply()` 调用 `queue()`，我们确保两种路径都使用相同的逻辑

2. **`DeferredWorld` 的作用**：
   - 提供了一种安全的方式来排队对世界的更改
   - 允许观察者系统在适当的时间点处理这些更改
   - 对于 gizmo 这样的渲染系统特别重要，因为渲染通常需要在特定阶段进行

3. **类型转换**：`world.into()` 调用将 `&mut World` 转换为 `DeferredWorld`，这是通过 Bevy 的转换特性实现的

### 影响和教训

这个看似简单的更改实际上解决了几个重要问题：

1. **观察者兼容性**：确保 gizmo 系统能够正确与 Bevy 的观察者系统集成
2. **代码一致性**：统一了立即执行和延迟执行的路径
3. **版本管理教训**：凸显了在多分支开发中保持修复完整性的重要性

从工程角度看，这个PR提供了一个很好的案例，说明即使在复杂的版本管理场景中，保持代码简单和一致的价值。通过确保 `apply()` 和 `queue()` 使用相同的底层逻辑，我们减少了代码重复，并确保两种执行路径产生相同的结果。

## 可视化表示

```mermaid
graph TD
    A[SystemBuffer trait] --> B[GizmoBuffer]
    B --> C[apply()方法]
    B --> D[queue()方法]
    C --> E[调用 world.into()]
    E --> F[转换为 DeferredWorld]
    F --> D
    D --> G[操作 GizmoStorage]
```

## 关键文件变更

**文件**: `crates/bevy_gizmos/src/gizmos.rs` (+6/-2)

**更改描述**：
这个文件修改了 `GizmoBuffer` 的 `SystemBuffer` 实现。主要变化是添加了 `queue()` 方法的实现，并修改 `apply()` 方法使其委托给 `queue()` 方法。

**代码变更**：
```rust
// 关键变更：导入 DeferredWorld
use bevy_ecs::{
    world::{unsafe_world_cell::UnsafeWorldCell, DeferredWorld, World},
};

// 关键变更：apply 方法现在委托给 queue 方法
fn apply(&mut self, system_meta: &SystemMeta, world: &mut World) {
    self.queue(system_meta, world.into());  // 添加了这行
}

// 关键变更：queue 方法的实现
fn queue(&mut self, _system_meta: &SystemMeta, mut world: DeferredWorld) {
    let mut storage = world.resource_mut::<GizmoStorage<Config, Clear>>();
    storage.list_positions.append(&mut self.list_positions);
    storage.list_colors.append(&mut self.list_colors);
    // ... 其他字段
}
```

## 进一步阅读

1. **Bevy ECS 系统缓冲器**：了解 `SystemBuffer` trait 的作用和实现
2. **观察者模式在游戏引擎中的应用**：了解观察者模式如何用于处理游戏状态变更
3. **Git分支管理策略**：学习如何有效管理多版本并行开发
4. **Deferred Execution模式**：了解延迟执行在实时系统中的应用

**相关PR**：
- #22800: 原始修复的完整版本
- #22832: 包含部分修复的主分支PR

**Bevy文档**：
- [SystemParam and SystemBuffer](https://docs.rs/bevy/latest/bevy/ecs/system/trait.SystemParam.html)
- [Observer Pattern in Bevy](https://bevyengine.org/learn/quick-start/ecs/observers/)