+++
title = "#23147 Fix wireframe and examples with mesh pipeline set"
date = "2026-02-25T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23147-en-20260225" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23147-zh-cn-20260225" }}
+++

# Fix wireframe and examples with mesh pipeline set

## 基本信息
- **标题**: Fix wireframe and examples with mesh pipeline set
- **PR链接**: https://github.com/bevyengine/bevy/pull/23147
- **作者**: mockersf
- **状态**: 已合并
- **标签**: C-Bug, A-Rendering, S-Ready-For-Final-Review, P-Regression
- **创建时间**: 2026-02-25T11:17:43Z
- **合并时间**: 2026-02-25T19:39:09Z
- **合并者**: alice-i-cecile

## 描述翻译

### 目标
- #22443 破坏了线框渲染和部分示例

### 解决方案
- 通过让系统在 `MeshPipelineSet` 之后运行来修复它们
- 同时添加迁移指南

### 测试
- 运行已修改的示例或任何使用线框渲染的功能

## 此拉取请求的技术故事

这个PR修复了一个由前一个PR (#22443) 引入的回归问题。问题的本质是系统执行顺序的依赖关系没有得到正确处理。

### 问题和背景

在PR #22443中，某些资源（`MeshPipelineViewLayouts`、`MeshPipeline` 和 `RenderDebugOverlayPipeline`）的创建被移到了 `RenderStartup` 调度中。这是一个架构上的改进，但引入了一个隐藏的依赖问题：多个系统需要在这些资源创建之后才能运行。

具体来说，线框渲染系统和几个高级着色器示例中的系统，都依赖于 `MeshPipeline` 相关的资源。当这些系统在 `MeshPipelineSet` 之前运行时，它们会尝试访问尚未初始化的资源，导致运行时错误或渲染异常。

这个问题是一个典型的"回归" - 新功能破坏了现有的功能。在这种情况下，破坏的包括：
- 线框渲染功能
- 多个高级着色器示例：`custom_render_phase`、`custom_shader_instancing`、`specialized_mesh_pipeline`

### 解决方案

解决方案在概念上很简单，但需要仔细修改：确保所有依赖于 `MeshPipeline` 资源的系统都在 `MeshPipelineSet` 之后运行。

技术上，这通过修改系统调度来实现。对于每个受影响的系统，开发者添加了 `.after(MeshPipelineSet)` 约束。这确保了正确的执行顺序：
1. 首先，`MeshPipelineSet` 系统集运行，创建所需的资源
2. 然后，依赖这些资源的系统运行

### 实现细节

让我们具体看看修改。每个受影响的文件都遵循相同的模式：

首先，需要导入 `MeshPipelineSet`。在之前，这些文件可能没有导入它，或者使用的是不同的导入。例如，在 `wireframe.rs` 中：

```rust
// 修改前：
use crate::{
    render::{PreprocessBindGroups, PreprocessPipelines},
    DrawMesh, MeshPipeline, MeshPipelineKey, RenderLightmaps, RenderMeshInstanceFlags,
    RenderMeshInstances, SetMeshBindGroup, SetMeshViewBindGroup, SetMeshViewBindingArrayBindGroup,
    ViewKeyCache,
};

// 修改后：
use crate::{
    render::{PreprocessBindGroups, PreprocessPipelines},
    DrawMesh, MeshPipeline, MeshPipelineKey, MeshPipelineSet, RenderLightmaps,
    RenderMeshInstanceFlags, RenderMeshInstances, SetMeshBindGroup, SetMeshViewBindGroup,
    SetMeshViewBindingArrayBindGroup, ViewKeyCache,
};
```

然后，修改系统调度，添加 `.after(MeshPipelineSet)` 约束：

```rust
// 修改前：
.add_systems(RenderStartup, init_wireframe_3d_pipeline)

// 修改后：
.add_systems(
    RenderStartup,
    init_wireframe_3d_pipeline.after(MeshPipelineSet),
)
```

这种模式在所有四个受影响的代码文件中重复出现。这显示了良好的代码一致性 - 所有地方都使用相同的解决方案来解决相同的问题。

### 技术洞察

这里有几个重要的技术点：

1. **系统顺序的重要性**：在Bevy的ECS架构中，系统执行顺序至关重要。当系统之间存在依赖关系（特别是资源创建和使用的依赖）时，必须显式指定顺序。

2. **系统集(SystemSet)的使用**：`MeshPipelineSet` 是一个系统集，它包含一组相关的系统。通过使用 `.after(MeshPipelineSet)`，我们实际上是在说："在这个系统集的所有系统完成后运行"。这比指定单个系统更清晰，也更有弹性。

3. **显式依赖 vs 隐式依赖**：之前，依赖是隐式的 - 系统只是"期望"资源已经存在。现在，依赖变成了显式的，通过调度约束来表达。这使得依赖关系更清晰，也更容易维护。

4. **迁移指南的重要性**：这个PR还添加了一个迁移指南文件。这是一个很好的实践，因为它：
   - 帮助其他开发者了解变化
   - 提供明确的指导，告诉他们如果遇到类似问题该如何修复自己的代码
   - 记录了这次改变的原因和影响

### 影响

这些修改的影响是直接的：
1. 线框渲染功能恢复正常
2. 受影响的高级着色器示例再次正常工作
3. 其他可能依赖 `MeshPipeline` 资源的自定义渲染管道现在有了明确的指导来修复类似问题

从架构角度来看，这个修复加强了系统的可靠性，通过显式的依赖关系减少了未来的潜在问题。

## 可视化表示

```mermaid
graph TD
    A[PR #22443] --> B[移动资源创建到 RenderStartup]
    B --> C[导致系统顺序问题]
    C --> D[线框渲染和示例损坏]
    D --> E[PR #23147 修复]
    E --> F[添加 .after(MeshPipelineSet) 约束]
    E --> G[添加迁移指南]
    F --> H[系统顺序正确]
    G --> I[开发者知道如何迁移]
    H --> J[功能恢复正常]
```

## 关键文件变更

### 1. `crates/bevy_pbr/src/wireframe.rs` (+7/-4)
- **修改内容**：修复线框渲染管道的初始化系统，确保它在 `MeshPipelineSet` 之后运行
- **关键代码变更**：
  ```rust
  // 修改前：
  .add_systems(RenderStartup, init_wireframe_3d_pipeline)
  
  // 修改后：
  .add_systems(
      RenderStartup,
      init_wireframe_3d_pipeline.after(MeshPipelineSet),
  )
  ```

### 2. `examples/shader_advanced/specialized_mesh_pipeline.rs` (+7/-3)
- **修改内容**：修复自定义网格管道示例，确保初始化系统在正确的时间运行
- **关键代码变更**：
  ```rust
  // 修改前：
  .add_systems(RenderStartup, init_custom_mesh_pipeline)
  
  // 修改后：
  .add_systems(
      RenderStartup,
      init_custom_mesh_pipeline.after(MeshPipelineSet),
  )
  ```

### 3. `release-content/migration-guides/meshpipelineset-renderstartup-systems.md` (+6/-0)
- **修改内容**：新增迁移指南，记录这个变化并指导其他开发者
- **文件内容**：
  ```
  ---
  title: Resources `MeshPipelineViewLayouts`, `MeshPipeline` and `RenderDebugOverlayPipeline` are now created in `RenderStartup` systems
  pull_requests: [22443]
  ---

  Systems using the `MeshPipelineViewLayouts`, `MeshPipeline` and `RenderDebugOverlayPipeline` resources in the `RenderStartup` schedule now need to be run after the `MeshPipelineSet` system set.
  ```

### 4. `examples/shader_advanced/custom_render_phase.rs` (+2/-2)
- **修改内容**：修复自定义渲染阶段示例
- **关键代码变更**：
  ```rust
  // 修改前：
  .add_systems(RenderStartup, init_stencil_pipeline)
  
  // 修改后：
  .add_systems(RenderStartup, init_stencil_pipeline.after(MeshPipelineSet))
  ```

### 5. `examples/shader_advanced/custom_shader_instancing.rs` (+2/-2)
- **修改内容**：修复自定义着色器实例化示例
- **关键代码变更**：
  ```rust
  // 修改前：
  .add_systems(RenderStartup, init_custom_pipeline)
  
  // 修改后：
  .add_systems(RenderStartup, init_custom_pipeline.after(MeshPipelineSet))
  ```

## 进一步阅读

1. **Bevy调度系统文档**：了解Bevy ECS中系统调度和顺序控制的最佳实践
2. **系统集(SystemSet)概念**：深入研究如何组织和分组相关系统
3. **资源生命周期管理**：理解Bevy中资源的创建、访问和销毁时机
4. **回归测试的重要性**：这个PR展示了为什么回归测试对于确保更改不会破坏现有功能至关重要