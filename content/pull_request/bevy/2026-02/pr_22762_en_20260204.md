+++
title = "#22762 Adds Frustum Gizmo"
date = "2026-02-04T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22762-en-20260204" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22762-zh-cn-20260204" }}
labels = ["C-Feature", "A-Math", "A-Gizmos", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Adds Frustum Gizmo
- **PR Link**: https://github.com/bevyengine/bevy/pull/22762
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: C-Feature, S-Ready-For-Final-Review, A-Math, A-Gizmos, D-Straightforward
- **Created**: 2026-02-01T02:49:48Z
- **Merged**: 2026-02-04T01:14:37Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

- Adopts #10038 by @tim-blackbird 
- Half of #19468 (no camera gizmo, just frustum)
- Does Part 3 of and fixes #13878

## Solution

I stand on the shoulders of giants and have updated #10038 to main, with the following changes:
- The frustum gizmos are now immediate gizmos, not retained
- The current view's frustum is drawn around the border of the screen as a color like so (note the green border at the left, bottom, and right edges of the screen).
<img width="1286" height="752" alt="Screenshot 2026-01-31 at 9 18 41 PM" src="https://github.com/user-attachments/assets/7ed2b4db-1710-4be1-b6ca-00725d09944f" />

Also thanks to @RCoder01 for their github gist attached to the original PR; my updates basically ended up being the same although code is more or less in its proper place now.

## Testing

- I ran some scene_viewer gltf files in the bevy repo (e.g. `cargo run --example scene_viewer --features "free_camera" -- assets/models/cubes/Cubes.glb`). I guess none have multiple cameras though to cycle through though as far as I could tell? But at least this shows you that toggling the frusta shows the faint border around the screen.
- I ran the light_gizmos example `cargo run --example light_gizmos`. Only `SpotLight` has gizmos drawn (`PointLight` and `DirectionalLight` have components that wrap `Frustum` but not `Frustum` itself). It's the yellow gizmo in the following screenshot. Since there are dedicated light gizmos, using a Frustum gizmo on a light seems unnecessary.
<img width="1278" height="740" alt="Screenshot 2026-01-31 at 9 36 54 PM" src="https://github.com/user-attachments/assets/6e676bb8-32d4-4d90-9225-ee3a878745a6" />
- Like the original author, I modified the `split_screen` example to see a camera frustum gizmo from one player on another player's screen. I removed players 3 and 4, added a frustum gizmo for player 2's camera, and moved player 1's camera far enough so that you can see the frustum.
<img width="1274" height="740" alt="Screenshot 2026-01-31 at 9 09 46 PM" src="https://github.com/user-attachments/assets/fff38469-9d00-46ba-9098-fdf8418b54fa" />

---

## Showcase

<details>
  <summary>Modified `split_screen` example code</summary>

```rust
//! Renders four cameras to the same window to accomplish "split screen".

use std::f32::consts::PI;

use bevy::{
    camera::Viewport, light::CascadeShadowConfigBuilder, prelude::*, window::WindowResized,
};

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup)
        .add_systems(Update, (set_camera_viewports, button_system))
        .run();
}

/// set up a simple 3D scene
fn setup(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    // plane
    commands.spawn((
        Mesh3d(meshes.add(Plane3d::default().mesh().size(100.0, 100.0))),
        MeshMaterial3d(materials.add(Color::srgb(0.3, 0.5, 0.3))),
    ));

    commands.spawn(SceneRoot(
        asset_server.load(GltfAssetLabel::Scene(0).from_asset("models/animated/Fox.glb")),
    ));

    // Light
    commands.spawn((
        Transform::from_rotation(Quat::from_euler(EulerRot::ZYX, 0.0, 1.0, -PI / 4.)),
        DirectionalLight {
            shadow_maps_enabled: true,
            ..default()
        },
        CascadeShadowConfigBuilder {
            num_cascades: if cfg!(all(
                feature = "webgl2",
                target_arch = "wasm32",
                not(feature = "webgpu")
            )) {
                // Limited to 1 cascade in WebGL
                1
            } else {
                2
            },
            first_cascade_far_bound: 200.0,
            maximum_distance: 280.0,
            ..default()
        }
        .build(),
    ));

    // Cameras and their dedicated UI
    for (index, (camera_name, camera_pos)) in [
        ("Player 1", Vec3::new(300.0, 300.0, -150.0)),
        ("Player 2", Vec3::new(150.0, 150., 50.0)),
    ]
    .iter()
    .enumerate()
    {
        let camera = commands
            .spawn((
                Camera3d::default(),
                Transform::from_translation(*camera_pos).looking_at(Vec3::ZERO, Vec3::Y),
                Camera {
                    // Renders cameras with different priorities to prevent ambiguities
                    order: index as isize,
                    ..default()
                },
                CameraPosition {
                    pos: index as u32 % 2,
                },
                ShowFrustumGizmo {
                    color: if index == 0 { Some(Color::NONE) } else { None },
                },
            ))
            .id();

        // Set up UI
        if index == 0 {
        commands.spawn((
            UiTargetCamera(camera),
            Node {
                width: percent(100),
                height: percent(100),
                ..default()
            },
            children![
                (
                    Text::new(*camera_name),
                    Node {
                        position_type: PositionType::Absolute,
                        top: px(12),
                        left: px(12),
                        ..default()
                    },
                ),
                buttons_panel(),
            ],
        ));
        }
    }

    fn buttons_panel() -> impl Bundle {
        (
            Node {
                position_type: PositionType::Absolute,
                width: percent(100),
                height: percent(100),
                display: Display::Flex,
                flex_direction: FlexDirection::Row,
                justify_content: JustifyContent::SpaceBetween,
                align_items: AlignItems::Center,
                padding: UiRect::all(px(20)),
                ..default()
            },
            children![
                rotate_button("<", Direction::Left),
                rotate_button(">", Direction::Right),
            ],
        )
    }

    fn rotate_button(caption: &str, direction: Direction) -> impl Bundle {
        (
            RotateCamera(direction),
            Button,
            Node {
                width: px(40),
                height: px(40),
                border: UiRect::all(px(2)),
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                ..default()
            },
            BorderColor::all(Color::WHITE),
            BackgroundColor(Color::srgb(0.25, 0.25, 0.25)),
            children![Text::new(caption)],
        )
    }
}

#[derive(Component)]
struct CameraPosition {
    pos: u32,
}

#[derive(Component)]
struct RotateCamera(Direction);

enum Direction {
    Left,
    Right,
}

fn set_camera_viewports(
    windows: Query<&Window>,
    mut window_resized_reader: MessageReader<WindowResized>,
    mut query: Query<(&CameraPosition, &mut Camera)>,
) {
    // We need to dynamically resize the camera's viewports whenever the window size changes
    // so then each camera always takes up half the screen.
    // A resize_event is sent when the window is first created, allowing us to reuse this system for initial setup.
    for window_resized in window_resized_reader.read() {
        let window = windows.get(window_resized.window).unwrap();
        let size = window.physical_size();

        for (camera_position, mut camera) in &mut query {
            camera.viewport = Some(Viewport {
                physical_position: camera_position.pos * size,
                physical_size: size,
                ..default()
            });
        }
    }
}

fn button_system(
    interaction_query: Query<
        (&Interaction, &ComputedUiTargetCamera, &RotateCamera),
        (Changed<Interaction>, With<Button>),
    >,
    mut camera_query: Query<&mut Transform, With<Camera>>,
) {
    for (interaction, computed_target, RotateCamera(direction)) in &interaction_query {
        if let Interaction::Pressed = *interaction {
            // Since TargetCamera propagates to the children, we can use it to find
            // which side of the screen the button is on.
            if let Some(mut camera_transform) = computed_target
                .get()
                .and_then(|camera| camera_query.get_mut(camera).ok())
            {
                let angle = match direction {
                    Direction::Left => -0.1,
                    Direction::Right => 0.1,
                };
                camera_transform.rotate_around(Vec3::ZERO, Quat::from_axis_angle(Vec3::Y, angle));
            }
        }
    }
}

```

</details>

## The Story of This Pull Request

This PR addresses a long-standing need for visualizing camera frustums in the Bevy engine. Before this change, developers working with cameras and frustum culling had to rely on mental models or external tools to understand the spatial relationships between cameras and visible geometry. The implementation builds upon previous work from community contributors, specifically PR #10038, while updating the approach to use immediate-mode gizmos instead of retained gizmos for better performance and consistency with Bevy's existing gizmo system.

The core problem was straightforward: cameras and lights in Bevy have Frustum components that define their field of view, but there was no built-in way to visualize these geometric shapes for debugging purposes. This made it difficult to debug camera positioning, understand why certain objects weren't rendering, or visualize spatial relationships in multi-camera setups like split-screen games.

The solution follows a consistent pattern already established in Bevy for other debug visualizations like AABBs (Axis-Aligned Bounding Boxes). The implementation adds a new `FrustumGizmoPlugin` that provides two ways to enable frustum visualization: either by adding a `ShowFrustumGizmo` component to individual camera entities, or by globally enabling frustum drawing through configuration. This dual approach gives developers flexibility - they can debug specific cameras while avoiding visual clutter from all cameras in complex scenes.

A key technical challenge was computing the 8 corners of a frustum from its mathematical representation. Frustums in Bevy are defined by 6 half-spaces (planes), and calculating the intersection points where three planes meet gives us the corners. The implementation needed to handle edge cases like infinite far planes (used in directional lights) and degenerate frustums. The solution involved adding two new mathematical primitives:

```rust
// In bevy_math/src/primitives/half_space.rs
pub fn intersection_point(a: HalfSpace, b: HalfSpace, c: HalfSpace) -> Option<Vec3>

// In bevy_math/src/primitives/view_frustum.rs  
pub fn corners(&self) -> Option<[Vec3; 8]>
```

The `intersection_point` function computes where three planes meet using linear algebra. For planes defined by equations `n·x + d = 0`, we can solve for the intersection point using determinants. The implementation handles cases where planes are parallel or coincident by returning `None` when the determinant is near zero.

The frustum visualization system integrates cleanly with Bevy's existing architecture. It runs in the `PostUpdate` schedule, specifically after `VisibilitySystems::UpdateFrusta` to ensure frustums are up-to-date before drawing them. For spotlights (which also have frustums), the system ordering was adjusted so that light frustum updates happen before gizmo drawing when the `bevy_gizmos` feature is enabled.

Performance considerations were addressed by making the frustum corners computation lazy - corners are only computed when actually drawing the gizmo. The immediate-mode gizmo API ensures that frustum lines are only generated and submitted to the GPU when actually needed, avoiding overhead when frustum visualization is disabled.

The implementation also includes comprehensive testing for the mathematical functions, with test cases covering normal frustums, degenerate cases, and frustums with infinite far planes. These tests ensure that the corner computation handles edge cases correctly and returns appropriate values (including NaN for corners that don't exist, like with infinite far planes).

For developers, this feature significantly improves the debugging experience. The scene viewer example was updated to include a toggle (F key) for visualizing camera frustums, making it immediately useful. In multi-camera setups like split-screen games, developers can now see exactly what each camera can see, which is particularly valuable for debugging viewport configuration and frustum culling issues.

## Visual Representation

```mermaid
graph TD
    A[FrustumGizmoPlugin] --> B[FrustumGizmoSystems]
    B --> C[draw_frustum_gizmos]
    B --> D[draw_all_frustum_gizmos]
    
    E[ShowFrustumGizmo component] --> C
    F[FrustumGizmoConfigGroup] --> D
    
    G[ViewFrustum::corners()] --> H[HalfSpace::intersection_point()]
    H --> I[Compute 8 corners]
    I --> C
    I --> D
    
    C --> J[Gizmos::linestrip/line]
    D --> J
    J --> K[Rendered frustum wireframe]
```

## Key Files Changed

### 1. `crates/bevy_gizmos/src/frustum.rs` (+149/-0)
This new file contains the core frustum visualization system. It defines:
- `FrustumGizmoPlugin` - registers the frustum gizmo systems
- `FrustumGizmoConfigGroup` - configuration for controlling frustum visualization
- `ShowFrustumGizmo` component - marker component for entities whose frustums should be drawn
- Drawing systems that query entities with `Frustum` components and draw them as gizmos

Key code snippet:
```rust
// The drawing system for entities with ShowFrustumGizmo component
fn draw_frustum_gizmos(
    query: Query<(Entity, &Frustum, &ShowFrustumGizmo)>,
    mut gizmos: Gizmos<FrustumGizmoConfigGroup>,
) {
    for (entity, &frustum, gizmo) in &query {
        let color = gizmo
            .color
            .or(gizmos.config_ext.default_color)
            .unwrap_or_else(|| color_from_entity(entity));

        frustum_inner(&frustum, color, &mut gizmos);
    }
}
```

### 2. `crates/bevy_math/src/primitives/view_frustum.rs` (+165/-0)
Adds the `corners()` method to `ViewFrustum` that computes the 8 corners from the 6 half-spaces. This is the mathematical foundation for the visualization.

Key code snippet:
```rust
pub fn corners(&self) -> Option<[Vec3; 8]> {
    let [left, right, top, bottom, near, far] = self.half_spaces;
    Some([
        HalfSpace::intersection_point(top, left, near)?,
        HalfSpace::intersection_point(top, right, near)?,
        // ... 6 more corners computed similarly
    ])
}
```

### 3. `crates/bevy_math/src/primitives/half_space.rs` (+76/-1)
Adds the `intersection_point()` method that computes where three planes intersect using linear algebra.

Key code snippet:
```rust
pub fn intersection_point(a: HalfSpace, b: HalfSpace, c: HalfSpace) -> Option<Vec3> {
    // Set up matrices and solve using determinants
    let denom = x.dot(u);
    if ops::abs(denom) < f32::EPSILON {
        return None;
    }
    Some(Vec3::new(d.dot(u), z.dot(v), -y.dot(v)) / denom)
}
```

### 4. `crates/bevy_gizmos/src/lib.rs` (+14/-1)
Integrates the new frustum module into the gizmo system and moves the `color_from_entity` function to be shared between AABB and frustum gizmos.

Key changes:
```rust
// Added to prelude
pub use crate::frustum::{FrustumGizmoConfigGroup, ShowFrustumGizmo};

// Added to plugins
app.add_plugins((
    aabb::AabbGizmoPlugin,
    frustum::FrustumGizmoPlugin,  // New
    global::GlobalGizmosPlugin,
));

// Shared color generation function
pub fn color_from_entity(entity: Entity) -> Color {
    Oklcha::sequential_dispersed(entity.index_u32()).into()
}
```

### 5. `crates/bevy_light/src/lib.rs` (+9/-0)
Updates the light system ordering to ensure spot light frustums are updated before being drawn by the gizmo system.

Key change:
```rust
// When bevy_gizmos feature is enabled, run before FrustumGizmoSystems
#[cfg(feature = "bevy_gizmos")]
update_spot_light_frusta
    .in_set(SimulationLightSystems::UpdateLightFrusta)
    .before(FrustumGizmoSystems)
```

### 6. `examples/tools/scene_viewer/scene_viewer_plugin.rs`
Adds a toggle for frustum visualization in the scene viewer example (F key).

```rust
fn toggle_camera_frusta(mut config: ResMut<GizmoConfigStore>) {
    config.config_mut::<FrustumGizmoConfigGroup>().1.draw_all ^= true;
}
```

## Further Reading

1. **Frustum Culling**: The mathematical concept behind frustums and their use in graphics
2. **Half-space representation**: How planes are represented in 3D graphics and computational geometry
3. **Immediate Mode vs Retained Mode Rendering**: The design philosophy behind Bevy's gizmo system
4. **Bevy's ECS (Entity Component System)**: How components and systems work together in Bevy
5. **Linear Algebra for Game Development**: Specifically plane equations and solving linear systems