+++
title = "#22757 Add example for triggering and recovering from rendering errors"
date = "2026-02-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22757-en-20260203" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22757-zh-cn-20260203" }}
+++

# Add example for triggering and recovering from rendering errors

## 基本信息
- **标题**: Add example for triggering and recovering from rendering errors
- **PR链接**: https://github.com/bevyengine/bevy/pull/22757
- **作者**: atlv24
- **状态**: 已合并
- **标签**: A-Rendering, C-Examples, S-Ready-For-Final-Review, D-Modest
- **创建时间**: 2026-01-31T21:36:19Z
- **合并时间**: 2026-02-02T23:54:29Z
- **合并者**: alice-i-cecile

## 描述翻译

# 目标
- 用于渲染恢复的测试套件/演示

## 解决方案
- 添加一个能够触发各种渲染错误的示例

## 测试
- 运行它

注意：我单独提交这个PR，以便可以将bevy主分支的行为与即将到来的渲染恢复PR进行比较。它不一定需要先合并。

## 这个PR的技术故事

这个PR的核心目标很简单：创建一个用于测试和演示渲染错误恢复能力的示例应用。在现代图形API（如Vulkan、Metal、DirectX 12）和WebGPU中，渲染错误处理变得至关重要，因为这些API会暴露更多的底层细节，使得应用程序更容易遇到内存不足、验证错误或设备丢失等问题。

从技术角度看，这个示例有几个关键设计点：

首先，它建立了一个标准的三维场景（圆形基座、立方体、光源和旋转的摄像机），这为渲染提供了一个可见的基准状态。当渲染错误被触发时，开发者可以直观地看到渲染是否恢复正常。

```rust
// 创建基本3D场景
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    // 圆形基座
    commands.spawn((
        Mesh3d(meshes.add(Circle::new(4.0))),
        MeshMaterial3d(materials.add(Color::WHITE)),
        Transform::from_rotation(Quat::from_rotation_x(-std::f32::consts::FRAC_PI_2)),
    ));
    // 立方体
    commands.spawn((
        Mesh3d(meshes.add(Cuboid::new(2.0, 2.0, 2.0))),
        MeshMaterial3d(materials.add(Color::srgb_u8(124, 144, 255))),
        Transform::from_xyz(0.0, 1.0, 0.0),
    ));
    // 光源
    commands.spawn((
        PointLight {
            shadow_maps_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));
    // 摄像机
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y),
    ));
}
```

第二，这个示例实现了四种不同类型的渲染错误，每种都模拟了真实场景中可能遇到的问题：

1. **内存不足错误（OutOfMemory）**：通过循环创建64个8192×8192的RGBA16Float纹理来耗尽GPU内存。
2. **验证错误（Validation）**：尝试创建一个大小为2^63的缓冲区，这超出了有效范围。
3. **设备丢失错误（DeviceLost）**：主动销毁渲染设备，模拟硬件故障或驱动程序崩溃。
4. **无限循环错误（Loop）**：创建一个包含无限循环的计算着色器，导致GPU挂起。

这些错误是通过一个枚举类型`RenderError`和对应的输入系统来控制的：

```rust
#[derive(Resource, ExtractResource, Clone, Default)]
enum RenderError {
    #[default]
    None,
    OutOfMemory,
    Validation,
    DeviceLost,
    Loop,
}

fn input(input: Res<ButtonInput<Key>>, mut error: ResMut<RenderError>) {
    *error = RenderError::None;
    if input.just_pressed(Key::Character("o".into())) {
        *error = RenderError::OutOfMemory;
    }
    if input.just_pressed(Key::Character("v".into())) {
        *error = RenderError::Validation;
    }
    if input.just_pressed(Key::Character("d".into())) {
        *error = RenderError::DeviceLost;
    }
    if input.just_pressed(Key::Character("l".into())) {
        *error = RenderError::Loop;
    }
}
```

第三，错误触发逻辑运行在渲染子应用（RenderApp）中，这是Bevy的渲染系统架构的一部分。通过使用`ExtractResourcePlugin`，`RenderError`资源可以从主应用提取到渲染应用中：

```rust
fn main() {
    let mut app = App::new();
    app.add_plugins((
        DefaultPlugins,
        ExtractResourcePlugin::<RenderError>::default(),
    ))
    .add_systems(Startup, setup)
    .add_systems(Update, (update_camera, input))
    .init_resource::<RenderError>()
    .sub_app_mut(RenderApp)
    .add_systems(Render, cause_error);
    app.run();
}
```

这种架构设计确保了错误触发逻辑只在渲染线程中执行，这是必要的，因为渲染资源（如`RenderDevice`和`RenderQueue`）只能在渲染上下文中访问。

技术实现上，`cause_error`函数使用`If<Res<RenderError>>`条件系统来避免在没有错误时执行开销大的操作：

```rust
fn cause_error(error: If<Res<RenderError>>, device: Res<RenderDevice>, queue: Res<RenderQueue>) {
    match **error {
        RenderError::None => {}
        RenderError::OutOfMemory => {
            // 创建大量大纹理以耗尽内存
            let mut textures = Vec::new();
            for _ in 0..64 {
                textures.push(device.create_texture(&TextureDescriptor {
                    label: None,
                    size: Extent3d {
                        width: 8192,
                        height: 8192,
                        depth_or_array_layers: 1,
                    },
                    // ... 省略其他字段
                }));
            }
        }
        // ... 其他错误类型
    }
}
```

这个PR的一个重要背景是作者在描述中提到的：它是为了配合一个即将到来的"渲染恢复PR"而创建的。这意味着这个示例不仅仅是一个演示，而是一个测试工具，用于验证Bevy渲染系统在遇到各种错误时能否正确恢复。

从工程角度看，这个示例展示了几个有用的模式：
1. 如何在Bevy中安全地触发和管理渲染错误
2. 如何使用`ExtractResource`在应用和渲染应用之间传递状态
3. 如何编写条件系统以避免不必要的计算开销
4. 如何构建一个交互式示例，让开发者可以按需测试不同的错误场景

## 可视化表示

```mermaid
graph TD
    A[主应用 Main App] -->|ExtractResource| B[渲染应用 Render App]
    B --> C[渲染设备 RenderDevice]
    B --> D[渲染队列 RenderQueue]
    E[用户输入] -->|设置RenderError| A
    A -->|传递RenderError| B
    B -->|根据RenderError触发| F[特定渲染错误]
    
    F --> G[内存不足 OutOfMemory]
    F --> H[验证错误 Validation]
    F --> I[设备丢失 DeviceLost]
    F --> J[无限循环 Loop]
    
    G -->|大量纹理分配| C
    H -->|无效缓冲区创建| C
    I -->|destroy()调用| C
    J -->|无限循环着色器| D
```

## 关键文件变更

### `examples/app/render_recovery.rs` (+182/-0)
这是一个全新的示例文件，实现了渲染错误触发和恢复的演示应用。

**主要实现内容：**
1. 创建基本的3D场景用于视觉验证
2. 定义`RenderError`枚举作为可提取的资源
3. 实现输入系统来切换不同的错误类型
4. 在渲染系统中实现具体错误触发逻辑

```rust
// 关键代码片段：无限循环错误实现
RenderError::Loop => {
    let sm = device.create_and_validate_shader_module(ShaderModuleDescriptor {
        label: Some("shader"),
        source: ShaderSource::Wgsl(
            "@compute @workgroup_size(1, 1, 1) fn main() { loop { workgroupBarrier(); } }"
                .into(),
        ),
    });

    // 创建计算管线并调度
    let pipeline = device.create_compute_pipeline(&RawComputePipelineDescriptor {
        label: Some("pipeline"),
        // ... 省略其他参数
    });

    let mut encoder = device.create_command_encoder(&CommandEncoderDescriptor::default());
    {
        let mut cpass = encoder.begin_compute_pass(&ComputePassDescriptor::default());
        cpass.set_pipeline(&pipeline);
        cpass.dispatch_workgroups(1, 1, 1);
    }
    device.poll(PollType::wait_indefinitely()).unwrap();
    queue.submit([encoder.finish()]);
}
```

### `Cargo.toml` (+11/-0)
添加了新的示例配置到Bevy的示例列表中。

```toml
# 添加的配置
[[example]]
name = "render_recovery"
path = "examples/app/render_recovery.rs"
doc-scrape-examples = true

[package.metadata.example.render_recovery]
name = "Render Recovery"
description = "Demonstrates how bevy can recover from rendering failures."
category = "Application"
wasm = false
```

### `examples/README.md` (+1/-0)
在示例文档中添加了新示例的条目。

```markdown
# 添加的行
[Render Recovery](../examples/app/render_recovery.rs) | Demonstrates how bevy can recover from rendering failures.
```

## 进一步阅读

1. **WebGPU错误处理规范**: https://www.w3.org/TR/webgpu/#errors-and-debugging
2. **Bevy渲染架构文档**: https://bevyengine.org/learn/book/getting-started/architecture/
3. **Vulkan错误处理最佳实践**: https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Frame_buffers
4. **Bevy提取系统（Extract System）**: 了解`ExtractResourcePlugin`如何工作以及如何在主应用和渲染应用之间传递数据
5. **GPU驱动错误恢复机制**: 不同GPU厂商（NVIDIA、AMD、Intel）如何处理设备丢失和恢复