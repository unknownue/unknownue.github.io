+++
title = "#23096 Add configurable output_dir to EasyScreenRecordPlugin"
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23096-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23096-zh-cn-20260224" }}
labels = ["C-Usability", "M-Migration-Guide", "A-Dev-Tools", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Add configurable output_dir to EasyScreenRecordPlugin
- **PR Link**: https://github.com/bevyengine/bevy/pull/23096
- **Author**: hueypark
- **Status**: MERGED
- **Labels**: C-Usability, S-Ready-For-Final-Review, M-Migration-Guide, A-Dev-Tools, D-Straightforward
- **Created**: 2026-02-21T12:02:00Z
- **Merged**: 2026-02-24T17:43:57Z
- **Merged By**: alice-i-cecile

## Description Translation
**Objective**

- Allow users to specify a custom output directory for screen recordings in `EasyScreenRecordPlugin`.
- Currently, recordings are always saved to the current working directory with no way to configure the path.

**Solution**

- Add an `output_dir: Option<PathBuf>` field to `EasyScreenRecordPlugin`.
- When `None` (the default), recordings are saved in the current working directory, preserving existing behavior.
- When `Some(path)`, recordings are saved in the specified directory. The directory is created automatically if it does not exist.
- Update `RecordCommand::Start` to use `PathBuf` instead of `String`.

**Testing**

- Verified compilation with `cargo check -p bevy_dev_tools --features screenrecording`.

---

**Showcase**

```rust
// Default: records to current working directory
app.add_plugins(EasyScreenRecordPlugin::default());

// Custom output directory
app.add_plugins(EasyScreenRecordPlugin {
    output_dir: Some("recordings".into()),
    ..default()
});
```

## The Story of This Pull Request

The EasyScreenRecordPlugin in Bevy's development tools provides a convenient way to capture screen recordings during application development. However, it had a significant limitation: all recordings were always saved to the current working directory with no way for developers to configure where these files should go.

This created practical issues for developers working on projects where they wanted to organize recordings systematically. For example, when running multiple test sessions or different versions of an application, developers couldn't separate recordings by feature, test run, or version without manually moving files after recording. The lack of directory configuration also made it harder to integrate screen recording into automated testing pipelines where output organization is crucial.

The solution approached this problem by adding an optional `output_dir` field to the `EasyScreenRecordPlugin` struct. This approach maintains backward compatibility by making the field `Option<PathBuf>` with a default of `None`. When `None`, the plugin behaves exactly as before, saving files to the current working directory. When `Some(path)`, recordings are saved to the specified directory. The implementation also handles directory creation automatically using `std::fs::create_dir_all(parent).unwrap()`, ensuring the target directory exists before attempting to write files.

A key design decision was changing the internal `RecordCommand::Start` variant from using `String` to `std::path::PathBuf`. This change improves type safety and better represents the actual data being passed (a filesystem path rather than just any string). The migration from `String` to `PathBuf` happens transparently within the plugin's internal messaging system.

The implementation follows Rust's path handling best practices. When constructing the final path for a recording, the code uses `dir.join(&filename)` when an output directory is specified, or `std::path::PathBuf::from(&filename)` when using the default behavior. This ensures proper path concatenation regardless of the operating system's path separator conventions.

One important consideration in the implementation is the use of `.unwrap()` when creating directories and files. This is acceptable in this context because `EasyScreenRecordPlugin` is a development tool, not production code. Failed recording saves are inconvenient but shouldn't crash the entire application in development scenarios. However, the code logs errors appropriately with `info!("starting recording at {}", path.display())`.

The changes affect both the plugin's configuration and its runtime behavior. Configuration changes include adding the new field with documentation explaining its purpose. Runtime changes include:
1. Checking if the output directory exists and creating it if necessary
2. Constructing the full output path based on the configuration
3. Passing the complete path through the internal command system

This implementation demonstrates a clean extension pattern: adding optional configuration that defaults to existing behavior, using appropriate types (`PathBuf` over `String` for paths), and handling edge cases (directory creation). The approach minimizes disruption while providing useful new functionality.

## Visual Representation

```mermaid
graph TD
    A[EasyScreenRecordPlugin Configuration] --> B{output_dir: Option<PathBuf>}
    B -->|None| C[Save to current working directory]
    B -->|Some(path)| D[Create directory if needed]
    D --> E[Construct full path: dir.join(filename)]
    C --> F[Internal RecordCommand System]
    E --> F
    F --> G[Write video file to final path]
```

## Key Files Changed

### `crates/bevy_dev_tools/src/easy_screenshot.rs` (+20/-5)

This is the main implementation file for the EasyScreenRecordPlugin. The changes add the new configuration option and update the internal recording logic to use it.

**Key modifications:**

1. Added the `output_dir` field to the `EasyScreenRecordPlugin` struct with comprehensive documentation:

```rust
// Before:
pub struct EasyScreenRecordPlugin {
    pub toggle: KeyCode,
    pub preset: Preset,
    pub tune: Tune,
    pub frame_time: Duration,
}

// After:
pub struct EasyScreenRecordPlugin {
    pub toggle: KeyCode,
    pub preset: Preset,
    pub tune: Tune,
    pub frame_time: Duration,
    /// Output directory for recorded video files.
    ///
    /// When `None`, recordings are saved in the current working directory.
    /// When `Some(path)`, recordings are saved in the specified directory.
    /// The directory will be created if it does not exist.
    pub output_dir: Option<std::path::PathBuf>,
}
```

2. Updated the `Default` implementation to initialize `output_dir` as `None`:

```rust
// Before:
impl Default for EasyScreenRecordPlugin {
    fn default() -> Self {
        Self {
            toggle: KeyCode::Space,
            preset: Preset::Medium,
            tune: Tune::Animation,
            frame_time: Duration::from_millis(33),
        }
    }
}

// After:
impl Default for EasyScreenRecordPlugin {
    fn default() -> Self {
        Self {
            toggle: KeyCode::Space,
            preset: Preset::Medium,
            tune: Tune::Animation,
            frame_time: Duration::from_millis(33),
            output_dir: None,
        }
    }
}
```

3. Changed the internal `RecordCommand::Start` variant to use `PathBuf` instead of `String`:

```rust
// Before:
enum RecordCommand {
    Start(String, Preset, Tune),
    Stop,
    Frame(Image),
}

// After:
enum RecordCommand {
    Start(std::path::PathBuf, Preset, Tune),
    Stop,
    Frame(Image),
}
```

4. Added directory creation logic and path construction in the recording thread:

```rust
// Before:
match next {
    RecordCommand::Start(name, preset, tune) => {
        info!("starting recording at {}", name);
        file = Some(File::create(name).unwrap());
        setup = Some(Setup::preset(preset, tune, false, true).high());
    }
    // ...
}

// After:
match next {
    RecordCommand::Start(path, preset, tune) => {
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent).unwrap();
        }
        info!("starting recording at {}", path.display());
        file = Some(File::create(path).unwrap());
        setup = Some(Setup::preset(preset, tune, false, true).high());
    }
    // ...
}
```

5. Added path construction logic in the system that handles recording commands:

```rust
// New code added:
let path = match &output_dir {
    Some(dir) => dir.join(&filename),
    None => std::path::PathBuf::from(&filename),
};
tx.send(RecordCommand::Start(path, preset, tune)).unwrap();
```

### `release-content/migration-guides/EasyScreenRecordPlugin_output_dir.md` (+27/-0)

This is a new migration guide created to help users update their code when upgrading to the new version of Bevy.

**Content:**

The migration guide shows users how to update their code when manually constructing an `EasyScreenRecordPlugin`. It provides clear before/after examples:

```rust
// 0.18 (before the change)
let plugin = EasyScreenRecordPlugin {
    toggle: KeyCode::Space,
    preset: Preset::Medium,
    tune: Tune::Animation,
    frame_time: Duration::from_millis(33),
};

// 0.19 (after the change)
let plugin = EasyScreenRecordPlugin {
    toggle: KeyCode::Space,
    preset: Preset::Medium,
    tune: Tune::Animation,
    frame_time: Duration::from_millis(33),
    output_dir: Some("recordings".into()),
};
```

The guide emphasizes that users who use `..default()` don't need to make any changes, which is an important point for maintaining backward compatibility.

## Further Reading

1. **Rust Path Handling**: The Rust documentation on `std::path` provides comprehensive information on cross-platform path handling: https://doc.rust-lang.org/std/path/index.html

2. **Bevy Plugin System**: Understanding how Bevy plugins work helps in extending existing functionality: https://bevyengine.org/learn/book/getting-started/plugins/

3. **Configuration Patterns in Rust**: The Rust Design Patterns repository includes examples of builder patterns and configuration options: https://github.com/rust-unofficial/patterns

4. **File System Operations in Rust**: The `std::fs` module documentation covers file and directory operations: https://doc.rust-lang.org/std/fs/index.html

5. **Bevy Development Tools**: The Bevy dev tools module contains other useful development utilities: https://github.com/bevyengine/bevy/tree/main/crates/bevy_dev_tools