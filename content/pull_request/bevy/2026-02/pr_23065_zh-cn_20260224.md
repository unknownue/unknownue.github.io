+++
title = "#23065 Fix unsound access of component metadata (change ticks) in `bevy_ecs::storage::Table`"
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23065-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23065-zh-cn-20260224" }}
labels = ["C-Bug", "A-ECS", "P-Unsound", "D-Straightforward", "D-Unsafe"]
+++

# Title

## Basic Information
- **Title**: Fix unsound access of component metadata (change ticks) in `bevy_ecs::storage::Table`
- **PR Link**: https://github.com/bevyengine/bevy/pull/23065
- **Author**: nils-mathieu
- **Status**: MERGED
- **Labels**: C-Bug, A-ECS, S-Ready-For-Final-Review, P-Unsound, D-Straightforward, D-Unsafe
- **Created**: 2026-02-20T04:29:43Z
- **Merged**: 2026-02-24T01:50:21Z
- **Merged By**: alice-i-cecile

## Description Translation

# 目标

这个拉取请求简单地修改了 `bevy_ecs/src/storage/table/mod.rs` 中的三个函数，这些函数当前可能错误地访问了越界的元素。

目前这些函数使用以下模式来防止无效的 `TableRow`：

```Rust
/// Get the specific [`change tick`](Tick) of the component matching `component_id` in `row`.
pub fn get_changed_tick(
  &self,
  component_id: ComponentId,
  row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
  (row.index_u32() < self.entity_count()).then_some(
    // SAFETY: `row.as_usize()` < `len`
    unsafe {
      self.get_column(component_id)?
        .changed_ticks
        .get_unchecked(row.index())
    },
  )
}
```

这里使用 `then_some` 是无效的，因为它按值获取输入，即使 `row.index_u32() < self.entity_count()` 为 `false`，也会立即计算 `get_unchecked` 调用。

使用无效的索引调用 `get_unchecked` 会立即触发未定义行为，即使该值未被使用。

## 解决方案

我们不能使用 `then` 来代替 `then_some`，因为 `self.get_column` 可能返回 `None` 而失败，所以我选择使用常规的 `if` 守卫，如下所示：

```Rust
/// Get the specific [`change tick`](Tick) of the component matching `component_id` in `row`.
pub fn get_changed_tick(
  &self,
  component_id: ComponentId,
  row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
  if row.index_u32() >= self.entity_count() {
    return None;
  }

  // SAFETY: `row.as_usize()` < `len`
  self.get_column(component_id)
    .map(|col| unsafe { col.changed_ticks.get_unchecked(row.index()) })
}
```

## 测试

我尝试在 CI 上运行整个测试，但我的 clippy 版本（nightly）被代码的其他部分触发，而且我懒得安装 Rust 稳定版并重新编译所有内容。如果 CI 失败，我会在这里修复任何问题，并在本地重新检查。

## 其他说明

我不熟悉代码库（嗯，我读了一点并四处看了看，但我不是什么都懂），所以代码中可能还有其他地方有相同的问题。我 grep 了 `then_some`，没有发现其他相同问题的实例，所以至少它没有以这种形式出现在其他地方。

## The Story of This Pull Request

这个 PR 修复了 Bevy ECS 中一个潜在的未定义行为问题，涉及 `Table` 存储中组件元数据的访问。问题出现在三个获取组件变更标记（change ticks）的函数中，它们使用了不安全的模式进行边界检查。

问题的核心是 `Option::then_some` 方法的求值顺序。在原来的实现中，开发者试图通过 `(row.index_u32() < self.entity_count()).then_some(...)` 来确保只有在索引有效时才执行不安全的 `get_unchecked` 调用。但 `then_some` 的设计导致了一个关键问题：它的参数会在条件判断之前就被求值。这意味着即使索引越界，`get_unchecked(row.index())` 仍然会被执行，这直接违反了 unsafe 代码的安全保证。

从技术角度看，`then_some` 的签名是 `fn then_some<T>(self, val: T) -> Option<T>`，它接受一个按值传递的 `val` 参数。在 Rust 中，按值传递意味着参数会在函数调用时被求值。所以在这个例子中，无论条件是否为真，`unsafe { ... }` 块都会被执行，`get_unchecked` 都会被调用。

修复方案采用了更直观的防御性编程模式：使用显式的 `if` 语句进行早期返回。这种模式有两个关键优势：首先，它确保了只有在索引有效时才会进入 unsafe 代码块；其次，代码的意图更加清晰，便于后续维护。

具体实现中，开发者将三个函数统一改为以下模式：
1. 首先检查 `row.index_u32() >= self.entity_count()`，如果为真则立即返回 `None`
2. 然后安全地调用 `self.get_column(component_id)` 获取列引用
3. 最后使用 `map` 和 `get_unchecked` 组合来访问具体的标记数据

修改后的代码在安全保证方面有明显改善。原来的 unsafe 块注释提到 `row.as_usize() < len`，但实际上这个保证可能不成立，因为边界检查被 `then_some` 的求值顺序破坏了。修复后的代码通过显式检查建立了这个保证，使得 unsafe 块的使用变得合理。

从代码风格角度看，这个修复展示了在处理 unsafe 代码时的最佳实践：尽可能将安全检查放在 unsafe 块外部，减少 unsafe 块的范围和复杂度。虽然 `if` 语句比单行的 `then_some` 稍微冗长，但它在安全性和可读性方面的提升是值得的。

这个修复的影响范围相对有限，只涉及三个获取组件元数据的函数。但由于这些函数可能被频繁调用，修复潜在的内存安全问题对于系统的稳定性很重要。标签中的 `P-Unsound` 和 `D-Unsafe` 准确反映了问题的性质：这是一个可能导致未定义行为的不安全代码使用问题。

## Visual Representation

```mermaid
graph TD
    A[调用 get_changed_tick 等函数] --> B{检查 row.index_u32() < self.entity_count()?}
    B -->|否| C[立即返回 None]
    B -->|是| D[调用 self.get_column(component_id)]
    D -->|返回 None| E[返回 None]
    D -->|返回 Some(col)| F[使用 get_unchecked 访问特定索引]
    F --> G[返回 &UnsafeCell<Tick>]
    
    H[原方案: then_some] --> I[无条件执行 get_unchecked]
    I --> J[即使索引无效也执行<br/>导致未定义行为]
    
    K[修复方案: if 守卫] --> L[有效时执行 get_unchecked]
    L --> M[索引有效保证安全]
```

## Key Files Changed

### `crates/bevy_ecs/src/storage/table/mod.rs` (+24/-25)

这个文件包含了 Bevy ECS 中 Table 存储的核心实现。Table 是 ECS 架构中的一种密集存储方式，用于存储具有相同组件组合的实体。修改的三个函数负责获取组件的变更标记（change ticks），这些标记用于跟踪组件何时被添加或修改。

**关键修改：**

1. **get_changed_tick 函数** - 获取组件的变更标记

```rust
// 修改前：
pub fn get_changed_tick(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
    (row.index_u32() < self.entity_count()).then_some(
        // SAFETY: `row.as_usize()` < `len`
        unsafe {
            self.get_column(component_id)?
                .changed_ticks
                .get_unchecked(row.index())
        },
    )
}

// 修改后：
pub fn get_changed_tick(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
    if row.index_u32() >= self.entity_count() {
        return None;
    }

    // SAFETY: `row.index()` < `len`
    self.get_column(component_id)
        .map(|col| unsafe { col.changed_ticks.get_unchecked(row.index()) })
}
```

2. **get_added_tick 函数** - 获取组件的添加标记

```rust
// 修改前：
pub fn get_added_tick(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
    (row.index_u32() < self.entity_count()).then_some(
        // SAFETY: `row.as_usize()` < `len`
        unsafe {
            self.get_column(component_id)?
                .added_ticks
                .get_unchecked(row.index())
        },
    )
}

// 修改后：
pub fn get_added_tick(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
    if row.index_u32() >= self.entity_count() {
        return None;
    }

    // SAFETY: `row.index()` < `len`
    self.get_column(component_id)
        .map(|col| unsafe { col.added_ticks.get_unchecked(row.index()) })
}
```

3. **get_changed_by_location 函数** - 获取变更的位置信息

```rust
// 修改前：
pub fn get_changed_by_location(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> MaybeLocation<Option<&UnsafeCell<&'static Location<'static>>>> {
    MaybeLocation::new_with_flattened(|| {
        (row.index_u32() < self.entity_count()).then_some(
            // SAFETY: `row.as_usize()` < `len`
            unsafe {
                self.get_column(component_id)?
                    .changed_by
                    .as_ref()
                    .map(|changed_by| changed_by.get_unchecked(row.index()))
            },
        )
    })
}

// 修改后：
pub fn get_changed_by_location(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> MaybeLocation<Option<&UnsafeCell<&'static Location<'static>>>> {
    MaybeLocation::new_with_flattened(|| {
        if row.index_u32() >= self.entity_count() {
            return None;
        }

        self.get_column(component_id).map(|col| {
            // SAFETY: `row.index()` < `len`
            col.changed_by
                .as_ref()
                .map(|changed_by| unsafe { changed_by.get_unchecked(row.index()) })
        })
    })
}
```

**这些修改与 PR 目标的关系：**
所有三个修改都遵循相同的模式：将可能不安全的 `then_some` 调用替换为显式的边界检查加安全访问。这确保了只有在索引有效时才会执行 `get_unchecked`，从而消除了未定义行为的可能性。

## Further Reading

1. **Rust 官方文档：未定义行为**
   - https://doc.rust-lang.org/reference/behavior-considered-undefined.html
   - 理解什么构成未定义行为对于编写安全的 unsafe 代码至关重要。

2. **Rust 标准库：Option::then_some 方法**
   - https://doc.rust-lang.org/std/option/enum.Option.html#method.then_some
   - 了解 `then_some` 的求值语义，特别是它按值接受参数的特点。

3. **Rustonomicon：编写不安全代码的指南**
   - https://doc.rust-lang.org/nomicon/
   - 特别是关于边界检查和指针操作的部分。

4. **Bevy ECS 架构文档**
   - https://bevyengine.org/learn/book/features/ecs/
   - 理解 Table 存储和组件变更标记在 Bevy ECS 中的作用。

5. **Rust 编译器内部：立即求值与惰性求值**
   - 了解不同求值策略对安全性的影响，特别是在 unsafe 上下文中的影响。