diff --git a/Cargo.toml b/Cargo.toml
index 5a1a4861858f2..a57eef25f7054 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -2043,6 +2043,17 @@ category = "Assets"
 # Uses non-standard asset path
 wasm = false
 
+[[example]]
+name = "generated_assets"
+path = "examples/asset/generated_assets.rs"
+doc-scrape-examples = true
+
+[package.metadata.example.generated_assets]
+name = "Generated Assets"
+description = "Shows how to generate and store assets at runtime"
+category = "Assets"
+wasm = true
+
 [[example]]
 name = "web_asset"
 path = "examples/asset/web_asset.rs"
diff --git a/examples/README.md b/examples/README.md
index a99b13cb16117..56d05ad94bdf9 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -263,6 +263,7 @@ Example | Description
 [Custom Asset IO](../examples/asset/custom_asset_reader.rs) | Implements a custom AssetReader
 [Embedded Asset](../examples/asset/embedded_asset.rs) | Embed an asset in the application binary and load it
 [Extra Asset Source](../examples/asset/extra_source.rs) | Load an asset from a non-standard asset source
+[Generated Assets](../examples/asset/generated_assets.rs) | Shows how to generate and store assets at runtime
 [Hot Reloading of Assets](../examples/asset/hot_asset_reloading.rs) | Demonstrates automatic reloading of assets when modified on disk
 [Multi-asset synchronization](../examples/asset/multi_asset_sync.rs) | Demonstrates how to wait for multiple assets to be loaded.
 [Repeated texture configuration](../examples/asset/repeated_texture.rs) | How to configure the texture to repeat instead of the default clamp to edges
diff --git a/examples/asset/generated_assets.rs b/examples/asset/generated_assets.rs
new file mode 100644
index 0000000000000..22f4f0eb7a987
--- /dev/null
+++ b/examples/asset/generated_assets.rs
@@ -0,0 +1,71 @@
+//! Shows how to generate and store assets at runtime.
+
+use bevy::prelude::*;
+
+fn main() {
+    App::new()
+        .add_plugins(DefaultPlugins)
+        .add_systems(Startup, setup)
+        .add_systems(Update, generate_mesh_system.run_if(run_once))
+        .run();
+}
+
+fn setup(
+    mut commands: Commands,
+    asset_server: Res<AssetServer>,
+    mut materials: ResMut<Assets<StandardMaterial>>,
+    meshes: Res<Assets<Mesh>>,
+) {
+    commands.spawn((Camera3d::default(), Transform::from_xyz(0.0, 0.0, 5.0)));
+
+    commands.spawn((
+        DirectionalLight::default(),
+        Transform::default().looking_to(Dir3::new(Vec3::new(-1.0, -1.0, -1.0)).unwrap(), Dir3::Y),
+    ));
+
+    // The simplest way to generate an asset is to add it directly to the `Assets`.
+    let material_handle = materials.add(StandardMaterial::default());
+
+    commands.spawn((
+        Transform::from_xyz(-2.0, 0.0, 0.0),
+        MeshMaterial3d(material_handle.clone()),
+        // Alternatively, `add_async` creates a task that runs your async function. Once it
+        // completes, the asset is added to the `Assets`. This is "deferred" meaning that the asset
+        // may take a frame to be added after the task completes.
+        Mesh3d(asset_server.add_async(generate_mesh_async())),
+    ));
+
+    // The last way to generate assets is to reserve a handle, and then use `Assets::insert` to
+    // populate the asset later. In this example, the `generate_mesh_system` system runs to populate
+    // the mesh.
+    let mesh_handle = meshes.reserve_handle();
+    commands.insert_resource(HandleToGenerate(mesh_handle.clone()));
+    commands.spawn((
+        Transform::from_xyz(2.0, 0.0, 0.0)
+            .with_rotation(Quat::from_rotation_x(50.0f32.to_radians())),
+        Mesh3d(mesh_handle),
+        MeshMaterial3d(material_handle),
+    ));
+}
+
+async fn generate_mesh_async() -> Result<Mesh, std::io::Error> {
+    // This mesh could take a while to generate. It could even take several frames (though in this
+    // example it should be ~instant).
+
+    Ok(Mesh::from(Cone::new(1.0, 2.0)))
+}
+
+#[derive(Resource)]
+struct HandleToGenerate(Handle<Mesh>);
+
+/// This system runs once to populate the handle in [`HandleToGenerate`].
+///
+/// This generates a runtime mesh. Since it's a system, it can use other data in the world to
+/// generate the asset!
+fn generate_mesh_system(
+    handle_to_generate: Res<HandleToGenerate>,
+    mut meshes: ResMut<Assets<Mesh>>,
+) {
+    let mesh = Mesh::from(Torus::new(0.8, 1.2));
+    meshes.insert(&handle_to_generate.0, mesh).unwrap();
+}
