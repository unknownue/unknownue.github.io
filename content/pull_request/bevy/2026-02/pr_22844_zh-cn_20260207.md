+++
title = "#22844 remove Debug from material strings and add LoadContext to GltfExtensi…"
date = "2026-02-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22844-en-20260207" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22844-zh-cn-20260207" }}
labels = ["A-Rendering", "C-Examples", "A-glTF"]
+++

# Title
remove Debug from material strings and add LoadContext to GltfExtensi…

## Basic Information
- **Title**: remove Debug from material strings and add LoadContext to GltfExtensi…
- **PR Link**: https://github.com/bevyengine/bevy/pull/22844
- **Author**: ChristopherBiscardi
- **Status**: MERGED
- **Labels**: A-Rendering, C-Examples, S-Ready-For-Final-Review, A-glTF
- **Created**: 2026-02-07T03:19:01Z
- **Merged**: 2026-02-07T05:51:47Z
- **Merged By**: alice-i-cecile

## Description Translation
（PR 描述的中文翻译，保留所有技术术语、图片链接和代码格式）

**目标**
PR #22569 引入了一些回归问题。其中至少部分问题是由资产名称中的 debug 格式化引起的。

这导致了像 `"DefaultMaterial"#std` 这样的资产名称。

**解决方案**
移除 debug 格式化。

此外，启用从 `GltfMaterial::default()` 构建的 `StandardMaterial` 等资源的初始化，以便资产加载器能够访问它们。像这种不存在的默认材质将不会调用 `on_material` 钩子，因此也不会被初始化以供后续引用。

**测试**
multi_asset_sync 和 hot_reloading 通过此修复得到了解决。

<img width="3776" height="2096" alt="screenshot-2026-02-06-at-19 11 31@2x" src="https://github.com/user-attachments/assets/07a31bf9-4013-4e80-a285-9b078eb28875" />
<img width="3776" height="2096" alt="screenshot-2026-02-06-at-19 16 42@2x" src="https://github.com/user-attachments/assets/5f1c1848-9469-4108-9600-5115d71d7e4c" />

但各向异性看起来仍然不正确，因此这只是修复了一个问题，似乎还有更多工作要做。

<img width="3776" height="2096" alt="screenshot-2026-02-06-at-19 17 20@2x" src="https://github.com/user-attachments/assets/70bd1fe2-39e4-439d-a88e-e34b39aa06a8" />

## The Story of This Pull Request

这个 PR 源于一个在资产加载和热重载过程中发现的、由看似微小的格式问题导致的回归。PR #22569 引入了一些更改，无意中破坏了 `multi_asset_sync` 和 `hot_reloading` 示例的功能。经过调查，问题被追踪到资产名称的生成方式上。

问题的根本原因在于 `bevy_pbr` 模块中，glTF 材质扩展处理器（`GltfExtensionHandlerPbr`）在创建 `StandardMaterial` 资产时，使用了 `Debug` trait 的格式化（即 `format!("{:?}#std", material_label)`）来生成资产标签（label）。这导致当 `material_label` 是一个字符串字面量（如 `"DefaultMaterial"`）时，生成的资产名称会包含引号，变成 `"DefaultMaterial"#std`。而在资产加载和引用系统中，这些引号成为资产标签的一部分，使得后续通过 `format!("{}#std", material_label)`（不带 `Debug` 格式化）构建的标签无法匹配到之前注册的资产，从而导致资产句柄查找失败，表现为材质丢失或热重载不生效。

因此，解决方案的第一个部分非常直接：将 `format!("{:?}#std", material_label)` 全部替换为 `format!("{}#std", material_label)`，即使用 `Display` 格式化而非 `Debug` 格式化。这样，字符串 `"DefaultMaterial"` 生成的标签就是 `DefaultMaterial#std`，确保了标签创建和后续查找的一致性。

然而，修复格式化问题只是解决了资产名称不匹配的问题。PR 描述中还提到了一个更深层次的问题：对于那些没有明确指定材质、应该使用 glTF 默认材质的网格（meshes），其对应的 `StandardMaterial` 可能根本不会被创建。这是因为 `GltfExtensionHandlerPbr` 的 `on_material` 钩子只有在 glTF 文件中实际定义了材质时才会被调用。如果一个网格没有材质，它应该使用默认材质，但默认材质作为一个逻辑概念，并没有一个对应的 `GltfMaterial` 数据块来触发 `on_material` 调用。

为了解决这个问题，需要提前创建并注册这个默认材质资产。这就是解决方案的第二个部分：利用 `GltfExtensionHandler` trait 新增的 `on_root` 生命周期钩子。`on_root` 在 glTF 根数据被加载后、具体处理网格和材质之前被调用，它为扩展处理器提供了一个在资产加载上下文（`LoadContext`）中提前创建资产的机会。

在这个 PR 中，`GltfExtensionHandlerPbr` 实现了 `on_root` 方法。它使用一个预定义的标签 `GltfAssetLabel::DefaultMaterial`（其值为 `"DefaultMaterial"`）拼接上 `#std` 后缀，构造出默认材质的标签（`"DefaultMaterial#std"`）。然后，它调用 `load_context.add_labeled_asset`，将一个由 `GltfMaterial::default()` 创建的 `StandardMaterial` 注册到该标签下。这样，无论后续的网格是否指定了材质，只要它需要引用默认材质，都可以通过这个预注册的标签获取到正确的资产句柄。

值得注意的是，为了支持这个新的 `on_root` 钩子，`GltfExtensionHandler` trait 的定义和其在整个 glTF 加载流程中的调用点也必须进行修改。这正是另外两个被修改文件的作用：它们将 `LoadContext` 参数添加到了 `on_root` 方法的签名中，并确保在加载器（`GltfLoader`）中调用时传递了这个上下文。

这次修改展示了资产加载系统中一个重要的模式：对于某些逻辑上存在但数据中可能不直接存在的“默认”或“后备”资源，需要在加载流程的合适时机（如 `on_root`）主动进行创建和注册，以确保整个引用链的完整性。

尽管这个 PR 修复了资产名称格式化和默认材质初始化的问题，使 `multi_asset_sync` 和 `hot_reloading` 示例恢复了正常（如提交的截图所示），但作者指出各向异性（anisotropy）渲染仍然存在问题。这表明 #22569 引入的回归可能涉及多个方面，需要后续的 PR 来完全解决。

## Visual Representation

以下 Mermaid 图展示了此 PR 修改后，glTF 加载流程中相关组件与资产创建的关键关系：

```mermaid
graph TD
    subgraph "Gltf Loading Process"
        A[GltfLoader.load] --> B[调用所有扩展的 on_root]
        B --> C[GltfExtensionHandlerPbr.on_root]
        C --> D[创建并注册 DefaultMaterial 资产]
        A --> E[处理具体 Mesh 和 Material]
        E --> F[调用 on_material (如果材质存在)]
        F --> G[GltfExtensionHandlerPbr.on_material]
        G --> H[创建并注册对应 StandardMaterial 资产]
        E --> I[调用 on_spawn_mesh_and_material]
        I --> J[GltfExtensionHandlerPbr.on_spawn_mesh_and_material]
        J --> K[为 Entity 插入 MeshMaterial3d 组件]
        K --> L[使用 LoadContext.get_label_handle 获取材质句柄]
    end
    subgraph "Asset Registry (LoadContext)"
        M[Registered Assets]
        D --> M
        H --> M
        L -.-> M
    end
```
该图描绘了修改后 glTF 加载器（`GltfLoader`）如何协调各个扩展处理器（`GltfExtensionHandler`）。关键新增路径是 `on_root` 阶段提前注册默认材质，确保了后续步骤（尤其是 `on_spawn_mesh_and_material`）能够通过一致的标签（无 `Debug` 格式化）查找到所需的材质资产句柄。

## Key Files Changed

### 1. `crates/bevy_pbr/src/lib.rs` (+20/-6)
这是本次修复的核心文件，修改了 `GltfExtensionHandlerPbr` 的实现。

**主要修改与原因:**
1.  **移除 Debug 格式化**：在 `on_material` 和 `on_spawn_mesh_and_material` 方法中，将生成材质标签的代码从 `format!("{:?}#std", material_label)` 改为 `format!("{}#std", material_label)`。这解决了资产名称因包含引号而导致的不匹配问题。
2.  **简化资产注册**：在 `on_material` 方法中，将原本使用 `labeled_asset_scope` 的复杂注册方式，改为直接使用 `load_context.add_labeled_asset`。这使代码更清晰，并与 `on_root` 中的做法保持一致。
3.  **实现 `on_root` 钩子**：新增 `on_root` 方法实现，用于在 glTF 根数据加载后，主动创建并注册默认的 `StandardMaterial` 资产（标签为 `"DefaultMaterial#std"`）。这确保了没有明确材质的网格也能引用到有效的默认材质。

**关键代码片段:**
```rust
// After: on_root 方法新增
fn on_root(&mut self, load_context: &mut LoadContext<'_>, _gltf: &gltf::Gltf) {
    // 为 glTF 的 `DefaultMaterial` 创建 `StandardMaterial`，
    // 以便当网格没有材质时可以访问它。
    let std_label = format!("{}#std", GltfAssetLabel::DefaultMaterial);

    load_context.add_labeled_asset(
        std_label,
        standard_material_from_gltf_material(&GltfMaterial::default()),
    );
}

// After: on_material 方法修改 (对比之前)
fn on_material(&mut self, ...) {
    // 修改点1: 移除 Debug 格式化 (`{:?}` -> `{}`)
    let std_label = format!("{}#std", material_label);

    // 修改点2: 使用更直接的 add_labeled_asset 替代 labeled_asset_scope
    load_context.add_labeled_asset(
        std_label,
        standard_material_from_gltf_material(material_asset),
    );
}

// After: on_spawn_mesh_and_material 方法修改
fn on_spawn_mesh_and_material(&mut self, ...) {
    // 修改点: 移除 Debug 格式化 (`{:?}` -> `{}`)
    let std_label = format!("{}#std", material_label);
    let handle = load_context.get_label_handle::<StandardMaterial>(std_label);
    // ...
}
```

### 2. `crates/bevy_gltf/src/loader/extensions/mod.rs` (+1/-1)
这个文件修改了 `GltfExtensionHandler` trait 的定义。

**主要修改与原因:**
为了支持在 `on_root` 阶段创建资产，需要将 `LoadContext` 参数添加到 `on_root` 方法的签名中。这使得具体的扩展处理器（如 `GltfExtensionHandlerPbr`）在实现 `on_root` 时能够访问资产加载上下文。

**关键代码片段:**
```rust
// Before:
fn on_root(&mut self, gltf: &gltf::Gltf) {}

// After:
fn on_root(&mut self, load_context: &mut LoadContext<'_>, gltf: &gltf::Gltf) {}
```

### 3. `crates/bevy_gltf/src/loader/mod.rs` (+1/-1)
这个文件修改了 glTF 加载器（`GltfLoader`）中调用扩展处理器的代码。

**主要修改与原因:**
为了匹配 trait 定义的更改，需要在调用每个扩展的 `on_root` 方法时，传入 `load_context` 参数。

**关键代码片段:**
```rust
// Before:
for extension in extensions.iter_mut() {
    extension.on_root(&gltf);
}

// After:
for extension in extensions.iter_mut() {
    extension.on_root(load_context, &gltf);
}
```

## Further Reading
1.  **Related PR**: #22569 - 这个 PR 引入了最初的回归，理解它有助于了解问题的完整背景。
2.  **Bevy Asset System**: 关于 Bevy 资产系统、`LoadContext` 和标签化资产（labeled assets）的官方文档或示例，可以帮助深入理解本 PR 涉及的资产加载机制。
3.  **glTF Extension System**: Bevy 中 glTF 扩展处理器的设计文档或相关代码，有助于理解 `GltfExtensionHandler` trait 的生命周期钩子（如 `on_root`, `on_material`）是如何被集成到整个 glTF 加载流程中的。