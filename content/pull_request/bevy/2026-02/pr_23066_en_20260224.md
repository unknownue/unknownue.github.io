+++
title = "#23066 Makes Free Camera speed change exponential wrt scroll"
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23066-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23066-zh-cn-20260224" }}
labels = ["C-Usability", "A-Math", "D-Straightforward", "A-Camera"]
+++

# Title
Makes Free Camera speed change exponential wrt scroll

## Basic Information
- **Title**: Makes Free Camera speed change exponential wrt scroll
- **PR Link**: https://github.com/bevyengine/bevy/pull/23066
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: C-Usability, S-Ready-For-Final-Review, A-Math, D-Straightforward, A-Camera
- **Created**: 2026-02-20T06:12:13Z
- **Merged**: 2026-02-24T01:50:21Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- Adopts and closes #21453 and goes the side of using `exp`
- Supersedes and closes #21483 
- Make free_camera more usable at very large or very small scales

## Solution

- Basically updated  #21453 to use `exp` instead of `powf` with a percent change. This means that `scroll_factor` no longer means "the additional percentage added to/subtracted from speed."
- I made sure to add some helpful comments in `scroll_factor` for determining an appropriate value for `scroll_factor` and what a reasonable default is. Hopefully it's not too wordy

## Testing

I tested with `cargo run --example free_camera_controller --features="free_camera"` and `cargo run --example 3d_gizmos --features="free_camera"` and made sure the controls feel good. Compared to `main`, it doesn't take too long to go really fast and decreasing slower than the initial speed is more gradual.

## The Story of This Pull Request

The problem with the free camera controller in Bevy was that adjusting movement speed with the mouse scroll wheel used a linear scaling approach, which became problematic when navigating scenes at very large or very small scales. When dealing with large virtual worlds, developers needed to scroll excessively to reach usable speeds, while fine-grained speed adjustments were difficult at smaller scales.

Two previous PRs (#21453 and #21483) had attempted to solve this problem by implementing exponential scaling. This PR adopts the approach from #21453 but improves it by using the exponential function (`exp`) instead of power functions (`powf`), which is mathematically cleaner and more efficient. The key insight is that exponential scaling ensures that each unit of scroll has the same relative effect on speed, regardless of whether the hardware reports scroll events as one large event or multiple smaller ones.

The implementation changes how the `scroll_factor` parameter works. Previously, it represented a linear percentage change applied to the speed multiplier. With the new exponential approach, `scroll_factor` becomes the exponent in `e^(scroll_factor * scroll_delta)`, where each unit of scroll multiplies the current speed by `e^(scroll_factor)` for positive scrolls and divides it by `e^(scroll_factor)` (or multiplies by `e^(-scroll_factor)`) for negative scrolls.

The default `scroll_factor` value was changed from 0.5 to approximately ln(1.05) ≈ 0.04879016, which means each positive scroll unit increases speed by 5%, and each negative scroll unit decreases it by about 4.76%. This provides smooth, intuitive control where users can quickly reach high speeds with reasonable scrolling but still have fine-grained control at lower speeds.

The implementation also updates the minimum clamp value for the speed multiplier from 0.0 to `f32::EPSILON`. This is necessary because with exponential scaling, the speed multiplier should never reach zero (since `exp(x) > 0` for all real x). Using `f32::EPSILON` prevents division by zero issues while maintaining mathematical correctness.

From an engineering perspective, this change improves the user experience significantly while keeping the API simple. The updated documentation provides clear guidance for developers on choosing appropriate `scroll_factor` values, explaining the mathematical relationship and suggesting reasonable ranges. The implementation is computationally efficient, using the `exp` function from Bevy's math utilities.

The testing approach was practical - the author verified the changes work correctly using existing examples (`free_camera_controller` and `3d_gizmos`), confirming that speed adjustments feel responsive and intuitive across different scales. Compared to the previous linear approach, users can now reach high speeds more quickly while still having precise control at lower speeds.

This change demonstrates good API design principles: it solves a real usability problem, maintains backward compatibility for the most part (the `scroll_factor` parameter still exists but now has a different semantic meaning), provides clear documentation, and uses appropriate mathematical functions for the problem domain.

## Visual Representation

```mermaid
graph TD
    A[Mouse Scroll Event] --> B{Determine Scroll Amount}
    B -->|Line units| C[Use delta.y directly]
    B -->|Pixel units| D[Convert pixels to lines]
    C --> E[Calculate scroll factor]
    D --> E
    E --> F[Compute exponential multiplier: exp(scroll_factor * scroll)]
    F --> G[Update speed_multiplier *= multiplier]
    G --> H[Clamp to EPSILON..MAX]
    H --> I[Apply to camera movement]
```

## Key Files Changed

### `crates/bevy_camera_controller/src/free_camera.rs` (+27/-10)

This file contains the implementation of the free camera controller, which handles user input for camera movement, rotation, and speed adjustment. The changes modify how mouse scroll wheel input affects the camera's movement speed.

**Key modifications:**

1. **Import addition**: Added `ops::exp` to the math imports to use the exponential function.

```rust
// Before:
use bevy_math::{EulerRot, Quat, StableInterpolate, Vec2, Vec3};

// After:
use bevy_math::{ops::exp, EulerRot, Quat, StableInterpolate, Vec2, Vec3};
```

2. **Documentation update**: Expanded the documentation for `scroll_factor` to explain the new exponential behavior and provide guidance on choosing appropriate values.

```rust
// Before (brief comment):
/// Multiplier for how the mouse scroll wheel modifies [`walk_speed`](FreeCamera::walk_speed)
/// and [`run_speed`](FreeCamera::run_speed).
pub scroll_factor: f32,

// After (detailed explanation):
/// Multiplier for how much the mouse scroll wheel affects [`walk_speed`](FreeCamera::walk_speed)
/// and [`run_speed`](FreeCamera::run_speed).
///
/// Mouse scroll affects speed exponentially. This is to ensure that scrolling the same
/// amount always has the same effect on speed, regardless of how the scroll amount
/// is reported by the hardware (i.e. as one big event vs many smaller events). This
/// also allows the free camera to navigate very large scenes easier.
///
/// For every unit of scroll, the speed of the camera is multiplied by a factor of
/// `e^(scroll_factor)`.
///
/// A reasonable value to start with is a `scroll_factor` between 0.04879016 (~ln(1.05))
/// and 0.0953102 (~ln(1.1)). They represent an increase by a factor between 1.05 and 1.1 per
/// positive unit scroll and a reduction between ~0.952 (~e^-0.04879016) and ~0.909
/// (~e^-0.0953102) times its value per negative unit scroll
///
/// A `scroll_factor` closer to 0.0 means that speed will be less sensitive to scroll.
/// A `scroll_factor` equal to 0.0 means that speed is unaffected by scroll
/// (it will be multiplied by a factor of 1.0 per positive and negative unit scroll).
pub scroll_factor: f32,
```

3. **Default value change**: Updated the default `scroll_factor` from 0.5 to approximately ln(1.05).

```rust
// Before:
scroll_factor: 0.5,

// After:
// Approximation of ln(1.05)
scroll_factor: 0.04879016,
```

4. **Scroll processing logic**: Changed from linear accumulation to exponential scaling.

```rust
// Before implementation (simplified for comparison):
let mut scroll = 0.0;
scroll += amount;  // accumulated scroll
state.speed_multiplier += scroll * config.scroll_factor;
state.speed_multiplier = state.speed_multiplier.clamp(0.0, f32::MAX);

// After implementation:
let scroll = match accumulated_mouse_scroll.unit {
    MouseScrollUnit::Line => accumulated_mouse_scroll.delta.y,
    MouseScrollUnit::Pixel => {
        accumulated_mouse_scroll.delta.y / MouseScrollUnit::SCROLL_UNIT_CONVERSION_FACTOR
    }
};
// By using exponentiation we ensure that this scales up and down smoothly
// regardless of the amount of scrolling processed per frame
state.speed_multiplier *= exp(config.scroll_factor * scroll);
// Clamp the speed multiplier for safety.
state.speed_multiplier = state.speed_multiplier.clamp(f32::EPSILON, f32::MAX);
```

These changes relate directly to the PR's purpose of making camera speed adjustments more usable across different scales by implementing exponential scaling, which provides consistent relative speed changes regardless of the current speed or how scroll events are reported by hardware.

## Further Reading

1. **Exponential Functions in Game Development**: Exponential scaling is commonly used for camera controls, volume sliders, and other settings where users need to adjust values across multiple orders of magnitude while maintaining fine control at both ends of the range.

2. **Logarithmic and Exponential Relationships**: Understanding the mathematical relationship between logarithmic and exponential functions is key to designing intuitive control schemes. The natural logarithm (ln) and exponential (exp) functions are inverses of each other.

3. **Human Perception and Control Design**: Research in human-computer interaction shows that humans perceive many physical phenomena (like sound, light, and in this case, motion speed) logarithmically rather than linearly, making exponential controls more intuitive.

4. **Bevy Input System**: For developers wanting to understand how input events work in Bevy, the `bevy_input` crate documentation provides details on how mouse, keyboard, and other input events are processed and can be used in game systems.

5. **Camera Controllers in 3D Engines**: Most modern 3D game engines and DCC tools use exponential or logarithmic scaling for camera navigation controls, as this approach has proven most effective for working with scenes that can vary dramatically in scale.