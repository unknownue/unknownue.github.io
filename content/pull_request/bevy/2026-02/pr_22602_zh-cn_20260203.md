+++
title = "#22602 Observer run conditions"
date = "2026-02-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22602-en-20260203" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22602-zh-cn-20260203" }}
+++

# Observer run conditions

## 基本信息
- **标题**: Observer run conditions
- **PR链接**: https://github.com/bevyengine/bevy/pull/22602
- **作者**: jonas-meyer
- **状态**: MERGED
- **标签**: C-Feature, A-ECS, S-Ready-For-Final-Review, M-Release-Note, D-Modest, D-Unsafe
- **创建时间**: 2026-01-19T21:58:49Z
- **合并时间**: 2026-02-03T16:12:26Z
- **合并者**: alice-i-cecile

## 描述翻译
### 目标

允许观察者使用运行条件，使其能够基于世界状态进行条件执行——与系统使用 `.run_if()` 的模式相同。

修复 #14195
修复 #21442

### 解决方案

通过 `ObserverSystemExt` trait 为观察者系统添加 `run_if()` 方法。条件存储在 `Observer` 中，并在运行器中执行前检查。

关键实现细节：
- `ObserverWithCondition<E,B,M,S>` 包装器保留事件类型信息，以便在实体观察者上实现编译时 `EntityEvent` 强制。
- 条件必须是 `ReadOnlySystem`（由 `SystemCondition` trait 强制执行），与系统运行条件一致。
- 多个条件以 AND 语义链式组合，第一个 false 会短路。

这比[这里](https://github.com/bevyengine/bevy/issues/21442#issuecomment-3765694484)提到的要复杂一些，因为我们需要完整的系统风格 API：链式 run_ifs、带有编译时 `EntityEvent` 检查的实体观察者，以及与 `add_observer`/`observe` 的配合使用。

这迫使实现使用了类型包装器 + 标记类型 + `IntoObserver`/`IntoEntityObserver`，并且条件必须在生成时初始化（因此钩子必须接受/初始化/恢复）。运行器还需要在运行观察者之前进行安全检查。

### 测试

- 新增 7 个测试，涵盖：
  - 条件阻止/允许执行
  - 多个条件（全部为真 / 一个为假）
  - 带有条件的实体观察者
  - 基于资源的条件
  - `Observer::new()` 上的构建器模式
- 所有现有测试通过 (`cargo test -p bevy_ecs`)
- 使用空格键切换更新了 `observers.rs` 示例

---

### 展示

```rust
#[derive(Resource)]
struct GameActive(bool);
// 全局观察者 - 仅在游戏激活时运行
app.add_observer(
    on_damage.run_if(|state: Res<GameActive>| state.0)
);
// 链式条件（AND 语义）
app.add_observer(
    on_damage
        .run_if(|state: Res<GameActive>| state.0)
        .run_if(|player: Query<&Health, With<Player>>| player.single().is_ok())
);
// 实体观察者
commands.spawn(Enemy).observe(
    on_hit.run_if(|game: Res<GameActive>| game.0)
);
// 构建器模式
world.spawn(
    Observer::new(on_event)
        .with_entity(target)
        .run_if(some_condition)
);
```

<details>

<summary>observers.rs 示例</summary>

```rust
#[derive(Resource, Default)]
struct ExplosionsEnabled(bool);

fn toggle_explosions(mut enabled: ResMut<ExplosionsEnabled>, input: Res<ButtonInput<KeyCode>>) {
    if input.just_pressed(KeyCode::Space) {
        enabled.0 = !enabled.0;
        info!("Explosions {}", if enabled.0 { "enabled" } else { "disabled" });
    }
}

fn setup(app: &mut App) {
    app.add_observer(
        explode_mine.run_if(|enabled: Res<ExplosionsEnabled>| enabled.0)
    );
}
```

</details>

## 这个PR的故事

这个PR开始于一个实际的需求：Bevy的观察者(Observer)系统缺乏条件执行能力。在Bevy ECS中，观察者用于响应事件，类似于回调函数，但当开发者需要在特定条件下才执行观察者时，之前没有直接的方法。系统(Systems)已经有`.run_if()`方法，但观察者没有。

问题在issue #14195和#21442中明确提出。开发者需要让观察者只在某些资源存在或某些状态为真时才运行，例如只在游戏未暂停时执行伤害处理，或者只在玩家存在时处理事件。

这个PR的目标很直接：为观察者添加运行条件，使其API与系统保持一致。但实现起来比预期复杂，因为需要保持现有的类型安全特性和编译时检查。

### 核心挑战

观察者有两个主要使用场景：全局观察者（通过`add_observer`添加）和实体观察者（通过`observe`方法附加到特定实体）。对于实体观察者，Bevy要求在编译时验证事件类型实现了`EntityEvent` trait。这意味着任何解决方案都不能破坏现有的类型检查。

另一个挑战是条件需要在观察者被触发时动态评估，这涉及到：
1. 将条件存储在观察者内部
2. 在观察者运行前评估所有条件
3. 保持条件系统与普通系统运行条件相同的语义

### 解决方案架构

开发者采用了分层的设计。首先创建了`ObserverCondition`结构体来包装条件系统：

```rust
pub(crate) struct ObserverCondition {
    condition: BoxedCondition,
}
```

这个结构体负责条件的初始化和检查。关键的设计决策是让条件系统与普通系统使用相同的`BoxedCondition`类型，确保API一致性。

然后引入了`ObserverWithCondition<E, B, M, S>`包装器：

```rust
pub struct ObserverWithCondition<E: Event, B: Bundle, M, S: IntoObserverSystem<E, B, M>> {
    pub(crate) system: S,
    pub(crate) conditions: Vec<BoxedCondition>,
    pub(crate) _marker: PhantomData<fn() -> (E, B, M)>,
}
```

这个包装器是关键所在。它保留了事件类型`E`、bundle类型`B`和marker类型`M`的信息，这使得它可以在编译时进行类型检查。`_marker`字段确保类型参数在编译时被使用，防止类型擦除。

### 扩展trait设计

为了提供流畅的API，添加了`ObserverSystemExt` trait：

```rust
pub trait ObserverSystemExt<E: Event, B: Bundle, M>: IntoObserverSystem<E, B, M> + Sized {
    fn run_if<C, CM>(self, condition: C) -> ObserverWithCondition<E, B, M, Self>
    where
        C: SystemCondition<CM>;
}
```

这个trait为所有观察者系统添加了`.run_if()`方法，返回`ObserverWithCondition`包装器。这使得链式调用成为可能：`observer.run_if(cond1).run_if(cond2)`。

### 统一入口点

为了处理不同类型的观察者输入（普通系统、带条件的系统、已构建的Observer实例），引入了两个新的trait：

```rust
pub trait IntoObserver<Marker>: Send + 'static {
    fn into_observer(self) -> Observer;
}

pub trait IntoEntityObserver<Marker>: Send + 'static {
    fn into_observer_for_entity(self, entity: Entity) -> Observer;
}
```

这些trait替代了之前直接使用`IntoObserverSystem`的方法签名。`add_observer`现在接受`impl IntoObserver`，而`observe`接受`impl IntoEntityObserver`。这种设计提供了灵活性，同时保持了类型安全。

### 条件执行机制

在运行器层面，修改了观察者的执行流程。在`runner.rs`中，在执行观察者系统之前添加了条件检查：

```rust
let mut should_run = true;
for condition in state.conditions.iter_mut() {
    should_run &= unsafe { condition.check(world) };
}

if !should_run {
    return;
}
```

这里的安全注释很重要：条件系统被限制为只读系统(`ReadOnlySystem`)，因此它们不会引起别名问题。调用者必须确保世界单元格对条件系统的参数有效。

### 初始化流程

条件的初始化需要特别处理，因为观察者可能通过命令(command)或钩子(hook)添加。在`hook_on_add`函数中，现在会提取条件、初始化它们，然后再存回观察者：

```rust
let mut conditions = {
    let Some(mut observe) = world.get_mut::<Observer>(entity) else {
        return;
    };
    core::mem::take(&mut observe.conditions)
};

for condition in &mut conditions {
    condition.initialize(world);
}

if let Some(mut observe) = world.get_mut::<Observer>(entity) {
    observe.conditions = conditions;
}
```

使用`core::mem::take`确保了在初始化期间不会持有对观察者的可变引用，避免了借用冲突。

### 测试策略

PR包含了全面的测试，验证了各种场景：
- 条件为真/假时的观察者执行
- 多个条件的AND语义
- 条件重新评估（资源变化后）
- 实体观察者与条件的配合
- 构建器模式

这些测试不仅验证了功能正确性，还验证了变更检测的正确性。一个有趣的测试展示了条件与变更检测的交互：

```rust
observer.run_if(|res1: Res<RunConditionFlag>| res1.is_changed())
       .run_if(|res2: Res<Bool2>| res2.is_changed())
```

这个测试确保当条件使用`is_changed()`时，行为符合预期。

### 示例更新

`observers.rs`示例被更新以展示新功能。添加了`ExplosionsEnabled`资源，并通过空格键切换其状态。观察者现在只在爆炸启用时运行：

```rust
app.add_observer(
    explode_mine.run_if(|enabled: Res<ExplosionsEnabled>| enabled.0)
);
```

这个示例直观地展示了运行条件的实用性。

### 设计权衡

实现中做了几个重要的设计决策：

1. **AND语义**：多个条件使用AND连接，所有条件必须为真。这与系统运行条件的行为一致。

2. **无短路求值**：文档明确指出，链式的`.run_if()`调用不会短路——所有条件每次都会运行。这是为了保持变更检测的正确性。如果需要短路行为，可以使用`.run_if(a.and(b))`，但要注意这可能导致陈旧的`Changed<T>`检测。

3. **编译时类型安全**：通过`ObserverWithCondition`包装器保持实体观察者的类型检查，即使添加了条件也不会削弱类型安全。

4. **统一API**：通过`IntoObserver`和`IntoEntityObserver` trait统一了不同输入类型的处理，使API更加一致和灵活。

### 影响

这个PR为Bevy观察者带来了重要的功能扩展。它使观察者更加灵活，能够根据游戏状态动态控制执行。API设计保持了与现有系统的一致性，降低了学习成本。

从架构角度看，这个PR展示了如何在保持向后兼容性和类型安全的同时扩展复杂系统。条件系统的设计与现有系统运行条件共享基础设施，避免了重复实现。

## 可视化表示

```mermaid
graph TD
    A[用户代码] --> B[.run_if(condition)]
    B --> C[ObserverWithCondition]
    C --> D[IntoObserver/IntoEntityObserver]
    D --> E[Observer结构体]
    E --> F[包含conditions字段]
    F --> G[观察者运行器]
    G --> H{检查所有条件}
    H -->|全部为真| I[执行观察者系统]
    H -->|任一为假| J[跳过执行]
    
    subgraph "条件系统"
        K[SystemCondition trait]
        L[ReadOnlySystem约束]
        M[BoxedCondition包装]
    end
    
    K --> L
    L --> M
    M --> F
```

## 关键文件变更

### `crates/bevy_ecs/src/observer/condition.rs` (+108/-0)
**新增文件**，定义观察者运行条件的核心类型。

关键代码：
```rust
pub(crate) struct ObserverCondition {
    condition: BoxedCondition,
}

impl ObserverCondition {
    pub(crate) fn new<M>(condition: impl SystemCondition<M>) -> Self {
        Self {
            condition: Box::new(IntoSystem::into_system(condition)),
        }
    }
    
    pub(crate) unsafe fn check(&mut self, world: UnsafeWorldCell) -> bool {
        unsafe { self.condition.run_unsafe((), world) }.unwrap_or(false)
    }
}

pub struct ObserverWithCondition<E: Event, B: Bundle, M, S: IntoObserverSystem<E, B, M>> {
    pub(crate) system: S,
    pub(crate) conditions: Vec<BoxedCondition>,
    pub(crate) _marker: PhantomData<fn() -> (E, B, M)>,
}
```

### `crates/bevy_ecs/src/observer/distributed_storage.rs` (+138/-12)
**主要修改文件**，更新`Observer`结构体并添加新trait。

关键变更：
```rust
// 在Observer结构体中添加conditions字段
pub struct Observer {
    // ... 其他字段
    pub(crate) conditions: Vec<ObserverCondition>,
}

// 为Observer添加run_if方法
impl Observer {
    pub fn run_if<M>(mut self, condition: impl SystemCondition<M>) -> Self {
        self.conditions.push(ObserverCondition::new(condition));
        self
    }
}

// 新增IntoObserver trait
pub trait IntoObserver<Marker>: Send + 'static {
    fn into_observer(self) -> Observer;
}

// 新增IntoEntityObserver trait
pub trait IntoEntityObserver<Marker>: Send + 'static {
    fn into_observer_for_entity(self, entity: Entity) -> Observer;
}

// 新增ObserverSystemExt trait
pub trait ObserverSystemExt<E: Event, B: Bundle, M>: IntoObserverSystem<E, B, M> + Sized {
    fn run_if<C, CM>(self, condition: C) -> ObserverWithCondition<E, B, M, Self>
    where
        C: SystemCondition<CM>;
}
```

### `crates/bevy_ecs/src/observer/runner.rs` (+20/-0)
**修改运行器**，添加条件检查逻辑。

关键代码：
```rust
// 在执行观察者系统前添加条件检查
let mut should_run = true;
for condition in state.conditions.iter_mut() {
    // SAFETY: See the safety comment above.
    should_run &= unsafe { condition.check(world) };
}

if !should_run {
    return;
}
```

### `crates/bevy_ecs/src/observer/mod.rs` (+215/-6)
**修改模块主文件**，更新API并添加测试。

关键变更：
```rust
// 更新add_observer方法签名
pub fn add_observer<M>(&mut self, observer: impl IntoObserver<M>) -> EntityWorldMut<'_> {
    self.spawn(observer.into_observer())
}

// 添加7个新测试验证运行条件功能
```

### `examples/ecs/observers.rs` (+32/-7)
**更新示例**，展示运行条件的使用。

关键变更：
```rust
// 添加资源控制爆炸是否启用
#[derive(Resource)]
struct ExplosionsEnabled(bool);

// 添加系统切换爆炸状态
fn toggle_explosions(keyboard: Res<ButtonInput<KeyCode>>, mut enabled: ResMut<ExplosionsEnabled>) {
    if keyboard.just_pressed(KeyCode::Space) {
        enabled.0 = !enabled.0;
        info!("Explosions {}", if enabled.0 { "ENABLED" } else { "DISABLED" });
    }
}

// 观察者使用运行条件
app.add_observer(
    explode_mine.run_if(|enabled: Res<ExplosionsEnabled>| enabled.0)
);
```

### `release-content/release-notes/observer_run_conditions.md` (+26/-0)
**新增发布说明**，记录新功能。

## 进一步阅读

- [Bevy观察者文档](https://docs.rs/bevy_ecs/latest/bevy_ecs/observer/index.html) - 官方观察者系统文档
- [系统运行条件](https://docs.rs/bevy_ecs/latest/bevy_ecs/system/trait.IntoSystem.html#method.run_if) - 系统运行条件的设计和实现
- [EntityEvent trait](https://docs.rs/bevy_ecs/latest/bevy_ecs/event/trait.EntityEvent.html) - 实体事件的定义和用途
- [Rust PhantomData](https://doc.rust-lang.org/std/marker/struct.PhantomData.html) - 理解类型标记模式
- [Bevy ECS架构](https://bevy-cheatbook.github.io/programming/ecs-intro.html) - Bevy ECS整体架构介绍