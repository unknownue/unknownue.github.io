+++
title = "#22857 Make light extraction retained, and clean up lights that became newly invisible."
date = "2026-02-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22857-en-20260209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22857-zh-cn-20260209" }}
labels = ["C-Bug", "A-Rendering", "C-Performance", "P-Regression"]
+++

# Title

## Basic Information
- **Title**: Make light extraction retained, and clean up lights that became newly invisible.
- **PR Link**: https://github.com/bevyengine/bevy/pull/22857
- **Author**: pcwalton
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, C-Performance, P-Regression
- **Created**: 2026-02-07T18:21:08Z
- **Merged**: 2026-02-09T07:36:06Z
- **Merged By**: superdump

## Description Translation
The lighting code is designed such that lights that aren't visible in any view shouldn't exist in the render world. Unfortunately, when the render world was made retained, the light extraction code was never fully updated to clean up components corresponding to lights that became invisible. So Bevy is currently not enforcing that invariant. This causes `many_lights` to become slower over time as more lights enter the view and are extracted to the render world, while lights outside the view aren't removed.

This PR fixes the issue in two ways:

1. Light extraction now properly accounts for the retained render world, following the patterns that other objects like meshes use. Lights that haven't changed from the previous frame aren't re-extracted and are retained from frame to frame.

2. Visibility of lights and other clustered objects is now determined by the same system that determines visibility of meshes. The `GlobalVisibleClusterableObjects` side table is gone. To do this, I made the existing `Sphere` type into a component that can be added in lieu of `Aabb` to entities that are culled using spheres instead of AABBs.  This was surprisingly straightforward to add to the visibility code, as it was already using spheres for quick rejection.

In addition to being a simplification, this PR increases the FPS of `many_lights` from around 30 FPS to around 100 FPS on my Ryzen 9 8945HS, moving it from CPU bound to strongly GPU bound. The profile was dominated by `extract_lights` and `prepare_lights` before. Retained mode drops `extract_lights` time from 8.9 ms plus 8.0 ms of commands processing time to 0.4 ms, and `prepare_lights` time drops to approximately 1.2 ms per frame (which further drops to 0.9 ms with my extra PR #22846 applied).

`many_lights` on `main`:
<img width="2756" height="1800" alt="Screenshot 2026-02-07 101916" src="https://github.com/user-attachments/assets/18ec7190-cb5b-41c8-8c6f-75ef13d683fb" />

`many_lights` in this PR:
<img width="2756" height="1800" alt="Screenshot 2026-02-07 101210" src="https://github.com/user-attachments/assets/daf3d93f-efcc-4a2e-b728-da1f32e6ad85" />

Comparison of `prepare_lights` between `main` and this PR for `many_lights`:
<img width="2756" height="1800" alt="Screenshot 2026-02-07 101234" src="https://github.com/user-attachments/assets/c8c63685-a3df-4351-a7f3-d74fc40d505a" />

Comparison of `extract_lights` between `main` and this PR for `many_lights`:
<img width="2756" height="1800" alt="Screenshot 2026-02-07 101248" src="https://github.com/user-attachments/assets/68eb1618-a856-40eb-94bc-91f215d1dc4e" />

## The Story of This Pull Request

The render world in Bevy was transitioned to a retained model to improve performance by avoiding re-extraction of unchanged entities each frame. However, the light extraction system wasn't fully updated during this transition, leaving a critical gap: lights that became invisible weren't being cleaned up from the render world.

This created a performance regression where the `many_lights` example would gradually slow down over time. The problem was that as more lights entered the view frustum, they were extracted to the render world, but when they left the frustum, their corresponding components weren't removed. This violated the design invariant that invisible lights shouldn't exist in the render world, leading to unnecessary processing and memory usage that accumulated frame after frame.

The solution implemented here addresses two main issues. First, light extraction needed to be made properly retained, following the same pattern used by other render objects like meshes. Second, the system for determining light visibility needed to be unified with the existing mesh visibility system, eliminating a separate side table that tracked visible clusterable objects.

To achieve the second goal, the developer made a strategic observation: the existing visibility system already used spheres for quick frustum culling rejection, even though it primarily worked with AABBs. By converting the existing `Sphere` struct into a proper `Component`, lights (which are naturally bounded by spheres based on their range) could use the same visibility determination pipeline as meshes.

The implementation involved several coordinated changes:

1. **Sphere Component**: The `Sphere` struct in `primitives.rs` was converted to a component with proper documentation. This allowed lights to have bounding spheres instead of AABBs for frustum culling.

2. **Visibility System Updates**: The `check_visibility` function was extended to handle entities with either `Aabb` or `Sphere` components. The logic already existed for sphere-based quick rejection, so this was a natural extension.

3. **Light Bound Updates**: New systems (`update_point_light_bounding_spheres` and `update_spot_light_bounding_spheres`) were added to automatically update bounding sphere components when light properties or transforms change. These systems run in a new `UpdateBounds` system set before visibility calculations.

4. **Removal of GlobalVisibleClusterableObjects**: The `GlobalVisibleClusterableObjects` resource was completely removed. Instead of maintaining a separate set of visible lights, the system now relies on the standard `ViewVisibility` component that's part of the visibility system.

5. **Retained Light Extraction**: The `extract_lights` system was refactored to work in retained mode. It now:
   - Only processes lights that have changed (using `Changed` filters in queries)
   - Properly removes extracted light components when lights become invisible
   - Tracks which lights were processed in the current frame to avoid incorrectly removing components when lights are removed and re-added in the same frame

The key insight in the extraction logic was that the system needed to handle component removal correctly. The developer added a helper function `remove_components` that removes render-world components when their corresponding main-world components are removed, but only if those entities weren't already processed in the current extraction pass. This handles the edge case where a component might be removed and re-added in the same frame.

The performance improvements are substantial. By moving from a non-retained extraction model (where all visible lights were re-extracted every frame) to a retained model (where only changed lights are processed), extraction time dropped from ~17ms (8.9ms extraction + 8.0ms commands processing) to just 0.4ms. The `prepare_lights` system also saw significant improvements due to reduced data volume.

This refactoring also simplified the codebase by eliminating the `GlobalVisibleClusterableObjects` side table and unifying light visibility determination with the existing mesh visibility system. The changes maintain backward compatibility while fixing both a bug (lights not being cleaned up) and a performance regression.

## Visual Representation

```mermaid
graph TB
    subgraph "Before PR"
        A[Main World Lights] --> B[GlobalVisibleClusterableObjects]
        B --> C[extract_lights processes all]
        C --> D[Render World Lights]
    end
    
    subgraph "After PR"
        E[Main World Lights] --> F[Visibility System]
        F --> G[ViewVisibility Component]
        G --> H[extract_lights processes only changed]
        H --> I[Render World Lights]
    end
    
    style A fill:#e1f5fe
    style E fill:#e1f5fe
    style D fill:#f1f8e9
    style I fill:#f1f8e9
    style B fill:#ffebee
    style F fill:#f3e5f5
```

## Key Files Changed

### `crates/bevy_camera/src/primitives.rs`
**What changed**: The `Sphere` struct was converted to a `Component` with proper documentation.
**Why**: To allow entities (particularly lights) to use spheres for frustum culling instead of AABBs.
**Code snippet**:
```rust
// Before:
#[derive(Clone, Debug, Default)]
pub struct Sphere {
    pub center: Vec3A,
    pub radius: f32,
}

// After:
#[derive(Component, Clone, Copy, Debug, Default, Reflect)]
#[reflect(Component, Clone, Debug, Default)]
pub struct Sphere {
    pub center: Vec3A,
    pub radius: f32,
}
```

### `crates/bevy_camera/src/visibility/mod.rs`
**What changed**: The `check_visibility` function was extended to handle entities with `Sphere` components for frustum culling.
**Why**: To allow lights with bounding spheres to use the same visibility determination as meshes with AABBs.
**Code snippet**:
```rust
// After: Added support for Sphere components
if !no_frustum_culling && !no_cpu_culling_camera && !no_cpu_culling_entity {
    if let Some(model_aabb) = maybe_model_aabb {
        // Existing AABB-based culling
    } else if let Some(model_sphere) = maybe_model_sphere
        && !frustum.intersects_sphere(model_sphere, false)
    {
        // Do sphere-based frustum culling in this case
        return;
    }
}
```

### `crates/bevy_light/src/point_light.rs`
**What changed**: Added `update_point_light_bounding_spheres` system and updated `update_point_light_frusta`.
**Why**: To automatically maintain bounding sphere components for point lights and update frusta based on visibility.
**Code snippet**:
```rust
// New system to update bounding spheres
pub fn update_point_light_bounding_spheres(
    mut commands: Commands,
    point_lights_query: Query<
        (Entity, &PointLight, &GlobalTransform),
        Or<(Changed<PointLight>, Changed<GlobalTransform>)>,
    >,
) {
    for (point_light_entity, point_light, global_transform) in &point_lights_query {
        commands.entity(point_light_entity).insert(Sphere {
            center: global_transform.translation_vec3a(),
            radius: point_light.range,
        });
    }
}

// Updated frusta update to use ViewVisibility instead of GlobalVisibleClusterableObjects
pub fn update_point_light_frusta(
    mut views: Query<
        (
            &GlobalTransform,
            &PointLight,
            &mut CubemapFrusta,
            &ViewVisibility,
        ),
        Or<(
            Changed<GlobalTransform>,
            Changed<PointLight>,
            Changed<ViewVisibility>,
        )>,
    >,
) {
    for (transform, point_light, mut cubemap_frusta, view_visibility) in &mut views {
        if !point_light.shadow_maps_enabled || !view_visibility.get() {
            continue;
        }
        // Update frusta...
    }
}
```

### `crates/bevy_light/src/spot_light.rs`
**What changed**: Added `update_spot_light_bounding_spheres` system with similar changes to point lights.
**Why**: Consistency with point lights - spot lights also need bounding spheres for visibility determination.
**Code snippet**:
```rust
pub fn update_spot_light_bounding_spheres(
    mut commands: Commands,
    spot_lights_query: Query<
        (Entity, &SpotLight, &GlobalTransform),
        Or<(Changed<SpotLight>, Changed<GlobalTransform>)>,
    >,
) {
    for (spot_light_entity, spot_light, global_transform) in &spot_lights_query {
        commands.entity(spot_light_entity).insert(Sphere {
            center: global_transform.translation_vec3a(),
            radius: spot_light.range,
        });
    }
}
```

### `crates/bevy_pbr/src/render/light.rs`
**What changed**: Complete refactor of `extract_lights` to work in retained mode with proper cleanup.
**Why**: To fix the performance regression and ensure invisible lights are removed from render world.
**Key changes**:
1. Uses `Changed` filters to only process modified lights
2. Tracks processed entities to avoid incorrect removal
3. Adds helper function to clean up components when lights are removed

**Code snippet** (extract logic for point lights):
```rust
// Now using Changed filters
let point_lights = Extract<
    Query<
        (
            Entity,
            RenderEntity,
            &PointLight,
            &CubemapVisibleEntities,
            &GlobalTransform,
            &ViewVisibility,
            &CubemapFrusta,
            Option<&VolumetricLight>,
        ),
        Or<(
            Changed<PointLight>,
            Changed<CubemapVisibleEntities>,
            Changed<GlobalTransform>,
            Changed<ViewVisibility>,
            Changed<CubemapFrusta>,
            Changed<VolumetricLight>,
        )>,
    >,
>;

// Helper function for component removal
fn remove_components<MC, RWC>(
    commands: &mut Commands,
    mapper: &Query<RenderEntity>,
    removed_components: &mut RemovedComponents<MC>,
    seen_entities: &MainEntityHashSet,
) where
    MC: Component,
    RWC: Component,
{
    for main_entity in removed_components.read() {
        if !seen_entities.contains(&MainEntity::from(main_entity))
            && let Ok(render_entity) = mapper.get(main_entity)
            && let Ok(mut entity_commands) = commands.get_entity(render_entity)
        {
            entity_commands.remove::<RWC>();
        }
    }
}
```

### `crates/bevy_light/src/cluster/mod.rs`
**What changed**: Removed `GlobalVisibleClusterableObjects` resource and added system to add AABBs to light probes and decals.
**Why**: To eliminate the side table and use standard visibility system for all clustered objects.
**Code snippet**:
```rust
// Resource removed entirely
// Previously: #[derive(Resource, Default)]
// pub struct GlobalVisibleClusterableObjects {
//     pub(crate) entities: HashSet<Entity>,
// }

// New system to ensure light probes and decals have AABBs for visibility
pub fn add_light_probe_and_decal_aabbs(
    mut commands: Commands,
    light_probes_and_decals_query: Query<
        Entity,
        (Or<(With<ClusteredDecal>, With<LightProbe>)>, Without<Aabb>),
    >,
) {
    for entity in &light_probes_and_decals_query {
        commands.entity(entity).insert(Aabb {
            center: Vec3A::ZERO,
            half_extents: Vec3A::splat(0.5),
        });
    }
}
```

## Further Reading

1. **Bevy Render Architecture**: Understanding Bevy's ECS-based renderer and the retained render world pattern
2. **Frustum Culling Algorithms**: Techniques for visibility determination in 3D graphics
3. **Clustered Forward/Deferred Rendering**: Modern approaches to handling many lights in real-time rendering
4. **Component Removal Patterns in ECS**: Best practices for managing component lifecycle in entity-component systems