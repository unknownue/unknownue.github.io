diff --git a/crates/bevy_asset/src/asset_changed.rs b/crates/bevy_asset/src/asset_changed.rs
index c5e3b4afba324..0562a857d047d 100644
--- a/crates/bevy_asset/src/asset_changed.rs
+++ b/crates/bevy_asset/src/asset_changed.rs
@@ -249,7 +249,7 @@ unsafe impl<A: AsAssetId> WorldQuery for AssetChanged<A> {
     }
 
     fn get_state(components: &Components) -> Option<Self::State> {
-        let resource_id = components.resource_id::<AssetChanges<A::Asset>>()?;
+        let resource_id = components.component_id::<AssetChanges<A::Asset>>()?;
         let asset_id = components.component_id::<A>()?;
         Some(AssetChangedState {
             asset_id,
diff --git a/crates/bevy_ecs/src/component/info.rs b/crates/bevy_ecs/src/component/info.rs
index a8423d9e67196..ece5ee20d68ee 100644
--- a/crates/bevy_ecs/src/component/info.rs
+++ b/crates/bevy_ecs/src/component/info.rs
@@ -167,9 +167,8 @@ impl ComponentInfo {
 /// one `World` to access the metadata of a `Component` in a different `World` is undefined behavior
 /// and must not be attempted.
 ///
-/// Given a type `T` which implements [`Component`], the `ComponentId` for `T` can be retrieved
+/// Given a type `T` which implements [`Component`] (including [`Resource`]), the `ComponentId` for `T` can be retrieved
 /// from a `World` using [`World::component_id()`](crate::world::World::component_id) or via [`Components::component_id()`].
-/// Access to the `ComponentId` for a [`Resource`] is available via [`Components::resource_id()`].
 #[derive(Debug, Copy, Clone, Hash, Ord, PartialOrd, Eq, PartialEq)]
 #[cfg_attr(
     feature = "bevy_reflect",
@@ -301,6 +300,7 @@ impl ComponentDescriptor {
     /// Create a new `ComponentDescriptor` for a resource.
     ///
     /// The [`StorageType`] for resources is always [`StorageType::Table`].
+    #[deprecated(since = "0.19.0", note = "use ComponentDescriptor::new()")]
     pub fn new_resource<T: Resource>() -> Self {
         Self::new::<T>()
     }
@@ -577,7 +577,6 @@ impl Components {
     /// # See also
     ///
     /// * [`Components::get_valid_id()`]
-    /// * [`Components::valid_resource_id()`]
     /// * [`World::component_id()`](crate::world::World::component_id)
     #[inline]
     pub fn valid_component_id<T: Component>(&self) -> Option<ComponentId> {
@@ -586,6 +585,7 @@ impl Components {
 
     /// Type-erased equivalent of [`Components::valid_resource_id()`].
     #[inline]
+    #[deprecated(since = "0.19.0", note = "use get_valid_id")]
     pub fn get_valid_resource_id(&self, type_id: TypeId) -> Option<ComponentId> {
         self.indices.get(&type_id).copied()
     }
@@ -611,8 +611,9 @@ impl Components {
     /// * [`Components::valid_component_id()`]
     /// * [`Components::get_resource_id()`]
     #[inline]
+    #[deprecated(since = "0.19.0", note = "use valid_component_id")]
     pub fn valid_resource_id<T: Resource>(&self) -> Option<ComponentId> {
-        self.get_valid_resource_id(TypeId::of::<T>())
+        self.get_valid_id(TypeId::of::<T>())
     }
 
     /// Type-erased equivalent of [`Components::component_id()`].
@@ -655,7 +656,6 @@ impl Components {
     ///
     /// * [`ComponentIdFor`](super::ComponentIdFor)
     /// * [`Components::get_id()`]
-    /// * [`Components::resource_id()`]
     /// * [`World::component_id()`](crate::world::World::component_id)
     #[inline]
     pub fn component_id<T: Component>(&self) -> Option<ComponentId> {
@@ -664,6 +664,7 @@ impl Components {
 
     /// Type-erased equivalent of [`Components::resource_id()`].
     #[inline]
+    #[deprecated(since = "0.19.0", note = "use get_id")]
     pub fn get_resource_id(&self, type_id: TypeId) -> Option<ComponentId> {
         self.indices.get(&type_id).copied().or_else(|| {
             self.queued
@@ -703,8 +704,9 @@ impl Components {
     /// * [`Components::component_id()`]
     /// * [`Components::get_resource_id()`]
     #[inline]
+    #[deprecated(since = "0.19.0", note = "use component_id")]
     pub fn resource_id<T: Resource>(&self) -> Option<ComponentId> {
-        self.get_resource_id(TypeId::of::<T>())
+        self.get_id(TypeId::of::<T>())
     }
 
     /// # Safety
diff --git a/crates/bevy_ecs/src/component/register.rs b/crates/bevy_ecs/src/component/register.rs
index 76c10810b8061..8f5f175efc1c9 100644
--- a/crates/bevy_ecs/src/component/register.rs
+++ b/crates/bevy_ecs/src/component/register.rs
@@ -1,4 +1,4 @@
-use alloc::{boxed::Box, vec::Vec};
+use alloc::vec::Vec;
 use bevy_platform::sync::PoisonError;
 use bevy_utils::TypeIdMap;
 use core::any::Any;
@@ -326,7 +326,7 @@ impl<'w> ComponentsRegistrator<'w> {
     unsafe fn register_non_send_with(
         &mut self,
         type_id: TypeId,
-        descriptor: impl FnOnce() -> ComponentDescriptor,
+        descriptor: fn() -> ComponentDescriptor,
     ) -> ComponentId {
         if let Some(id) = self.indices.get(&type_id) {
             return *id;
@@ -367,8 +367,7 @@ impl<'w> ComponentsRegistrator<'w> {
 
 /// A queued component registration.
 pub(super) struct QueuedRegistration {
-    pub(super) registrator:
-        Box<dyn FnOnce(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor)>,
+    pub(super) registrator: fn(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor),
     pub(super) id: ComponentId,
     pub(super) descriptor: ComponentDescriptor,
 }
@@ -382,10 +381,10 @@ impl QueuedRegistration {
     unsafe fn new(
         id: ComponentId,
         descriptor: ComponentDescriptor,
-        func: impl FnOnce(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor) + 'static,
+        func: fn(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor),
     ) -> Self {
         Self {
-            registrator: Box::new(func),
+            registrator: func,
             id,
             descriptor,
         }
@@ -475,32 +474,7 @@ impl<'w> ComponentsQueuedRegistrator<'w> {
         &self,
         type_id: TypeId,
         descriptor: ComponentDescriptor,
-        func: impl FnOnce(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor) + 'static,
-    ) -> ComponentId {
-        self.components
-            .queued
-            .write()
-            .unwrap_or_else(PoisonError::into_inner)
-            .components
-            .entry(type_id)
-            .or_insert_with(|| {
-                // SAFETY: The id was just generated.
-                unsafe { QueuedRegistration::new(self.ids.next(), descriptor, func) }
-            })
-            .id
-    }
-
-    /// Queues this function to run as a resource registrator if the given
-    /// type is not already queued as a resource.
-    ///
-    /// # Safety
-    ///
-    /// The [`TypeId`] must not already be registered as a resource.
-    unsafe fn register_arbitrary_resource(
-        &self,
-        type_id: TypeId,
-        descriptor: ComponentDescriptor,
-        func: impl FnOnce(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor) + 'static,
+        func: fn(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor),
     ) -> ComponentId {
         self.components
             .queued
@@ -519,7 +493,7 @@ impl<'w> ComponentsQueuedRegistrator<'w> {
     fn register_arbitrary_dynamic(
         &self,
         descriptor: ComponentDescriptor,
-        func: impl FnOnce(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor) + 'static,
+        func: fn(&mut ComponentsRegistrator, ComponentId, ComponentDescriptor),
     ) -> ComponentId {
         let id = self.ids.next();
         self.components
@@ -552,14 +526,14 @@ impl<'w> ComponentsQueuedRegistrator<'w> {
                 self.register_arbitrary_component(
                     TypeId::of::<T>(),
                     ComponentDescriptor::new::<T>(),
-                    |registrator, id, _descriptor| {
+                    |registrator, id, descriptor| {
                         // SAFETY: We just checked that this is not currently registered or queued, and if it was registered since, this would have been dropped from the queue.
                         #[expect(unused_unsafe, reason = "More precise to specify.")]
                         unsafe {
                             registrator.register_component_unchecked(
                                 TypeId::of::<T>(),
                                 id,
-                                ComponentDescriptor::new::<T>(),
+                                descriptor,
                                 T::register_required_components,
                                 ComponentHooks::update_from_component::<T>,
                             );
@@ -611,27 +585,9 @@ impl<'w> ComponentsQueuedRegistrator<'w> {
     /// Technically speaking, the returned [`ComponentId`] is not valid, but it will become valid later.
     /// See type level docs for details.
     #[inline]
+    #[deprecated(since = "0.19.0", note = "use queue_register_component")]
     pub fn queue_register_resource<T: Resource>(&self) -> ComponentId {
-        let type_id = TypeId::of::<T>();
-        self.get_resource_id(type_id).unwrap_or_else(|| {
-            // SAFETY: We just checked that this type was not already registered.
-            unsafe {
-                self.register_arbitrary_resource(
-                    type_id,
-                    ComponentDescriptor::new_resource::<T>(),
-                    move |registrator, id, descriptor| {
-                        // SAFETY: We just checked that this is not currently registered or queued, and if it was registered since, this would have been dropped from the queue.
-                        // SAFETY: Id uniqueness handled by caller, and the type_id matches descriptor.
-                        #[expect(unused_unsafe, reason = "More precise to specify.")]
-                        unsafe {
-                            registrator
-                                .components
-                                .register_non_send_unchecked(type_id, id, descriptor);
-                        }
-                    },
-                )
-            }
-        })
+        self.queue_register_component::<T>()
     }
 
     /// This is a queued version of [`ComponentsRegistrator::register_non_send`].
@@ -647,20 +603,22 @@ impl<'w> ComponentsQueuedRegistrator<'w> {
     #[inline]
     pub fn queue_register_non_send<T: Any>(&self) -> ComponentId {
         let type_id = TypeId::of::<T>();
-        self.get_resource_id(type_id).unwrap_or_else(|| {
+        self.get_id(type_id).unwrap_or_else(|| {
             // SAFETY: We just checked that this type was not already registered.
             unsafe {
-                self.register_arbitrary_resource(
+                self.register_arbitrary_component(
                     type_id,
                     ComponentDescriptor::new_non_send::<T>(StorageType::default()),
-                    move |registrator, id, descriptor| {
+                    |registrator, id, descriptor| {
                         // SAFETY: We just checked that this is not currently registered or queued, and if it was registered since, this would have been dropped from the queue.
                         // SAFETY: Id uniqueness handled by caller, and the type_id matches descriptor.
                         #[expect(unused_unsafe, reason = "More precise to specify.")]
                         unsafe {
-                            registrator
-                                .components
-                                .register_non_send_unchecked(type_id, id, descriptor);
+                            registrator.components.register_non_send_unchecked(
+                                descriptor.type_id().unwrap(),
+                                id,
+                                descriptor,
+                            );
                         }
                     },
                 )
diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index f88d924e76b20..8834eee6b057a 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -1260,10 +1260,7 @@ mod tests {
         assert!(!world.is_resource_changed::<Num>());
 
         world.insert_resource(Num(123));
-        let resource_id = world
-            .components()
-            .get_resource_id(TypeId::of::<Num>())
-            .unwrap();
+        let resource_id = world.components().get_id(TypeId::of::<Num>()).unwrap();
 
         assert_eq!(world.resource::<Num>().0, 123);
         assert!(world.contains_resource::<Num>());
@@ -1317,10 +1314,7 @@ mod tests {
             "other resources are unaffected"
         );
 
-        let current_resource_id = world
-            .components()
-            .get_resource_id(TypeId::of::<Num>())
-            .unwrap();
+        let current_resource_id = world.components().get_id(TypeId::of::<Num>()).unwrap();
         assert_eq!(
             resource_id, current_resource_id,
             "resource id does not change after removing / re-adding"
diff --git a/crates/bevy_ecs/src/query/mod.rs b/crates/bevy_ecs/src/query/mod.rs
index 1c4474b5f6978..17ef51cbf046f 100644
--- a/crates/bevy_ecs/src/query/mod.rs
+++ b/crates/bevy_ecs/src/query/mod.rs
@@ -872,7 +872,7 @@ mod tests {
         }
 
         fn get_state(components: &Components) -> Option<Self::State> {
-            components.resource_id::<R>()
+            components.component_id::<R>()
         }
 
         fn matches_component_set(
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index 8c483c5c8ab9a..840b00251aca0 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -1198,10 +1198,7 @@ mod tests {
         let y_access = y.initialize(&mut world);
 
         let conflicts = x_access.get_conflicts(&y_access);
-        let b_id = world
-            .components()
-            .get_resource_id(TypeId::of::<ResB>())
-            .unwrap();
+        let b_id = world.components().get_id(TypeId::of::<ResB>()).unwrap();
         let d_id = world.components().get_id(TypeId::of::<D>()).unwrap();
         assert_eq!(conflicts, vec![b_id, d_id].into());
     }
diff --git a/crates/bevy_ecs/src/world/filtered_resource.rs b/crates/bevy_ecs/src/world/filtered_resource.rs
index 164777fe235c7..241df0012734a 100644
--- a/crates/bevy_ecs/src/world/filtered_resource.rs
+++ b/crates/bevy_ecs/src/world/filtered_resource.rs
@@ -148,7 +148,7 @@ impl<'w, 's> FilteredResources<'w, 's> {
     /// Returns `true` if the `FilteredResources` has access to the given resource.
     /// Note that [`Self::get()`] may still return `Err` if the resource does not exist.
     pub fn has_read<R: Resource>(&self) -> bool {
-        let component_id = self.world.components().resource_id::<R>();
+        let component_id = self.world.components().component_id::<R>();
         component_id.is_some_and(|component_id| self.access.has_resource_read(component_id))
     }
 
@@ -157,7 +157,7 @@ impl<'w, 's> FilteredResources<'w, 's> {
         let component_id = self
             .world
             .components()
-            .valid_resource_id::<R>()
+            .valid_component_id::<R>()
             .ok_or(ResourceFetchError::NotRegistered)?;
         if !self.access.has_resource_read(component_id) {
             return Err(ResourceFetchError::NoResourceAccess(component_id));
@@ -416,14 +416,14 @@ impl<'w, 's> FilteredResourcesMut<'w, 's> {
     /// Returns `true` if the `FilteredResources` has read access to the given resource.
     /// Note that [`Self::get()`] may still return `Err` if the resource does not exist.
     pub fn has_read<R: Resource>(&self) -> bool {
-        let component_id = self.world.components().resource_id::<R>();
+        let component_id = self.world.components().component_id::<R>();
         component_id.is_some_and(|component_id| self.access.has_resource_read(component_id))
     }
 
     /// Returns `true` if the `FilteredResources` has write access to the given resource.
     /// Note that [`Self::get_mut()`] may still return `Err` if the resource does not exist.
     pub fn has_write<R: Resource>(&self) -> bool {
-        let component_id = self.world.components().resource_id::<R>();
+        let component_id = self.world.components().component_id::<R>();
         component_id.is_some_and(|component_id| self.access.has_resource_write(component_id))
     }
 
@@ -474,7 +474,7 @@ impl<'w, 's> FilteredResourcesMut<'w, 's> {
         let component_id = self
             .world
             .components()
-            .valid_resource_id::<R>()
+            .valid_component_id::<R>()
             .ok_or(ResourceFetchError::NotRegistered)?;
         // SAFETY: THe caller ensures that there are no conflicting borrows.
         unsafe { self.get_mut_by_id_unchecked(component_id) }
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index 568bbc0bd35f5..fe77d91000825 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -661,8 +661,9 @@ impl World {
     ///
     /// Returns [`None`] if the [`Resource`] type has not yet been initialized within the
     /// [`World`] using [`World::register_resource`], [`World::init_resource`] or [`World::insert_resource`].
+    #[deprecated(since = "0.19.0", note = "use component_id")]
     pub fn resource_id<T: Resource>(&self) -> Option<ComponentId> {
-        self.components.get_resource_id(TypeId::of::<T>())
+        self.components.get_id(TypeId::of::<T>())
     }
 
     /// Returns [`EntityRef`]s that expose read-only operations for the given
@@ -1993,7 +1994,7 @@ impl World {
     /// Removes the resource of a given type and returns it, if it exists. Otherwise returns `None`.
     #[inline]
     pub fn remove_resource<R: Resource>(&mut self) -> Option<R> {
-        let resource_id = self.resource_id::<R>()?;
+        let resource_id = self.component_id::<R>()?;
         let entity = *self.resource_entities.get(resource_id)?;
         let value = self
             .get_entity_mut(entity)
@@ -2021,7 +2022,7 @@ impl World {
     /// thread than where the value was inserted from.
     #[inline]
     pub fn remove_non_send<R: 'static>(&mut self) -> Option<R> {
-        let component_id = self.components.get_valid_resource_id(TypeId::of::<R>())?;
+        let component_id = self.components.get_valid_id(TypeId::of::<R>())?;
         let (ptr, _, _) = self.storages.non_sends.get_mut(component_id)?.remove()?;
         // SAFETY: `component_id` was gotten via looking up the `R` type
         unsafe { Some(ptr.read::<R>()) }
@@ -2031,7 +2032,7 @@ impl World {
     #[inline]
     pub fn contains_resource<R: Resource>(&self) -> bool {
         self.components
-            .get_valid_resource_id(TypeId::of::<R>())
+            .get_valid_id(TypeId::of::<R>())
             .is_some_and(|component_id| self.contains_resource_by_id(component_id))
     }
 
@@ -2050,7 +2051,7 @@ impl World {
     #[inline]
     pub fn contains_non_send<R: 'static>(&self) -> bool {
         self.components
-            .get_valid_resource_id(TypeId::of::<R>())
+            .get_valid_id(TypeId::of::<R>())
             .and_then(|component_id| self.storages.non_sends.get(component_id))
             .is_some_and(NonSendData::is_present)
     }
@@ -2073,7 +2074,7 @@ impl World {
     ///   was called.
     pub fn is_resource_added<R: Resource>(&self) -> bool {
         self.components
-            .get_valid_resource_id(TypeId::of::<R>())
+            .get_valid_id(TypeId::of::<R>())
             .is_some_and(|component_id| self.is_resource_added_by_id(component_id))
     }
 
@@ -2098,7 +2099,7 @@ impl World {
     ///   was called.
     pub fn is_resource_changed<R: Resource>(&self) -> bool {
         self.components
-            .get_valid_resource_id(TypeId::of::<R>())
+            .get_valid_id(TypeId::of::<R>())
             .is_some_and(|component_id| self.is_resource_changed_by_id(component_id))
     }
 
@@ -2117,7 +2118,7 @@ impl World {
     /// Retrieves the change ticks for the given resource.
     pub fn get_resource_change_ticks<R: Resource>(&self) -> Option<ComponentTicks> {
         self.components
-            .get_valid_resource_id(TypeId::of::<R>())
+            .get_valid_id(TypeId::of::<R>())
             .and_then(|component_id| self.get_resource_change_ticks_by_id(component_id))
     }
 
@@ -2779,7 +2780,7 @@ impl World {
         let last_change_tick = self.last_change_tick();
         let change_tick = self.change_tick();
 
-        let component_id = self.components.valid_resource_id::<R>()?;
+        let component_id = self.components.valid_component_id::<R>()?;
         let entity = *self.resource_entities.get(component_id)?;
         let mut entity_mut = self.get_entity_mut(entity).ok()?;
 
@@ -4084,7 +4085,7 @@ mod tests {
         world.insert_resource(TestResource(42));
         let component_id = world
             .components()
-            .get_valid_resource_id(TypeId::of::<TestResource>())
+            .get_valid_id(TypeId::of::<TestResource>())
             .unwrap();
 
         let resource = world.get_resource_by_id(component_id).unwrap();
@@ -4100,7 +4101,7 @@ mod tests {
         world.insert_resource(TestResource(42));
         let component_id = world
             .components()
-            .get_valid_resource_id(TypeId::of::<TestResource>())
+            .get_valid_id(TypeId::of::<TestResource>())
             .unwrap();
 
         {
diff --git a/crates/bevy_ecs/src/world/unsafe_world_cell.rs b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
index cddafc0cb721d..5438579c842b9 100644
--- a/crates/bevy_ecs/src/world/unsafe_world_cell.rs
+++ b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
@@ -416,7 +416,7 @@ impl<'w> UnsafeWorldCell<'w> {
     /// - no mutable reference to the resource exists at the same time
     #[inline]
     pub unsafe fn get_resource<R: Resource>(self) -> Option<&'w R> {
-        let component_id = self.components().get_valid_resource_id(TypeId::of::<R>())?;
+        let component_id = self.components().get_valid_id(TypeId::of::<R>())?;
         // SAFETY: caller ensures `self` has permission to access the resource
         //  caller also ensure that no mutable reference to the resource exists
         unsafe {
@@ -434,7 +434,7 @@ impl<'w> UnsafeWorldCell<'w> {
     /// - no mutable reference to the resource exists at the same time
     #[inline]
     pub unsafe fn get_resource_ref<R: Resource>(self) -> Option<Ref<'w, R>> {
-        let component_id = self.components().get_valid_resource_id(TypeId::of::<R>())?;
+        let component_id = self.components().get_valid_id(TypeId::of::<R>())?;
 
         // SAFETY: caller ensures `self` has permission to access the resource
         // caller also ensures that no mutable reference to the resource exists
@@ -489,7 +489,7 @@ impl<'w> UnsafeWorldCell<'w> {
     /// - no mutable reference to the data exists at the same time
     #[inline]
     pub unsafe fn get_non_send<R: 'static>(self) -> Option<&'w R> {
-        let component_id = self.components().get_valid_resource_id(TypeId::of::<R>())?;
+        let component_id = self.components().get_valid_id(TypeId::of::<R>())?;
         // SAFETY: caller ensures that `self` has permission to access `R`
         //  caller ensures that no mutable reference exists to `R`
         unsafe {
@@ -545,7 +545,7 @@ impl<'w> UnsafeWorldCell<'w> {
     #[inline]
     pub unsafe fn get_resource_mut<R: Resource>(self) -> Option<Mut<'w, R>> {
         self.assert_allows_mutable_access();
-        let component_id = self.components().get_valid_resource_id(TypeId::of::<R>())?;
+        let component_id = self.components().get_valid_id(TypeId::of::<R>())?;
         // SAFETY:
         // - caller ensures `self` has permission to access the resource mutably
         // - caller ensures no other references to the resource exist
@@ -599,7 +599,7 @@ impl<'w> UnsafeWorldCell<'w> {
     #[inline]
     pub unsafe fn get_non_send_mut<R: 'static>(self) -> Option<Mut<'w, R>> {
         self.assert_allows_mutable_access();
-        let component_id = self.components().get_valid_resource_id(TypeId::of::<R>())?;
+        let component_id = self.components().get_valid_id(TypeId::of::<R>())?;
         // SAFETY:
         // - caller ensures that `self` has permission to access the data
         // - caller ensures that the data is unaliased
diff --git a/crates/bevy_remote/src/builtin_methods.rs b/crates/bevy_remote/src/builtin_methods.rs
index d047d2102b0a2..4a8df4e84887a 100644
--- a/crates/bevy_remote/src/builtin_methods.rs
+++ b/crates/bevy_remote/src/builtin_methods.rs
@@ -1059,7 +1059,7 @@ pub fn process_remote_insert_resources_request(
     let type_id = resource_registration.type_id();
     let resource_id = world
         .components()
-        .get_resource_id(type_id)
+        .get_id(type_id)
         .ok_or(anyhow!("Resource is not registered: `{}`", resource_path))
         .map_err(BrpError::resource_error)?;
     world.insert_reflect_resource(resource_id, reflected_resource);
@@ -1688,7 +1688,7 @@ fn get_resource_entity_pair(
     let type_id = resource_registration.type_id();
     let component_id = world
         .components()
-        .get_resource_id(type_id)
+        .get_id(type_id)
         .ok_or(anyhow!("Resource not registered: `{}`", resource_path))?;
     let entity = world
         .resource_entities()
diff --git a/crates/bevy_scene/src/dynamic_scene_builder.rs b/crates/bevy_scene/src/dynamic_scene_builder.rs
index 7b159da5d3db5..70db074cf61ce 100644
--- a/crates/bevy_scene/src/dynamic_scene_builder.rs
+++ b/crates/bevy_scene/src/dynamic_scene_builder.rs
@@ -355,7 +355,7 @@ impl<'w> DynamicSceneBuilder<'w> {
         let original_world_dqf_id = self
             .original_world
             .components()
-            .get_valid_resource_id(TypeId::of::<DefaultQueryFilters>());
+            .get_valid_id(TypeId::of::<DefaultQueryFilters>());
 
         let type_registry = self.original_world.resource::<AppTypeRegistry>().read();
 
diff --git a/crates/bevy_scene/src/scene.rs b/crates/bevy_scene/src/scene.rs
index 591fe60f03f9b..c4cde1ad37c4b 100644
--- a/crates/bevy_scene/src/scene.rs
+++ b/crates/bevy_scene/src/scene.rs
@@ -69,7 +69,7 @@ impl Scene {
         let self_dqf_id = self
             .world
             .components()
-            .get_resource_id(TypeId::of::<DefaultQueryFilters>());
+            .get_id(TypeId::of::<DefaultQueryFilters>());
 
         // Resources archetype
         for (component_id, source_entity) in self.world.resource_entities().iter() {
diff --git a/release-content/migration-guides/resources_as_components.md b/release-content/migration-guides/resources_as_components.md
index fa84c09b2dd7f..023d7be0ec0dc 100644
--- a/release-content/migration-guides/resources_as_components.md
+++ b/release-content/migration-guides/resources_as_components.md
@@ -65,10 +65,16 @@ Before using components and resources they must be registered to a world.
 The registration process for components and resources is very similar and now that `Send` resources *are* components, we're able to simplify some of the code; removing / deprecating some methods.
 
 - `Components::register_resource_unchecked` is renamed to `Components::register_non_send_unchecked`.
+- `Components::get_valid_resource_id` was deprecated in favor of `Components::get_valid_id`.
+- `Components::valid_resource_id` was deprecated in favor of `Components::valid_component_id`.
+- `Components::resource_id` was deprecated in favor of `Components::component_id`.
 - `ComponentsRegistrator::register_resource` is deprecated in favor of `ComponentsRegistrator::register_component`.
 - `ComponentsRegistrator::register_resource_with` is renamed to `ComponentsRegistrator::register_non_send_with`.
 - `ComponentsRegistrator::register_resource_with_descriptor` is removed in favor of `ComponentsRegistrator::register_component_with_descriptor`.
 - `ComponentsQueuedRegistrator::queue_register_resource_with_descriptor` was removed in favor of `ComponentsQueuedRegistrator::queue_register_component_with_descriptor`.
+- `ComponentsQueuedRegistrator::queue_register_resource` was deprecated in favor of `ComponentsQueuedRegistrator::queue_register_component`.
+- `ComponentDescriptor::new_resource` was deprecated in favor of `ComponentDescriptor::new`
+- `ComponentDescriptor::new_resource` was deprecated in favor of `ComponentDescriptor::new`
 - `World::register_resource_with_descriptor was renamed to World::register_non_send_with_descriptor`.
 
 ## Miscellaneous
