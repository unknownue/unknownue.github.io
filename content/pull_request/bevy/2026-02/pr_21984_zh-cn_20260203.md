+++
title = "#21984 Contiguous access"
date = "2026-02-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-21984-en-20260203" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-21984-zh-cn-20260203" }}
+++

# 标题

## 基本信息
- **标题**: Contiguous access
- **PR链接**: https://github.com/bevyengine/bevy/pull/21984
- **作者**: Jenya705
- **状态**: 已合并 (MERGED)
- **标签**: C-Feature, A-ECS, C-Performance, S-Ready-For-Final-Review, D-Complex, M-Release-Note, D-Unsafe
- **创建时间**: 2025-11-30T15:04:09Z
- **合并时间**: 2026-02-03T00:45:33Z
- **合并者**: alice-i-cecile

## 描述翻译

### 目标
使查询 (Query) 能够直接从表中访问切片 (slice)。

修复: #21861

### 解决方案
引入一个新的 trait：
- `ContiguousQueryData` 允许一次性从表中获取所有值（`&T` 的实现返回对应表中组件的切片，`&mut T` 的实现返回对应表中组件的可变切片，以及一个包含用于设置更新 tick 方法的结构体（以匹配 `fetch` 的实现））。

在 `Query` 和 `QueryState` 中添加了方法 `contiguous_iter`、`contiguous_iter_mut` 及类似方法，使得使用这些 trait 进行迭代成为可能。

更新了宏 `QueryData`，使其在添加了 `contiguous(target)` 属性时支持连续项（目标可以是 `all`、`mutable` 和 `immutable`，参考 `custom_query_param` 示例）。

### 测试
- `sparse_set_contiguous_query` 测试验证了不能对稀疏集组件使用 `next_contiguous`
- `test_contiguous_query_data` 测试验证返回的值是有效的
- `base_contiguous` 基准测试（文件名为 `iter_simple_contiguous.rs`）
- `base_no_detection` 基准测试（文件名为 `iter_simple_no_detection.rs`）
- `base_no_detection_contiguous` 基准测试（文件名为 `iter_simple_no_detection_contiguous.rs`）
- `base_contiguous_avx2` 基准测试（文件名为 `iter_simple_contiguous_avx2.rs`）

---

### 展示
示例 `contiguous_query`、`custom_query_param`

### 示例
```rust
// - self.0 是一个 World
// - self.1 是一个 QueryState
// - velocity 是一个包含 Vec3 的组件切片。
// - position 是一个实现了 Deref/DerefMut 和 IntoIterator 方法以访问切片以及自动在解引用时更新 update ticks 的数据结构，可以通过 `bypass_change_detection` 方法绕过更新。
for (velocity, mut position) in self.1.contiguous_iter_mut(&mut self.0).unwrap() {
    assert!(velocity.len() == position.len());
    for (v, p) in velocity.iter().zip(position.iter_mut()) {
        p.0 += v.0;
    }
}
```

### 基准测试
`base` 基准测试的代码：
```rust
#[derive(Component, Copy, Clone)]
struct Transform(Mat4);

#[derive(Component, Copy, Clone)]
struct Position(Vec3);

#[derive(Component, Copy, Clone)]
struct Rotation(Vec3);

#[derive(Component, Copy, Clone)]
struct Velocity(Vec3);

pub struct Benchmark<'w>(World, QueryState<(&'w Velocity, &'w mut Position)>);

impl<'w> Benchmark<'w> {
    pub fn new() -> Self {
        let mut world = World::new();

        world.spawn_batch(core::iter::repeat_n(
            (
                Transform(Mat4::from_scale(Vec3::ONE)),
                Position(Vec3::X),
                Rotation(Vec3::X),
                Velocity(Vec3::X),
            ),
            10_000,
        ));

        let query = world.query::<(&Velocity, &mut Position)>();
        Self(world, query)
    }

    #[inline(never)]
    pub fn run(&mut self) {
        for (velocity, mut position) in self.1.iter_mut(&mut self.0) {
            position.0 += velocity.0;
        }
    }
}
```
迭代 10000 个来自**单个**表的实体，并将组件 `Position` 中的 3 维向量增加组件 `Velocity` 中的 3 维向量。

| 名称                          | 时间        | 时间 (AVX2) | 描述                                                                     |
|-------------------------------|-------------|-------------|-------------------------------------------------------------------------|
| base                          | 5.5828 µs   | 5.5122 µs   | 按组件迭代                                                               |
| base_contiguous               | 4.8825 µs   | 1.8665 µs   | 按连续块迭代                                                             |
| base_contiguous_avx2          | 2.0740 µs   | 1.8665 µs   | 使用强制 avx2 优化的连续块迭代                                             |
| base_no_detection             | 4.8065 µs   | 4.7723 µs   | 通过 `bypass_change_detection()` 方法绕过变更检测的组件迭代              |
| base_no_detection_contiguous  | 4.3979 µs   | 1.5797 µs   | 不注册更新 ticks 的组件迭代                                              |

使用连续 '迭代器' 使程序稍微快一些，并且可以进一步向量化以使其更快。

## 这个 Pull Request 的故事

### 问题与背景
Bevy 的 ECS（实体组件系统）查询系统允许开发者高效地迭代具有特定组件组合的实体。标准的查询迭代器（`iter` 和 `iter_mut`）会逐个实体地返回组件引用。然而，在典型的表格存储中，属于同一个表的所有实体的组件数据在内存中是连续存储的。这意味着，对于需要在大量实体上执行相同操作的系统（例如，对所有具有 `Velocity` 和 `Position` 的实体应用速度更新），标准迭代器会为每个实体进行一次索引和边界检查，这会带来开销，并且阻止了编译器进行有效的 SIMD（单指令多数据）向量化优化。

PR #21984 的目标正是为了解决这个问题。开发者希望提供一个方法，能够直接访问表中连续存储的组件切片，从而：
1. 减少迭代开销（每个表只需一次迭代，而不是每个实体一次）。
2. 为编译器提供机会进行自动向量化，或者允许开发者手动编写 SIMD 代码。
3. 在处理大批量相同类型实体的系统中，提供显著的性能提升。

### 解决方案与工程决策
实现此功能的核心是引入一个新的 trait `ContiguousQueryData`。这个 trait 扩展了现有的 `QueryData` 体系，它定义了一个方法 `fetch_contiguous`，用于从当前设置的表中获取一个代表连续内存块的数据结构（例如，切片）。

关键的设计决策和实现策略包括：

1. **新的 Trait 和数据结构**：
   - 定义了 `ContiguousQueryData` trait，其关联类型 `Contiguous<'w, 's>` 表示连续访问的返回类型。
   - 为 `&T`、`&mut T`、`Ref<T>`、`Mut<T>` 等常见的查询项类型实现了 `ContiguousQueryData`。例如：
     - `&T` 返回 `&[T]`
     - `&mut T` 返回 `ContiguousMut<'w, T>`（一个新的包装器，包含可变切片 `&mut [T]` 和用于管理变更检测的 ticks）。
   - 引入了新的数据结构 `ContiguousRef`、`ContiguousMut`、`ContiguousComponentTicksRef` 和 `ContiguousComponentTicksMut` 来封装连续访问的组件数据和对应的变更 tick 信息。这些结构体提供了将数据切片与 tick 切片分离的方法（例如 `ContiguousMut::split`），以便在需要检查变更状态时使用。

2. **迭代器基础设施**：
   - 在 `Query` 和 `QueryState` 中添加了 `contiguous_iter` 和 `contiguous_iter_mut` 方法，它们返回一个新的迭代器类型 `QueryContiguousIter`。
   - `QueryContiguousIter` 的 `next` 方法会跳过整个表，每次调用返回一个 `ContiguousQueryData::Contiguous` 项（例如，一个包含整个表所有 `Velocity` 组件的切片）。这要求查询的过滤器（Filter）必须实现 `ArchetypeFilter`（例如 `With`、`Without`），以确保过滤器可以在表级别进行评估，而不是在实体级别。像 `Changed<T>` 这样的过滤器无法实现 `ArchetypeFilter`，因此无法用于连续迭代。

3. **宏的扩展**：
   - 更新了 `QueryData` 派生宏，使其支持新的 `contiguous(target)` 属性。开发者可以在自定义查询数据结构上添加此属性（例如 `#[query_data(mutable, contiguous(all))]`），宏将自动为其生成实现 `ContiguousQueryData` 所需的代码，并生成对应的 `ContiguousItem` 类型。这是使自定义查询能够利用连续迭代功能的关键。

4. **底层内存访问**：
   - 为了安全地处理底层的内存切片，扩展了 `bevy_ptr` 中的 `ThinSlicePtr` 类型，增加了 `as_slice_unchecked`、`as_mut_slice_unchecked` 和 `cast` 方法。这些方法在 `UnsafeCell` 包装的类型之间进行转换，并假设调用者已经确保了所有的安全条件（如正确的长度和独占访问权限）。

### 实现细节与代码示例
我们来看几个关键文件的具体修改，它们共同构成了这个功能。

首先，`ContiguousQueryData` trait 在 `crates/bevy_ecs/src/query/fetch.rs` 中被定义和实现：
```rust
pub trait ContiguousQueryData: ArchetypeQueryData {
    type Contiguous<'w, 's>;
    unsafe fn fetch_contiguous<'w, 's>(
        state: &'s Self::State,
        fetch: &mut Self::Fetch<'w>,
        entities: &'w [Entity],
    ) -> Self::Contiguous<'w, 's>;
}

impl<T: Component> ContiguousQueryData for &T {
    type Contiguous<'w, 's> = &'w [T];
    unsafe fn fetch_contiguous<'w, 's>(...) -> Self::Contiguous<'w, 's> {
        // 从表中提取连续切片
        fetch.components.extract(
            |table| {
                unsafe { table.cast().as_slice_unchecked(entities.len()) }
            },
            |_| { ... },
        )
    }
}
```

`ContiguousMut` 结构体在 `crates/bevy_ecs/src/change_detection/params.rs` 中定义，它包装了组件值切片和 tick 信息，并提供了便捷的访问和变更检测绕过方法：
```rust
pub struct ContiguousMut<'w, T> {
    pub(crate) value: &'w mut [T],
    pub(crate) ticks: ContiguousComponentTicksMut<'w>,
}
impl<'w, T> ContiguousMut<'w, T> {
    pub fn bypass_change_detection(&mut self) -> &mut [T] {
        self.value
    }
    pub fn split(mut this: Self) -> (&'w mut [T], ContiguousComponentTicksMut<'w>) {
        this.mark_all_as_changed();
        (this.value, this.ticks)
    }
}
```

新的迭代器 `QueryContiguousIter` 在 `crates/bevy_ecs/src/query/iter.rs` 中实现。它的核心逻辑是遍历所有匹配的表，并对每个表调用 `fetch_contiguous`：
```rust
pub struct QueryContiguousIter<'w, 's, D: ContiguousQueryData, F: ArchetypeFilter> { ... }
impl<'w, 's, D: ContiguousQueryData, F: ArchetypeFilter> Iterator for QueryContiguousIter<'w, 's, D, F> {
    type Item = D::Contiguous<'w, 's>;
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let table_id = unsafe { self.storage_id_iter.next()?.table_id };
            let table = unsafe { self.tables.get(table_id).debug_checked_unwrap() };
            if table.is_empty() { continue; }
            unsafe { D::set_table(&mut self.fetch, &self.query_state.fetch_state, table); };
            let item = unsafe {
                D::fetch_contiguous(
                    &self.query_state.fetch_state,
                    &mut self.fetch,
                    table.entities(),
                )
            };
            return Some(item);
        }
    }
}
```

### 技术洞见与性能考虑
这个实现充分利用了 ECS 数据布局的特性。当一个查询只涉及存储在表中的组件（即“密集”组件）并且过滤器是表级别（`ArchetypeFilter`）时，所有匹配的实体在内存中是连续的。`QueryContiguousIter` 正是针对这种场景进行了优化，它将迭代粒度从实体提升到了表。

性能基准测试结果清晰地展示了这种优化的价值：
- **`base_contiguous` vs `base`**：即使没有显式的 SIMD，连续迭代也带来了约 12% 的性能提升（从 5.58 µs 到 4.88 µs），这主要归功于减少了循环和边界检查的开销。
- **`base_contiguous_avx2`**：当使用 AVX2 指令集手动向量化后，性能提升达到了约 66% （从 5.51 µs 到 1.87 µs）。这证明了连续内存访问为利用现代 CPU 的 SIMD 能力打开了大门。
- **变更检测的开销**：对比 `base_no_detection` 和 `base_no_detection_contiguous` 可以看出，即使绕过变更检测，连续迭代仍然更快。而 `base_no_detection_contiguous` 结合 AVX2 后达到了最快的 1.58 µs，这显示了在不需要变更检测的场景下，连续迭代结合 SIMD 的巨大潜力。

需要注意的是，这个功能引入了一些 `unsafe` 代码，主要用于直接操作内存切片和转换指针类型。这些 `unsafe` 块的正确性依赖于调用者（如 `QueryContiguousIter`）确保满足前置条件，例如在调用 `fetch_contiguous` 之前必须正确设置表（`set_table`），并且提供的实体切片长度与表的行数匹配。

### 影响与总结
PR #21984 为 Bevy ECS 引入了一个强大的性能优化工具。它允许系统开发者在处理大量同类实体时，选择更高效的迭代模式。这个功能是向后兼容的，现有的查询代码无需修改。只有当开发者明确需要性能提升，并且他们的查询符合连续迭代的条件（密集组件、表级别过滤器）时，他们才需要将 `iter()` 调用替换为 `contiguous_iter()`。

从更广泛的角度看，这个 PR 体现了高性能游戏引擎中常见的优化模式：利用数据局部性（data locality）和批量处理（batching）来减少开销并启用硬件加速。它为未来更高级的优化（如基于查询的自动向量化）奠定了基础。

主要的经验教训包括：
1. 在设计 ECS 这样的核心系统时，考虑提供不同粒度的数据访问接口（实体级 vs 表级）是很有价值的。
2. 宏（macro）在生成复杂 trait 实现和减少样板代码方面非常强大。`QueryData` 宏的扩展使得添加新功能（如 `contiguous`）对最终用户非常友好。
3. 性能优化往往需要深入底层，但可以通过精心设计的安全抽象（如 `ContiguousMut`）将其封装起来，为上层提供相对安全的 API。

## 视觉表示

```mermaid
graph TD
    subgraph "用户API层"
        Q[Query] --> CI[contiguous_iter]
        Q --> CIM[contiguous_iter_mut]
        CI --> QCI[QueryContiguousIter]
        CIM --> QCI
    end

    subgraph "Trait与实现层"
        CQD[ContiguousQueryData] --> |为 &T 实现| ImplRef[返回 &[T]]
        CQD --> |为 &mut T 实现| ImplMut[返回 ContiguousMut<T>]
        CQD --> |为自定义 QueryData 实现| MacroGen[由宏生成实现]
    end

    subgraph "数据结构层"
        ContiguousMut --> |包含| Slice[&mut [T]]
        ContiguousMut --> |包含| Ticks[ContiguousComponentTicksMut]
        ContiguousComponentTicksMut --> |管理| AddedTicks[added: &mut [Tick]]
        ContiguousComponentTicksMut --> |管理| ChangedTicks[changed: &mut [Tick]]
    end

    subgraph "底层存储"
        Table[Table] --> |存储| CompData[连续组件数据]
        Table --> |存储| TickData[连续Tick数据]
    end

    QCI --> |遍历| Table
    QCI --> |调用| CQD
    ImplRef --> |访问| CompData
    ImplMut --> |访问| CompData
    ImplMut --> |访问| TickData
    Slice --> |指向| CompData
    Ticks --> |指向| TickData
```

## 关键文件变更

### 1. `crates/bevy_ecs/src/change_detection/params.rs` (+705/-1)
这个文件是变更检测模块的核心，主要添加了支持连续访问的新数据结构。
- **做了什么**：引入了 `ContiguousRef`、`ContiguousMut`、`ContiguousComponentTicksRef` 和 `ContiguousComponentTicksMut`。这些结构体用于封装连续组件切片及其对应的变更 tick 信息。
- **为什么重要**：它们是为 `&T` 和 `&mut T` 实现 `ContiguousQueryData` 时返回的具体类型，提供了将数据与 tick 分离、绕过变更检测、批量标记变更等实用方法。
- **关键代码片段**：
```rust
pub struct ContiguousMut<'w, T> {
    pub(crate) value: &'w mut [T],
    pub(crate) ticks: ContiguousComponentTicksMut<'w>,
}
impl<'w, T> ContiguousMut<'w, T> {
    pub fn bypass_change_detection(&mut self) -> &mut [T] {
        self.value
    }
    pub fn split(mut this: Self) -> (&'w mut [T], ContiguousComponentTicksMut<'w>) {
        this.mark_all_as_changed();
        (this.value, this.ticks)
    }
}
```

### 2. `crates/bevy_ecs/src/query/fetch.rs` (+467/-9)
这个文件定义了查询获取数据相关的 trait 和实现。
- **做了什么**：
  1. 定义了新的 `ContiguousQueryData` trait。
  2. 为 `Entity`、`&T`、`&mut T`、`Ref<T>`、`Mut<T>`、`Option<T>`、`Has<T>`、`AnyOf<T>` 以及所有元组类型实现了 `ContiguousQueryData`。
  3. 添加了相应的单元测试。
- **为什么重要**：这是连续访问功能的核心定义。每个查询项类型（如 `&T`）都需要实现这个 trait 才能参与连续迭代。实现决定了如何从表中提取连续切片。
- **关键代码片段** (为 `&T` 的实现)：
```rust
impl<T: Component> ContiguousQueryData for &T {
    type Contiguous<'w, 's> = &'w [T];
    unsafe fn fetch_contiguous<'w, 's>(
        _state: &'s Self::State,
        fetch: &mut Self::Fetch<'w>,
        entities: &'w [Entity],
    ) -> Self::Contiguous<'w, 's> {
        fetch.components.extract(
            |table| {
                unsafe { table.cast().as_slice_unchecked(entities.len()) }
            },
            |_| { ... },
        )
    }
}
```

### 3. `crates/bevy_ecs/macros/src/query_data.rs` (+204/-3)
这是 `QueryData` 派生宏的实现。
- **做了什么**：
  1. 扩展了宏以识别新的 `contiguous(target)` 属性（`target` 可以是 `all`, `mutable`, `immutable`）。
  2. 根据属性为自定义查询数据结构生成对应的 `ContiguousItem` 类型和 `ContiguousQueryData` trait 的实现。
- **为什么重要**：它使得开发者能够通过简单的属性标注，就让自己定义的查询数据结构支持连续迭代，极大地简化了使用。
- **关键代码片段** (处理 `contiguous` 属性的部分)：
```rust
// 在 derive_query_data_impl 函数中
} else if meta.path.is_ident(CONTIGUOUS_ATTRIBUTE_NAME) {
    meta.parse_nested_meta(|meta| {
        if meta.path.is_ident("all") {
            attributes.is_contiguous_mutable = true;
            attributes.is_contiguous_immutable = true;
            Ok(())
        } else if meta.path.is_ident("mutable") {
            attributes.is_contiguous_mutable = true;
            Ok(())
        } else if meta.path.is_ident("immutable") {
            attributes.is_contiguous_immutable = true;
            Ok(())
        } else {
            Err(meta.error("invalid target, expected `all`, `mutable` or `immutable`"))
        }
    })
```

### 4. `crates/bevy_ecs/src/system/query.rs` (+100/-2)
这个文件包含了 `Query` 系统参数类型的实现。
- **做了什么**：为 `Query` 类型添加了新的方法 `contiguous_iter`、`contiguous_iter_mut` 和 `contiguous_iter_inner`。
- **为什么重要**：这是面向用户的 API 入口。系统开发者通过这些方法来获取连续迭代器。
- **关键代码片段**：
```rust
impl<'w, 's, D: QueryData, F: QueryFilter> Query<'w, 's, D, F> {
    pub fn contiguous_iter(&self) -> Option<QueryContiguousIter<'_, 's, D::ReadOnly, F>>
    where
        D::ReadOnly: ContiguousQueryData,
        F: ArchetypeFilter,
    {
        self.as_readonly().contiguous_iter_inner().ok()
    }
    pub fn contiguous_iter_mut(&mut self) -> Option<QueryContiguousIter<'_, 's, D, F>>
    where
        D: ContiguousQueryData,
        F: ArchetypeFilter,
    {
        self.reborrow().contiguous_iter_inner().ok()
    }
}
```

### 5. `crates/bevy_ecs/src/query/iter.rs` (+92/-2)
这个文件定义了各种查询迭代器。
- **做了什么**：引入了新的迭代器类型 `QueryContiguousIter`，并实现了其 `Iterator` trait。
- **为什么重要**：这是连续迭代的执行引擎。它负责遍历所有匹配的表，并对每个表调用 `fetch_contiguous`。
- **关键代码片段** (`QueryContiguousIter::next` 方法的核心部分)：
```rust
fn next(&mut self) -> Option<Self::Item> {
    loop {
        let table_id = unsafe { self.storage_id_iter.next()?.table_id };
        let table = unsafe { self.tables.get(table_id).debug_checked_unwrap() };
        if table.is_empty() { continue; }
        unsafe { D::set_table(&mut self.fetch, &self.query_state.fetch_state, table); };
        let item = unsafe {
            D::fetch_contiguous(
                &self.query_state.fetch_state,
                &mut self.fetch,
                table.entities(),
            )
        };
        return Some(item);
    }
}
```

## 扩展阅读
对于想要深入了解此 PR 中涉及的概念和技术的读者，建议参考以下资源：

1. **Bevy 官方文档 - ECS 查询**：了解 Bevy ECS 查询系统的基础知识，包括 `Query`、`WorldQuery` trait 和变更检测。
2. **Rust 的 SIMD 编程**：学习如何使用 Rust 的 `core::arch` 模块编写显式的 SIMD 代码，以充分利用连续数据访问带来的性能优势。
3. **数据导向设计 (Data-Oriented Design)**：理解为什么连续内存布局和批量处理对游戏引擎性能至关重要。这本书/理念是许多现代 ECS 实现的基础。
4. **Bevy 源码中的其他迭代器**：研究 `QueryIter`、`QueryCombinationIter` 等迭代器的实现，以全面理解 Bevy ECS 迭代系统的设计模式。
5. **Issue #21861**：查看这个 PR 所解决的具体问题和讨论，了解功能需求的原始上下文。