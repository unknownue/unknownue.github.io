+++
title = "#22908 Fix Image pixel access error propagation for compressed formats"
date = "2026-02-12T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22908-en-20260212" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22908-zh-cn-20260212" }}
labels = ["C-Bug", "A-Rendering", "M-Migration-Guide"]
+++

# Title

## Basic Information
- **Title**: Fix Image pixel access error propagation for compressed formats
- **PR Link**: https://github.com/bevyengine/bevy/pull/22908
- **Author**: mirsella
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, S-Ready-For-Final-Review, M-Migration-Guide
- **Created**: 2026-02-11T14:07:34Z
- **Merged**: 2026-02-12T18:50:21Z
- **Merged By**: alice-i-cecile

## Description Translation

follow up to #22414

in my comment <https://github.com/bevyengine/bevy/pull/22414#issuecomment-2645849258> i realized the warn added in #22414 would never actually trigger because `pixel_bytes` and `pixel_bytes_mut` were returning `Option` instead of `Result`, which caused the `UnsupportedTextureFormat` error to be lost and converted to `OutOfBounds`.

this changes:
- `pixel_data_offset` now returns `Result` instead of `Option`
- `pixel_bytes` and `pixel_bytes_mut` now return `Result` instead of `Option`
- errors are properly propagated so the warn in sprite picking actually triggers for compressed textures
- added a regression test `compressed_texture_format_is_reported_correctly`
- updated `examples/2d/cpu_draw.rs` for the new signature

should i remove the regression test if it's useless ?

thanks

## The Story of This Pull Request

This PR addresses an error propagation issue in Bevy's image handling system, specifically related to how compressed texture formats report errors when accessed through pixel-level operations. The problem originated from a previous PR (#22414) that attempted to add warnings for unsupported texture formats but had a fundamental flaw in its implementation.

The core issue was in the `Image` struct's pixel access methods: `pixel_data_offset`, `pixel_bytes`, and `pixel_bytes_mut`. These methods were returning `Option<...>` instead of `Result<..., TextureAccessError>`, which meant that different types of errors were being collapsed into a single `None` value. Specifically, when trying to access pixels in compressed texture formats (like BC1, BC2, BC3, ETC2, etc.), the `UnsupportedTextureFormat` error was being lost and incorrectly reported as an `OutOfBounds` error.

This bug was particularly problematic because it prevented the warning system added in PR #22414 from working correctly. The warning was supposed to alert users when sprite picking operations encountered compressed textures (which don't support direct pixel access), but since the error type was being converted, the warning never triggered.

The developer's solution was straightforward but important: change the return types from `Option` to `Result<..., TextureAccessError>` and ensure proper error propagation throughout the call chain. This involved updating three key methods:

1. `pixel_data_offset` - Changed from returning `None` for out-of-bounds access to returning `Err(TextureAccessError::OutOfBounds{...})`
2. `pixel_bytes` and `pixel_bytes_mut` - Now properly propagate errors from both `pixel_data_offset` and the format's `pixel_size()` method, and also handle the case where image data is not initialized

The implementation shows good attention to error handling patterns. Instead of using `.ok()` to convert `Result` to `Option` (which discards error information), the code now uses the `?` operator to propagate errors while preserving their type. This allows callers to distinguish between different failure modes: out-of-bounds access, unsupported texture formats, and uninitialized image data.

An important addition was the new `TextureAccessError::Uninitialized` variant, which handles the case where `self.data` is `None`. Previously, this would return `None` from the `Option`, making it indistinguishable from other errors.

The changes also required updating the internal methods `get_color_at_internal` and `set_color_at_internal` to handle the new `Result` types. These methods now simply propagate errors using the `?` operator, which simplifies their logic and ensures consistent error reporting.

From an architectural perspective, this fix improves the API's clarity and correctness. By using `Result` instead of `Option`, the methods now explicitly communicate what can go wrong, allowing callers to handle different error cases appropriately. This is particularly important for a game engine like Bevy where texture handling is a common operation and developers need clear feedback when something goes wrong.

The PR includes a regression test `compressed_texture_format_is_reported_correctly` that verifies compressed textures correctly report `UnsupportedTextureFormat` errors. This test creates an image with the BC1RgbaUnorm format (a compressed format) and attempts to access pixels, ensuring the proper error is returned. The test also covers both read (`get_color_at`) and write (`set_color_at`) operations.

The migration guide added with this PR provides clear instructions for users who need to update their code. It explains the rationale for the change and shows before/after examples of how to handle the new `Result` return type.

This fix has minimal performance impact since it mainly changes error handling logic rather than adding new computations. The use of `#[inline(always)]` on these small methods helps ensure the error handling doesn't introduce significant overhead.

## Visual Representation

```mermaid
graph TD
    A[Caller: get_color_at/set_color_at] --> B[pixel_bytes/pixel_bytes_mut]
    B --> C[pixel_data_offset]
    C --> D{Check bounds}
    D -->|Out of bounds| E[Error::OutOfBounds]
    D -->|In bounds| F[Compute offset]
    B --> G[format.pixel_size()]
    G -->|Unsupported format| H[Error::UnsupportedTextureFormat]
    G -->|Supported format| I[Get pixel size]
    B --> J{data initialized?}
    J -->|No data| K[Error::Uninitialized]
    J -->|Has data| L[Return slice]
    
    style E fill:#f96
    style H fill:#f96
    style K fill:#f96
    style L fill:#6c6
```

## Key Files Changed

### `crates/bevy_image/src/image.rs` (+63/-32)

This file contains the core implementation changes for the `Image` struct's pixel access methods. The key modifications include:

1. **Return type changes from `Option` to `Result`**:
```rust
// Before:
pub fn pixel_data_offset(&self, coords: UVec3) -> Option<usize> {
    // ...
    if coords.x >= width || coords.y >= height || coords.z >= depth {
        return None;  // No error details
    }
    // ...
}

// After:
pub fn pixel_data_offset(&self, coords: UVec3) -> Result<usize, TextureAccessError> {
    // ...
    if coords.x >= width || coords.y >= height || coords.z >= depth {
        return Err(TextureAccessError::OutOfBounds {
            x: coords.x,
            y: coords.y,
            z: coords.z,
        });  // Detailed error
    }
    // ...
}
```

2. **Proper error propagation in pixel access methods**:
```rust
// Before:
pub fn pixel_bytes(&self, coords: UVec3) -> Option<&[u8]> {
    let len = self.texture_descriptor.format.pixel_size().ok()?;  // Error lost
    let data = self.data.as_ref()?;  // Error lost
    self.pixel_data_offset(coords)
        .map(|start| &data[start..(start + len)])
}

// After:
pub fn pixel_bytes(&self, coords: UVec3) -> Result<&[u8], TextureAccessError> {
    let len = self.texture_descriptor.format.pixel_size()?;  // Error preserved
    let start = self.pixel_data_offset(coords)?;  // Error preserved
    let Some(data) = self.data.as_ref() else {
        return Err(TextureAccessError::Uninitialized);  // Explicit error
    };
    Ok(&data[start..(start + len)])
}
```

3. **New error variant for uninitialized data**:
```rust
pub enum TextureAccessError {
    OutOfBounds { x: u32, y: u32, z: u32 },
    UnsupportedTextureFormat(TextureFormat),
    Uninitialized,  // New variant
    WrongDimension,
}
```

4. **Regression test for compressed texture error reporting**:
```rust
#[test]
fn compressed_texture_format_is_reported_correctly() {
    let mut image = Image::new_uninit(
        Extent3d { width: 4, height: 4, depth_or_array_layers: 1 },
        TextureDimension::D2,
        TextureFormat::Bc1RgbaUnorm,  // Compressed format
        RenderAssetUsages::MAIN_WORLD,
    );

    // Verify both read and write operations fail with correct error
    assert!(matches!(
        image.get_color_at(0, 0),
        Err(TextureAccessError::UnsupportedTextureFormat(
            TextureFormat::Bc1RgbaUnorm
        ))
    ));
}
```

### `release-content/migration-guides/image_pixel_bytes_result.md` (+48/-0)

This new file provides a migration guide for users updating their code to handle the new `Result` return types:

```markdown
---
title: "`Image::pixel_bytes` and `Image::pixel_data_offset` now return `Result`"
pull_requests: [22908]
---

`Image::pixel_bytes`, `Image::pixel_bytes_mut`, and
`Image::pixel_data_offset` now return `Result<..., TextureAccessError>`.

Previously, these methods returned `Option` and would silently fail for
both out-of-bounds access and unsupported texture formats (such as
compressed textures). This caused error information to be lost, making it
impossible for callers to distinguish between these different failure
cases.

Now, these methods properly propagate `TextureAccessError`:
- `TextureAccessError::OutOfBounds` for coordinates outside the image bounds
- `TextureAccessError::UnsupportedTextureFormat` for compressed or unsupported texture formats
- `TextureAccessError::Uninitialized` if the image data is not initialized

## Migration

Update any code using these methods to handle the `Result` return type:
```rust
// Before
if let Some(bytes) = image.pixel_bytes(coords) {
    // use bytes
}

// After
match image.pixel_bytes(coords) {
    Ok(bytes) => {
        // use bytes
    }
    Err(TextureAccessError::Uninitialized) => {
        // handle missing image data
    }
    Err(TextureAccessError::OutOfBounds { .. }) => {
        // handle out of bounds
    }
    Err(TextureAccessError::UnsupportedTextureFormat(format)) => {
        // handle compressed/unsupported format
    }
}
```
```

## Further Reading

- [Rust Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html) - Official Rust documentation on `Result` and error handling patterns
- [Bevy Texture Formats](https://docs.rs/bevy_render/latest/bevy_render/texture/enum.TextureFormat.html) - Documentation on Bevy's texture format support
- [Texture Compression](https://www.khronos.org/opengl/wiki/Texture_Compression) - Background on texture compression formats and their limitations
- [PR #22414](https://github.com/bevyengine/bevy/pull/22414) - The original PR that attempted to add warnings for compressed textures
- [Error Propagation in Rust](https://doc.rust-lang.org/rust-by-example/error/result/result_map.html) - Techniques for proper error propagation in Rust