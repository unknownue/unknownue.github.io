diff --git a/crates/bevy_sprite/src/text2d.rs b/crates/bevy_sprite/src/text2d.rs
index 1920adf81acb6..bf9eca6fbcd7d 100644
--- a/crates/bevy_sprite/src/text2d.rs
+++ b/crates/bevy_sprite/src/text2d.rs
@@ -173,7 +173,6 @@ pub fn update_text2d_layout(
     mut textures: ResMut<Assets<Image>>,
     fonts: Res<Assets<Font>>,
     camera_query: Query<(&Camera, &VisibleEntities, Option<&RenderLayers>)>,
-    mut texture_atlases: ResMut<Assets<TextureAtlasLayout>>,
     mut font_atlas_set: ResMut<FontAtlasSet>,
     mut text_pipeline: ResMut<TextPipeline>,
     mut text_query: Query<(
@@ -300,7 +299,6 @@ pub fn update_text2d_layout(
         match text_pipeline.update_text_layout_info(
             &mut text_layout_info,
             &mut font_atlas_set,
-            &mut texture_atlases,
             &mut textures,
             &mut computed,
             &mut scale_cx,
diff --git a/crates/bevy_sprite_render/src/text2d/mod.rs b/crates/bevy_sprite_render/src/text2d/mod.rs
index 14bde85b65ad4..b8e1a6d9aa0b6 100644
--- a/crates/bevy_sprite_render/src/text2d/mod.rs
+++ b/crates/bevy_sprite_render/src/text2d/mod.rs
@@ -1,15 +1,14 @@
 use crate::{
     ExtractedSlice, ExtractedSlices, ExtractedSprite, ExtractedSpriteKind, ExtractedSprites,
 };
-use bevy_asset::{AssetId, Assets};
+use bevy_asset::AssetId;
 use bevy_camera::visibility::ViewVisibility;
 use bevy_color::LinearRgba;
 use bevy_ecs::{
     entity::Entity,
     query::Has,
-    system::{Commands, Query, Res, ResMut},
+    system::{Commands, Query, ResMut},
 };
-use bevy_image::prelude::*;
 use bevy_math::{Vec2, Vec3};
 use bevy_render::sync_world::TemporaryRenderEntity;
 use bevy_render::Extract;
@@ -26,7 +25,6 @@ pub fn extract_text2d_sprite(
     mut commands: Commands,
     mut extracted_sprites: ResMut<ExtractedSprites>,
     mut extracted_slices: ResMut<ExtractedSlices>,
-    texture_atlases: Extract<Res<Assets<TextureAtlasLayout>>>,
     text2d_query: Extract<
         Query<(
             Entity,
@@ -122,15 +120,10 @@ pub fn extract_text2d_sprite(
                 },
             ) in text_layout_info.glyphs.iter().enumerate()
             {
-                let rect = texture_atlases
-                    .get(atlas_info.texture_atlas)
-                    .unwrap()
-                    .textures[atlas_info.location.glyph_index]
-                    .as_rect();
                 extracted_slices.slices.push(ExtractedSlice {
                     offset: *position,
-                    rect,
-                    size: rect.size(),
+                    rect: atlas_info.rect,
+                    size: atlas_info.rect.size(),
                 });
 
                 if text_layout_info
@@ -239,15 +232,10 @@ pub fn extract_text2d_sprite(
                     .unwrap_or_default();
                 current_span = *span_index;
             }
-            let rect = texture_atlases
-                .get(atlas_info.texture_atlas)
-                .unwrap()
-                .textures[atlas_info.location.glyph_index]
-                .as_rect();
             extracted_slices.slices.push(ExtractedSlice {
                 offset: *position,
-                rect,
-                size: rect.size(),
+                rect: atlas_info.rect,
+                size: atlas_info.rect.size(),
             });
 
             if text_layout_info.glyphs.get(i + 1).is_none_or(|info| {
diff --git a/crates/bevy_text/src/font_atlas.rs b/crates/bevy_text/src/font_atlas.rs
index 3cf9cc94b70f2..c696adc318ac5 100644
--- a/crates/bevy_text/src/font_atlas.rs
+++ b/crates/bevy_text/src/font_atlas.rs
@@ -1,6 +1,6 @@
 use bevy_asset::{Assets, Handle, RenderAssetUsages};
 use bevy_image::{prelude::*, ImageSampler, ToExtents};
-use bevy_math::{IVec2, UVec2};
+use bevy_math::{UVec2, Vec2};
 use bevy_platform::collections::HashMap;
 use swash::scale::Scaler;
 use wgpu_types::{Extent3d, TextureDimension, TextureFormat};
@@ -31,8 +31,8 @@ pub struct FontAtlas {
     pub dynamic_texture_atlas_builder: DynamicTextureAtlasBuilder,
     /// A mapping between subpixel-offset glyphs and their [`GlyphAtlasLocation`].
     pub glyph_to_atlas_index: HashMap<GlyphCacheKey, GlyphAtlasLocation>,
-    /// The handle to the [`TextureAtlasLayout`] that holds the rasterized glyphs.
-    pub texture_atlas: Handle<TextureAtlasLayout>,
+    /// The layout for the font atlas.
+    pub texture_atlas: TextureAtlasLayout,
     /// The texture where this font atlas is located
     pub texture: Handle<Image>,
 }
@@ -41,7 +41,6 @@ impl FontAtlas {
     /// Create a new [`FontAtlas`] with the given size, adding it to the appropriate asset collections.
     pub fn new(
         textures: &mut Assets<Image>,
-        texture_atlases_layout: &mut Assets<TextureAtlasLayout>,
         size: UVec2,
         font_smoothing: FontSmoothing,
     ) -> FontAtlas {
@@ -57,9 +56,8 @@ impl FontAtlas {
             image.sampler = ImageSampler::nearest();
         }
         let texture = textures.add(image);
-        let texture_atlas = texture_atlases_layout.add(TextureAtlasLayout::new_empty(size));
         Self {
-            texture_atlas,
+            texture_atlas: TextureAtlasLayout::new_empty(size),
             glyph_to_atlas_index: HashMap::default(),
             dynamic_texture_atlas_builder: DynamicTextureAtlasBuilder::new(size, 2),
             texture,
@@ -90,20 +88,16 @@ impl FontAtlas {
     pub fn add_glyph(
         &mut self,
         textures: &mut Assets<Image>,
-        atlas_layouts: &mut Assets<TextureAtlasLayout>,
         key: GlyphCacheKey,
         texture: &Image,
-        offset: IVec2,
+        offset: Vec2,
     ) -> Result<(), TextError> {
-        let mut atlas_layout = atlas_layouts
-            .get_mut(&self.texture_atlas)
-            .ok_or(TextError::MissingAtlasLayout)?;
         let mut atlas_texture = textures
             .get_mut(&self.texture)
             .ok_or(TextError::MissingAtlasTexture)?;
 
         if let Ok(glyph_index) = self.dynamic_texture_atlas_builder.add_texture(
-            &mut atlas_layout,
+            &mut self.texture_atlas,
             texture,
             &mut atlas_texture,
         ) {
@@ -135,7 +129,6 @@ impl core::fmt::Debug for FontAtlas {
 /// Adds the given subpixel-offset glyph to the given font atlases
 pub fn add_glyph_to_atlas(
     font_atlases: &mut Vec<FontAtlas>,
-    texture_atlases: &mut Assets<TextureAtlasLayout>,
     textures: &mut Assets<Image>,
     scaler: &mut Scaler,
     font_smoothing: FontSmoothing,
@@ -143,13 +136,7 @@ pub fn add_glyph_to_atlas(
 ) -> Result<GlyphAtlasInfo, TextError> {
     let (glyph_texture, offset) = get_outlined_glyph_texture(scaler, glyph_id, font_smoothing)?;
     let mut add_char_to_font_atlas = |atlas: &mut FontAtlas| -> Result<(), TextError> {
-        atlas.add_glyph(
-            textures,
-            texture_atlases,
-            GlyphCacheKey { glyph_id },
-            &glyph_texture,
-            offset,
-        )
+        atlas.add_glyph(textures, GlyphCacheKey { glyph_id }, &glyph_texture, offset)
     };
     if !font_atlases
         .iter_mut()
@@ -164,20 +151,9 @@ pub fn add_glyph_to_atlas(
         // Pick the higher of 512 or the smallest power of 2 greater than glyph_max_size
         let containing = (1u32 << (32 - glyph_max_size.leading_zeros())).max(512);
 
-        let mut new_atlas = FontAtlas::new(
-            textures,
-            texture_atlases,
-            UVec2::splat(containing),
-            font_smoothing,
-        );
+        let mut new_atlas = FontAtlas::new(textures, UVec2::splat(containing), font_smoothing);
 
-        new_atlas.add_glyph(
-            textures,
-            texture_atlases,
-            GlyphCacheKey { glyph_id },
-            &glyph_texture,
-            offset,
-        )?;
+        new_atlas.add_glyph(textures, GlyphCacheKey { glyph_id }, &glyph_texture, offset)?;
 
         font_atlases.push(new_atlas);
     }
@@ -195,7 +171,7 @@ pub fn get_outlined_glyph_texture(
     scaler: &mut Scaler,
     glyph_id: u16,
     font_smoothing: FontSmoothing,
-) -> Result<(Image, IVec2), TextError> {
+) -> Result<(Image, Vec2), TextError> {
     let image = swash::scale::Render::new(&[
         swash::scale::Source::ColorOutline(0),
         swash::scale::Source::ColorBitmap(swash::scale::StrikeWith::BestFit),
@@ -245,7 +221,7 @@ pub fn get_outlined_glyph_texture(
             TextureFormat::Rgba8UnormSrgb,
             RenderAssetUsages::MAIN_WORLD,
         ),
-        IVec2::new(left, top),
+        Vec2::new(left as f32, -top as f32),
     ))
 }
 
@@ -258,8 +234,8 @@ pub fn get_glyph_atlas_info(
         atlas
             .get_glyph_index(cache_key)
             .map(|location| GlyphAtlasInfo {
-                location,
-                texture_atlas: atlas.texture_atlas.id(),
+                offset: location.offset,
+                rect: atlas.texture_atlas.textures[location.glyph_index].as_rect(),
                 texture: atlas.texture.id(),
             })
     })
diff --git a/crates/bevy_text/src/glyph.rs b/crates/bevy_text/src/glyph.rs
index f9edd7b85bd98..f656e80a064d5 100644
--- a/crates/bevy_text/src/glyph.rs
+++ b/crates/bevy_text/src/glyph.rs
@@ -2,7 +2,7 @@
 
 use bevy_asset::AssetId;
 use bevy_image::prelude::*;
-use bevy_math::{IVec2, Vec2};
+use bevy_math::{Rect, Vec2};
 use bevy_reflect::Reflect;
 
 /// A glyph of a font, typically representing a single character, positioned in screen space.
@@ -15,8 +15,6 @@ use bevy_reflect::Reflect;
 pub struct PositionedGlyph {
     /// The position of the glyph in the text block's bounding box.
     pub position: Vec2,
-    /// The width and height of the glyph in logical pixels.
-    pub size: Vec2,
     /// Information about the glyph's atlas.
     pub atlas_info: GlyphAtlasInfo,
     /// The index of the glyph in the [`ComputedTextBlock`](crate::ComputedTextBlock)'s tracked spans.
@@ -42,13 +40,10 @@ pub struct GlyphAtlasInfo {
     ///
     /// An asset ID of the handle held by the [`FontAtlas`](crate::FontAtlas).
     pub texture: AssetId<Image>,
-    /// An asset ID to the [`TextureAtlasLayout`] map for the texture atlas this glyph was placed
-    /// in.
-    ///
-    /// An asset ID of the handle held by the [`FontAtlas`](crate::FontAtlas).
-    pub texture_atlas: AssetId<TextureAtlasLayout>,
-    /// Location and offset of a glyph within the texture atlas.
-    pub location: GlyphAtlasLocation,
+    /// Bounds of the glyph in the atlas texture
+    pub rect: Rect,
+    /// The required offset (relative positioning) when placed
+    pub offset: Vec2,
 }
 
 /// The location of a glyph in an atlas,
@@ -61,5 +56,5 @@ pub struct GlyphAtlasLocation {
     /// The index of the glyph in the atlas
     pub glyph_index: usize,
     /// The required offset (relative positioning) when placed
-    pub offset: IVec2,
+    pub offset: Vec2,
 }
diff --git a/crates/bevy_text/src/pipeline.rs b/crates/bevy_text/src/pipeline.rs
index 68adebda88540..7f9bdf8ca01d1 100644
--- a/crates/bevy_text/src/pipeline.rs
+++ b/crates/bevy_text/src/pipeline.rs
@@ -10,7 +10,7 @@ use bevy_ecs::{
 };
 use bevy_image::prelude::*;
 use bevy_log::warn_once;
-use bevy_math::{Rect, UVec2, Vec2};
+use bevy_math::{Rect, Vec2};
 use bevy_platform::hash::FixedHasher;
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
 use parley::style::{OverflowWrap, TextWrapMode};
@@ -264,7 +264,6 @@ impl TextPipeline {
         &mut self,
         layout_info: &mut TextLayoutInfo,
         font_atlas_set: &mut FontAtlasSet,
-        texture_atlases: &mut Assets<TextureAtlasLayout>,
         textures: &mut Assets<Image>,
         computed: &mut ComputedTextBlock,
         scale_cx: &mut ScaleCx,
@@ -326,7 +325,6 @@ impl TextPipeline {
                                 .unwrap_or_else(|| {
                                     add_glyph_to_atlas(
                                         font_atlases,
-                                        texture_atlases,
                                         textures,
                                         &mut scaler,
                                         font_smoothing,
@@ -334,22 +332,17 @@ impl TextPipeline {
                                     )
                                 })?;
 
-                        let texture_atlas = texture_atlases.get(atlas_info.texture_atlas).unwrap();
-                        let location = atlas_info.location;
-                        let glyph_rect = texture_atlas.textures[location.glyph_index];
-                        let glyph_size =
-                            UVec2::new(glyph_rect.width(), glyph_rect.height()).as_vec2();
                         let glyph_pos = Vec2::new(glyph.x, glyph.y);
+                        let size = atlas_info.rect.size();
 
                         layout_info.glyphs.push(PositionedGlyph {
-                            position: glyph_size / 2.
+                            position: size / 2.
                                 + if font_smoothing == FontSmoothing::None {
                                     glyph_pos.floor()
                                 } else {
                                     glyph_pos
                                 }
-                                + location.offset.as_vec2() * Vec2::new(1., -1.),
-                            size: glyph_size,
+                                + atlas_info.offset,
                             atlas_info,
                             span_index,
                             byte_index: text_range.start,
diff --git a/crates/bevy_ui/src/widget/text.rs b/crates/bevy_ui/src/widget/text.rs
index f8735e62b683a..5da2c8752d69a 100644
--- a/crates/bevy_ui/src/widget/text.rs
+++ b/crates/bevy_ui/src/widget/text.rs
@@ -331,7 +331,6 @@ pub fn measure_text_system(
 /// It does not modify or observe existing ones. The exception is when adding new glyphs to a [`bevy_text::FontAtlas`].
 pub fn text_system(
     mut textures: ResMut<Assets<Image>>,
-    mut texture_atlases: ResMut<Assets<TextureAtlasLayout>>,
     mut font_atlas_set: ResMut<FontAtlasSet>,
     mut text_pipeline: ResMut<TextPipeline>,
     mut text_query: Query<(
@@ -364,7 +363,6 @@ pub fn text_system(
             match text_pipeline.update_text_layout_info(
                 &mut text_layout_info,
                 &mut font_atlas_set,
-                &mut texture_atlases,
                 &mut textures,
                 &mut computed,
                 &mut scale_cx,
diff --git a/crates/bevy_ui_render/src/lib.rs b/crates/bevy_ui_render/src/lib.rs
index 9d2635d95e08a..fee505ee9ac04 100644
--- a/crates/bevy_ui_render/src/lib.rs
+++ b/crates/bevy_ui_render/src/lib.rs
@@ -843,7 +843,6 @@ pub fn extract_viewport_nodes(
 pub fn extract_text_sections(
     mut commands: Commands,
     mut extracted_uinodes: ResMut<ExtractedUiNodes>,
-    texture_atlases: Extract<Res<Assets<TextureAtlasLayout>>>,
     uinode_query: Extract<
         Query<(
             Entity,
@@ -912,15 +911,10 @@ pub fn extract_text_sections(
                 current_span_index = *span_index;
             }
 
-            let rect = texture_atlases
-                .get(atlas_info.texture_atlas)
-                .unwrap()
-                .textures[atlas_info.location.glyph_index]
-                .as_rect();
             extracted_uinodes.glyphs.push(ExtractedGlyph {
                 color,
                 translation: *position,
-                rect,
+                rect: atlas_info.rect,
             });
 
             if text_layout_info
@@ -949,7 +943,6 @@ pub fn extract_text_sections(
 pub fn extract_text_shadows(
     mut commands: Commands,
     mut extracted_uinodes: ResMut<ExtractedUiNodes>,
-    texture_atlases: Extract<Res<Assets<TextureAtlasLayout>>>,
     uinode_query: Extract<
         Query<(
             Entity,
@@ -1006,15 +999,10 @@ pub fn extract_text_shadows(
             },
         ) in text_layout_info.glyphs.iter().enumerate()
         {
-            let rect = texture_atlases
-                .get(atlas_info.texture_atlas)
-                .unwrap()
-                .textures[atlas_info.location.glyph_index]
-                .as_rect();
             extracted_uinodes.glyphs.push(ExtractedGlyph {
                 color: shadow.color.into(),
                 translation: *position,
-                rect,
+                rect: atlas_info.rect,
             });
 
             if text_layout_info.glyphs.get(i + 1).is_none_or(|info| {
diff --git a/release-content/migration-guides/FontAtlas-texture-atlas-layout.md b/release-content/migration-guides/FontAtlas-texture-atlas-layout.md
new file mode 100644
index 0000000000000..05f06f81d1488
--- /dev/null
+++ b/release-content/migration-guides/FontAtlas-texture-atlas-layout.md
@@ -0,0 +1,16 @@
+---
+title: "`FontAtlas` changes"
+pull_requests: [23012]
+---
+
+The texture atlas layout for font atlases is no longer stored as a separate asset. Instead, it is stored directly in the `texture_atlas` field of `FontAtlas`.
+
+The `TextureAtlasLayout` parameters of `FontAtlas`'s `new` and `add_glyph_to_atlas` methods have been removed.
+
+`FontAtlas::add_glyph`'s offset parameter has been changed from an `IVec2` to a `Vec2`
+
+`GlyphAtlasInfo`'s `texture_atlas` and `location` fields have been removed, replaced by `rect` and `offset` fields.
+
+The `size` field has been removed from `PositionedGlyph`. The glyphâ€™s size can now be obtained from the `Rect` stored in the `atlas_info: GlyphAtlasInfo` field.
+
+`GlyphAtlasLocation::offset` is now a `Vec2`.
