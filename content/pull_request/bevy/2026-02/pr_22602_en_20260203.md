+++
title = "#22602 Observer run conditions"
date = "2026-02-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22602-en-20260203" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22602-zh-cn-20260203" }}
labels = ["C-Feature", "A-ECS", "M-Release-Note", "D-Modest", "D-Unsafe"]
+++

# Title

## Basic Information
- **Title**: Observer run conditions
- **PR Link**: https://github.com/bevyengine/bevy/pull/22602
- **Author**: jonas-meyer
- **Status**: MERGED
- **Labels**: C-Feature, A-ECS, S-Ready-For-Final-Review, M-Release-Note, D-Modest, D-Unsafe
- **Created**: 2026-01-19T21:58:49Z
- **Merged**: 2026-02-03T16:12:26Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

Allow observers to use run conditions, enabling conditional execution based on world state - the same pattern that systems use with .run_if().

Fixes #14195
Fixes #21442

## Solution

Add a run_if() method to observer systems via the ObserverSystemExt trait. Conditions are stored in Observer and checked before execution in the runner.

Key implementation details:
- ObserverWithCondition<E,B,M,S> wrapper preserves event type info for compile-time EntityEvent enforcement on entity observers
- Conditions are ReadOnlySystem (enforced by SystemCondition trait), matching system run conditions
- Multiple conditions chain with AND semantics, short-circuiting on first false

It's a bit more involved than mentioned [here](https://github.com/bevyengine/bevy/issues/21442#issuecomment-3765694484) since we need the full system‑style API: chained run_ifs, entity observers with compile‑time EntityEvent checks, and use with add_observer/observe. 

That forces a typed wrapper + marker types + IntoObserver/IntoEntityObserver, and conditions must be initialized at spawn time (so the hook has to take/init/restore). The runner also needs a safety‑documented precheck before running the observer.

## Testing

- Added 7 new tests covering:
  - Condition preventing/allowing execution
  - Multiple conditions (all true / one false)
  - Entity observers with conditions
  - Resource-based conditions
  - Builder pattern on Observer::new()
- All existing tests pass (cargo test -p bevy_ecs)
- Updated observers.rs example with Space key toggle

---

## Showcase

```rust
#[derive(Resource)]
struct GameActive(bool);
// Global observer - only runs when game is active
app.add_observer(
    on_damage.run_if(|state: Res<GameActive>| state.0)
);
// Chained conditions (AND semantics)
app.add_observer(
    on_damage
        .run_if(|state: Res<GameActive>| state.0)
        .run_if(|player: Query<&Health, With<Player>>| player.single().is_ok())
);
// Entity observer
commands.spawn(Enemy).observe(
    on_hit.run_if(|game: Res<GameActive>| game.0)
);
// Builder pattern
world.spawn(
    Observer::new(on_event)
        .with_entity(target)
        .run_if(some_condition)
);
```

<details>

<summary>Example from observers.rs</summary>

```rust
#[derive(Resource, Default)]
struct ExplosionsEnabled(bool);

fn toggle_explosions(mut enabled: ResMut<ExplosionsEnabled>, input: Res<ButtonInput<KeyCode>>) {
    if input.just_pressed(KeyCode::Space) {
        enabled.0 = !enabled.0;
        info!("Explosions {}", if enabled.0 { "enabled" } else { "disabled" });
    }
}

fn setup(app: &mut App) {
    app.add_observer(
        explode_mine.run_if(|enabled: Res<ExplosionsEnabled>| enabled.0)
    );
}
```

</details>


## The Story of This Pull Request

Observers in Bevy provide a powerful way to react to events, but they lacked a critical feature: conditional execution. This limitation became apparent when developers needed observers to run only under specific game states or conditions, requiring workarounds like checking conditions inside the observer function itself or using multiple observers. This PR addresses that gap by bringing `.run_if()` functionality to observers, matching the capabilities already available to regular systems.

The implementation began with the core requirement: conditions needed to work seamlessly across all observer use cases. This included global observers added via `add_observer()`, entity observers created with `.observe()`, and the builder pattern using `Observer::new()`. The challenge was maintaining type safety while supporting chained conditions and preserving compile-time validation for entity events.

The solution centers around three key components. First, the `ObserverSystemExt` trait provides the `.run_if()` method that returns an `ObserverWithCondition` wrapper. This wrapper preserves the event type information needed for compile-time enforcement of `EntityEvent` on entity observers. Second, the `Observer` struct now stores a vector of `ObserverCondition` objects that hold the actual condition systems. Third, the observer runner checks all conditions before executing the observer's main logic.

A significant implementation detail is the initialization sequence. Conditions must be initialized after the observer is added to the world but before any events can trigger it. This required modifying the `hook_on_add` function to temporarily take ownership of the conditions vector, initialize each condition, and then restore it to the observer. The runner performs safety-documented checks before evaluating conditions, ensuring proper world access.

The design follows Bevy's existing patterns for system conditions. Conditions are `ReadOnlySystem`s (enforced by the `SystemCondition` trait), matching how system run conditions work. Multiple conditions chain with AND semantics and short-circuit on the first false condition. The implementation also handles error cases where conditions might return `Result<bool>`.

Testing was comprehensive, covering both global and entity observers with various condition types. The example in `observers.rs` was updated to demonstrate the feature with a Space key toggle, providing immediate visual feedback of the functionality. All existing tests continue to pass, confirming backward compatibility.

This change enhances Bevy's observer system by providing the same conditional execution capabilities that systems enjoy, reducing boilerplate and enabling more declarative observer patterns. Developers can now write observers that cleanly separate condition checking from reaction logic, improving code organization and maintainability.

## Visual Representation

```mermaid
graph TD
    A[ObserverSystemExt trait] -->|provides| B[.run_if() method]
    B -->|returns| C[ObserverWithCondition wrapper]
    C -->|preserves type info| D[EntityEvent validation]
    E[Observer struct] -->|stores| F[Vec<ObserverCondition>]
    F -->|initialized by| G[hook_on_add function]
    H[Observer runner] -->|checks| F
    F -->|all true| I[Execute observer]
    F -->|any false| J[Skip observer]
    K[IntoObserver trait] -->|enables| L[add_observer() API]
    M[IntoEntityObserver trait] -->|enables| N[entity.observe() API]
```

## Key Files Changed

### `crates/bevy_ecs/src/observer/mod.rs` (+215/-6)
This is the main entry point for observer functionality. The changes add support for run conditions throughout the observer API.

Key modifications:
1. **`World::add_observer()`** now uses the `IntoObserver` trait instead of `IntoObserverSystem`, enabling it to accept observers with conditions.
   
   ```rust
   // Before:
   pub fn add_observer<E: Event, B: Bundle, M>(
       &mut self,
       system: impl IntoObserverSystem<E, B, M>,
   ) -> EntityWorldMut<'_> {
       self.spawn(Observer::new(system))
   }
   
   // After:
   pub fn add_observer<M>(&mut self, observer: impl IntoObserver<M>) -> EntityWorldMut<'_> {
       self.spawn(observer.into_observer())
   }
   ```

2. **New tests** were added to verify run condition functionality, covering:
   - Basic true/false conditions
   - Chained conditions with AND semantics
   - Entity observers with conditions
   - Conditions returning `Result<bool>`
   - Change detection in conditions
   - Builder pattern with `Observer::new().run_if()`

### `crates/bevy_ecs/src/observer/distributed_storage.rs` (+138/-12)
This file contains the core `Observer` struct definition and related traits.

Key modifications:
1. **`Observer` struct** now includes a `conditions` field:
   
   ```rust
   pub struct Observer {
       // ... existing fields ...
       pub(crate) conditions: Vec<ObserverCondition>,
   }
   ```

2. **New methods** for adding conditions:
   ```rust
   /// Adds a run condition to this observer.
   pub fn run_if<M>(mut self, condition: impl SystemCondition<M>) -> Self {
       self.conditions.push(ObserverCondition::new(condition));
       self
   }
   ```

3. **`IntoObserver` and `IntoEntityObserver` traits** enable polymorphic acceptance of observers with or without conditions:
   ```rust
   pub trait IntoObserver<Marker>: Send + 'static {
       fn into_observer(self) -> Observer;
   }
   
   pub trait IntoEntityObserver<Marker>: Send + 'static {
       fn into_observer_for_entity(self, entity: Entity) -> Observer;
   }
   ```

4. **`hook_on_add` function** was updated to initialize conditions during observer registration:
   ```rust
   let mut conditions = {
       // ... get observer and take conditions ...
   };
   for condition in &mut conditions {
       condition.initialize(world);
   }
   // ... restore conditions to observer ...
   ```

### `crates/bevy_ecs/src/observer/condition.rs` (+108/-0)
This is a new file that defines the types and structures for observer conditions.

Key components:
1. **`ObserverCondition` struct** wraps a boxed condition system:
   ```rust
   pub(crate) struct ObserverCondition {
       condition: BoxedCondition,
   }
   
   impl ObserverCondition {
       pub(crate) unsafe fn check(&mut self, world: UnsafeWorldCell) -> bool {
           unsafe { self.condition.run_unsafe((), world) }.unwrap_or(false)
       }
   }
   ```

2. **`ObserverWithCondition` struct** is the typed wrapper returned by `.run_if()`:
   ```rust
   pub struct ObserverWithCondition<E: Event, B: Bundle, M, S: IntoObserverSystem<E, B, M>> {
       pub(crate) system: S,
       pub(crate) conditions: Vec<BoxedCondition>,
       pub(crate) _marker: PhantomData<fn() -> (E, B, M)>,
   }
   ```

3. **`ObserverSystemExt` trait** provides the `.run_if()` method:
   ```rust
   pub trait ObserverSystemExt<E: Event, B: Bundle, M>: IntoObserverSystem<E, B, M> + Sized {
       fn run_if<C, CM>(self, condition: C) -> ObserverWithCondition<E, B, M, Self>
       where
           C: SystemCondition<CM>,
   }
   ```

### `crates/bevy_ecs/src/observer/runner.rs` (+15/-0)
The observer runner was updated to check conditions before executing the observer.

Key modification:
```rust
// Check all conditions before running the observer
let mut should_run = true;
for condition in state.conditions.iter_mut() {
    should_run &= unsafe { condition.check(world) };
}

if !should_run {
    return;
}
```

### `examples/ecs/observers.rs` (+32/-7)
The example was updated to demonstrate observer run conditions with a Space key toggle.

Key changes:
1. **Added `ExplosionsEnabled` resource** to control whether explosions should occur.
2. **Added `toggle_explosions` system** that toggles the resource when Space is pressed.
3. **Modified observer** to use `.run_if()`:
   ```rust
   .add_observer(
       (|explode_mines: On<ExplodeMines>, /* ... */| {
           // Observer logic
       })
       .run_if(|enabled: Res<ExplosionsEnabled>| enabled.0),
   )
   ```

### Other files
- **`crates/bevy_app/src/app.rs`**: Updated `App::add_observer()` to use `IntoObserver` trait.
- **`crates/bevy_ecs/src/system/commands/mod.rs`**: Updated command APIs to use `IntoObserver` and `IntoEntityObserver` traits.
- **`crates/bevy_ecs/src/world/entity_access/world_mut.rs`**: Updated `EntityWorldMut::observe()` to use `IntoEntityObserver`.
- **`release-content/release-notes/observer_run_conditions.md`**: Added release notes documenting the new feature.

## Further Reading

1. **Bevy Observer Documentation**: The [official Bevy observer documentation](https://docs.rs/bevy_ecs/latest/bevy_ecs/observer/index.html) provides comprehensive information about observers.
2. **System Conditions**: Understanding [Bevy's system conditions](https://docs.rs/bevy_ecs/latest/bevy_ecs/schedule/trait.SystemCondition.html) helps in writing effective observer conditions.
3. **Entity Events**: The [`EntityEvent` trait documentation](https://docs.rs/bevy_ecs/latest/bevy_ecs/event/trait.EntityEvent.html) explains how entity-specific events work.
4. **Original Issues**: Issues [#14195](https://github.com/bevyengine/bevy/issues/14195) and [#21442](https://github.com/bevyengine/bevy/issues/21442) provide context about the need for observer run conditions.
5. **Bevy ECS Architecture**: The [Bevy ECS architecture guide](https://bevy-cheatbook.github.io/programming/ecs-intro.html) offers a broader understanding of how observers fit into Bevy's ECS model.