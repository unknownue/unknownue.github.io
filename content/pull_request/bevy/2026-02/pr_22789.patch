diff --git a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.rs b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.rs
index 79c21586441b2..cf212566e8df2 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.rs
+++ b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.rs
@@ -19,8 +19,8 @@ mod case2 {
     use super::*;
 
     #[derive(Component, Debug)]
-    #[component(on_replace = foo_hook)]
-    //~^ ERROR: Custom on_replace hooks are not supported as RelationshipTarget already defines an on_replace hook
+    #[component(on_discard = foo_hook)]
+    //~^ ERROR: Custom on_discard hooks are not supported as RelationshipTarget already defines an on_discard hook
     #[relationship_target(relationship = FooTargetOf)]
     pub struct FooTargetsFail(Vec<Entity>);
 
@@ -34,8 +34,8 @@ mod case3 {
     use super::*;
 
     #[derive(Component, Debug)]
-    #[component(on_replace = foo_hook)]
-    //~^ ERROR: Custom on_replace hooks are not supported as Relationships already define an on_replace hook
+    #[component(on_discard = foo_hook)]
+    //~^ ERROR: Custom on_discard hooks are not supported as Relationships already define an on_discard hook
     #[relationship(relationship_target = BarTargets)]
     pub struct BarTargetOfFail(Entity);
 
diff --git a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr
index 6ef40f9bf0255..18f4b457d4214 100644
--- a/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr
+++ b/crates/bevy_ecs/compile_fail/tests/ui/component_hook_relationship.stderr
@@ -4,16 +4,16 @@ error: Custom on_insert hooks are not supported as relationships already define
 7 |     #[component(on_insert = foo_hook)]
   |     ^
 
-error: Custom on_replace hooks are not supported as RelationshipTarget already defines an on_replace hook
+error: Custom on_discard hooks are not supported as RelationshipTarget already defines an on_discard hook
   --> tests/ui/component_hook_relationship.rs:22:5
    |
-22 |     #[component(on_replace = foo_hook)]
+22 |     #[component(on_discard = foo_hook)]
    |     ^
 
-error: Custom on_replace hooks are not supported as Relationships already define an on_replace hook
+error: Custom on_discard hooks are not supported as Relationships already define an on_discard hook
   --> tests/ui/component_hook_relationship.rs:37:5
    |
-37 |     #[component(on_replace = foo_hook)]
+37 |     #[component(on_discard = foo_hook)]
    |     ^
 
 error: Custom on_despawn hooks are not supported as this RelationshipTarget already defines an on_despawn hook, via the 'linked_spawn' attribute
diff --git a/crates/bevy_ecs/macros/src/component.rs b/crates/bevy_ecs/macros/src/component.rs
index 40b23c1a4aaa5..ba4907b25d568 100644
--- a/crates/bevy_ecs/macros/src/component.rs
+++ b/crates/bevy_ecs/macros/src/component.rs
@@ -184,31 +184,31 @@ pub fn derive_component(input: TokenStream) -> TokenStream {
             .map(|path| path.to_token_stream(&bevy_ecs_path))
     };
 
-    let on_replace_path = if relationship.is_some() {
-        if attrs.on_replace.is_some() {
+    let on_discard_path = if relationship.is_some() {
+        if attrs.on_discard.is_some() {
             return syn::Error::new(
                 ast.span(),
-                "Custom on_replace hooks are not supported as Relationships already define an on_replace hook",
+                "Custom on_discard hooks are not supported as Relationships already define an on_discard hook",
             )
             .into_compile_error()
             .into();
         }
 
-        Some(quote!(<Self as #bevy_ecs_path::relationship::Relationship>::on_replace))
+        Some(quote!(<Self as #bevy_ecs_path::relationship::Relationship>::on_discard))
     } else if attrs.relationship_target.is_some() {
-        if attrs.on_replace.is_some() {
+        if attrs.on_discard.is_some() {
             return syn::Error::new(
                 ast.span(),
-                "Custom on_replace hooks are not supported as RelationshipTarget already defines an on_replace hook",
+                "Custom on_discard hooks are not supported as RelationshipTarget already defines an on_discard hook",
             )
             .into_compile_error()
             .into();
         }
 
-        Some(quote!(<Self as #bevy_ecs_path::relationship::RelationshipTarget>::on_replace))
+        Some(quote!(<Self as #bevy_ecs_path::relationship::RelationshipTarget>::on_discard))
     } else {
         attrs
-            .on_replace
+            .on_discard
             .map(|path| path.to_token_stream(&bevy_ecs_path))
     };
 
@@ -234,8 +234,8 @@ pub fn derive_component(input: TokenStream) -> TokenStream {
 
     let on_add = hook_register_function_call(&bevy_ecs_path, quote! {on_add}, on_add_path);
     let on_insert = hook_register_function_call(&bevy_ecs_path, quote! {on_insert}, on_insert_path);
-    let on_replace =
-        hook_register_function_call(&bevy_ecs_path, quote! {on_replace}, on_replace_path);
+    let on_discard =
+        hook_register_function_call(&bevy_ecs_path, quote! {on_discard}, on_discard_path);
     let on_remove = hook_register_function_call(&bevy_ecs_path, quote! {on_remove}, on_remove_path);
     let on_despawn =
         hook_register_function_call(&bevy_ecs_path, quote! {on_despawn}, on_despawn_path);
@@ -340,7 +340,7 @@ pub fn derive_component(input: TokenStream) -> TokenStream {
 
             #on_add
             #on_insert
-            #on_replace
+            #on_discard
             #on_remove
             #on_despawn
 
@@ -462,7 +462,7 @@ pub const RELATIONSHIP_TARGET: &str = "relationship_target";
 
 pub const ON_ADD: &str = "on_add";
 pub const ON_INSERT: &str = "on_insert";
-pub const ON_REPLACE: &str = "on_replace";
+pub const ON_DISCARD: &str = "on_discard";
 pub const ON_REMOVE: &str = "on_remove";
 pub const ON_DESPAWN: &str = "on_despawn";
 pub const MAP_ENTITIES: &str = "map_entities";
@@ -585,7 +585,7 @@ struct Attrs {
     requires: Option<Punctuated<Require, Comma>>,
     on_add: Option<HookAttributeKind>,
     on_insert: Option<HookAttributeKind>,
-    on_replace: Option<HookAttributeKind>,
+    on_discard: Option<HookAttributeKind>,
     on_remove: Option<HookAttributeKind>,
     on_despawn: Option<HookAttributeKind>,
     relationship: Option<Relationship>,
@@ -625,7 +625,7 @@ fn parse_component_attr(ast: &DeriveInput) -> Result<Attrs> {
         storage: StorageTy::Table,
         on_add: None,
         on_insert: None,
-        on_replace: None,
+        on_discard: None,
         on_remove: None,
         on_despawn: None,
         requires: None,
@@ -661,9 +661,9 @@ fn parse_component_attr(ast: &DeriveInput) -> Result<Attrs> {
                         parse_quote! { Self::on_insert }
                     })?);
                     Ok(())
-                } else if nested.path.is_ident(ON_REPLACE) {
-                    attrs.on_replace = Some(HookAttributeKind::parse(nested.input, || {
-                        parse_quote! { Self::on_replace }
+                } else if nested.path.is_ident(ON_DISCARD) {
+                    attrs.on_discard = Some(HookAttributeKind::parse(nested.input, || {
+                        parse_quote! { Self::on_discard }
                     })?);
                     Ok(())
                 } else if nested.path.is_ident(ON_REMOVE) {
diff --git a/crates/bevy_ecs/macros/src/lib.rs b/crates/bevy_ecs/macros/src/lib.rs
index dbfccf1f00d9a..6c830203ffce8 100644
--- a/crates/bevy_ecs/macros/src/lib.rs
+++ b/crates/bevy_ecs/macros/src/lib.rs
@@ -650,7 +650,7 @@ pub fn derive_resource(input: TokenStream) -> TokenStream {
 /// #[component(hook_name = function)]
 /// struct MyComponent;
 /// ```
-/// where `hook_name` is `on_add`, `on_insert`, `on_replace` or `on_remove`;
+/// where `hook_name` is `on_add`, `on_insert`, `on_discard` or `on_remove`;
 /// `function` can be either a path, e.g. `some_function::<Self>`,
 /// or a function call that returns a function that can be turned into
 /// a `ComponentHook`, e.g. `get_closure("Hi!")`.
diff --git a/crates/bevy_ecs/src/archetype.rs b/crates/bevy_ecs/src/archetype.rs
index 984d8a14aa67f..e651e0aed47f1 100644
--- a/crates/bevy_ecs/src/archetype.rs
+++ b/crates/bevy_ecs/src/archetype.rs
@@ -363,12 +363,12 @@ bitflags::bitflags! {
     pub(crate) struct ArchetypeFlags: u32 {
         const ON_ADD_HOOK    = (1 << 0);
         const ON_INSERT_HOOK = (1 << 1);
-        const ON_REPLACE_HOOK = (1 << 2);
+        const ON_DISCARD_HOOK = (1 << 2);
         const ON_REMOVE_HOOK = (1 << 3);
         const ON_DESPAWN_HOOK = (1 << 4);
         const ON_ADD_OBSERVER = (1 << 5);
         const ON_INSERT_OBSERVER = (1 << 6);
-        const ON_REPLACE_OBSERVER = (1 << 7);
+        const ON_DISCARD_OBSERVER = (1 << 7);
         const ON_REMOVE_OBSERVER = (1 << 8);
         const ON_DESPAWN_OBSERVER = (1 << 9);
     }
@@ -680,10 +680,10 @@ impl Archetype {
         self.flags().contains(ArchetypeFlags::ON_INSERT_HOOK)
     }
 
-    /// Returns true if any of the components in this archetype have `on_replace` hooks
+    /// Returns true if any of the components in this archetype have `on_discard` hooks
     #[inline]
-    pub fn has_replace_hook(&self) -> bool {
-        self.flags().contains(ArchetypeFlags::ON_REPLACE_HOOK)
+    pub fn has_discard_hook(&self) -> bool {
+        self.flags().contains(ArchetypeFlags::ON_DISCARD_HOOK)
     }
 
     /// Returns true if any of the components in this archetype have `on_remove` hooks
@@ -714,12 +714,12 @@ impl Archetype {
         self.flags().contains(ArchetypeFlags::ON_INSERT_OBSERVER)
     }
 
-    /// Returns true if any of the components in this archetype have at least one [`Replace`] observer
+    /// Returns true if any of the components in this archetype have at least one [`Discard`] observer
     ///
-    /// [`Replace`]: crate::lifecycle::Replace
+    /// [`Discard`]: crate::lifecycle::Discard
     #[inline]
-    pub fn has_replace_observer(&self) -> bool {
-        self.flags().contains(ArchetypeFlags::ON_REPLACE_OBSERVER)
+    pub fn has_discard_observer(&self) -> bool {
+        self.flags().contains(ArchetypeFlags::ON_DISCARD_OBSERVER)
     }
 
     /// Returns true if any of the components in this archetype have at least one [`Remove`] observer
diff --git a/crates/bevy_ecs/src/bundle/insert.rs b/crates/bevy_ecs/src/bundle/insert.rs
index 782edf1dc2d2e..858eccaca98fc 100644
--- a/crates/bevy_ecs/src/bundle/insert.rs
+++ b/crates/bevy_ecs/src/bundle/insert.rs
@@ -12,7 +12,7 @@ use crate::{
     component::{Components, StorageType},
     entity::{Entities, Entity, EntityLocation},
     event::EntityComponentsTrigger,
-    lifecycle::{Add, Insert, Replace, ADD, INSERT, REPLACE},
+    lifecycle::{Add, Discard, Insert, ADD, DISCARD, INSERT},
     observer::Observers,
     query::DebugCheckedUnwrap as _,
     relationship::RelationshipHookMode,
@@ -174,11 +174,11 @@ impl<'w> BundleInserter<'w> {
                         new_archetype.as_ref()
                     }
                 };
-                if archetype.has_replace_observer() {
-                    // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+                if archetype.has_discard_observer() {
+                    // SAFETY: the DISCARD event_key corresponds to the Discard event's type
                     deferred_world.trigger_raw(
-                        REPLACE,
-                        &mut Replace { entity },
+                        DISCARD,
+                        &mut Discard { entity },
                         &mut EntityComponentsTrigger {
                             components: archetype_after_insert.existing(),
                             old_archetype: Some(archetype),
@@ -187,7 +187,7 @@ impl<'w> BundleInserter<'w> {
                         caller,
                     );
                 }
-                deferred_world.trigger_on_replace(
+                deferred_world.trigger_on_discard(
                     archetype,
                     entity,
                     archetype_after_insert.existing().iter().copied(),
@@ -199,7 +199,7 @@ impl<'w> BundleInserter<'w> {
 
         let table = table.as_mut();
 
-        // SAFETY: Archetype gets borrowed when running the on_replace observers above,
+        // SAFETY: Archetype gets borrowed when running the on_discard observers above,
         // so this reference can only be promoted from shared to &mut down here, after they have been ran
         let archetype = archetype.as_mut();
 
diff --git a/crates/bevy_ecs/src/bundle/remove.rs b/crates/bevy_ecs/src/bundle/remove.rs
index 664061a930b51..5ceb9789eacce 100644
--- a/crates/bevy_ecs/src/bundle/remove.rs
+++ b/crates/bevy_ecs/src/bundle/remove.rs
@@ -9,7 +9,7 @@ use crate::{
     component::{ComponentId, Components, StorageType},
     entity::{Entity, EntityLocation},
     event::EntityComponentsTrigger,
-    lifecycle::{Remove, Replace, REMOVE, REPLACE},
+    lifecycle::{Discard, Remove, DISCARD, REMOVE},
     observer::Observers,
     relationship::RelationshipHookMode,
     storage::{SparseSets, Storages, Table},
@@ -147,12 +147,12 @@ impl<'w> BundleRemover<'w> {
                     .iter_explicit_components()
                     .filter(|component_id| self.old_archetype.as_ref().contains(*component_id))
             };
-            if self.old_archetype.as_ref().has_replace_observer() {
+            if self.old_archetype.as_ref().has_discard_observer() {
                 let components = bundle_components_in_archetype().collect::<Vec<_>>();
-                // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+                // SAFETY: the DISCARD event_key corresponds to the Discard event's type
                 deferred_world.trigger_raw(
-                    REPLACE,
-                    &mut Replace { entity },
+                    DISCARD,
+                    &mut Discard { entity },
                     &mut EntityComponentsTrigger {
                         components: &components,
                         old_archetype: Some(self.old_archetype.as_ref()),
@@ -161,7 +161,7 @@ impl<'w> BundleRemover<'w> {
                     caller,
                 );
             }
-            deferred_world.trigger_on_replace(
+            deferred_world.trigger_on_discard(
                 self.old_archetype.as_ref(),
                 entity,
                 bundle_components_in_archetype(),
diff --git a/crates/bevy_ecs/src/bundle/tests.rs b/crates/bevy_ecs/src/bundle/tests.rs
index 875e604f12409..4553170b6e656 100644
--- a/crates/bevy_ecs/src/bundle/tests.rs
+++ b/crates/bevy_ecs/src/bundle/tests.rs
@@ -6,7 +6,7 @@ use crate::{
 struct A;
 
 #[derive(Component)]
-#[component(on_add = a_on_add, on_insert = a_on_insert, on_replace = a_on_replace, on_remove = a_on_remove)]
+#[component(on_add = a_on_add, on_insert = a_on_insert, on_discard = a_on_discard, on_remove = a_on_remove)]
 struct AMacroHooks;
 
 fn a_on_add(mut world: DeferredWorld, _: HookContext) {
@@ -17,7 +17,7 @@ fn a_on_insert(mut world: DeferredWorld, _: HookContext) {
     world.resource_mut::<R>().assert_order(1);
 }
 
-fn a_on_replace(mut world: DeferredWorld, _: HookContext) {
+fn a_on_discard(mut world: DeferredWorld, _: HookContext) {
     world.resource_mut::<R>().assert_order(2);
 }
 
@@ -76,7 +76,7 @@ fn component_hook_order_spawn_despawn() {
         .register_component_hooks::<A>()
         .on_add(|mut world, _| world.resource_mut::<R>().assert_order(0))
         .on_insert(|mut world, _| world.resource_mut::<R>().assert_order(1))
-        .on_replace(|mut world, _| world.resource_mut::<R>().assert_order(2))
+        .on_discard(|mut world, _| world.resource_mut::<R>().assert_order(2))
         .on_remove(|mut world, _| world.resource_mut::<R>().assert_order(3));
 
     let entity = world.spawn(A).id();
@@ -103,7 +103,7 @@ fn component_hook_order_insert_remove() {
         .register_component_hooks::<A>()
         .on_add(|mut world, _| world.resource_mut::<R>().assert_order(0))
         .on_insert(|mut world, _| world.resource_mut::<R>().assert_order(1))
-        .on_replace(|mut world, _| world.resource_mut::<R>().assert_order(2))
+        .on_discard(|mut world, _| world.resource_mut::<R>().assert_order(2))
         .on_remove(|mut world, _| world.resource_mut::<R>().assert_order(3));
 
     let mut entity = world.spawn_empty();
@@ -118,7 +118,7 @@ fn component_hook_order_replace() {
     let mut world = World::new();
     world
         .register_component_hooks::<A>()
-        .on_replace(|mut world, _| world.resource_mut::<R>().assert_order(0))
+        .on_discard(|mut world, _| world.resource_mut::<R>().assert_order(0))
         .on_insert(|mut world, _| {
             if let Some(mut r) = world.get_resource_mut::<R>() {
                 r.assert_order(1);
@@ -129,7 +129,7 @@ fn component_hook_order_replace() {
     world.init_resource::<R>();
     let mut entity = world.entity_mut(entity);
     entity.insert(A);
-    entity.insert_if_new(A); // this will not trigger on_replace or on_insert
+    entity.insert_if_new(A); // this will not trigger on_discard or on_insert
     entity.flush();
     assert_eq!(2, world.resource::<R>().0);
 }
diff --git a/crates/bevy_ecs/src/component/constants.rs b/crates/bevy_ecs/src/component/constants.rs
index 17c12b5d76ed0..3f582545f85b9 100644
--- a/crates/bevy_ecs/src/component/constants.rs
+++ b/crates/bevy_ecs/src/component/constants.rs
@@ -4,8 +4,8 @@
 pub const ADD: usize = 0;
 /// `usize` for the [`Insert`](crate::lifecycle::Insert) component used in lifecycle observers.
 pub const INSERT: usize = 1;
-/// `usize` for the [`Replace`](crate::lifecycle::Replace) component used in lifecycle observers.
-pub const REPLACE: usize = 2;
+/// `usize` for the [`Discard`](crate::lifecycle::Discard) component used in lifecycle observers.
+pub const DISCARD: usize = 2;
 /// `usize` for the [`Remove`](crate::lifecycle::Remove) component used in lifecycle observers.
 pub const REMOVE: usize = 3;
 /// `usize` for [`Despawn`](crate::lifecycle::Despawn) component used in lifecycle observers.
diff --git a/crates/bevy_ecs/src/component/info.rs b/crates/bevy_ecs/src/component/info.rs
index a8423d9e67196..05ca09d39ea46 100644
--- a/crates/bevy_ecs/src/component/info.rs
+++ b/crates/bevy_ecs/src/component/info.rs
@@ -120,8 +120,8 @@ impl ComponentInfo {
         if self.hooks().on_insert.is_some() {
             flags.insert(ArchetypeFlags::ON_INSERT_HOOK);
         }
-        if self.hooks().on_replace.is_some() {
-            flags.insert(ArchetypeFlags::ON_REPLACE_HOOK);
+        if self.hooks().on_discard.is_some() {
+            flags.insert(ArchetypeFlags::ON_DISCARD_HOOK);
         }
         if self.hooks().on_remove.is_some() {
             flags.insert(ArchetypeFlags::ON_REMOVE_HOOK);
diff --git a/crates/bevy_ecs/src/component/mod.rs b/crates/bevy_ecs/src/component/mod.rs
index 566806331743c..c12dfb06e1524 100644
--- a/crates/bevy_ecs/src/component/mod.rs
+++ b/crates/bevy_ecs/src/component/mod.rs
@@ -356,7 +356,7 @@ use core::{fmt::Debug, marker::PhantomData, ops::Deref};
 /// Alternatively to the example shown in [`ComponentHooks`]' documentation, hooks can be configured using following attributes:
 /// - `#[component(on_add = on_add_function)]`
 /// - `#[component(on_insert = on_insert_function)]`
-/// - `#[component(on_replace = on_replace_function)]`
+/// - `#[component(on_discard = on_discard_function)]`
 /// - `#[component(on_remove = on_remove_function)]`
 ///
 /// ```
@@ -373,8 +373,8 @@ use core::{fmt::Debug, marker::PhantomData, ops::Deref};
 /// // Another possible way of configuring hooks:
 /// // #[component(on_add = my_on_add_hook, on_insert = my_on_insert_hook)]
 /// //
-/// // We don't have a replace or remove hook, so we can leave them out:
-/// // #[component(on_replace = my_on_replace_hook, on_remove = my_on_remove_hook)]
+/// // We don't have a discard or remove hook, so we can leave them out:
+/// // #[component(on_discard = my_on_discard_hook, on_remove = my_on_remove_hook)]
 /// struct ComponentA;
 ///
 /// fn my_on_add_hook(world: DeferredWorld, context: HookContext) {
@@ -530,8 +530,8 @@ pub trait Component: Send + Sync + 'static {
         None
     }
 
-    /// Gets the `on_replace` [`ComponentHook`] for this [`Component`] if one is defined.
-    fn on_replace() -> Option<ComponentHook> {
+    /// Gets the `on_discard` [`ComponentHook`] for this [`Component`] if one is defined.
+    fn on_discard() -> Option<ComponentHook> {
         None
     }
 
@@ -673,7 +673,7 @@ mod private {
 /// `&mut ...`, created while inserted onto an entity.
 /// In all other ways, they are identical to mutable components.
 /// This restriction allows hooks to observe all changes made to an immutable
-/// component, effectively turning the `Insert` and `Replace` hooks into a
+/// component, effectively turning the `Insert` and `Discard` hooks into a
 /// `OnMutate` hook.
 /// This is not practical for mutable components, as the runtime cost of invoking
 /// a hook for every exclusive reference created would be far too high.
diff --git a/crates/bevy_ecs/src/event/trigger.rs b/crates/bevy_ecs/src/event/trigger.rs
index 140e9cd17eca1..83c8624aed4ec 100644
--- a/crates/bevy_ecs/src/event/trigger.rs
+++ b/crates/bevy_ecs/src/event/trigger.rs
@@ -344,7 +344,7 @@ pub struct EntityComponentsTrigger<'a> {
     pub components: &'a [ComponentId],
 
     /// The [`Archetype`] of the target entity before this change, or `None` if the entity was just spawned.
-    /// For observers that run before the change, like [`Replace`](crate::lifecycle::Replace) and [`Remove`](crate::lifecycle::Remove), this will be the current archetype.
+    /// For observers that run before the change, like [`Discard`](crate::lifecycle::Discard) and [`Remove`](crate::lifecycle::Remove), this will be the current archetype.
     ///
     /// This can be useful in [`Insert`](crate::lifecycle::Insert) and [`Add`](crate::lifecycle::Add) observers,
     /// since the old archetype will not include any other components added at the same time.
@@ -385,7 +385,7 @@ pub struct EntityComponentsTrigger<'a> {
     /// The [`Archetype`] of the target entity after this change, or `None` if the entity will be despawned.
     /// For observers that run after the change, like [`Insert`](crate::lifecycle::Insert) and [`Add`](crate::lifecycle::Add), this will be the current archetype.
     ///
-    /// This can be useful in [`Replace`](crate::lifecycle::Replace) and [`Remove`](crate::lifecycle::Remove) observers,
+    /// This can be useful in [`Discard`](crate::lifecycle::Discard) and [`Remove`](crate::lifecycle::Remove) observers,
     /// since the new archetype will not include any other components removed at the same time.
     ///
     /// Note that `None` should usually be treated the same as an archetype with no components,
diff --git a/crates/bevy_ecs/src/hierarchy.rs b/crates/bevy_ecs/src/hierarchy.rs
index 89a1a2e725a6e..9472a74730a8c 100644
--- a/crates/bevy_ecs/src/hierarchy.rs
+++ b/crates/bevy_ecs/src/hierarchy.rs
@@ -1156,7 +1156,7 @@ mod tests {
         assert_eq!(
             &**world.entity(parent).get::<Children>().unwrap(),
             &[child],
-            "Children should still have the old value, as on_insert/on_replace didn't run"
+            "Children should still have the old value, as on_insert/on_discard didn't run"
         );
     }
 }
diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index f88d924e76b20..7fd3ab19d9c1e 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -75,7 +75,7 @@ pub mod prelude {
         error::{BevyError, Result},
         event::{EntityEvent, Event},
         hierarchy::{ChildOf, ChildSpawner, ChildSpawnerCommands, Children},
-        lifecycle::{Add, Despawn, Insert, Remove, RemovedComponents, Replace},
+        lifecycle::{Add, Despawn, Discard, Insert, Remove, RemovedComponents},
         message::{
             Message, MessageMutator, MessageReader, MessageWriter, Messages, PopulatedMessageReader,
         },
diff --git a/crates/bevy_ecs/src/lifecycle.rs b/crates/bevy_ecs/src/lifecycle.rs
index 260d93c8e2e24..ace0dfd87abda 100644
--- a/crates/bevy_ecs/src/lifecycle.rs
+++ b/crates/bevy_ecs/src/lifecycle.rs
@@ -23,19 +23,19 @@
 //!
 //! Next, we have lifecycle events that are triggered when a component is removed from an entity:
 //!
-//! - [`Replace`]: Triggered when a component is removed from an entity, regardless if it is then replaced with a new value.
+//! - [`Discard`]: Triggered when a component is removed from an entity, regardless if it is then replaced with a new value.
 //! - [`Remove`]: Triggered when a component is removed from an entity and not replaced, before the component is removed.
 //! - [`Despawn`]: Triggered for each component on an entity when it is despawned.
 //!
-//! [`Replace`] hooks are evaluated before [`Remove`], then finally [`Despawn`] hooks are evaluated.
+//! [`Discard`] hooks are evaluated before [`Remove`], then finally [`Despawn`] hooks are evaluated.
 //!
 //! [`Add`] and [`Remove`] are counterparts: they are only triggered when a component is added or removed
 //! from an entity in such a way as to cause a change in the component's presence on that entity.
-//! Similarly, [`Insert`] and [`Replace`] are counterparts: they are triggered when a component is added or replaced
+//! Similarly, [`Insert`] and [`Discard`] are counterparts: they are triggered when a component is added or overwritten
 //! on an entity, regardless of whether this results in a change in the component's presence on that entity.
 //!
 //! To reliably synchronize data structures using with component lifecycle events,
-//! you can combine [`Insert`] and [`Replace`] to fully capture any changes to the data.
+//! you can combine [`Insert`] and [`Discard`] to fully capture any changes to the data.
 //! This is particularly useful in combination with immutable components,
 //! to avoid any lifecycle-bypassing mutations.
 //!
@@ -149,7 +149,7 @@ pub struct HookContext {
 pub struct ComponentHooks {
     pub(crate) on_add: Option<ComponentHook>,
     pub(crate) on_insert: Option<ComponentHook>,
-    pub(crate) on_replace: Option<ComponentHook>,
+    pub(crate) on_discard: Option<ComponentHook>,
     pub(crate) on_remove: Option<ComponentHook>,
     pub(crate) on_despawn: Option<ComponentHook>,
 }
@@ -162,8 +162,8 @@ impl ComponentHooks {
         if let Some(hook) = C::on_insert() {
             self.on_insert(hook);
         }
-        if let Some(hook) = C::on_replace() {
-            self.on_replace(hook);
+        if let Some(hook) = C::on_discard() {
+            self.on_discard(hook);
         }
         if let Some(hook) = C::on_remove() {
             self.on_remove(hook);
@@ -212,7 +212,7 @@ impl ComponentHooks {
     /// allowing access to the previous data just before it is dropped.
     /// This hook does *not* run if the entity did not already have this component.
     ///
-    /// An `on_replace` hook always runs before any `on_remove` hooks (if the component is being removed from the entity).
+    /// An `on_discard` hook always runs before any `on_remove` hooks (if the component is being removed from the entity).
     ///
     /// # Warning
     ///
@@ -221,10 +221,10 @@ impl ComponentHooks {
     ///
     /// # Panics
     ///
-    /// Will panic if the component already has an `on_replace` hook
-    pub fn on_replace(&mut self, hook: ComponentHook) -> &mut Self {
-        self.try_on_replace(hook)
-            .expect("Component already has an on_replace hook")
+    /// Will panic if the component already has an `on_discard` hook
+    pub fn on_discard(&mut self, hook: ComponentHook) -> &mut Self {
+        self.try_on_discard(hook)
+            .expect("Component already has an on_discard hook")
     }
 
     /// Register a [`ComponentHook`] that will be run when this component is removed from an entity.
@@ -276,14 +276,14 @@ impl ComponentHooks {
 
     /// Attempt to register a [`ComponentHook`] that will be run when this component is replaced (with `.insert`) or removed
     ///
-    /// This is a fallible version of [`Self::on_replace`].
+    /// This is a fallible version of [`Self::on_discard`].
     ///
-    /// Returns `None` if the component already has an `on_replace` hook.
-    pub fn try_on_replace(&mut self, hook: ComponentHook) -> Option<&mut Self> {
-        if self.on_replace.is_some() {
+    /// Returns `None` if the component already has an `on_discard` hook.
+    pub fn try_on_discard(&mut self, hook: ComponentHook) -> Option<&mut Self> {
+        if self.on_discard.is_some() {
             return None;
         }
-        self.on_replace = Some(hook);
+        self.on_discard = Some(hook);
         Some(self)
     }
 
@@ -318,8 +318,8 @@ impl ComponentHooks {
 pub const ADD: EventKey = EventKey(ComponentId::new(crate::component::ADD));
 /// [`EventKey`] for [`Insert`]
 pub const INSERT: EventKey = EventKey(ComponentId::new(crate::component::INSERT));
-/// [`EventKey`] for [`Replace`]
-pub const REPLACE: EventKey = EventKey(ComponentId::new(crate::component::REPLACE));
+/// [`EventKey`] for [`Discard`]
+pub const DISCARD: EventKey = EventKey(ComponentId::new(crate::component::DISCARD));
 /// [`EventKey`] for [`Remove`]
 pub const REMOVE: EventKey = EventKey(ComponentId::new(crate::component::REMOVE));
 /// [`EventKey`] for [`Despawn`]
@@ -355,14 +355,16 @@ pub struct Insert {
 /// of whether or not it is later replaced.
 ///
 /// Runs before the value is replaced, so you can still access the original component data.
-/// See [`ComponentHooks::on_replace`](`crate::lifecycle::ComponentHooks::on_replace`) for more information.
+/// See [`ComponentHooks::on_discard`](`crate::lifecycle::ComponentHooks::on_discard`) for more information.
 #[derive(Debug, Clone, EntityEvent)]
 #[entity_event(trigger = EntityComponentsTrigger<'a>)]
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 #[cfg_attr(feature = "bevy_reflect", reflect(Debug))]
+#[doc(alias = "OnDiscard")]
 #[doc(alias = "OnReplace")]
-pub struct Replace {
-    /// The entity that held this component before it was replaced.
+#[doc(alias = "Replace")]
+pub struct Discard {
+    /// The entity that held this component before it was discarded.
     pub entity: Entity,
 }
 
diff --git a/crates/bevy_ecs/src/observer/centralized_storage.rs b/crates/bevy_ecs/src/observer/centralized_storage.rs
index bd2df94af6d9c..8b09e95a0ec90 100644
--- a/crates/bevy_ecs/src/observer/centralized_storage.rs
+++ b/crates/bevy_ecs/src/observer/centralized_storage.rs
@@ -28,7 +28,7 @@ pub struct Observers {
     // Cached ECS observers to save a lookup for high-traffic built-in event types.
     add: CachedObservers,
     insert: CachedObservers,
-    replace: CachedObservers,
+    discard: CachedObservers,
     remove: CachedObservers,
     despawn: CachedObservers,
     // Map from event type to set of observers watching for that event
@@ -42,7 +42,7 @@ impl Observers {
         match event_key {
             ADD => &mut self.add,
             INSERT => &mut self.insert,
-            REPLACE => &mut self.replace,
+            DISCARD => &mut self.discard,
             REMOVE => &mut self.remove,
             DESPAWN => &mut self.despawn,
             _ => self.cache.entry(event_key).or_default(),
@@ -51,12 +51,12 @@ impl Observers {
 
     /// Attempts to get the observers for the given `event_key`.
     ///
-    /// When accessing the observers for lifecycle events, such as [`Add`], [`Insert`], [`Replace`], [`Remove`], and [`Despawn`],
+    /// When accessing the observers for lifecycle events, such as [`Add`], [`Insert`], [`Discard`], [`Remove`], and [`Despawn`],
     /// use the [`EventKey`] constants from the [`lifecycle`](crate::lifecycle) module.
     ///
     /// [`Add`]: crate::lifecycle::Add
     /// [`Insert`]: crate::lifecycle::Insert
-    /// [`Replace`]: crate::lifecycle::Replace
+    /// [`Discard`]: crate::lifecycle::Discard
     /// [`Remove`]: crate::lifecycle::Remove
     /// [`Despawn`]: crate::lifecycle::Despawn
     pub fn try_get_observers(&self, event_key: EventKey) -> Option<&CachedObservers> {
@@ -65,7 +65,7 @@ impl Observers {
         match event_key {
             ADD => Some(&self.add),
             INSERT => Some(&self.insert),
-            REPLACE => Some(&self.replace),
+            DISCARD => Some(&self.discard),
             REMOVE => Some(&self.remove),
             DESPAWN => Some(&self.despawn),
             _ => self.cache.get(&event_key),
@@ -78,7 +78,7 @@ impl Observers {
         match event_key {
             ADD => Some(ArchetypeFlags::ON_ADD_OBSERVER),
             INSERT => Some(ArchetypeFlags::ON_INSERT_OBSERVER),
-            REPLACE => Some(ArchetypeFlags::ON_REPLACE_OBSERVER),
+            DISCARD => Some(ArchetypeFlags::ON_DISCARD_OBSERVER),
             REMOVE => Some(ArchetypeFlags::ON_REMOVE_OBSERVER),
             DESPAWN => Some(ArchetypeFlags::ON_DESPAWN_OBSERVER),
             _ => None,
@@ -98,8 +98,8 @@ impl Observers {
             flags.insert(ArchetypeFlags::ON_INSERT_OBSERVER);
         }
 
-        if self.replace.component_observers.contains_key(&component_id) {
-            flags.insert(ArchetypeFlags::ON_REPLACE_OBSERVER);
+        if self.discard.component_observers.contains_key(&component_id) {
+            flags.insert(ArchetypeFlags::ON_DISCARD_OBSERVER);
         }
 
         if self.remove.component_observers.contains_key(&component_id) {
diff --git a/crates/bevy_ecs/src/observer/mod.rs b/crates/bevy_ecs/src/observer/mod.rs
index ae42035a77c26..a1e1b9217e70c 100644
--- a/crates/bevy_ecs/src/observer/mod.rs
+++ b/crates/bevy_ecs/src/observer/mod.rs
@@ -253,7 +253,7 @@ mod tests {
         error::Result,
         event::{EntityComponentsTrigger, Event, GlobalTrigger},
         hierarchy::ChildOf,
-        observer::{Observer, Replace},
+        observer::{Discard, Observer},
         prelude::*,
         world::DeferredWorld,
     };
@@ -304,15 +304,15 @@ mod tests {
 
         world.add_observer(|_: On<Add, A>, mut res: ResMut<Order>| res.observed("add"));
         world.add_observer(|_: On<Insert, A>, mut res: ResMut<Order>| res.observed("insert"));
-        world.add_observer(|_: On<Replace, A>, mut res: ResMut<Order>| {
-            res.observed("replace");
+        world.add_observer(|_: On<Discard, A>, mut res: ResMut<Order>| {
+            res.observed("discard");
         });
         world.add_observer(|_: On<Remove, A>, mut res: ResMut<Order>| res.observed("remove"));
 
         let entity = world.spawn(A).id();
         world.despawn(entity);
         assert_eq!(
-            vec!["add", "insert", "replace", "remove"],
+            vec!["add", "insert", "discard", "remove"],
             world.resource::<Order>().0
         );
     }
@@ -324,8 +324,8 @@ mod tests {
 
         world.add_observer(|_: On<Add, A>, mut res: ResMut<Order>| res.observed("add"));
         world.add_observer(|_: On<Insert, A>, mut res: ResMut<Order>| res.observed("insert"));
-        world.add_observer(|_: On<Replace, A>, mut res: ResMut<Order>| {
-            res.observed("replace");
+        world.add_observer(|_: On<Discard, A>, mut res: ResMut<Order>| {
+            res.observed("discard");
         });
         world.add_observer(|_: On<Remove, A>, mut res: ResMut<Order>| res.observed("remove"));
 
@@ -334,7 +334,7 @@ mod tests {
         entity.remove::<A>();
         entity.flush();
         assert_eq!(
-            vec!["add", "insert", "replace", "remove"],
+            vec!["add", "insert", "discard", "remove"],
             world.resource::<Order>().0
         );
     }
@@ -346,8 +346,8 @@ mod tests {
 
         world.add_observer(|_: On<Add, S>, mut res: ResMut<Order>| res.observed("add"));
         world.add_observer(|_: On<Insert, S>, mut res: ResMut<Order>| res.observed("insert"));
-        world.add_observer(|_: On<Replace, S>, mut res: ResMut<Order>| {
-            res.observed("replace");
+        world.add_observer(|_: On<Discard, S>, mut res: ResMut<Order>| {
+            res.observed("discard");
         });
         world.add_observer(|_: On<Remove, S>, mut res: ResMut<Order>| res.observed("remove"));
 
@@ -356,7 +356,7 @@ mod tests {
         entity.remove::<S>();
         entity.flush();
         assert_eq!(
-            vec!["add", "insert", "replace", "remove"],
+            vec!["add", "insert", "discard", "remove"],
             world.resource::<Order>().0
         );
     }
@@ -370,15 +370,15 @@ mod tests {
 
         world.add_observer(|_: On<Add, A>, mut res: ResMut<Order>| res.observed("add"));
         world.add_observer(|_: On<Insert, A>, mut res: ResMut<Order>| res.observed("insert"));
-        world.add_observer(|_: On<Replace, A>, mut res: ResMut<Order>| {
-            res.observed("replace");
+        world.add_observer(|_: On<Discard, A>, mut res: ResMut<Order>| {
+            res.observed("discard");
         });
         world.add_observer(|_: On<Remove, A>, mut res: ResMut<Order>| res.observed("remove"));
 
         let mut entity = world.entity_mut(entity);
         entity.insert(A);
         entity.flush();
-        assert_eq!(vec!["replace", "insert"], world.resource::<Order>().0);
+        assert_eq!(vec!["discard", "insert"], world.resource::<Order>().0);
     }
 
     #[test]
@@ -1353,7 +1353,7 @@ mod tests {
 
         world.add_observer(observer::<Add>);
         world.add_observer(observer::<Insert>);
-        world.add_observer(observer::<Replace>);
+        world.add_observer(observer::<Discard>);
         world.add_observer(observer::<Remove>);
         world.add_observer(observer::<Despawn>);
 
@@ -1368,14 +1368,14 @@ mod tests {
             &[
                 ("bevy_ecs::lifecycle::Add", None, Some(ab)),
                 ("bevy_ecs::lifecycle::Insert", None, Some(ab)),
-                ("bevy_ecs::lifecycle::Replace", Some(ab), Some(empty)),
+                ("bevy_ecs::lifecycle::Discard", Some(ab), Some(empty)),
                 ("bevy_ecs::lifecycle::Remove", Some(ab), Some(empty)),
                 ("bevy_ecs::lifecycle::Add", Some(empty), Some(a)),
                 ("bevy_ecs::lifecycle::Insert", Some(empty), Some(a)),
-                ("bevy_ecs::lifecycle::Replace", Some(a), Some(a)),
+                ("bevy_ecs::lifecycle::Discard", Some(a), Some(a)),
                 ("bevy_ecs::lifecycle::Insert", Some(a), Some(a)),
                 ("bevy_ecs::lifecycle::Despawn", Some(a), None),
-                ("bevy_ecs::lifecycle::Replace", Some(a), None),
+                ("bevy_ecs::lifecycle::Discard", Some(a), None),
                 ("bevy_ecs::lifecycle::Remove", Some(a), None),
             ],
         );
diff --git a/crates/bevy_ecs/src/relationship/mod.rs b/crates/bevy_ecs/src/relationship/mod.rs
index 68ed3f2904cf7..a484dbfc0cee8 100644
--- a/crates/bevy_ecs/src/relationship/mod.rs
+++ b/crates/bevy_ecs/src/relationship/mod.rs
@@ -121,7 +121,7 @@ pub trait Relationship: Component + Sized {
     /// # Warning
     ///
     /// This should generally not be called by user code, as modifying the related entity could invalidate the
-    /// relationship. If this method is used, then the hooks [`on_replace`](Relationship::on_replace) have to
+    /// relationship. If this method is used, then the hooks [`on_discard`](Relationship::on_discard) have to
     /// run before and [`on_insert`](Relationship::on_insert) after it.
     /// This happens automatically when this method is called with [`EntityWorldMut::modify_component`].
     ///
@@ -196,9 +196,9 @@ pub trait Relationship: Component + Sized {
         }
     }
 
-    /// The `on_replace` component hook that maintains the [`Relationship`] / [`RelationshipTarget`] connection.
+    /// The `on_discard` component hook that maintains the [`Relationship`] / [`RelationshipTarget`] connection.
     // note: think of this as "on_drop"
-    fn on_replace(
+    fn on_discard(
         mut world: DeferredWorld,
         HookContext {
             entity,
@@ -284,9 +284,9 @@ pub trait RelationshipTarget: Component<Mutability = Mutable> + Sized {
     /// The collection should not contain duplicates.
     fn from_collection_risky(collection: Self::Collection) -> Self;
 
-    /// The `on_replace` component hook that maintains the [`Relationship`] / [`RelationshipTarget`] connection.
+    /// The `on_discard` component hook that maintains the [`Relationship`] / [`RelationshipTarget`] connection.
     // note: think of this as "on_drop"
-    fn on_replace(
+    fn on_discard(
         mut world: DeferredWorld,
         HookContext {
             entity,
@@ -380,14 +380,14 @@ pub fn clone_relationship_target<T: RelationshipTarget>(
     }
 }
 
-/// Configures the conditions under which the Relationship insert/replace hooks will be run.
+/// Configures the conditions under which the Relationship insert/discard hooks will be run.
 #[derive(Copy, Clone, Debug)]
 pub enum RelationshipHookMode {
-    /// Relationship insert/replace hooks will always run
+    /// Relationship insert/discard hooks will always run
     Run,
-    /// Relationship insert/replace hooks will run if [`RelationshipTarget::LINKED_SPAWN`] is false
+    /// Relationship insert/discard hooks will run if [`RelationshipTarget::LINKED_SPAWN`] is false
     RunIfNotLinked,
-    /// Relationship insert/replace hooks will always be skipped
+    /// Relationship insert/discard hooks will always be skipped
     Skip,
 }
 
diff --git a/crates/bevy_ecs/src/relationship/related_methods.rs b/crates/bevy_ecs/src/relationship/related_methods.rs
index 75bdad1604385..ae715a9fd46a0 100644
--- a/crates/bevy_ecs/src/relationship/related_methods.rs
+++ b/crates/bevy_ecs/src/relationship/related_methods.rs
@@ -888,7 +888,7 @@ mod tests {
 
     #[test]
     fn despawn_related_observers_can_access_relationship_data() {
-        use crate::lifecycle::Replace;
+        use crate::lifecycle::Discard;
         use crate::observer::On;
         use crate::prelude::Has;
         use crate::system::Query;
@@ -905,7 +905,7 @@ mod tests {
         let result_entity = world.spawn(ObserverResult::default()).id();
 
         world.add_observer(
-            move |replace: On<Replace, MyComponent>,
+            move |replace: On<Discard, MyComponent>,
                   has_relationship: Query<Has<ChildOf>>,
                   mut results: Query<&mut ObserverResult>| {
                 if has_relationship.get(replace.entity).unwrap_or(false) {
diff --git a/crates/bevy_ecs/src/resource.rs b/crates/bevy_ecs/src/resource.rs
index 693ba2b45563e..a94fa13277efc 100644
--- a/crates/bevy_ecs/src/resource.rs
+++ b/crates/bevy_ecs/src/resource.rs
@@ -113,7 +113,7 @@ impl DerefMut for ResourceEntities {
 /// A marker component for entities that have a Resource component.
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect), reflect(Component, Debug))]
 #[derive(Component, Debug)]
-#[component(on_insert, on_replace, on_despawn)]
+#[component(on_insert, on_discard, on_despawn)]
 pub struct IsResource(ComponentId);
 
 impl IsResource {
@@ -174,7 +174,7 @@ impl IsResource {
         }
     }
 
-    pub(crate) fn on_replace(mut world: DeferredWorld, context: HookContext) {
+    pub(crate) fn on_discard(mut world: DeferredWorld, context: HookContext) {
         let resource_component_id = world
             .entity(context.entity)
             .get::<Self>()
diff --git a/crates/bevy_ecs/src/world/deferred_world.rs b/crates/bevy_ecs/src/world/deferred_world.rs
index 229389c09d03f..e6fd07d0fad93 100644
--- a/crates/bevy_ecs/src/world/deferred_world.rs
+++ b/crates/bevy_ecs/src/world/deferred_world.rs
@@ -8,7 +8,7 @@ use crate::{
     component::{ComponentId, Mutable},
     entity::Entity,
     event::{EntityComponentsTrigger, Event, EventKey, Trigger},
-    lifecycle::{HookContext, Insert, Replace, INSERT, REPLACE},
+    lifecycle::{Discard, HookContext, Insert, DISCARD, INSERT},
     message::{Message, MessageId, Messages, WriteBatchIds},
     observer::TriggerContext,
     prelude::{Component, QueryState},
@@ -93,7 +93,7 @@ impl<'w> DeferredWorld<'w> {
 
     /// Temporarily removes a [`Component`] `T` from the provided [`Entity`] and
     /// runs the provided closure on it, returning the result if `T` was available.
-    /// This will trigger the `Remove` and `Replace` component hooks without
+    /// This will trigger the `Remove` and `Discard` component hooks without
     /// causing an archetype move.
     ///
     /// This is most useful with immutable components, where removal and reinsertion
@@ -130,7 +130,7 @@ impl<'w> DeferredWorld<'w> {
     /// Temporarily removes a [`Component`] identified by the provided
     /// [`ComponentId`] from the provided [`Entity`] and runs the provided
     /// closure on it, returning the result if the component was available.
-    /// This will trigger the `Remove` and `Replace` component hooks without
+    /// This will trigger the `Remove` and `Discard` component hooks without
     /// causing an archetype move.
     ///
     /// This is most useful with immutable components, where removal and reinsertion
@@ -162,21 +162,21 @@ impl<'w> DeferredWorld<'w> {
         // - DeferredWorld ensures archetype pointer will remain valid as no
         //   relocations will occur.
         // - component_id exists on this world and this entity
-        // - REPLACE is able to accept ZST events
+        // - DISCARD is able to accept ZST events
         unsafe {
             let archetype = &*archetype;
-            self.trigger_on_replace(
+            self.trigger_on_discard(
                 archetype,
                 entity,
                 [component_id].into_iter(),
                 MaybeLocation::caller(),
                 relationship_hook_mode,
             );
-            if archetype.has_replace_observer() {
-                // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+            if archetype.has_discard_observer() {
+                // SAFETY: the DISCARD event_key corresponds to the Discard event's type
                 self.trigger_raw(
-                    REPLACE,
-                    &mut Replace { entity },
+                    DISCARD,
+                    &mut Discard { entity },
                     &mut EntityComponentsTrigger {
                         components: &[component_id],
                         old_archetype: Some(archetype),
@@ -207,7 +207,7 @@ impl<'w> DeferredWorld<'w> {
         // - DeferredWorld ensures archetype pointer will remain valid as no
         //   relocations will occur.
         // - component_id exists on this world and this entity
-        // - REPLACE is able to accept ZST events
+        // - DISCARD is able to accept ZST events
         unsafe {
             let archetype = &*archetype;
             self.trigger_on_insert(
@@ -679,12 +679,12 @@ impl<'w> DeferredWorld<'w> {
         }
     }
 
-    /// Triggers all `on_replace` hooks for [`ComponentId`] in target.
+    /// Triggers all `on_discard` hooks for [`ComponentId`] in target.
     ///
     /// # Safety
     /// Caller must ensure [`ComponentId`] in target exist in self.
     #[inline]
-    pub(crate) unsafe fn trigger_on_replace(
+    pub(crate) unsafe fn trigger_on_discard(
         &mut self,
         archetype: &Archetype,
         entity: Entity,
@@ -692,11 +692,11 @@ impl<'w> DeferredWorld<'w> {
         caller: MaybeLocation,
         relationship_hook_mode: RelationshipHookMode,
     ) {
-        if archetype.has_replace_hook() {
+        if archetype.has_discard_hook() {
             for component_id in targets {
                 // SAFETY: Caller ensures that these components exist
                 let hooks = unsafe { self.components().get_info_unchecked(component_id) }.hooks();
-                if let Some(hook) = hooks.on_replace {
+                if let Some(hook) = hooks.on_discard {
                     hook(
                         DeferredWorld { world: self.world },
                         HookContext {
diff --git a/crates/bevy_ecs/src/world/entity_access/mod.rs b/crates/bevy_ecs/src/world/entity_access/mod.rs
index 5928c663aaa4d..a4a63e76d2cf3 100644
--- a/crates/bevy_ecs/src/world/entity_access/mod.rs
+++ b/crates/bevy_ecs/src/world/entity_access/mod.rs
@@ -1231,7 +1231,7 @@ mod tests {
     struct TestVec(Vec<&'static str>);
 
     #[derive(Component)]
-    #[component(on_add = ord_a_hook_on_add, on_insert = ord_a_hook_on_insert, on_replace = ord_a_hook_on_replace, on_remove = ord_a_hook_on_remove)]
+    #[component(on_add = ord_a_hook_on_add, on_insert = ord_a_hook_on_insert, on_discard = ord_a_hook_on_discard, on_remove = ord_a_hook_on_remove)]
     struct OrdA;
 
     fn ord_a_hook_on_add(mut world: DeferredWorld, HookContext { entity, .. }: HookContext) {
@@ -1248,11 +1248,11 @@ mod tests {
         world.commands().entity(entity).remove::<OrdB>();
     }
 
-    fn ord_a_hook_on_replace(mut world: DeferredWorld, _: HookContext) {
+    fn ord_a_hook_on_discard(mut world: DeferredWorld, _: HookContext) {
         world
             .resource_mut::<TestVec>()
             .0
-            .push("OrdA hook on_replace");
+            .push("OrdA hook on_discard");
     }
 
     fn ord_a_hook_on_remove(mut world: DeferredWorld, _: HookContext) {
@@ -1270,8 +1270,8 @@ mod tests {
         res.0.push("OrdA observer on_insert");
     }
 
-    fn ord_a_observer_on_replace(_event: On<Replace, OrdA>, mut res: ResMut<TestVec>) {
-        res.0.push("OrdA observer on_replace");
+    fn ord_a_observer_on_discard(_event: On<Discard, OrdA>, mut res: ResMut<TestVec>) {
+        res.0.push("OrdA observer on_discard");
     }
 
     fn ord_a_observer_on_remove(_event: On<Remove, OrdA>, mut res: ResMut<TestVec>) {
@@ -1279,7 +1279,7 @@ mod tests {
     }
 
     #[derive(Component)]
-    #[component(on_add = ord_b_hook_on_add, on_insert = ord_b_hook_on_insert, on_replace = ord_b_hook_on_replace, on_remove = ord_b_hook_on_remove)]
+    #[component(on_add = ord_b_hook_on_add, on_insert = ord_b_hook_on_insert, on_discard = ord_b_hook_on_discard, on_remove = ord_b_hook_on_remove)]
     struct OrdB;
 
     fn ord_b_hook_on_add(mut world: DeferredWorld, _: HookContext) {
@@ -1299,11 +1299,11 @@ mod tests {
             .push("OrdB hook on_insert");
     }
 
-    fn ord_b_hook_on_replace(mut world: DeferredWorld, _: HookContext) {
+    fn ord_b_hook_on_discard(mut world: DeferredWorld, _: HookContext) {
         world
             .resource_mut::<TestVec>()
             .0
-            .push("OrdB hook on_replace");
+            .push("OrdB hook on_discard");
     }
 
     fn ord_b_hook_on_remove(mut world: DeferredWorld, _: HookContext) {
@@ -1321,8 +1321,8 @@ mod tests {
         res.0.push("OrdB observer on_insert");
     }
 
-    fn ord_b_observer_on_replace(_event: On<Replace, OrdB>, mut res: ResMut<TestVec>) {
-        res.0.push("OrdB observer on_replace");
+    fn ord_b_observer_on_discard(_event: On<Discard, OrdB>, mut res: ResMut<TestVec>) {
+        res.0.push("OrdB observer on_discard");
     }
 
     fn ord_b_observer_on_remove(_event: On<Remove, OrdB>, mut res: ResMut<TestVec>) {
@@ -1335,11 +1335,11 @@ mod tests {
         world.insert_resource(TestVec(Vec::new()));
         world.add_observer(ord_a_observer_on_add);
         world.add_observer(ord_a_observer_on_insert);
-        world.add_observer(ord_a_observer_on_replace);
+        world.add_observer(ord_a_observer_on_discard);
         world.add_observer(ord_a_observer_on_remove);
         world.add_observer(ord_b_observer_on_add);
         world.add_observer(ord_b_observer_on_insert);
-        world.add_observer(ord_b_observer_on_replace);
+        world.add_observer(ord_b_observer_on_discard);
         world.add_observer(ord_b_observer_on_remove);
         let _entity = world.spawn(OrdA).id();
         let expected = [
@@ -1352,12 +1352,12 @@ mod tests {
             "OrdB hook on_insert",
             "OrdB observer on_insert",
             "OrdB command on_add", // command added by OrdB hook on_add, needs to run before despawn command
-            "OrdA observer on_replace", // start of despawn
-            "OrdA hook on_replace",
+            "OrdA observer on_discard", // start of despawn
+            "OrdA hook on_discard",
             "OrdA observer on_remove",
             "OrdA hook on_remove",
-            "OrdB observer on_replace",
-            "OrdB hook on_replace",
+            "OrdB observer on_discard",
+            "OrdB hook on_discard",
             "OrdB observer on_remove",
             "OrdB hook on_remove",
         ];
@@ -1531,7 +1531,7 @@ mod tests {
 
         static ADD_COUNT: AtomicU8 = AtomicU8::new(0);
         static REMOVE_COUNT: AtomicU8 = AtomicU8::new(0);
-        static REPLACE_COUNT: AtomicU8 = AtomicU8::new(0);
+        static DISCARD_COUNT: AtomicU8 = AtomicU8::new(0);
         static INSERT_COUNT: AtomicU8 = AtomicU8::new(0);
 
         let mut world = World::default();
@@ -1555,8 +1555,8 @@ mod tests {
                     Some(&Foo(EXPECTED_VALUE.load(Ordering::Relaxed)))
                 );
             })
-            .on_replace(|world, context| {
-                REPLACE_COUNT.fetch_add(1, Ordering::Relaxed);
+            .on_discard(|world, context| {
+                DISCARD_COUNT.fetch_add(1, Ordering::Relaxed);
 
                 assert_eq!(
                     world.get(context.entity),
@@ -1576,7 +1576,7 @@ mod tests {
 
         assert_eq!(ADD_COUNT.load(Ordering::Relaxed), 1);
         assert_eq!(REMOVE_COUNT.load(Ordering::Relaxed), 0);
-        assert_eq!(REPLACE_COUNT.load(Ordering::Relaxed), 0);
+        assert_eq!(DISCARD_COUNT.load(Ordering::Relaxed), 0);
         assert_eq!(INSERT_COUNT.load(Ordering::Relaxed), 1);
 
         let mut entity = world.entity_mut(entity);
@@ -1596,7 +1596,7 @@ mod tests {
 
         assert_eq!(ADD_COUNT.load(Ordering::Relaxed), 1);
         assert_eq!(REMOVE_COUNT.load(Ordering::Relaxed), 0);
-        assert_eq!(REPLACE_COUNT.load(Ordering::Relaxed), 1);
+        assert_eq!(DISCARD_COUNT.load(Ordering::Relaxed), 1);
         assert_eq!(INSERT_COUNT.load(Ordering::Relaxed), 2);
 
         assert_eq!(archetype_pointer_before, archetype_pointer_after);
diff --git a/crates/bevy_ecs/src/world/entity_access/world_mut.rs b/crates/bevy_ecs/src/world/entity_access/world_mut.rs
index e4b4e4e10a837..6e6d309add84d 100644
--- a/crates/bevy_ecs/src/world/entity_access/world_mut.rs
+++ b/crates/bevy_ecs/src/world/entity_access/world_mut.rs
@@ -7,7 +7,7 @@ use crate::{
     component::{Component, ComponentId, Components, Mutable, StorageType},
     entity::{Entity, EntityCloner, EntityClonerBuilder, EntityLocation, OptIn, OptOut},
     event::{EntityComponentsTrigger, EntityEvent},
-    lifecycle::{Despawn, Remove, Replace, DESPAWN, REMOVE, REPLACE},
+    lifecycle::{Despawn, Discard, Remove, DESPAWN, DISCARD, REMOVE},
     observer::IntoEntityObserver,
     query::{
         has_conflicts, DebugCheckedUnwrap, QueryAccessError, ReadOnlyQueryData,
@@ -520,7 +520,7 @@ impl<'w> EntityWorldMut<'w> {
 
     /// Temporarily removes a [`Component`] `T` from this [`Entity`] and runs the
     /// provided closure on it, returning the result if `T` was available.
-    /// This will trigger the `Remove` and `Replace` component hooks without
+    /// This will trigger the `Remove` and `Discard` component hooks without
     /// causing an archetype move.
     ///
     /// This is most useful with immutable components, where removal and reinsertion
@@ -573,7 +573,7 @@ impl<'w> EntityWorldMut<'w> {
 
     /// Temporarily removes a [`Component`] `T` from this [`Entity`] and runs the
     /// provided closure on it, returning the result if `T` was available.
-    /// This will trigger the `Remove` and `Replace` component hooks without
+    /// This will trigger the `Remove` and `Discard` component hooks without
     /// causing an archetype move.
     ///
     /// This is most useful with immutable components, where removal and reinsertion
@@ -1613,11 +1613,11 @@ impl<'w> EntityWorldMut<'w> {
                 archetype.iter_components(),
                 caller,
             );
-            if archetype.has_replace_observer() {
-                // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+            if archetype.has_discard_observer() {
+                // SAFETY: the DISCARD event_key corresponds to the Discard event's type
                 deferred_world.trigger_raw(
-                    REPLACE,
-                    &mut Replace {
+                    DISCARD,
+                    &mut Discard {
                         entity: self.entity,
                     },
                     &mut EntityComponentsTrigger {
@@ -1628,7 +1628,7 @@ impl<'w> EntityWorldMut<'w> {
                     caller,
                 );
             }
-            deferred_world.trigger_on_replace(
+            deferred_world.trigger_on_discard(
                 archetype,
                 self.entity,
                 archetype.iter_components(),
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index 568bbc0bd35f5..f95f6811ab29a 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -51,10 +51,10 @@ use crate::{
     entity::{Entities, Entity, EntityAllocator, EntityNotSpawnedError, SpawnError},
     entity_disabling::DefaultQueryFilters,
     error::{DefaultErrorHandler, ErrorHandler},
-    lifecycle::{ComponentHooks, RemovedComponentMessages, ADD, DESPAWN, INSERT, REMOVE, REPLACE},
+    lifecycle::{ComponentHooks, RemovedComponentMessages, ADD, DESPAWN, DISCARD, INSERT, REMOVE},
     message::{Message, MessageId, Messages, WriteBatchIds},
     observer::Observers,
-    prelude::{Add, Despawn, DetectChangesMut, Insert, Remove, Replace},
+    prelude::{Add, Despawn, DetectChangesMut, Discard, Insert, Remove},
     query::{DebugCheckedUnwrap, QueryData, QueryFilter, QueryState},
     relationship::RelationshipHookMode,
     resource::{IsResource, Resource, ResourceEntities, IS_RESOURCE},
@@ -166,8 +166,8 @@ impl World {
         let on_insert = self.register_event_key::<Insert>();
         assert_eq!(INSERT, on_insert);
 
-        let on_replace = self.register_event_key::<Replace>();
-        assert_eq!(REPLACE, on_replace);
+        let on_discard = self.register_event_key::<Discard>();
+        assert_eq!(DISCARD, on_discard);
 
         let on_remove = self.register_event_key::<Remove>();
         assert_eq!(REMOVE, on_remove);
@@ -1390,7 +1390,7 @@ impl World {
 
     /// Temporarily removes a [`Component`] `T` from the provided [`Entity`] and
     /// runs the provided closure on it, returning the result if `T` was available.
-    /// This will trigger the `Remove` and `Replace` component hooks without
+    /// This will trigger the `Remove` and `Discard` component hooks without
     /// causing an archetype move.
     ///
     /// This is most useful with immutable components, where removal and reinsertion
@@ -1441,7 +1441,7 @@ impl World {
     /// Temporarily removes a [`Component`] identified by the provided
     /// [`ComponentId`] from the provided [`Entity`] and runs the provided
     /// closure on it, returning the result if the component was available.
-    /// This will trigger the `Remove` and `Replace` component hooks without
+    /// This will trigger the `Remove` and `Discard` component hooks without
     /// causing an archetype move.
     ///
     /// This is most useful with immutable components, where removal and reinsertion
diff --git a/examples/ecs/component_hooks.rs b/examples/ecs/component_hooks.rs
index 5fb6bc1bf6314..77d6573a4aaf7 100644
--- a/examples/ecs/component_hooks.rs
+++ b/examples/ecs/component_hooks.rs
@@ -25,7 +25,7 @@ use std::collections::HashMap;
 /// using [`Component`] derive macro:
 /// ```no_run
 /// #[derive(Component)]
-/// #[component(on_add = ..., on_insert = ..., on_replace = ..., on_remove = ...)]
+/// #[component(on_add = ..., on_insert = ..., on_discard = ..., on_remove = ...)]
 /// ```
 struct MyComponent(KeyCode);
 
@@ -65,7 +65,7 @@ fn setup(world: &mut World) {
     // This is to prevent overriding hooks defined in plugins and other crates as well as keeping things fast
     world
         .register_component_hooks::<MyComponent>()
-        // There are 4 component lifecycle hooks: `on_add`, `on_insert`, `on_replace` and `on_remove`
+        // There are 4 component lifecycle hooks: `on_add`, `on_insert`, `on_discard` and `on_remove`
         // A hook has 2 arguments:
         // - a `DeferredWorld`, this allows access to resource and component data as well as `Commands`
         // - a `HookContext`, this provides access to the following contextual information:
@@ -103,10 +103,10 @@ fn setup(world: &mut World) {
         .on_insert(|world, _| {
             println!("Current Index: {:?}", world.resource::<MyComponentIndex>());
         })
-        // `on_replace` will trigger when a component is inserted onto an entity that already had it,
+        // `on_discard` will trigger when a component is inserted onto an entity that already had it,
         // and runs before the value is replaced.
         // Also triggers when a component is removed from an entity, and runs before `on_remove`
-        .on_replace(|mut world, context| {
+        .on_discard(|mut world, context| {
             let value = world.get::<MyComponent>(context.entity).unwrap().0;
             world.resource_mut::<MyComponentIndex>().remove(&value);
         })
diff --git a/examples/ecs/immutable_components.rs b/examples/ecs/immutable_components.rs
index a4e282af61967..fec29d0f9dafc 100644
--- a/examples/ecs/immutable_components.rs
+++ b/examples/ecs/immutable_components.rs
@@ -54,7 +54,7 @@ fn demo_1(world: &mut World) {
     // these component hooks. This allows for keeping other parts of the ECS synced
     // to a component's value at all times.
     on_insert = on_insert_name,
-    on_replace = on_replace_name,
+    on_discard = on_discard_name,
 )]
 pub struct Name(pub &'static str);
 
@@ -89,9 +89,9 @@ fn on_insert_name(mut world: DeferredWorld<'_>, HookContext { entity, .. }: Hook
 ///
 /// Since all mutations to [`Name`] are captured by hooks, we know it is currently
 /// inserted in the index.
-fn on_replace_name(mut world: DeferredWorld<'_>, HookContext { entity, .. }: HookContext) {
+fn on_discard_name(mut world: DeferredWorld<'_>, HookContext { entity, .. }: HookContext) {
     let Some(&name) = world.entity(entity).get::<Name>() else {
-        unreachable!("Replace hook guarantees `Name` is available on entity")
+        unreachable!("Discard hook guarantees `Name` is available on entity")
     };
     let Some(mut index) = world.get_resource_mut::<NameIndex>() else {
         return;
diff --git a/release-content/migration-guides/lifecycle-events.md b/release-content/migration-guides/lifecycle-events.md
new file mode 100644
index 0000000000000..f8d04850c03cd
--- /dev/null
+++ b/release-content/migration-guides/lifecycle-events.md
@@ -0,0 +1,8 @@
+---
+title: Lifecycle event changes
+pull_requests: [22789]
+---
+
+`Replace` has been renamed to `Discard` and `ComponentHooks::on_replace` has been renamed to `ComponentHooks::on_discard`.
+The `#[component(on_replace = ...)]` derive attribute is now `#[component(on_discard = ...)]`.
+Replace all references and imports.
