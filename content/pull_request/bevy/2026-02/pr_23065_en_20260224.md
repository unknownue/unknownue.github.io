+++
title = "#23065 Fix unsound access of component metadata (change ticks) in `bevy_ecs::storage::Table`"
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-23065-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-23065-zh-cn-20260224" }}
labels = ["C-Bug", "A-ECS", "P-Unsound", "D-Straightforward", "D-Unsafe"]
+++

# Title

## Basic Information
- **Title**: Fix unsound access of component metadata (change ticks) in `bevy_ecs::storage::Table`
- **PR Link**: https://github.com/bevyengine/bevy/pull/23065
- **Author**: nils-mathieu
- **Status**: MERGED
- **Labels**: C-Bug, A-ECS, S-Ready-For-Final-Review, P-Unsound, D-Straightforward, D-Unsafe
- **Created**: 2026-02-20T04:29:43Z
- **Merged**: 2026-02-24T01:50:21Z
- **Merged By**: alice-i-cecile

## Description Translation
This pull request changes three functions in `bevy_ecs/src/storage/table/mod.rs` which currently may incorrectly access an out of bounds element.

Currently those functions use the following pattern to guard against invalid `TableRow`:

```Rust
/// Get the specific [`change tick`](Tick) of the component matching `component_id` in `row`.
pub fn get_changed_tick(
  &self,
  component_id: ComponentId,
  row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
  (row.index_u32() < self.entity_count()).then_some(
    // SAFETY: `row.as_usize()` < `len`
    unsafe {
      self.get_column(component_id)?
        .changed_ticks
        .get_unchecked(row.index())
    },
  )
}
```

The usage of `then_some` is invalid here because it takes its input by value, which evaluates the `get_unchecked` call instantly even if `row.index_u32() < self.entity_count()` is `false`.

Calling `get_unchecked` with an invalid index triggers instant undefined behavior even if the value is not used.

## Solution

We can't really use `then` instead of `then_some` because `self.get_column` can fail by returning `None`, so I opted for a regular `if` guard like this:

```Rust
/// Get the specific [`change tick`](Tick) of the component matching `component_id` in `row`.
pub fn get_changed_tick(
  &self,
  component_id: ComponentId,
  row: TableRow,
) -> Option<&UnsafeCell<Tick>> {
  if row.index_u32() >= self.entity_count() {
    return None;
  }

  // SAFETY: `row.as_usize()` < `len`
  self.get_column(component_id)
    .map(|col| unsafe { col.changed_ticks.get_unchecked(row.index()) })
}
```

## Testing

I tried to run the CI on the whole thing but my version of clippy (nightly) is triggered by other parts of the code and I was too lazy to install Rust stable and re-compile everything again. I will fix anything that fails in CI here and re-check everything locally if it turns out to fail.

## Other Notes

I'm not familiar with the codebase (well, I've been reading an poking around for a bit but I don't know everything), so there might be other places in the code with the same issue. I grep'ed `then_some` and found no other instance of the same problem, so at least it doesn't appear anywhere else in this form.

## The Story of This Pull Request

This PR addresses a subtle but critical soundness issue in Bevy's Entity Component System (ECS) storage layer. The problem centered around three methods in the `Table` struct that retrieve component metadata - specifically change ticks and change locations. These methods were using a seemingly safe pattern that actually contained undefined behavior when called with out-of-bounds indices.

The core issue was in the use of `then_some()` combined with unsafe operations. In Rust, `bool::then_some()` evaluates its argument eagerly, before checking the boolean condition. This meant that even when `row.index_u32() < self.entity_count()` was false, the unsafe `get_unchecked()` call would still execute with an invalid index, violating Rust's safety guarantees and causing immediate undefined behavior.

Looking at the original code, the intent was clear: first check if the row index is within bounds, and only then perform the unsafe array access. The developer used `then_some()` presumably for conciseness, not realizing that it evaluates the closure argument unconditionally. This is a common pitfall when mixing safe Rust control flow with unsafe operations.

The fix is straightforward: replace the `then_some()` pattern with explicit early returns. By checking the bounds condition first and returning `None` immediately when out of bounds, we ensure the unsafe code only runs when the index is valid. The solution maintains the same API while eliminating the undefined behavior.

What's interesting about this fix is that it highlights an important principle in Rust: unsafe operations require careful consideration of evaluation order. Even seemingly safe wrapper functions like `then_some()` can introduce issues when combined with unsafe code. The fix demonstrates the importance of explicit control flow when safety depends on condition evaluation order.

The implementation changes affect three similar methods in the `Table` struct:
1. `get_changed_tick()` - retrieves when a component was last changed
2. `get_added_tick()` - retrieves when a component was added
3. `get_changed_location()` - retrieves the source code location where a component was changed

Each method follows the same pattern: check bounds, retrieve the appropriate column, then access the specific element using `get_unchecked()`. The fix ensures the bounds check happens before any unsafe operations, preserving the safety invariant that `get_unchecked()` is only called with valid indices.

This PR also illustrates how even experienced Rust developers can introduce subtle soundness issues. The original code looked reasonable at first glance, but contained a critical flaw in evaluation order. The fix is minimal and focused, addressing exactly the issue without refactoring unrelated code.

## Visual Representation

```mermaid
graph TD
    A[Table.get_changed_tick()] --> B{Bounds check row < entity_count?}
    B -->|No| C[Return None]
    B -->|Yes| D[Get column for component_id]
    D --> E{Column exists?}
    E -->|No| F[Return None]
    E -->|Yes| G[Call get_unchecked(row.index())]
    G --> H[Return Some(&UnsafeCell<Tick>)]
```

## Key Files Changed

### `crates/bevy_ecs/src/storage/table/mod.rs` (+24/-25)

This file contains the `Table` struct implementation for Bevy's ECS storage system. The changes fix unsound bounds checking in three methods that access component metadata.

**Key modifications:**

1. **`get_changed_tick()` method** - Fixed bounds checking before unsafe access:

```rust
// Before:
pub fn get_changed_tick(&self, component_id: ComponentId, row: TableRow) -> Option<&UnsafeCell<Tick>> {
    (row.index_u32() < self.entity_count()).then_some(
        // SAFETY: `row.as_usize()` < `len`
        unsafe {
            self.get_column(component_id)?
                .changed_ticks
                .get_unchecked(row.index())
        },
    )
}

// After:
pub fn get_changed_tick(&self, component_id: ComponentId, row: TableRow) -> Option<&UnsafeCell<Tick>> {
    if row.index_u32() >= self.entity_count() {
        return None;
    }
    
    // SAFETY: `row.index()` < `len`
    self.get_column(component_id)
        .map(|col| unsafe { col.changed_ticks.get_unchecked(row.index()) })
}
```

2. **`get_added_tick()` method** - Same pattern fix for added ticks:

```rust
// Before:
pub fn get_added_tick(&self, component_id: ComponentId, row: TableRow) -> Option<&UnsafeCell<Tick>> {
    (row.index_u32() < self.entity_count()).then_some(
        // SAFETY: `row.as_usize()` < `len`
        unsafe {
            self.get_column(component_id)?
                .added_ticks
                .get_unchecked(row.index())
        },
    )
}

// After:
pub fn get_added_tick(&self, component_id: ComponentId, row: TableRow) -> Option<&UnsafeCell<Tick>> {
    if row.index_u32() >= self.entity_count() {
        return None;
    }
    
    // SAFETY: `row.index()` < `len`
    self.get_column(component_id)
        .map(|col| unsafe { col.added_ticks.get_unchecked(row.index()) })
}
```

3. **`get_changed_location()` method** - Same fix for change location tracking:

```rust
// Before:
pub fn get_changed_location(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> MaybeLocation<Option<&UnsafeCell<&'static Location<'static>>>> {
    MaybeLocation::new_with_flattened(|| {
        (row.index_u32() < self.entity_count()).then_some(
            // SAFETY: `row.as_usize()` < `len`
            unsafe {
                self.get_column(component_id)?
                    .changed_by
                    .as_ref()
                    .map(|changed_by| changed_by.get_unchecked(row.index()))
            },
        )
    })
}

// After:
pub fn get_changed_location(
    &self,
    component_id: ComponentId,
    row: TableRow,
) -> MaybeLocation<Option<&UnsafeCell<&'static Location<'static>>>> {
    MaybeLocation::new_with_flattened(|| {
        if row.index_u32() >= self.entity_count() {
            return None;
        }
        
        self.get_column(component_id).map(|col| {
            // SAFETY: `row.index()` < `len`
            col.changed_by
                .as_ref()
                .map(|changed_by| unsafe { changed_by.get_unchecked(row.index()) })
        })
    })
}
```

## Further Reading

1. **Rust `bool::then_some()` documentation** - Understanding the eager evaluation behavior: https://doc.rust-lang.org/std/primitive.bool.html#method.then_some
2. **Rust Unsafe Code Guidelines** - Best practices for writing safe unsafe code: https://rust-lang.github.io/unsafe-code-guidelines/
3. **Bevy ECS Architecture** - Understanding how Tables fit into Bevy's ECS: https://bevyengine.org/learn/ecs-in-depth/
4. **Rust Evaluation Order** - The Rust Reference on expression evaluation order: https://doc.rust-lang.org/reference/expressions.html#evaluation-order-of-operands