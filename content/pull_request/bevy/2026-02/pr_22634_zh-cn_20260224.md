+++
title = "#22634 Overrides for no-path in autonavigation for `bevy_input_focus"
date = "2026-02-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2026-02/pr-22634-en-20260224" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2026-02/pr-22634-zh-cn-20260224" }}
+++

# 标题: Overrides for no-path in autonavigation for `bevy_input_focus`

## 基本信息
- **标题**: Overrides for no-path in autonavigation for `bevy_input_focus`
- **PR链接**: https://github.com/bevyengine/bevy/pull/22634
- **作者**: kumaryash6352
- **状态**: 已合并
- **标签**: C-Feature, A-UI, S-Ready-For-Final-Review, D-Modest
- **创建时间**: 2026-01-21T20:43:59Z
- **合并时间**: 2026-02-24T03:08:28Z
- **合并者**: alice-i-cecile

## 描述翻译

### 目标
- 修复 #22378

### 解决方案
将 `NavNeighbors` 从存储 `Option<Entity>` 数组改为存储 `NavNeighbor` 枚举数组。`NavNeighbor` 枚举包含3个值：`Unset`（此方向未明确设置任何内容）、`Blocked`（假设此方向没有可路径导航的目标）和 `Neighbor(Entity)`。

### 测试
使用新的测试 `test_respects_set_blocks` 和手动使用 `directional_navigation_override` 示例来测试更改。第二页的每个按钮都限制为左/右移动，因为上/下方向被阻止。

### 展示
我不太确定如何展示这个功能，因为它是一个非常面向输入的功能，而且功能正常工作意味着什么都没有发生。

## 这个Pull Request的故事

这个Pull Request解决了一个特定的用户界面导航问题：开发者需要能够明确阻止特定方向的自动导航，而不仅仅是"未设置"状态。在原来的实现中，导航邻接关系使用 `Option<Entity>` 表示，这只能区分"有邻居"和"无邻居"两种状态。但对于UI导航来说，有时需要明确表示"这个方向应该被阻止导航"，而不仅仅是"还没有找到邻居"。

问题的核心在于 #22378 中描述的场景：当使用方向键在UI元素间导航时，系统需要区分"此方向没有设置邻居（但可以自动查找）"和"此方向应该明确阻止导航"。原来的 `Option<Entity>` 无法表达这种区别，因为 `None` 同时表示"未设置"和"没有邻居"。

开发者采用的解决方案是引入一个新的枚举类型 `NavNeighbor`，包含三种状态：
- `Auto`: 未显式设置，允许自动查找邻居
- `Blocked`: 明确阻止在此方向导航
- `Set(Entity)`: 已明确设置邻居实体

这个设计决策有几个关键考虑。首先，保持向后兼容性很重要，所以 `Default` 实现是 `Auto` 状态，这与原来的 `None` 行为相似。其次，需要更新所有相关方法来处理新的三态逻辑，而不仅仅是原来的二元逻辑。

在实现上，开发者重构了 `NavNeighbors` 结构体，将其内部数组类型从 `[Option<Entity>; 8]` 改为 `[NavNeighbor; 8]`。这影响了多个方面：
1. `get` 方法现在返回 `NavNeighbor` 而不是 `Option<Entity>`
2. 新增 `block` 方法用于设置阻止状态
3. `set` 方法现在设置 `NavNeighbor::Set(entity)`

在 `DirectionalNavigationMap` 中，`get_neighbor` 方法也改为返回 `NavNeighbor`。这要求在导航系统 (`DirectionalNavigation::navigate`) 中更新逻辑，现在需要匹配三种状态：
- 如果是 `Auto`，尝试自动导航（如果失败则返回错误）
- 如果是 `Blocked`，直接返回阻塞错误
- 如果是 `Set(entity)`，直接导航到指定实体

一个重要的实现细节是 `auto_generate_navigation_edges` 函数。这个函数负责自动生成导航边，现在需要检查当前状态是否是 `Blocked` 或 `Set`，如果是则跳过自动生成，这确保了手动设置（无论是明确邻居还是阻止）不会被自动系统覆盖。

技术上的一个重要决策是如何处理对称边。开发者提供了 `block_symmetrical_edge` 方法，但注意 `block_edge` 不是对称的，这与 `add_edge` 的行为一致。这意味着阻止A到B的导航不会自动阻止B到A的导航，这给了开发者更精细的控制。

在 `bevy_ui` 的 `AutoDirectionalNavigator` 中，导航逻辑需要适应新的错误类型。现在，只有 `NoNeighborInDirection` 错误会触发自动导航尝试，而 `BlockedNavigation` 错误则直接返回，不尝试自动查找。

示例代码的更新展示了如何使用这个新功能。在第一页中，每个按钮都阻止了上下方向的导航，但用户仍然可以通过左右方向在不同行间导航。这是一个实际的用例，展示了如何创建受限的导航模式。

这个实现的一个微妙之处是性能影响：使用枚举而不是 `Option<Entity>` 的内存占用略有增加，但提供了更强的表达能力。对于UI导航系统来说，这种表达能力的提升是值得的，因为它允许更精确的导航控制。

从架构角度看，这个改变遵循了Rust的类型安全原则：使用类型系统来区分不同的语义状态，而不是依赖注释或约定。通过将"未设置"、"已阻止"和"已设置"编码为不同的变体，编译器可以确保每种情况都被正确处理。

## 视觉表示

```mermaid
graph TD
    A[用户输入方向键] --> B[DirectionalNavigation系统]
    B --> C{检查NavNeighbors}
    C -->|Auto状态| D[尝试自动查找邻居]
    C -->|Blocked状态| E[返回BlockedNavigation错误]
    C -->|Set(Entity)状态| F[导航到指定实体]
    D --> G{找到合适邻居?}
    G -->|是| F
    G -->|否| H[返回NoNeighborInDirection错误]
```

## 关键文件更改

### 1. `crates/bevy_input_focus/src/directional_navigation.rs` (+236/-57)

**主要更改和原因**:
这是核心改动文件，引入了新的 `NavNeighbor` 枚举，并重构了相关类型和方法以支持三态导航逻辑。

**关键代码片段**:
```rust
// 新的枚举定义
pub enum NavNeighbor {
    /// No neighbor explicitly set.
    #[default]
    Auto,
    /// Do not find a neighbor.
    Blocked,
    /// The neighbor is known and set.
    Set(Entity),
}

// NavNeighbors 结构体的变化
pub struct NavNeighbors {
    // 从 Option<Entity> 改为 NavNeighbor
    pub neighbors: [NavNeighbor; 8],
}

// 新增的 block 方法
pub const fn block(&mut self, octant: CompassOctant) {
    self.neighbors[octant.to_index()] = NavNeighbor::Blocked;
}

// DirectionalNavigation::navigate 方法的更新
match self.map.get_neighbor(current_focus, direction) {
    NavNeighbor::Auto => Err(DirectionalNavigationError::NoNeighborInDirection {
        current_focus,
        direction,
    }),
    NavNeighbor::Blocked => Err(DirectionalNavigationError::BlockedNavigation {
        current_focus,
        direction,
    }),
    NavNeighbor::Set(new_focus) => {
        self.focus.set(new_focus);
        Ok(new_focus)
    }
}
```

### 2. `examples/ui/navigation/directional_navigation_overrides.rs` (+35/-24)

**主要更改和原因**:
更新示例以展示新的阻塞功能，特别展示了如何在第一页中阻止按钮的上下导航。

**关键代码片段**:
```rust
// 在第一页的每个按钮上阻止上下导航
for btn in &pages_entities[0] {
    manual_directional_nav_map.block_edge(*btn, CompassOctant::South);
    manual_directional_nav_map.block_edge(*btn, CompassOctant::North);
}

// 更新页脚文本以说明第一页的导航限制
let text = match page_num {
    // For the first page, add a notice about vertical navigation being blocked off
    0 => Text::new(
        "Vertical movements disabled on each button, but you can still navigate between rows by going off the left or right sides."
    ),
    // ... 其他页面
    _ => Text::default()
};
```

### 3. `crates/bevy_ui/src/auto_directional_navigation.rs` (+25/-19)

**主要更改和原因**:
更新自动导航器以正确处理新的阻塞错误类型，确保只有 `NoNeighborInDirection` 错误会触发自动导航。

**关键代码片段**:
```rust
match self.manual_directional_navigation.navigate(direction) {
    Ok(new_focus) => {
        self.manual_directional_navigation.focus.set(new_focus);
        Ok(new_focus)
    }
    Err(DirectionalNavigationError::NoNeighborInDirection { .. }) => {
        // 尝试自动导航...
    }
    err => err, // 其他错误（包括BlockedNavigation）直接返回
}
```

## 完整代码差异

```diff
// 详细差异见原始PR，主要更改包括：
// 1. 引入 NavNeighbor 枚举
// 2. 更新 NavNeighbors 使用新枚举
// 3. 添加 block_edge 和 block_symmetrical_edge 方法
// 4. 更新所有相关方法处理三态逻辑
// 5. 添加测试 test_respects_set_blocks
// 6. 更新示例展示阻塞功能
```

## 进一步阅读

对于想要了解更多关于此PR中使用的概念和模式的读者，建议查看：
1. [Rust枚举模式](https://doc.rust-lang.org/book/ch06-00-enums.html) - 了解如何使用枚举表示状态
2. [Bevy UI导航系统文档](https://bevyengine.org/learn/books/bevy-ui-navigation/) - 了解Bevy的UI导航架构
3. [状态模式在游戏开发中的应用](https://gameprogrammingpatterns.com/state.html) - 了解状态模式，这与三态导航逻辑相关
4. [类型驱动设计](https://www.parsonsmatt.org/2017/04/26/type_safe_directional_navigation_in_rust.html) - 了解如何使用类型系统提高代码安全性