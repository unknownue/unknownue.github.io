diff --git a/Cargo.toml b/Cargo.toml
index a7b301a4e9a8d..1a5d9b84363a3 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -136,7 +136,7 @@ default = [
   "bevy_color",
   "bevy_core_pipeline",
   "bevy_post_process",
-  "bevy_core_widgets",
+  "bevy_ui_widgets",
   "bevy_anti_alias",
   "bevy_gilrs",
   "bevy_gizmos",
@@ -296,7 +296,7 @@ bevy_log = ["bevy_internal/bevy_log"]
 bevy_input_focus = ["bevy_internal/bevy_input_focus"]
 
 # Headless widget collection for Bevy UI.
-bevy_core_widgets = ["bevy_internal/bevy_core_widgets"]
+bevy_ui_widgets = ["bevy_internal/bevy_ui_widgets"]
 
 # Feathers widget collection.
 experimental_bevy_feathers = ["bevy_internal/bevy_feathers"]
@@ -4658,23 +4658,23 @@ category = "ECS (Entity Component System)"
 wasm = false
 
 [[example]]
-name = "core_widgets"
-path = "examples/ui/core_widgets.rs"
+name = "standard_widgets"
+path = "examples/ui/standard_widgets.rs"
 doc-scrape-examples = true
 
-[package.metadata.example.core_widgets]
-name = "Core Widgets"
+[package.metadata.example.standard_widgets]
+name = "Standard Widgets"
 description = "Demonstrates use of core (headless) widgets in Bevy UI"
 category = "UI (User Interface)"
 wasm = true
 
 [[example]]
-name = "core_widgets_observers"
-path = "examples/ui/core_widgets_observers.rs"
+name = "standard_widgets_observers"
+path = "examples/ui/standard_widgets_observers.rs"
 doc-scrape-examples = true
 
-[package.metadata.example.core_widgets_observers]
-name = "Core Widgets (w/Observers)"
+[package.metadata.example.standard_widgets_observers]
+name = "Standard Widgets (w/Observers)"
 description = "Demonstrates use of core (headless) widgets in Bevy UI, with Observers"
 category = "UI (User Interface)"
 wasm = true
diff --git a/crates/bevy_feathers/Cargo.toml b/crates/bevy_feathers/Cargo.toml
index b0523b4f02d3d..50cc7dce606bf 100644
--- a/crates/bevy_feathers/Cargo.toml
+++ b/crates/bevy_feathers/Cargo.toml
@@ -15,7 +15,7 @@ bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
 bevy_asset = { path = "../bevy_asset", version = "0.17.0-dev" }
 bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
 bevy_color = { path = "../bevy_color", version = "0.17.0-dev" }
-bevy_core_widgets = { path = "../bevy_core_widgets", version = "0.17.0-dev" }
+bevy_ui_widgets = { path = "../bevy_ui_widgets", version = "0.17.0-dev" }
 bevy_ecs = { path = "../bevy_ecs", version = "0.17.0-dev" }
 bevy_input_focus = { path = "../bevy_input_focus", version = "0.17.0-dev" }
 bevy_log = { path = "../bevy_log", version = "0.17.0-dev" }
diff --git a/crates/bevy_feathers/src/controls/button.rs b/crates/bevy_feathers/src/controls/button.rs
index 851408db27214..1067792097d5c 100644
--- a/crates/bevy_feathers/src/controls/button.rs
+++ b/crates/bevy_feathers/src/controls/button.rs
@@ -1,5 +1,4 @@
 use bevy_app::{Plugin, PreUpdate};
-use bevy_core_widgets::{Activate, Callback, CoreButton};
 use bevy_ecs::{
     bundle::Bundle,
     component::Component,
@@ -16,6 +15,7 @@ use bevy_input_focus::tab_navigation::TabIndex;
 use bevy_picking::{hover::Hovered, PickingSystems};
 use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{AlignItems, InteractionDisabled, JustifyContent, Node, Pressed, UiRect, Val};
+use bevy_ui_widgets::{Activate, Button, Callback};
 
 use crate::{
     constants::{fonts, size},
@@ -71,7 +71,7 @@ pub fn button<C: SpawnableList<ChildOf> + Send + Sync + 'static, B: Bundle>(
             flex_grow: 1.0,
             ..Default::default()
         },
-        CoreButton {
+        Button {
             on_activate: props.on_click,
         },
         props.variant,
diff --git a/crates/bevy_feathers/src/controls/checkbox.rs b/crates/bevy_feathers/src/controls/checkbox.rs
index b7c5869cd449f..ebeff7fe3b171 100644
--- a/crates/bevy_feathers/src/controls/checkbox.rs
+++ b/crates/bevy_feathers/src/controls/checkbox.rs
@@ -1,6 +1,5 @@
 use bevy_app::{Plugin, PreUpdate};
 use bevy_camera::visibility::Visibility;
-use bevy_core_widgets::{Callback, CoreCheckbox, ValueChange};
 use bevy_ecs::{
     bundle::Bundle,
     children,
@@ -22,6 +21,7 @@ use bevy_ui::{
     AlignItems, BorderRadius, Checked, Display, FlexDirection, InteractionDisabled, JustifyContent,
     Node, PositionType, UiRect, UiTransform, Val,
 };
+use bevy_ui_widgets::{Callback, Checkbox, ValueChange};
 
 use crate::{
     constants::{fonts, size},
@@ -74,7 +74,7 @@ pub fn checkbox<C: SpawnableList<ChildOf> + Send + Sync + 'static, B: Bundle>(
             column_gap: Val::Px(4.0),
             ..Default::default()
         },
-        CoreCheckbox {
+        Checkbox {
             on_change: props.on_change,
         },
         CheckboxFrame,
diff --git a/crates/bevy_feathers/src/controls/color_slider.rs b/crates/bevy_feathers/src/controls/color_slider.rs
index 76ad6523ab4c0..0ef776e3b7808 100644
--- a/crates/bevy_feathers/src/controls/color_slider.rs
+++ b/crates/bevy_feathers/src/controls/color_slider.rs
@@ -3,9 +3,6 @@ use core::f32::consts::PI;
 use bevy_app::{Plugin, PreUpdate};
 use bevy_asset::Handle;
 use bevy_color::{Alpha, Color, Hsla};
-use bevy_core_widgets::{
-    Callback, CoreSlider, CoreSliderThumb, SliderRange, SliderValue, TrackClick, ValueChange,
-};
 use bevy_ecs::{
     bundle::Bundle,
     children,
@@ -26,6 +23,9 @@ use bevy_ui::{
     UiRect, UiTransform, Val, Val2, ZIndex,
 };
 use bevy_ui_render::ui_material::MaterialNode;
+use bevy_ui_widgets::{
+    Callback, Slider, SliderRange, SliderThumb, SliderValue, TrackClick, ValueChange,
+};
 
 use crate::{
     alpha_pattern::{AlphaPattern, AlphaPatternMaterial},
@@ -164,7 +164,7 @@ impl Default for ColorSliderProps {
 
 /// A color slider widget.
 #[derive(Component, Default, Clone)]
-#[require(CoreSlider, SliderBaseColor(Color::WHITE))]
+#[require(Slider, SliderBaseColor(Color::WHITE))]
 pub struct ColorSlider {
     /// Which channel is being edited by this slider.
     pub channel: ColorChannel,
@@ -194,7 +194,7 @@ pub fn color_slider<B: Bundle>(props: ColorSliderProps, overrides: B) -> impl Bu
             flex_grow: 1.0,
             ..Default::default()
         },
-        CoreSlider {
+        Slider {
             on_change: props.on_change,
             track_click: TrackClick::Snap,
         },
@@ -257,7 +257,7 @@ pub fn color_slider<B: Bundle>(props: ColorSliderProps, overrides: B) -> impl Bu
                                 border: UiRect::all(Val::Px(2.0)),
                                 ..Default::default()
                             },
-                            CoreSliderThumb,
+                            SliderThumb,
                             ColorSliderThumb,
                             BorderRadius::MAX,
                             BorderColor::all(palette::WHITE),
diff --git a/crates/bevy_feathers/src/controls/radio.rs b/crates/bevy_feathers/src/controls/radio.rs
index 404ed8608f1dc..0d90374955eb9 100644
--- a/crates/bevy_feathers/src/controls/radio.rs
+++ b/crates/bevy_feathers/src/controls/radio.rs
@@ -1,6 +1,5 @@
 use bevy_app::{Plugin, PreUpdate};
 use bevy_camera::visibility::Visibility;
-use bevy_core_widgets::CoreRadio;
 use bevy_ecs::{
     bundle::Bundle,
     children,
@@ -21,6 +20,7 @@ use bevy_ui::{
     AlignItems, BorderRadius, Checked, Display, FlexDirection, InteractionDisabled, JustifyContent,
     Node, UiRect, Val,
 };
+use bevy_ui_widgets::RadioButton;
 
 use crate::{
     constants::{fonts, size},
@@ -60,7 +60,7 @@ pub fn radio<C: SpawnableList<ChildOf> + Send + Sync + 'static, B: Bundle>(
             column_gap: Val::Px(4.0),
             ..Default::default()
         },
-        CoreRadio,
+        RadioButton,
         Hovered::default(),
         EntityCursor::System(bevy_window::SystemCursorIcon::Pointer),
         TabIndex(0),
@@ -111,7 +111,7 @@ fn update_radio_styles(
             &ThemeFontColor,
         ),
         (
-            With<CoreRadio>,
+            With<RadioButton>,
             Or<(Changed<Hovered>, Added<Checked>, Added<InteractionDisabled>)>,
         ),
     >,
@@ -159,7 +159,7 @@ fn update_radio_styles_remove(
             &Hovered,
             &ThemeFontColor,
         ),
-        With<CoreRadio>,
+        With<RadioButton>,
     >,
     q_children: Query<&Children>,
     mut q_outline: Query<&ThemeBorderColor, With<RadioOutline>>,
diff --git a/crates/bevy_feathers/src/controls/slider.rs b/crates/bevy_feathers/src/controls/slider.rs
index d649ae62050e7..9db8f5fd35c9d 100644
--- a/crates/bevy_feathers/src/controls/slider.rs
+++ b/crates/bevy_feathers/src/controls/slider.rs
@@ -2,7 +2,6 @@ use core::f32::consts::PI;
 
 use bevy_app::{Plugin, PreUpdate};
 use bevy_color::Color;
-use bevy_core_widgets::{Callback, CoreSlider, SliderRange, SliderValue, TrackClick, ValueChange};
 use bevy_ecs::{
     bundle::Bundle,
     children,
@@ -24,6 +23,7 @@ use bevy_ui::{
     InteractionDisabled, InterpolationColorSpace, JustifyContent, LinearGradient, Node,
     PositionType, UiRect, Val,
 };
+use bevy_ui_widgets::{Callback, Slider, SliderRange, SliderValue, TrackClick, ValueChange};
 
 use crate::{
     constants::{fonts, size},
@@ -59,7 +59,7 @@ impl Default for SliderProps {
 }
 
 #[derive(Component, Default, Clone)]
-#[require(CoreSlider)]
+#[require(Slider)]
 #[derive(Reflect)]
 #[reflect(Component, Clone, Default)]
 struct SliderStyle;
@@ -85,7 +85,7 @@ pub fn slider<B: Bundle>(props: SliderProps, overrides: B) -> impl Bundle {
             flex_grow: 1.0,
             ..Default::default()
         },
-        CoreSlider {
+        Slider {
             on_change: props.on_change,
             track_click: TrackClick::Drag,
         },
diff --git a/crates/bevy_feathers/src/controls/toggle_switch.rs b/crates/bevy_feathers/src/controls/toggle_switch.rs
index 0eb48e4387878..94a49ca1972b5 100644
--- a/crates/bevy_feathers/src/controls/toggle_switch.rs
+++ b/crates/bevy_feathers/src/controls/toggle_switch.rs
@@ -1,7 +1,6 @@
 use accesskit::Role;
 use bevy_a11y::AccessibilityNode;
 use bevy_app::{Plugin, PreUpdate};
-use bevy_core_widgets::{Callback, CoreCheckbox, ValueChange};
 use bevy_ecs::{
     bundle::Bundle,
     children,
@@ -20,6 +19,7 @@ use bevy_input_focus::tab_navigation::TabIndex;
 use bevy_picking::{hover::Hovered, PickingSystems};
 use bevy_reflect::{prelude::ReflectDefault, Reflect};
 use bevy_ui::{BorderRadius, Checked, InteractionDisabled, Node, PositionType, UiRect, Val};
+use bevy_ui_widgets::{Callback, Checkbox, ValueChange};
 
 use crate::{
     constants::size,
@@ -58,7 +58,7 @@ pub fn toggle_switch<B: Bundle>(props: ToggleSwitchProps, overrides: B) -> impl
             border: UiRect::all(Val::Px(2.0)),
             ..Default::default()
         },
-        CoreCheckbox {
+        Checkbox {
             on_change: props.on_change,
         },
         ToggleSwitchOutline,
diff --git a/crates/bevy_feathers/src/controls/virtual_keyboard.rs b/crates/bevy_feathers/src/controls/virtual_keyboard.rs
index 6f0473ffe0611..acc62afc82478 100644
--- a/crates/bevy_feathers/src/controls/virtual_keyboard.rs
+++ b/crates/bevy_feathers/src/controls/virtual_keyboard.rs
@@ -1,4 +1,3 @@
-use bevy_core_widgets::{Activate, Callback};
 use bevy_ecs::{
     bundle::Bundle,
     component::Component,
@@ -11,6 +10,7 @@ use bevy_input_focus::tab_navigation::TabGroup;
 use bevy_ui::Node;
 use bevy_ui::Val;
 use bevy_ui::{widget::Text, FlexDirection};
+use bevy_ui_widgets::{Activate, Callback};
 
 use crate::controls::{button, ButtonProps};
 
diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index babb95a4dac1c..536e56fb7f59e 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -476,7 +476,7 @@ bevy_color = { path = "../bevy_color", optional = true, version = "0.17.0-dev",
 ] }
 bevy_core_pipeline = { path = "../bevy_core_pipeline", optional = true, version = "0.17.0-dev" }
 bevy_post_process = { path = "../bevy_post_process", optional = true, version = "0.17.0-dev" }
-bevy_core_widgets = { path = "../bevy_core_widgets", optional = true, version = "0.17.0-dev" }
+bevy_ui_widgets = { path = "../bevy_ui_widgets", optional = true, version = "0.17.0-dev" }
 bevy_anti_alias = { path = "../bevy_anti_alias", optional = true, version = "0.17.0-dev" }
 bevy_dev_tools = { path = "../bevy_dev_tools", optional = true, version = "0.17.0-dev" }
 bevy_gilrs = { path = "../bevy_gilrs", optional = true, version = "0.17.0-dev" }
diff --git a/crates/bevy_internal/src/lib.rs b/crates/bevy_internal/src/lib.rs
index 78c8ba2b221f5..d4a9b06965caa 100644
--- a/crates/bevy_internal/src/lib.rs
+++ b/crates/bevy_internal/src/lib.rs
@@ -33,8 +33,6 @@ pub use bevy_camera as camera;
 pub use bevy_color as color;
 #[cfg(feature = "bevy_core_pipeline")]
 pub use bevy_core_pipeline as core_pipeline;
-#[cfg(feature = "bevy_core_widgets")]
-pub use bevy_core_widgets as core_widgets;
 #[cfg(feature = "bevy_dev_tools")]
 pub use bevy_dev_tools as dev_tools;
 pub use bevy_diagnostic as diagnostic;
@@ -93,6 +91,8 @@ pub use bevy_transform as transform;
 pub use bevy_ui as ui;
 #[cfg(feature = "bevy_ui_render")]
 pub use bevy_ui_render as ui_render;
+#[cfg(feature = "bevy_ui_widgets")]
+pub use bevy_ui_widgets as ui_widgets;
 pub use bevy_utils as utils;
 #[cfg(feature = "bevy_window")]
 pub use bevy_window as window;
diff --git a/crates/bevy_core_widgets/Cargo.toml b/crates/bevy_ui_widgets/Cargo.toml
similarity index 97%
rename from crates/bevy_core_widgets/Cargo.toml
rename to crates/bevy_ui_widgets/Cargo.toml
index 7a090cc29e9b2..d4f333f7d619a 100644
--- a/crates/bevy_core_widgets/Cargo.toml
+++ b/crates/bevy_ui_widgets/Cargo.toml
@@ -1,5 +1,5 @@
 [package]
-name = "bevy_core_widgets"
+name = "bevy_ui_widgets"
 version = "0.17.0-dev"
 edition = "2024"
 description = "Unstyled common widgets for Bevy Engine"
diff --git a/crates/bevy_core_widgets/src/core_button.rs b/crates/bevy_ui_widgets/src/button.rs
similarity index 90%
rename from crates/bevy_core_widgets/src/core_button.rs
rename to crates/bevy_ui_widgets/src/button.rs
index 0eea42588f5a9..46fea109ac62d 100644
--- a/crates/bevy_core_widgets/src/core_button.rs
+++ b/crates/bevy_ui_widgets/src/button.rs
@@ -23,7 +23,7 @@ use crate::{Activate, Callback, Notify};
 /// event when the button is un-pressed.
 #[derive(Component, Default, Debug)]
 #[require(AccessibilityNode(accesskit::Node::new(Role::Button)))]
-pub struct CoreButton {
+pub struct Button {
     /// Callback to invoke when the button is clicked, or when the `Enter` or `Space` key
     /// is pressed while the button is focused.
     pub on_activate: Callback<In<Activate>>,
@@ -31,7 +31,7 @@ pub struct CoreButton {
 
 fn button_on_key_event(
     mut event: On<FocusedInput<KeyboardInput>>,
-    q_state: Query<(&CoreButton, Has<InteractionDisabled>)>,
+    q_state: Query<(&Button, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
     if let Ok((bstate, disabled)) = q_state.get(event.focused_entity)
@@ -50,7 +50,7 @@ fn button_on_key_event(
 
 fn button_on_pointer_click(
     mut click: On<Pointer<Click>>,
-    mut q_state: Query<(&CoreButton, Has<Pressed>, Has<InteractionDisabled>)>,
+    mut q_state: Query<(&Button, Has<Pressed>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
     if let Ok((bstate, pressed, disabled)) = q_state.get_mut(click.entity) {
@@ -63,7 +63,7 @@ fn button_on_pointer_click(
 
 fn button_on_pointer_down(
     mut press: On<Pointer<Press>>,
-    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
+    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<Button>>,
     mut commands: Commands,
 ) {
     if let Ok((button, disabled, pressed)) = q_state.get_mut(press.entity) {
@@ -76,7 +76,7 @@ fn button_on_pointer_down(
 
 fn button_on_pointer_up(
     mut release: On<Pointer<Release>>,
-    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
+    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<Button>>,
     mut commands: Commands,
 ) {
     if let Ok((button, disabled, pressed)) = q_state.get_mut(release.entity) {
@@ -89,7 +89,7 @@ fn button_on_pointer_up(
 
 fn button_on_pointer_drag_end(
     mut drag_end: On<Pointer<DragEnd>>,
-    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
+    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<Button>>,
     mut commands: Commands,
 ) {
     if let Ok((button, disabled, pressed)) = q_state.get_mut(drag_end.entity) {
@@ -102,7 +102,7 @@ fn button_on_pointer_drag_end(
 
 fn button_on_pointer_cancel(
     mut cancel: On<Pointer<Cancel>>,
-    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
+    mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<Button>>,
     mut commands: Commands,
 ) {
     if let Ok((button, disabled, pressed)) = q_state.get_mut(cancel.entity) {
@@ -113,10 +113,10 @@ fn button_on_pointer_cancel(
     }
 }
 
-/// Plugin that adds the observers for the [`CoreButton`] widget.
-pub struct CoreButtonPlugin;
+/// Plugin that adds the observers for the [`Button`] widget.
+pub struct ButtonPlugin;
 
-impl Plugin for CoreButtonPlugin {
+impl Plugin for ButtonPlugin {
     fn build(&self, app: &mut App) {
         app.add_observer(button_on_key_event)
             .add_observer(button_on_pointer_down)
diff --git a/crates/bevy_core_widgets/src/callback.rs b/crates/bevy_ui_widgets/src/callback.rs
similarity index 98%
rename from crates/bevy_core_widgets/src/callback.rs
rename to crates/bevy_ui_widgets/src/callback.rs
index d27fb21220af3..6dba1f9056b9e 100644
--- a/crates/bevy_core_widgets/src/callback.rs
+++ b/crates/bevy_ui_widgets/src/callback.rs
@@ -10,7 +10,7 @@ use bevy_reflect::{prelude::ReflectDefault, Reflect};
 /// Example:
 /// ```
 /// use bevy_app::App;
-/// use bevy_core_widgets::{Callback, Notify};
+/// use bevy_ui_widgets::{Callback, Notify};
 /// use bevy_ecs::system::{Commands, IntoSystem};
 ///
 /// let mut app = App::new();
diff --git a/crates/bevy_core_widgets/src/core_checkbox.rs b/crates/bevy_ui_widgets/src/checkbox.rs
similarity index 85%
rename from crates/bevy_core_widgets/src/core_checkbox.rs
rename to crates/bevy_ui_widgets/src/checkbox.rs
index 33cdf7956fdbf..d50d464f5fb1d 100644
--- a/crates/bevy_core_widgets/src/core_checkbox.rs
+++ b/crates/bevy_ui_widgets/src/checkbox.rs
@@ -26,12 +26,12 @@ use bevy_ecs::entity::Entity;
 ///
 /// # Toggle switches
 ///
-/// The [`CoreCheckbox`] component can be used to implement other kinds of toggle widgets. If you
+/// The [`Checkbox`] component can be used to implement other kinds of toggle widgets. If you
 /// are going to do a toggle switch, you should override the [`AccessibilityNode`] component with
 /// the `Switch` role instead of the `Checkbox` role.
 #[derive(Component, Debug, Default)]
 #[require(AccessibilityNode(accesskit::Node::new(Role::CheckBox)), Checkable)]
-pub struct CoreCheckbox {
+pub struct Checkbox {
     /// One-shot system that is run when the checkbox state needs to be changed. If this value is
     /// `Callback::Ignore`, then the checkbox will update it's own internal [`Checked`] state
     /// without notification.
@@ -40,7 +40,7 @@ pub struct CoreCheckbox {
 
 fn checkbox_on_key_input(
     mut ev: On<FocusedInput<KeyboardInput>>,
-    q_checkbox: Query<(&CoreCheckbox, Has<Checked>), Without<InteractionDisabled>>,
+    q_checkbox: Query<(&Checkbox, Has<Checked>), Without<InteractionDisabled>>,
     mut commands: Commands,
 ) {
     if let Ok((checkbox, is_checked)) = q_checkbox.get(ev.focused_entity) {
@@ -57,7 +57,7 @@ fn checkbox_on_key_input(
 
 fn checkbox_on_pointer_click(
     mut click: On<Pointer<Click>>,
-    q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
+    q_checkbox: Query<(&Checkbox, Has<Checked>, Has<InteractionDisabled>)>,
     focus: Option<ResMut<InputFocus>>,
     focus_visible: Option<ResMut<InputFocusVisible>>,
     mut commands: Commands,
@@ -86,12 +86,12 @@ fn checkbox_on_pointer_click(
 ///
 /// ```
 /// use bevy_ecs::system::Commands;
-/// use bevy_core_widgets::{CoreCheckbox, SetChecked};
+/// use bevy_ui_widgets::{Checkbox, SetChecked};
 ///
 /// fn setup(mut commands: Commands) {
 ///     // Create a checkbox
 ///     let entity = commands.spawn((
-///         CoreCheckbox::default(),
+///         Checkbox::default(),
 ///     )).id();
 ///
 ///     // Set to checked
@@ -100,7 +100,7 @@ fn checkbox_on_pointer_click(
 /// ```
 #[derive(EntityEvent)]
 pub struct SetChecked {
-    /// The [`CoreCheckbox`] entity to set the "checked" state on.
+    /// The [`Checkbox`] entity to set the "checked" state on.
     pub entity: Entity,
     /// Sets the `checked` state to `true` or `false`.
     pub checked: bool,
@@ -113,12 +113,12 @@ pub struct SetChecked {
 ///
 /// ```
 /// use bevy_ecs::system::Commands;
-/// use bevy_core_widgets::{CoreCheckbox, ToggleChecked};
+/// use bevy_ui_widgets::{Checkbox, ToggleChecked};
 ///
 /// fn setup(mut commands: Commands) {
 ///     // Create a checkbox
 ///     let entity = commands.spawn((
-///         CoreCheckbox::default(),
+///         Checkbox::default(),
 ///     )).id();
 ///
 ///     // Set to checked
@@ -127,13 +127,13 @@ pub struct SetChecked {
 /// ```
 #[derive(EntityEvent)]
 pub struct ToggleChecked {
-    /// The [`Entity`] of the toggled [`CoreCheckbox`]
+    /// The [`Entity`] of the toggled [`Checkbox`]
     pub entity: Entity,
 }
 
 fn checkbox_on_set_checked(
     set_checked: On<SetChecked>,
-    q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
+    q_checkbox: Query<(&Checkbox, Has<Checked>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
     if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(set_checked.entity) {
@@ -150,7 +150,7 @@ fn checkbox_on_set_checked(
 
 fn checkbox_on_toggle_checked(
     toggle_checked: On<ToggleChecked>,
-    q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
+    q_checkbox: Query<(&Checkbox, Has<Checked>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
     if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(toggle_checked.entity) {
@@ -165,7 +165,7 @@ fn checkbox_on_toggle_checked(
 fn set_checkbox_state(
     commands: &mut Commands,
     entity: impl Into<Entity>,
-    checkbox: &CoreCheckbox,
+    checkbox: &Checkbox,
     new_state: bool,
 ) {
     if !matches!(checkbox.on_change, Callback::Ignore) {
@@ -183,10 +183,10 @@ fn set_checkbox_state(
     }
 }
 
-/// Plugin that adds the observers for the [`CoreCheckbox`] widget.
-pub struct CoreCheckboxPlugin;
+/// Plugin that adds the observers for the [`Checkbox`] widget.
+pub struct CheckboxPlugin;
 
-impl Plugin for CoreCheckboxPlugin {
+impl Plugin for CheckboxPlugin {
     fn build(&self, app: &mut App) {
         app.add_observer(checkbox_on_key_input)
             .add_observer(checkbox_on_pointer_click)
diff --git a/crates/bevy_core_widgets/src/lib.rs b/crates/bevy_ui_widgets/src/lib.rs
similarity index 58%
rename from crates/bevy_core_widgets/src/lib.rs
rename to crates/bevy_ui_widgets/src/lib.rs
index 1f20a31496b29..da73a04959b14 100644
--- a/crates/bevy_core_widgets/src/lib.rs
+++ b/crates/bevy_ui_widgets/src/lib.rs
@@ -1,4 +1,4 @@
-//! This crate provides a set of core widgets for Bevy UI, such as buttons, checkboxes, and sliders.
+//! This crate provides a set of standard widgets for Bevy UI, such as buttons, checkboxes, and sliders.
 //! These widgets have no inherent styling, it's the responsibility of the user to add styling
 //! appropriate for their game or application.
 //!
@@ -10,39 +10,35 @@
 //! widget. The primary motivation for this is to avoid two-way data binding in scenarios where the
 //! user interface is showing a live view of dynamic data coming from deeper within the game engine.
 
-// Note on naming: the `Core` prefix is used on components that would normally be internal to the
-// styled/opinionated widgets that use them. Components which are directly exposed to users above
-// the widget level, like `SliderValue`, should not have the `Core` prefix.
-
+mod button;
 mod callback;
-mod core_button;
-mod core_checkbox;
-mod core_radio;
-mod core_scrollbar;
-mod core_slider;
+mod checkbox;
+mod radio;
+mod scrollbar;
+mod slider;
 
+pub use button::*;
 pub use callback::*;
-pub use core_button::*;
-pub use core_checkbox::*;
-pub use core_radio::*;
-pub use core_scrollbar::*;
-pub use core_slider::*;
+pub use checkbox::*;
+pub use radio::*;
+pub use scrollbar::*;
+pub use slider::*;
 
 use bevy_app::{PluginGroup, PluginGroupBuilder};
 use bevy_ecs::entity::Entity;
 
-/// A plugin group that registers the observers for all of the core widgets. If you don't want to
+/// A plugin group that registers the observers for all of the widgets in this crate. If you don't want to
 /// use all of the widgets, you can import the individual widget plugins instead.
-pub struct CoreWidgetsPlugins;
+pub struct WidgetBehaviorPlugins;
 
-impl PluginGroup for CoreWidgetsPlugins {
+impl PluginGroup for WidgetBehaviorPlugins {
     fn build(self) -> PluginGroupBuilder {
         PluginGroupBuilder::start::<Self>()
-            .add(CoreButtonPlugin)
-            .add(CoreCheckboxPlugin)
-            .add(CoreRadioGroupPlugin)
-            .add(CoreScrollbarPlugin)
-            .add(CoreSliderPlugin)
+            .add(ButtonPlugin)
+            .add(CheckboxPlugin)
+            .add(RadioGroupPlugin)
+            .add(ScrollbarPlugin)
+            .add(SliderPlugin)
     }
 }
 
diff --git a/crates/bevy_core_widgets/src/core_radio.rs b/crates/bevy_ui_widgets/src/radio.rs
similarity index 90%
rename from crates/bevy_core_widgets/src/core_radio.rs
rename to crates/bevy_ui_widgets/src/radio.rs
index b2a313552c0e2..0e5fde2aa53cb 100644
--- a/crates/bevy_core_widgets/src/core_radio.rs
+++ b/crates/bevy_ui_widgets/src/radio.rs
@@ -19,29 +19,29 @@ use bevy_ui::{Checkable, Checked, InteractionDisabled};
 use crate::{Activate, Callback, Notify};
 
 /// Headless widget implementation for a "radio button group". This component is used to group
-/// multiple [`CoreRadio`] components together, allowing them to behave as a single unit. It
+/// multiple [`RadioButton`] components together, allowing them to behave as a single unit. It
 /// implements the tab navigation logic and keyboard shortcuts for radio buttons.
 ///
-/// The [`CoreRadioGroup`] component does not have any state itself, and makes no assumptions about
+/// The [`RadioGroup`] component does not have any state itself, and makes no assumptions about
 /// what, if any, value is associated with each radio button, or what Rust type that value might be.
 /// Instead, the output of the group is the entity id of the selected button. The app can then
 /// derive the selected value from this using app-specific means, such as accessing a component on
 /// the individual buttons.
 ///
-/// The [`CoreRadioGroup`] doesn't actually set the [`Checked`] states directly, that is presumed to
+/// The [`RadioGroup`] doesn't actually set the [`Checked`] states directly, that is presumed to
 /// happen by the app or via some external data-binding scheme. Typically, each button would be
 /// associated with a particular constant value, and would be checked whenever that value is equal
 /// to the group's value. This also means that as long as each button's associated value is unique
 /// within the group, it should never be the case that more than one button is selected at a time.
 #[derive(Component, Debug)]
 #[require(AccessibilityNode(accesskit::Node::new(Role::RadioGroup)))]
-pub struct CoreRadioGroup {
+pub struct RadioGroup {
     /// Callback which is called when the selected radio button changes.
     pub on_change: Callback<In<Activate>>,
 }
 
 /// Headless widget implementation for radio buttons. These should be enclosed within a
-/// [`CoreRadioGroup`] widget, which is responsible for the mutual exclusion logic.
+/// [`RadioGroup`] widget, which is responsible for the mutual exclusion logic.
 ///
 /// According to the WAI-ARIA best practices document, radio buttons should not be focusable,
 /// but rather the enclosing group should be focusable.
@@ -50,16 +50,16 @@ pub struct CoreRadioGroup {
 #[require(AccessibilityNode(accesskit::Node::new(Role::RadioButton)), Checkable)]
 #[derive(Reflect)]
 #[reflect(Component)]
-pub struct CoreRadio;
+pub struct RadioButton;
 
 fn radio_group_on_key_input(
     mut ev: On<FocusedInput<KeyboardInput>>,
-    q_group: Query<&CoreRadioGroup>,
-    q_radio: Query<(Has<Checked>, Has<InteractionDisabled>), With<CoreRadio>>,
+    q_group: Query<&RadioGroup>,
+    q_radio: Query<(Has<Checked>, Has<InteractionDisabled>), With<RadioButton>>,
     q_children: Query<&Children>,
     mut commands: Commands,
 ) {
-    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.focused_entity) {
+    if let Ok(RadioGroup { on_change }) = q_group.get(ev.focused_entity) {
         let event = &ev.event().input;
         if event.state == ButtonState::Pressed
             && !event.repeat
@@ -141,13 +141,13 @@ fn radio_group_on_key_input(
 
 fn radio_group_on_button_click(
     mut ev: On<Pointer<Click>>,
-    q_group: Query<&CoreRadioGroup>,
-    q_radio: Query<(Has<Checked>, Has<InteractionDisabled>), With<CoreRadio>>,
+    q_group: Query<&RadioGroup>,
+    q_radio: Query<(Has<Checked>, Has<InteractionDisabled>), With<RadioButton>>,
     q_parents: Query<&ChildOf>,
     q_children: Query<&Children>,
     mut commands: Commands,
 ) {
-    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.entity) {
+    if let Ok(RadioGroup { on_change }) = q_group.get(ev.entity) {
         // Starting with the original target, search upward for a radio button.
         let radio_id = if q_radio.contains(ev.original_event_target()) {
             ev.original_event_target()
@@ -206,10 +206,10 @@ fn radio_group_on_button_click(
     }
 }
 
-/// Plugin that adds the observers for the [`CoreRadioGroup`] widget.
-pub struct CoreRadioGroupPlugin;
+/// Plugin that adds the observers for the [`RadioGroup`] widget.
+pub struct RadioGroupPlugin;
 
-impl Plugin for CoreRadioGroupPlugin {
+impl Plugin for RadioGroupPlugin {
     fn build(&self, app: &mut App) {
         app.add_observer(radio_group_on_key_input)
             .add_observer(radio_group_on_button_click);
diff --git a/crates/bevy_core_widgets/src/core_scrollbar.rs b/crates/bevy_ui_widgets/src/scrollbar.rs
similarity index 96%
rename from crates/bevy_core_widgets/src/core_scrollbar.rs
rename to crates/bevy_ui_widgets/src/scrollbar.rs
index ad23ea813751c..974264b0f2394 100644
--- a/crates/bevy_core_widgets/src/core_scrollbar.rs
+++ b/crates/bevy_ui_widgets/src/scrollbar.rs
@@ -29,7 +29,7 @@ pub enum ControlOrientation {
 
 /// A headless scrollbar widget, which can be used to build custom scrollbars.
 ///
-/// Scrollbars operate differently than the other core widgets in a number of respects.
+/// Scrollbars operate differently than the other UI widgets in a number of respects.
 ///
 /// Unlike sliders, scrollbars don't have an [`AccessibilityNode`](bevy_a11y::AccessibilityNode)
 /// component, nor can they have keyboard focus. This is because scrollbars are usually used in
@@ -50,7 +50,7 @@ pub enum ControlOrientation {
 /// the content to make room for the scrollbars.
 #[derive(Component, Debug, Reflect)]
 #[reflect(Component)]
-pub struct CoreScrollbar {
+pub struct Scrollbar {
     /// Entity being scrolled.
     pub target: Entity,
     /// Whether the scrollbar is vertical or horizontal.
@@ -70,7 +70,7 @@ pub struct CoreScrollbar {
 #[reflect(Component)]
 pub struct CoreScrollbarThumb;
 
-impl CoreScrollbar {
+impl Scrollbar {
     /// Construct a new scrollbar.
     ///
     /// # Arguments
@@ -102,12 +102,12 @@ fn scrollbar_on_pointer_down(
     mut ev: On<Pointer<Press>>,
     q_thumb: Query<&ChildOf, With<CoreScrollbarThumb>>,
     mut q_scrollbar: Query<(
-        &CoreScrollbar,
+        &Scrollbar,
         &ComputedNode,
         &ComputedUiRenderTargetInfo,
         &UiGlobalTransform,
     )>,
-    mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<CoreScrollbar>>,
+    mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<Scrollbar>>,
     ui_scale: Res<UiScale>,
 ) {
     if q_thumb.contains(ev.entity) {
@@ -159,7 +159,7 @@ fn scrollbar_on_pointer_down(
 fn scrollbar_on_drag_start(
     mut ev: On<Pointer<DragStart>>,
     mut q_thumb: Query<(&ChildOf, &mut CoreScrollbarDragState), With<CoreScrollbarThumb>>,
-    q_scrollbar: Query<&CoreScrollbar>,
+    q_scrollbar: Query<&Scrollbar>,
     q_scroll_area: Query<&ScrollPosition>,
 ) {
     if let Ok((ChildOf(thumb_parent), mut drag)) = q_thumb.get_mut(ev.entity) {
@@ -179,8 +179,8 @@ fn scrollbar_on_drag_start(
 fn scrollbar_on_drag(
     mut ev: On<Pointer<Drag>>,
     mut q_thumb: Query<(&ChildOf, &mut CoreScrollbarDragState), With<CoreScrollbarThumb>>,
-    mut q_scrollbar: Query<(&ComputedNode, &CoreScrollbar)>,
-    mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<CoreScrollbar>>,
+    mut q_scrollbar: Query<(&ComputedNode, &Scrollbar)>,
+    mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<Scrollbar>>,
     ui_scale: Res<UiScale>,
 ) {
     if let Ok((ChildOf(thumb_parent), drag)) = q_thumb.get_mut(ev.entity)
@@ -241,7 +241,7 @@ fn scrollbar_on_drag_cancel(
 
 fn update_scrollbar_thumb(
     q_scroll_area: Query<(&ScrollPosition, &ComputedNode)>,
-    q_scrollbar: Query<(&CoreScrollbar, &ComputedNode, &Children)>,
+    q_scrollbar: Query<(&Scrollbar, &ComputedNode, &Children)>,
     mut q_thumb: Query<&mut Node, With<CoreScrollbarThumb>>,
 ) {
     for (scrollbar, scrollbar_node, children) in q_scrollbar.iter() {
@@ -319,10 +319,10 @@ fn update_scrollbar_thumb(
     }
 }
 
-/// Plugin that adds the observers for the [`CoreScrollbar`] widget.
-pub struct CoreScrollbarPlugin;
+/// Plugin that adds the observers for the [`Scrollbar`] widget.
+pub struct ScrollbarPlugin;
 
-impl Plugin for CoreScrollbarPlugin {
+impl Plugin for ScrollbarPlugin {
     fn build(&self, app: &mut App) {
         app.add_observer(scrollbar_on_pointer_down)
             .add_observer(scrollbar_on_drag_start)
diff --git a/crates/bevy_core_widgets/src/core_slider.rs b/crates/bevy_ui_widgets/src/slider.rs
similarity index 95%
rename from crates/bevy_core_widgets/src/core_slider.rs
rename to crates/bevy_ui_widgets/src/slider.rs
index aa706d6241e09..a417ba2bb9786 100644
--- a/crates/bevy_core_widgets/src/core_slider.rs
+++ b/crates/bevy_ui_widgets/src/slider.rs
@@ -60,7 +60,7 @@ pub enum TrackClick {
 ///
 /// Typically a slider will contain entities representing the "track" and "thumb" elements. The core
 /// slider makes no assumptions about the hierarchical structure of these elements, but expects that
-/// the thumb will be marked with a [`CoreSliderThumb`] component.
+/// the thumb will be marked with a [`SliderThumb`] component.
 ///
 /// The core slider does not modify the visible position of the thumb: that is the responsibility of
 /// the stylist. This can be done either in percent or pixel units as desired. To prevent overhang
@@ -80,7 +80,7 @@ pub enum TrackClick {
     SliderRange,
     SliderStep
 )]
-pub struct CoreSlider {
+pub struct Slider {
     /// Callback which is called when the slider is dragged or the value is changed via other user
     /// interaction. If this value is `Callback::Ignore`, then the slider will update it's own
     /// internal [`SliderValue`] state without notification.
@@ -92,7 +92,7 @@ pub struct CoreSlider {
 
 /// Marker component that identifies which descendant element is the slider thumb.
 #[derive(Component, Debug, Default)]
-pub struct CoreSliderThumb;
+pub struct SliderThumb;
 
 /// A component which stores the current value of the slider.
 #[derive(Component, Debug, Default, PartialEq, Clone, Copy)]
@@ -231,7 +231,7 @@ pub struct CoreSliderDragState {
 pub(crate) fn slider_on_pointer_down(
     mut press: On<Pointer<Press>>,
     q_slider: Query<(
-        &CoreSlider,
+        &Slider,
         &SliderValue,
         &SliderRange,
         &SliderStep,
@@ -241,7 +241,7 @@ pub(crate) fn slider_on_pointer_down(
         &UiGlobalTransform,
         Has<InteractionDisabled>,
     )>,
-    q_thumb: Query<&ComputedNode, With<CoreSliderThumb>>,
+    q_thumb: Query<&ComputedNode, With<SliderThumb>>,
     q_children: Query<&Children>,
     mut commands: Commands,
     ui_scale: Res<UiScale>,
@@ -268,7 +268,7 @@ pub(crate) fn slider_on_pointer_down(
             return;
         }
 
-        // Find thumb size by searching descendants for the first entity with CoreSliderThumb
+        // Find thumb size by searching descendants for the first entity with SliderThumb
         let thumb_size = q_children
             .iter_descendants(press.entity)
             .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
@@ -325,7 +325,7 @@ pub(crate) fn slider_on_drag_start(
             &mut CoreSliderDragState,
             Has<InteractionDisabled>,
         ),
-        With<CoreSlider>,
+        With<Slider>,
     >,
 ) {
     if let Ok((value, mut drag, disabled)) = q_slider.get_mut(drag_start.entity) {
@@ -341,14 +341,14 @@ pub(crate) fn slider_on_drag(
     mut event: On<Pointer<Drag>>,
     mut q_slider: Query<(
         &ComputedNode,
-        &CoreSlider,
+        &Slider,
         &SliderRange,
         Option<&SliderPrecision>,
         &UiGlobalTransform,
         &mut CoreSliderDragState,
         Has<InteractionDisabled>,
     )>,
-    q_thumb: Query<&ComputedNode, With<CoreSliderThumb>>,
+    q_thumb: Query<&ComputedNode, With<SliderThumb>>,
     q_children: Query<&Children>,
     mut commands: Commands,
     ui_scale: Res<UiScale>,
@@ -361,7 +361,7 @@ pub(crate) fn slider_on_drag(
             let mut distance = event.distance / ui_scale.0;
             distance.y *= -1.;
             let distance = transform.transform_vector2(distance);
-            // Find thumb size by searching descendants for the first entity with CoreSliderThumb
+            // Find thumb size by searching descendants for the first entity with SliderThumb
             let thumb_size = q_children
                 .iter_descendants(event.entity)
                 .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
@@ -398,7 +398,7 @@ pub(crate) fn slider_on_drag(
 
 pub(crate) fn slider_on_drag_end(
     mut drag_end: On<Pointer<DragEnd>>,
-    mut q_slider: Query<(&CoreSlider, &mut CoreSliderDragState)>,
+    mut q_slider: Query<(&Slider, &mut CoreSliderDragState)>,
 ) {
     if let Ok((_slider, mut drag)) = q_slider.get_mut(drag_end.entity) {
         drag_end.propagate(false);
@@ -411,7 +411,7 @@ pub(crate) fn slider_on_drag_end(
 fn slider_on_key_input(
     mut focused_input: On<FocusedInput<KeyboardInput>>,
     q_slider: Query<(
-        &CoreSlider,
+        &Slider,
         &SliderValue,
         &SliderRange,
         &SliderStep,
@@ -449,7 +449,7 @@ fn slider_on_key_input(
     }
 }
 
-pub(crate) fn slider_on_insert(insert: On<Insert, CoreSlider>, mut world: DeferredWorld) {
+pub(crate) fn slider_on_insert(insert: On<Insert, Slider>, mut world: DeferredWorld) {
     let mut entity = world.entity_mut(insert.entity);
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_orientation(Orientation::Horizontal);
@@ -489,11 +489,11 @@ pub(crate) fn slider_on_insert_step(insert: On<Insert, SliderStep>, mut world: D
 ///
 /// ```
 /// # use bevy_ecs::system::Commands;
-/// # use bevy_core_widgets::{CoreSlider, SliderRange, SliderValue, SetSliderValue, SliderValueChange};
+/// # use bevy_ui_widgets::{Slider, SliderRange, SliderValue, SetSliderValue, SliderValueChange};
 /// fn setup(mut commands: Commands) {
 ///     // Create a slider
 ///     let entity = commands.spawn((
-///         CoreSlider::default(),
+///         Slider::default(),
 ///         SliderValue(0.5),
 ///         SliderRange::new(0.0, 1.0),
 ///     )).id();
@@ -532,7 +532,7 @@ pub enum SliderValueChange {
 
 fn slider_on_set_value(
     set_slider_value: On<SetSliderValue>,
-    q_slider: Query<(&CoreSlider, &SliderValue, &SliderRange, Option<&SliderStep>)>,
+    q_slider: Query<(&Slider, &SliderValue, &SliderRange, Option<&SliderStep>)>,
     mut commands: Commands,
 ) {
     if let Ok((slider, value, range, step)) = q_slider.get(set_slider_value.entity) {
@@ -559,10 +559,10 @@ fn slider_on_set_value(
     }
 }
 
-/// Plugin that adds the observers for the [`CoreSlider`] widget.
-pub struct CoreSliderPlugin;
+/// Plugin that adds the observers for the [`Slider`] widget.
+pub struct SliderPlugin;
 
-impl Plugin for CoreSliderPlugin {
+impl Plugin for SliderPlugin {
     fn build(&self, app: &mut App) {
         app.add_observer(slider_on_pointer_down)
             .add_observer(slider_on_drag_start)
diff --git a/docs/cargo_features.md b/docs/cargo_features.md
index 530ba2c52a04d..5d105fce10579 100644
--- a/docs/cargo_features.md
+++ b/docs/cargo_features.md
@@ -22,7 +22,6 @@ The default feature set enables most of the expected features of a game engine,
 |bevy_camera|Provides camera and visibility types, as well as culling primitives.|
 |bevy_color|Provides shared color types and operations|
 |bevy_core_pipeline|Provides cameras and other basic render pipeline features|
-|bevy_core_widgets|Headless widget collection for Bevy UI.|
 |bevy_gilrs|Adds gamepad support|
 |bevy_gizmos|Adds support for rendering gizmos|
 |bevy_gltf|[glTF](https://www.khronos.org/gltf/) support|
@@ -46,6 +45,7 @@ The default feature set enables most of the expected features of a game engine,
 |bevy_ui|A custom ECS-driven UI framework|
 |bevy_ui_picking_backend|Provides an implementation for picking UI|
 |bevy_ui_render|Provides rendering functionality for bevy_ui|
+|bevy_ui_widgets|Headless widget collection for Bevy UI.|
 |bevy_window|Windowing layer|
 |bevy_winit|winit window and input backend|
 |custom_cursor|Enable winit custom cursor support|
diff --git a/examples/README.md b/examples/README.md
index e7c694e2669de..7b09f3c517a00 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -555,8 +555,6 @@ Example | Description
 [Box Shadow](../examples/ui/box_shadow.rs) | Demonstrates how to create a node with a shadow
 [Button](../examples/ui/button.rs) | Illustrates creating and updating a button
 [CSS Grid](../examples/ui/grid.rs) | An example for CSS Grid layout
-[Core Widgets](../examples/ui/core_widgets.rs) | Demonstrates use of core (headless) widgets in Bevy UI
-[Core Widgets (w/Observers)](../examples/ui/core_widgets_observers.rs) | Demonstrates use of core (headless) widgets in Bevy UI, with Observers
 [Directional Navigation](../examples/ui/directional_navigation.rs) | Demonstration of Directional Navigation between UI elements
 [Display and Visibility](../examples/ui/display_and_visibility.rs) | Demonstrates how Display and Visibility work in the UI.
 [Drag to Scroll](../examples/ui/drag_to_scroll.rs) | This example tests scale factor, dragging and scrolling
@@ -573,6 +571,8 @@ Example | Description
 [Scrollbars](../examples/ui/scrollbars.rs) | Demonstrates use of core scrollbar in Bevy UI
 [Size Constraints](../examples/ui/size_constraints.rs) | Demonstrates how the to use the size constraints to control the size of a UI node.
 [Stacked Gradients](../examples/ui/stacked_gradients.rs) | An example demonstrating stacked gradients
+[Standard Widgets](../examples/ui/standard_widgets.rs) | Demonstrates use of core (headless) widgets in Bevy UI
+[Standard Widgets (w/Observers)](../examples/ui/standard_widgets_observers.rs) | Demonstrates use of core (headless) widgets in Bevy UI, with Observers
 [Tab Navigation](../examples/ui/tab_navigation.rs) | Demonstration of Tab Navigation between UI elements
 [Text](../examples/ui/text.rs) | Illustrates creating and updating text
 [Text Background Colors](../examples/ui/text_background_colors.rs) | Demonstrates text background colors
diff --git a/examples/testbed/full_ui.rs b/examples/testbed/full_ui.rs
index 7c4e8e779ba3b..50843b0c31284 100644
--- a/examples/testbed/full_ui.rs
+++ b/examples/testbed/full_ui.rs
@@ -9,11 +9,11 @@ use bevy::{
         basic::LIME,
         css::{DARK_GRAY, NAVY},
     },
-    core_widgets::CoreScrollbar,
     input::mouse::{MouseScrollUnit, MouseWheel},
     picking::hover::HoverMap,
     prelude::*,
     ui::widget::NodeImageMode,
+    ui_widgets::Scrollbar,
 };
 
 fn main() {
@@ -438,7 +438,7 @@ fn toggle_debug_overlay(
 pub fn update_scroll_position(
     mut mouse_wheel_events: EventReader<MouseWheel>,
     hover_map: Res<HoverMap>,
-    mut scrolled_node_query: Query<(&mut ScrollPosition, &ComputedNode), Without<CoreScrollbar>>,
+    mut scrolled_node_query: Query<(&mut ScrollPosition, &ComputedNode), Without<Scrollbar>>,
     keyboard_input: Res<ButtonInput<KeyCode>>,
 ) {
     for mouse_wheel_event in mouse_wheel_events.read() {
diff --git a/examples/ui/feathers.rs b/examples/ui/feathers.rs
index 8d3ffc96ceb8e..cb1abb4bbf77a 100644
--- a/examples/ui/feathers.rs
+++ b/examples/ui/feathers.rs
@@ -2,10 +2,6 @@
 
 use bevy::{
     color::palettes,
-    core_widgets::{
-        Activate, Callback, CoreRadio, CoreRadioGroup, CoreWidgetsPlugins, SliderPrecision,
-        SliderStep, SliderValue, ValueChange,
-    },
     feathers::{
         controls::{
             button, checkbox, color_slider, color_swatch, radio, slider, toggle_switch,
@@ -23,6 +19,10 @@ use bevy::{
     },
     prelude::*,
     ui::{Checked, InteractionDisabled},
+    ui_widgets::{
+        Activate, Callback, RadioButton, RadioGroup, SliderPrecision, SliderStep, SliderValue,
+        ValueChange, WidgetBehaviorPlugins,
+    },
 };
 
 /// A struct to hold the state of various widgets shown in the demo.
@@ -42,7 +42,7 @@ fn main() {
     App::new()
         .add_plugins((
             DefaultPlugins,
-            CoreWidgetsPlugins,
+            WidgetBehaviorPlugins,
             InputDispatchPlugin,
             TabNavigationPlugin,
             FeathersPlugin,
@@ -67,7 +67,7 @@ fn setup(mut commands: Commands) {
 fn demo_root(commands: &mut Commands) -> impl Bundle {
     // Update radio button states based on notification from radio group.
     let radio_exclusion = commands.register_system(
-        |ent: In<Activate>, q_radio: Query<Entity, With<CoreRadio>>, mut commands: Commands| {
+        |ent: In<Activate>, q_radio: Query<Entity, With<RadioButton>>, mut commands: Commands| {
             for radio in q_radio.iter() {
                 if radio == ent.0 .0 {
                     commands.entity(radio).insert(Checked);
@@ -284,7 +284,7 @@ fn demo_root(commands: &mut Commands) -> impl Bundle {
                         row_gap: px(4),
                         ..default()
                     },
-                    CoreRadioGroup {
+                    RadioGroup {
                         on_change: Callback::System(radio_exclusion),
                     },
                     children![
diff --git a/examples/ui/scrollbars.rs b/examples/ui/scrollbars.rs
index 1a9d29b555393..f5dedeea5069d 100644
--- a/examples/ui/scrollbars.rs
+++ b/examples/ui/scrollbars.rs
@@ -1,10 +1,6 @@
 //! Demonstrations of scrolling and scrollbars.
 
 use bevy::{
-    core_widgets::{
-        ControlOrientation, CoreScrollbar, CoreScrollbarDragState, CoreScrollbarPlugin,
-        CoreScrollbarThumb,
-    },
     ecs::{relationship::RelatedSpawner, spawn::SpawnWith},
     input_focus::{
         tab_navigation::{TabGroup, TabNavigationPlugin},
@@ -12,13 +8,16 @@ use bevy::{
     },
     picking::hover::Hovered,
     prelude::*,
+    ui_widgets::{
+        ControlOrientation, CoreScrollbarDragState, CoreScrollbarThumb, Scrollbar, ScrollbarPlugin,
+    },
 };
 
 fn main() {
     App::new()
         .add_plugins((
             DefaultPlugins,
-            CoreScrollbarPlugin,
+            ScrollbarPlugin,
             InputDispatchPlugin,
             TabNavigationPlugin,
         ))
@@ -113,7 +112,7 @@ fn scroll_area_demo() -> impl Bundle {
                     grid_column: GridPlacement::start(2),
                     ..default()
                 },
-                CoreScrollbar {
+                Scrollbar {
                     orientation: ControlOrientation::Vertical,
                     target: scroll_area_id,
                     min_thumb_length: 8.0,
@@ -138,7 +137,7 @@ fn scroll_area_demo() -> impl Bundle {
                     grid_column: GridPlacement::start(1),
                     ..default()
                 },
-                CoreScrollbar {
+                Scrollbar {
                     orientation: ControlOrientation::Horizontal,
                     target: scroll_area_id,
                     min_thumb_length: 8.0,
diff --git a/examples/ui/core_widgets.rs b/examples/ui/standard_widgets.rs
similarity index 97%
rename from examples/ui/core_widgets.rs
rename to examples/ui/standard_widgets.rs
index 6e6caefc2807e..1934952b5db02 100644
--- a/examples/ui/core_widgets.rs
+++ b/examples/ui/standard_widgets.rs
@@ -1,12 +1,7 @@
-//! This example illustrates how to create widgets using the `bevy_core_widgets` widget set.
+//! This example illustrates how to create widgets using the `bevy_ui_widgets` widget set.
 
 use bevy::{
     color::palettes::basic::*,
-    core_widgets::{
-        Activate, Callback, CoreButton, CoreCheckbox, CoreRadio, CoreRadioGroup, CoreSlider,
-        CoreSliderDragState, CoreSliderThumb, CoreWidgetsPlugins, SliderRange, SliderValue,
-        TrackClick, ValueChange,
-    },
     input_focus::{
         tab_navigation::{TabGroup, TabIndex, TabNavigationPlugin},
         InputDispatchPlugin,
@@ -14,13 +9,17 @@ use bevy::{
     picking::hover::Hovered,
     prelude::*,
     ui::{Checked, InteractionDisabled, Pressed},
+    ui_widgets::{
+        Activate, Button, Callback, Checkbox, CoreSliderDragState, RadioButton, RadioGroup, Slider,
+        SliderRange, SliderThumb, SliderValue, TrackClick, ValueChange, WidgetBehaviorPlugins,
+    },
 };
 
 fn main() {
     App::new()
         .add_plugins((
             DefaultPlugins,
-            CoreWidgetsPlugins,
+            WidgetBehaviorPlugins,
             InputDispatchPlugin,
             TabNavigationPlugin,
         ))
@@ -90,7 +89,7 @@ struct DemoWidgetStates {
 /// Update the widget states based on the changing resource.
 fn update_widget_values(
     res: Res<DemoWidgetStates>,
-    mut sliders: Query<(Entity, &mut CoreSlider), With<DemoSlider>>,
+    mut sliders: Query<(Entity, &mut Slider), With<DemoSlider>>,
     radios: Query<(Entity, &DemoRadio, Has<Checked>)>,
     mut commands: Commands,
 ) {
@@ -189,7 +188,7 @@ fn button(asset_server: &AssetServer, on_click: Callback<In<Activate>>) -> impl
             ..default()
         },
         DemoButton,
-        CoreButton {
+        Button {
             on_activate: on_click,
         },
         Hovered::default(),
@@ -342,7 +341,7 @@ fn slider(
         Name::new("Slider"),
         Hovered::default(),
         DemoSlider,
-        CoreSlider {
+        Slider {
             on_change,
             track_click: TrackClick::Snap,
         },
@@ -376,7 +375,7 @@ fn slider(
                 children![(
                     // Thumb
                     DemoSliderThumb,
-                    CoreSliderThumb,
+                    SliderThumb,
                     Node {
                         display: Display::Flex,
                         width: px(12),
@@ -486,7 +485,7 @@ fn checkbox(
         Name::new("Checkbox"),
         Hovered::default(),
         DemoCheckbox,
-        CoreCheckbox { on_change },
+        Checkbox { on_change },
         TabIndex(0),
         Children::spawn((
             Spawn((
@@ -674,7 +673,7 @@ fn radio_group(asset_server: &AssetServer, on_change: Callback<In<Activate>>) ->
             ..default()
         },
         Name::new("RadioGroup"),
-        CoreRadioGroup { on_change },
+        RadioGroup { on_change },
         TabIndex::default(),
         children![
             (radio(asset_server, TrackClick::Drag, "Slider Drag"),),
@@ -699,7 +698,7 @@ fn radio(asset_server: &AssetServer, value: TrackClick, caption: &str) -> impl B
         Name::new("RadioButton"),
         Hovered::default(),
         DemoRadio(value),
-        CoreRadio,
+        RadioButton,
         Children::spawn((
             Spawn((
                 // Radio outer
@@ -746,10 +745,10 @@ fn toggle_disabled(
     mut interaction_query: Query<
         (Entity, Has<InteractionDisabled>),
         Or<(
-            With<CoreButton>,
-            With<CoreSlider>,
-            With<CoreCheckbox>,
-            With<CoreRadio>,
+            With<Button>,
+            With<Slider>,
+            With<Checkbox>,
+            With<RadioButton>,
         )>,
     >,
     mut commands: Commands,
diff --git a/examples/ui/core_widgets_observers.rs b/examples/ui/standard_widgets_observers.rs
similarity index 98%
rename from examples/ui/core_widgets_observers.rs
rename to examples/ui/standard_widgets_observers.rs
index 3601ecc5bdb48..1ff2ca80314aa 100644
--- a/examples/ui/core_widgets_observers.rs
+++ b/examples/ui/standard_widgets_observers.rs
@@ -1,11 +1,7 @@
-//! This example illustrates how to create widgets using the `bevy_core_widgets` widget set.
+//! This example illustrates how to create widgets using the `bevy_ui_widgets` widget set.
 
 use bevy::{
     color::palettes::basic::*,
-    core_widgets::{
-        Activate, Callback, CoreButton, CoreCheckbox, CoreSlider, CoreSliderThumb,
-        CoreWidgetsPlugins, SliderRange, SliderValue, ValueChange,
-    },
     ecs::system::SystemId,
     input_focus::{
         tab_navigation::{TabGroup, TabIndex, TabNavigationPlugin},
@@ -14,13 +10,17 @@ use bevy::{
     picking::hover::Hovered,
     prelude::*,
     ui::{Checked, InteractionDisabled, Pressed},
+    ui_widgets::{
+        Activate, Button, Callback, Checkbox, Slider, SliderRange, SliderThumb, SliderValue,
+        ValueChange, WidgetBehaviorPlugins,
+    },
 };
 
 fn main() {
     App::new()
         .add_plugins((
             DefaultPlugins,
-            CoreWidgetsPlugins,
+            WidgetBehaviorPlugins,
             InputDispatchPlugin,
             TabNavigationPlugin,
         ))
@@ -136,7 +136,7 @@ fn button(asset_server: &AssetServer, on_click: Callback<In<Activate>>) -> impl
             ..default()
         },
         DemoButton,
-        CoreButton {
+        Button {
             on_activate: on_click,
         },
         Hovered::default(),
@@ -369,7 +369,7 @@ fn slider(
         Name::new("Slider"),
         Hovered::default(),
         DemoSlider,
-        CoreSlider {
+        Slider {
             on_change,
             ..default()
         },
@@ -403,7 +403,7 @@ fn slider(
                 children![(
                     // Thumb
                     DemoSliderThumb,
-                    CoreSliderThumb,
+                    SliderThumb,
                     Node {
                         display: Display::Flex,
                         width: px(12),
@@ -534,7 +534,7 @@ fn checkbox(
         Name::new("Checkbox"),
         Hovered::default(),
         DemoCheckbox,
-        CoreCheckbox { on_change },
+        Checkbox { on_change },
         TabIndex(0),
         Children::spawn((
             Spawn((
@@ -736,7 +736,7 @@ fn toggle_disabled(
     input: Res<ButtonInput<KeyCode>>,
     mut interaction_query: Query<
         (Entity, Has<InteractionDisabled>),
-        Or<(With<CoreButton>, With<CoreSlider>, With<CoreCheckbox>)>,
+        Or<(With<Button>, With<Slider>, With<Checkbox>)>,
     >,
     mut commands: Commands,
 ) {
diff --git a/examples/ui/virtual_keyboard.rs b/examples/ui/virtual_keyboard.rs
index a6eef0a9dbaae..870e153dfa305 100644
--- a/examples/ui/virtual_keyboard.rs
+++ b/examples/ui/virtual_keyboard.rs
@@ -2,20 +2,20 @@
 
 use bevy::{
     color::palettes::css::NAVY,
-    core_widgets::{Activate, CoreWidgetsPlugins},
     ecs::relationship::RelatedSpawnerCommands,
     feathers::{
         controls::virtual_keyboard, dark_theme::create_dark_theme, theme::UiTheme, FeathersPlugin,
     },
     input_focus::{tab_navigation::TabNavigationPlugin, InputDispatchPlugin},
     prelude::*,
+    ui_widgets::{Activate, WidgetBehaviorPlugins},
 };
 
 fn main() {
     App::new()
         .add_plugins((
             DefaultPlugins,
-            CoreWidgetsPlugins,
+            WidgetBehaviorPlugins,
             InputDispatchPlugin,
             TabNavigationPlugin,
             FeathersPlugin,
diff --git a/release-content/release-notes/headless-widgets.md b/release-content/release-notes/headless-widgets.md
index b812385e5b450..5fc8b6a4e944c 100644
--- a/release-content/release-notes/headless-widgets.md
+++ b/release-content/release-notes/headless-widgets.md
@@ -1,7 +1,7 @@
 ---
 title: Headless Widgets
 authors: ["@viridia", "@ickshonpe", "@alice-i-cecile"]
-pull_requests: [19366, 19584, 19665, 19778, 19803, 20032, 20036, 20086]
+pull_requests: [19366, 19584, 19665, 19778, 19803, 20032, 20036, 20086, 20944]
 ---
 
 Bevy's `Button` and `Interaction` components have been around for a long time. Unfortunately
@@ -22,25 +22,25 @@ including integration with screen readers, but which are unstyled. It's the resp
 game developer to provide the visual style and animation for the widgets, which can fit the overall
 style of their game.
 
-With this release, Bevy introduces a collection of headless or "core" widgets. These are components
-which can be added to any UI Node to get widget-like behavior. The core widget set includes buttons,
+With this release, Bevy introduces a collection of headless widgets. These are components
+which can be added to any UI Node to get widget-like behavior. The standard widget set includes buttons,
 sliders, scrollbars, checkboxes, radio buttons, and more. This set will likely be expanded in
 future releases.
 
-## Core Widgets
+## Standard Widgets
 
-The `bevy_core_widgets` crate provides implementations of unstyled widgets, such as buttons,
+The `bevy_ui_widgets` crate provides implementations of unstyled widgets, such as buttons,
 sliders, checkboxes and radio buttons.
 
-- `CoreButton` is a push button. It emits an activation event when clicked.
-- `CoreSlider` is a standard slider, which lets you edit an `f32` value in a given range.
-- `CoreScrollbar` can be used to implement scrollbars.
-- `CoreCheckbox` can be used for checkboxes and toggle switches.
-- `CoreRadio` and `CoreRadioGroup` can be used for radio buttons.
+- `ui_widgets::Button` is a push button. It emits an activation event when clicked.
+- `ui_widgets::Slider` is a standard slider, which lets you edit an `f32` value in a given range.
+- `ui_widgets::Scrollbar` can be used to implement scrollbars.
+- `ui_widgets::Checkbox` can be used for checkboxes and toggle switches.
+- `ui_widgets::RadioButton` and `ui_widgets::RadioGroup` can be used for radio buttons.
 
 ## Widget Interaction Marker Components
 
-Many of the core widgets will define supplementary ECS components that are used to store the widget's
+Many of the standard widgets will define supplementary ECS components that are used to store the widget's
 state, similar to how the old `Interaction` component worked, but in a way that is more flexible.
 These components include:
 
@@ -66,7 +66,7 @@ is using Bevy observers. This approach is useful in cases where you want the wid
 to bubble up the hierarchy.
 
 However, in UI work it's often desirable to send notifications "point-to-point" in ways that cut
-across the hierarchy. For these kinds of situations, the core widgets offer a different
+across the hierarchy. For these kinds of situations, the standard widgets offer a different
 approach: callbacks. The `Callback` enum allows different options for triggering a notification
 when a widget's state is updated. For example, you can pass in the `SystemId` of a registered
 one-shot system as a widget parameter when it is constructed. When the button subsequently
@@ -77,7 +77,7 @@ inject any additional parameters it needs to update the Bevy world in response t
 
 See the [Wikipedia Article on State Management](https://en.wikipedia.org/wiki/State_management).
 
-Most of the core widgets support "external state management" - something that is referred to in the
+Most of the standard widgets support "external state management" - something that is referred to in the
 React.js world as "controlled" widgets. This means that for widgets that edit a parameter value
 (such as checkboxes and sliders), the widget doesn't automatically update its own internal value,
 but only sends a notification to the app telling it that the value needs to change. It's the
