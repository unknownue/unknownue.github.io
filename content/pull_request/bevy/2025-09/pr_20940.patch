diff --git a/Cargo.toml b/Cargo.toml
index 170e9457589c7..05bee813f96b2 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -2719,6 +2719,17 @@ description = "Demonstrates how reflection in Bevy provides a way to dynamically
 category = "Reflection"
 wasm = false
 
+[[example]]
+name = "serialization"
+path = "examples/reflection/serialization.rs"
+doc-scrape-examples = true
+
+[package.metadata.example.serialization]
+name = "Serialization"
+description = "Demonstrates serialization and deserialization using reflection without serde's Serialize/Deserialize traits"
+category = "Reflection"
+wasm = false
+
 [[example]]
 name = "custom_attributes"
 path = "examples/reflection/custom_attributes.rs"
diff --git a/examples/README.md b/examples/README.md
index 443fa62639341..e7c694e2669de 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -433,6 +433,7 @@ Example | Description
 [Generic Reflection](../examples/reflection/generic_reflection.rs) | Registers concrete instances of generic types that may be used with reflection
 [Reflection](../examples/reflection/reflection.rs) | Demonstrates how reflection in Bevy provides a way to dynamically interact with Rust types
 [Reflection Types](../examples/reflection/reflection_types.rs) | Illustrates the various reflection types available
+[Serialization](../examples/reflection/serialization.rs) | Demonstrates serialization and deserialization using reflection without serde's Serialize/Deserialize traits
 [Type Data](../examples/reflection/type_data.rs) | Demonstrates how to create and use type data
 
 ### Remote Protocol
diff --git a/examples/reflection/serialization.rs b/examples/reflection/serialization.rs
new file mode 100644
index 0000000000000..9aa165f37260b
--- /dev/null
+++ b/examples/reflection/serialization.rs
@@ -0,0 +1,75 @@
+//! Illustrates how "reflection" serialization works in Bevy.
+//!
+//! Deriving `Reflect` will also register `SerializationData`,
+//! which powers reflect (de)serialization.
+//! Serializing reflected data *does not* require deriving serde's
+//! Serialize and Deserialize implementations.
+
+use bevy::{
+    prelude::*,
+    reflect::serde::{ReflectDeserializer, ReflectSerializer},
+};
+use serde::de::DeserializeSeed;
+
+fn main() {
+    App::new()
+        .add_plugins(DefaultPlugins)
+        .add_systems(Startup, (deserialize, serialize).chain())
+        .run();
+}
+
+/// Deriving `Reflect` includes reflecting `SerializationData`
+#[derive(Reflect)]
+pub struct Player {
+    name: String,
+    health: u32,
+}
+
+const PLAYER_JSON: &str = r#"{
+    "serialization::Player": {
+        "name": "BevyPlayerOne",
+        "health": 50
+    }
+}"#;
+
+fn deserialize(type_registry: Res<AppTypeRegistry>) {
+    let type_registry = type_registry.read();
+
+    // a serde_json::Value that might have come from an API
+    let value: serde_json::Value = serde_json::from_str(PLAYER_JSON).unwrap();
+
+    // alternatively, `TypedReflectDeserializer` can be used if the type
+    // is known.
+    let deserializer = ReflectDeserializer::new(&type_registry);
+    // deserialize
+    let reflect_value = deserializer.deserialize(value).unwrap();
+    // If Player implemented additional functionality, like Component,
+    // this reflect_value could be used with commands.insert_reflect
+    info!(?reflect_value);
+
+    // `FromReflect` and `ReflectFromReflect` can yield a concrete value.
+    let type_id = reflect_value.get_represented_type_info().unwrap().type_id();
+    let reflect_from_reflect = type_registry
+        .get_type_data::<ReflectFromReflect>(type_id)
+        .unwrap();
+    let player: Box<dyn Reflect> = reflect_from_reflect
+        .from_reflect(reflect_value.as_partial_reflect())
+        .unwrap();
+    info!(?player);
+}
+
+fn serialize(type_registry: Res<AppTypeRegistry>) {
+    let type_registry = type_registry.read();
+
+    // a concrete value
+    let value = Player {
+        name: "BevyPlayerSerialize".to_string(),
+        health: 80,
+    };
+
+    // By default, all derived `Reflect` types can be serialized using serde. No need to derive
+    // Serialize!
+    let serializer = ReflectSerializer::new(&value, &type_registry);
+    let json = serde_json::to_string(&serializer).unwrap();
+    info!(?json);
+}
