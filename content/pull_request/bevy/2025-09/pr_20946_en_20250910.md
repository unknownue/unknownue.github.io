+++
title = "#20946 Add Image::clear()"
date = "2025-09-10T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-09/pr-20946-en-20250910" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-09/pr-20946-zh-cn-20250910" }}
labels = ["D-Trivial", "A-Rendering", "C-Usability"]
+++

# Add Image::clear()

## Basic Information
- **Title**: Add Image::clear()
- **PR Link**: https://github.com/bevyengine/bevy/pull/20946
- **Author**: IceSentry
- **Status**: MERGED
- **Labels**: D-Trivial, A-Rendering, C-Usability, S-Ready-For-Final-Review
- **Created**: 2025-09-10T04:31:31Z
- **Merged**: 2025-09-10T16:48:10Z
- **Merged By**: mockersf

## Description Translation
# Objective

- When doing cpu drawing you sometimes need to clear the entire image. One option is to recreate a new image but this isn't the most efficient.

## Solution

- Add a utility function that clears the image using the provided pixel data. It does the exact same thing the `Image::new_fill()` does to fill the data buffer.

## Testing

- I added a test that makes sure the clear fills the image with the expected data.

## The Story of This Pull Request

This PR addresses a common performance optimization need in CPU-based image manipulation scenarios. When working with image data on the CPU, developers occasionally need to reset an entire image to a uniform color or pattern. The existing approach required creating a completely new Image instance, which incurred unnecessary allocation overhead and memory operations.

The solution implements a clear() method that operates directly on existing image data when available. The implementation follows the same pattern used by Image::new_fill() but applies it to an existing image buffer. This approach avoids the overhead of creating new allocations while providing identical functionality for clearing operations.

The implementation handles several edge cases gracefully:
- It returns early if the image format has a pixel size of zero or cannot be determined
- It includes debug assertions to validate that the provided pixel data matches expected size requirements
- It only operates when image data is already initialized (CPU-side), making it a no-op for GPU-only images

The method works by calculating the total byte length needed based on the image dimensions and format, then iterating through the existing data buffer in chunks corresponding to pixel size, copying the provided pixel data into each position.

A comprehensive test was added to verify the functionality works correctly. The test creates an image filled with zeros, verifies the initial state, clears it with a different value (255), and confirms the entire image was updated appropriately.

This change provides a straightforward performance optimization for CPU image manipulation workflows while maintaining the existing API consistency and safety guarantees of the Image type.

## Visual Representation

```mermaid
graph TD
    A[CPU Image Manipulation] --> B{Need to clear image?}
    B -->|Yes| C[Use Image::clear()]
    B -->|No| D[Continue normal operations]
    C --> E[Efficient in-place update]
    D --> F[Other image operations]
    E --> F
```

## Key Files Changed

**File: crates/bevy_image/src/image.rs**

This file received two main additions:
1. A new `clear()` method for the Image struct
2. A corresponding test function to verify the clear operation works correctly

**Code Changes:**

```rust
// New method added to Image implementation
pub fn clear(&mut self, pixel: &[u8]) {
    if let Ok(pixel_size) = self.texture_descriptor.format.pixel_size()
        && pixel_size > 0
    {
        let byte_len = pixel_size * self.texture_descriptor.size.volume();
        debug_assert_eq!(
            pixel.len() % pixel_size,
            0,
            "Must not have incomplete pixel data (pixel size is {}B).",
            pixel_size,
        );
        debug_assert!(
            pixel.len() <= byte_len,
            "Clear data must fit within pixel buffer (expected {byte_len}B).",
        );
        if let Some(data) = self.data.as_mut() {
            for pixel_data in data.chunks_mut(pixel_size) {
                pixel_data.copy_from_slice(pixel);
            }
        }
    }
}

// New test added
#[test]
fn image_clear() {
    let mut image = Image::new_fill(
        Extent3d {
            width: 32,
            height: 32,
            depth_or_array_layers: 1,
        },
        TextureDimension::D2,
        &[0; 4],
        TextureFormat::Rgba8Snorm,
        RenderAssetUsages::all(),
    );

    assert!(image.data.as_ref().unwrap().iter().all(|&p| p == 0));

    image.clear(&[255; 4]);

    assert!(image.data.as_ref().unwrap().iter().all(|&p| p == 255));
}
```

## Further Reading

- Bevy Image Documentation: https://docs.rs/bevy/latest/bevy/render/texture/struct.Image.html
- Texture Formats in Bevy: https://docs.rs/bevy/latest/bevy/render/texture/enum.TextureFormat.html
- CPU Image Manipulation Patterns: https://github.com/bevyengine/bevy/discussions/20177

# Full Code Diff
```diff
diff --git a/crates/bevy_image/src/image.rs b/crates/bevy_image/src/image.rs
index 9a6fcc63b8a7e..45e62ebe3c520 100644
--- a/crates/bevy_image/src/image.rs
+++ b/crates/bevy_image/src/image.rs
@@ -1291,6 +1291,33 @@ impl Image {
         offset.map(|start| &mut data[start..(start + len)])
     }
 
+    /// Clears the content of the image with the given pixel. The image needs to be initialized on
+    /// the cpu otherwise this is a noop.
+    ///
+    /// This does nothing if the image data is not already initialized
+    pub fn clear(&mut self, pixel: &[u8]) {
+        if let Ok(pixel_size) = self.texture_descriptor.format.pixel_size()
+            && pixel_size > 0
+        {
+            let byte_len = pixel_size * self.texture_descriptor.size.volume();
+            debug_assert_eq!(
+                pixel.len() % pixel_size,
+                0,
+                "Must not have incomplete pixel data (pixel size is {}B).",
+                pixel_size,
+            );
+            debug_assert!(
+                pixel.len() <= byte_len,
+                "Clear data must fit within pixel buffer (expected {byte_len}B).",
+            );
+            if let Some(data) = self.data.as_mut() {
+                for pixel_data in data.chunks_mut(pixel_size) {
+                    pixel_data.copy_from_slice(pixel);
+                }
+            }
+        }
+    }
+
     /// Read the color of a specific pixel (1D texture).
     ///
     /// See [`get_color_at`](Self::get_color_at) for more details.
@@ -2137,4 +2164,25 @@ mod test {
             Ok(Color::LinearRgba(GROW_FILL))
         ));
     }
+
+    #[test]
+    fn image_clear() {
+        let mut image = Image::new_fill(
+            Extent3d {
+                width: 32,
+                height: 32,
+                depth_or_array_layers: 1,
+            },
+            TextureDimension::D2,
+            &[0; 4],
+            TextureFormat::Rgba8Snorm,
+            RenderAssetUsages::all(),
+        );
+
+        assert!(image.data.as_ref().unwrap().iter().all(|&p| p == 0));
+
+        image.clear(&[255; 4]);
+
+        assert!(image.data.as_ref().unwrap().iter().all(|&p| p == 255));
+    }
 }
```