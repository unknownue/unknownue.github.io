diff --git a/crates/bevy_ecs/compile_fail/tests/ui/bundle_on_drop_impl.rs b/crates/bevy_ecs/compile_fail/tests/ui/bundle_on_drop_impl.rs
new file mode 100644
index 0000000000000..5381ebde89e31
--- /dev/null
+++ b/crates/bevy_ecs/compile_fail/tests/ui/bundle_on_drop_impl.rs
@@ -0,0 +1,17 @@
+use bevy_ecs::prelude::*;
+
+#[derive(Component, Debug)]
+pub struct A(usize);
+
+// this should fail since destructuring T: Drop cannot be split.
+#[derive(Bundle, Debug)]
+//~^ E0509
+pub struct DropBundle {
+    component_a: A,
+}
+
+impl Drop for DropBundle {
+    fn drop(&mut self) {
+        // Just need the impl
+    }
+}
diff --git a/crates/bevy_ecs/macros/src/lib.rs b/crates/bevy_ecs/macros/src/lib.rs
index 3e8276532e129..69a4b53d6afc5 100644
--- a/crates/bevy_ecs/macros/src/lib.rs
+++ b/crates/bevy_ecs/macros/src/lib.rs
@@ -115,6 +115,7 @@ pub fn derive_bundle(input: TokenStream) -> TokenStream {
 
     let mut active_field_types = Vec::new();
     let mut active_field_tokens = Vec::new();
+    let mut active_field_alias: Vec<proc_macro2::TokenStream> = Vec::new();
     let mut inactive_field_tokens = Vec::new();
     for (((i, field_type), field_kind), field) in field_type
         .iter()
@@ -122,6 +123,7 @@ pub fn derive_bundle(input: TokenStream) -> TokenStream {
         .zip(field_kind.iter())
         .zip(field.iter())
     {
+        let field_alias = format_ident!("field_{}", i).to_token_stream();
         let field_tokens = match field {
             Some(field) => field.to_token_stream(),
             None => Index::from(i).to_token_stream(),
@@ -129,6 +131,7 @@ pub fn derive_bundle(input: TokenStream) -> TokenStream {
         match field_kind {
             BundleFieldKind::Component => {
                 active_field_types.push(field_type);
+                active_field_alias.push(field_alias);
                 active_field_tokens.push(field_tokens);
             }
 
@@ -163,16 +166,46 @@ pub fn derive_bundle(input: TokenStream) -> TokenStream {
     };
 
     let dynamic_bundle_impl = quote! {
-        #[allow(deprecated)]
+        #[doc(hidden)]
+        #[expect(dead_code, reason = "This is a static assertion.")]
+        impl #impl_generics #struct_name #ty_generics #where_clause {
+            // Types that implement `Drop` cannot have their fields moved out. The implementation in
+            // `get_componments` avoids this with pointers, so there needs to be a static assertion
+            // that this is a sound thing to do. See https://doc.rust-lang.org/error_codes/E0509.html
+            // for more information.
+            fn check_no_bundle_drop(self) {
+                // This has no effect, but we need to make sure the compiler doesn't optimize it out
+                // black_box is used to do this
+                #( core::hint::black_box(self.#active_field_tokens); )*
+            }
+        }
+
         impl #impl_generics #ecs_path::bundle::DynamicBundle for #struct_name #ty_generics #where_clause {
             type Effect = ();
             #[allow(unused_variables)]
             #[inline]
-            fn get_components(
-                self,
+            unsafe fn get_components(
+                ptr: #ecs_path::ptr::MovingPtr<'_, Self>,
                 func: &mut impl FnMut(#ecs_path::component::StorageType, #ecs_path::ptr::OwningPtr<'_>)
             ) {
-                #(<#active_field_types as #ecs_path::bundle::DynamicBundle>::get_components(self.#active_field_tokens, &mut *func);)*
+                use #ecs_path::__macro_exports::DebugCheckedUnwrap;
+
+                #( let #active_field_alias = ptr.move_field(|ptr| &raw mut (*ptr).#active_field_tokens); )*
+                core::mem::forget(ptr);
+                #(
+                    <#active_field_types as #ecs_path::bundle::DynamicBundle>::get_components(
+                        #active_field_alias.try_into().debug_checked_unwrap(),
+                        func
+                    );
+                )*
+            }
+
+            #[allow(unused_variables)]
+            #[inline]
+            unsafe fn apply_effect(
+                ptr: #ecs_path::ptr::MovingPtr<'_, core::mem::MaybeUninit<Self>>,
+                func: &mut #ecs_path::world::EntityWorldMut<'_>,
+            ) {
             }
         }
     };
diff --git a/crates/bevy_ecs/src/bundle/impls.rs b/crates/bevy_ecs/src/bundle/impls.rs
index 9b67c7d4be2a8..7cf74a86e324f 100644
--- a/crates/bevy_ecs/src/bundle/impls.rs
+++ b/crates/bevy_ecs/src/bundle/impls.rs
@@ -1,11 +1,13 @@
 use core::any::TypeId;
 
-use bevy_ptr::OwningPtr;
-use variadics_please::all_tuples;
+use bevy_ptr::{MovingPtr, OwningPtr};
+use core::mem::MaybeUninit;
+use variadics_please::all_tuples_enumerated;
 
 use crate::{
-    bundle::{Bundle, BundleEffect, BundleFromComponents, DynamicBundle, NoBundleEffect},
+    bundle::{Bundle, BundleFromComponents, DynamicBundle, NoBundleEffect},
     component::{Component, ComponentId, Components, ComponentsRegistrator, StorageType},
+    query::DebugCheckedUnwrap,
     world::EntityWorldMut,
 };
 
@@ -40,13 +42,19 @@ unsafe impl<C: Component> BundleFromComponents for C {
 impl<C: Component> DynamicBundle for C {
     type Effect = ();
     #[inline]
-    fn get_components(self, func: &mut impl FnMut(StorageType, OwningPtr<'_>)) -> Self::Effect {
-        OwningPtr::make(self, |ptr| func(C::STORAGE_TYPE, ptr));
+    unsafe fn get_components(
+        ptr: MovingPtr<'_, Self>,
+        func: &mut impl FnMut(StorageType, OwningPtr<'_>),
+    ) -> Self::Effect {
+        func(C::STORAGE_TYPE, OwningPtr::from(ptr));
     }
+
+    #[inline]
+    unsafe fn apply_effect(_ptr: MovingPtr<'_, MaybeUninit<Self>>, _entity: &mut EntityWorldMut) {}
 }
 
 macro_rules! tuple_impl {
-    ($(#[$meta:meta])* $($name: ident),*) => {
+    ($(#[$meta:meta])* $(($index:tt, $name: ident, $alias: ident)),*) => {
         #[expect(
             clippy::allow_attributes,
             reason = "This is a tuple-related macro; as such, the lints below may not always apply."
@@ -125,59 +133,52 @@ macro_rules! tuple_impl {
                 reason = "Zero-length tuples will generate a function body equivalent to `()`; however, this macro is meant for all applicable tuples, and as such it makes no sense to rewrite it just for that case."
             )]
             #[inline(always)]
-            fn get_components(self, func: &mut impl FnMut(StorageType, OwningPtr<'_>)) -> Self::Effect {
-                #[allow(
-                    non_snake_case,
-                    reason = "The names of these variables are provided by the caller, not by us."
-                )]
-                let ($(mut $name,)*) = self;
-                ($(
-                    $name.get_components(&mut *func),
-                )*)
+            unsafe fn get_components(ptr: MovingPtr<'_, Self>, func: &mut impl FnMut(StorageType, OwningPtr<'_>)) {
+                // SAFETY:
+                // - All of the `move_field` calls all fetch distinct and valid fields within `Self`.
+                // - If a field is `NoBundleEffect`, it's `apply_effect` is a no-op
+                //   and cannot move any value out of an invalid instance after this call.
+                // - If a field is `!NoBundleEffect`, it must be valid since a safe
+                //   implementation of `DynamicBundle` only moves the value out only
+                //   once between `get_components` and `apply_effect`.
+                bevy_ptr::deconstruct_moving_ptr!(ptr => ($($index => $alias,)*));
+                // SAFETY:
+                // - If `ptr` is aligned, then field_ptr is aligned properly. Rust tuples cannot be `repr(packed)`.
+                $( $name::get_components($alias.try_into().debug_checked_unwrap(), func); )*
             }
-        }
-    }
-}
-
-all_tuples!(
-    #[doc(fake_variadic)]
-    tuple_impl,
-    0,
-    15,
-    B
-);
 
-macro_rules! after_effect_impl {
-    ($(#[$meta:meta])* $($after_effect: ident),*) => {
-        #[expect(
-            clippy::allow_attributes,
-            reason = "This is a tuple-related macro; as such, the lints below may not always apply."
-        )]
-        $(#[$meta])*
-        impl<$($after_effect: BundleEffect),*> BundleEffect for ($($after_effect,)*) {
             #[allow(
                 clippy::unused_unit,
-                reason = "Zero-length tuples will generate a function body equivalent to `()`; however, this macro is meant for all applicable tuples, and as such it makes no sense to rewrite it just for that case.")
-            ]
-            fn apply(self, _entity: &mut EntityWorldMut) {
-                #[allow(
-                    non_snake_case,
-                    reason = "The names of these variables are provided by the caller, not by us."
-                )]
-                let ($($after_effect,)*) = self;
-                $($after_effect.apply(_entity);)*
+                reason = "Zero-length tuples will generate a function body equivalent to `()`; however, this macro is meant for all applicable tuples, and as such it makes no sense to rewrite it just for that case."
+            )]
+            #[inline(always)]
+            unsafe fn apply_effect(ptr: MovingPtr<'_, MaybeUninit<Self>>, entity: &mut EntityWorldMut) {
+                // SAFETY:
+                // - All of the `move_field` calls all fetch distinct and valid fields within `Self`.
+                // - If a field is `NoBundleEffect`, it's `apply_effect` is a no-op
+                //   and cannot move any value out of an invalid instance.
+                // - If a field is `!NoBundleEffect`, it must be valid since a safe
+                //   implementation of `DynamicBundle` only moves the value out only
+                //   once between `get_components` and `apply_effect`.
+                bevy_ptr::deconstruct_moving_ptr!(ptr: MaybeUninit => (
+                    $($index => $alias,)*
+                ));
+                // SAFETY:
+                // - If `ptr` is aligned, then field_ptr is aligned properly. Rust tuples cannot be `repr(packed)`.
+                $( $name::apply_effect($alias.try_into().debug_checked_unwrap(), entity); )*
             }
         }
 
         $(#[$meta])*
-        impl<$($after_effect: NoBundleEffect),*> NoBundleEffect for ($($after_effect,)*) { }
+        impl<$($name: NoBundleEffect),*> NoBundleEffect for ($($name,)*) {}
     }
 }
 
-all_tuples!(
+all_tuples_enumerated!(
     #[doc(fake_variadic)]
-    after_effect_impl,
+    tuple_impl,
     0,
     15,
-    P
+    B,
+    field_
 );
diff --git a/crates/bevy_ecs/src/bundle/info.rs b/crates/bevy_ecs/src/bundle/info.rs
index 4990a2ffbb004..589ec0b7c65e6 100644
--- a/crates/bevy_ecs/src/bundle/info.rs
+++ b/crates/bevy_ecs/src/bundle/info.rs
@@ -3,7 +3,7 @@ use bevy_platform::{
     collections::{HashMap, HashSet},
     hash::FixedHasher,
 };
-use bevy_ptr::OwningPtr;
+use bevy_ptr::{MovingPtr, OwningPtr};
 use bevy_utils::TypeIdMap;
 use core::{any::TypeId, ptr::NonNull};
 use indexmap::{IndexMap, IndexSet};
@@ -228,8 +228,14 @@ impl BundleInfo {
     /// which removes the need to look up the [`ArchetypeAfterBundleInsert`](crate::archetype::ArchetypeAfterBundleInsert)
     /// in the archetype graph, which requires ownership of the entity's current archetype.
     ///
+    /// Regardless of how this is used, [`apply_effect`] must be called at most once on `bundle` after this function is
+    /// called if `T::Effect: !NoBundleEffect` before returning to user-space safe code before returning to user-space safe code.
+    /// This is currently only doable via use of [`MovingPtr::partial_move`].
+    ///
     /// `table` must be the "new" table for `entity`. `table_row` must have space allocated for the
     /// `entity`, `bundle` must match this [`BundleInfo`]'s type
+    ///
+    /// [`apply_effect`]: crate::bundle::DynamicBundle::apply_effect
     #[inline]
     pub(super) unsafe fn write_components<'a, T: DynamicBundle, S: BundleComponentStatus>(
         &self,
@@ -240,14 +246,14 @@ impl BundleInfo {
         entity: Entity,
         table_row: TableRow,
         change_tick: Tick,
-        bundle: T,
+        bundle: MovingPtr<'_, T>,
         insert_mode: InsertMode,
         caller: MaybeLocation,
-    ) -> T::Effect {
+    ) {
         // NOTE: get_components calls this closure on each component in "bundle order".
         // bundle_info.component_ids are also in "bundle order"
         let mut bundle_component = 0;
-        let after_effect = bundle.get_components(&mut |storage_type, component_ptr| {
+        T::get_components(bundle, &mut |storage_type, component_ptr| {
             let component_id = *self
                 .contributed_component_ids
                 .get_unchecked(bundle_component);
@@ -303,8 +309,6 @@ impl BundleInfo {
                 caller,
             );
         }
-
-        after_effect
     }
 
     /// Internal method to initialize a required component from an [`OwningPtr`]. This should ultimately be called
diff --git a/crates/bevy_ecs/src/bundle/insert.rs b/crates/bevy_ecs/src/bundle/insert.rs
index 86a356291ce55..e104265380088 100644
--- a/crates/bevy_ecs/src/bundle/insert.rs
+++ b/crates/bevy_ecs/src/bundle/insert.rs
@@ -1,5 +1,5 @@
 use alloc::vec::Vec;
-use bevy_ptr::ConstNonNull;
+use bevy_ptr::{ConstNonNull, MovingPtr};
 use core::ptr::NonNull;
 
 use crate::{
@@ -138,18 +138,25 @@ impl<'w> BundleInserter<'w> {
     }
 
     /// # Safety
-    /// `entity` must currently exist in the source archetype for this inserter. `location`
-    /// must be `entity`'s location in the archetype. `T` must match this [`BundleInfo`]'s type
+    /// - `entity` must currently exist in the source archetype for this inserter.
+    /// - `location` must be `entity`'s location in the archetype.
+    /// - `T` must match this [`BundleInserter`] type used to create
+    /// - If `T::Effect: !NoBundleEffect.`, then [`apply_effect`] must be called at most once on
+    ///   `bundle` after this function before returning to user-space safe code.
+    /// - The value pointed to by `bundle` must not be accessed for anything other than [`apply_effect`]
+    ///   or dropped.
+    ///
+    /// [`apply_effect`]: crate::bundle::DynamicBundle::apply_effect
     #[inline]
     pub(crate) unsafe fn insert<T: DynamicBundle>(
         &mut self,
         entity: Entity,
         location: EntityLocation,
-        bundle: T,
+        bundle: MovingPtr<'_, T>,
         insert_mode: InsertMode,
         caller: MaybeLocation,
         relationship_hook_mode: RelationshipHookMode,
-    ) -> (EntityLocation, T::Effect) {
+    ) -> EntityLocation {
         let bundle_info = self.bundle_info.as_ref();
         let archetype_after_insert = self.archetype_after_insert.as_ref();
         let archetype = self.archetype.as_ref();
@@ -188,7 +195,7 @@ impl<'w> BundleInserter<'w> {
         // so this reference can only be promoted from shared to &mut down here, after they have been ran
         let archetype = self.archetype.as_mut();
 
-        let (new_archetype, new_location, after_effect) = match &mut self.archetype_move_type {
+        let (new_archetype, new_location) = match &mut self.archetype_move_type {
             ArchetypeMoveType::SameArchetype => {
                 // SAFETY: Mutable references do not alias and will be dropped after this block
                 let sparse_sets = {
@@ -196,7 +203,7 @@ impl<'w> BundleInserter<'w> {
                     &mut world.storages.sparse_sets
                 };
 
-                let after_effect = bundle_info.write_components(
+                bundle_info.write_components(
                     table,
                     sparse_sets,
                     archetype_after_insert,
@@ -209,7 +216,7 @@ impl<'w> BundleInserter<'w> {
                     caller,
                 );
 
-                (archetype, location, after_effect)
+                (archetype, location)
             }
             ArchetypeMoveType::NewArchetypeSameTable { new_archetype } => {
                 let new_archetype = new_archetype.as_mut();
@@ -237,7 +244,7 @@ impl<'w> BundleInserter<'w> {
                 }
                 let new_location = new_archetype.allocate(entity, result.table_row);
                 entities.set(entity.index(), Some(new_location));
-                let after_effect = bundle_info.write_components(
+                bundle_info.write_components(
                     table,
                     sparse_sets,
                     archetype_after_insert,
@@ -250,7 +257,7 @@ impl<'w> BundleInserter<'w> {
                     caller,
                 );
 
-                (new_archetype, new_location, after_effect)
+                (new_archetype, new_location)
             }
             ArchetypeMoveType::NewArchetypeNewTable {
                 new_archetype,
@@ -319,7 +326,7 @@ impl<'w> BundleInserter<'w> {
                     }
                 }
 
-                let after_effect = bundle_info.write_components(
+                bundle_info.write_components(
                     new_table,
                     sparse_sets,
                     archetype_after_insert,
@@ -332,7 +339,7 @@ impl<'w> BundleInserter<'w> {
                     caller,
                 );
 
-                (new_archetype, new_location, after_effect)
+                (new_archetype, new_location)
             }
         };
 
@@ -411,7 +418,7 @@ impl<'w> BundleInserter<'w> {
             }
         }
 
-        (new_location, after_effect)
+        new_location
     }
 
     #[inline]
diff --git a/crates/bevy_ecs/src/bundle/mod.rs b/crates/bevy_ecs/src/bundle/mod.rs
index 956b478c5e8d4..17d894d40b660 100644
--- a/crates/bevy_ecs/src/bundle/mod.rs
+++ b/crates/bevy_ecs/src/bundle/mod.rs
@@ -14,6 +14,8 @@ pub(crate) use insert::BundleInserter;
 pub(crate) use remove::BundleRemover;
 pub(crate) use spawner::BundleSpawner;
 
+use bevy_ptr::MovingPtr;
+use core::mem::MaybeUninit;
 pub use info::*;
 
 /// Derive the [`Bundle`] trait
@@ -234,33 +236,57 @@ pub unsafe trait BundleFromComponents {
 }
 
 /// The parts from [`Bundle`] that don't require statically knowing the components of the bundle.
-pub trait DynamicBundle {
+pub trait DynamicBundle: Sized {
     /// An operation on the entity that happens _after_ inserting this bundle.
-    type Effect: BundleEffect;
-    // SAFETY:
-    // The `StorageType` argument passed into [`Bundle::get_components`] must be correct for the
-    // component being fetched.
-    //
-    /// Calls `func` on each value, in the order of this bundle's [`Component`]s. This passes
-    /// ownership of the component values to `func`.
-    #[doc(hidden)]
-    fn get_components(self, func: &mut impl FnMut(StorageType, OwningPtr<'_>)) -> Self::Effect;
-}
+    type Effect;
+
+    /// Moves the components out of the bundle.
+    ///
+    /// # Safety
+    /// For callers:
+    /// - Must be called exactly once before `apply_effect`
+    /// - The `StorageType` argument passed into `func` must be correct for the component being fetched.
+    /// - `apply_effect` must be called exactly once after this has been called if `Effect: !NoBundleEffect`
+    ///
+    /// For implementors:
+    ///  - Implementors of this function must convert `ptr` into pointers to individual components stored within
+    ///    `Self` and call `func` on each of them in exactly the same order as [`Bundle::get_component_ids`] and
+    ///    [`BundleFromComponents::from_components`].
+    ///  - If any part of `ptr` is to be accessed in `apply_effect`, it must *not* be dropped at any point in this
+    ///    function. Calling [`bevy_ptr::deconstruct_moving_ptr`] in this function automatically ensures this.
+    ///
+    /// [`Component`]: crate::component::Component
+    // This function explicitly uses `MovingPtr` to avoid potentially large stack copies of the bundle
+    // when inserting into ECS storage. See https://github.com/bevyengine/bevy/issues/20571 for more
+    // information.
+    unsafe fn get_components(
+        ptr: MovingPtr<'_, Self>,
+        func: &mut impl FnMut(StorageType, OwningPtr<'_>),
+    );
 
-/// An operation on an [`Entity`](crate::entity::Entity) that occurs _after_ inserting the
-/// [`Bundle`] that defined this bundle effect.
-/// The order of operations is:
-///
-/// 1. The [`Bundle`] is inserted on the entity
-/// 2. Relevant Hooks are run for the insert, then Observers
-/// 3. The [`BundleEffect`] is run.
-///
-/// See [`DynamicBundle::Effect`].
-pub trait BundleEffect {
-    /// Applies this effect to the given `entity`.
-    fn apply(self, entity: &mut EntityWorldMut);
+    /// Applies the after-effects of spawning this bundle.
+    ///
+    /// This is applied after all residual changes to the [`World`], including flushing the internal command
+    /// queue.
+    ///
+    /// # Safety
+    /// For callers:
+    /// - Must be called exactly once after `get_components` has been called.
+    /// - `ptr` must point to the instance of `Self` that `get_components` was called on,
+    ///   all of fields that were moved out of in `get_components` will not be valid anymore.
+    ///
+    /// For implementors:
+    ///  - If any part of `ptr` is to be accessed in this function, it must *not* be dropped at any point in
+    ///    `get_components`. Calling [`bevy_ptr::deconstruct_moving_ptr`] in `get_components` automatically
+    ///    ensures this is the case.
+    ///
+    /// [`World`]: crate::world::World
+    // This function explicitly uses `MovingPtr` to avoid potentially large stack copies of the bundle
+    // when inserting into ECS storage. See https://github.com/bevyengine/bevy/issues/20571 for more
+    // information.
+    unsafe fn apply_effect(ptr: MovingPtr<'_, MaybeUninit<Self>>, entity: &mut EntityWorldMut);
 }
 
-/// A trait implemented for [`BundleEffect`] implementations that do nothing. This is used as a type constraint for
+/// A trait implemented for [`DynamicBundle::Effect`] implementations that do nothing. This is used as a type constraint for
 /// [`Bundle`] APIs that do not / cannot run [`DynamicBundle::Effect`], such as "batch spawn" APIs.
 pub trait NoBundleEffect {}
diff --git a/crates/bevy_ecs/src/bundle/spawner.rs b/crates/bevy_ecs/src/bundle/spawner.rs
index 8a644429f342d..b4f32147aecdf 100644
--- a/crates/bevy_ecs/src/bundle/spawner.rs
+++ b/crates/bevy_ecs/src/bundle/spawner.rs
@@ -1,6 +1,6 @@
 use core::ptr::NonNull;
 
-use bevy_ptr::ConstNonNull;
+use bevy_ptr::{ConstNonNull, MovingPtr};
 
 use crate::{
     archetype::{Archetype, ArchetypeCreated, ArchetypeId, SpawnBundleStatus},
@@ -79,18 +79,25 @@ impl<'w> BundleSpawner<'w> {
     }
 
     /// # Safety
-    /// `entity` must be allocated (but non-existent), `T` must match this [`BundleInfo`]'s type
+    /// - `entity` must be allocated (but non-existent),
+    /// - `T` must match this [`BundleSpawner`]'s type
+    /// - If `T::Effect: !NoBundleEffect.`, then [`apply_effect`] must  be called exactly once on `bundle`
+    ///   after this function returns before returning to safe code.
+    /// - The value pointed to by `bundle` must not be accessed for anything other than [`apply_effect`]
+    ///   or dropped.
+    ///
+    /// [`apply_effect`]: crate::bundle::DynamicBundle::apply_effect
     #[inline]
     #[track_caller]
     pub unsafe fn spawn_non_existent<T: DynamicBundle>(
         &mut self,
         entity: Entity,
-        bundle: T,
+        bundle: MovingPtr<'_, T>,
         caller: MaybeLocation,
-    ) -> (EntityLocation, T::Effect) {
+    ) -> EntityLocation {
         // SAFETY: We do not make any structural changes to the archetype graph through self.world so these pointers always remain valid
         let bundle_info = self.bundle_info.as_ref();
-        let (location, after_effect) = {
+        let location = {
             let table = self.table.as_mut();
             let archetype = self.archetype.as_mut();
 
@@ -101,7 +108,7 @@ impl<'w> BundleSpawner<'w> {
             };
             let table_row = table.allocate(entity);
             let location = archetype.allocate(entity, table_row);
-            let after_effect = bundle_info.write_components(
+            bundle_info.write_components(
                 table,
                 sparse_sets,
                 &SpawnBundleStatus,
@@ -115,7 +122,7 @@ impl<'w> BundleSpawner<'w> {
             );
             entities.set(entity.index(), Some(location));
             entities.mark_spawn_despawn(entity.index(), caller, self.change_tick);
-            (location, after_effect)
+            location
         };
 
         // SAFETY: We have no outstanding mutable references to world as they were dropped
@@ -162,21 +169,33 @@ impl<'w> BundleSpawner<'w> {
             }
         };
 
-        (location, after_effect)
+        location
     }
 
     /// # Safety
-    /// `T` must match this [`BundleInfo`]'s type
+    /// - `T` must match this [`BundleSpawner`]'s type
+    /// - If `T::Effect: !NoBundleEffect.`, then [`apply_effect`] must  be called exactly once on `bundle`
+    ///   after this function returns before returning to safe code.
+    /// - The value pointed to by `bundle` must not be accessed for anything other than [`apply_effect`]
+    ///   or dropped.
+    ///
+    /// [`apply_effect`]: crate::bundle::DynamicBundle::apply_effect
     #[inline]
     pub unsafe fn spawn<T: Bundle>(
         &mut self,
-        bundle: T,
+        bundle: MovingPtr<'_, T>,
         caller: MaybeLocation,
-    ) -> (Entity, T::Effect) {
+    ) -> Entity {
         let entity = self.entities().alloc();
-        // SAFETY: entity is allocated (but non-existent), `T` matches this BundleInfo's type
-        let (_, after_effect) = unsafe { self.spawn_non_existent(entity, bundle, caller) };
-        (entity, after_effect)
+        // SAFETY:
+        // - `entity` is allocated above
+        // - The caller ensures that `T` matches this `BundleSpawner`'s type.
+        // - The caller ensures that if `T::Effect: !NoBundleEffect.`, then [`apply_effect`] must  be called exactly once on `bundle`
+        //   after this function returns before returning to safe code.
+        // - The caller ensures that the value pointed to by `bundle` must not be accessed for anything other than [`apply_effect`]
+        //   or dropped.
+        unsafe { self.spawn_non_existent::<T>(entity, bundle, caller) };
+        entity
     }
 
     #[inline]
diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index cb0c40913c042..bcbead5729aa2 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -133,6 +133,7 @@ pub mod __macro_exports {
     // Cannot directly use `alloc::vec::Vec` in macros, as a crate may not have
     // included `extern crate alloc;`. This re-export ensures we have access
     // to `Vec` in `no_std` and `std` contexts.
+    pub use crate::query::DebugCheckedUnwrap;
     pub use alloc::vec::Vec;
 }
 
@@ -1946,17 +1947,9 @@ mod tests {
     #[derive(Bundle)]
     struct Simple(ComponentA);
 
-    #[expect(
-        dead_code,
-        reason = "This struct is used as a compilation test to test the derive macros, and as such is intentionally never constructed."
-    )]
     #[derive(Bundle)]
     struct Tuple(Simple, ComponentB);
 
-    #[expect(
-        dead_code,
-        reason = "This struct is used as a compilation test to test the derive macros, and as such is intentionally never constructed."
-    )]
     #[derive(Bundle)]
     struct Record {
         field0: Simple,
diff --git a/crates/bevy_ecs/src/query/mod.rs b/crates/bevy_ecs/src/query/mod.rs
index 607b239f7059b..81f1c4ba49308 100644
--- a/crates/bevy_ecs/src/query/mod.rs
+++ b/crates/bevy_ecs/src/query/mod.rs
@@ -25,7 +25,8 @@ pub use world_query::*;
 /// debug modes if unwrapping a `None` or `Err` value in debug mode, but is
 /// equivalent to `Option::unwrap_unchecked` or `Result::unwrap_unchecked`
 /// in release mode.
-pub(crate) trait DebugCheckedUnwrap {
+#[doc(hidden)]
+pub trait DebugCheckedUnwrap {
     type Item;
     /// # Panics
     /// Panics if the value is `None` or `Err`, only in debug mode.
diff --git a/crates/bevy_ecs/src/spawn.rs b/crates/bevy_ecs/src/spawn.rs
index b2656f8192b5b..e4b7340c9ccfc 100644
--- a/crates/bevy_ecs/src/spawn.rs
+++ b/crates/bevy_ecs/src/spawn.rs
@@ -2,14 +2,20 @@
 //! for the best entry points into these APIs and examples of how to use them.
 
 use crate::{
-    bundle::{Bundle, BundleEffect, DynamicBundle, NoBundleEffect},
+    bundle::{Bundle, DynamicBundle, InsertMode, NoBundleEffect},
+    change_detection::MaybeLocation,
     entity::Entity,
-    relationship::{RelatedSpawner, Relationship, RelationshipTarget},
+    query::DebugCheckedUnwrap,
+    relationship::{RelatedSpawner, Relationship, RelationshipHookMode, RelationshipTarget},
     world::{EntityWorldMut, World},
 };
 use alloc::vec::Vec;
-use core::marker::PhantomData;
-use variadics_please::all_tuples;
+use bevy_ptr::{move_as_ptr, MovingPtr};
+use core::{
+    marker::PhantomData,
+    mem::{self, MaybeUninit},
+};
+use variadics_please::all_tuples_enumerated;
 
 /// A wrapper over a [`Bundle`] indicating that an entity should be spawned with that [`Bundle`].
 /// This is intended to be used for hierarchical spawning via traits like [`SpawnableList`] and [`SpawnRelated`].
@@ -37,18 +43,22 @@ pub struct Spawn<B: Bundle>(pub B);
 
 /// A spawn-able list of changes to a given [`World`] and relative to a given [`Entity`]. This is generally used
 /// for spawning "related" entities, such as children.
-pub trait SpawnableList<R> {
+pub trait SpawnableList<R>: Sized {
     /// Spawn this list of changes in a given [`World`] and relative to a given [`Entity`]. This is generally used
     /// for spawning "related" entities, such as children.
-    fn spawn(self, world: &mut World, entity: Entity);
+    // This function explicitly uses `MovingPtr` to avoid potentially large stack copies of the bundle
+    // when inserting into ECS storage. See https://github.com/bevyengine/bevy/issues/20571 for more
+    // information.
+    fn spawn(this: MovingPtr<'_, Self>, world: &mut World, entity: Entity);
+
     /// Returns a size hint, which is used to reserve space for this list in a [`RelationshipTarget`]. This should be
     /// less than or equal to the actual size of the list. When in doubt, just use 0.
     fn size_hint(&self) -> usize;
 }
 
 impl<R: Relationship, B: Bundle<Effect: NoBundleEffect>> SpawnableList<R> for Vec<B> {
-    fn spawn(self, world: &mut World, entity: Entity) {
-        let mapped_bundles = self.into_iter().map(|b| (R::from(entity), b));
+    fn spawn(ptr: MovingPtr<'_, Self>, world: &mut World, entity: Entity) {
+        let mapped_bundles = ptr.read().into_iter().map(|b| (R::from(entity), b));
         world.spawn_batch(mapped_bundles);
     }
 
@@ -58,8 +68,38 @@ impl<R: Relationship, B: Bundle<Effect: NoBundleEffect>> SpawnableList<R> for Ve
 }
 
 impl<R: Relationship, B: Bundle> SpawnableList<R> for Spawn<B> {
-    fn spawn(self, world: &mut World, entity: Entity) {
-        world.spawn((R::from(entity), self.0));
+    fn spawn(this: MovingPtr<'_, Self>, world: &mut World, entity: Entity) {
+        #[track_caller]
+        fn spawn<B: Bundle, R: Relationship>(
+            this: MovingPtr<'_, Spawn<B>>,
+            world: &mut World,
+            entity: Entity,
+        ) {
+            let caller = MaybeLocation::caller();
+
+            // SAFETY:
+            //  - `Spawn<B>` has one field at index 0.
+            //  - if `this` is aligned, then its inner bundle must be as well.
+            let bundle = unsafe {
+                bevy_ptr::deconstruct_moving_ptr!(this => (
+                    0 => bundle,
+                ));
+                bundle.try_into().debug_checked_unwrap()
+            };
+
+            let r = R::from(entity);
+            move_as_ptr!(r);
+            let mut entity = world.spawn_with_caller(r, caller);
+
+            entity.insert_with_caller(
+                bundle,
+                InsertMode::Replace,
+                caller,
+                RelationshipHookMode::Run,
+            );
+        }
+
+        spawn::<B, R>(this, world, entity);
     }
 
     fn size_hint(&self) -> usize {
@@ -88,8 +128,8 @@ pub struct SpawnIter<I>(pub I);
 impl<R: Relationship, I: Iterator<Item = B> + Send + Sync + 'static, B: Bundle> SpawnableList<R>
     for SpawnIter<I>
 {
-    fn spawn(self, world: &mut World, entity: Entity) {
-        for bundle in self.0 {
+    fn spawn(mut this: MovingPtr<'_, Self>, world: &mut World, entity: Entity) {
+        for bundle in &mut this.0 {
             world.spawn((R::from(entity), bundle));
         }
     }
@@ -124,8 +164,10 @@ pub struct SpawnWith<F>(pub F);
 impl<R: Relationship, F: FnOnce(&mut RelatedSpawner<R>) + Send + Sync + 'static> SpawnableList<R>
     for SpawnWith<F>
 {
-    fn spawn(self, world: &mut World, entity: Entity) {
-        world.entity_mut(entity).with_related_entities(self.0);
+    fn spawn(this: MovingPtr<'_, Self>, world: &mut World, entity: Entity) {
+        world
+            .entity_mut(entity)
+            .with_related_entities(this.read().0);
     }
 
     fn size_hint(&self) -> usize {
@@ -167,10 +209,9 @@ impl<I> WithRelated<I> {
 }
 
 impl<R: Relationship, I: Iterator<Item = Entity>> SpawnableList<R> for WithRelated<I> {
-    fn spawn(self, world: &mut World, entity: Entity) {
-        world
-            .entity_mut(entity)
-            .add_related::<R>(&self.0.collect::<Vec<_>>());
+    fn spawn(mut this: MovingPtr<'_, Self>, world: &mut World, entity: Entity) {
+        let related = (&mut this.0).collect::<Vec<_>>();
+        world.entity_mut(entity).add_related::<R>(&related);
     }
 
     fn size_hint(&self) -> usize {
@@ -205,8 +246,8 @@ impl<R: Relationship, I: Iterator<Item = Entity>> SpawnableList<R> for WithRelat
 pub struct WithOneRelated(pub Entity);
 
 impl<R: Relationship> SpawnableList<R> for WithOneRelated {
-    fn spawn(self, world: &mut World, entity: Entity) {
-        world.entity_mut(entity).add_one_related::<R>(self.0);
+    fn spawn(this: MovingPtr<'_, Self>, world: &mut World, entity: Entity) {
+        world.entity_mut(entity).add_one_related::<R>(this.read().0);
     }
 
     fn size_hint(&self) -> usize {
@@ -215,40 +256,43 @@ impl<R: Relationship> SpawnableList<R> for WithOneRelated {
 }
 
 macro_rules! spawnable_list_impl {
-    ($(#[$meta:meta])* $($list: ident),*) => {
-        #[expect(
-            clippy::allow_attributes,
-            reason = "This is a tuple-related macro; as such, the lints below may not always apply."
-        )]
+    ($(#[$meta:meta])* $(($index:tt, $list: ident, $alias: ident)),*) => {
         $(#[$meta])*
         impl<R: Relationship, $($list: SpawnableList<R>),*> SpawnableList<R> for ($($list,)*) {
-            fn spawn(self, _world: &mut World, _entity: Entity) {
-                #[allow(
-                    non_snake_case,
-                    reason = "The names of these variables are provided by the caller, not by us."
-                )]
-                let ($($list,)*) = self;
-                $($list.spawn(_world, _entity);)*
+            #[expect(
+                clippy::allow_attributes,
+                reason = "This is a tuple-related macro; as such, the lints below may not always apply."
+            )]
+            #[allow(unused_unsafe, reason = "The empty tuple will leave the unsafe blocks unused.")]
+            fn spawn(_this: MovingPtr<'_, Self>, _world: &mut World, _entity: Entity)
+            where
+                Self: Sized,
+            {
+                // SAFETY:
+                //  - The indices uniquely match the type definition and thus must point to the right fields.
+                //  - Rust tuples can never be `repr(packed)` so if `_this` is properly aligned, then all of the individual field
+                //    pointers must also be properly aligned.
+                unsafe {
+                    bevy_ptr::deconstruct_moving_ptr!(_this => ($($index => $alias,)*));
+                    $( SpawnableList::<R>::spawn($alias.try_into().debug_checked_unwrap(), _world, _entity); )*
+                }
             }
 
             fn size_hint(&self) -> usize {
-                #[allow(
-                    non_snake_case,
-                    reason = "The names of these variables are provided by the caller, not by us."
-                )]
-                let ($($list,)*) = self;
-                0 $(+ $list.size_hint())*
+                let ($($alias,)*) = self;
+                0 $(+ $alias.size_hint())*
             }
        }
     }
 }
 
-all_tuples!(
+all_tuples_enumerated!(
     #[doc(fake_variadic)]
     spawnable_list_impl,
     0,
     12,
-    P
+    P,
+    field_
 );
 
 /// A [`Bundle`] that:
@@ -261,15 +305,6 @@ pub struct SpawnRelatedBundle<R: Relationship, L: SpawnableList<R>> {
     marker: PhantomData<R>,
 }
 
-impl<R: Relationship, L: SpawnableList<R>> BundleEffect for SpawnRelatedBundle<R, L> {
-    fn apply(self, entity: &mut EntityWorldMut) {
-        let id = entity.id();
-        entity.world_scope(|world: &mut World| {
-            self.list.spawn(world, id);
-        });
-    }
-}
-
 // SAFETY: This internally relies on the RelationshipTarget's Bundle implementation, which is sound.
 unsafe impl<R: Relationship, L: SpawnableList<R> + Send + Sync + 'static> Bundle
     for SpawnRelatedBundle<R, L>
@@ -292,13 +327,37 @@ unsafe impl<R: Relationship, L: SpawnableList<R> + Send + Sync + 'static> Bundle
 impl<R: Relationship, L: SpawnableList<R>> DynamicBundle for SpawnRelatedBundle<R, L> {
     type Effect = Self;
 
-    fn get_components(
-        self,
+    unsafe fn get_components(
+        ptr: MovingPtr<'_, Self>,
         func: &mut impl FnMut(crate::component::StorageType, bevy_ptr::OwningPtr<'_>),
-    ) -> Self::Effect {
-        <R::RelationshipTarget as RelationshipTarget>::with_capacity(self.list.size_hint())
-            .get_components(func);
-        self
+    ) {
+        let target =
+            <R::RelationshipTarget as RelationshipTarget>::with_capacity(ptr.list.size_hint());
+        move_as_ptr!(target);
+        // SAFETY:
+        // - The caller must ensure that this is called exactly once before `apply_effect`.
+        // - Assuming `DynamicBundle` is implemented correctly for `R::Relationship` target, `func` should be
+        //   called exactly once for each component being fetched with the correct `StorageType`
+        // - `Effect: !NoBundleEffect`, which means the caller is responsible for calling this type's `apply_effect`
+        //   at least once before returning to safe code.
+        <R::RelationshipTarget as DynamicBundle>::get_components(target, func);
+        // Forget the pointer so that the value is available in `apply_effect`.
+        mem::forget(ptr);
+    }
+
+    unsafe fn apply_effect(ptr: MovingPtr<'_, MaybeUninit<Self>>, entity: &mut EntityWorldMut) {
+        // SAFETY: The value was not moved out in `get_components`, only borrowed, and thus should still
+        // be valid and initialized.
+        let effect = unsafe { ptr.assume_init() };
+        let id = entity.id();
+
+        // SAFETY:
+        //  - `ptr` points to an instance of type `Self`
+        //  - The field names and types match with the type definition.
+        entity.world_scope(|world: &mut World| unsafe {
+            bevy_ptr::deconstruct_moving_ptr!(effect => { list, });
+            L::spawn(list.try_into().debug_checked_unwrap(), world, id);
+        });
     }
 }
 
@@ -312,21 +371,32 @@ pub struct SpawnOneRelated<R: Relationship, B: Bundle> {
     marker: PhantomData<R>,
 }
 
-impl<R: Relationship, B: Bundle> BundleEffect for SpawnOneRelated<R, B> {
-    fn apply(self, entity: &mut EntityWorldMut) {
-        entity.with_related::<R>(self.bundle);
-    }
-}
-
 impl<R: Relationship, B: Bundle> DynamicBundle for SpawnOneRelated<R, B> {
     type Effect = Self;
 
-    fn get_components(
-        self,
+    unsafe fn get_components(
+        ptr: MovingPtr<'_, Self>,
         func: &mut impl FnMut(crate::component::StorageType, bevy_ptr::OwningPtr<'_>),
-    ) -> Self::Effect {
-        <R::RelationshipTarget as RelationshipTarget>::with_capacity(1).get_components(func);
-        self
+    ) {
+        let target = <R::RelationshipTarget as RelationshipTarget>::with_capacity(1);
+        move_as_ptr!(target);
+        // SAFETY:
+        // - The caller must ensure that this is called exactly once before `apply_effect`.
+        // - Assuming `DynamicBundle` is implemented correctly for `R::Relationship` target, `func` should be
+        //   called exactly once for each component being fetched with the correct `StorageType`
+        // - `Effect: !NoBundleEffect`, which means the caller is responsible for calling this type's `apply_effect`
+        //   at least once before returning to safe code.
+        <R::RelationshipTarget as DynamicBundle>::get_components(target, func);
+        // Forget the pointer so that the value is available in `apply_effect`.
+        mem::forget(ptr);
+    }
+
+    unsafe fn apply_effect(ptr: MovingPtr<'_, MaybeUninit<Self>>, entity: &mut EntityWorldMut) {
+        // SAFETY: The value was not moved out in `get_components`, only borrowed, and thus should still
+        // be valid and initialized.
+        let effect = unsafe { ptr.assume_init() };
+        let effect = effect.read();
+        entity.with_related::<R>(effect.bundle);
     }
 }
 
diff --git a/crates/bevy_ecs/src/system/commands/entity_command.rs b/crates/bevy_ecs/src/system/commands/entity_command.rs
index 6510c54960dd1..4d79d789806a0 100644
--- a/crates/bevy_ecs/src/system/commands/entity_command.rs
+++ b/crates/bevy_ecs/src/system/commands/entity_command.rs
@@ -17,7 +17,7 @@ use crate::{
     system::IntoObserverSystem,
     world::{error::EntityMutableFetchError, EntityWorldMut, FromWorld},
 };
-use bevy_ptr::OwningPtr;
+use bevy_ptr::{move_as_ptr, OwningPtr};
 
 /// A command which gets executed for a given [`Entity`].
 ///
@@ -108,6 +108,7 @@ where
 pub fn insert(bundle: impl Bundle, mode: InsertMode) -> impl EntityCommand {
     let caller = MaybeLocation::caller();
     move |mut entity: EntityWorldMut| {
+        move_as_ptr!(bundle);
         entity.insert_with_caller(bundle, mode, caller, RelationshipHookMode::Run);
     }
 }
@@ -153,6 +154,7 @@ pub fn insert_from_world<T: Component + FromWorld>(mode: InsertMode) -> impl Ent
     move |mut entity: EntityWorldMut| {
         if !(mode == InsertMode::Keep && entity.contains::<T>()) {
             let value = entity.world_scope(|world| T::from_world(world));
+            move_as_ptr!(value);
             entity.insert_with_caller(value, mode, caller, RelationshipHookMode::Run);
         }
     }
@@ -172,8 +174,9 @@ where
     let caller = MaybeLocation::caller();
     move |mut entity: EntityWorldMut| {
         if !(mode == InsertMode::Keep && entity.contains::<T>()) {
-            let value = component_fn();
-            entity.insert_with_caller(value, mode, caller, RelationshipHookMode::Run);
+            let bundle = component_fn();
+            move_as_ptr!(bundle);
+            entity.insert_with_caller(bundle, mode, caller, RelationshipHookMode::Run);
         }
     }
 }
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index 634e3caee8934..e723f21605a1a 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -4,6 +4,7 @@ pub mod entity_command;
 #[cfg(feature = "std")]
 mod parallel_scope;
 
+use bevy_ptr::move_as_ptr;
 pub use command::Command;
 pub use entity_command::EntityCommand;
 
@@ -396,6 +397,7 @@ impl<'w, 's> Commands<'w, 's> {
                 }
             });
 
+            move_as_ptr!(bundle);
             entity.insert_with_caller(
                 bundle,
                 InsertMode::Replace,
diff --git a/crates/bevy_ecs/src/world/entity_ref.rs b/crates/bevy_ecs/src/world/entity_ref.rs
index b4dd981f07f61..8e7b33448938e 100644
--- a/crates/bevy_ecs/src/world/entity_ref.rs
+++ b/crates/bevy_ecs/src/world/entity_ref.rs
@@ -1,8 +1,7 @@
 use crate::{
     archetype::Archetype,
     bundle::{
-        Bundle, BundleEffect, BundleFromComponents, BundleInserter, BundleRemover, DynamicBundle,
-        InsertMode,
+        Bundle, BundleFromComponents, BundleInserter, BundleRemover, DynamicBundle, InsertMode,
     },
     change_detection::{MaybeLocation, MutUntyped},
     component::{Component, ComponentId, ComponentTicks, Components, Mutable, StorageType, Tick},
@@ -22,7 +21,7 @@ use crate::{
 };
 use alloc::vec::Vec;
 use bevy_platform::collections::{HashMap, HashSet};
-use bevy_ptr::{OwningPtr, Ptr};
+use bevy_ptr::{move_as_ptr, MovingPtr, OwningPtr, Ptr};
 use core::{
     any::TypeId,
     cmp::Ordering,
@@ -1968,6 +1967,7 @@ impl<'w> EntityWorldMut<'w> {
     /// If the entity has been despawned while this `EntityWorldMut` is still alive.
     #[track_caller]
     pub fn insert<T: Bundle>(&mut self, bundle: T) -> &mut Self {
+        move_as_ptr!(bundle);
         self.insert_with_caller(
             bundle,
             InsertMode::Replace,
@@ -1996,6 +1996,7 @@ impl<'w> EntityWorldMut<'w> {
         bundle: T,
         relationship_hook_mode: RelationshipHookMode,
     ) -> &mut Self {
+        move_as_ptr!(bundle);
         self.insert_with_caller(
             bundle,
             InsertMode::Replace,
@@ -2014,6 +2015,7 @@ impl<'w> EntityWorldMut<'w> {
     /// If the entity has been despawned while this `EntityWorldMut` is still alive.
     #[track_caller]
     pub fn insert_if_new<T: Bundle>(&mut self, bundle: T) -> &mut Self {
+        move_as_ptr!(bundle);
         self.insert_with_caller(
             bundle,
             InsertMode::Keep,
@@ -2022,12 +2024,11 @@ impl<'w> EntityWorldMut<'w> {
         )
     }
 
-    /// Split into a new function so we can pass the calling location into the function when using
-    /// as a command.
+    /// Adds a [`Bundle`] of components to the entity.
     #[inline]
     pub(crate) fn insert_with_caller<T: Bundle>(
         &mut self,
-        bundle: T,
+        bundle: MovingPtr<'_, T>,
         mode: InsertMode,
         caller: MaybeLocation,
         relationship_hook_mode: RelationshipHookMode,
@@ -2036,8 +2037,15 @@ impl<'w> EntityWorldMut<'w> {
         let change_tick = self.world.change_tick();
         let mut bundle_inserter =
             BundleInserter::new::<T>(self.world, location.archetype_id, change_tick);
-        // SAFETY: location matches current entity. `T` matches `bundle_info`
-        let (location, after_effect) = unsafe {
+        // SAFETY:
+        // - `location` matches current entity and thus must currently exist in the source
+        //   archetype for this inserter and its location within the archetype.
+        // - `T` matches the type used to create the `BundleInserter`.
+        // - `apply_effect` is called exactly once after this function.
+        // - The value pointed at by `bundle` is not accessed for anything other than `apply_effect`
+        //   and the caller ensures that the value is not accessed or dropped after this function
+        //   returns.
+        let (bundle, location) = bundle.partial_move(|bundle| unsafe {
             bundle_inserter.insert(
                 self.entity,
                 location,
@@ -2046,11 +2054,14 @@ impl<'w> EntityWorldMut<'w> {
                 caller,
                 relationship_hook_mode,
             )
-        };
+        });
         self.location = Some(location);
         self.world.flush();
         self.update_location();
-        after_effect.apply(self);
+        // SAFETY:
+        // - This is called exactly once after the `BundleInsert::insert` call before returning to safe code.
+        // - `bundle` points to the same `B` that `BundleInsert::insert` was called on.
+        unsafe { T::apply_effect(bundle, self) };
         self
     }
 
@@ -2852,8 +2863,9 @@ impl<'w> EntityWorldMut<'w> {
         caller: MaybeLocation,
     ) -> &mut Self {
         self.assert_not_despawned();
-        self.world
-            .spawn_with_caller(Observer::new(observer).with_entity(self.entity), caller);
+        let bundle = Observer::new(observer).with_entity(self.entity);
+        move_as_ptr!(bundle);
+        self.world.spawn_with_caller(bundle, caller);
         self.world.flush();
         self.update_location();
         self
@@ -4624,8 +4636,17 @@ unsafe fn insert_dynamic_bundle<
         for DynamicInsertBundle<'a, I>
     {
         type Effect = ();
-        fn get_components(self, func: &mut impl FnMut(StorageType, OwningPtr<'_>)) {
-            self.components.for_each(|(t, ptr)| func(t, ptr));
+        unsafe fn get_components(
+            mut ptr: MovingPtr<'_, Self>,
+            func: &mut impl FnMut(StorageType, OwningPtr<'_>),
+        ) {
+            (&mut ptr.components).for_each(|(t, ptr)| func(t, ptr));
+        }
+
+        unsafe fn apply_effect(
+            _ptr: MovingPtr<'_, MaybeUninit<Self>>,
+            _entity: &mut EntityWorldMut,
+        ) {
         }
     }
 
@@ -4633,18 +4654,23 @@ unsafe fn insert_dynamic_bundle<
         components: storage_types.zip(components),
     };
 
-    // SAFETY: location matches current entity.
+    move_as_ptr!(bundle);
+
+    // SAFETY:
+    // - `location` matches `entity`.  and thus must currently exist in the source
+    //   archetype for this inserter and its location within the archetype.
+    // - The caller must ensure that the iterators and storage types match up with the `BundleInserter`
+    // - `apply_effect` is never called on this bundle.
+    // - `bundle` is not used or dropped after this point.
     unsafe {
-        bundle_inserter
-            .insert(
-                entity,
-                location,
-                bundle,
-                mode,
-                caller,
-                relationship_hook_insert_mode,
-            )
-            .0
+        bundle_inserter.insert(
+            entity,
+            location,
+            bundle,
+            mode,
+            caller,
+            relationship_hook_insert_mode,
+        )
     }
 }
 
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index d7841481a1ce0..c6cde38e9d75b 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -32,8 +32,8 @@ pub use spawn_batch::*;
 use crate::{
     archetype::{ArchetypeId, Archetypes},
     bundle::{
-        Bundle, BundleEffect, BundleId, BundleInfo, BundleInserter, BundleSpawner, Bundles,
-        InsertMode, NoBundleEffect,
+        Bundle, BundleId, BundleInfo, BundleInserter, BundleSpawner, Bundles, InsertMode,
+        NoBundleEffect,
     },
     change_detection::{MaybeLocation, MutUntyped, TicksMut},
     component::{
@@ -63,7 +63,7 @@ use crate::{
 };
 use alloc::{boxed::Box, vec::Vec};
 use bevy_platform::sync::atomic::{AtomicU32, Ordering};
-use bevy_ptr::{OwningPtr, Ptr, UnsafeCellDeref};
+use bevy_ptr::{move_as_ptr, MovingPtr, OwningPtr, Ptr, UnsafeCellDeref};
 use bevy_utils::prelude::DebugName;
 use core::{any::TypeId, fmt};
 use log::warn;
@@ -1152,21 +1152,29 @@ impl World {
     /// ```
     #[track_caller]
     pub fn spawn<B: Bundle>(&mut self, bundle: B) -> EntityWorldMut<'_> {
+        move_as_ptr!(bundle);
         self.spawn_with_caller(bundle, MaybeLocation::caller())
     }
 
     pub(crate) fn spawn_with_caller<B: Bundle>(
         &mut self,
-        bundle: B,
+        bundle: MovingPtr<'_, B>,
         caller: MaybeLocation,
     ) -> EntityWorldMut<'_> {
         self.flush();
         let change_tick = self.change_tick();
         let entity = self.entities.alloc();
         let mut bundle_spawner = BundleSpawner::new::<B>(self, change_tick);
-        // SAFETY: bundle's type matches `bundle_info`, entity is allocated but non-existent
-        let (entity_location, after_effect) =
-            unsafe { bundle_spawner.spawn_non_existent(entity, bundle, caller) };
+        let (bundle, entity_location) = bundle.partial_move(|bundle| {
+            // SAFETY:
+            // - `B` matches `bundle_spawner`'s type
+            // -  `entity` is allocated but non-existent
+            // - `B::Effect` is unconstrained, and `B::apply_effect` is called exactly once on the bundle after this call.
+            // - This function ensures that the value pointed to by `bundle` must not be accessed for anything afterwards by consuming
+            //   the `MovingPtr`. The value is otherwise only used to call `apply_effect` within this function, and the safety invariants
+            //   of `DynamicBundle` ensure that only the elements that have not been moved out of by this call are accessed.
+            unsafe { bundle_spawner.spawn_non_existent::<B>(entity, bundle, caller) }
+        });
 
         let mut entity_location = Some(entity_location);
 
@@ -1178,7 +1186,10 @@ impl World {
 
         // SAFETY: entity and location are valid, as they were just created above
         let mut entity = unsafe { EntityWorldMut::new(self, entity, entity_location) };
-        after_effect.apply(&mut entity);
+        // SAFETY:
+        // - This is called exactly once after `get_components` has been called in `spawn_non_existent`.
+        // - `bundle` had it's `get_components` function called exactly once inside `spawn_non_existent`.
+        unsafe { B::apply_effect(bundle, &mut entity) };
         entity
     }
 
@@ -2316,7 +2327,12 @@ impl World {
                     },
                     archetype_id: first_location.archetype_id,
                 };
-                // SAFETY: `entity` is valid, `location` matches entity, bundle matches inserter
+
+                move_as_ptr!(first_bundle);
+                // SAFETY:
+                // - `entity` is valid, `location` matches entity, bundle matches inserter
+                // - `apply_effect` is never called on this bundle.
+                // - `first_bundle` is not be accessed or dropped after this.
                 unsafe {
                     cache.inserter.insert(
                         first_entity,
@@ -2344,7 +2360,12 @@ impl World {
                                 archetype_id: location.archetype_id,
                             }
                         }
-                        // SAFETY: `entity` is valid, `location` matches entity, bundle matches inserter
+
+                        move_as_ptr!(bundle);
+                        // SAFETY:
+                        // - `entity` is valid, `location` matches entity, bundle matches inserter
+                        // - `apply_effect` is never called on this bundle.
+                        // - `bundle` is not be accessed or dropped after this.
                         unsafe {
                             cache.inserter.insert(
                                 entity,
@@ -2461,7 +2482,12 @@ impl World {
                         },
                         archetype_id: first_location.archetype_id,
                     };
-                    // SAFETY: `entity` is valid, `location` matches entity, bundle matches inserter
+
+                    move_as_ptr!(first_bundle);
+                    // SAFETY:
+                    // - `entity` is valid, `location` matches entity, bundle matches inserter
+                    // - `apply_effect` is never called on this bundle.
+                    // - `first_bundle` is not be accessed or dropped after this.
                     unsafe {
                         cache.inserter.insert(
                             first_entity,
@@ -2498,7 +2524,12 @@ impl World {
                             archetype_id: location.archetype_id,
                         }
                     }
-                    // SAFETY: `entity` is valid, `location` matches entity, bundle matches inserter
+
+                    move_as_ptr!(bundle);
+                    // SAFETY:
+                    // - `entity` is valid, `location` matches entity, bundle matches inserter
+                    // - `apply_effect` is never called on this bundle.
+                    // - `bundle` is not be accessed or dropped after this.
                     unsafe {
                         cache.inserter.insert(
                             entity,
diff --git a/crates/bevy_ecs/src/world/spawn_batch.rs b/crates/bevy_ecs/src/world/spawn_batch.rs
index 16bd9bb8059b4..9f9c87ee572b9 100644
--- a/crates/bevy_ecs/src/world/spawn_batch.rs
+++ b/crates/bevy_ecs/src/world/spawn_batch.rs
@@ -1,3 +1,5 @@
+use bevy_ptr::move_as_ptr;
+
 use crate::{
     bundle::{Bundle, BundleSpawner, NoBundleEffect},
     change_detection::MaybeLocation,
@@ -13,7 +15,7 @@ use core::iter::FusedIterator;
 pub struct SpawnBatchIter<'w, I>
 where
     I: Iterator,
-    I::Item: Bundle,
+    I::Item: Bundle<Effect: NoBundleEffect>,
 {
     inner: I,
     spawner: BundleSpawner<'w>,
@@ -52,7 +54,7 @@ where
 impl<I> Drop for SpawnBatchIter<'_, I>
 where
     I: Iterator,
-    I::Item: Bundle,
+    I::Item: Bundle<Effect: NoBundleEffect>,
 {
     fn drop(&mut self) {
         // Iterate through self in order to spawn remaining bundles.
@@ -66,14 +68,18 @@ where
 impl<I> Iterator for SpawnBatchIter<'_, I>
 where
     I: Iterator,
-    I::Item: Bundle,
+    I::Item: Bundle<Effect: NoBundleEffect>,
 {
     type Item = Entity;
 
     fn next(&mut self) -> Option<Entity> {
         let bundle = self.inner.next()?;
-        // SAFETY: bundle matches spawner type
-        unsafe { Some(self.spawner.spawn(bundle, self.caller).0) }
+        move_as_ptr!(bundle);
+        // SAFETY:
+        // - The spawner matches `I::Item`'s type.
+        // - `I::Item::Effect: NoBundleEffect`, thus [`apply_effect`] does not need to be called.
+        // - `bundle` is not accessed or dropped after this function call.
+        unsafe { Some(self.spawner.spawn::<I::Item>(bundle, self.caller)) }
     }
 
     fn size_hint(&self) -> (usize, Option<usize>) {
@@ -84,7 +90,7 @@ where
 impl<I, T> ExactSizeIterator for SpawnBatchIter<'_, I>
 where
     I: ExactSizeIterator<Item = T>,
-    T: Bundle,
+    T: Bundle<Effect: NoBundleEffect>,
 {
     fn len(&self) -> usize {
         self.inner.len()
@@ -94,7 +100,7 @@ where
 impl<I, T> FusedIterator for SpawnBatchIter<'_, I>
 where
     I: FusedIterator<Item = T>,
-    T: Bundle,
+    T: Bundle<Effect: NoBundleEffect>,
 {
 }
 
@@ -102,6 +108,6 @@ where
 unsafe impl<I: Iterator, T> EntitySetIterator for SpawnBatchIter<'_, I>
 where
     I: FusedIterator<Item = T>,
-    T: Bundle,
+    T: Bundle<Effect: NoBundleEffect>,
 {
 }
diff --git a/crates/bevy_ptr/src/lib.rs b/crates/bevy_ptr/src/lib.rs
index ea5f741e4391f..1d6e43fcf1f9b 100644
--- a/crates/bevy_ptr/src/lib.rs
+++ b/crates/bevy_ptr/src/lib.rs
@@ -13,6 +13,7 @@ use core::{
     marker::PhantomData,
     mem::{self, ManuallyDrop, MaybeUninit},
     num::NonZeroUsize,
+    ops::{Deref, DerefMut},
     ptr::{self, NonNull},
 };
 
@@ -444,16 +445,10 @@ impl<'a, T> MovingPtr<'a, T, Aligned> {
         value
     }
 
-    /// Consumes a value and creates an [`MovingPtr`] to it while ensuring a double drop does not happen.
-    #[inline]
-    pub fn make<F: FnOnce(MovingPtr<'_, T>) -> R, R>(val: T, f: F) -> R {
-        let mut val = MaybeUninit::new(val);
-        // SAFETY: The value behind the pointer will not get dropped or observed later.
-        f(unsafe { MovingPtr::from_value(&mut val) })
-    }
-
     /// Creates a [`MovingPtr`] from a provided value of type `T`.
     ///
+    /// For a safer alternative, it is strongly advised to use [`move_as_ptr`] where possible.
+    ///
     /// # Safety
     /// - `value` must store a properly initialized value of type `T`.
     /// - Once the returned [`MovingPtr`] has been used, `value` must be treated as
@@ -467,9 +462,11 @@ impl<'a, T> MovingPtr<'a, T, Aligned> {
     }
 }
 
-impl<'a, T, A: IsAligned> MovingPtr<'_, T, A> {
+impl<'a, T, A: IsAligned> MovingPtr<'a, T, A> {
     /// Creates a new instance from a raw pointer.
     ///
+    /// For a safer alternative, it is strongly advised to use [`move_as_ptr`] where possible.
+    ///
     /// # Safety
     /// - `inner` must point to valid value of `T`.
     /// - If the `A` type parameter is [`Aligned`] then `inner` must be be [properly aligned] for `T`.
@@ -485,20 +482,16 @@ impl<'a, T, A: IsAligned> MovingPtr<'_, T, A> {
 
     /// Partially moves out some fields inside of `self`.
     ///
-    /// The partially returned value is returned back pointing to `MaybeUninit<T>`.
+    /// The partially returned value is returned back pointing to [`MaybeUninit<T>`].
     ///
-    /// # Safety
-    ///  - The call into `f` must not complete having dropped the provided pointer.
-    ///  - The fields moved out of in `f` must not be accessed or dropped after this function returns.
-    ///
-    /// As a result, it is strongly recommended to call [`forget`] on the provided pointer once the
-    /// partial deconstruction has completed.
+    /// While calling this function is safe, care must be taken with the returned `MovingPtr` as it
+    /// points to a value that may no longer be completely valid.
     ///
     /// # Example
     ///
     /// ```
     /// use core::mem::{offset_of, MaybeUninit};
-    /// use bevy_ptr::MovingPtr;
+    /// use bevy_ptr::{MovingPtr, move_as_ptr};
     /// # use bevy_ptr::Unaligned;
     /// # struct FieldAType(usize);
     /// # struct FieldBType(usize);
@@ -517,33 +510,46 @@ impl<'a, T, A: IsAligned> MovingPtr<'_, T, A> {
     /// #   field_c: FieldCType(0),
     /// # };
     ///
-    /// MovingPtr::make(parent, |parent_ptr| unsafe {
-    ///    // SAFETY:
-    ///    // - It is impossible for the provided closure to drop the provided pointer as `move_field` cannot panic.
-    ///    // - `field_a` and `field_b` are moved out of but never accessed after this.
-    ///    let partial_parent = MovingPtr::partial_move(parent_ptr, |parent_ptr| {
-    ///       bevy_ptr::deconstruct_moving_ptr!(parent_ptr, Parent {
-    ///         field_a: FieldAType => { insert(field_a) },
-    ///         field_b: FieldBType => { insert(field_b) },
-    ///       });
-    ///    });
+    /// // Converts `parent` into a `MovingPtr`
+    /// move_as_ptr!(parent);
+    ///
+    /// // SAFETY:
+    /// // - `field_a` and `field_b` are both unique.
+    /// let (partial_parent, ()) = MovingPtr::partial_move(parent, |parent_ptr| unsafe {
+    ///   bevy_ptr::deconstruct_moving_ptr!(parent_ptr => {
+    ///     field_a,
+    ///     field_b,
+    ///   });
+    ///   
+    ///   insert(field_a);
+    ///   insert(field_b);
+    /// });
     ///
-    ///    // Move the rest of fields out of the parent.
-    ///    bevy_ptr::deconstruct_moving_ptr!(partial_parent, Parent {
-    ///       field_c: FieldBType => { insert(field_c) },
+    /// // Move the rest of fields out of the parent.
+    /// // SAFETY:
+    /// // - `field_c` is by itself unique and does not conflict with the previous accesses
+    /// //   inside `partial_move`.
+    /// unsafe {
+    ///    bevy_ptr::deconstruct_moving_ptr!(partial_parent: MaybeUninit => {
+    ///       field_c,
     ///    });
-    /// });
+    ///
+    ///    insert(field_c);
+    /// }
     /// ```
     ///
     /// [`forget`]: core::mem::forget
     #[inline]
-    pub unsafe fn partial_move(
-        ptr: MovingPtr<'a, T, A>,
-        f: impl FnOnce(MovingPtr<'a, T, A>),
-    ) -> MovingPtr<'a, MaybeUninit<T>, A> {
-        let partial_ptr = ptr.0;
-        f(ptr);
-        MovingPtr(partial_ptr.cast::<MaybeUninit<T>>(), PhantomData)
+    pub fn partial_move<R>(
+        self,
+        f: impl FnOnce(MovingPtr<'_, T, A>) -> R,
+    ) -> (MovingPtr<'a, MaybeUninit<T>, A>, R) {
+        let partial_ptr = self.0;
+        let ret = f(self);
+        (
+            MovingPtr(partial_ptr.cast::<MaybeUninit<T>>(), PhantomData),
+            ret,
+        )
     }
 
     /// Reads the value pointed to by this pointer.
@@ -600,8 +606,7 @@ impl<'a, T, A: IsAligned> MovingPtr<'_, T, A> {
         }
     }
 
-    /// Creates a [`MovingPtr`] for a specific field within `self`. This is a building block for
-    /// [`deconstruct_moving_ptr`] and should generally not be accessed directly.
+    /// Creates a [`MovingPtr`] for a specific field within `self`.
     ///
     /// This function is explicitly made for deconstructive moves.
     ///
@@ -611,8 +616,8 @@ impl<'a, T, A: IsAligned> MovingPtr<'_, T, A> {
     /// unaligned fields. The pointer is convertible back into an aligned one using the [`TryFrom`] impl.
     ///
     /// # Safety
-    ///  - `U` must be the correct type for the field at `byte_offset` within `self`.
-    ///  - `self` should not be accessed or dropped as if it were a complete value.
+    ///  - `f` must return a non-null pointer to a valid field inside `T`
+    ///  - `self` should not be accessed or dropped as if it were a complete value after this function returns.
     ///    Other fields that have not been moved out of may still be accessed or dropped separately.
     ///  - This function cannot alias the field with any other access, including other calls to [`move_field`]
     ///    for the same field, without first calling [`forget`] on it first.
@@ -625,7 +630,7 @@ impl<'a, T, A: IsAligned> MovingPtr<'_, T, A> {
     ///
     /// ```
     /// use core::mem::offset_of;
-    /// use bevy_ptr::MovingPtr;
+    /// use bevy_ptr::{MovingPtr, move_as_ptr};
     /// # use bevy_ptr::Unaligned;
     /// # struct FieldAType(usize);
     /// # struct FieldBType(usize);
@@ -638,38 +643,70 @@ impl<'a, T, A: IsAligned> MovingPtr<'_, T, A> {
     ///   field_c: FieldCType,
     /// }
     ///
-    /// # let parent = Parent {
-    /// #   field_a: FieldAType(0),
-    /// #   field_b: FieldBType(0),
-    /// #   field_c: FieldCType(0),
-    /// # };
+    /// let parent = Parent {
+    ///    field_a: FieldAType(0),
+    ///    field_b: FieldBType(0),
+    ///    field_c: FieldCType(0),
+    /// };
+    ///
+    /// // Converts `parent` into a `MovingPtr`.
+    /// move_as_ptr!(parent);
     ///
-    /// MovingPtr::make(parent, |parent_ptr| unsafe {
-    ///    let field_a = parent_ptr.move_field::<FieldAType>(offset_of!(Parent, field_a));
-    ///    let field_b = parent_ptr.move_field::<FieldBType>(offset_of!(Parent, field_b));
-    ///    let field_c = parent_ptr.move_field::<FieldCType>(offset_of!(Parent, field_c));
+    /// unsafe {
+    ///    let field_a = parent.move_field(|ptr| &raw mut (*ptr).field_a);
+    ///    let field_b = parent.move_field(|ptr| &raw mut (*ptr).field_b);
+    ///    let field_c = parent.move_field(|ptr| &raw mut (*ptr).field_c);
     ///    // Each call to insert may panic! Ensure that `parent_ptr` cannot be dropped before
     ///    // calling them!
-    ///    core::mem::forget(parent_ptr);
+    ///    core::mem::forget(parent);
     ///    insert(field_a);
     ///    insert(field_b);
     ///    insert(field_c);
-    /// });
+    /// }
     /// ```
     ///
     /// [`forget`]: core::mem::forget
     /// [`move_field`]: Self::move_field
-    #[inline]
-    #[doc(hidden)]
-    pub unsafe fn move_field<U>(&self, byte_offset: usize) -> MovingPtr<'a, U, Unaligned> {
+    #[inline(always)]
+    pub unsafe fn move_field<U>(
+        &self,
+        f: impl Fn(*mut T) -> *mut U,
+    ) -> MovingPtr<'a, U, Unaligned> {
         MovingPtr(
             // SAFETY: The caller must ensure that `U` is the correct type for the field at `byte_offset`.
-            unsafe { self.0.byte_add(byte_offset) }.cast::<U>(),
+            unsafe { NonNull::new_unchecked(f(self.0.as_ptr())) },
             PhantomData,
         )
     }
 }
 
+impl<'a, T, A: IsAligned> MovingPtr<'a, MaybeUninit<T>, A> {
+    /// Creates a [`MovingPtr`] for a specific field within `self`.
+    ///
+    /// This function is explicitly made for deconstructive moves.
+    ///
+    /// The correct `byte_offset` for a field can be obtained via [`core::mem::offset_of`].
+    ///
+    /// The returned value will always be considered unaligned as `repr(packed)` types may result in
+    /// unaligned fields. The pointer is convertible back into an aligned one using the [`TryFrom`] impl.
+    ///
+    /// # Safety
+    ///  - `f` must return a non-null pointer to a valid field inside `T`
+    #[inline(always)]
+    pub unsafe fn move_maybe_uninit_field<U>(
+        &self,
+        f: impl Fn(*mut T) -> *mut U,
+    ) -> MovingPtr<'a, MaybeUninit<U>, Unaligned> {
+        let self_ptr = self.0.as_ptr().cast::<T>();
+        // SAFETY:
+        // - The caller must ensure that `U` is the correct type for the field at `byte_offset` and thus
+        //   cannot be null.
+        // - `MaybeUninit<T>` is `repr(transparent)` and thus must have the same memory layout as `T``
+        let field_ptr = unsafe { NonNull::new_unchecked(f(self_ptr)) };
+        MovingPtr(field_ptr.cast::<MaybeUninit<U>>(), PhantomData)
+    }
+}
+
 impl<'a, T, A: IsAligned> MovingPtr<'a, MaybeUninit<T>, A> {
     /// Creates a [`MovingPtr`] pointing to a valid instance of `T`.
     ///
@@ -729,6 +766,7 @@ impl<'a, T> TryFrom<MovingPtr<'a, T, Unaligned>> for MovingPtr<'a, T, Aligned> {
     fn try_from(value: MovingPtr<'a, T, Unaligned>) -> Result<Self, Self::Error> {
         let ptr = value.0;
         if ptr.as_ptr().is_aligned() {
+            mem::forget(value);
             Ok(MovingPtr(ptr, PhantomData))
         } else {
             Err(value)
@@ -736,6 +774,25 @@ impl<'a, T> TryFrom<MovingPtr<'a, T, Unaligned>> for MovingPtr<'a, T, Aligned> {
     }
 }
 
+impl<T> Deref for MovingPtr<'_, T, Aligned> {
+    type Target = T;
+    #[inline]
+    fn deref(&self) -> &Self::Target {
+        let ptr = self.0.as_ptr().debug_ensure_aligned();
+        // SAFETY: This type owns the value it points to and the generic type parameter is `A` so this pointer must be aligned.
+        unsafe { &*ptr }
+    }
+}
+
+impl<T> DerefMut for MovingPtr<'_, T, Aligned> {
+    #[inline]
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        let ptr = self.0.as_ptr().debug_ensure_aligned();
+        // SAFETY: This type owns the value it points to and the generic type parameter is `A` so this pointer must be aligned.
+        unsafe { &mut *ptr }
+    }
+}
+
 impl<T, A: IsAligned> Drop for MovingPtr<'_, T, A> {
     fn drop(&mut self) {
         // SAFETY:
@@ -1139,6 +1196,22 @@ impl<T: Sized> DebugEnsureAligned for *mut T {
     }
 }
 
+/// Safely converts a owned value into a [`MovingPtr`] while minimizing the number of stack copies.
+///
+/// This cannot be used as expression and must be used as a statement. Internally this macro works via variable shadowing.
+#[macro_export]
+macro_rules! move_as_ptr {
+    ($value: ident) => {
+        let mut $value = core::mem::MaybeUninit::new($value);
+        // SAFETY:
+        // - This macro shadows a MaybeUninit value that took ownership of the original value.
+        //   it is impossible to refer to the original value, preventing further access after
+        //   the `MovingPtr` has been used. `MaybeUninit` also prevents the compiler from
+        //   dropping the original value.
+        let $value = unsafe { bevy_ptr::MovingPtr::from_value(&mut $value) };
+    };
+}
+
 /// Deconstructs a [`MovingPtr`] into its individual fields.
 ///
 /// This consumes the [`MovingPtr`] and hands out [`MovingPtr`] wrappers around
@@ -1150,25 +1223,25 @@ impl<T: Sized> DebugEnsureAligned for *mut T {
 ///
 /// # Safety
 /// This macro generates unsafe code and must be set up correctly to avoid undefined behavior.
-///  - The provided type must match the type of the value pointed to by the [`MovingPtr`].
-///  - The type and name of the fields must match the type's definition. For tuples and tuple structs,
-///    this would be the tuple indices.
+///  - Each field accessed must be unique, multiple of the same field cannot be listed.
+///
+/// # Examples
 ///
-/// # Example
+/// ## Structs
 ///
 /// ```
 /// use core::mem::{offset_of, MaybeUninit};
-/// use bevy_ptr::MovingPtr;
+/// use bevy_ptr::{MovingPtr, move_as_ptr};
 /// # use bevy_ptr::Unaligned;
 /// # struct FieldAType(usize);
 /// # struct FieldBType(usize);
 /// # struct FieldCType(usize);
 ///
-/// pub struct Parent {
-///   pub field_a: FieldAType,
-///   pub field_b: FieldBType,
-///   pub field_c: FieldCType,
-/// }
+/// # pub struct Parent {
+/// #  pub field_a: FieldAType,
+/// #  pub field_b: FieldBType,
+/// #  pub field_c: FieldCType,
+/// # }
 ///
 /// let parent = Parent {
 ///   field_a: FieldAType(11),
@@ -1180,15 +1253,70 @@ impl<T: Sized> DebugEnsureAligned for *mut T {
 /// let mut target_b = FieldBType(102);
 /// let mut target_c = FieldCType(103);
 ///
-/// MovingPtr::make(parent, |parent_ptr| unsafe {
-///   bevy_ptr::deconstruct_moving_ptr!(parent_ptr, Parent {
-///      // The field name and type must match the name used in the type definition.
-///      // Each one will be a `MovingPtr` of the supplied type
-///      field_a: FieldAType => { field_a.assign_to(&mut target_a) },
-///      field_b: FieldBType => { field_b.assign_to(&mut target_b) },
-///      field_c: FieldCType => { field_c.assign_to(&mut target_c) },
+/// // Converts `parent` into a `MovingPtr`
+/// move_as_ptr!(parent);
+///
+/// // The field names must match the name used in the type definition.
+/// // Each one will be a `MovingPtr` of the field's type.
+/// unsafe {
+///   bevy_ptr::deconstruct_moving_ptr!(parent => {
+///      field_a,
+///      field_b,
+///      field_c,
 ///   });
-/// });
+///
+///   field_a.assign_to(&mut target_a);
+///   field_b.assign_to(&mut target_b);
+///   field_c.assign_to(&mut target_c);
+/// }
+///
+/// assert_eq!(target_a.0, 11);
+/// assert_eq!(target_b.0, 22);
+/// assert_eq!(target_c.0, 33);
+/// ```
+///
+/// ## Tuples
+///
+/// ```
+/// use core::mem::{offset_of, MaybeUninit};
+/// use bevy_ptr::{MovingPtr, move_as_ptr};
+/// # use bevy_ptr::Unaligned;
+/// # struct FieldAType(usize);
+/// # struct FieldBType(usize);
+/// # struct FieldCType(usize);
+///
+/// # pub struct Parent {
+/// #   pub field_a: FieldAType,
+/// #  pub field_b: FieldBType,
+/// #  pub field_c: FieldCType,
+/// # }
+///
+/// let parent = (
+///   FieldAType(11),
+///   FieldBType(22),
+///   FieldCType(33),
+/// );
+///
+/// let mut target_a = FieldAType(101);
+/// let mut target_b = FieldBType(102);
+/// let mut target_c = FieldCType(103);
+///
+/// // Converts `parent` into a `MovingPtr`
+/// move_as_ptr!(parent);
+///
+/// // The field names must match the name used in the type definition.
+/// // Each one will be a `MovingPtr` of the field's type.
+/// unsafe {
+///   bevy_ptr::deconstruct_moving_ptr!(parent => (
+///      0 => field_a,
+///      1 => field_b,
+///      2 => field_c,
+///   ));
+///
+///   field_a.assign_to(&mut target_a);
+///   field_b.assign_to(&mut target_b);
+///   field_c.assign_to(&mut target_c);
+/// }
 ///
 /// assert_eq!(target_a.0, 11);
 /// assert_eq!(target_b.0, 22);
@@ -1198,11 +1326,18 @@ impl<T: Sized> DebugEnsureAligned for *mut T {
 /// [`assign_to`]: MovingPtr::assign_to
 #[macro_export]
 macro_rules! deconstruct_moving_ptr {
-    ($ptr:ident, $self_type:tt {$($field_name:tt: $field_type:tt => $field_block:block,)*}) => {
-        $(let $field_name = $ptr.move_field::<$field_type>(core::mem::offset_of!($self_type, $field_name));)*
-        // Each field block may panic! Ensure that `parent_ptr` cannot be dropped before
-        // calling them!
+    ($ptr:ident => {$($field_name:ident,)*}) => {
+        $crate::deconstruct_moving_ptr!($ptr => ($($field_name => $field_name,)*))
+    };
+    ($ptr:ident => ($($field_index:tt => $field_alias:ident,)*)) => {
+        $(let $field_alias = $ptr.move_field(|f| &raw mut (*f).$field_index);)*
+        core::mem::forget($ptr);
+    };
+    ($ptr:ident: MaybeUninit => {$($field_name:tt,)*}) => {
+        $crate::deconstruct_moving_ptr!($ptr: MaybeUninit => ($($field_name => $field_name,)*))
+    };
+    ($ptr:ident: MaybeUninit => ($($field_index:tt => $field_alias:ident,)*)) => {
+        $(let $field_alias = $ptr.move_maybe_uninit_field(|f| &raw mut (*f).$field_index);)*
         core::mem::forget($ptr);
-        $($field_block)*
     };
 }
