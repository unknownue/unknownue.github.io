diff --git a/Cargo.toml b/Cargo.toml
index 05bee813f96b2..a7b301a4e9a8d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -602,13 +602,14 @@ serde = { version = "1", features = ["derive"] }
 serde_json = "1.0.140"
 bytemuck = "1"
 # The following explicit dependencies are needed for proc macros to work inside of examples as they are part of the bevy crate itself.
-bevy_render = { path = "crates/bevy_render", version = "0.17.0-dev", default-features = false }
-bevy_ecs = { path = "crates/bevy_ecs", version = "0.17.0-dev", default-features = false }
-bevy_state = { path = "crates/bevy_state", version = "0.17.0-dev", default-features = false }
+bevy_animation = { path = "crates/bevy_animation", version = "0.17.0-dev", default-features = false }
 bevy_asset = { path = "crates/bevy_asset", version = "0.17.0-dev", default-features = false }
-bevy_reflect = { path = "crates/bevy_reflect", version = "0.17.0-dev", default-features = false }
-bevy_image = { path = "crates/bevy_image", version = "0.17.0-dev", default-features = false }
+bevy_ecs = { path = "crates/bevy_ecs", version = "0.17.0-dev", default-features = false }
 bevy_gizmos = { path = "crates/bevy_gizmos", version = "0.17.0-dev", default-features = false }
+bevy_image = { path = "crates/bevy_image", version = "0.17.0-dev", default-features = false }
+bevy_reflect = { path = "crates/bevy_reflect", version = "0.17.0-dev", default-features = false }
+bevy_render = { path = "crates/bevy_render", version = "0.17.0-dev", default-features = false }
+bevy_state = { path = "crates/bevy_state", version = "0.17.0-dev", default-features = false }
 # Needed to poll Task examples
 futures-lite = "2.0.1"
 futures-timer = { version = "3", features = ["wasm-bindgen", "gloo-timers"] }
diff --git a/benches/benches/bevy_ecs/observers/simple.rs b/benches/benches/bevy_ecs/observers/custom.rs
similarity index 56%
rename from benches/benches/bevy_ecs/observers/simple.rs
rename to benches/benches/bevy_ecs/observers/custom.rs
index a4915e6afa807..f38e44d062a8d 100644
--- a/benches/benches/bevy_ecs/observers/simple.rs
+++ b/benches/benches/bevy_ecs/observers/custom.rs
@@ -1,8 +1,9 @@
 use core::hint::black_box;
 
 use bevy_ecs::{
-    event::EntityEvent,
-    observer::{On, TriggerTargets},
+    entity::Entity,
+    event::{EntityEvent, Event},
+    observer::On,
     world::World,
 };
 
@@ -13,43 +14,50 @@ fn deterministic_rand() -> ChaCha8Rng {
     ChaCha8Rng::seed_from_u64(42)
 }
 
-#[derive(Clone, EntityEvent)]
-struct EventBase;
+#[derive(Clone, Event)]
+struct A;
 
-pub fn observe_simple(criterion: &mut Criterion) {
+pub fn observer_custom(criterion: &mut Criterion) {
     let mut group = criterion.benchmark_group("observe");
     group.warm_up_time(core::time::Duration::from_millis(500));
     group.measurement_time(core::time::Duration::from_secs(4));
 
-    group.bench_function("trigger_simple", |bencher| {
+    group.bench_function("observer_custom", |bencher| {
         let mut world = World::new();
-        world.add_observer(empty_listener_base);
+        world.add_observer(on_a);
         bencher.iter(|| {
             for _ in 0..10000 {
-                world.trigger(EventBase);
+                world.trigger(A);
             }
         });
     });
 
-    group.bench_function("trigger_targets_simple/10000_entity", |bencher| {
+    group.bench_function("observer_custom/10000_entity", |bencher| {
         let mut world = World::new();
         let mut entities = vec![];
         for _ in 0..10000 {
-            entities.push(world.spawn_empty().observe(empty_listener_base).id());
+            entities.push(world.spawn_empty().observe(on_b).id());
         }
         entities.shuffle(&mut deterministic_rand());
         bencher.iter(|| {
-            send_base_event(&mut world, &entities);
+            for entity in entities.iter().copied() {
+                world.trigger(B { entity });
+            }
         });
     });
 
     group.finish();
 }
 
-fn empty_listener_base(event: On<EventBase>) {
+fn on_a(event: On<A>) {
     black_box(event);
 }
 
-fn send_base_event(world: &mut World, entities: impl TriggerTargets) {
-    world.trigger_targets(EventBase, entities);
+#[derive(Clone, EntityEvent)]
+struct B {
+    entity: Entity,
+}
+
+fn on_b(event: On<B>) {
+    black_box(event);
 }
diff --git a/benches/benches/bevy_ecs/observers/lifecycle.rs b/benches/benches/bevy_ecs/observers/lifecycle.rs
new file mode 100644
index 0000000000000..7f81aba92b87a
--- /dev/null
+++ b/benches/benches/bevy_ecs/observers/lifecycle.rs
@@ -0,0 +1,35 @@
+use bevy_ecs::{component::Component, lifecycle::Insert, observer::On, world::World};
+use core::hint::black_box;
+use criterion::Criterion;
+use rand::SeedableRng;
+use rand_chacha::ChaCha8Rng;
+
+fn deterministic_rand() -> ChaCha8Rng {
+    ChaCha8Rng::seed_from_u64(42)
+}
+
+pub fn observer_lifecycle(criterion: &mut Criterion) {
+    let mut group = criterion.benchmark_group("observe");
+    group.warm_up_time(core::time::Duration::from_millis(500));
+    group.measurement_time(core::time::Duration::from_secs(4));
+
+    group.bench_function("observer_lifecycle_insert", |bencher| {
+        let mut world = World::new();
+        world.add_observer(on_insert);
+        let mut entity = world.spawn(A);
+        bencher.iter(|| {
+            for _ in 0..10000 {
+                entity.insert(A);
+            }
+        });
+    });
+
+    group.finish();
+}
+
+#[derive(Component)]
+struct A;
+
+fn on_insert(event: On<Insert, A>) {
+    black_box(event);
+}
diff --git a/benches/benches/bevy_ecs/observers/mod.rs b/benches/benches/bevy_ecs/observers/mod.rs
index 16008def7e461..76218072f50f7 100644
--- a/benches/benches/bevy_ecs/observers/mod.rs
+++ b/benches/benches/bevy_ecs/observers/mod.rs
@@ -1,8 +1,15 @@
+mod custom;
+mod lifecycle;
 mod propagation;
-mod simple;
 
 use criterion::criterion_group;
+use custom::*;
+use lifecycle::*;
 use propagation::*;
-use simple::*;
 
-criterion_group!(benches, event_propagation, observe_simple);
+criterion_group!(
+    benches,
+    event_propagation,
+    observer_custom,
+    observer_lifecycle
+);
diff --git a/benches/benches/bevy_ecs/observers/propagation.rs b/benches/benches/bevy_ecs/observers/propagation.rs
index 3b862cc1a631f..3b676137c0aa1 100644
--- a/benches/benches/bevy_ecs/observers/propagation.rs
+++ b/benches/benches/bevy_ecs/observers/propagation.rs
@@ -62,14 +62,16 @@ pub fn event_propagation(criterion: &mut Criterion) {
 }
 
 #[derive(EntityEvent, Clone, Component)]
-#[entity_event(traversal = &'static ChildOf, auto_propagate)]
-struct TestEvent<const N: usize> {}
+#[entity_event(propagate, auto_propagate)]
+struct TestEvent<const N: usize> {
+    entity: Entity,
+}
 
 fn send_events<const N: usize, const N_EVENTS: usize>(world: &mut World, leaves: &[Entity]) {
-    let target = leaves.iter().choose(&mut rand::rng()).unwrap();
+    let entity = *leaves.iter().choose(&mut rand::rng()).unwrap();
 
     (0..N_EVENTS).for_each(|_| {
-        world.trigger_targets(TestEvent::<N> {}, *target);
+        world.trigger(TestEvent::<N> { entity });
     });
 }
 
diff --git a/crates/bevy_animation/Cargo.toml b/crates/bevy_animation/Cargo.toml
index ec3d91956ce38..a6013626ac645 100644
--- a/crates/bevy_animation/Cargo.toml
+++ b/crates/bevy_animation/Cargo.toml
@@ -10,6 +10,7 @@ keywords = ["bevy"]
 
 [dependencies]
 # bevy
+bevy_animation_macros = { path = "macros", version = "0.17.0-dev" }
 bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
 bevy_asset = { path = "../bevy_asset", version = "0.17.0-dev" }
 bevy_color = { path = "../bevy_color", version = "0.17.0-dev" }
diff --git a/crates/bevy_animation/macros/Cargo.toml b/crates/bevy_animation/macros/Cargo.toml
new file mode 100644
index 0000000000000..a56d11c387801
--- /dev/null
+++ b/crates/bevy_animation/macros/Cargo.toml
@@ -0,0 +1,22 @@
+[package]
+name = "bevy_animation_macros"
+version = "0.17.0-dev"
+description = "Macros for bevy_animation"
+edition = "2024"
+license = "MIT OR Apache-2.0"
+
+[lib]
+proc-macro = true
+
+[dependencies]
+bevy_macro_utils = { path = "../../bevy_macro_utils", version = "0.17.0-dev" }
+
+syn = { version = "2.0", features = ["full"] }
+quote = "1.0"
+
+[lints]
+workspace = true
+
+[package.metadata.docs.rs]
+rustdoc-args = ["-Zunstable-options"]
+all-features = true
diff --git a/crates/bevy_animation/macros/LICENSE-APACHE b/crates/bevy_animation/macros/LICENSE-APACHE
new file mode 100644
index 0000000000000..d9a10c0d8e868
--- /dev/null
+++ b/crates/bevy_animation/macros/LICENSE-APACHE
@@ -0,0 +1,176 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
diff --git a/crates/bevy_animation/macros/LICENSE-MIT b/crates/bevy_animation/macros/LICENSE-MIT
new file mode 100644
index 0000000000000..9cf106272ac3b
--- /dev/null
+++ b/crates/bevy_animation/macros/LICENSE-MIT
@@ -0,0 +1,19 @@
+MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/crates/bevy_animation/macros/src/animation_event.rs b/crates/bevy_animation/macros/src/animation_event.rs
new file mode 100644
index 0000000000000..b4abf9fc85f07
--- /dev/null
+++ b/crates/bevy_animation/macros/src/animation_event.rs
@@ -0,0 +1,26 @@
+use bevy_macro_utils::BevyManifest;
+use proc_macro::TokenStream;
+use quote::quote;
+use syn::{parse_macro_input, DeriveInput};
+
+pub fn derive_animation_event(input: TokenStream) -> TokenStream {
+    let ast = parse_macro_input!(input as DeriveInput);
+    let manifest = BevyManifest::shared();
+    let bevy_ecs = manifest.get_path("bevy_ecs");
+    let bevy_animation = manifest.get_path("bevy_animation");
+
+    let generics = ast.generics;
+    let (impl_generics, type_generics, where_clause) = generics.split_for_impl();
+
+    let struct_name = &ast.ident;
+
+    quote! {
+        impl #impl_generics #bevy_ecs::event::Event for #struct_name #type_generics #where_clause {
+            type Trigger<'a> = #bevy_animation::AnimationEventTrigger;
+        }
+
+        impl #impl_generics #bevy_animation::AnimationEvent for #struct_name #type_generics #where_clause {
+        }
+    }
+    .into()
+}
diff --git a/crates/bevy_animation/macros/src/lib.rs b/crates/bevy_animation/macros/src/lib.rs
new file mode 100644
index 0000000000000..2954b412b4c5a
--- /dev/null
+++ b/crates/bevy_animation/macros/src/lib.rs
@@ -0,0 +1,16 @@
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+
+//! Macros for deriving animation behaviors.
+
+extern crate proc_macro;
+
+mod animation_event;
+
+use proc_macro::TokenStream;
+
+/// Implements the `AnimationEvent` trait for a type - see the trait
+/// docs for an example usage.
+#[proc_macro_derive(AnimationEvent)]
+pub fn derive_animation_event(input: TokenStream) -> TokenStream {
+    animation_event::derive_animation_event(input)
+}
diff --git a/crates/bevy_animation/src/animation_event.rs b/crates/bevy_animation/src/animation_event.rs
new file mode 100644
index 0000000000000..55bf5655855a6
--- /dev/null
+++ b/crates/bevy_animation/src/animation_event.rs
@@ -0,0 +1,58 @@
+pub use bevy_animation_macros::AnimationEvent;
+
+use bevy_ecs::{
+    entity::Entity,
+    event::{trigger_entity_internal, Event, Trigger},
+    observer::{CachedObservers, TriggerContext},
+    world::DeferredWorld,
+};
+
+/// An [`Event`] that an [`AnimationPlayer`](crate::AnimationPlayer) can trigger when playing an [`AnimationClip`](crate::AnimationClip).
+/// See [`AnimationClip::add_event`](crate::AnimationClip::add_event).
+///
+/// This trait can be derived.
+pub trait AnimationEvent: Clone + for<'a> Event<Trigger<'a> = AnimationEventTrigger> {}
+
+/// The [`Trigger`] implementation for [`AnimationEvent`]. This passes in the [`AnimationPlayer`](crate::AnimationPlayer)
+/// context, and uses that to run any observers that target that entity.
+pub struct AnimationEventTrigger {
+    /// The [`AnimationPlayer`](crate::AnimationPlayer) where this [`AnimationEvent`] occurred.
+    pub animation_player: Entity,
+}
+
+#[expect(
+    unsafe_code,
+    reason = "We must implement this trait to define a custom Trigger, which is required to be unsafe due to safety considerations within bevy_ecs."
+)]
+// SAFETY:
+// - `E`'s [`Event::Trigger`] is constrained to [`AnimationEventTrigger`]
+// - The implementation abides by the other safety constraints defined in [`Trigger`]
+unsafe impl<E: AnimationEvent + for<'a> Event<Trigger<'a> = AnimationEventTrigger>> Trigger<E>
+    for AnimationEventTrigger
+{
+    unsafe fn trigger(
+        &mut self,
+        world: DeferredWorld,
+        observers: &CachedObservers,
+        trigger_context: &TriggerContext,
+        event: &mut E,
+    ) {
+        let animation_player = self.animation_player;
+        // SAFETY:
+        // - `observers` come from `world` and match the event type `E`, enforced by the call to `trigger`
+        // - the passed in event pointer comes from `event`, which is an `Event`
+        // - `trigger` is a matching trigger type, as it comes from `self`, which is the Trigger for `E`
+        // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger`
+        // - this abides by the nuances defined in the `Trigger` safety docs
+        unsafe {
+            trigger_entity_internal(
+                world,
+                observers,
+                event.into(),
+                self.into(),
+                animation_player,
+                trigger_context,
+            );
+        }
+    }
+}
diff --git a/crates/bevy_animation/src/lib.rs b/crates/bevy_animation/src/lib.rs
index 386eb614be3a3..ac87e41d6787c 100644
--- a/crates/bevy_animation/src/lib.rs
+++ b/crates/bevy_animation/src/lib.rs
@@ -1,5 +1,5 @@
 #![cfg_attr(docsrs, feature(doc_auto_cfg))]
-#![forbid(unsafe_code)]
+#![warn(unsafe_code)]
 #![doc(
     html_logo_url = "https://bevy.org/assets/icon.png",
     html_favicon_url = "https://bevy.org/assets/icon.png"
@@ -14,8 +14,12 @@ pub mod animation_curves;
 pub mod gltf_curves;
 pub mod graph;
 pub mod transition;
+
+mod animation_event;
 mod util;
 
+pub use animation_event::*;
+
 use core::{
     any::TypeId,
     cell::RefCell,
@@ -108,17 +112,17 @@ pub struct AnimationClip {
 #[reflect(Clone)]
 struct TimedAnimationEvent {
     time: f32,
-    event: AnimationEvent,
+    event: AnimationEventData,
 }
 
 #[derive(Reflect, Debug, Clone)]
 #[reflect(Clone)]
-struct AnimationEvent {
+struct AnimationEventData {
     #[reflect(ignore, clone)]
     trigger: AnimationEventFn,
 }
 
-impl AnimationEvent {
+impl AnimationEventData {
     fn trigger(&self, commands: &mut Commands, entity: Entity, time: f32, weight: f32) {
         (self.trigger.0)(commands, entity, time, weight);
     }
@@ -329,11 +333,16 @@ impl AnimationClip {
     /// is reached in the animation.
     ///
     /// See also [`add_event_to_target`](Self::add_event_to_target).
-    pub fn add_event(&mut self, time: f32, event: impl EntityEvent + Clone) {
+    pub fn add_event(&mut self, time: f32, event: impl AnimationEvent) {
         self.add_event_fn(
             time,
             move |commands: &mut Commands, entity: Entity, _time: f32, _weight: f32| {
-                commands.entity(entity).trigger(event.clone());
+                commands.trigger_with(
+                    event.clone(),
+                    AnimationEventTrigger {
+                        animation_player: entity,
+                    },
+                );
             },
         );
     }
@@ -348,13 +357,18 @@ impl AnimationClip {
         &mut self,
         target_id: AnimationTargetId,
         time: f32,
-        event: impl EntityEvent + Clone,
+        event: impl AnimationEvent,
     ) {
         self.add_event_fn_to_target(
             target_id,
             time,
             move |commands: &mut Commands, entity: Entity, _time: f32, _weight: f32| {
-                commands.entity(entity).trigger(event.clone());
+                commands.trigger_with(
+                    event.clone(),
+                    AnimationEventTrigger {
+                        animation_player: entity,
+                    },
+                );
             },
         );
     }
@@ -419,7 +433,7 @@ impl AnimationClip {
                 index,
                 TimedAnimationEvent {
                     time,
-                    event: AnimationEvent {
+                    event: AnimationEventData {
                         trigger: AnimationEventFn(Arc::new(trigger_fn)),
                     },
                 },
@@ -1521,11 +1535,12 @@ impl<'a> Iterator for TriggeredEventsIter<'a> {
 
 #[cfg(test)]
 mod tests {
+    use crate as bevy_animation;
     use bevy_reflect::{DynamicMap, Map};
 
     use super::*;
 
-    #[derive(EntityEvent, Reflect, Clone)]
+    #[derive(AnimationEvent, Reflect, Clone)]
     struct A;
 
     #[track_caller]
diff --git a/crates/bevy_app/src/app.rs b/crates/bevy_app/src/app.rs
index 7ef2a4a82b773..f2bd1b67cf27f 100644
--- a/crates/bevy_app/src/app.rs
+++ b/crates/bevy_app/src/app.rs
@@ -11,7 +11,7 @@ pub use bevy_derive::AppLabel;
 use bevy_ecs::{
     component::RequiredComponentsError,
     error::{DefaultErrorHandler, ErrorHandler},
-    event::{event_update_system, EventCursor},
+    event::{event_update_system, Event, EventCursor},
     intern::Interned,
     prelude::*,
     schedule::{InternedSystemSet, ScheduleBuildSettings, ScheduleLabel},
@@ -1339,7 +1339,9 @@ impl App {
     /// # };
     /// #
     /// # #[derive(EntityEvent)]
-    /// # struct Invite;
+    /// # struct Invite {
+    /// #    entity: Entity,
+    /// # }
     /// #
     /// # #[derive(Component)]
     /// # struct Friend;
@@ -1347,8 +1349,8 @@ impl App {
     ///
     /// app.add_observer(|event: On<Party>, friends: Query<Entity, With<Friend>>, mut commands: Commands| {
     ///     if event.friends_allowed {
-    ///         for friend in friends.iter() {
-    ///             commands.trigger_targets(Invite, friend);
+    ///         for entity in friends.iter() {
+    ///             commands.trigger(Invite { entity } );
     ///         }
     ///     }
     /// });
diff --git a/crates/bevy_core_widgets/src/core_button.rs b/crates/bevy_core_widgets/src/core_button.rs
index 059a2751c863d..0eea42588f5a9 100644
--- a/crates/bevy_core_widgets/src/core_button.rs
+++ b/crates/bevy_core_widgets/src/core_button.rs
@@ -34,7 +34,7 @@ fn button_on_key_event(
     q_state: Query<(&CoreButton, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((bstate, disabled)) = q_state.get(event.entity())
+    if let Ok((bstate, disabled)) = q_state.get(event.focused_entity)
         && !disabled
     {
         let input_event = &event.input;
@@ -43,31 +43,31 @@ fn button_on_key_event(
             && (input_event.key_code == KeyCode::Enter || input_event.key_code == KeyCode::Space)
         {
             event.propagate(false);
-            commands.notify_with(&bstate.on_activate, Activate(event.entity()));
+            commands.notify_with(&bstate.on_activate, Activate(event.focused_entity));
         }
     }
 }
 
 fn button_on_pointer_click(
-    mut event: On<Pointer<Click>>,
+    mut click: On<Pointer<Click>>,
     mut q_state: Query<(&CoreButton, Has<Pressed>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((bstate, pressed, disabled)) = q_state.get_mut(event.entity()) {
-        event.propagate(false);
+    if let Ok((bstate, pressed, disabled)) = q_state.get_mut(click.entity) {
+        click.propagate(false);
         if pressed && !disabled {
-            commands.notify_with(&bstate.on_activate, Activate(event.entity()));
+            commands.notify_with(&bstate.on_activate, Activate(click.entity));
         }
     }
 }
 
 fn button_on_pointer_down(
-    mut event: On<Pointer<Press>>,
+    mut press: On<Pointer<Press>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
-        event.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(press.entity) {
+        press.propagate(false);
         if !disabled && !pressed {
             commands.entity(button).insert(Pressed);
         }
@@ -75,12 +75,12 @@ fn button_on_pointer_down(
 }
 
 fn button_on_pointer_up(
-    mut event: On<Pointer<Release>>,
+    mut release: On<Pointer<Release>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
-        event.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(release.entity) {
+        release.propagate(false);
         if !disabled && pressed {
             commands.entity(button).remove::<Pressed>();
         }
@@ -88,12 +88,12 @@ fn button_on_pointer_up(
 }
 
 fn button_on_pointer_drag_end(
-    mut event: On<Pointer<DragEnd>>,
+    mut drag_end: On<Pointer<DragEnd>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
-        event.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(drag_end.entity) {
+        drag_end.propagate(false);
         if !disabled && pressed {
             commands.entity(button).remove::<Pressed>();
         }
@@ -101,12 +101,12 @@ fn button_on_pointer_drag_end(
 }
 
 fn button_on_pointer_cancel(
-    mut event: On<Pointer<Cancel>>,
+    mut cancel: On<Pointer<Cancel>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
-        event.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(cancel.entity) {
+        cancel.propagate(false);
         if !disabled && pressed {
             commands.entity(button).remove::<Pressed>();
         }
diff --git a/crates/bevy_core_widgets/src/core_checkbox.rs b/crates/bevy_core_widgets/src/core_checkbox.rs
index ed84efd44d259..33cdf7956fdbf 100644
--- a/crates/bevy_core_widgets/src/core_checkbox.rs
+++ b/crates/bevy_core_widgets/src/core_checkbox.rs
@@ -16,6 +16,7 @@ use bevy_picking::events::{Click, Pointer};
 use bevy_ui::{Checkable, Checked, InteractionDisabled};
 
 use crate::{Callback, Notify as _, ValueChange};
+use bevy_ecs::entity::Entity;
 
 /// Headless widget implementation for checkboxes. The [`Checked`] component represents the current
 /// state of the checkbox. The `on_change` field is an optional system id that will be run when the
@@ -42,38 +43,38 @@ fn checkbox_on_key_input(
     q_checkbox: Query<(&CoreCheckbox, Has<Checked>), Without<InteractionDisabled>>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked)) = q_checkbox.get(ev.entity()) {
+    if let Ok((checkbox, is_checked)) = q_checkbox.get(ev.focused_entity) {
         let event = &ev.event().input;
         if event.state == ButtonState::Pressed
             && !event.repeat
             && (event.key_code == KeyCode::Enter || event.key_code == KeyCode::Space)
         {
             ev.propagate(false);
-            set_checkbox_state(&mut commands, ev.entity(), checkbox, !is_checked);
+            set_checkbox_state(&mut commands, ev.focused_entity, checkbox, !is_checked);
         }
     }
 }
 
 fn checkbox_on_pointer_click(
-    mut ev: On<Pointer<Click>>,
+    mut click: On<Pointer<Click>>,
     q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
     focus: Option<ResMut<InputFocus>>,
     focus_visible: Option<ResMut<InputFocusVisible>>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.entity()) {
+    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(click.entity) {
         // Clicking on a button makes it the focused input,
         // and hides the focus ring if it was visible.
         if let Some(mut focus) = focus {
-            focus.0 = Some(ev.entity());
+            focus.0 = Some(click.entity);
         }
         if let Some(mut focus_visible) = focus_visible {
             focus_visible.0 = false;
         }
 
-        ev.propagate(false);
+        click.propagate(false);
         if !disabled {
-            set_checkbox_state(&mut commands, ev.entity(), checkbox, !is_checked);
+            set_checkbox_state(&mut commands, click.entity, checkbox, !is_checked);
         }
     }
 }
@@ -89,16 +90,21 @@ fn checkbox_on_pointer_click(
 ///
 /// fn setup(mut commands: Commands) {
 ///     // Create a checkbox
-///     let checkbox = commands.spawn((
+///     let entity = commands.spawn((
 ///         CoreCheckbox::default(),
 ///     )).id();
 ///
 ///     // Set to checked
-///     commands.trigger_targets(SetChecked(true), checkbox);
+///     commands.trigger(SetChecked { entity, checked: true});
 /// }
 /// ```
 #[derive(EntityEvent)]
-pub struct SetChecked(pub bool);
+pub struct SetChecked {
+    /// The [`CoreCheckbox`] entity to set the "checked" state on.
+    pub entity: Entity,
+    /// Sets the `checked` state to `true` or `false`.
+    pub checked: bool,
+}
 
 /// Event which can be triggered on a checkbox to toggle the checked state. This can be used to
 /// control the checkbox via gamepad buttons or other inputs.
@@ -111,53 +117,54 @@ pub struct SetChecked(pub bool);
 ///
 /// fn setup(mut commands: Commands) {
 ///     // Create a checkbox
-///     let checkbox = commands.spawn((
+///     let entity = commands.spawn((
 ///         CoreCheckbox::default(),
 ///     )).id();
 ///
 ///     // Set to checked
-///     commands.trigger_targets(ToggleChecked, checkbox);
+///     commands.trigger(ToggleChecked { entity });
 /// }
 /// ```
 #[derive(EntityEvent)]
-pub struct ToggleChecked;
+pub struct ToggleChecked {
+    /// The [`Entity`] of the toggled [`CoreCheckbox`]
+    pub entity: Entity,
+}
 
 fn checkbox_on_set_checked(
-    mut ev: On<SetChecked>,
+    set_checked: On<SetChecked>,
     q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.entity()) {
-        ev.propagate(false);
+    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(set_checked.entity) {
         if disabled {
             return;
         }
 
-        let will_be_checked = ev.event().0;
+        let will_be_checked = set_checked.checked;
         if will_be_checked != is_checked {
-            set_checkbox_state(&mut commands, ev.entity(), checkbox, will_be_checked);
+            set_checkbox_state(&mut commands, set_checked.entity, checkbox, will_be_checked);
         }
     }
 }
 
 fn checkbox_on_toggle_checked(
-    mut ev: On<ToggleChecked>,
+    toggle_checked: On<ToggleChecked>,
     q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.entity()) {
-        ev.propagate(false);
+    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(toggle_checked.entity) {
         if disabled {
             return;
         }
 
-        set_checkbox_state(&mut commands, ev.entity(), checkbox, !is_checked);
+        set_checkbox_state(&mut commands, toggle_checked.entity, checkbox, !is_checked);
     }
 }
 
 fn set_checkbox_state(
     commands: &mut Commands,
-    entity: impl Into<bevy_ecs::entity::Entity>,
+    entity: impl Into<Entity>,
     checkbox: &CoreCheckbox,
     new_state: bool,
 ) {
diff --git a/crates/bevy_core_widgets/src/core_radio.rs b/crates/bevy_core_widgets/src/core_radio.rs
index e5ba867a3410f..b2a313552c0e2 100644
--- a/crates/bevy_core_widgets/src/core_radio.rs
+++ b/crates/bevy_core_widgets/src/core_radio.rs
@@ -1,15 +1,13 @@
 use accesskit::Role;
 use bevy_a11y::AccessibilityNode;
 use bevy_app::{App, Plugin};
-use bevy_ecs::hierarchy::{ChildOf, Children};
-use bevy_ecs::query::Has;
-use bevy_ecs::system::In;
 use bevy_ecs::{
     component::Component,
+    hierarchy::{ChildOf, Children},
     observer::On,
-    query::With,
+    query::{Has, With},
     reflect::ReflectComponent,
-    system::{Commands, Query},
+    system::{Commands, In, Query},
 };
 use bevy_input::keyboard::{KeyCode, KeyboardInput};
 use bevy_input::ButtonState;
@@ -61,7 +59,7 @@ fn radio_group_on_key_input(
     q_children: Query<&Children>,
     mut commands: Commands,
 ) {
-    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.entity()) {
+    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.focused_entity) {
         let event = &ev.event().input;
         if event.state == ButtonState::Pressed
             && !event.repeat
@@ -80,7 +78,7 @@ fn radio_group_on_key_input(
 
             // Find all radio descendants that are not disabled
             let radio_buttons = q_children
-                .iter_descendants(ev.entity())
+                .iter_descendants(ev.focused_entity)
                 .filter_map(|child_id| match q_radio.get(child_id) {
                     Ok((checked, false)) => Some((child_id, checked)),
                     Ok((_, true)) | Err(_) => None,
@@ -149,14 +147,14 @@ fn radio_group_on_button_click(
     q_children: Query<&Children>,
     mut commands: Commands,
 ) {
-    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.entity()) {
+    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.entity) {
         // Starting with the original target, search upward for a radio button.
-        let radio_id = if q_radio.contains(ev.original_entity()) {
-            ev.original_entity()
+        let radio_id = if q_radio.contains(ev.original_event_target()) {
+            ev.original_event_target()
         } else {
             // Search ancestors for the first radio button
             let mut found_radio = None;
-            for ancestor in q_parents.iter_ancestors(ev.original_entity()) {
+            for ancestor in q_parents.iter_ancestors(ev.original_event_target()) {
                 if q_group.contains(ancestor) {
                     // We reached a radio group before finding a radio button, bail out
                     return;
@@ -180,7 +178,7 @@ fn radio_group_on_button_click(
 
         // Gather all the enabled radio group descendants for exclusion.
         let radio_buttons = q_children
-            .iter_descendants(ev.entity())
+            .iter_descendants(ev.entity)
             .filter_map(|child_id| match q_radio.get(child_id) {
                 Ok((checked, false)) => Some((child_id, checked)),
                 Ok((_, true)) | Err(_) => None,
diff --git a/crates/bevy_core_widgets/src/core_scrollbar.rs b/crates/bevy_core_widgets/src/core_scrollbar.rs
index 00569243ec593..ad23ea813751c 100644
--- a/crates/bevy_core_widgets/src/core_scrollbar.rs
+++ b/crates/bevy_core_widgets/src/core_scrollbar.rs
@@ -110,10 +110,10 @@ fn scrollbar_on_pointer_down(
     mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<CoreScrollbar>>,
     ui_scale: Res<UiScale>,
 ) {
-    if q_thumb.contains(ev.entity()) {
+    if q_thumb.contains(ev.entity) {
         // If they click on the thumb, do nothing. This will be handled by the drag event.
         ev.propagate(false);
-    } else if let Ok((scrollbar, node, node_target, transform)) = q_scrollbar.get_mut(ev.entity()) {
+    } else if let Ok((scrollbar, node, node_target, transform)) = q_scrollbar.get_mut(ev.entity) {
         // If they click on the scrollbar track, page up or down.
         ev.propagate(false);
 
@@ -162,7 +162,7 @@ fn scrollbar_on_drag_start(
     q_scrollbar: Query<&CoreScrollbar>,
     q_scroll_area: Query<&ScrollPosition>,
 ) {
-    if let Ok((ChildOf(thumb_parent), mut drag)) = q_thumb.get_mut(ev.entity()) {
+    if let Ok((ChildOf(thumb_parent), mut drag)) = q_thumb.get_mut(ev.entity) {
         ev.propagate(false);
         if let Ok(scrollbar) = q_scrollbar.get(*thumb_parent)
             && let Ok(scroll_area) = q_scroll_area.get(scrollbar.target)
@@ -183,7 +183,7 @@ fn scrollbar_on_drag(
     mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<CoreScrollbar>>,
     ui_scale: Res<UiScale>,
 ) {
-    if let Ok((ChildOf(thumb_parent), drag)) = q_thumb.get_mut(ev.entity())
+    if let Ok((ChildOf(thumb_parent), drag)) = q_thumb.get_mut(ev.entity)
         && let Ok((node, scrollbar)) = q_scrollbar.get_mut(*thumb_parent)
     {
         ev.propagate(false);
@@ -219,7 +219,7 @@ fn scrollbar_on_drag_end(
     mut ev: On<Pointer<DragEnd>>,
     mut q_thumb: Query<&mut CoreScrollbarDragState, With<CoreScrollbarThumb>>,
 ) {
-    if let Ok(mut drag) = q_thumb.get_mut(ev.entity()) {
+    if let Ok(mut drag) = q_thumb.get_mut(ev.entity) {
         ev.propagate(false);
         if drag.dragging {
             drag.dragging = false;
@@ -231,7 +231,7 @@ fn scrollbar_on_drag_cancel(
     mut ev: On<Pointer<Cancel>>,
     mut q_thumb: Query<&mut CoreScrollbarDragState, With<CoreScrollbarThumb>>,
 ) {
-    if let Ok(mut drag) = q_thumb.get_mut(ev.entity()) {
+    if let Ok(mut drag) = q_thumb.get_mut(ev.entity) {
         ev.propagate(false);
         if drag.dragging {
             drag.dragging = false;
diff --git a/crates/bevy_core_widgets/src/core_slider.rs b/crates/bevy_core_widgets/src/core_slider.rs
index e680b849eda63..aa706d6241e09 100644
--- a/crates/bevy_core_widgets/src/core_slider.rs
+++ b/crates/bevy_core_widgets/src/core_slider.rs
@@ -28,6 +28,7 @@ use bevy_ui::{
 };
 
 use crate::{Callback, Notify, ValueChange};
+use bevy_ecs::entity::Entity;
 
 /// Defines how the slider should behave when you click on the track (not the thumb).
 #[derive(Debug, Default, PartialEq, Clone, Copy, Reflect)]
@@ -228,7 +229,7 @@ pub struct CoreSliderDragState {
 }
 
 pub(crate) fn slider_on_pointer_down(
-    mut event: On<Pointer<Press>>,
+    mut press: On<Pointer<Press>>,
     q_slider: Query<(
         &CoreSlider,
         &SliderValue,
@@ -245,9 +246,9 @@ pub(crate) fn slider_on_pointer_down(
     mut commands: Commands,
     ui_scale: Res<UiScale>,
 ) {
-    if q_thumb.contains(event.entity()) {
+    if q_thumb.contains(press.entity) {
         // Thumb click, stop propagation to prevent track click.
-        event.propagate(false);
+        press.propagate(false);
     } else if let Ok((
         slider,
         value,
@@ -258,10 +259,10 @@ pub(crate) fn slider_on_pointer_down(
         node_target,
         transform,
         disabled,
-    )) = q_slider.get(event.entity())
+    )) = q_slider.get(press.entity)
     {
         // Track click
-        event.propagate(false);
+        press.propagate(false);
 
         if disabled {
             return;
@@ -269,13 +270,13 @@ pub(crate) fn slider_on_pointer_down(
 
         // Find thumb size by searching descendants for the first entity with CoreSliderThumb
         let thumb_size = q_children
-            .iter_descendants(event.entity())
+            .iter_descendants(press.entity)
             .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
             .unwrap_or(0.0);
 
         // Detect track click.
         let local_pos = transform.try_inverse().unwrap().transform_point2(
-            event.pointer_location.position * node_target.scale_factor() / ui_scale.0,
+            press.pointer_location.position * node_target.scale_factor() / ui_scale.0,
         );
         let track_width = node.size().x - thumb_size;
         // Avoid division by zero
@@ -303,14 +304,12 @@ pub(crate) fn slider_on_pointer_down(
         });
 
         if matches!(slider.on_change, Callback::Ignore) {
-            commands
-                .entity(event.entity())
-                .insert(SliderValue(new_value));
+            commands.entity(press.entity).insert(SliderValue(new_value));
         } else {
             commands.notify_with(
                 &slider.on_change,
                 ValueChange {
-                    source: event.entity(),
+                    source: press.entity,
                     value: new_value,
                 },
             );
@@ -319,7 +318,7 @@ pub(crate) fn slider_on_pointer_down(
 }
 
 pub(crate) fn slider_on_drag_start(
-    mut event: On<Pointer<DragStart>>,
+    mut drag_start: On<Pointer<DragStart>>,
     mut q_slider: Query<
         (
             &SliderValue,
@@ -329,8 +328,8 @@ pub(crate) fn slider_on_drag_start(
         With<CoreSlider>,
     >,
 ) {
-    if let Ok((value, mut drag, disabled)) = q_slider.get_mut(event.entity()) {
-        event.propagate(false);
+    if let Ok((value, mut drag, disabled)) = q_slider.get_mut(drag_start.entity) {
+        drag_start.propagate(false);
         if !disabled {
             drag.dragging = true;
             drag.offset = value.0;
@@ -355,7 +354,7 @@ pub(crate) fn slider_on_drag(
     ui_scale: Res<UiScale>,
 ) {
     if let Ok((node, slider, range, precision, transform, drag, disabled)) =
-        q_slider.get_mut(event.entity())
+        q_slider.get_mut(event.entity)
     {
         event.propagate(false);
         if drag.dragging && !disabled {
@@ -364,7 +363,7 @@ pub(crate) fn slider_on_drag(
             let distance = transform.transform_vector2(distance);
             // Find thumb size by searching descendants for the first entity with CoreSliderThumb
             let thumb_size = q_children
-                .iter_descendants(event.entity())
+                .iter_descendants(event.entity)
                 .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
                 .unwrap_or(0.0);
             let slider_width = ((node.size().x - thumb_size) * node.inverse_scale_factor).max(1.0);
@@ -382,13 +381,13 @@ pub(crate) fn slider_on_drag(
 
             if matches!(slider.on_change, Callback::Ignore) {
                 commands
-                    .entity(event.entity())
+                    .entity(event.entity)
                     .insert(SliderValue(rounded_value));
             } else {
                 commands.notify_with(
                     &slider.on_change,
                     ValueChange {
-                        source: event.entity(),
+                        source: event.entity,
                         value: rounded_value,
                     },
                 );
@@ -398,11 +397,11 @@ pub(crate) fn slider_on_drag(
 }
 
 pub(crate) fn slider_on_drag_end(
-    mut event: On<Pointer<DragEnd>>,
+    mut drag_end: On<Pointer<DragEnd>>,
     mut q_slider: Query<(&CoreSlider, &mut CoreSliderDragState)>,
 ) {
-    if let Ok((_slider, mut drag)) = q_slider.get_mut(event.entity()) {
-        event.propagate(false);
+    if let Ok((_slider, mut drag)) = q_slider.get_mut(drag_end.entity) {
+        drag_end.propagate(false);
         if drag.dragging {
             drag.dragging = false;
         }
@@ -410,7 +409,7 @@ pub(crate) fn slider_on_drag_end(
 }
 
 fn slider_on_key_input(
-    mut event: On<FocusedInput<KeyboardInput>>,
+    mut focused_input: On<FocusedInput<KeyboardInput>>,
     q_slider: Query<(
         &CoreSlider,
         &SliderValue,
@@ -420,8 +419,8 @@ fn slider_on_key_input(
     )>,
     mut commands: Commands,
 ) {
-    if let Ok((slider, value, range, step, disabled)) = q_slider.get(event.entity()) {
-        let input_event = &event.input;
+    if let Ok((slider, value, range, step, disabled)) = q_slider.get(focused_input.focused_entity) {
+        let input_event = &focused_input.input;
         if !disabled && input_event.state == ButtonState::Pressed {
             let new_value = match input_event.key_code {
                 KeyCode::ArrowLeft => range.clamp(value.0 - step.0),
@@ -432,16 +431,16 @@ fn slider_on_key_input(
                     return;
                 }
             };
-            event.propagate(false);
+            focused_input.propagate(false);
             if matches!(slider.on_change, Callback::Ignore) {
                 commands
-                    .entity(event.entity())
+                    .entity(focused_input.focused_entity)
                     .insert(SliderValue(new_value));
             } else {
                 commands.notify_with(
                     &slider.on_change,
                     ValueChange {
-                        source: event.entity(),
+                        source: focused_input.focused_entity,
                         value: new_value,
                     },
                 );
@@ -450,23 +449,23 @@ fn slider_on_key_input(
     }
 }
 
-pub(crate) fn slider_on_insert(event: On<Insert, CoreSlider>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn slider_on_insert(insert: On<Insert, CoreSlider>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(insert.entity);
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_orientation(Orientation::Horizontal);
     }
 }
 
-pub(crate) fn slider_on_insert_value(event: On<Insert, SliderValue>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn slider_on_insert_value(insert: On<Insert, SliderValue>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(insert.entity);
     let value = entity.get::<SliderValue>().unwrap().0;
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_numeric_value(value.into());
     }
 }
 
-pub(crate) fn slider_on_insert_range(event: On<Insert, SliderRange>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn slider_on_insert_range(insert: On<Insert, SliderRange>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(insert.entity);
     let range = *entity.get::<SliderRange>().unwrap();
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_min_numeric_value(range.start().into());
@@ -474,8 +473,8 @@ pub(crate) fn slider_on_insert_range(event: On<Insert, SliderRange>, mut world:
     }
 }
 
-pub(crate) fn slider_on_insert_step(event: On<Insert, SliderStep>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn slider_on_insert_step(insert: On<Insert, SliderStep>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(insert.entity);
     let step = entity.get::<SliderStep>().unwrap().0;
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_numeric_value_step(step.into());
@@ -489,26 +488,40 @@ pub(crate) fn slider_on_insert_step(event: On<Insert, SliderStep>, mut world: De
 /// # Example:
 ///
 /// ```
-/// use bevy_ecs::system::Commands;
-/// use bevy_core_widgets::{CoreSlider, SliderRange, SliderValue, SetSliderValue};
-///
+/// # use bevy_ecs::system::Commands;
+/// # use bevy_core_widgets::{CoreSlider, SliderRange, SliderValue, SetSliderValue, SliderValueChange};
 /// fn setup(mut commands: Commands) {
 ///     // Create a slider
-///     let slider = commands.spawn((
+///     let entity = commands.spawn((
 ///         CoreSlider::default(),
 ///         SliderValue(0.5),
 ///         SliderRange::new(0.0, 1.0),
 ///     )).id();
 ///
 ///     // Set to an absolute value
-///     commands.trigger_targets(SetSliderValue::Absolute(0.75), slider);
+///     commands.trigger(SetSliderValue {
+///         entity,
+///         change: SliderValueChange::Absolute(0.75),
+///     });
 ///
 ///     // Adjust relatively
-///     commands.trigger_targets(SetSliderValue::Relative(-0.25), slider);
+///     commands.trigger(SetSliderValue {
+///         entity,
+///         change: SliderValueChange::Relative(-0.25),
+///     });
 /// }
 /// ```
 #[derive(EntityEvent, Clone)]
-pub enum SetSliderValue {
+pub struct SetSliderValue {
+    /// The slider entity to change.
+    pub entity: Entity,
+    /// The change to apply to the slider entity.
+    pub change: SliderValueChange,
+}
+
+/// The type of slider value change to apply in [`SetSliderValue`].
+#[derive(Clone)]
+pub enum SliderValueChange {
     /// Set the slider value to a specific value.
     Absolute(f32),
     /// Add a delta to the slider value.
@@ -518,28 +531,27 @@ pub enum SetSliderValue {
 }
 
 fn slider_on_set_value(
-    mut event: On<SetSliderValue>,
+    set_slider_value: On<SetSliderValue>,
     q_slider: Query<(&CoreSlider, &SliderValue, &SliderRange, Option<&SliderStep>)>,
     mut commands: Commands,
 ) {
-    if let Ok((slider, value, range, step)) = q_slider.get(event.entity()) {
-        event.propagate(false);
-        let new_value = match event.event() {
-            SetSliderValue::Absolute(new_value) => range.clamp(*new_value),
-            SetSliderValue::Relative(delta) => range.clamp(value.0 + *delta),
-            SetSliderValue::RelativeStep(delta) => {
-                range.clamp(value.0 + *delta * step.map(|s| s.0).unwrap_or_default())
+    if let Ok((slider, value, range, step)) = q_slider.get(set_slider_value.entity) {
+        let new_value = match set_slider_value.change {
+            SliderValueChange::Absolute(new_value) => range.clamp(new_value),
+            SliderValueChange::Relative(delta) => range.clamp(value.0 + delta),
+            SliderValueChange::RelativeStep(delta) => {
+                range.clamp(value.0 + delta * step.map(|s| s.0).unwrap_or_default())
             }
         };
         if matches!(slider.on_change, Callback::Ignore) {
             commands
-                .entity(event.entity())
+                .entity(set_slider_value.entity)
                 .insert(SliderValue(new_value));
         } else {
             commands.notify_with(
                 &slider.on_change,
                 ValueChange {
-                    source: event.entity(),
+                    source: set_slider_value.entity,
                     value: new_value,
                 },
             );
diff --git a/crates/bevy_core_widgets/src/lib.rs b/crates/bevy_core_widgets/src/lib.rs
index 9a20b59c13032..1f20a31496b29 100644
--- a/crates/bevy_core_widgets/src/lib.rs
+++ b/crates/bevy_core_widgets/src/lib.rs
@@ -21,21 +21,15 @@ mod core_radio;
 mod core_scrollbar;
 mod core_slider;
 
-use bevy_app::{PluginGroup, PluginGroupBuilder};
+pub use callback::*;
+pub use core_button::*;
+pub use core_checkbox::*;
+pub use core_radio::*;
+pub use core_scrollbar::*;
+pub use core_slider::*;
 
+use bevy_app::{PluginGroup, PluginGroupBuilder};
 use bevy_ecs::entity::Entity;
-pub use callback::{Callback, Notify};
-pub use core_button::{CoreButton, CoreButtonPlugin};
-pub use core_checkbox::{CoreCheckbox, CoreCheckboxPlugin, SetChecked, ToggleChecked};
-pub use core_radio::{CoreRadio, CoreRadioGroup, CoreRadioGroupPlugin};
-pub use core_scrollbar::{
-    ControlOrientation, CoreScrollbar, CoreScrollbarDragState, CoreScrollbarPlugin,
-    CoreScrollbarThumb,
-};
-pub use core_slider::{
-    CoreSlider, CoreSliderDragState, CoreSliderPlugin, CoreSliderThumb, SetSliderValue,
-    SliderPrecision, SliderRange, SliderStep, SliderValue, TrackClick,
-};
 
 /// A plugin group that registers the observers for all of the core widgets. If you don't want to
 /// use all of the widgets, you can import the individual widget plugins instead.
diff --git a/crates/bevy_ecs/README.md b/crates/bevy_ecs/README.md
index 9ca4e9300044a..9de1d7ed693d7 100644
--- a/crates/bevy_ecs/README.md
+++ b/crates/bevy_ecs/README.md
@@ -301,7 +301,7 @@ fn reader(mut reader: EventReader<Message>) {
 
 ### Observers
 
-Observers are systems that listen for a "trigger" of a specific `Event`:
+Observers are systems that watch for a "trigger" of a specific `Event`:
 
 ```rust
 use bevy_ecs::prelude::*;
@@ -317,8 +317,6 @@ world.add_observer(|event: On<Speak>| {
     println!("{}", event.message);
 });
 
-world.flush();
-
 world.trigger(Speak {
     message: "Hello!".to_string(),
 });
@@ -334,19 +332,19 @@ If the event is an `EntityEvent`, it can also be triggered to target specific en
 use bevy_ecs::prelude::*;
 
 #[derive(EntityEvent)]
-struct Explode;
+struct Explode {
+    entity: Entity,
+}
 
 let mut world = World::new();
 let entity = world.spawn_empty().id();
 
-world.add_observer(|event: On<Explode>, mut commands: Commands| {
-    println!("Entity {} goes BOOM!", event.entity());
-    commands.entity(event.entity()).despawn();
+world.add_observer(|explode: On<Explode>, mut commands: Commands| {
+    println!("Entity {} goes BOOM!", explode.entity);
+    commands.entity(explode.entity).despawn();
 });
 
-world.flush();
-
-world.trigger_targets(Explode, entity);
+world.trigger(Explode { entity });
 ```
 
 [bevy]: https://bevy.org/
diff --git a/crates/bevy_ecs/macros/src/component.rs b/crates/bevy_ecs/macros/src/component.rs
index fe4fe4fa5b00c..1980a065e266b 100644
--- a/crates/bevy_ecs/macros/src/component.rs
+++ b/crates/bevy_ecs/macros/src/component.rs
@@ -9,57 +9,100 @@ use syn::{
     punctuated::Punctuated,
     spanned::Spanned,
     token::{Brace, Comma, Paren},
-    Data, DataEnum, DataStruct, DeriveInput, Expr, ExprCall, ExprPath, Field, Fields, Ident,
+    Data, DataEnum, DataStruct, DeriveInput, Expr, ExprCall, ExprPath, Field, Fields, Ident, Index,
     LitStr, Member, Path, Result, Token, Type, Visibility,
 };
 
-pub const EVENT: &str = "entity_event";
-pub const AUTO_PROPAGATE: &str = "auto_propagate";
+pub const EVENT: &str = "event";
+pub const ENTITY_EVENT: &str = "entity_event";
+pub const PROPAGATE: &str = "propagate";
+#[deprecated(since = "0.17.0", note = "This has been renamed to `propagate`.")]
 pub const TRAVERSAL: &str = "traversal";
+pub const AUTO_PROPAGATE: &str = "auto_propagate";
+pub const TRIGGER: &str = "trigger";
 
 pub fn derive_event(input: TokenStream) -> TokenStream {
-    let mut ast = parse_macro_input!(input as DeriveInput);
+    let ast = parse_macro_input!(input as DeriveInput);
     let bevy_ecs_path: Path = crate::bevy_ecs_path();
 
-    ast.generics
-        .make_where_clause()
-        .predicates
-        .push(parse_quote! { Self: Send + Sync + 'static });
+    let mut processed_attrs = Vec::new();
+    let mut trigger: Option<Type> = None;
+
+    for attr in ast.attrs.iter().filter(|attr| attr.path().is_ident(EVENT)) {
+        if let Err(e) = attr.parse_nested_meta(|meta| match meta.path.get_ident() {
+            Some(ident) if processed_attrs.iter().any(|i| ident == i) => {
+                Err(meta.error(format!("duplicate attribute: {ident}")))
+            }
+            Some(ident) if ident == TRIGGER => {
+                trigger = Some(meta.value()?.parse()?);
+                processed_attrs.push(TRIGGER);
+                Ok(())
+            }
+            Some(ident) => Err(meta.error(format!("unsupported attribute: {ident}"))),
+            None => Err(meta.error("expected identifier")),
+        }) {
+            return e.to_compile_error().into();
+        }
+    }
+
+    let trigger = if let Some(trigger) = trigger {
+        quote! {#trigger}
+    } else {
+        quote! {#bevy_ecs_path::event::GlobalTrigger}
+    };
 
     let struct_name = &ast.ident;
     let (impl_generics, type_generics, where_clause) = &ast.generics.split_for_impl();
 
     TokenStream::from(quote! {
-        impl #impl_generics #bevy_ecs_path::event::Event for #struct_name #type_generics #where_clause {}
+        impl #impl_generics #bevy_ecs_path::event::Event for #struct_name #type_generics #where_clause {
+            type Trigger<'a> = #trigger;
+        }
     })
 }
 
 pub fn derive_entity_event(input: TokenStream) -> TokenStream {
-    let mut ast = parse_macro_input!(input as DeriveInput);
+    let ast = parse_macro_input!(input as DeriveInput);
     let mut auto_propagate = false;
-    let mut traversal: Type = parse_quote!(());
+    let mut propagate = false;
+    let mut traversal: Option<Type> = None;
+    let mut trigger: Option<Type> = None;
     let bevy_ecs_path: Path = crate::bevy_ecs_path();
 
     let mut processed_attrs = Vec::new();
 
-    ast.generics
-        .make_where_clause()
-        .predicates
-        .push(parse_quote! { Self: Send + Sync + 'static });
-
-    for attr in ast.attrs.iter().filter(|attr| attr.path().is_ident(EVENT)) {
+    for attr in ast
+        .attrs
+        .iter()
+        .filter(|attr| attr.path().is_ident(ENTITY_EVENT))
+    {
         if let Err(e) = attr.parse_nested_meta(|meta| match meta.path.get_ident() {
             Some(ident) if processed_attrs.iter().any(|i| ident == i) => {
                 Err(meta.error(format!("duplicate attribute: {ident}")))
             }
             Some(ident) if ident == AUTO_PROPAGATE => {
+                propagate = true;
                 auto_propagate = true;
                 processed_attrs.push(AUTO_PROPAGATE);
                 Ok(())
             }
+            #[expect(deprecated, reason = "we want to continue supporting this for a release")]
             Some(ident) if ident == TRAVERSAL => {
-                traversal = meta.value()?.parse()?;
-                processed_attrs.push(TRAVERSAL);
+                Err(meta.error(
+                    "`traversal` has been renamed to `propagate`, use that instead. If you were writing `traversal = &'static ChildOf`, you can now just write `propagate`, which defaults to the `ChildOf` traversal."
+                ))
+            }
+            Some(ident) if ident == PROPAGATE => {
+                propagate = true;
+                if meta.input.peek(Token![=]) {
+                    traversal = Some(meta.value()?.parse()?);
+                }
+                processed_attrs.push(PROPAGATE);
+                Ok(())
+            }
+            Some(ident) if ident == TRIGGER => {
+                trigger = Some(meta.value()?.parse()?);
+                processed_attrs.push(TRIGGER);
                 Ok(())
             }
             Some(ident) => Err(meta.error(format!("unsupported attribute: {ident}"))),
@@ -69,18 +112,95 @@ pub fn derive_entity_event(input: TokenStream) -> TokenStream {
         }
     }
 
+    if trigger.is_some() && propagate {
+        return syn::Error::new(
+            ast.span(),
+            "Cannot define both #[entity_event(trigger)] and #[entity_event(propagate)]",
+        )
+        .into_compile_error()
+        .into();
+    }
+
+    let entity_field = match get_event_target_field(&ast) {
+        Ok(value) => value,
+        Err(err) => return err.into_compile_error().into(),
+    };
+
     let struct_name = &ast.ident;
     let (impl_generics, type_generics, where_clause) = &ast.generics.split_for_impl();
 
+    let trigger = if let Some(trigger) = trigger {
+        quote! {#trigger}
+    } else if propagate {
+        let traversal = traversal
+            .unwrap_or_else(|| parse_quote! { &'static #bevy_ecs_path::hierarchy::ChildOf});
+        quote! {#bevy_ecs_path::event::PropagateEntityTrigger<#auto_propagate, Self, #traversal>}
+    } else {
+        quote! {#bevy_ecs_path::event::EntityTrigger}
+    };
     TokenStream::from(quote! {
-        impl #impl_generics #bevy_ecs_path::event::Event for #struct_name #type_generics #where_clause {}
+        impl #impl_generics #bevy_ecs_path::event::Event for #struct_name #type_generics #where_clause {
+            type Trigger<'a> = #trigger;
+        }
+
         impl #impl_generics #bevy_ecs_path::event::EntityEvent for #struct_name #type_generics #where_clause {
-            type Traversal = #traversal;
-            const AUTO_PROPAGATE: bool = #auto_propagate;
+            fn event_target(&self) -> #bevy_ecs_path::entity::Entity {
+                self.#entity_field
+            }
+
+            fn event_target_mut(&mut self) -> &mut #bevy_ecs_path::entity::Entity {
+                &mut self.#entity_field
+            }
         }
+
     })
 }
 
+/// Returns the field with the `#[event_target]` attribute, the only field if unnamed,
+/// or the field with the name "entity".
+fn get_event_target_field(ast: &DeriveInput) -> Result<Member> {
+    let Data::Struct(DataStruct { fields, .. }) = &ast.data else {
+        return Err(syn::Error::new(
+            ast.span(),
+            "EntityEvent can only be derived for structs.",
+        ));
+    };
+    match fields {
+        Fields::Named(fields) => fields.named.iter().find_map(|field| {
+            if field.ident.as_ref().is_some_and(|i| i == "entity") || field
+                .attrs
+                .iter()
+                .any(|attr| attr.path().is_ident(EVENT_TARGET)) {
+                    Some(Member::Named(field.ident.clone()?))
+                } else {
+                    None
+                }
+        }).ok_or(syn::Error::new(
+            fields.span(),
+            "EntityEvent derive expected a field name 'entity' or a field annotated with #[event_target]."
+        )),
+        Fields::Unnamed(fields) if fields.unnamed.len() == 1 => Ok(Member::Unnamed(Index::from(0))),
+        Fields::Unnamed(fields) => fields.unnamed.iter().enumerate().find_map(|(index, field)| {
+                if field
+                    .attrs
+                    .iter()
+                    .any(|attr| attr.path().is_ident(EVENT_TARGET)) {
+                        Some(Member::Unnamed(Index::from(index)))
+                    } else {
+                        None
+                    }
+            })
+            .ok_or(syn::Error::new(
+                fields.span(),
+                "EntityEvent derive expected unnamed structs with one field or with a field annotated with #[event_target].",
+            )),
+        Fields::Unit => Err(syn::Error::new(
+            fields.span(),
+            "EntityEvent derive does not work on unit structs. Your type must have a field to store the `Entity` target, such as `Attack(Entity)` or `Attack { entity: Entity }`.",
+        )),
+    }
+}
+
 pub fn derive_buffered_event(input: TokenStream) -> TokenStream {
     let mut ast = parse_macro_input!(input as DeriveInput);
     let bevy_ecs_path: Path = crate::bevy_ecs_path();
@@ -417,6 +537,7 @@ pub const STORAGE: &str = "storage";
 pub const REQUIRE: &str = "require";
 pub const RELATIONSHIP: &str = "relationship";
 pub const RELATIONSHIP_TARGET: &str = "relationship_target";
+pub const EVENT_TARGET: &str = "event_target";
 
 pub const ON_ADD: &str = "on_add";
 pub const ON_INSERT: &str = "on_insert";
diff --git a/crates/bevy_ecs/macros/src/lib.rs b/crates/bevy_ecs/macros/src/lib.rs
index 964bc56adbbb2..3e8276532e129 100644
--- a/crates/bevy_ecs/macros/src/lib.rs
+++ b/crates/bevy_ecs/macros/src/lib.rs
@@ -548,7 +548,7 @@ pub(crate) fn bevy_ecs_path() -> syn::Path {
 }
 
 /// Implement the `Event` trait.
-#[proc_macro_derive(Event)]
+#[proc_macro_derive(Event, attributes(event))]
 pub fn derive_event(input: TokenStream) -> TokenStream {
     component::derive_event(input)
 }
@@ -558,13 +558,15 @@ pub fn derive_event(input: TokenStream) -> TokenStream {
 ///
 /// ```ignore
 /// #[derive(EntityEvent)]
-/// /// Traversal component
-/// #[entity_event(traversal = &'static ChildOf)]
+/// /// Enable propagation, which defaults to using the ChildOf component
+/// #[entity_event(propagate)]
+/// /// Enable propagation using the given Traversal implementation
+/// #[entity_event(propagate = &'static ChildOf)]
 /// /// Always propagate
 /// #[entity_event(auto_propagate)]
 /// struct MyEvent;
 /// ```
-#[proc_macro_derive(EntityEvent, attributes(entity_event))]
+#[proc_macro_derive(EntityEvent, attributes(entity_event, event_target))]
 pub fn derive_entity_event(input: TokenStream) -> TokenStream {
     component::derive_entity_event(input)
 }
diff --git a/crates/bevy_ecs/src/archetype.rs b/crates/bevy_ecs/src/archetype.rs
index bbb22b59b8f2d..c6fa3dc81dd53 100644
--- a/crates/bevy_ecs/src/archetype.rs
+++ b/crates/bevy_ecs/src/archetype.rs
@@ -143,10 +143,10 @@ pub(crate) struct ArchetypeAfterBundleInsert {
     /// The initial values are determined based on the provided constructor, falling back to the `Default` trait if none is given.
     pub required_components: Box<[RequiredComponentConstructor]>,
     /// The components added by this bundle. This includes any Required Components that are inserted when adding this bundle.
-    added: Box<[ComponentId]>,
+    pub(crate) added: Box<[ComponentId]>,
     /// The components that were explicitly contributed by this bundle, but already existed in the archetype. This _does not_ include any
     /// Required Components.
-    existing: Box<[ComponentId]>,
+    pub(crate) existing: Box<[ComponentId]>,
 }
 
 impl ArchetypeAfterBundleInsert {
@@ -524,14 +524,22 @@ impl Archetype {
             .map(|(id, _)| *id)
     }
 
-    /// Gets an iterator of all of the components in the archetype.
+    /// Returns a slice of all of the components in the archetype.
     ///
     /// All of the IDs are unique.
     #[inline]
-    pub fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
+    pub fn components(&self) -> &[ComponentId] {
         self.components.indices()
     }
 
+    /// Gets an iterator of all of the components in the archetype.
+    ///
+    /// All of the IDs are unique.
+    #[inline]
+    pub fn iter_components(&self) -> impl Iterator<Item = ComponentId> + Clone {
+        self.components.indices().iter().copied()
+    }
+
     /// Returns the total number of components in the archetype
     #[inline]
     pub fn component_count(&self) -> usize {
diff --git a/crates/bevy_ecs/src/bundle/insert.rs b/crates/bevy_ecs/src/bundle/insert.rs
index 83b28bbf901b5..86a356291ce55 100644
--- a/crates/bevy_ecs/src/bundle/insert.rs
+++ b/crates/bevy_ecs/src/bundle/insert.rs
@@ -11,7 +11,8 @@ use crate::{
     change_detection::MaybeLocation,
     component::{Components, StorageType, Tick},
     entity::{Entities, Entity, EntityLocation},
-    lifecycle::{ADD, INSERT, REPLACE},
+    event::EntityComponentsTrigger,
+    lifecycle::{Add, Insert, Replace, ADD, INSERT, REPLACE},
     observer::Observers,
     query::DebugCheckedUnwrap as _,
     relationship::RelationshipHookMode,
@@ -161,10 +162,13 @@ impl<'w> BundleInserter<'w> {
 
             if insert_mode == InsertMode::Replace {
                 if archetype.has_replace_observer() {
-                    deferred_world.trigger_observers(
+                    // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+                    deferred_world.trigger_raw(
                         REPLACE,
-                        Some(entity),
-                        archetype_after_insert.iter_existing(),
+                        &mut Replace { entity },
+                        &mut EntityComponentsTrigger {
+                            components: &archetype_after_insert.existing,
+                        },
                         caller,
                     );
                 }
@@ -346,10 +350,13 @@ impl<'w> BundleInserter<'w> {
                 caller,
             );
             if new_archetype.has_add_observer() {
-                deferred_world.trigger_observers(
+                // SAFETY: the ADD event_key corresponds to the Add event's type
+                deferred_world.trigger_raw(
                     ADD,
-                    Some(entity),
-                    archetype_after_insert.iter_added(),
+                    &mut Add { entity },
+                    &mut EntityComponentsTrigger {
+                        components: &archetype_after_insert.added,
+                    },
                     caller,
                 );
             }
@@ -364,10 +371,17 @@ impl<'w> BundleInserter<'w> {
                         relationship_hook_mode,
                     );
                     if new_archetype.has_insert_observer() {
-                        deferred_world.trigger_observers(
+                        // SAFETY: the INSERT event_key corresponds to the Insert event's type
+                        deferred_world.trigger_raw(
                             INSERT,
-                            Some(entity),
-                            archetype_after_insert.iter_inserted(),
+                            &mut Insert { entity },
+                            // PERF: this is not a regression from what we were doing before, but ideally we don't
+                            // need to collect here
+                            &mut EntityComponentsTrigger {
+                                components: &archetype_after_insert
+                                    .iter_inserted()
+                                    .collect::<Vec<_>>(),
+                            },
                             caller,
                         );
                     }
@@ -383,10 +397,13 @@ impl<'w> BundleInserter<'w> {
                         relationship_hook_mode,
                     );
                     if new_archetype.has_insert_observer() {
-                        deferred_world.trigger_observers(
+                        // SAFETY: the INSERT event_key corresponds to the Insert event's type
+                        deferred_world.trigger_raw(
                             INSERT,
-                            Some(entity),
-                            archetype_after_insert.iter_added(),
+                            &mut Insert { entity },
+                            &mut EntityComponentsTrigger {
+                                components: &archetype_after_insert.added,
+                            },
                             caller,
                         );
                     }
diff --git a/crates/bevy_ecs/src/bundle/remove.rs b/crates/bevy_ecs/src/bundle/remove.rs
index 20d8d3de46f9b..f40c82c7f7d67 100644
--- a/crates/bevy_ecs/src/bundle/remove.rs
+++ b/crates/bevy_ecs/src/bundle/remove.rs
@@ -8,7 +8,8 @@ use crate::{
     change_detection::MaybeLocation,
     component::{ComponentId, Components, StorageType},
     entity::{Entity, EntityLocation},
-    lifecycle::{REMOVE, REPLACE},
+    event::EntityComponentsTrigger,
+    lifecycle::{Remove, Replace, REMOVE, REPLACE},
     observer::Observers,
     relationship::RelationshipHookMode,
     storage::{SparseSets, Storages, Table},
@@ -147,10 +148,14 @@ impl<'w> BundleRemover<'w> {
                     .filter(|component_id| self.old_archetype.as_ref().contains(*component_id))
             };
             if self.old_archetype.as_ref().has_replace_observer() {
-                deferred_world.trigger_observers(
+                let components = bundle_components_in_archetype().collect::<Vec<_>>();
+                // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+                deferred_world.trigger_raw(
                     REPLACE,
-                    Some(entity),
-                    bundle_components_in_archetype(),
+                    &mut Replace { entity },
+                    &mut EntityComponentsTrigger {
+                        components: &components,
+                    },
                     caller,
                 );
             }
@@ -162,10 +167,14 @@ impl<'w> BundleRemover<'w> {
                 self.relationship_hook_mode,
             );
             if self.old_archetype.as_ref().has_remove_observer() {
-                deferred_world.trigger_observers(
+                let components = bundle_components_in_archetype().collect::<Vec<_>>();
+                // SAFETY: the REMOVE event_key corresponds to the Remove event's type
+                deferred_world.trigger_raw(
                     REMOVE,
-                    Some(entity),
-                    bundle_components_in_archetype(),
+                    &mut Remove { entity },
+                    &mut EntityComponentsTrigger {
+                        components: &components,
+                    },
                     caller,
                 );
             }
diff --git a/crates/bevy_ecs/src/bundle/spawner.rs b/crates/bevy_ecs/src/bundle/spawner.rs
index 3df3fb0229bb3..8a644429f342d 100644
--- a/crates/bevy_ecs/src/bundle/spawner.rs
+++ b/crates/bevy_ecs/src/bundle/spawner.rs
@@ -8,7 +8,8 @@ use crate::{
     change_detection::MaybeLocation,
     component::Tick,
     entity::{Entities, Entity, EntityLocation},
-    lifecycle::{ADD, INSERT},
+    event::EntityComponentsTrigger,
+    lifecycle::{Add, Insert, ADD, INSERT},
     relationship::RelationshipHookMode,
     storage::Table,
     world::{unsafe_world_cell::UnsafeWorldCell, World},
@@ -131,10 +132,13 @@ impl<'w> BundleSpawner<'w> {
                 caller,
             );
             if archetype.has_add_observer() {
-                deferred_world.trigger_observers(
+                // SAFETY: the ADD event_key corresponds to the Add event's type
+                deferred_world.trigger_raw(
                     ADD,
-                    Some(entity),
-                    bundle_info.iter_contributed_components(),
+                    &mut Add { entity },
+                    &mut EntityComponentsTrigger {
+                        components: bundle_info.contributed_components(),
+                    },
                     caller,
                 );
             }
@@ -146,10 +150,13 @@ impl<'w> BundleSpawner<'w> {
                 RelationshipHookMode::Run,
             );
             if archetype.has_insert_observer() {
-                deferred_world.trigger_observers(
+                // SAFETY: the INSERT event_key corresponds to the Insert event's type
+                deferred_world.trigger_raw(
                     INSERT,
-                    Some(entity),
-                    bundle_info.iter_contributed_components(),
+                    &mut Insert { entity },
+                    &mut EntityComponentsTrigger {
+                        components: bundle_info.contributed_components(),
+                    },
                     caller,
                 );
             }
diff --git a/crates/bevy_ecs/src/component/tick.rs b/crates/bevy_ecs/src/component/tick.rs
index 09d82a13d4eb2..b02259637f4fa 100644
--- a/crates/bevy_ecs/src/component/tick.rs
+++ b/crates/bevy_ecs/src/component/tick.rs
@@ -86,7 +86,7 @@ impl Tick {
     }
 }
 
-/// An observer [`Event`] that can be used to maintain [`Tick`]s in custom data structures, enabling to make
+/// An [`Event`] that can be used to maintain [`Tick`]s in custom data structures, enabling to make
 /// use of bevy's periodic checks that clamps ticks to a certain range, preventing overflows and thus
 /// keeping methods like [`Tick::is_newer_than`] reliably return `false` for ticks that got too old.
 ///
diff --git a/crates/bevy_ecs/src/entity/clone_entities.rs b/crates/bevy_ecs/src/entity/clone_entities.rs
index 2f7000357f08f..4c110d0057c9a 100644
--- a/crates/bevy_ecs/src/entity/clone_entities.rs
+++ b/crates/bevy_ecs/src/entity/clone_entities.rs
@@ -1116,14 +1116,14 @@ impl CloneByFilter for OptOut {
     ) {
         match self.insert_mode {
             InsertMode::Replace => {
-                for component in source_archetype.components() {
+                for component in source_archetype.iter_components() {
                     if !self.deny.contains(&component) {
                         clone_component(component);
                     }
                 }
             }
             InsertMode::Keep => {
-                for component in source_archetype.components() {
+                for component in source_archetype.iter_components() {
                     if !target_archetype.contains(component) && !self.deny.contains(&component) {
                         clone_component(component);
                     }
diff --git a/crates/bevy_ecs/src/event/base.rs b/crates/bevy_ecs/src/event/base.rs
deleted file mode 100644
index 2ba0de493eb7a..0000000000000
--- a/crates/bevy_ecs/src/event/base.rs
+++ /dev/null
@@ -1,442 +0,0 @@
-use crate::change_detection::MaybeLocation;
-use crate::component::ComponentId;
-use crate::world::World;
-use crate::{component::Component, traversal::Traversal};
-#[cfg(feature = "bevy_reflect")]
-use bevy_reflect::Reflect;
-use core::{
-    cmp::Ordering,
-    fmt,
-    hash::{Hash, Hasher},
-    marker::PhantomData,
-};
-
-/// Something that "happens" and can be processed by app logic.
-///
-/// Events can be triggered on a [`World`] using a method like [`trigger`](World::trigger),
-/// causing any global [`Observer`] watching that event to run. This allows for push-based
-/// event handling where observers are immediately notified of events as they happen.
-///
-/// Additional event handling behavior can be enabled by implementing the [`EntityEvent`]
-/// and [`BufferedEvent`] traits:
-///
-/// - [`EntityEvent`]s support targeting specific entities, triggering any observers watching those targets.
-///   They are useful for entity-specific event handlers and can even be propagated from one entity to another.
-/// - [`BufferedEvent`]s support a pull-based event handling system where events are written using an [`EventWriter`]
-///   and read later using an [`EventReader`]. This is an alternative to observers that allows efficient batch processing
-///   of events at fixed points in a schedule.
-///
-/// Events must be thread-safe.
-///
-/// # Usage
-///
-/// The [`Event`] trait can be derived:
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// #[derive(Event)]
-/// struct Speak {
-///     message: String,
-/// }
-/// ```
-///
-/// An [`Observer`] can then be added to listen for this event type:
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// # #[derive(Event)]
-/// # struct Speak {
-/// #     message: String,
-/// # }
-/// #
-/// # let mut world = World::new();
-/// #
-/// world.add_observer(|event: On<Speak>| {
-///     println!("{}", event.message);
-/// });
-/// ```
-///
-/// The event can be triggered on the [`World`] using the [`trigger`](World::trigger) method:
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// # #[derive(Event)]
-/// # struct Speak {
-/// #     message: String,
-/// # }
-/// #
-/// # let mut world = World::new();
-/// #
-/// # world.add_observer(|event: On<Speak>| {
-/// #     println!("{}", event.message);
-/// # });
-/// #
-/// # world.flush();
-/// #
-/// world.trigger(Speak {
-///     message: "Hello!".to_string(),
-/// });
-/// ```
-///
-/// For events that additionally need entity targeting or buffering, consider also deriving
-/// [`EntityEvent`] or [`BufferedEvent`], respectively.
-///
-/// [`World`]: crate::world::World
-/// [`Observer`]: crate::observer::Observer
-/// [`EventReader`]: super::EventReader
-/// [`EventWriter`]: super::EventWriter
-#[diagnostic::on_unimplemented(
-    message = "`{Self}` is not an `Event`",
-    label = "invalid `Event`",
-    note = "consider annotating `{Self}` with `#[derive(Event)]`"
-)]
-pub trait Event: Send + Sync + 'static {
-    /// Generates the [`EventKey`] for this event type.
-    ///
-    /// If this type has already been registered,
-    /// this will return the existing [`EventKey`].
-    ///
-    /// This is used by various dynamically typed observer APIs,
-    /// such as [`World::trigger_targets_dynamic`].
-    ///
-    /// # Warning
-    ///
-    /// This method should not be overridden by implementers,
-    /// and should always correspond to the implementation of [`event_key`](Event::event_key).
-    fn register_event_key(world: &mut World) -> EventKey {
-        EventKey(world.register_component::<EventWrapperComponent<Self>>())
-    }
-
-    /// Fetches the [`EventKey`] for this event type,
-    /// if it has already been generated.
-    ///
-    /// This is used by various dynamically typed observer APIs,
-    /// such as [`World::trigger_targets_dynamic`].
-    ///
-    /// # Warning
-    ///
-    /// This method should not be overridden by implementers,
-    /// and should always correspond to the implementation of
-    /// [`register_event_key`](Event::register_event_key).
-    fn event_key(world: &World) -> Option<EventKey> {
-        world
-            .component_id::<EventWrapperComponent<Self>>()
-            .map(EventKey)
-    }
-}
-
-/// An [`Event`] that can be targeted at specific entities.
-///
-/// Entity events can be triggered on a [`World`] with specific entity targets using a method
-/// like [`trigger_targets`](World::trigger_targets), causing any [`Observer`] watching the event
-/// for those entities to run.
-///
-/// Unlike basic [`Event`]s, entity events can optionally be propagated from one entity target to another
-/// based on the [`EntityEvent::Traversal`] type associated with the event. This enables use cases
-/// such as bubbling events to parent entities for UI purposes.
-///
-/// Entity events must be thread-safe.
-///
-/// # Usage
-///
-/// The [`EntityEvent`] trait can be derived. The `event` attribute can be used to further configure
-/// the propagation behavior: adding `auto_propagate` sets [`EntityEvent::AUTO_PROPAGATE`] to `true`,
-/// while adding `traversal = X` sets [`EntityEvent::Traversal`] to be of type `X`.
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// // When the `Damage` event is triggered on an entity, bubble the event up to ancestors.
-/// #[derive(EntityEvent)]
-/// #[entity_event(traversal = &'static ChildOf, auto_propagate)]
-/// struct Damage {
-///     amount: f32,
-/// }
-/// ```
-///
-/// An [`Observer`] can then be added to listen for this event type for the desired entity:
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// # #[derive(EntityEvent)]
-/// # #[entity_event(traversal = &'static ChildOf, auto_propagate)]
-/// # struct Damage {
-/// #     amount: f32,
-/// # }
-/// #
-/// # #[derive(Component)]
-/// # struct Health(f32);
-/// #
-/// # #[derive(Component)]
-/// # struct Enemy;
-/// #
-/// # #[derive(Component)]
-/// # struct ArmorPiece;
-/// #
-/// # let mut world = World::new();
-/// #
-/// // Spawn an enemy entity.
-/// let enemy = world.spawn((Enemy, Health(100.0))).id();
-///
-/// // Spawn some armor as a child of the enemy entity.
-/// // When the armor takes damage, it will bubble the event up to the enemy,
-/// // which can then handle the event with its own observer.
-/// let armor_piece = world
-///     .spawn((ArmorPiece, Health(25.0), ChildOf(enemy)))
-///     .observe(|event: On<Damage>, mut query: Query<&mut Health>| {
-///         // Note: `On::entity` only exists because this is an `EntityEvent`.
-///         let mut health = query.get_mut(event.entity()).unwrap();
-///         health.0 -= event.amount;
-///     })
-///     .id();
-/// ```
-///
-/// The event can be triggered on the [`World`] using the [`trigger_targets`](World::trigger_targets) method,
-/// providing the desired entity target(s):
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// # #[derive(EntityEvent)]
-/// # #[entity_event(traversal = &'static ChildOf, auto_propagate)]
-/// # struct Damage {
-/// #     amount: f32,
-/// # }
-/// #
-/// # #[derive(Component)]
-/// # struct Health(f32);
-/// #
-/// # #[derive(Component)]
-/// # struct Enemy;
-/// #
-/// # #[derive(Component)]
-/// # struct ArmorPiece;
-/// #
-/// # let mut world = World::new();
-/// #
-/// # let enemy = world.spawn((Enemy, Health(100.0))).id();
-/// # let armor_piece = world
-/// #     .spawn((ArmorPiece, Health(25.0), ChildOf(enemy)))
-/// #     .observe(|event: On<Damage>, mut query: Query<&mut Health>| {
-/// #         // Note: `On::entity` only exists because this is an `EntityEvent`.
-/// #         let mut health = query.get_mut(event.entity()).unwrap();
-/// #         health.0 -= event.amount;
-/// #     })
-/// #     .id();
-/// #
-/// # world.flush();
-/// #
-/// world.trigger_targets(Damage { amount: 10.0 }, armor_piece);
-/// ```
-///
-/// [`World`]: crate::world::World
-/// [`TriggerTargets`]: crate::observer::TriggerTargets
-/// [`Observer`]: crate::observer::Observer
-/// [`Events<E>`]: super::Events
-/// [`EventReader`]: super::EventReader
-/// [`EventWriter`]: super::EventWriter
-#[diagnostic::on_unimplemented(
-    message = "`{Self}` is not an `EntityEvent`",
-    label = "invalid `EntityEvent`",
-    note = "consider annotating `{Self}` with `#[derive(EntityEvent)]`"
-)]
-pub trait EntityEvent: Event {
-    /// The component that describes which [`Entity`] to propagate this event to next, when [propagation] is enabled.
-    ///
-    /// [`Entity`]: crate::entity::Entity
-    /// [propagation]: crate::observer::On::propagate
-    type Traversal: Traversal<Self>;
-
-    /// When true, this event will always attempt to propagate when [triggered], without requiring a call
-    /// to [`On::propagate`].
-    ///
-    /// [triggered]: crate::system::Commands::trigger_targets
-    /// [`On::propagate`]: crate::observer::On::propagate
-    const AUTO_PROPAGATE: bool = false;
-}
-
-/// A buffered event for pull-based event handling.
-///
-/// Buffered events can be written with [`EventWriter`] and read using the [`EventReader`] system parameter.
-/// These events are stored in the [`Events<E>`] resource, and require periodically polling the world for new events,
-/// typically in a system that runs as part of a schedule.
-///
-/// While the polling imposes a small overhead, buffered events are useful for efficiently batch processing
-/// a large number of events at once. This can make them more efficient than [`Event`]s used by [`Observer`]s
-/// for events that happen at a high frequency or in large quantities.
-///
-/// Unlike [`Event`]s triggered for observers, buffered events are evaluated at fixed points in the schedule
-/// rather than immediately when they are sent. This allows for more predictable scheduling and deferring
-/// event processing to a later point in time.
-///
-/// Buffered events do *not* trigger observers automatically when they are written via an [`EventWriter`].
-/// However, they can still also be triggered on a [`World`] in case you want both buffered and immediate
-/// event handling for the same event.
-///
-/// Buffered events must be thread-safe.
-///
-/// # Usage
-///
-/// The [`BufferedEvent`] trait can be derived:
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// #[derive(BufferedEvent)]
-/// struct Message(String);
-/// ```
-///
-/// The event can then be written to the event buffer using an [`EventWriter`]:
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// # #[derive(BufferedEvent)]
-/// # struct Message(String);
-/// #
-/// fn write_hello(mut writer: EventWriter<Message>) {
-///     writer.write(Message("Hello!".to_string()));
-/// }
-/// ```
-///
-/// Buffered events can be efficiently read using an [`EventReader`]:
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// #
-/// # #[derive(BufferedEvent)]
-/// # struct Message(String);
-/// #
-/// fn read_messages(mut reader: EventReader<Message>) {
-///     // Process all buffered events of type `Message`.
-///     for Message(message) in reader.read() {
-///         println!("{message}");
-///     }
-/// }
-/// ```
-///
-/// [`World`]: crate::world::World
-/// [`Observer`]: crate::observer::Observer
-/// [`Events<E>`]: super::Events
-/// [`EventReader`]: super::EventReader
-/// [`EventWriter`]: super::EventWriter
-#[diagnostic::on_unimplemented(
-    message = "`{Self}` is not an `BufferedEvent`",
-    label = "invalid `BufferedEvent`",
-    note = "consider annotating `{Self}` with `#[derive(BufferedEvent)]`"
-)]
-pub trait BufferedEvent: Send + Sync + 'static {}
-
-/// An internal type that implements [`Component`] for a given [`Event`] type.
-///
-/// This exists so we can easily get access to a unique [`ComponentId`] for each [`Event`] type,
-/// without requiring that [`Event`] types implement [`Component`] directly.
-/// [`ComponentId`] is used internally as a unique identifier for events because they are:
-///
-/// - Unique to each event type.
-/// - Can be quickly generated and looked up.
-/// - Are compatible with dynamic event types, which aren't backed by a Rust type.
-///
-/// This type is an implementation detail and should never be made public.
-// TODO: refactor events to store their metadata on distinct entities, rather than using `ComponentId`
-#[derive(Component)]
-struct EventWrapperComponent<E: Event + ?Sized>(PhantomData<E>);
-
-/// An `EventId` uniquely identifies an event stored in a specific [`World`].
-///
-/// An `EventId` can among other things be used to trace the flow of an event from the point it was
-/// sent to the point it was processed. `EventId`s increase monotonically by send order.
-///
-/// [`World`]: crate::world::World
-#[cfg_attr(
-    feature = "bevy_reflect",
-    derive(Reflect),
-    reflect(Clone, Debug, PartialEq, Hash)
-)]
-pub struct EventId<E: BufferedEvent> {
-    /// Uniquely identifies the event associated with this ID.
-    // This value corresponds to the order in which each event was added to the world.
-    pub id: usize,
-    /// The source code location that triggered this event.
-    pub caller: MaybeLocation,
-    #[cfg_attr(feature = "bevy_reflect", reflect(ignore, clone))]
-    pub(super) _marker: PhantomData<E>,
-}
-
-impl<E: BufferedEvent> Copy for EventId<E> {}
-
-impl<E: BufferedEvent> Clone for EventId<E> {
-    fn clone(&self) -> Self {
-        *self
-    }
-}
-
-impl<E: BufferedEvent> fmt::Display for EventId<E> {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        <Self as fmt::Debug>::fmt(self, f)
-    }
-}
-
-impl<E: BufferedEvent> fmt::Debug for EventId<E> {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        write!(
-            f,
-            "event<{}>#{}",
-            core::any::type_name::<E>().split("::").last().unwrap(),
-            self.id,
-        )
-    }
-}
-
-impl<E: BufferedEvent> PartialEq for EventId<E> {
-    fn eq(&self, other: &Self) -> bool {
-        self.id == other.id
-    }
-}
-
-impl<E: BufferedEvent> Eq for EventId<E> {}
-
-impl<E: BufferedEvent> PartialOrd for EventId<E> {
-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        Some(self.cmp(other))
-    }
-}
-
-impl<E: BufferedEvent> Ord for EventId<E> {
-    fn cmp(&self, other: &Self) -> Ordering {
-        self.id.cmp(&other.id)
-    }
-}
-
-impl<E: BufferedEvent> Hash for EventId<E> {
-    fn hash<H: Hasher>(&self, state: &mut H) {
-        Hash::hash(&self.id, state);
-    }
-}
-
-#[derive(Debug)]
-#[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
-pub(crate) struct EventInstance<E: BufferedEvent> {
-    pub event_id: EventId<E>,
-    pub event: E,
-}
-
-/// A unique identifier for an [`Event`], used by [observers].
-///
-/// You can look up the key for your event by calling the [`Event::event_key`] method.
-///
-/// [observers]: crate::observer
-#[derive(Debug, Copy, Clone, Hash, Ord, PartialOrd, Eq, PartialEq)]
-pub struct EventKey(pub(crate) ComponentId);
-
-impl EventKey {
-    /// Returns the internal [`ComponentId`].
-    #[inline]
-    pub(crate) fn component_id(&self) -> ComponentId {
-        self.0
-    }
-}
diff --git a/crates/bevy_ecs/src/event/collections.rs b/crates/bevy_ecs/src/event/buffered_event/collections.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/collections.rs
rename to crates/bevy_ecs/src/event/buffered_event/collections.rs
diff --git a/crates/bevy_ecs/src/event/event_cursor.rs b/crates/bevy_ecs/src/event/buffered_event/event_cursor.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/event_cursor.rs
rename to crates/bevy_ecs/src/event/buffered_event/event_cursor.rs
diff --git a/crates/bevy_ecs/src/event/iterators.rs b/crates/bevy_ecs/src/event/buffered_event/iterators.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/iterators.rs
rename to crates/bevy_ecs/src/event/buffered_event/iterators.rs
diff --git a/crates/bevy_ecs/src/event/buffered_event/mod.rs b/crates/bevy_ecs/src/event/buffered_event/mod.rs
new file mode 100644
index 0000000000000..69680af13c6cb
--- /dev/null
+++ b/crates/bevy_ecs/src/event/buffered_event/mod.rs
@@ -0,0 +1,180 @@
+mod collections;
+mod event_cursor;
+mod iterators;
+mod mut_iterators;
+mod mutator;
+mod reader;
+mod registry;
+mod update;
+mod writer;
+
+pub use collections::*;
+pub use event_cursor::*;
+pub use iterators::*;
+pub use mut_iterators::*;
+pub use mutator::*;
+pub use reader::*;
+pub use registry::*;
+pub use update::*;
+pub use writer::*;
+
+use crate::change_detection::MaybeLocation;
+#[cfg(feature = "bevy_reflect")]
+use bevy_reflect::Reflect;
+use core::{
+    cmp::Ordering,
+    fmt,
+    hash::{Hash, Hasher},
+    marker::PhantomData,
+};
+
+/// A buffered event for pull-based event handling.
+///
+/// Buffered events can be written with [`EventWriter`] and read using the [`EventReader`] system parameter.
+/// These events are stored in the [`Events<E>`] resource, and require periodically polling the world for new events,
+/// typically in a system that runs as part of a schedule.
+///
+/// While the polling imposes a small overhead, buffered events are useful for efficiently batch processing
+/// a large number of events at once. This can make them more efficient than [`Event`]s used by [`Observer`]s
+/// for events that happen at a high frequency or in large quantities.
+///
+/// Unlike [`Event`]s triggered for observers, buffered events are evaluated at fixed points in the schedule
+/// rather than immediately when they are sent. This allows for more predictable scheduling and deferring
+/// event processing to a later point in time.
+///
+/// Buffered events do *not* trigger observers automatically when they are written via an [`EventWriter`].
+/// However, they can still also be triggered on a [`World`] in case you want both buffered and immediate
+/// event handling for the same event.
+///
+/// Buffered events must be thread-safe.
+///
+/// # Usage
+///
+/// The [`BufferedEvent`] trait can be derived:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #
+/// #[derive(BufferedEvent)]
+/// struct Message(String);
+/// ```
+///
+/// The event can then be written to the event buffer using an [`EventWriter`]:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #
+/// # #[derive(BufferedEvent)]
+/// # struct Message(String);
+/// #
+/// fn write_hello(mut writer: EventWriter<Message>) {
+///     writer.write(Message("Hello!".to_string()));
+/// }
+/// ```
+///
+/// Buffered events can be efficiently read using an [`EventReader`]:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #
+/// # #[derive(BufferedEvent)]
+/// # struct Message(String);
+/// #
+/// fn read_messages(mut reader: EventReader<Message>) {
+///     // Process all buffered events of type `Message`.
+///     for Message(message) in reader.read() {
+///         println!("{message}");
+///     }
+/// }
+/// ```
+/// [`Event`]: crate::event::Event
+/// [`World`]: crate::world::World
+/// [`Observer`]: crate::observer::Observer
+/// [`Events<E>`]: super::Events
+/// [`EventReader`]: super::EventReader
+/// [`EventWriter`]: super::EventWriter
+#[diagnostic::on_unimplemented(
+    message = "`{Self}` is not an `BufferedEvent`",
+    label = "invalid `BufferedEvent`",
+    note = "consider annotating `{Self}` with `#[derive(BufferedEvent)]`"
+)]
+pub trait BufferedEvent: Send + Sync + 'static {}
+
+#[derive(Debug)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
+pub(crate) struct EventInstance<E: BufferedEvent> {
+    pub event_id: EventId<E>,
+    pub event: E,
+}
+
+/// An `EventId` uniquely identifies an event stored in a specific [`World`].
+///
+/// An `EventId` can among other things be used to trace the flow of an event from the point it was
+/// sent to the point it was processed. `EventId`s increase monotonically by send order.
+///
+/// [`World`]: crate::world::World
+#[cfg_attr(
+    feature = "bevy_reflect",
+    derive(Reflect),
+    reflect(Clone, Debug, PartialEq, Hash)
+)]
+pub struct EventId<E: BufferedEvent> {
+    /// Uniquely identifies the event associated with this ID.
+    // This value corresponds to the order in which each event was added to the world.
+    pub id: usize,
+    /// The source code location that triggered this event.
+    pub caller: MaybeLocation,
+    #[cfg_attr(feature = "bevy_reflect", reflect(ignore, clone))]
+    pub(super) _marker: PhantomData<E>,
+}
+
+impl<E: BufferedEvent> Copy for EventId<E> {}
+
+impl<E: BufferedEvent> Clone for EventId<E> {
+    fn clone(&self) -> Self {
+        *self
+    }
+}
+
+impl<E: BufferedEvent> fmt::Display for EventId<E> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        <Self as fmt::Debug>::fmt(self, f)
+    }
+}
+
+impl<E: BufferedEvent> fmt::Debug for EventId<E> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        write!(
+            f,
+            "event<{}>#{}",
+            core::any::type_name::<E>().split("::").last().unwrap(),
+            self.id,
+        )
+    }
+}
+
+impl<E: BufferedEvent> PartialEq for EventId<E> {
+    fn eq(&self, other: &Self) -> bool {
+        self.id == other.id
+    }
+}
+
+impl<E: BufferedEvent> Eq for EventId<E> {}
+
+impl<E: BufferedEvent> PartialOrd for EventId<E> {
+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
+        Some(self.cmp(other))
+    }
+}
+
+impl<E: BufferedEvent> Ord for EventId<E> {
+    fn cmp(&self, other: &Self) -> Ordering {
+        self.id.cmp(&other.id)
+    }
+}
+
+impl<E: BufferedEvent> Hash for EventId<E> {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        Hash::hash(&self.id, state);
+    }
+}
diff --git a/crates/bevy_ecs/src/event/mut_iterators.rs b/crates/bevy_ecs/src/event/buffered_event/mut_iterators.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/mut_iterators.rs
rename to crates/bevy_ecs/src/event/buffered_event/mut_iterators.rs
diff --git a/crates/bevy_ecs/src/event/mutator.rs b/crates/bevy_ecs/src/event/buffered_event/mutator.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/mutator.rs
rename to crates/bevy_ecs/src/event/buffered_event/mutator.rs
diff --git a/crates/bevy_ecs/src/event/reader.rs b/crates/bevy_ecs/src/event/buffered_event/reader.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/reader.rs
rename to crates/bevy_ecs/src/event/buffered_event/reader.rs
diff --git a/crates/bevy_ecs/src/event/registry.rs b/crates/bevy_ecs/src/event/buffered_event/registry.rs
similarity index 96%
rename from crates/bevy_ecs/src/event/registry.rs
rename to crates/bevy_ecs/src/event/buffered_event/registry.rs
index 9fc5b21d5b669..23ddaba779a74 100644
--- a/crates/bevy_ecs/src/event/registry.rs
+++ b/crates/bevy_ecs/src/event/buffered_event/registry.rs
@@ -17,13 +17,13 @@ struct RegisteredEvent {
     update: unsafe fn(MutUntyped),
 }
 
-/// A registry of all of the [`Events`] in the [`World`], used by [`event_update_system`](crate::event::update::event_update_system)
+/// A registry of all of the [`Events`] in the [`World`], used by [`event_update_system`](crate::event::event_update_system)
 /// to update all of the events.
 #[derive(Resource, Default)]
 pub struct EventRegistry {
     /// Should the events be updated?
     ///
-    /// This field is generally automatically updated by the [`signal_event_update_system`](crate::event::update::signal_event_update_system).
+    /// This field is generally automatically updated by the [`signal_event_update_system`](crate::event::signal_event_update_system).
     pub should_update: ShouldUpdateEvents,
     event_updates: Vec<RegisteredEvent>,
 }
diff --git a/crates/bevy_ecs/src/event/update.rs b/crates/bevy_ecs/src/event/buffered_event/update.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/update.rs
rename to crates/bevy_ecs/src/event/buffered_event/update.rs
diff --git a/crates/bevy_ecs/src/event/writer.rs b/crates/bevy_ecs/src/event/buffered_event/writer.rs
similarity index 100%
rename from crates/bevy_ecs/src/event/writer.rs
rename to crates/bevy_ecs/src/event/buffered_event/writer.rs
diff --git a/crates/bevy_ecs/src/event/mod.rs b/crates/bevy_ecs/src/event/mod.rs
index 020b258557fd4..9dbb6554ce0f8 100644
--- a/crates/bevy_ecs/src/event/mod.rs
+++ b/crates/bevy_ecs/src/event/mod.rs
@@ -1,39 +1,351 @@
 //! Event handling types.
-mod base;
-mod collections;
-mod event_cursor;
-mod iterators;
-mod mut_iterators;
-mod mutator;
-mod reader;
-mod registry;
-mod update;
-mod writer;
-
-pub(crate) use base::EventInstance;
-pub use base::{BufferedEvent, EntityEvent, Event, EventId, EventKey};
+mod buffered_event;
+mod trigger;
+
 pub use bevy_ecs_macros::{BufferedEvent, EntityEvent, Event};
-#[expect(deprecated, reason = "`SendBatchIds` was renamed to `WriteBatchIds`.")]
-pub use collections::{Events, SendBatchIds, WriteBatchIds};
-pub use event_cursor::EventCursor;
-#[cfg(feature = "multi_threaded")]
-pub use iterators::EventParIter;
-pub use iterators::{EventIterator, EventIteratorWithId};
-#[cfg(feature = "multi_threaded")]
-pub use mut_iterators::EventMutParIter;
-pub use mut_iterators::{EventMutIterator, EventMutIteratorWithId};
-pub use mutator::EventMutator;
-pub use reader::EventReader;
-pub use registry::{EventRegistry, ShouldUpdateEvents};
-#[expect(
-    deprecated,
-    reason = "`EventUpdates` was renamed to `EventUpdateSystems`."
-)]
-pub use update::{
-    event_update_condition, event_update_system, signal_event_update_system, EventUpdateSystems,
-    EventUpdates,
+pub use buffered_event::*;
+pub use trigger::*;
+
+use crate::{
+    component::{Component, ComponentId},
+    entity::Entity,
+    world::World,
 };
-pub use writer::EventWriter;
+use core::marker::PhantomData;
+
+/// An [`Event`] is something that "happens" at a given moment.
+///
+/// To make an [`Event`] "happen", you "trigger" it on a [`World`] using [`World::trigger`] or via a [`Command`](crate::system::Command)
+/// using [`Commands::trigger`](crate::system::Commands::trigger). This causes any [`Observer`](crate::observer::Observer) watching for that
+/// [`Event`] to run _immediately_, as part of the [`World::trigger`] call.
+///
+/// First, we create an [`Event`] type, typically by deriving the trait.
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #
+/// #[derive(Event)]
+/// struct Speak {
+///     message: String,
+/// }
+/// ```
+///
+/// Then, we add an [`Observer`](crate::observer::Observer) to watch for this event type:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #
+/// # #[derive(Event)]
+/// # struct Speak {
+/// #     message: String,
+/// # }
+/// #
+/// # let mut world = World::new();
+/// #
+/// world.add_observer(|speak: On<Speak>| {
+///     println!("{}", speak.message);
+/// });
+/// ```
+///
+/// Finally, we trigger the event by calling [`World::trigger`](World::trigger):
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #
+/// # #[derive(Event)]
+/// # struct Speak {
+/// #     message: String,
+/// # }
+/// #
+/// # let mut world = World::new();
+/// #
+/// # world.add_observer(|speak: On<Speak>| {
+/// #     println!("{}", speak.message);
+/// # });
+/// #
+/// # world.flush();
+/// #
+/// world.trigger(Speak {
+///     message: "Hello!".to_string(),
+/// });
+/// ```
+///
+/// # Triggers
+///
+/// Every [`Event`] has an associated [`Trigger`] implementation (set via [`Event::Trigger`]), which defines which observers will run,
+/// what data will be passed to them, and the order they will be run in. Unless you are an internals developer or you have very specific
+/// needs, you don't need to worry too much about [`Trigger`]. When you derive [`Event`] (or a more specific event trait like [`EntityEvent`]),
+/// a [`Trigger`] will be provided for you.
+///
+/// The [`Event`] derive defaults [`Event::Trigger`] to [`GlobalTrigger`], which will run all observers that watch for the [`Event`].
+///
+/// # Entity Events
+///
+/// For events that "target" a specific [`Entity`], see [`EntityEvent`].
+#[diagnostic::on_unimplemented(
+    message = "`{Self}` is not an `Event`",
+    label = "invalid `Event`",
+    note = "consider annotating `{Self}` with `#[derive(Event)]`"
+)]
+pub trait Event: Send + Sync + Sized + 'static {
+    /// Defines which observers will run, what data will be passed to them, and the order they will be run in. See [`Trigger`] for more info.
+    type Trigger<'a>: Trigger<Self>;
+}
+
+/// An [`EntityEvent`] is an [`Event`] that is triggered for a specific [`EntityEvent::event_target`] entity:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// # let mut world = World::default();
+/// # let entity = world.spawn_empty().id();
+/// #[derive(EntityEvent)]
+/// struct Explode {
+///     entity: Entity,
+/// }
+///
+/// world.add_observer(|event: On<Explode>, mut commands: Commands| {
+///     println!("Entity {} goes BOOM!", event.entity);
+///     commands.entity(event.entity).despawn();
+/// });
+///
+/// world.trigger(Explode { entity });
+/// ```
+///
+/// [`EntityEvent`] will set [`EntityEvent::event_target`] automatically for named structs with an `entity` field name (as seen above). It also works for tuple structs
+/// whose only field is [`Entity`]:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #[derive(EntityEvent)]
+/// struct Explode(Entity);
+/// ```
+///
+/// The [`EntityEvent::event_target`] can also be manually set using the `#[event_target]` field attribute:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #[derive(EntityEvent)]
+/// struct Explode {
+///     #[event_target]
+///     exploded_entity: Entity,
+/// }
+/// ```
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #[derive(EntityEvent)]
+/// struct Explode(#[event_target] Entity);
+/// ```
+///
+/// ## Trigger Behavior
+///
+/// When derived, [`EntityEvent`] defaults to setting [`Event::Trigger`] to [`EntityTrigger`], which will run all normal "untargeted"
+/// observers added via [`World::add_observer`], just like a default [`Event`] would (see the example above).
+///
+/// However it will _also_ run all observers that watch _specific_ entities, which enables you to assign entity-specific logic:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// # #[derive(Component, Debug)]
+/// # struct Name(String);
+/// # let mut world = World::default();
+/// # let e1 = world.spawn_empty().id();
+/// # let e2 = world.spawn_empty().id();
+/// # #[derive(EntityEvent)]
+/// # struct Explode {
+/// #    entity: Entity,
+/// # }
+/// world.entity_mut(e1).observe(|event: On<Explode>, mut commands: Commands| {
+///     println!("Boom!");
+///     commands.entity(event.entity).despawn();
+/// });
+///
+/// world.entity_mut(e2).observe(|event: On<Explode>, mut commands: Commands| {
+///     println!("The explosion fizzles! This entity is immune!");
+/// });
+/// ```
+///
+/// ## [`EntityEvent`] Propagation
+///
+/// When deriving [`EntityEvent`], you can enable "event propagation" (also known as "event bubbling") by
+/// specifying the `#[entity_event(propagate)]` attribute:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #[derive(EntityEvent)]
+/// #[entity_event(propagate)]
+/// struct Click {
+///     entity: Entity,
+/// }
+/// ```
+///
+/// This will default to using the [`ChildOf`](crate::hierarchy::ChildOf) component to propagate the [`Event`] "up"
+/// the hierarchy (from child to parent).
+///
+/// You can also specify your own [`Traversal`](crate::traversal::Traversal) implementation. A common pattern is to use
+/// [`Relationship`](crate::relationship::Relationship) components, which will follow the relationships to their root
+/// (just be sure to avoid cycles ... these aren't detected for performance reasons):
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #[derive(Component)]
+/// #[relationship(relationship_target = ClickableBy)]
+/// struct Clickable(Entity);
+///
+/// #[derive(Component)]
+/// #[relationship_target(relationship = Clickable)]
+/// struct ClickableBy(Vec<Entity>);
+///
+/// #[derive(EntityEvent)]
+/// #[entity_event(propagate = &'static Clickable)]
+/// struct Click {
+///     entity: Entity,
+/// }
+/// ```
+///
+/// By default, propagation requires observers to opt-in:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #[derive(EntityEvent)]
+/// #[entity_event(propagate)]
+/// struct Click {
+///     entity: Entity,
+/// }
+///
+/// # let mut world = World::default();
+/// world.add_observer(|mut click: On<Click>| {
+///   // this will propagate the event up to the parent, using `ChildOf`
+///   click.propagate(true);
+/// });
+/// ```
+///
+/// But you can enable auto propagation using the `#[entity_event(auto_propagate)]` attribute:
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// #[derive(EntityEvent)]
+/// #[entity_event(propagate, auto_propagate)]
+/// struct Click {
+///     entity: Entity,
+/// }
+/// ```
+///
+/// You can also _stop_ propagation like this:
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// # #[derive(EntityEvent)]
+/// # #[entity_event(propagate)]
+/// # struct Click {
+/// #    entity: Entity,
+/// # }
+/// # fn is_finished_propagating() -> bool { true }
+/// # let mut world = World::default();
+/// world.add_observer(|mut click: On<Click>| {
+///   if is_finished_propagating() {
+///     click.propagate(false);
+///   }
+/// });
+/// ```
+///
+/// ## Naming and Usage Conventions
+///
+/// In most cases, it is recommended to use a named struct field for the "event target" entity, and to use
+/// a name that is descriptive as possible, as this makes events easier to understand and read.
+///
+/// For events with only one [`Entity`] field, `entity` is often a reasonable name. But if there are multiple
+/// [`Entity`] fields, it is often a good idea to use a more descriptive name.
+///
+/// It is also generally recommended to _consume_ "event target" entities directly via their named field, as this
+/// can make the context clearer, allows for more specific documentation hints in IDEs, and it generally reads better.
+///
+/// ## Manually spawning [`EntityEvent`] observers
+///
+/// The examples above that call [`EntityWorldMut::observe`] to add entity-specific observer logic are
+/// just shorthand for spawning an [`Observer`] directly and manually watching the entity:
+///
+/// ```
+/// # use bevy_ecs::prelude::*;
+/// # let mut world = World::default();
+/// # let entity = world.spawn_empty().id();
+/// # #[derive(EntityEvent)]
+/// # struct Explode(Entity);
+/// let mut observer = Observer::new(|event: On<Explode>| {});
+/// observer.watch_entity(entity);
+/// world.spawn(observer);
+/// ```
+///
+/// Note that the [`Observer`] component is not added to the entity it is observing. Observers should always be their own entities, as there
+/// can be multiple observers of the same entity!
+///
+/// You can call [`Observer::watch_entity`] more than once or [`Observer::watch_entities`] to watch multiple entities with the same [`Observer`].
+///
+/// [`EntityWorldMut::observe`]: crate::world::EntityWorldMut::observe
+/// [`Observer`]: crate::observer::Observer
+/// [`Observer::watch_entity`]: crate::observer::Observer::watch_entity
+/// [`Observer::watch_entities`]: crate::observer::Observer::watch_entities
+pub trait EntityEvent: Event {
+    /// The [`Entity`] "target" of this [`EntityEvent`]. When triggered, this will run observers that watch for this specific entity.
+    fn event_target(&self) -> Entity;
+    /// Returns a mutable reference to the [`Entity`] "target" of this [`EntityEvent`]. When triggered, this will run observers that watch for this specific entity.
+    ///
+    /// Note: In general, this should not be mutated from within an [`Observer`](crate::observer::Observer), as this will not "retarget"
+    /// the event in any of Bevy's built-in [`Trigger`] implementations.
+    fn event_target_mut(&mut self) -> &mut Entity;
+}
+
+impl World {
+    /// Generates the [`EventKey`] for this event type.
+    ///
+    /// If this type has already been registered,
+    /// this will return the existing [`EventKey`].
+    ///
+    /// This is used by various dynamically typed observer APIs,
+    /// such as [`DeferredWorld::trigger_raw`](crate::world::DeferredWorld::trigger_raw).
+    pub fn register_event_key<E: Event>(&mut self) -> EventKey {
+        EventKey(self.register_component::<EventWrapperComponent<E>>())
+    }
+
+    /// Fetches the [`EventKey`] for this event type,
+    /// if it has already been generated.
+    ///
+    /// This is used by various dynamically typed observer APIs,
+    /// such as [`DeferredWorld::trigger_raw`](crate::world::DeferredWorld::trigger_raw).
+    pub fn event_key<E: Event>(&self) -> Option<EventKey> {
+        self.component_id::<EventWrapperComponent<E>>()
+            .map(EventKey)
+    }
+}
+
+/// An internal type that implements [`Component`] for a given [`Event`] type.
+///
+/// This exists so we can easily get access to a unique [`ComponentId`] for each [`Event`] type,
+/// without requiring that [`Event`] types implement [`Component`] directly.
+/// [`ComponentId`] is used internally as a unique identifier for events because they are:
+///
+/// - Unique to each event type.
+/// - Can be quickly generated and looked up.
+/// - Are compatible with dynamic event types, which aren't backed by a Rust type.
+///
+/// This type is an implementation detail and should never be made public.
+// TODO: refactor events to store their metadata on distinct entities, rather than using `ComponentId`
+#[derive(Component)]
+struct EventWrapperComponent<E: Event>(PhantomData<E>);
+
+/// A unique identifier for an [`Event`], used by [observers].
+///
+/// You can look up the key for your event by calling the [`World::event_key`] method.
+///
+/// [observers]: crate::observer
+#[derive(Debug, Copy, Clone, Hash, Ord, PartialOrd, Eq, PartialEq)]
+pub struct EventKey(pub(crate) ComponentId);
+
+impl EventKey {
+    /// Returns the internal [`ComponentId`].
+    #[inline]
+    pub(crate) fn component_id(&self) -> ComponentId {
+        self.0
+    }
+}
 
 #[cfg(test)]
 mod tests {
diff --git a/crates/bevy_ecs/src/event/trigger.rs b/crates/bevy_ecs/src/event/trigger.rs
new file mode 100644
index 0000000000000..45b5e52b06b7b
--- /dev/null
+++ b/crates/bevy_ecs/src/event/trigger.rs
@@ -0,0 +1,430 @@
+use crate::{
+    component::ComponentId,
+    entity::Entity,
+    event::{EntityEvent, Event},
+    observer::{CachedObservers, TriggerContext},
+    traversal::Traversal,
+    world::DeferredWorld,
+};
+use bevy_ptr::PtrMut;
+use core::marker::PhantomData;
+
+/// [`Trigger`] determines _how_ an [`Event`] is triggered when [`World::trigger`](crate::world::World::trigger) is called.
+/// This decides which [`Observer`](crate::observer::Observer)s will run, what data gets passed to them, and the order they will
+/// be executed in.
+///
+/// Implementing [`Trigger`] is "advanced-level" territory, and is generally unnecessary unless you are developing highly specialized
+/// [`Event`] trigger logic.
+///
+/// Bevy comes with a number of built-in [`Trigger`] implementations (see their documentation for more info):
+/// - [`GlobalTrigger`]: The [`Event`] derive defaults to using this
+/// - [`EntityTrigger`]: The [`EntityEvent`] derive defaults to using this
+/// - [`PropagateEntityTrigger`]: The [`EntityEvent`] derive uses this when propagation is enabled.
+/// - [`EntityComponentsTrigger`]: Used by Bevy's [component lifecycle events](crate::lifecycle).
+///
+/// # Safety
+///
+/// Implementing this properly is _advanced_ soundness territory! Implementers must abide by the following:
+///
+/// - The `E`' [`Event::Trigger`] must be constrained to the implemented [`Trigger`] type, as part of the implementation.
+///   This prevents other [`Trigger`] implementations from directly deferring to your implementation, which is a very easy
+///   soundness misstep, as most [`Trigger`] implementations will invoke observers that are developed _for their specific [`Trigger`] type_.
+///   Without this constraint, something like [`GlobalTrigger`] could be called for _any_ [`Event`] type, even one that expects a different
+///   [`Trigger`] type. This would result in an unsound cast of [`GlobalTrigger`] reference.
+///   This is not expressed as an explicit type constraint,, as the `for<'a> Event::Trigger<'a>` lifetime can mismatch explicit lifetimes in
+///   some impls.
+pub unsafe trait Trigger<E: Event> {
+    /// Trigger the given `event`, running every [`Observer`](crate::observer::Observer) that matches the `event`, as defined by this
+    /// [`Trigger`] and the state stored on `self`.
+    ///
+    /// # Safety
+    /// - The [`CachedObservers`] `observers` must come from the [`DeferredWorld`] `world`
+    /// - [`TriggerContext`] must contain an [`EventKey`](crate::event::EventKey) that matches the `E` [`Event`] type
+    /// - `observers` must correspond to observers compatible with the event type `E`
+    /// - Read and abide by the "Safety" section defined in the top-level [`Trigger`] docs. Calling this function is
+    ///   unintuitively risky. _Do not use it directly unless you know what you are doing_. Importantly, this should only
+    ///   be called for an `event` whose [`Event::Trigger`] matches this trigger.
+    unsafe fn trigger(
+        &mut self,
+        world: DeferredWorld,
+        observers: &CachedObservers,
+        trigger_context: &TriggerContext,
+        event: &mut E,
+    );
+}
+
+/// A [`Trigger`] that runs _every_ "global" [`Observer`](crate::observer::Observer) (ex: registered via [`World::add_observer`](crate::world::World::add_observer))
+/// that matches the given [`Event`].
+///
+/// The [`Event`] derive defaults to using this [`Trigger`], and it is usable for any [`Event`] type.
+#[derive(Default)]
+pub struct GlobalTrigger;
+
+// SAFETY:
+// - `E`'s [`Event::Trigger`] is constrained to [`GlobalTrigger`]
+// - The implementation abides by the other safety constraints defined in [`Trigger`]
+unsafe impl<E: for<'a> Event<Trigger<'a> = Self>> Trigger<E> for GlobalTrigger {
+    unsafe fn trigger(
+        &mut self,
+        world: DeferredWorld,
+        observers: &CachedObservers,
+        trigger_context: &TriggerContext,
+        event: &mut E,
+    ) {
+        // SAFETY:
+        // - The caller of `trigger` ensures that `observers` come from the `world`
+        // - The passed in event ptr comes from `event`, which is E: Event
+        // - E: Event::Trigger is constrained to GlobalTrigger
+        // - The caller of `trigger` ensures that `TriggerContext::event_key` matches `event`
+        unsafe {
+            self.trigger_internal(world, observers, trigger_context, event.into());
+        }
+    }
+}
+
+impl GlobalTrigger {
+    /// # Safety
+    /// - `observers` must come from the `world` [`DeferredWorld`], and correspond to observers that match the `event` type
+    /// - `event` must point to an [`Event`]
+    /// -  The `event` [`Event::Trigger`] must be [`GlobalTrigger`]
+    /// - `trigger_context`'s [`TriggerContext::event_key`] must correspond to the `event` type.
+    unsafe fn trigger_internal(
+        &mut self,
+        mut world: DeferredWorld,
+        observers: &CachedObservers,
+        trigger_context: &TriggerContext,
+        mut event: PtrMut,
+    ) {
+        // SAFETY: `observers` is the only active reference to something in `world`
+        unsafe {
+            world.as_unsafe_world_cell().increment_trigger_id();
+        }
+        for (observer, runner) in observers.global_observers() {
+            // SAFETY:
+            // - `observers` come from `world` and match the `event` type, enforced by the call to `trigger_internal`
+            // - the passed in event pointer is an `Event`, enforced by the call to `trigger_internal`
+            // - `trigger` is a matching trigger type, as it comes from `self`, which is the Trigger for `event`, enforced by `trigger_internal`
+            // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger_internal`
+            // - this abides by the nuances defined in the `Trigger` safety docs
+            unsafe {
+                (runner)(
+                    world.reborrow(),
+                    *observer,
+                    trigger_context,
+                    event.reborrow(),
+                    self.into(),
+                );
+            }
+        }
+    }
+}
+
+/// An [`EntityEvent`] [`Trigger`] that does two things:
+/// - Runs all "global" [`Observer`] (ex: registered via [`World::add_observer`](crate::world::World::add_observer))
+///   that matches the given [`Event`]. This is the same behavior as [`GlobalTrigger`].
+/// - Runs every "entity scoped" [`Observer`] that watches the given [`EntityEvent::event_target`] entity.
+///
+/// The [`EntityEvent`] derive defaults to using this [`Trigger`], and it is usable for any [`EntityEvent`] type.
+///
+/// [`Observer`]: crate::observer::Observer
+#[derive(Default)]
+pub struct EntityTrigger;
+
+// SAFETY:
+// - `E`'s [`Event::Trigger`] is constrained to [`EntityTrigger`]
+// - The implementation abides by the other safety constraints defined in [`Trigger`]
+unsafe impl<E: EntityEvent + for<'a> Event<Trigger<'a> = Self>> Trigger<E> for EntityTrigger {
+    unsafe fn trigger(
+        &mut self,
+        world: DeferredWorld,
+        observers: &CachedObservers,
+        trigger_context: &TriggerContext,
+        event: &mut E,
+    ) {
+        let entity = event.event_target();
+        // SAFETY:
+        // - `observers` come from `world` and match the event type `E`, enforced by the call to `trigger`
+        // - the passed in event pointer comes from `event`, which is an `Event`
+        // - `trigger` is a matching trigger type, as it comes from `self`, which is the Trigger for `E`
+        // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger`
+        unsafe {
+            trigger_entity_internal(
+                world,
+                observers,
+                event.into(),
+                self.into(),
+                entity,
+                trigger_context,
+            );
+        }
+    }
+}
+
+/// Trigger observers watching for the given entity event.
+/// The `target_entity` should match the [`EntityEvent::event_target`] on `event` for logical correctness.
+///
+/// # Safety
+/// - `observers` must come from the `world` [`DeferredWorld`], and correspond to observers that match the `event` type
+/// - `event` must point to an [`Event`]
+/// - `trigger` must correspond to the [`Event::Trigger`] type expected by the `event`
+/// - `trigger_context`'s [`TriggerContext::event_key`] must correspond to the `event` type.
+/// - Read, understand, and abide by the [`Trigger`] safety documentation
+// Note: this is not an EntityTrigger method because we want to reuse this logic for the entity propagation trigger
+#[inline(never)]
+pub unsafe fn trigger_entity_internal(
+    mut world: DeferredWorld,
+    observers: &CachedObservers,
+    mut event: PtrMut,
+    mut trigger: PtrMut,
+    target_entity: Entity,
+    trigger_context: &TriggerContext,
+) {
+    // SAFETY: there are no outstanding world references
+    unsafe {
+        world.as_unsafe_world_cell().increment_trigger_id();
+    }
+    for (observer, runner) in observers.global_observers() {
+        // SAFETY:
+        // - `observers` come from `world` and match the `event` type, enforced by the call to `trigger_entity_internal`
+        // - the passed in event pointer is an `Event`, enforced by the call to `trigger_entity_internal`
+        // - `trigger` is a matching trigger type, enforced by the call to `trigger_entity_internal`
+        // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger_entity_internal`
+        unsafe {
+            (runner)(
+                world.reborrow(),
+                *observer,
+                trigger_context,
+                event.reborrow(),
+                trigger.reborrow(),
+            );
+        }
+    }
+
+    if let Some(map) = observers.entity_observers().get(&target_entity) {
+        for (observer, runner) in map {
+            // SAFETY:
+            // - `observers` come from `world` and match the `event` type, enforced by the call to `trigger_entity_internal`
+            // - the passed in event pointer is an `Event`, enforced by the call to `trigger_entity_internal`
+            // - `trigger` is a matching trigger type, enforced by the call to `trigger_entity_internal`
+            // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger_entity_internal`
+            unsafe {
+                (runner)(
+                    world.reborrow(),
+                    *observer,
+                    trigger_context,
+                    event.reborrow(),
+                    trigger.reborrow(),
+                );
+            }
+        }
+    }
+}
+
+/// An [`EntityEvent`] [`Trigger`] that behaves like [`EntityTrigger`], but "propagates" the event
+/// using an [`Entity`] [`Traversal`]. At each step in the propagation, the [`EntityTrigger`] logic will
+/// be run, until [`PropagateEntityTrigger::propagate`] is false, or there are no entities left to traverse.
+///
+/// This is used by the [`EntityEvent`] derive when `#[entity_event(propagate)]` is enabled. It is usable by every
+/// [`EntityEvent`] type.
+///
+/// If `AUTO_PROPAGATE` is `true`, [`PropagateEntityTrigger::propagate`] will default to `true`.
+pub struct PropagateEntityTrigger<const AUTO_PROPAGATE: bool, E: EntityEvent, T: Traversal<E>> {
+    /// The original [`Entity`] the [`Event`] was _first_ triggered for.
+    pub original_event_target: Entity,
+
+    /// Whether or not to continue propagating using the `T` [`Traversal`]. If this is false,
+    /// The [`Traversal`] will stop on the current entity.
+    pub propagate: bool,
+
+    _marker: PhantomData<(E, T)>,
+}
+
+impl<const AUTO_PROPAGATE: bool, E: EntityEvent, T: Traversal<E>> Default
+    for PropagateEntityTrigger<AUTO_PROPAGATE, E, T>
+{
+    fn default() -> Self {
+        Self {
+            original_event_target: Entity::PLACEHOLDER,
+            propagate: AUTO_PROPAGATE,
+            _marker: Default::default(),
+        }
+    }
+}
+
+// SAFETY:
+// - `E`'s [`Event::Trigger`] is constrained to [`PropagateEntityTrigger<E>`]
+unsafe impl<
+        const AUTO_PROPAGATE: bool,
+        E: EntityEvent + for<'a> Event<Trigger<'a> = Self>,
+        T: Traversal<E>,
+    > Trigger<E> for PropagateEntityTrigger<AUTO_PROPAGATE, E, T>
+{
+    unsafe fn trigger(
+        &mut self,
+        mut world: DeferredWorld,
+        observers: &CachedObservers,
+        trigger_context: &TriggerContext,
+        event: &mut E,
+    ) {
+        let mut current_entity = event.event_target();
+        self.original_event_target = current_entity;
+        // SAFETY:
+        // - `observers` come from `world` and match the event type `E`, enforced by the call to `trigger`
+        // - the passed in event pointer comes from `event`, which is an `Event`
+        // - `trigger` is a matching trigger type, as it comes from `self`, which is the Trigger for `E`
+        // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger`
+        unsafe {
+            trigger_entity_internal(
+                world.reborrow(),
+                observers,
+                event.into(),
+                self.into(),
+                current_entity,
+                trigger_context,
+            );
+        }
+
+        loop {
+            if !self.propagate {
+                return;
+            }
+            if let Ok(entity) = world.get_entity(current_entity)
+                && let Some(item) = entity.get_components::<T>()
+                && let Some(traverse_to) = T::traverse(item, event)
+            {
+                current_entity = traverse_to;
+            } else {
+                break;
+            }
+
+            *event.event_target_mut() = current_entity;
+            // SAFETY:
+            // - `observers` come from `world` and match the event type `E`, enforced by the call to `trigger`
+            // - the passed in event pointer comes from `event`, which is an `Event`
+            // - `trigger` is a matching trigger type, as it comes from `self`, which is the Trigger for `E`
+            // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger`
+            unsafe {
+                trigger_entity_internal(
+                    world.reborrow(),
+                    observers,
+                    event.into(),
+                    self.into(),
+                    current_entity,
+                    trigger_context,
+                );
+            }
+        }
+    }
+}
+
+/// An [`EntityEvent`] [`Trigger`] that, in addition to behaving like a normal [`EntityTrigger`], _also_ runs observers
+/// that watch for components that match the slice of [`ComponentId`]s referenced in [`EntityComponentsTrigger`]. This includes
+/// both _global_ observers of those components and "entity scoped" observers that watch the [`EntityEvent::event_target`].
+///
+/// This is used by Bevy's built-in [lifecycle events](crate::lifecycle).
+#[derive(Default)]
+pub struct EntityComponentsTrigger<'a> {
+    /// All of the components whose observers were triggered together for the target entity. For example,
+    /// if components `A` and `B` are added together, producing the [`Add`](crate::lifecycle::Add) event, this will
+    /// contain the [`ComponentId`] for both `A` and `B`.
+    pub components: &'a [ComponentId],
+}
+
+// SAFETY:
+// - `E`'s [`Event::Trigger`] is constrained to [`EntityComponentsTrigger`]
+unsafe impl<'a, E: EntityEvent + Event<Trigger<'a> = EntityComponentsTrigger<'a>>> Trigger<E>
+    for EntityComponentsTrigger<'a>
+{
+    unsafe fn trigger(
+        &mut self,
+        world: DeferredWorld,
+        observers: &CachedObservers,
+        trigger_context: &TriggerContext,
+        event: &mut E,
+    ) {
+        let entity = event.event_target();
+        // SAFETY:
+        // - `observers` come from `world` and match the event type `E`, enforced by the call to `trigger`
+        // - the passed in event pointer comes from `event`, which is an `Event`
+        // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger`
+        unsafe {
+            self.trigger_internal(world, observers, event.into(), entity, trigger_context);
+        }
+    }
+}
+
+impl<'a> EntityComponentsTrigger<'a> {
+    /// # Safety
+    /// - `observers` must come from the `world` [`DeferredWorld`]
+    /// - `event` must point to an [`Event`] whose [`Event::Trigger`] is [`EntityComponentsTrigger`]
+    /// - `trigger_context`'s [`TriggerContext::event_key`] must correspond to the `event` type.
+    #[inline(never)]
+    unsafe fn trigger_internal(
+        &mut self,
+        mut world: DeferredWorld,
+        observers: &CachedObservers,
+        mut event: PtrMut,
+        entity: Entity,
+        trigger_context: &TriggerContext,
+    ) {
+        // SAFETY:
+        // - `observers` come from `world` and match the event type `E`, enforced by the call to `trigger`
+        // - the passed in event pointer comes from `event`, which is an `Event`
+        // - `trigger` is a matching trigger type, as it comes from `self`, which is the Trigger for `E`
+        // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger`
+        unsafe {
+            trigger_entity_internal(
+                world.reborrow(),
+                observers,
+                event.reborrow(),
+                self.into(),
+                entity,
+                trigger_context,
+            );
+        }
+
+        // Trigger observers watching for a specific component
+        for id in self.components {
+            if let Some(component_observers) = observers.component_observers().get(id) {
+                for (observer, runner) in component_observers.global_observers() {
+                    // SAFETY:
+                    // - `observers` come from `world` and match the `event` type, enforced by the call to `trigger_internal`
+                    // - the passed in event pointer is an `Event`, enforced by the call to `trigger_internal`
+                    // - `trigger` is a matching trigger type, enforced by the call to `trigger_internal`
+                    // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger_internal`
+                    unsafe {
+                        (runner)(
+                            world.reborrow(),
+                            *observer,
+                            trigger_context,
+                            event.reborrow(),
+                            self.into(),
+                        );
+                    }
+                }
+
+                if let Some(map) = component_observers
+                    .entity_component_observers()
+                    .get(&entity)
+                {
+                    for (observer, runner) in map {
+                        // SAFETY:
+                        // - `observers` come from `world` and match the `event` type, enforced by the call to `trigger_internal`
+                        // - the passed in event pointer is an `Event`, enforced by the call to `trigger_internal`
+                        // - `trigger` is a matching trigger type, enforced by the call to `trigger_internal`
+                        // - `trigger_context`'s event_key matches `E`, enforced by the call to `trigger_internal`
+                        unsafe {
+                            (runner)(
+                                world.reborrow(),
+                                *observer,
+                                trigger_context,
+                                event.reborrow(),
+                                self.into(),
+                            );
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/crates/bevy_ecs/src/lifecycle.rs b/crates/bevy_ecs/src/lifecycle.rs
index e45f9eefa0113..cc16250dfc978 100644
--- a/crates/bevy_ecs/src/lifecycle.rs
+++ b/crates/bevy_ecs/src/lifecycle.rs
@@ -43,7 +43,7 @@
 //!
 //! Despite the absence of generics, each lifecycle event is associated with a specific component.
 //! When defining a component hook for a [`Component`] type, that component is used.
-//! When listening to lifecycle events for observers, the `B: Bundle` generic is used.
+//! When observers watch lifecycle events, the `B: Bundle` generic is used.
 //!
 //! Each of these lifecycle events also corresponds to a fixed [`ComponentId`],
 //! which are assigned during [`World`] initialization.
@@ -54,8 +54,8 @@ use crate::{
     component::{Component, ComponentId, ComponentIdFor, Tick},
     entity::Entity,
     event::{
-        BufferedEvent, EntityEvent, EventCursor, EventId, EventIterator, EventIteratorWithId,
-        EventKey, Events,
+        BufferedEvent, EntityComponentsTrigger, EntityEvent, EventCursor, EventId, EventIterator,
+        EventIteratorWithId, EventKey, Events,
     },
     query::FilteredAccessSet,
     relationship::RelationshipHookMode,
@@ -328,48 +328,68 @@ pub const DESPAWN: EventKey = EventKey(ComponentId::new(4));
 /// Trigger emitted when a component is inserted onto an entity that does not already have that
 /// component. Runs before `Insert`.
 /// See [`crate::lifecycle::ComponentHooks::on_add`] for more information.
-#[derive(EntityEvent, Debug, Clone)]
+#[derive(Debug, Clone, EntityEvent)]
+#[entity_event(trigger = EntityComponentsTrigger<'a>)]
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 #[cfg_attr(feature = "bevy_reflect", reflect(Debug))]
 #[doc(alias = "OnAdd")]
-pub struct Add;
+pub struct Add {
+    /// The entity this component was added to.
+    pub entity: Entity,
+}
 
 /// Trigger emitted when a component is inserted, regardless of whether or not the entity already
 /// had that component. Runs after `Add`, if it ran.
 /// See [`crate::lifecycle::ComponentHooks::on_insert`] for more information.
-#[derive(EntityEvent, Debug, Clone)]
+#[derive(Debug, Clone, EntityEvent)]
+#[entity_event(trigger = EntityComponentsTrigger<'a>)]
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 #[cfg_attr(feature = "bevy_reflect", reflect(Debug))]
 #[doc(alias = "OnInsert")]
-pub struct Insert;
+pub struct Insert {
+    /// The entity this component was inserted into.
+    pub entity: Entity,
+}
 
 /// Trigger emitted when a component is removed from an entity, regardless
 /// of whether or not it is later replaced.
 ///
 /// Runs before the value is replaced, so you can still access the original component data.
 /// See [`crate::lifecycle::ComponentHooks::on_replace`] for more information.
-#[derive(EntityEvent, Debug, Clone)]
+#[derive(Debug, Clone, EntityEvent)]
+#[entity_event(trigger = EntityComponentsTrigger<'a>)]
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 #[cfg_attr(feature = "bevy_reflect", reflect(Debug))]
 #[doc(alias = "OnReplace")]
-pub struct Replace;
+pub struct Replace {
+    /// The entity that held this component before it was replaced.
+    pub entity: Entity,
+}
 
 /// Trigger emitted when a component is removed from an entity, and runs before the component is
 /// removed, so you can still access the component data.
 /// See [`crate::lifecycle::ComponentHooks::on_remove`] for more information.
-#[derive(EntityEvent, Debug, Clone)]
+#[derive(Debug, Clone, EntityEvent)]
+#[entity_event(trigger = EntityComponentsTrigger<'a>)]
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 #[cfg_attr(feature = "bevy_reflect", reflect(Debug))]
 #[doc(alias = "OnRemove")]
-pub struct Remove;
+pub struct Remove {
+    /// The entity this component was removed from.
+    pub entity: Entity,
+}
 
-/// Trigger emitted for each component on an entity when it is despawned.
+/// [`EntityEvent`] emitted for each component on an entity when it is despawned.
 /// See [`crate::lifecycle::ComponentHooks::on_despawn`] for more information.
-#[derive(EntityEvent, Debug, Clone)]
+#[derive(Debug, Clone, EntityEvent)]
+#[entity_event(trigger = EntityComponentsTrigger<'a>)]
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 #[cfg_attr(feature = "bevy_reflect", reflect(Debug))]
 #[doc(alias = "OnDespawn")]
-pub struct Despawn;
+pub struct Despawn {
+    /// The entity that held this component before it was despawned.
+    pub entity: Entity,
+}
 
 /// Deprecated in favor of [`Add`].
 #[deprecated(since = "0.17.0", note = "Renamed to `Add`.")]
diff --git a/crates/bevy_ecs/src/observer/centralized_storage.rs b/crates/bevy_ecs/src/observer/centralized_storage.rs
index 2e3b78a8daf83..c972ef5b5e1f5 100644
--- a/crates/bevy_ecs/src/observer/centralized_storage.rs
+++ b/crates/bevy_ecs/src/observer/centralized_storage.rs
@@ -12,31 +12,26 @@
 use bevy_platform::collections::HashMap;
 
 use crate::{
-    archetype::ArchetypeFlags,
-    change_detection::MaybeLocation,
-    component::ComponentId,
-    entity::EntityHashMap,
-    observer::{ObserverRunner, ObserverTrigger},
-    prelude::*,
-    world::DeferredWorld,
+    archetype::ArchetypeFlags, component::ComponentId, entity::EntityHashMap,
+    observer::ObserverRunner, prelude::*,
 };
 
 /// An internal lookup table tracking all of the observers in the world.
 ///
-/// Stores a cache mapping trigger ids to the registered observers.
+/// Stores a cache mapping event ids to their registered observers.
 /// Some observer kinds (like [lifecycle](crate::lifecycle) observers) have a dedicated field,
 /// saving lookups for the most common triggers.
 ///
 /// This can be accessed via [`World::observers`].
 #[derive(Default, Debug)]
 pub struct Observers {
-    // Cached ECS observers to save a lookup most common triggers.
+    // Cached ECS observers to save a lookup for high-traffic built-in event types.
     add: CachedObservers,
     insert: CachedObservers,
     replace: CachedObservers,
     remove: CachedObservers,
     despawn: CachedObservers,
-    // Map from trigger type to set of observers listening to that trigger
+    // Map from event type to set of observers watching for that event
     cache: HashMap<EventKey, CachedObservers>,
 }
 
@@ -71,80 +66,6 @@ impl Observers {
         }
     }
 
-    /// This will run the observers of the given `event_key`, targeting the given `entity` and `components`.
-    pub(crate) fn invoke<T>(
-        mut world: DeferredWorld,
-        event_key: EventKey,
-        current_target: Option<Entity>,
-        original_entity: Option<Entity>,
-        components: impl Iterator<Item = ComponentId> + Clone,
-        data: &mut T,
-        propagate: &mut bool,
-        caller: MaybeLocation,
-    ) {
-        // SAFETY: You cannot get a mutable reference to `observers` from `DeferredWorld`
-        let (mut world, observers) = unsafe {
-            let world = world.as_unsafe_world_cell();
-            // SAFETY: There are no outstanding world references
-            world.increment_trigger_id();
-            let observers = world.observers();
-            let Some(observers) = observers.try_get_observers(event_key) else {
-                return;
-            };
-            // SAFETY: The only outstanding reference to world is `observers`
-            (world.into_deferred(), observers)
-        };
-
-        let trigger_for_components = components.clone();
-
-        let mut trigger_observer = |(&observer, runner): (&Entity, &ObserverRunner)| {
-            (runner)(
-                world.reborrow(),
-                ObserverTrigger {
-                    observer,
-                    event_key,
-                    components: components.clone().collect(),
-                    entity: current_target,
-                    original_entity,
-                    caller,
-                },
-                data.into(),
-                propagate,
-            );
-        };
-        // Trigger observers listening for any kind of this trigger
-        observers
-            .global_observers
-            .iter()
-            .for_each(&mut trigger_observer);
-
-        // Trigger entity observers listening for this kind of trigger
-        if let Some(target_entity) = current_target {
-            if let Some(map) = observers.entity_observers.get(&target_entity) {
-                map.iter().for_each(&mut trigger_observer);
-            }
-        }
-
-        // Trigger observers listening to this trigger targeting a specific component
-        trigger_for_components.for_each(|id| {
-            if let Some(component_observers) = observers.component_observers.get(&id) {
-                component_observers
-                    .global_observers
-                    .iter()
-                    .for_each(&mut trigger_observer);
-
-                if let Some(target_entity) = current_target {
-                    if let Some(map) = component_observers
-                        .entity_component_observers
-                        .get(&target_entity)
-                    {
-                        map.iter().for_each(&mut trigger_observer);
-                    }
-                }
-            }
-        });
-    }
-
     pub(crate) fn is_archetype_cached(event_key: EventKey) -> Option<ArchetypeFlags> {
         use crate::lifecycle::*;
 
@@ -190,30 +111,30 @@ impl Observers {
 /// This is stored inside of [`Observers`], specialized for each kind of observer.
 #[derive(Default, Debug)]
 pub struct CachedObservers {
-    // Observers listening for any time this event is fired, regardless of target
-    // This will also respond to events targeting specific components or entities
+    /// Observers watching for any time this event is triggered, regardless of target.
+    /// These will also respond to events targeting specific components or entities
     pub(super) global_observers: ObserverMap,
-    // Observers listening for this trigger fired at a specific component
+    /// Observers watching for triggers of events for a specific component
     pub(super) component_observers: HashMap<ComponentId, CachedComponentObservers>,
-    // Observers listening for this trigger fired at a specific entity
+    /// Observers watching for triggers of events for a specific entity
     pub(super) entity_observers: EntityHashMap<ObserverMap>,
 }
 
 impl CachedObservers {
-    /// Returns the observers listening for this trigger, regardless of target.
-    /// These observers will also respond to events targeting specific components or entities.
+    /// Observers watching for any time this event is triggered, regardless of target.
+    /// These will also respond to events targeting specific components or entities
     pub fn global_observers(&self) -> &ObserverMap {
         &self.global_observers
     }
 
-    /// Returns the observers listening for this trigger targeting components.
-    pub fn get_component_observers(&self) -> &HashMap<ComponentId, CachedComponentObservers> {
+    /// Returns observers watching for triggers of events for a specific component.
+    pub fn component_observers(&self) -> &HashMap<ComponentId, CachedComponentObservers> {
         &self.component_observers
     }
 
-    /// Returns the observers listening for this trigger targeting entities.
-    pub fn entity_observers(&self) -> &HashMap<ComponentId, CachedComponentObservers> {
-        &self.component_observers
+    /// Returns observers watching for triggers of events for a specific entity.
+    pub fn entity_observers(&self) -> &EntityHashMap<ObserverMap> {
+        &self.entity_observers
     }
 }
 
@@ -225,20 +146,19 @@ pub type ObserverMap = EntityHashMap<ObserverRunner>;
 /// This is stored inside of [`CachedObservers`].
 #[derive(Default, Debug)]
 pub struct CachedComponentObservers {
-    // Observers listening to events targeting this component, but not a specific entity
+    // Observers watching for events targeting this component, but not a specific entity
     pub(super) global_observers: ObserverMap,
-    // Observers listening to events targeting this component on a specific entity
+    // Observers watching for events targeting this component on a specific entity
     pub(super) entity_component_observers: EntityHashMap<ObserverMap>,
 }
 
 impl CachedComponentObservers {
-    /// Returns the observers listening for this trigger, regardless of target.
-    /// These observers will also respond to events targeting specific entities.
+    /// Returns observers watching for events targeting this component, but not a specific entity
     pub fn global_observers(&self) -> &ObserverMap {
         &self.global_observers
     }
 
-    /// Returns the observers listening for this trigger targeting this component on a specific entity.
+    /// Returns observers watching for events targeting this component on a specific entity
     pub fn entity_component_observers(&self) -> &EntityHashMap<ObserverMap> {
         &self.entity_component_observers
     }
diff --git a/crates/bevy_ecs/src/observer/distributed_storage.rs b/crates/bevy_ecs/src/observer/distributed_storage.rs
index 4610e26047b8b..3dce0621f44f4 100644
--- a/crates/bevy_ecs/src/observer/distributed_storage.rs
+++ b/crates/bevy_ecs/src/observer/distributed_storage.rs
@@ -18,6 +18,7 @@ use crate::{
     entity::Entity,
     entity_disabling::Internal,
     error::{ErrorContext, ErrorHandler},
+    event::Event,
     lifecycle::{ComponentHook, HookContext},
     observer::{observer_system_runner, ObserverRunner},
     prelude::*,
@@ -33,12 +34,10 @@ use crate::prelude::ReflectComponent;
 
 /// An [`Observer`] system. Add this [`Component`] to an [`Entity`] to turn it into an "observer".
 ///
-/// Observers listen for a "trigger" of a specific [`Event`]. An event can be triggered on the [`World`]
-/// by calling [`World::trigger`], or if the event is an [`EntityEvent`], it can also be triggered for specific
-/// entity targets using [`World::trigger_targets`].
+/// Observers watch for a "trigger" of a specific [`Event`]. An event can be triggered on the [`World`]
+/// by calling [`World::trigger`]. It can also be queued up as a [`Command`] using [`Commands::trigger`].
 ///
-/// Note that [`BufferedEvent`]s sent using [`EventReader`] and [`EventWriter`] are _not_ automatically triggered.
-/// They must be triggered at a specific point in the schedule.
+/// When a [`World`] triggers an [`Event`], it will immediately run every [`Observer`] that watches for that [`Event`].
 ///
 /// # Usage
 ///
@@ -56,16 +55,12 @@ use crate::prelude::ReflectComponent;
 ///     println!("{}", event.message);
 /// });
 ///
-/// // Observers currently require a flush() to be registered. In the context of schedules,
-/// // this will generally be done for you.
-/// world.flush();
-///
 /// world.trigger(Speak {
 ///     message: "Hello!".into(),
 /// });
 /// ```
 ///
-/// Notice that we used [`World::add_observer`]. This is just a shorthand for spawning an [`Observer`] manually:
+/// Notice that we used [`World::add_observer`]. This is just a shorthand for spawning an [`Entity`] with an [`Observer`] manually:
 ///
 /// ```
 /// # use bevy_ecs::prelude::*;
@@ -77,7 +72,10 @@ use crate::prelude::ReflectComponent;
 /// world.spawn(Observer::new(|event: On<Speak>| {}));
 /// ```
 ///
-/// Observers are systems. They can access arbitrary [`World`] data by adding [`SystemParam`]s:
+/// Observers are a specialized [`System`] called an [`ObserverSystem`]. The first parameter must be [`On`], which provides access
+/// to the [`Event`], the [`Trigger`], and some additional execution context.
+///
+/// Because they are systems, they can access arbitrary [`World`] data by adding [`SystemParam`]s:
 ///
 /// ```
 /// # use bevy_ecs::prelude::*;
@@ -93,8 +91,6 @@ use crate::prelude::ReflectComponent;
 /// });
 /// ```
 ///
-/// Note that [`On`] must always be the first parameter.
-///
 /// You can also add [`Commands`], which means you can spawn new entities, insert new components, etc:
 ///
 /// ```
@@ -127,81 +123,86 @@ use crate::prelude::ReflectComponent;
 /// recursively evaluated until there are no commands left, meaning nested triggers all
 /// evaluate at the same time!
 ///
-/// If the event is an [`EntityEvent`], it can be triggered for specific entities,
-/// which will be passed to the [`Observer`]:
+/// ## Event [`Trigger`] behavior
 ///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// # let mut world = World::default();
-/// # let entity = world.spawn_empty().id();
-/// #[derive(EntityEvent)]
-/// struct Explode;
+/// Each [`Event`] defines a [`Trigger`] behavior, which determines _which_ observers will run for the given [`Event`] and _how_ they will be run.
 ///
-/// world.add_observer(|event: On<Explode>, mut commands: Commands| {
-///     println!("Entity {} goes BOOM!", event.entity());
-///     commands.entity(event.entity()).despawn();
-/// });
+/// [`Event`] by default (when derived) uses [`GlobalTrigger`](crate::event::GlobalTrigger). When it is triggered any [`Observer`] watching for it will be run.
 ///
-/// world.flush();
+/// ## Event sub-types
 ///
-/// world.trigger_targets(Explode, entity);
-/// ```
+/// There are some built-in specialized [`Event`] types with custom [`Trigger`] logic:
 ///
-/// You can trigger multiple entities at once:
+/// - [`EntityEvent`] / [`EntityTrigger`](crate::event::EntityTrigger): An [`Event`] that targets a _specific_ entity. This also has opt-in support for
+///   "event bubbling" behavior. See [`EntityEvent`] for details.
+/// - [`EntityComponentsTrigger`](crate::event::EntityComponentsTrigger): An [`Event`] that targets an entity _and_ one or more components on that entity.
+///   This is used for [component lifecycle events](crate::lifecycle).
 ///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// # let mut world = World::default();
-/// # let e1 = world.spawn_empty().id();
-/// # let e2 = world.spawn_empty().id();
-/// # #[derive(EntityEvent)]
-/// # struct Explode;
-/// world.trigger_targets(Explode, [e1, e2]);
-/// ```
+/// You can also define your own!
 ///
-/// Observers can also watch _specific_ entities, which enables you to assign entity-specific logic:
+/// ## Observer execution timing
 ///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// # #[derive(Component, Debug)]
-/// # struct Name(String);
-/// # let mut world = World::default();
-/// # let e1 = world.spawn_empty().id();
-/// # let e2 = world.spawn_empty().id();
-/// # #[derive(EntityEvent)]
-/// # struct Explode;
-/// world.entity_mut(e1).observe(|event: On<Explode>, mut commands: Commands| {
-///     println!("Boom!");
-///     commands.entity(event.entity()).despawn();
-/// });
+/// Observers triggered via [`World::trigger`] are evaluated immediately, as are all commands they queue up.
 ///
-/// world.entity_mut(e2).observe(|event: On<Explode>, mut commands: Commands| {
-///     println!("The explosion fizzles! This entity is immune!");
-/// });
-/// ```
+/// Observers triggered via [`Commands::trigger`] are evaluated at the next sync point in the ECS schedule, just like any other [`Command`].
 ///
-/// If all entities watched by a given [`Observer`] are despawned, the [`Observer`] entity will also be despawned.
+/// To control the relative ordering of observer trigger commands sent from different systems,
+/// order the systems in the schedule relative to each other.
+///
+/// Currently, Bevy does not provide [a way to specify the relative ordering of observers](https://github.com/bevyengine/bevy/issues/14890)
+/// watching for the same event. Their ordering is considered to be arbitrary. It is recommended to make no
+/// assumptions about their execution order.
+///
+/// Commands sent by observers are [currently not immediately applied](https://github.com/bevyengine/bevy/issues/19569).
+/// Instead, all queued observers will run, and then all of the commands from those observers will be applied.
+///
+/// ## [`ObservedBy`]
+///
+/// When entities are observed, they will receive an [`ObservedBy`] component,
+/// which will be updated to track the observers that are currently observing them.
+///
+/// ## Manual [`Observer`] target configuration
+///
+/// You can manually control the targets that an observer is watching by calling builder methods like [`Observer::with_entity`]
+/// _before_ inserting the [`Observer`] component.
+///
+/// In general, it is better to use the [`EntityWorldMut::observe`] or [`EntityCommands::observe`] methods,
+/// which spawns a new observer, and configures it to watch the entity it is called on.
+///
+/// ## Cleaning up observers
+///
+/// If an [`EntityEvent`] [`Observer`] targets specific entities, and all of those entities are despawned, the [`Observer`] entity will also be despawned.
 /// This protects against observer "garbage" building up over time.
 ///
-/// The examples above calling [`EntityWorldMut::observe`] to add entity-specific observer logic are (once again)
-/// just shorthand for spawning an [`Observer`] directly:
+/// ## Component lifecycle events: Observers vs Hooks
 ///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// # let mut world = World::default();
-/// # let entity = world.spawn_empty().id();
-/// # #[derive(EntityEvent)]
-/// # struct Explode;
-/// let mut observer = Observer::new(|event: On<Explode>| {});
-/// observer.watch_entity(entity);
-/// world.spawn(observer);
-/// ```
+/// It is important to note that observers, just like [hooks](crate::lifecycle::ComponentHooks),
+/// can watch for and respond to [lifecycle](crate::lifecycle) events.
+/// Unlike hooks, observers are not treated as an "innate" part of component behavior:
+/// they can be added or removed at runtime, and multiple observers
+/// can be registered for the same lifecycle event for the same component.
+///
+/// The ordering of hooks versus observers differs based on the lifecycle event in question:
+///
+/// - when adding components, hooks are evaluated first, then observers
+/// - when removing components, observers are evaluated first, then hooks
+///
+/// This allows hooks to act as constructors and destructors for components,
+/// as they always have the first and final say in the component's lifecycle.
+///
+/// ## Observer re-targeting
+///
+/// Currently, [observers cannot be retargeted after spawning](https://github.com/bevyengine/bevy/issues/19587):
+/// despawn and respawn an observer as a workaround.
 ///
-/// Note that the [`Observer`] component is not added to the entity it is observing. Observers should always be their own entities!
+/// ## Internal observer cache
 ///
-/// You can call [`Observer::watch_entity`] more than once or [`Observer::watch_entities`] to watch multiple entities with the same [`Observer`].
+/// For more efficient observer triggering, Observers make use of the internal [`CachedObservers`](crate::observer::CachedObservers) storage.
+/// In general, this is an implementation detail developers don't need to worry about, but it can be used when implementing custom [`Trigger`](crate::event::Trigger)
+/// types, or to add "dynamic" observers for cases like scripting / modding.
 ///
 /// [`SystemParam`]: crate::system::SystemParam
+/// [`Trigger`]: crate::event::Trigger
 pub struct Observer {
     hook_on_add: ComponentHook,
     pub(crate) error_handler: Option<ErrorHandler>,
@@ -213,8 +214,7 @@ pub struct Observer {
 }
 
 impl Observer {
-    /// Creates a new [`Observer`], which defaults to a "global" observer. This means it will run whenever the event `E` is triggered
-    /// for _any_ entity (or no entity).
+    /// Creates a new [`Observer`], which defaults to a "global" observer. This means it will run _whenever_ an event of type `E` is triggered.
     ///
     /// # Panics
     ///
@@ -240,7 +240,7 @@ impl Observer {
         }
     }
 
-    /// Creates a new [`Observer`] with custom runner, this is mostly used for dynamic event observer
+    /// Creates a new [`Observer`] with custom runner, this is mostly used for dynamic event observers
     pub fn with_dynamic_runner(runner: ObserverRunner) -> Self {
         Self {
             system: Box::new(IntoSystem::into_system(|| {})),
@@ -268,7 +268,7 @@ impl Observer {
     }
 
     /// Observes the given `entity` (in addition to any entity already being observed).
-    /// This will cause the [`Observer`] to run whenever the [`Event`] is triggered for the `entity`.
+    /// This will cause the [`Observer`] to run whenever an [`EntityEvent::event_target`] is the given `entity`.
     /// Note that if this is called _after_ an [`Observer`] is spawned, it will produce no effects.
     pub fn with_entity(mut self, entity: Entity) -> Self {
         self.watch_entity(entity);
@@ -276,7 +276,7 @@ impl Observer {
     }
 
     /// Observes the given `entities` (in addition to any entity already being observed).
-    /// This will cause the [`Observer`] to run whenever the [`Event`] is triggered for any of these `entities`.
+    /// This will cause the [`Observer`] to run whenever an [`EntityEvent::event_target`] is any of the `entities`.
     /// Note that if this is called _after_ an [`Observer`] is spawned, it will produce no effects.
     pub fn with_entities<I: IntoIterator<Item = Entity>>(mut self, entities: I) -> Self {
         self.watch_entities(entities);
@@ -284,21 +284,21 @@ impl Observer {
     }
 
     /// Observes the given `entity` (in addition to any entity already being observed).
-    /// This will cause the [`Observer`] to run whenever the [`Event`] is triggered for the `entity`.
+    /// This will cause the [`Observer`] to run whenever an [`EntityEvent::event_target`] is the given `entity`.
     /// Note that if this is called _after_ an [`Observer`] is spawned, it will produce no effects.
     pub fn watch_entity(&mut self, entity: Entity) {
         self.descriptor.entities.push(entity);
     }
 
     /// Observes the given `entity` (in addition to any entity already being observed).
-    /// This will cause the [`Observer`] to run whenever the [`Event`] is triggered for any of these `entities`.
+    /// This will cause the [`Observer`] to run whenever an [`EntityEvent::event_target`] is any of the `entities`.
     /// Note that if this is called _after_ an [`Observer`] is spawned, it will produce no effects.
     pub fn watch_entities<I: IntoIterator<Item = Entity>>(&mut self, entities: I) {
         self.descriptor.entities.extend(entities);
     }
 
-    /// Observes the given `component`. This will cause the [`Observer`] to run whenever the [`Event`] is triggered
-    /// with the given component target.
+    /// Observes the given `component`. This will cause the [`Observer`] to run whenever the [`Event`] has
+    /// an [`EntityComponentsTrigger`](crate::event::EntityComponentsTrigger) that targets the given `component`.
     pub fn with_component(mut self, component: ComponentId) -> Self {
         self.descriptor.components.push(component);
         self
@@ -435,7 +435,7 @@ fn hook_on_add<E: Event, B: Bundle, S: ObserverSystem<E, B>>(
     HookContext { entity, .. }: HookContext,
 ) {
     world.commands().queue(move |world: &mut World| {
-        let event_key = E::register_event_key(world);
+        let event_key = world.register_event_key::<E>();
         let mut components = alloc::vec![];
         B::component_ids(&mut world.components_registrator(), &mut |id| {
             components.push(id);
diff --git a/crates/bevy_ecs/src/observer/entity_cloning.rs b/crates/bevy_ecs/src/observer/entity_cloning.rs
index 6c75bbd8a4320..7af2d2129c594 100644
--- a/crates/bevy_ecs/src/observer/entity_cloning.rs
+++ b/crates/bevy_ecs/src/observer/entity_cloning.rs
@@ -72,7 +72,11 @@ fn component_clone_observed_by(_source: &SourceComponent, ctx: &mut ComponentClo
 #[cfg(test)]
 mod tests {
     use crate::{
-        entity::EntityCloner, event::EntityEvent, observer::On, resource::Resource, system::ResMut,
+        entity::{Entity, EntityCloner},
+        event::EntityEvent,
+        observer::On,
+        resource::Resource,
+        system::ResMut,
         world::World,
     };
 
@@ -80,7 +84,7 @@ mod tests {
     struct Num(usize);
 
     #[derive(EntityEvent)]
-    struct E;
+    struct E(Entity);
 
     #[test]
     fn clone_entity_with_observer() {
@@ -93,14 +97,15 @@ mod tests {
             .id();
         world.flush();
 
-        world.trigger_targets(E, e);
+        world.trigger(E(e));
 
         let e_clone = world.spawn_empty().id();
         EntityCloner::build_opt_out(&mut world)
             .add_observers(true)
             .clone_entity(e, e_clone);
 
-        world.trigger_targets(E, [e, e_clone]);
+        world.trigger(E(e));
+        world.trigger(E(e_clone));
 
         assert_eq!(world.resource::<Num>().0, 3);
     }
diff --git a/crates/bevy_ecs/src/observer/mod.rs b/crates/bevy_ecs/src/observer/mod.rs
index fe15a67e17c87..43edfdd4ccef6 100644
--- a/crates/bevy_ecs/src/observer/mod.rs
+++ b/crates/bevy_ecs/src/observer/mod.rs
@@ -1,150 +1,22 @@
-//! Observers are a push-based tool for responding to [`Event`]s.
+//! Observers are a push-based tool for responding to [`Event`]s. The [`Observer`] component holds a [`System`] that runs whenever a matching [`Event`]
+//! is triggered.
 //!
-//! ## Observer targeting
-//!
-//! Observers can be "global", listening for events that are both targeted at and not targeted at any specific entity,
-//! or they can be "entity-specific", listening for events that are targeted at specific entities.
-//!
-//! They can also be further refined by listening to events targeted at specific components
-//! (instead of using a generic event type), as is done with the [`Add`] family of lifecycle events.
-//!
-//! When entities are observed, they will receive an [`ObservedBy`] component,
-//! which will be updated to track the observers that are currently observing them.
-//!
-//! Currently, [observers cannot be retargeted after spawning](https://github.com/bevyengine/bevy/issues/19587):
-//! despawn and respawn an observer as a workaround.
-//!
-//! ## Writing observers
-//!
-//! Observers are systems which implement [`IntoObserverSystem`] that listen for [`Event`]s matching their
-//! type and target(s).
-//! To write observer systems, use [`On`] as the first parameter of your system.
-//! This parameter provides access to the specific event that triggered the observer,
-//! as well as the entity that the event was targeted at, if any.
-//!
-//! Observers can request other data from the world, such as via a [`Query`] or [`Res`].
-//! Commonly, you might want to verify that the entity that the observable event is targeting
-//! has a specific component, or meets some other condition. [`Query::get`] or [`Query::contains`]
-//! on the [`On::entity`] entity is a good way to do this.
-//!
-//! [`Commands`] can also be used inside of observers.
-//! This can be particularly useful for triggering other observers!
-//!
-//! ## Spawning observers
-//!
-//! Observers can be spawned via [`World::add_observer`], or the equivalent app method.
-//! This will cause an entity with the [`Observer`] component to be created,
-//! which will then run the observer system whenever the event it is watching is triggered.
-//!
-//! You can control the targets that an observer is watching by calling [`Observer::watch_entity`]
-//! once the entity is spawned, or by manually spawning an entity with the [`Observer`] component
-//! configured with the desired targets.
-//!
-//! Observers are fundamentally defined as "entities which have the [`Observer`] component"
-//! allowing you to add it manually to existing entities.
-//! At first, this seems convenient, but only one observer can be added to an entity at a time,
-//! regardless of the event it responds to: like always, components are unique.
-//!
-//! Instead, a better way to achieve a similar aim is to
-//! use the [`EntityWorldMut::observe`] / [`EntityCommands::observe`] method,
-//! which spawns a new observer, and configures it to watch the entity it is called on.
-//! Unfortunately, observers defined in this way
-//! [currently cannot be spawned as part of bundles](https://github.com/bevyengine/bevy/issues/14204).
-//!
-//! ## Triggering observers
-//!
-//! Observers are most commonly triggered by [`Commands`],
-//! via [`Commands::trigger`] (for untargeted [`Event`]s) or [`Commands::trigger_targets`] (for targeted [`EntityEvent`]s).
-//! Like usual, equivalent methods are available on [`World`], allowing you to reduce overhead when working with exclusive world access.
-//!
-//! If your observer is configured to watch for a specific component or set of components instead,
-//! you can pass in [`ComponentId`]s into [`Commands::trigger_targets`] by using the [`TriggerTargets`] trait.
-//! As discussed in the [`On`] documentation, this use case is rare, and is currently only used
-//! for [lifecycle](crate::lifecycle) events, which are automatically emitted.
-//!
-//! ## Observer bubbling
-//!
-//! When using an [`EntityEvent`] targeted at an entity, the event can optionally be propagated to other targets,
-//! typically up to parents in an entity hierarchy.
-//!
-//! This behavior is controlled via [`EntityEvent::Traversal`] and [`EntityEvent::AUTO_PROPAGATE`],
-//! with the details of the propagation path specified by the [`Traversal`](crate::traversal::Traversal) trait.
-//!
-//! When auto-propagation is enabled, propagation must be manually stopped to prevent the event from
-//! continuing to other targets. This can be done using the [`On::propagate`] method inside of your observer.
-//!
-//! ## Observer timing
-//!
-//! Observers are triggered via [`Commands`], which imply that they are evaluated at the next sync point in the ECS schedule.
-//! Accordingly, they have full access to the world, and are evaluated sequentially, in the order that the commands were sent.
-//!
-//! To control the relative ordering of observers sent from different systems,
-//! order the systems in the schedule relative to each other.
-//!
-//! Currently, Bevy does not provide [a way to specify the ordering of observers](https://github.com/bevyengine/bevy/issues/14890)
-//! listening to the same event relative to each other.
-//!
-//! Commands sent by observers are [currently not immediately applied](https://github.com/bevyengine/bevy/issues/19569).
-//! Instead, all queued observers will run, and then all of the commands from those observers will be applied.
-//! Careful use of [`Schedule::apply_deferred`] may help as a workaround.
-//!
-//! ## Lifecycle events and observers
-//!
-//! It is important to note that observers, just like [hooks](crate::lifecycle::ComponentHooks),
-//! can listen to and respond to [lifecycle](crate::lifecycle) events.
-//! Unlike hooks, observers are not treated as an "innate" part of component behavior:
-//! they can be added or removed at runtime, and multiple observers
-//! can be registered for the same lifecycle event for the same component.
-//!
-//! The ordering of hooks versus observers differs based on the lifecycle event in question:
-//!
-//! - when adding components, hooks are evaluated first, then observers
-//! - when removing components, observers are evaluated first, then hooks
-//!
-//! This allows hooks to act as constructors and destructors for components,
-//! as they always have the first and final say in the component's lifecycle.
-//!
-//! ## Cleaning up observers
-//!
-//! Currently, observer entities are never cleaned up, even if their target entity(s) are despawned.
-//! This won't cause any runtime overhead, but is a waste of memory and can result in memory leaks.
-//!
-//! If you run into this problem, you could manually scan the world for observer entities and despawn them,
-//! by checking if the entity in [`Observer::descriptor`] still exists.
-//!
-//! ## Observers vs buffered events
-//!
-//! By contrast, [`EventReader`] and [`EventWriter`] ("buffered events"), are pull-based.
-//! They require periodically polling the world to check for new events, typically in a system that runs as part of a schedule.
-//!
-//! This imposes a small overhead, making observers a better choice for extremely rare events,
-//! but buffered events can be more efficient for events that are expected to occur multiple times per frame,
-//! as it allows for batch processing of events.
-//!
-//! The difference in timing is also an important consideration:
-//! buffered events are evaluated at fixed points during schedules,
-//! while observers are evaluated as soon as possible after the event is triggered.
-//!
-//! This provides more control over the timing of buffered event evaluation,
-//! but allows for a more ad hoc approach with observers,
-//! and enables indefinite chaining of observers triggering other observers (for both better and worse!).
+//! See [`Event`] and [`Observer`] for in-depth documentation and usage examples.
 
 mod centralized_storage;
 mod distributed_storage;
 mod entity_cloning;
 mod runner;
 mod system_param;
-mod trigger_targets;
 
 pub use centralized_storage::*;
 pub use distributed_storage::*;
 pub use runner::*;
 pub use system_param::*;
-pub use trigger_targets::*;
 
 use crate::{
     change_detection::MaybeLocation,
-    component::ComponentId,
+    event::Event,
     prelude::*,
     system::IntoObserverSystem,
     world::{DeferredWorld, *},
@@ -156,10 +28,6 @@ impl World {
     ///
     /// `system` can be any system whose first parameter is [`On`].
     ///
-    /// **Calling [`observe`](EntityWorldMut::observe) on the returned
-    /// [`EntityWorldMut`] will observe the observer itself, which you very
-    /// likely do not want.**
-    ///
     /// # Example
     ///
     /// ```
@@ -176,6 +44,10 @@ impl World {
     /// });
     /// ```
     ///
+    /// **Calling [`observe`](EntityWorldMut::observe) on the returned
+    /// [`EntityWorldMut`] will observe the observer itself, which you very
+    /// likely do not want.**
+    ///
     /// # Panics
     ///
     /// Panics if the given system is an exclusive system.
@@ -188,179 +60,66 @@ impl World {
 
     /// Triggers the given [`Event`], which will run any [`Observer`]s watching for it.
     ///
-    /// While event types commonly implement [`Copy`],
-    /// those that don't will be consumed and will no longer be accessible.
-    /// If you need to use the event after triggering it, use [`World::trigger_ref`] instead.
+    /// For a variant that borrows the `event` rather than consuming it, use [`World::trigger_ref`] instead.
     #[track_caller]
-    pub fn trigger<E: Event>(&mut self, event: E) {
-        self.trigger_with_caller(event, MaybeLocation::caller());
-    }
-
-    pub(crate) fn trigger_with_caller<E: Event>(&mut self, mut event: E, caller: MaybeLocation) {
-        let event_key = E::register_event_key(self);
-        // SAFETY: We just registered `event_key` with the type of `event`
-        unsafe {
-            self.trigger_dynamic_ref_with_caller(event_key, &mut event, caller);
-        }
+    pub fn trigger<'a, E: Event<Trigger<'a>: Default>>(&mut self, mut event: E) {
+        self.trigger_ref_with_caller(
+            &mut event,
+            &mut <E::Trigger<'a> as Default>::default(),
+            MaybeLocation::caller(),
+        );
     }
 
-    /// Triggers the given [`Event`] as a mutable reference, which will run any [`Observer`]s watching for it.
+    /// A deprecated alias for [`trigger`](Self::trigger) to ease migration.
     ///
-    /// Compared to [`World::trigger`], this method is most useful when it's necessary to check
-    /// or use the event after it has been modified by observers.
-    #[track_caller]
-    pub fn trigger_ref<E: Event>(&mut self, event: &mut E) {
-        let event_key = E::register_event_key(self);
-        // SAFETY: We just registered `event_key` with the type of `event`
-        unsafe { self.trigger_dynamic_ref_with_caller(event_key, event, MaybeLocation::caller()) };
-    }
-
-    unsafe fn trigger_dynamic_ref_with_caller<E: Event>(
-        &mut self,
-        event_key: EventKey,
-        event_data: &mut E,
-        caller: MaybeLocation,
-    ) {
-        let mut world = DeferredWorld::from(self);
-        // SAFETY: `event_data` is accessible as the type represented by `event_key`
-        unsafe {
-            world.trigger_observers_with_data::<_, ()>(
-                event_key,
-                None,
-                None,
-                core::iter::empty::<ComponentId>(),
-                event_data,
-                false,
-                caller,
-            );
-        };
+    /// Instead of specifying the trigger target separately,
+    /// information about the target of the event is embedded in the data held by
+    /// the event type itself.
+    #[deprecated(since = "0.17.0", note = "Use `World::trigger` instead.")]
+    pub fn trigger_targets<'a>(&mut self, event: impl Event<Trigger<'a>: Default>) {
+        self.trigger(event);
     }
 
-    /// Triggers the given [`EntityEvent`] for the given `targets`, which will run any [`Observer`]s watching for it.
+    /// Triggers the given [`Event`] using the given [`Trigger`](crate::event::Trigger), which will run any [`Observer`]s watching for it.
     ///
-    /// While event types commonly implement [`Copy`],
-    /// those that don't will be consumed and will no longer be accessible.
-    /// If you need to use the event after triggering it, use [`World::trigger_targets_ref`] instead.
+    /// For a variant that borrows the `event` rather than consuming it, use [`World::trigger_ref`] instead.
     #[track_caller]
-    pub fn trigger_targets<E: EntityEvent>(&mut self, event: E, targets: impl TriggerTargets) {
-        self.trigger_targets_with_caller(event, targets, MaybeLocation::caller());
-    }
-
-    pub(crate) fn trigger_targets_with_caller<E: EntityEvent>(
-        &mut self,
-        mut event: E,
-        targets: impl TriggerTargets,
-        caller: MaybeLocation,
-    ) {
-        let event_key = E::register_event_key(self);
-        // SAFETY: We just registered `event_key` with the type of `event`
-        unsafe {
-            self.trigger_targets_dynamic_ref_with_caller(event_key, &mut event, targets, caller);
-        }
+    pub fn trigger_with<'a, E: Event>(&mut self, mut event: E, mut trigger: E::Trigger<'a>) {
+        self.trigger_ref_with_caller(&mut event, &mut trigger, MaybeLocation::caller());
     }
 
-    /// Triggers the given [`EntityEvent`] as a mutable reference for the given `targets`,
-    /// which will run any [`Observer`]s watching for it.
+    /// Triggers the given mutable [`Event`] reference, which will run any [`Observer`]s watching for it.
     ///
-    /// Compared to [`World::trigger_targets`], this method is most useful when it's necessary to check
+    /// Compared to [`World::trigger`], this method is most useful when it's necessary to check
     /// or use the event after it has been modified by observers.
     #[track_caller]
-    pub fn trigger_targets_ref<E: EntityEvent>(
-        &mut self,
-        event: &mut E,
-        targets: impl TriggerTargets,
-    ) {
-        let event_key = E::register_event_key(self);
-        // SAFETY: We just registered `event_key` with the type of `event`
-        unsafe { self.trigger_targets_dynamic_ref(event_key, event, targets) };
-    }
-
-    /// Triggers the given [`EntityEvent`] for the given `targets`, which will run any [`Observer`]s watching for it.
-    ///
-    /// While event types commonly implement [`Copy`],
-    /// those that don't will be consumed and will no longer be accessible.
-    /// If you need to use the event after triggering it, use [`World::trigger_targets_dynamic_ref`] instead.
-    ///
-    /// # Safety
-    ///
-    /// Caller must ensure that `event_data` is accessible as the type represented by `event_key`.
-    #[track_caller]
-    pub unsafe fn trigger_targets_dynamic<E: EntityEvent, Targets: TriggerTargets>(
-        &mut self,
-        event_key: EventKey,
-        mut event_data: E,
-        targets: Targets,
-    ) {
-        // SAFETY: `event_data` is accessible as the type represented by `event_key`
-        unsafe {
-            self.trigger_targets_dynamic_ref(event_key, &mut event_data, targets);
-        };
+    pub fn trigger_ref<'a, E: Event<Trigger<'a>: Default>>(&mut self, event: &mut E) {
+        self.trigger_ref_with_caller(
+            event,
+            &mut <E::Trigger<'a> as Default>::default(),
+            MaybeLocation::caller(),
+        );
     }
 
-    /// Triggers the given [`EntityEvent`] as a mutable reference for the given `targets`,
-    /// which will run any [`Observer`]s watching for it.
+    /// Triggers the given mutable [`Event`] reference using the given mutable [`Trigger`](crate::event::Trigger) reference, which
+    /// will run any [`Observer`]s watching for it.
     ///
-    /// Compared to [`World::trigger_targets_dynamic`], this method is most useful when it's necessary to check
+    /// Compared to [`World::trigger`], this method is most useful when it's necessary to check
     /// or use the event after it has been modified by observers.
-    ///
-    /// # Safety
-    ///
-    /// Caller must ensure that `event_data` is accessible as the type represented by `event_key`.
-    #[track_caller]
-    pub unsafe fn trigger_targets_dynamic_ref<E: EntityEvent, Targets: TriggerTargets>(
-        &mut self,
-        event_key: EventKey,
-        event_data: &mut E,
-        targets: Targets,
-    ) {
-        self.trigger_targets_dynamic_ref_with_caller(
-            event_key,
-            event_data,
-            targets,
-            MaybeLocation::caller(),
-        );
+    pub fn trigger_ref_with<'a, E: Event>(&mut self, event: &mut E, trigger: &mut E::Trigger<'a>) {
+        self.trigger_ref_with_caller(event, trigger, MaybeLocation::caller());
     }
 
-    /// # Safety
-    ///
-    /// See `trigger_targets_dynamic_ref`
-    unsafe fn trigger_targets_dynamic_ref_with_caller<E: EntityEvent, Targets: TriggerTargets>(
+    pub(crate) fn trigger_ref_with_caller<'a, E: Event>(
         &mut self,
-        event_key: EventKey,
-        event_data: &mut E,
-        targets: Targets,
+        event: &mut E,
+        trigger: &mut E::Trigger<'a>,
         caller: MaybeLocation,
     ) {
-        let mut world = DeferredWorld::from(self);
-        let mut entity_targets = targets.entities().peekable();
-        if entity_targets.peek().is_none() {
-            // SAFETY: `event_data` is accessible as the type represented by `event_key`
-            unsafe {
-                world.trigger_observers_with_data::<_, E::Traversal>(
-                    event_key,
-                    None,
-                    None,
-                    targets.components(),
-                    event_data,
-                    false,
-                    caller,
-                );
-            };
-        } else {
-            for target_entity in entity_targets {
-                // SAFETY: `event_data` is accessible as the type represented by `event_key`
-                unsafe {
-                    world.trigger_observers_with_data::<_, E::Traversal>(
-                        event_key,
-                        Some(target_entity),
-                        Some(target_entity),
-                        targets.components(),
-                        event_data,
-                        E::AUTO_PROPAGATE,
-                        caller,
-                    );
-                };
-            }
+        let event_key = self.register_event_key::<E>();
+        // SAFETY: event_key was just registered and matches `event`
+        unsafe {
+            DeferredWorld::from(self).trigger_raw(event_key, event, trigger, caller);
         }
     }
 
@@ -476,7 +235,7 @@ impl World {
                                     let archetype = &mut archetypes.archetypes[archetype.index()];
                                     if archetype.contains(*component) {
                                         let no_longer_observed = archetype
-                                            .components()
+                                            .iter_components()
                                             .all(|id| !cache.component_observers.contains_key(&id));
 
                                         if no_longer_observed {
@@ -497,16 +256,16 @@ impl World {
 mod tests {
     use alloc::{vec, vec::Vec};
 
-    use bevy_platform::collections::HashMap;
     use bevy_ptr::OwningPtr;
 
     use crate::{
         change_detection::MaybeLocation,
-        component::ComponentId,
         entity_disabling::Internal,
+        event::{EntityComponentsTrigger, Event, GlobalTrigger},
+        hierarchy::ChildOf,
         observer::{Observer, Replace},
         prelude::*,
-        traversal::Traversal,
+        world::DeferredWorld,
     };
 
     #[derive(Component)]
@@ -519,10 +278,17 @@ mod tests {
     #[component(storage = "SparseSet")]
     struct S;
 
-    #[derive(EntityEvent)]
+    #[derive(Event)]
     struct EventA;
 
     #[derive(EntityEvent)]
+    struct EntityEventA(Entity);
+
+    #[derive(EntityEvent)]
+    #[entity_event(trigger = EntityComponentsTrigger<'a>)]
+    struct EntityComponentsEvent(Entity);
+
+    #[derive(Event)]
     struct EventWithData {
         counter: usize,
     }
@@ -537,18 +303,9 @@ mod tests {
         }
     }
 
-    #[derive(Component)]
-    struct ChildOf(Entity);
-
-    impl<D> Traversal<D> for &'_ ChildOf {
-        fn traverse(item: Self::Item<'_, '_>, _: &D) -> Option<Entity> {
-            Some(item.0)
-        }
-    }
-
     #[derive(Component, EntityEvent)]
-    #[entity_event(traversal = &'static ChildOf, auto_propagate)]
-    struct EventPropagating;
+    #[entity_event(propagate, auto_propagate)]
+    struct EventPropagating(Entity);
 
     #[test]
     fn observer_order_spawn_despawn() {
@@ -639,22 +396,22 @@ mod tests {
         let mut world = World::new();
         world.init_resource::<Order>();
         world.add_observer(
-            |obs: On<Add, A>, mut res: ResMut<Order>, mut commands: Commands| {
+            |add: On<Add, A>, mut res: ResMut<Order>, mut commands: Commands| {
                 res.observed("add_a");
-                commands.entity(obs.entity()).insert(B);
+                commands.entity(add.entity).insert(B);
             },
         );
         world.add_observer(
-            |obs: On<Remove, A>, mut res: ResMut<Order>, mut commands: Commands| {
+            |remove: On<Remove, A>, mut res: ResMut<Order>, mut commands: Commands| {
                 res.observed("remove_a");
-                commands.entity(obs.entity()).remove::<B>();
+                commands.entity(remove.entity).remove::<B>();
             },
         );
 
         world.add_observer(
-            |obs: On<Add, B>, mut res: ResMut<Order>, mut commands: Commands| {
+            |add: On<Add, B>, mut res: ResMut<Order>, mut commands: Commands| {
                 res.observed("add_b");
-                commands.entity(obs.entity()).remove::<A>();
+                commands.entity(add.entity).remove::<A>();
             },
         );
         world.add_observer(|_: On<Remove, B>, mut res: ResMut<Order>| {
@@ -684,26 +441,6 @@ mod tests {
         assert_eq!(7, event.counter);
     }
 
-    #[test]
-    fn observer_trigger_targets_ref() {
-        let mut world = World::new();
-
-        world.add_observer(|mut event: On<EventWithData, A>| {
-            event.counter += 1;
-        });
-        world.add_observer(|mut event: On<EventWithData, B>| {
-            event.counter += 2;
-        });
-        world.add_observer(|mut event: On<EventWithData, A>| {
-            event.counter += 4;
-        });
-
-        let mut event = EventWithData { counter: 0 };
-        let component_a = world.register_component::<A>();
-        world.trigger_targets_ref(&mut event, component_a);
-        assert_eq!(5, event.counter);
-    }
-
     #[test]
     fn observer_multiple_listeners() {
         let mut world = World::new();
@@ -729,7 +466,7 @@ mod tests {
     fn observer_multiple_events() {
         let mut world = World::new();
         world.init_resource::<Order>();
-        let on_remove = Remove::register_event_key(&mut world);
+        let on_remove = world.register_event_key::<Remove>();
         world.spawn(
             // SAFETY: Add and Remove are both unit types, so this is safe
             unsafe {
@@ -813,44 +550,26 @@ mod tests {
         assert_eq!(vec!["add_ab"], world.resource::<Order>().0);
     }
 
-    #[test]
-    fn observer_no_target() {
-        let mut world = World::new();
-        world.init_resource::<Order>();
-
-        let system: fn(On<EventA>) = |_| {
-            panic!("Trigger routed to non-targeted entity.");
-        };
-        world.spawn_empty().observe(system);
-        world.add_observer(move |obs: On<EventA>, mut res: ResMut<Order>| {
-            assert_eq!(obs.entity(), Entity::PLACEHOLDER);
-            res.observed("event_a");
-        });
-
-        world.trigger(EventA);
-        assert_eq!(vec!["event_a"], world.resource::<Order>().0);
-    }
-
     #[test]
     fn observer_entity_routing() {
         let mut world = World::new();
         world.init_resource::<Order>();
 
-        let system: fn(On<EventA>) = |_| {
+        let system: fn(On<EntityEventA>) = |_| {
             panic!("Trigger routed to non-targeted entity.");
         };
 
         world.spawn_empty().observe(system);
         let entity = world
             .spawn_empty()
-            .observe(|_: On<EventA>, mut res: ResMut<Order>| res.observed("a_1"))
+            .observe(|_: On<EntityEventA>, mut res: ResMut<Order>| res.observed("a_1"))
             .id();
-        world.add_observer(move |obs: On<EventA>, mut res: ResMut<Order>| {
-            assert_eq!(obs.entity(), entity);
+        world.add_observer(move |event: On<EntityEventA>, mut res: ResMut<Order>| {
+            assert_eq!(event.event_target(), entity);
             res.observed("a_2");
         });
 
-        world.trigger_targets(EventA, entity);
+        world.trigger(EntityEventA(entity));
         assert_eq!(vec!["a_2", "a_1"], world.resource::<Order>().0);
     }
 
@@ -867,93 +586,72 @@ mod tests {
         // targets (entity_1, A)
         let entity_1 = world
             .spawn_empty()
-            .observe(|_: On<EventA, A>, mut res: ResMut<R>| res.0 += 1)
+            .observe(|_: On<EntityComponentsEvent, A>, mut res: ResMut<R>| res.0 += 1)
             .id();
         // targets (entity_2, B)
         let entity_2 = world
             .spawn_empty()
-            .observe(|_: On<EventA, B>, mut res: ResMut<R>| res.0 += 10)
+            .observe(|_: On<EntityComponentsEvent, B>, mut res: ResMut<R>| res.0 += 10)
             .id();
         // targets any entity or component
-        world.add_observer(|_: On<EventA>, mut res: ResMut<R>| res.0 += 100);
+        world.add_observer(|_: On<EntityComponentsEvent>, mut res: ResMut<R>| res.0 += 100);
         // targets any entity, and components A or B
-        world.add_observer(|_: On<EventA, (A, B)>, mut res: ResMut<R>| res.0 += 1000);
+        world
+            .add_observer(|_: On<EntityComponentsEvent, (A, B)>, mut res: ResMut<R>| res.0 += 1000);
         // test all tuples
-        world.add_observer(|_: On<EventA, (A, B, (A, B))>, mut res: ResMut<R>| res.0 += 10000);
         world.add_observer(
-            |_: On<EventA, (A, B, (A, B), ((A, B), (A, B)))>, mut res: ResMut<R>| {
+            |_: On<EntityComponentsEvent, (A, B, (A, B))>, mut res: ResMut<R>| res.0 += 10000,
+        );
+        world.add_observer(
+            |_: On<EntityComponentsEvent, (A, B, (A, B), ((A, B), (A, B)))>, mut res: ResMut<R>| {
                 res.0 += 100000;
             },
         );
         world.add_observer(
-            |_: On<EventA, (A, B, (A, B), (B, A), (A, B, ((A, B), (B, A))))>,
+            |_: On<EntityComponentsEvent, (A, B, (A, B), (B, A), (A, B, ((A, B), (B, A))))>,
              mut res: ResMut<R>| res.0 += 1000000,
         );
 
         // trigger for an entity and a component
-        world.trigger_targets(EventA, (entity_1, component_a));
+        world.trigger_with(
+            EntityComponentsEvent(entity_1),
+            EntityComponentsTrigger {
+                components: &[component_a],
+            },
+        );
         // only observer that doesn't trigger is the one only watching entity_2
         assert_eq!(1111101, world.resource::<R>().0);
         world.resource_mut::<R>().0 = 0;
 
         // trigger for both entities, but no components: trigger once per entity target
-        world.trigger_targets(EventA, (entity_1, entity_2));
+        world.trigger_with(
+            EntityComponentsEvent(entity_1),
+            EntityComponentsTrigger { components: &[] },
+        );
+        world.trigger_with(
+            EntityComponentsEvent(entity_2),
+            EntityComponentsTrigger { components: &[] },
+        );
+
         // only the observer that doesn't require components triggers - once per entity
         assert_eq!(200, world.resource::<R>().0);
         world.resource_mut::<R>().0 = 0;
 
-        // trigger for both components, but no entities: trigger once
-        world.trigger_targets(EventA, (component_a, component_b));
-        // all component observers trigger, entities are not observed
-        assert_eq!(1111100, world.resource::<R>().0);
-        world.resource_mut::<R>().0 = 0;
-
         // trigger for both entities and both components: trigger once per entity target
         // we only get 2222211 because a given observer can trigger only once per entity target
-        world.trigger_targets(EventA, ((component_a, component_b), (entity_1, entity_2)));
-        assert_eq!(2222211, world.resource::<R>().0);
-        world.resource_mut::<R>().0 = 0;
-
-        // trigger to test complex tuples: (A, B, (A, B))
-        world.trigger_targets(
-            EventA,
-            (component_a, component_b, (component_a, component_b)),
-        );
-        // the duplicate components in the tuple don't cause multiple triggers
-        assert_eq!(1111100, world.resource::<R>().0);
-        world.resource_mut::<R>().0 = 0;
-
-        // trigger to test complex tuples: (A, B, (A, B), ((A, B), (A, B)))
-        world.trigger_targets(
-            EventA,
-            (
-                component_a,
-                component_b,
-                (component_a, component_b),
-                ((component_a, component_b), (component_a, component_b)),
-            ),
+        world.trigger_with(
+            EntityComponentsEvent(entity_1),
+            EntityComponentsTrigger {
+                components: &[component_a, component_b],
+            },
         );
-        // the duplicate components in the tuple don't cause multiple triggers
-        assert_eq!(1111100, world.resource::<R>().0);
-        world.resource_mut::<R>().0 = 0;
-
-        // trigger to test the most complex tuple: (A, B, (A, B), (B, A), (A, B, ((A, B), (B, A))))
-        world.trigger_targets(
-            EventA,
-            (
-                component_a,
-                component_b,
-                (component_a, component_b),
-                (component_b, component_a),
-                (
-                    component_a,
-                    component_b,
-                    ((component_a, component_b), (component_b, component_a)),
-                ),
-            ),
+        world.trigger_with(
+            EntityComponentsEvent(entity_2),
+            EntityComponentsTrigger {
+                components: &[component_a, component_b],
+            },
         );
-        // the duplicate components in the tuple don't cause multiple triggers
-        assert_eq!(1111100, world.resource::<R>().0);
+        assert_eq!(2222211, world.resource::<R>().0);
         world.resource_mut::<R>().0 = 0;
     }
 
@@ -973,9 +671,7 @@ mod tests {
             // SAFETY: we registered `component_id` above.
             unsafe { entity.insert_by_id(component_id, ptr) };
         });
-        let entity = entity.flush();
 
-        world.trigger_targets(EventA, entity);
         assert_eq!(vec!["event_a"], world.resource::<Order>().0);
     }
 
@@ -983,20 +679,29 @@ mod tests {
     fn observer_dynamic_trigger() {
         let mut world = World::new();
         world.init_resource::<Order>();
-        let event_a = Remove::register_event_key(&mut world);
+        let event_a = world.register_event_key::<EventA>();
 
         // SAFETY: we registered `event_a` above and it matches the type of EventA
         let observe = unsafe {
-            Observer::with_dynamic_runner(|mut world, _trigger, _ptr, _propagate| {
-                world.resource_mut::<Order>().observed("event_a");
-            })
+            Observer::with_dynamic_runner(
+                |mut world, _observer, _trigger_context, _event, _trigger| {
+                    world.resource_mut::<Order>().observed("event_a");
+                },
+            )
             .with_event_key(event_a)
         };
         world.spawn(observe);
 
         world.commands().queue(move |world: &mut World| {
             // SAFETY: we registered `event_a` above and it matches the type of EventA
-            unsafe { world.trigger_targets_dynamic(event_a, EventA, ()) };
+            unsafe {
+                DeferredWorld::from(world).trigger_raw(
+                    event_a,
+                    &mut EventA,
+                    &mut GlobalTrigger,
+                    MaybeLocation::caller(),
+                );
+            }
         });
         world.flush();
         assert_eq!(vec!["event_a"], world.resource::<Order>().0);
@@ -1014,20 +719,20 @@ mod tests {
             move |event: On<EventPropagating>, mut res: ResMut<Order>| {
                 res.observed("parent");
 
-                assert_eq!(event.entity(), parent);
-                assert_eq!(event.original_entity(), child);
+                assert_eq!(event.event_target(), parent);
+                assert_eq!(event.original_event_target(), child);
             },
         );
 
         world.entity_mut(child).observe(
             move |event: On<EventPropagating>, mut res: ResMut<Order>| {
                 res.observed("child");
-                assert_eq!(event.entity(), child);
-                assert_eq!(event.original_entity(), child);
+                assert_eq!(event.event_target(), child);
+                assert_eq!(event.original_event_target(), child);
             },
         );
 
-        world.trigger_targets(EventPropagating, child);
+        world.trigger(EventPropagating(child));
 
         assert_eq!(vec!["child", "parent"], world.resource::<Order>().0);
     }
@@ -1051,7 +756,8 @@ mod tests {
             })
             .id();
 
-        world.trigger_targets(EventPropagating, [child, child]);
+        world.trigger(EventPropagating(child));
+        world.trigger(EventPropagating(child));
 
         assert_eq!(
             vec!["child", "parent", "child", "parent"],
@@ -1078,7 +784,9 @@ mod tests {
             })
             .id();
 
-        world.trigger_targets(EventPropagating, [child, parent]);
+        world.trigger(EventPropagating(child));
+        world.trigger(EventPropagating(parent));
+
         assert_eq!(
             vec!["child", "parent", "parent"],
             world.resource::<Order>().0
@@ -1105,7 +813,7 @@ mod tests {
             })
             .id();
 
-        world.trigger_targets(EventPropagating, child);
+        world.trigger(EventPropagating(child));
 
         assert_eq!(vec!["child"], world.resource::<Order>().0);
     }
@@ -1136,7 +844,8 @@ mod tests {
             })
             .id();
 
-        world.trigger_targets(EventPropagating, [child_a, child_b]);
+        world.trigger(EventPropagating(child_a));
+        world.trigger(EventPropagating(child_b));
 
         assert_eq!(
             vec!["child_a", "parent", "child_b", "parent"],
@@ -1156,7 +865,7 @@ mod tests {
             })
             .id();
 
-        world.trigger_targets(EventPropagating, entity);
+        world.trigger(EventPropagating(entity));
         assert_eq!(vec!["event"], world.resource::<Order>().0);
     }
 
@@ -1194,7 +903,8 @@ mod tests {
             })
             .id();
 
-        world.trigger_targets(EventPropagating, [child_a, child_b]);
+        world.trigger(EventPropagating(child_a));
+        world.trigger(EventPropagating(child_b));
 
         assert_eq!(
             vec!["child_a", "child_b", "parent_b"],
@@ -1215,7 +925,7 @@ mod tests {
         let parent = world.spawn(ChildOf(grandparent)).id();
         let child = world.spawn(ChildOf(parent)).id();
 
-        world.trigger_targets(EventPropagating, child);
+        world.trigger(EventPropagating(child));
 
         assert_eq!(vec!["event", "event", "event"], world.resource::<Order>().0);
     }
@@ -1227,7 +937,7 @@ mod tests {
 
         world.add_observer(
             |event: On<EventPropagating>, query: Query<&A>, mut res: ResMut<Order>| {
-                if query.get(event.entity()).is_ok() {
+                if query.get(event.event_target()).is_ok() {
                     res.observed("event");
                 }
             },
@@ -1237,7 +947,7 @@ mod tests {
         let parent = world.spawn(ChildOf(grandparent)).id();
         let child = world.spawn((A, ChildOf(parent))).id();
 
-        world.trigger_targets(EventPropagating, child);
+        world.trigger(EventPropagating(child));
 
         assert_eq!(vec!["event", "event"], world.resource::<Order>().0);
     }
@@ -1245,9 +955,9 @@ mod tests {
     // Originally for https://github.com/bevyengine/bevy/issues/18452
     #[test]
     fn observer_modifies_relationship() {
-        fn on_add(event: On<Add, A>, mut commands: Commands) {
+        fn on_add(add: On<Add, A>, mut commands: Commands) {
             commands
-                .entity(event.entity())
+                .entity(add.entity)
                 .with_related_entities::<crate::hierarchy::ChildOf>(|rsc| {
                     rsc.spawn_empty();
                 });
@@ -1346,33 +1056,6 @@ mod tests {
         world.commands().spawn(Component).clear();
     }
 
-    #[test]
-    fn observer_triggered_components() {
-        #[derive(Resource, Default)]
-        struct Counter(HashMap<ComponentId, usize>);
-
-        let mut world = World::new();
-        world.init_resource::<Counter>();
-        let a_id = world.register_component::<A>();
-        let b_id = world.register_component::<B>();
-
-        world.add_observer(|event: On<EventA, (A, B)>, mut counter: ResMut<Counter>| {
-            for &component in event.components() {
-                *counter.0.entry(component).or_default() += 1;
-            }
-        });
-
-        world.trigger_targets(EventA, [a_id, b_id]);
-        world.trigger_targets(EventA, a_id);
-        world.trigger_targets(EventA, b_id);
-        world.trigger_targets(EventA, [a_id, b_id]);
-        world.trigger_targets(EventA, a_id);
-
-        let counter = world.resource::<Counter>();
-        assert_eq!(4, *counter.0.get(&a_id).unwrap());
-        assert_eq!(3, *counter.0.get(&b_id).unwrap());
-    }
-
     #[test]
     fn observer_watch_entities() {
         let mut world = World::new();
@@ -1380,14 +1063,16 @@ mod tests {
         let entities = world
             .spawn_batch(core::iter::repeat_n((), 4))
             .collect::<Vec<_>>();
-        let observer = Observer::new(|_: On<EventA>, mut order: ResMut<Order>| {
+        let observer = Observer::new(|_: On<EntityEventA>, mut order: ResMut<Order>| {
             order.observed("a");
         });
         world.spawn(observer.with_entities(entities.iter().copied().take(2)));
 
-        world.trigger_targets(EventA, [entities[0], entities[1]]);
+        world.trigger(EntityEventA(entities[0]));
+        world.trigger(EntityEventA(entities[1]));
         assert_eq!(vec!["a", "a"], world.resource::<Order>().0);
-        world.trigger_targets(EventA, [entities[2], entities[3]]);
+        world.trigger(EntityEventA(entities[2]));
+        world.trigger(EntityEventA(entities[3]));
         assert_eq!(vec!["a", "a"], world.resource::<Order>().0);
     }
 
@@ -1397,7 +1082,7 @@ mod tests {
         let mut observer = world.add_observer(|_: On<EventA>| {});
         observer.remove::<Observer>();
         let id = observer.id();
-        let event_key = EventA::event_key(&world).unwrap();
+        let event_key = world.event_key::<EventA>().unwrap();
         assert!(!world
             .observers
             .get_observers_mut(event_key)
@@ -1412,7 +1097,7 @@ mod tests {
         let observer = Observer::new(|_: On<EventA>| {}).with_entity(entity);
         let mut observer = world.spawn(observer);
         observer.remove::<Observer>();
-        let event_key = EventA::event_key(&world).unwrap();
+        let event_key = world.event_key::<EventA>().unwrap();
         assert!(!world
             .observers
             .get_observers_mut(event_key)
@@ -1427,11 +1112,11 @@ mod tests {
         let observer = Observer::new(|_: On<EventA>| {}).with_component(a);
         let mut observer = world.spawn(observer);
         observer.remove::<Observer>();
-        let event_key = EventA::event_key(&world).unwrap();
+        let event_key = world.event_key::<EventA>().unwrap();
         assert!(!world
             .observers
             .get_observers_mut(event_key)
-            .get_component_observers()
+            .component_observers()
             .contains_key(&a));
     }
 }
diff --git a/crates/bevy_ecs/src/observer/runner.rs b/crates/bevy_ecs/src/observer/runner.rs
index 7f2536f5f8318..dfffe3bec60cd 100644
--- a/crates/bevy_ecs/src/observer/runner.rs
+++ b/crates/bevy_ecs/src/observer/runner.rs
@@ -4,7 +4,8 @@ use core::any::Any;
 
 use crate::{
     error::ErrorContext,
-    observer::ObserverTrigger,
+    event::Event,
+    observer::TriggerContext,
     prelude::*,
     query::DebugCheckedUnwrap,
     system::{ObserverSystem, RunSystemError},
@@ -16,21 +17,32 @@ use bevy_ptr::PtrMut;
 ///
 /// Typically refers to the default runner that runs the system stored in the associated [`Observer`] component,
 /// but can be overridden for custom behavior.
-pub type ObserverRunner = fn(DeferredWorld, ObserverTrigger, PtrMut, propagate: &mut bool);
+///
+/// See `observer_system_runner` for safety considerations.
+pub type ObserverRunner =
+    unsafe fn(DeferredWorld, observer: Entity, &TriggerContext, event: PtrMut, trigger: PtrMut);
 
-pub(super) fn observer_system_runner<E: Event, B: Bundle, S: ObserverSystem<E, B>>(
+/// # Safety
+///
+/// - `world` must be the [`DeferredWorld`] that the `entity` is defined in
+/// - `event_ptr` must match the `E` [`Event`] type.
+/// - `trigger_ptr` must match the [`Event::Trigger`] type for `E`.
+/// - `trigger_context`'s [`TriggerContext::event_key`] must match the `E` event type.
+///
+// NOTE: The way `Trigger` and `On` interact in this implementation is _subtle_ and _easily invalidated_
+// from a soundness perspective. Please read and understand the safety comments before making any changes,
+// either here or in `On`.
+pub(super) unsafe fn observer_system_runner<E: Event, B: Bundle, S: ObserverSystem<E, B>>(
     mut world: DeferredWorld,
-    observer_trigger: ObserverTrigger,
-    ptr: PtrMut,
-    propagate: &mut bool,
+    observer: Entity,
+    trigger_context: &TriggerContext,
+    event_ptr: PtrMut,
+    trigger_ptr: PtrMut,
 ) {
     let world = world.as_unsafe_world_cell();
+
     // SAFETY: Observer was triggered so must still exist in world
-    let observer_cell = unsafe {
-        world
-            .get_entity(observer_trigger.observer)
-            .debug_checked_unwrap()
-    };
+    let observer_cell = unsafe { world.get_entity(observer).debug_checked_unwrap() };
     // SAFETY: Observer was triggered so must have an `Observer`
     let mut state = unsafe { observer_cell.get_mut::<Observer>().debug_checked_unwrap() };
 
@@ -41,11 +53,21 @@ pub(super) fn observer_system_runner<E: Event, B: Bundle, S: ObserverSystem<E, B
     }
     state.last_trigger_id = last_trigger;
 
+    // SAFETY: Caller ensures `trigger_ptr` is castable to `&mut E::Trigger<'_>`
+    // The soundness story here is complicated: This casts to &'a mut E::Trigger<'a> which notably
+    // casts the _arbitrary lifetimes_ of the passed in `trigger_ptr` (&'w E::Trigger<'t>, which are
+    // 'w and 't on On<'w, 't>) as the _same_ lifetime 'a, which is _local to this function call_.
+    // This becomes On<'a, 'a> in practice. This is why `On<'w, 't>` has the strict constraint that
+    // the 'w lifetime can never be exposed. To do so would make it possible to introduce use-after-free bugs.
+    // See this thread for more details: <https://github.com/bevyengine/bevy/pull/20731#discussion_r2311907935>
+    let trigger: &mut E::Trigger<'_> = unsafe { trigger_ptr.deref_mut() };
+
     let on: On<E, B> = On::new(
-        // SAFETY: Caller ensures `ptr` is castable to `&mut T`
-        unsafe { ptr.deref_mut() },
-        propagate,
-        observer_trigger,
+        // SAFETY: Caller ensures `ptr` is castable to `&mut E`
+        unsafe { event_ptr.deref_mut() },
+        observer,
+        trigger,
+        trigger_context,
     );
 
     // SAFETY:
diff --git a/crates/bevy_ecs/src/observer/system_param.rs b/crates/bevy_ecs/src/observer/system_param.rs
index a09cda0676c8b..d206af0179e42 100644
--- a/crates/bevy_ecs/src/observer/system_param.rs
+++ b/crates/bevy_ecs/src/observer/system_param.rs
@@ -1,20 +1,22 @@
 //! System parameters for working with observers.
 
-use core::marker::PhantomData;
-use core::ops::DerefMut;
-use core::{fmt::Debug, ops::Deref};
-
-use bevy_ptr::Ptr;
-use smallvec::SmallVec;
-
 use crate::{
-    bundle::Bundle, change_detection::MaybeLocation, component::ComponentId, event::EntityEvent,
+    bundle::Bundle,
+    change_detection::MaybeLocation,
+    event::{Event, PropagateEntityTrigger},
     prelude::*,
+    traversal::Traversal,
+};
+use bevy_ptr::Ptr;
+use core::{
+    fmt::Debug,
+    marker::PhantomData,
+    ops::{Deref, DerefMut},
 };
 
 /// Type containing triggered [`Event`] information for a given run of an [`Observer`]. This contains the
-/// [`Event`] data itself. If it was triggered for a specific [`Entity`], it includes that as well. It also
-/// contains event propagation information. See [`On::propagate`] for more information.
+/// [`Event`] data itself. It also provides access to the [`Trigger`](crate::event::Trigger), which for things like
+/// [`EntityEvent`] with a [`PropagateEntityTrigger`], includes control over event propagation.
 ///
 /// The generic `B: Bundle` is used to modify the further specialize the events that this observer is interested in.
 /// The entity involved *does not* have to have these components, but the observer will only be
@@ -26,31 +28,44 @@ use crate::{
 /// Providing multiple components in this bundle will cause this event to be triggered by any
 /// matching component in the bundle,
 /// [rather than requiring all of them to be present](https://github.com/bevyengine/bevy/issues/15325).
-pub struct On<'w, E, B: Bundle = ()> {
+// SAFETY WARNING!
+// this type must _never_ expose anything with the 'w lifetime
+// See the safety discussion on `Trigger` for more details.
+pub struct On<'w, 't, E: Event, B: Bundle = ()> {
+    observer: Entity,
+    // SAFETY WARNING: never expose this 'w lifetime
     event: &'w mut E,
-    propagate: &'w mut bool,
-    trigger: ObserverTrigger,
+    // SAFETY WARNING: never expose this 'w lifetime
+    trigger: &'w mut E::Trigger<'t>,
+    // SAFETY WARNING: never expose this 'w lifetime
+    pub(crate) trigger_context: &'w TriggerContext,
     _marker: PhantomData<B>,
 }
 
 /// Deprecated in favor of [`On`].
 #[deprecated(since = "0.17.0", note = "Renamed to `On`.")]
-pub type Trigger<'w, E, B = ()> = On<'w, E, B>;
-
-impl<'w, E, B: Bundle> On<'w, E, B> {
-    /// Creates a new instance of [`On`] for the given event and observer information.
-    pub fn new(event: &'w mut E, propagate: &'w mut bool, trigger: ObserverTrigger) -> Self {
+pub type Trigger<'w, 't, E, B = ()> = On<'w, 't, E, B>;
+
+impl<'w, 't, E: Event, B: Bundle> On<'w, 't, E, B> {
+    /// Creates a new instance of [`On`] for the given triggered event.
+    pub fn new(
+        event: &'w mut E,
+        observer: Entity,
+        trigger: &'w mut E::Trigger<'t>,
+        trigger_context: &'w TriggerContext,
+    ) -> Self {
         Self {
             event,
-            propagate,
+            observer,
             trigger,
+            trigger_context,
             _marker: PhantomData,
         }
     }
 
     /// Returns the event type of this [`On`] instance.
     pub fn event_key(&self) -> EventKey {
-        self.trigger.event_key
+        self.trigger_context.event_key
     }
 
     /// Returns a reference to the triggered event.
@@ -68,14 +83,17 @@ impl<'w, E, B: Bundle> On<'w, E, B> {
         Ptr::from(&self.event)
     }
 
-    /// Returns the components that triggered the observer, out of the
-    /// components defined in `B`. Does not necessarily include all of them as
-    /// `B` acts like an `OR` filter rather than an `AND` filter.
-    pub fn components(&self) -> &[ComponentId] {
-        &self.trigger.components
+    /// Returns the [`Trigger`](crate::event::Trigger) context for this event.
+    pub fn trigger(&self) -> &E::Trigger<'t> {
+        self.trigger
+    }
+
+    /// Returns the mutable [`Trigger`](crate::event::Trigger) context for this event.
+    pub fn trigger_mut(&mut self) -> &mut E::Trigger<'t> {
+        self.trigger
     }
 
-    /// Returns the [`Entity`] that observed the triggered event.
+    /// Returns the [`Entity`] of the [`Observer`] of the triggered event.
     /// This allows you to despawn the observer, ceasing observation.
     ///
     /// # Examples
@@ -84,83 +102,93 @@ impl<'w, E, B: Bundle> On<'w, E, B> {
     /// # use bevy_ecs::prelude::*;
     ///
     /// #[derive(EntityEvent)]  
-    /// struct AssertEvent;  
+    /// struct AssertEvent {
+    ///     entity: Entity,
+    /// }
     ///
     /// fn assert_observer(event: On<AssertEvent>) {  
-    ///     assert_eq!(event.observer(), event.entity());  
+    ///     assert_eq!(event.observer(), event.entity);  
     /// }  
     ///
     /// let mut world = World::new();  
-    /// let observer = world.spawn(Observer::new(assert_observer)).id();  
+    /// let entity = world.spawn(Observer::new(assert_observer)).id();  
     ///
-    /// world.trigger_targets(AssertEvent, observer);  
+    /// world.trigger(AssertEvent { entity });  
     /// ```
     pub fn observer(&self) -> Entity {
-        self.trigger.observer
+        self.observer
     }
 
-    /// Returns the source code location that triggered this observer.
+    /// Returns the source code location that triggered this observer, if the `track_location` cargo feature is enabled.
     pub fn caller(&self) -> MaybeLocation {
-        self.trigger.caller
+        self.trigger_context.caller
     }
 }
 
-impl<'w, E: EntityEvent, B: Bundle> On<'w, E, B> {
-    /// Returns the [`Entity`] that was targeted by the `event` that triggered this observer.
-    ///
-    /// Note that if event propagation is enabled, this may not be the same as the original target of the event,
-    /// which can be accessed via [`On::original_entity`].
-    ///
-    /// If the event was not targeted at a specific entity, this will return [`Entity::PLACEHOLDER`].
-    pub fn entity(&self) -> Entity {
-        self.trigger.entity.unwrap_or(Entity::PLACEHOLDER)
-    }
-
-    /// Returns the original [`Entity`] that the `event` was targeted at when it was first triggered.
-    ///
-    /// If event propagation is not enabled, this will always return the same value as [`On::entity`].
-    ///
-    /// If the event was not targeted at a specific entity, this will return [`Entity::PLACEHOLDER`].
-    pub fn original_entity(&self) -> Entity {
-        self.trigger.original_entity.unwrap_or(Entity::PLACEHOLDER)
+impl<
+        'w,
+        't,
+        const AUTO_PROPAGATE: bool,
+        E: EntityEvent + for<'a> Event<Trigger<'a> = PropagateEntityTrigger<AUTO_PROPAGATE, E, T>>,
+        B: Bundle,
+        T: Traversal<E>,
+    > On<'w, 't, E, B>
+{
+    /// A deprecated way to retrieve the entity that this [`EntityEvent`] targeted at.
+    ///
+    /// Access the event via [`On::event`], then read the entity that the event was targeting.
+    /// Prefer using the field name directly for clarity,
+    /// but if you are working in a generic context, you can use [`EntityEvent::event_target`].
+    #[deprecated(
+        since = "0.17.0",
+        note = "Call On::event() to access the event, then read the target entity from the event directly."
+    )]
+    pub fn target(&self) -> Entity {
+        self.event.event_target()
+    }
+
+    /// Returns the original [`Entity`] that this [`EntityEvent`] targeted via [`EntityEvent::event_target`] when it was _first_ triggered,
+    /// prior to any propagation logic.
+    pub fn original_event_target(&self) -> Entity {
+        self.trigger.original_event_target
     }
 
     /// Enables or disables event propagation, allowing the same event to trigger observers on a chain of different entities.
     ///
-    /// The path an event will propagate along is specified by its associated [`Traversal`] component. By default, events
-    /// use `()` which ends the path immediately and prevents propagation.
+    /// The path an [`EntityEvent`] will propagate along is specified by the [`Traversal`] component defined in [`PropagateEntityTrigger`].
+    ///
+    /// [`EntityEvent`] does not propagate by default. To enable propagation, you must:
+    /// + Enable propagation in [`EntityEvent`] using `#[entity_event(propagate)]`. See [`EntityEvent`] for details.
+    /// + Either call `propagate(true)` in the first observer or in the [`EntityEvent`] derive add `#[entity_event(auto_propagate)]`.
     ///
-    /// To enable propagation, you must:
-    /// + Set [`EntityEvent::Traversal`] to the component you want to propagate along.
-    /// + Either call `propagate(true)` in the first observer or set [`EntityEvent::AUTO_PROPAGATE`] to `true`.
+    /// You can prevent an event from propagating further using `propagate(false)`. This will prevent the event from triggering on the next
+    /// [`Entity`] in the [`Traversal`], but note that all remaining observers for the _current_ entity will still run.
     ///
-    /// You can prevent an event from propagating further using `propagate(false)`.
     ///
     /// [`Traversal`]: crate::traversal::Traversal
     pub fn propagate(&mut self, should_propagate: bool) {
-        *self.propagate = should_propagate;
+        self.trigger.propagate = should_propagate;
     }
 
     /// Returns the value of the flag that controls event propagation. See [`propagate`] for more information.
     ///
     /// [`propagate`]: On::propagate
     pub fn get_propagate(&self) -> bool {
-        *self.propagate
+        self.trigger.propagate
     }
 }
 
-impl<'w, E: Debug, B: Bundle> Debug for On<'w, E, B> {
+impl<'w, 't, E: for<'a> Event<Trigger<'a>: Debug> + Debug, B: Bundle> Debug for On<'w, 't, E, B> {
     fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
         f.debug_struct("On")
             .field("event", &self.event)
-            .field("propagate", &self.propagate)
             .field("trigger", &self.trigger)
             .field("_marker", &self._marker)
             .finish()
     }
 }
 
-impl<'w, E, B: Bundle> Deref for On<'w, E, B> {
+impl<'w, 't, E: Event, B: Bundle> Deref for On<'w, 't, E, B> {
     type Target = E;
 
     fn deref(&self) -> &Self::Target {
@@ -168,7 +196,7 @@ impl<'w, E, B: Bundle> Deref for On<'w, E, B> {
     }
 }
 
-impl<'w, E, B: Bundle> DerefMut for On<'w, E, B> {
+impl<'w, 't, E: Event, B: Bundle> DerefMut for On<'w, 't, E, B> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         self.event
     }
@@ -177,30 +205,9 @@ impl<'w, E, B: Bundle> DerefMut for On<'w, E, B> {
 /// Metadata about a specific [`Event`] that triggered an observer.
 ///
 /// This information is exposed via methods on [`On`].
-#[derive(Debug)]
-pub struct ObserverTrigger {
-    /// The [`Entity`] of the observer handling the trigger.
-    pub observer: Entity,
+pub struct TriggerContext {
     /// The [`EventKey`] the trigger targeted.
     pub event_key: EventKey,
-    /// The [`ComponentId`]s the trigger targeted.
-    pub components: SmallVec<[ComponentId; 2]>,
-    /// The entity that the entity-event targeted, if any.
-    ///
-    /// Note that if event propagation is enabled, this may not be the same as [`ObserverTrigger::original_entity`].
-    pub entity: Option<Entity>,
-    /// The entity that the entity-event was originally targeted at, if any.
-    ///
-    /// If event propagation is enabled, this will be the first entity that the event was targeted at,
-    /// even if the event was propagated to other entities.
-    pub original_entity: Option<Entity>,
     /// The location of the source code that triggered the observer.
     pub caller: MaybeLocation,
 }
-
-impl ObserverTrigger {
-    /// Returns the components that the trigger targeted.
-    pub fn components(&self) -> &[ComponentId] {
-        &self.components
-    }
-}
diff --git a/crates/bevy_ecs/src/observer/trigger_targets.rs b/crates/bevy_ecs/src/observer/trigger_targets.rs
deleted file mode 100644
index 77728e4acdd10..0000000000000
--- a/crates/bevy_ecs/src/observer/trigger_targets.rs
+++ /dev/null
@@ -1,117 +0,0 @@
-//! Stores the [`TriggerTargets`] trait.
-
-use crate::{component::ComponentId, prelude::*};
-use alloc::vec::Vec;
-use variadics_please::all_tuples;
-
-/// Represents a collection of targets for a specific [`On`] instance of an [`Event`].
-///
-/// When an event is triggered with [`TriggerTargets`], any [`Observer`] that watches for that specific
-/// event-target combination will run.
-///
-/// This trait is implemented for both [`Entity`] and [`ComponentId`], allowing you to target specific entities or components.
-/// It is also implemented for various collections of these types, such as [`Vec`], arrays, and tuples,
-/// allowing you to trigger events for multiple targets at once.
-pub trait TriggerTargets {
-    /// The components the trigger should target.
-    fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_;
-
-    /// The entities the trigger should target.
-    fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_;
-}
-
-impl<T: TriggerTargets + ?Sized> TriggerTargets for &T {
-    fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
-        (**self).components()
-    }
-
-    fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_ {
-        (**self).entities()
-    }
-}
-
-impl TriggerTargets for Entity {
-    fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
-        [].into_iter()
-    }
-
-    fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_ {
-        core::iter::once(*self)
-    }
-}
-
-impl TriggerTargets for ComponentId {
-    fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
-        core::iter::once(*self)
-    }
-
-    fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_ {
-        [].into_iter()
-    }
-}
-
-impl<T: TriggerTargets> TriggerTargets for Vec<T> {
-    fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
-        self.iter().flat_map(T::components)
-    }
-
-    fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_ {
-        self.iter().flat_map(T::entities)
-    }
-}
-
-impl<const N: usize, T: TriggerTargets> TriggerTargets for [T; N] {
-    fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
-        self.iter().flat_map(T::components)
-    }
-
-    fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_ {
-        self.iter().flat_map(T::entities)
-    }
-}
-
-impl<T: TriggerTargets> TriggerTargets for [T] {
-    fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
-        self.iter().flat_map(T::components)
-    }
-
-    fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_ {
-        self.iter().flat_map(T::entities)
-    }
-}
-
-macro_rules! impl_trigger_targets_tuples {
-    ($(#[$meta:meta])* $($trigger_targets: ident),*) => {
-        #[expect(clippy::allow_attributes, reason = "can't guarantee violation of non_snake_case")]
-        #[allow(non_snake_case, reason = "`all_tuples!()` generates non-snake-case variable names.")]
-        $(#[$meta])*
-        impl<$($trigger_targets: TriggerTargets),*> TriggerTargets for ($($trigger_targets,)*)
-        {
-            fn components(&self) -> impl Iterator<Item = ComponentId> + Clone + '_ {
-                let iter = [].into_iter();
-                let ($($trigger_targets,)*) = self;
-                $(
-                    let iter = iter.chain($trigger_targets.components());
-                )*
-                iter
-            }
-
-            fn entities(&self) -> impl Iterator<Item = Entity> + Clone + '_ {
-                let iter = [].into_iter();
-                let ($($trigger_targets,)*) = self;
-                $(
-                    let iter = iter.chain($trigger_targets.entities());
-                )*
-                iter
-            }
-        }
-    }
-}
-
-all_tuples!(
-    #[doc(fake_variadic)]
-    impl_trigger_targets_tuples,
-    0,
-    15,
-    T
-);
diff --git a/crates/bevy_ecs/src/relationship/related_methods.rs b/crates/bevy_ecs/src/relationship/related_methods.rs
index 7cd539c7312e1..e9b7849441ece 100644
--- a/crates/bevy_ecs/src/relationship/related_methods.rs
+++ b/crates/bevy_ecs/src/relationship/related_methods.rs
@@ -905,11 +905,10 @@ mod tests {
         let result_entity = world.spawn(ObserverResult::default()).id();
 
         world.add_observer(
-            move |event: On<Replace, MyComponent>,
+            move |replace: On<Replace, MyComponent>,
                   has_relationship: Query<Has<ChildOf>>,
                   mut results: Query<&mut ObserverResult>| {
-                let entity = event.entity();
-                if has_relationship.get(entity).unwrap_or(false) {
+                if has_relationship.get(replace.entity).unwrap_or(false) {
                     results.get_mut(result_entity).unwrap().success = true;
                 }
             },
diff --git a/crates/bevy_ecs/src/storage/sparse_set.rs b/crates/bevy_ecs/src/storage/sparse_set.rs
index bb28f967af377..f4c47207dd20a 100644
--- a/crates/bevy_ecs/src/storage/sparse_set.rs
+++ b/crates/bevy_ecs/src/storage/sparse_set.rs
@@ -421,8 +421,8 @@ macro_rules! impl_sparse_set {
             }
 
             /// Returns an iterator visiting all keys (indices) in arbitrary order.
-            pub fn indices(&self) -> impl Iterator<Item = I> + Clone + '_ {
-                self.indices.iter().cloned()
+            pub fn indices(&self) -> &[I] {
+                &self.indices
             }
 
             /// Returns an iterator visiting all values in arbitrary order.
diff --git a/crates/bevy_ecs/src/system/commands/command.rs b/crates/bevy_ecs/src/system/commands/command.rs
index 83dad342a803c..60382e6f78a14 100644
--- a/crates/bevy_ecs/src/system/commands/command.rs
+++ b/crates/bevy_ecs/src/system/commands/command.rs
@@ -9,8 +9,7 @@ use crate::{
     change_detection::MaybeLocation,
     entity::Entity,
     error::Result,
-    event::{BufferedEvent, EntityEvent, Event, Events},
-    observer::TriggerTargets,
+    event::{BufferedEvent, Event, Events},
     resource::Resource,
     schedule::ScheduleLabel,
     system::{IntoSystem, SystemId, SystemInput},
@@ -208,24 +207,33 @@ pub fn run_schedule(label: impl ScheduleLabel) -> impl Command<Result> {
     }
 }
 
-/// A [`Command`] that sends a global [`Event`] without any targets.
+/// Triggers the given [`Event`], which will run any [`Observer`]s watching for it.
+///
+/// [`Observer`]: crate::observer::Observer
 #[track_caller]
-pub fn trigger(event: impl Event) -> impl Command {
+pub fn trigger<'a, E: Event<Trigger<'a>: Default>>(mut event: E) -> impl Command {
     let caller = MaybeLocation::caller();
     move |world: &mut World| {
-        world.trigger_with_caller(event, caller);
+        world.trigger_ref_with_caller(
+            &mut event,
+            &mut <E::Trigger<'_> as Default>::default(),
+            caller,
+        );
     }
 }
 
-/// A [`Command`] that sends an [`EntityEvent`] for the given targets.
+/// Triggers the given [`Event`] using the given [`Trigger`], which will run any [`Observer`]s watching for it.
+///
+/// [`Trigger`]: crate::event::Trigger
+/// [`Observer`]: crate::observer::Observer
 #[track_caller]
-pub fn trigger_targets(
-    event: impl EntityEvent,
-    targets: impl TriggerTargets + Send + Sync + 'static,
+pub fn trigger_with<E: Event<Trigger<'static>: Send + Sync>>(
+    mut event: E,
+    mut trigger: E::Trigger<'static>,
 ) -> impl Command {
     let caller = MaybeLocation::caller();
     move |world: &mut World| {
-        world.trigger_targets_with_caller(event, targets, caller);
+        world.trigger_ref_with_caller(&mut event, &mut trigger, caller);
     }
 }
 
diff --git a/crates/bevy_ecs/src/system/commands/entity_command.rs b/crates/bevy_ecs/src/system/commands/entity_command.rs
index 74f206b348c0f..6510c54960dd1 100644
--- a/crates/bevy_ecs/src/system/commands/entity_command.rs
+++ b/crates/bevy_ecs/src/system/commands/entity_command.rs
@@ -242,7 +242,8 @@ pub fn despawn() -> impl EntityCommand {
 }
 
 /// An [`EntityCommand`] that creates an [`Observer`](crate::observer::Observer)
-/// listening for events of type `E` targeting an entity
+/// watching for an [`EntityEvent`] of type `E` whose [`EntityEvent::event_target`]
+/// targets this entity.
 #[track_caller]
 pub fn observe<E: EntityEvent, B: Bundle, M>(
     observer: impl IntoObserverSystem<E, B, M>,
@@ -253,20 +254,6 @@ pub fn observe<E: EntityEvent, B: Bundle, M>(
     }
 }
 
-/// An [`EntityCommand`] that sends an [`EntityEvent`] targeting an entity.
-///
-/// This will run any [`Observer`](crate::observer::Observer) of the given [`EntityEvent`] watching the entity.
-#[track_caller]
-pub fn trigger(event: impl EntityEvent) -> impl EntityCommand {
-    let caller = MaybeLocation::caller();
-    move |mut entity: EntityWorldMut| {
-        let id = entity.id();
-        entity.world_scope(|world| {
-            world.trigger_targets_with_caller(event, id, caller);
-        });
-    }
-}
-
 /// An [`EntityCommand`] that clones parts of an entity onto another entity,
 /// configured through [`EntityClonerBuilder`].
 ///
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index bf520223af5b8..634e3caee8934 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -21,7 +21,7 @@ use crate::{
     entity::{Entities, Entity, EntityClonerBuilder, EntityDoesNotExistError, OptIn, OptOut},
     error::{warn, BevyError, CommandWithEntity, ErrorContext, HandleError},
     event::{BufferedEvent, EntityEvent, Event},
-    observer::{Observer, TriggerTargets},
+    observer::Observer,
     resource::Resource,
     schedule::ScheduleLabel,
     system::{
@@ -1083,38 +1083,35 @@ impl<'w, 's> Commands<'w, 's> {
         self.queue(command::run_system_cached_with(system, input).handle_error_with(warn));
     }
 
-    /// Sends a global [`Event`] without any targets.
+    /// Triggers the given [`Event`], which will run any [`Observer`]s watching for it.
     ///
-    /// This will run any [`Observer`] of the given [`Event`] that isn't scoped to specific targets.
-    ///
-    /// If the entity that this command targets does not exist when the command is applied,
-    /// the command will fail, possibly causing it to panic based on the default [error handler](crate::error) set.
-    ///
-    /// To queue this command with a specific handler, use [`EntityCommands::queue_handled`]
-    /// with [`entity_command::trigger(event)`](entity_command::trigger).
-    /// [`EntityCommands::queue_silenced`] may also be used to ignore the error completely.
+    /// [`Observer`]: crate::observer::Observer
     #[track_caller]
-    pub fn trigger(&mut self, event: impl Event) {
+    pub fn trigger<'a>(&mut self, event: impl Event<Trigger<'a>: Default>) {
         self.queue(command::trigger(event));
     }
 
-    /// Sends an [`EntityEvent`] for the given targets.
-    ///
-    /// This will run any [`Observer`] of the given [`EntityEvent`] watching those targets.
+    /// A deprecated alias for [`trigger`](Self::trigger) to ease migration.
     ///
-    /// If the entity that this command targets does not exist when the command is applied,
-    /// the command will fail, possibly causing it to panic based on the default [error handler](crate::error) set.
+    /// Instead of specifying the trigger target separately,
+    /// information about the target of the event is embedded in the data held by
+    /// the event type itself.
+    #[deprecated(since = "0.17.0", note = "Use `Commands::trigger` instead.")]
+    pub fn trigger_targets<'a>(&mut self, event: impl Event<Trigger<'a>: Default>) {
+        self.trigger(event);
+    }
+
+    /// Triggers the given [`Event`] using the given [`Trigger`], which will run any [`Observer`]s watching for it.
     ///
-    /// To queue this command with a specific handler, use [`EntityCommands::queue_handled`]
-    /// with [`entity_command::trigger(event)`](entity_command::trigger).
-    /// [`EntityCommands::queue_silenced`] may also be used to ignore the error completely.
+    /// [`Trigger`]: crate::event::Trigger
+    /// [`Observer`]: crate::observer::Observer
     #[track_caller]
-    pub fn trigger_targets(
+    pub fn trigger_with<E: Event<Trigger<'static>: Send + Sync>>(
         &mut self,
-        event: impl EntityEvent,
-        targets: impl TriggerTargets + Send + Sync + 'static,
+        event: E,
+        trigger: E::Trigger<'static>,
     ) {
-        self.queue(command::trigger_targets(event, targets));
+        self.queue(command::trigger_with(event, trigger));
     }
 
     /// Spawns an [`Observer`] and returns the [`EntityCommands`] associated
@@ -2005,21 +2002,8 @@ impl<'a> EntityCommands<'a> {
         &mut self.commands
     }
 
-    /// Sends an [`EntityEvent`] targeting the entity.
-    ///
-    /// This will run any [`Observer`] of the given [`EntityEvent`] watching this entity.
-    ///
-    /// If the entity that this command targets does not exist when the command is applied,
-    /// the command will fail, possibly causing it to panic based on the default error handler set.
-    /// To queue this command with a handler, use [`EntityCommands::queue_handled`]
-    /// with [`entity_command::trigger(event)`](entity_command::trigger).
-    /// [`EntityCommands::queue_silenced`] may also be used to ignore the error completely.
-    #[track_caller]
-    pub fn trigger(&mut self, event: impl EntityEvent) -> &mut Self {
-        self.queue(entity_command::trigger(event))
-    }
-
-    /// Creates an [`Observer`] listening for events of type `E` targeting this entity.
+    /// Creates an [`Observer`] watching for an [`EntityEvent`] of type `E` whose [`EntityEvent::event_target`]
+    /// targets this entity.
     pub fn observe<E: EntityEvent, B: Bundle, M>(
         &mut self,
         observer: impl IntoObserverSystem<E, B, M>,
diff --git a/crates/bevy_ecs/src/system/input.rs b/crates/bevy_ecs/src/system/input.rs
index c8d799b05d544..429f4df018ed6 100644
--- a/crates/bevy_ecs/src/system/input.rs
+++ b/crates/bevy_ecs/src/system/input.rs
@@ -2,7 +2,7 @@ use core::ops::{Deref, DerefMut};
 
 use variadics_please::all_tuples;
 
-use crate::{bundle::Bundle, prelude::On, system::System};
+use crate::{bundle::Bundle, event::Event, prelude::On, system::System};
 
 /// Trait for types that can be used as input to [`System`]s.
 ///
@@ -222,9 +222,13 @@ impl<'i, T: ?Sized> DerefMut for InMut<'i, T> {
 /// Used for [`ObserverSystem`]s.
 ///
 /// [`ObserverSystem`]: crate::system::ObserverSystem
-impl<E: 'static, B: Bundle> SystemInput for On<'_, E, B> {
-    type Param<'i> = On<'i, E, B>;
-    type Inner<'i> = On<'i, E, B>;
+impl<E: Event, B: Bundle> SystemInput for On<'_, '_, E, B> {
+    // Note: the fact that we must use a shared lifetime here is
+    // a key piece of the complicated safety story documented above
+    // the `&mut E::Trigger<'_>` cast in `observer_system_runner` and in
+    // the `On` implementation.
+    type Param<'i> = On<'i, 'i, E, B>;
+    type Inner<'i> = On<'i, 'i, E, B>;
 
     fn wrap(this: Self::Inner<'_>) -> Self::Param<'_> {
         this
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index d971e312a7034..08375f6309743 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -1127,7 +1127,7 @@ mod tests {
             for entity in &query {
                 let location = entities.get(entity).unwrap();
                 let archetype = archetypes.get(location.archetype_id).unwrap();
-                let archetype_components = archetype.components().collect::<Vec<_>>();
+                let archetype_components = archetype.components();
                 let bundle_id = bundles
                     .get_id(TypeId::of::<(W<i32>, W<bool>)>())
                     .expect("Bundle used to spawn entity should exist");
diff --git a/crates/bevy_ecs/src/system/observer_system.rs b/crates/bevy_ecs/src/system/observer_system.rs
index 862ebf71c7eb4..fe612a3d8bc53 100644
--- a/crates/bevy_ecs/src/system/observer_system.rs
+++ b/crates/bevy_ecs/src/system/observer_system.rs
@@ -1,4 +1,5 @@
 use crate::{
+    event::Event,
     prelude::{Bundle, On},
     system::System,
 };
@@ -6,13 +7,13 @@ use crate::{
 use super::IntoSystem;
 
 /// Implemented for [`System`]s that have [`On`] as the first argument.
-pub trait ObserverSystem<E: 'static, B: Bundle, Out = ()>:
-    System<In = On<'static, E, B>, Out = Out> + Send + 'static
+pub trait ObserverSystem<E: Event, B: Bundle, Out = ()>:
+    System<In = On<'static, 'static, E, B>, Out = Out> + Send + 'static
 {
 }
 
-impl<E: 'static, B: Bundle, Out, T> ObserverSystem<E, B, Out> for T where
-    T: System<In = On<'static, E, B>, Out = Out> + Send + 'static
+impl<E: Event, B: Bundle, Out, T> ObserverSystem<E, B, Out> for T where
+    T: System<In = On<'static, 'static, E, B>, Out = Out> + Send + 'static
 {
 }
 
@@ -28,7 +29,7 @@ impl<E: 'static, B: Bundle, Out, T> ObserverSystem<E, B, Out> for T where
     label = "the trait `IntoObserverSystem` is not implemented",
     note = "for function `ObserverSystem`s, ensure the first argument is `On<T>` and any subsequent ones are `SystemParam`"
 )]
-pub trait IntoObserverSystem<E: 'static, B: Bundle, M, Out = ()>: Send + 'static {
+pub trait IntoObserverSystem<E: Event, B: Bundle, M, Out = ()>: Send + 'static {
     /// The type of [`System`] that this instance converts into.
     type System: ObserverSystem<E, B, Out>;
 
@@ -36,9 +37,9 @@ pub trait IntoObserverSystem<E: 'static, B: Bundle, M, Out = ()>: Send + 'static
     fn into_system(this: Self) -> Self::System;
 }
 
-impl<E, B, M, Out, S> IntoObserverSystem<E, B, M, Out> for S
+impl<E: Event, B, M, Out, S> IntoObserverSystem<E, B, M, Out> for S
 where
-    S: IntoSystem<On<'static, E, B>, Out, M> + Send + 'static,
+    S: IntoSystem<On<'static, 'static, E, B>, Out, M> + Send + 'static,
     S::System: ObserverSystem<E, B, Out>,
     E: 'static,
     B: Bundle,
diff --git a/crates/bevy_ecs/src/traversal.rs b/crates/bevy_ecs/src/traversal.rs
index 577720fd5dc17..33e54613cb655 100644
--- a/crates/bevy_ecs/src/traversal.rs
+++ b/crates/bevy_ecs/src/traversal.rs
@@ -8,7 +8,7 @@ use crate::{
 
 /// A component that can point to another entity, and which can be used to define a path through the ECS.
 ///
-/// Traversals are used to [specify the direction] of [event propagation] in [observers].
+/// Traversals are used to [specify the direction] of [event propagation] in [`EntityEvent`] [observers].
 /// The default query is `()`.
 ///
 /// Infinite loops are possible, and are not checked for. While looping can be desirable in some contexts
@@ -21,9 +21,10 @@ use crate::{
 /// parameter `D` is the event type given in `On<E>`. This allows traversal to differ depending on event
 /// data.
 ///
-/// [specify the direction]: crate::event::EntityEvent::Traversal
+/// [specify the direction]: crate::event::PropagateEntityTrigger
 /// [event propagation]: crate::observer::On::propagate
 /// [observers]: crate::observer::Observer
+/// [`EntityEvent`]: crate::event::EntityEvent
 pub trait Traversal<D: ?Sized>: ReadOnlyQueryData + ReleaseStateQueryData {
     /// Returns the next entity to visit.
     fn traverse(item: Self::Item<'_, '_>, data: &D) -> Option<Entity>;
diff --git a/crates/bevy_ecs/src/world/deferred_world.rs b/crates/bevy_ecs/src/world/deferred_world.rs
index 9c247bcab2638..22f38c698350d 100644
--- a/crates/bevy_ecs/src/world/deferred_world.rs
+++ b/crates/bevy_ecs/src/world/deferred_world.rs
@@ -7,15 +7,17 @@ use crate::{
     change_detection::{MaybeLocation, MutUntyped},
     component::{ComponentId, Mutable},
     entity::Entity,
-    event::{BufferedEvent, EntityEvent, Event, EventId, EventKey, Events, WriteBatchIds},
-    lifecycle::{HookContext, INSERT, REPLACE},
-    observer::{Observers, TriggerTargets},
+    event::{
+        BufferedEvent, EntityComponentsTrigger, Event, EventId, EventKey, Events, Trigger,
+        WriteBatchIds,
+    },
+    lifecycle::{HookContext, Insert, Replace, INSERT, REPLACE},
+    observer::TriggerContext,
     prelude::{Component, QueryState},
     query::{QueryData, QueryFilter},
     relationship::RelationshipHookMode,
     resource::Resource,
     system::{Commands, Query},
-    traversal::Traversal,
     world::{error::EntityMutableFetchError, EntityFetcher, WorldEntityFetch},
 };
 
@@ -167,10 +169,13 @@ impl<'w> DeferredWorld<'w> {
                 relationship_hook_mode,
             );
             if archetype.has_replace_observer() {
-                self.trigger_observers(
+                // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+                self.trigger_raw(
                     REPLACE,
-                    Some(entity),
-                    [component_id].into_iter(),
+                    &mut Replace { entity },
+                    &mut EntityComponentsTrigger {
+                        components: &[component_id],
+                    },
                     MaybeLocation::caller(),
                 );
             }
@@ -207,10 +212,13 @@ impl<'w> DeferredWorld<'w> {
                 relationship_hook_mode,
             );
             if archetype.has_insert_observer() {
-                self.trigger_observers(
+                // SAFETY: the INSERT event_key corresponds to the Insert event's type
+                self.trigger_raw(
                     INSERT,
-                    Some(entity),
-                    [component_id].into_iter(),
+                    &mut Insert { entity },
+                    &mut EntityComponentsTrigger {
+                        components: &[component_id],
+                    },
                     MaybeLocation::caller(),
                 );
             }
@@ -778,85 +786,36 @@ impl<'w> DeferredWorld<'w> {
         }
     }
 
-    /// Triggers all event observers for [`ComponentId`] in target.
+    /// Triggers all `event` observers for the given `targets`
     ///
     /// # Safety
-    /// Caller must ensure observers listening for `event_key` can accept ZST pointers
+    /// - Caller must ensure `E` is accessible as the type represented by `event_key`
     #[inline]
-    pub(crate) unsafe fn trigger_observers(
+    pub unsafe fn trigger_raw<'a, E: Event>(
         &mut self,
         event_key: EventKey,
-        target: Option<Entity>,
-        components: impl Iterator<Item = ComponentId> + Clone,
+        event: &mut E,
+        trigger: &mut E::Trigger<'a>,
         caller: MaybeLocation,
     ) {
-        Observers::invoke::<_>(
-            self.reborrow(),
-            event_key,
-            target,
-            target,
-            components,
-            &mut (),
-            &mut false,
-            caller,
-        );
-    }
-
-    /// Triggers all event observers for [`ComponentId`] in target.
-    ///
-    /// # Safety
-    /// Caller must ensure `E` is accessible as the type represented by `event_key`
-    #[inline]
-    pub(crate) unsafe fn trigger_observers_with_data<E, T>(
-        &mut self,
-        event_key: EventKey,
-        current_target: Option<Entity>,
-        original_entity: Option<Entity>,
-        components: impl Iterator<Item = ComponentId> + Clone,
-        data: &mut E,
-        mut propagate: bool,
-        caller: MaybeLocation,
-    ) where
-        T: Traversal<E>,
-    {
-        Observers::invoke::<_>(
-            self.reborrow(),
-            event_key,
-            current_target,
-            original_entity,
-            components.clone(),
-            data,
-            &mut propagate,
-            caller,
-        );
-        let Some(mut current_target) = current_target else {
-            return;
+        // SAFETY: You cannot get a mutable reference to `observers` from `DeferredWorld`
+        let (mut world, observers) = unsafe {
+            let world = self.as_unsafe_world_cell();
+            let observers = world.observers();
+            let Some(observers) = observers.try_get_observers(event_key) else {
+                return;
+            };
+            // SAFETY: The only outstanding reference to world is `observers`
+            (world.into_deferred(), observers)
         };
+        let context = TriggerContext { event_key, caller };
 
-        loop {
-            if !propagate {
-                return;
-            }
-            if let Some(traverse_to) = self
-                .get_entity(current_target)
-                .ok()
-                .and_then(|entity| entity.get_components::<T>())
-                .and_then(|item| T::traverse(item, data))
-            {
-                current_target = traverse_to;
-            } else {
-                break;
-            }
-            Observers::invoke::<_>(
-                self.reborrow(),
-                event_key,
-                Some(current_target),
-                original_entity,
-                components.clone(),
-                data,
-                &mut propagate,
-                caller,
-            );
+        // SAFETY:
+        // - `observers` comes from `world`, and corresponds to the `event_key`, as it was looked up above
+        // - trigger_context contains the correct event_key for `event`, as enforced by the call to `trigger_raw`
+        // - This method is being called for an `event` whose `Event::Trigger` matches, as the input trigger is E::Trigger.
+        unsafe {
+            trigger.trigger(world.reborrow(), observers, &context, event);
         }
     }
 
@@ -865,21 +824,8 @@ impl<'w> DeferredWorld<'w> {
     /// This will run any [`Observer`] of the given [`Event`] that isn't scoped to specific targets.
     ///
     /// [`Observer`]: crate::observer::Observer
-    pub fn trigger(&mut self, trigger: impl Event) {
-        self.commands().trigger(trigger);
-    }
-
-    /// Sends an [`EntityEvent`] with the given `targets`
-    ///
-    /// This will run any [`Observer`] of the given [`EntityEvent`] watching those targets.
-    ///
-    /// [`Observer`]: crate::observer::Observer
-    pub fn trigger_targets(
-        &mut self,
-        trigger: impl EntityEvent,
-        targets: impl TriggerTargets + Send + Sync + 'static,
-    ) {
-        self.commands().trigger_targets(trigger, targets);
+    pub fn trigger<'a>(&mut self, event: impl Event<Trigger<'a>: Default>) {
+        self.commands().trigger(event);
     }
 
     /// Gets an [`UnsafeWorldCell`] containing the underlying world.
diff --git a/crates/bevy_ecs/src/world/entity_ref.rs b/crates/bevy_ecs/src/world/entity_ref.rs
index 444c3a3a3b311..b4dd981f07f61 100644
--- a/crates/bevy_ecs/src/world/entity_ref.rs
+++ b/crates/bevy_ecs/src/world/entity_ref.rs
@@ -10,8 +10,8 @@ use crate::{
         ContainsEntity, Entity, EntityCloner, EntityClonerBuilder, EntityEquivalent,
         EntityIdLocation, EntityLocation, OptIn, OptOut,
     },
-    event::EntityEvent,
-    lifecycle::{DESPAWN, REMOVE, REPLACE},
+    event::{EntityComponentsTrigger, EntityEvent},
+    lifecycle::{Despawn, Remove, Replace, DESPAWN, REMOVE, REPLACE},
     observer::Observer,
     query::{Access, DebugCheckedUnwrap, ReadOnlyQueryData, ReleaseStateQueryData},
     relationship::RelationshipHookMode,
@@ -2344,7 +2344,7 @@ impl<'w> EntityWorldMut<'w> {
 
         // PERF: this could be stored in an Archetype Edge
         let to_remove = &old_archetype
-            .components()
+            .iter_components()
             .filter(|c| !retained_bundle_info.contributed_components().contains(c))
             .collect::<Vec<_>>();
         let remove_bundle = self.world.bundles.init_dynamic_info(
@@ -2496,7 +2496,8 @@ impl<'w> EntityWorldMut<'w> {
     #[inline]
     pub(crate) fn clear_with_caller(&mut self, caller: MaybeLocation) -> &mut Self {
         let location = self.location();
-        let component_ids: Vec<ComponentId> = self.archetype().components().collect();
+        // PERF: this should not be necessary
+        let component_ids: Vec<ComponentId> = self.archetype().components().to_vec();
         let components = &mut self.world.components;
 
         let bundle_id = self.world.bundles.init_dynamic_info(
@@ -2560,51 +2561,66 @@ impl<'w> EntityWorldMut<'w> {
         // SAFETY: All components in the archetype exist in world
         unsafe {
             if archetype.has_despawn_observer() {
-                deferred_world.trigger_observers(
+                // SAFETY: the DESPAWN event_key corresponds to the Despawn event's type
+                deferred_world.trigger_raw(
                     DESPAWN,
-                    Some(self.entity),
-                    archetype.components(),
+                    &mut Despawn {
+                        entity: self.entity,
+                    },
+                    &mut EntityComponentsTrigger {
+                        components: archetype.components(),
+                    },
                     caller,
                 );
             }
             deferred_world.trigger_on_despawn(
                 archetype,
                 self.entity,
-                archetype.components(),
+                archetype.iter_components(),
                 caller,
             );
             if archetype.has_replace_observer() {
-                deferred_world.trigger_observers(
+                // SAFETY: the REPLACE event_key corresponds to the Replace event's type
+                deferred_world.trigger_raw(
                     REPLACE,
-                    Some(self.entity),
-                    archetype.components(),
+                    &mut Replace {
+                        entity: self.entity,
+                    },
+                    &mut EntityComponentsTrigger {
+                        components: archetype.components(),
+                    },
                     caller,
                 );
             }
             deferred_world.trigger_on_replace(
                 archetype,
                 self.entity,
-                archetype.components(),
+                archetype.iter_components(),
                 caller,
                 RelationshipHookMode::Run,
             );
             if archetype.has_remove_observer() {
-                deferred_world.trigger_observers(
+                // SAFETY: the REMOVE event_key corresponds to the Remove event's type
+                deferred_world.trigger_raw(
                     REMOVE,
-                    Some(self.entity),
-                    archetype.components(),
+                    &mut Remove {
+                        entity: self.entity,
+                    },
+                    &mut EntityComponentsTrigger {
+                        components: archetype.components(),
+                    },
                     caller,
                 );
             }
             deferred_world.trigger_on_remove(
                 archetype,
                 self.entity,
-                archetype.components(),
+                archetype.iter_components(),
                 caller,
             );
         }
 
-        for component_id in archetype.components() {
+        for component_id in archetype.iter_components() {
             world.removed_components.write(component_id, self.entity);
         }
 
@@ -2814,21 +2830,8 @@ impl<'w> EntityWorldMut<'w> {
         }
     }
 
-    /// Triggers the given `event` for this entity, which will run any observers watching for it.
-    ///
-    /// # Panics
-    ///
-    /// If the entity has been despawned while this `EntityWorldMut` is still alive.
-    pub fn trigger(&mut self, event: impl EntityEvent) -> &mut Self {
-        self.assert_not_despawned();
-        self.world.trigger_targets(event, self.entity);
-        self.world.flush();
-        self.update_location();
-        self
-    }
-
-    /// Creates an [`Observer`] listening for events of type `E` targeting this entity.
-    /// In order to trigger the callback the entity must also match the query when the event is fired.
+    /// Creates an [`Observer`] watching for an [`EntityEvent`] of type `E` whose [`EntityEvent::event_target`]
+    /// targets this entity.
     ///
     /// # Panics
     ///
@@ -5223,7 +5226,7 @@ mod tests {
         let ent = world.spawn((Marker::<1>, Marker::<2>, Marker::<3>)).id();
 
         world.entity_mut(ent).retain::<()>();
-        assert_eq!(world.entity(ent).archetype().components().next(), None);
+        assert_eq!(world.entity(ent).archetype().components().len(), 0);
     }
 
     // Test removing some components with `retain`, including components not on the entity.
@@ -5239,15 +5242,7 @@ mod tests {
         // Check that marker 2 was retained.
         assert!(world.entity(ent).get::<Marker<2>>().is_some());
         // Check that only marker 2 was retained.
-        assert_eq!(
-            world
-                .entity(ent)
-                .archetype()
-                .components()
-                .collect::<Vec<_>>()
-                .len(),
-            1
-        );
+        assert_eq!(world.entity(ent).archetype().components().len(), 1);
     }
 
     // regression test for https://github.com/bevyengine/bevy/pull/7805
@@ -6066,7 +6061,7 @@ mod tests {
     }
 
     #[derive(EntityEvent)]
-    struct TestEvent;
+    struct TestEvent(Entity);
 
     #[test]
     fn adding_observer_updates_location() {
@@ -6074,7 +6069,9 @@ mod tests {
         let entity = world
             .spawn_empty()
             .observe(|event: On<TestEvent>, mut commands: Commands| {
-                commands.entity(event.entity()).insert(TestComponent(0));
+                commands
+                    .entity(event.event_target())
+                    .insert(TestComponent(0));
             })
             .id();
 
@@ -6082,7 +6079,9 @@ mod tests {
         world.flush();
 
         let mut a = world.entity_mut(entity);
-        a.trigger(TestEvent); // this adds command to change entity archetype
+        // SAFETY: this _intentionally_ doesn't update the location, to ensure that we're actually testing
+        // that observe() updates location
+        unsafe { a.world_mut().trigger(TestEvent(entity)) }
         a.observe(|_: On<TestEvent>| {}); // this flushes commands implicitly by spawning
         let location = a.location();
         assert_eq!(world.entities().get(entity), Some(location));
@@ -6092,8 +6091,8 @@ mod tests {
     #[should_panic]
     fn location_on_despawned_entity_panics() {
         let mut world = World::new();
-        world.add_observer(|event: On<Add, TestComponent>, mut commands: Commands| {
-            commands.entity(event.entity()).despawn();
+        world.add_observer(|add: On<Add, TestComponent>, mut commands: Commands| {
+            commands.entity(add.entity).despawn();
         });
         let entity = world.spawn_empty().id();
         let mut a = world.entity_mut(entity);
@@ -6122,8 +6121,8 @@ mod tests {
         let entity = world.spawn_empty().id();
         assert_eq!(world.resource::<TestFlush>().0, 1);
         world.commands().queue(count_flush);
+        world.flush_commands();
         let mut a = world.entity_mut(entity);
-        a.trigger(TestEvent);
         assert_eq!(a.world().resource::<TestFlush>().0, 2);
         a.insert(TestComponent(0));
         assert_eq!(a.world().resource::<TestFlush>().0, 3);
diff --git a/crates/bevy_ecs/src/world/error.rs b/crates/bevy_ecs/src/world/error.rs
index d04c28a5dfe10..6378123903a09 100644
--- a/crates/bevy_ecs/src/world/error.rs
+++ b/crates/bevy_ecs/src/world/error.rs
@@ -79,28 +79,26 @@ pub enum ResourceFetchError {
 mod tests {
     use crate::{
         prelude::*,
-        system::{entity_command::trigger, RunSystemOnce},
+        system::{command::trigger, RunSystemOnce},
     };
 
     // Inspired by https://github.com/bevyengine/bevy/issues/19623
     #[test]
     fn fixing_panicking_entity_commands() {
         #[derive(EntityEvent)]
-        struct Kill;
+        struct Kill(Entity);
 
         #[derive(EntityEvent)]
-        struct FollowupEvent;
+        struct FollowupEvent(Entity);
 
-        fn despawn(event: On<Kill>, mut commands: Commands) {
-            commands.entity(event.entity()).despawn();
+        fn despawn(kill: On<Kill>, mut commands: Commands) {
+            commands.entity(kill.event_target()).despawn();
         }
 
-        fn followup(on: On<Kill>, mut commands: Commands) {
+        fn followup(kill: On<Kill>, mut commands: Commands) {
             // When using a simple .trigger() here, this panics because the entity has already been despawned.
             // Instead, we need to use `.queue_handled` or `.queue_silenced` to avoid the panic.
-            commands
-                .entity(on.entity())
-                .queue_silenced(trigger(FollowupEvent));
+            commands.queue_silenced(trigger(FollowupEvent(kill.event_target())));
         }
 
         let mut world = World::new();
@@ -115,7 +113,7 @@ mod tests {
         // Trigger a kill event on the entity
         fn kill_everything(mut commands: Commands, query: Query<Entity>) {
             for id in query.iter() {
-                commands.entity(id).trigger(Kill);
+                commands.trigger(Kill(id));
             }
         }
         world.run_system_once(kill_everything).unwrap();
diff --git a/crates/bevy_ecs/src/world/mod.rs b/crates/bevy_ecs/src/world/mod.rs
index 8f438479533fb..d7841481a1ce0 100644
--- a/crates/bevy_ecs/src/world/mod.rs
+++ b/crates/bevy_ecs/src/world/mod.rs
@@ -4,28 +4,20 @@ pub(crate) mod command_queue;
 mod deferred_world;
 mod entity_fetch;
 mod entity_ref;
-pub mod error;
 mod filtered_resource;
 mod identifier;
 mod spawn_batch;
-pub mod unsafe_world_cell;
 
+pub mod error;
 #[cfg(feature = "bevy_reflect")]
 pub mod reflect;
+pub mod unsafe_world_cell;
 
-use crate::{
-    bundle::BundleId,
-    error::{DefaultErrorHandler, ErrorHandler},
-    event::BufferedEvent,
-    lifecycle::{ComponentHooks, ADD, DESPAWN, INSERT, REMOVE, REPLACE},
-    prelude::{Add, Despawn, Insert, Remove, Replace},
-};
 pub use crate::{
     change_detection::{Mut, Ref, CHECK_TICK_THRESHOLD},
     world::command_queue::CommandQueue,
 };
 pub use bevy_ecs_macros::FromWorld;
-use bevy_utils::prelude::DebugName;
 pub use deferred_world::DeferredWorld;
 pub use entity_fetch::{EntityFetcher, WorldEntityFetch};
 pub use entity_ref::{
@@ -40,8 +32,8 @@ pub use spawn_batch::*;
 use crate::{
     archetype::{ArchetypeId, Archetypes},
     bundle::{
-        Bundle, BundleEffect, BundleInfo, BundleInserter, BundleSpawner, Bundles, InsertMode,
-        NoBundleEffect,
+        Bundle, BundleEffect, BundleId, BundleInfo, BundleInserter, BundleSpawner, Bundles,
+        InsertMode, NoBundleEffect,
     },
     change_detection::{MaybeLocation, MutUntyped, TicksMut},
     component::{
@@ -51,9 +43,11 @@ use crate::{
     },
     entity::{Entities, Entity, EntityDoesNotExistError},
     entity_disabling::DefaultQueryFilters,
-    event::{Event, EventId, Events, WriteBatchIds},
-    lifecycle::RemovedComponentEvents,
+    error::{DefaultErrorHandler, ErrorHandler},
+    event::{BufferedEvent, EventId, Events, WriteBatchIds},
+    lifecycle::{ComponentHooks, RemovedComponentEvents, ADD, DESPAWN, INSERT, REMOVE, REPLACE},
     observer::Observers,
+    prelude::{Add, Despawn, Insert, Remove, Replace},
     query::{DebugCheckedUnwrap, QueryData, QueryFilter, QueryState},
     relationship::RelationshipHookMode,
     resource::Resource,
@@ -70,6 +64,7 @@ use crate::{
 use alloc::{boxed::Box, vec::Vec};
 use bevy_platform::sync::atomic::{AtomicU32, Ordering};
 use bevy_ptr::{OwningPtr, Ptr, UnsafeCellDeref};
+use bevy_utils::prelude::DebugName;
 use core::{any::TypeId, fmt};
 use log::warn;
 use unsafe_world_cell::{UnsafeEntityCell, UnsafeWorldCell};
@@ -153,19 +148,19 @@ impl World {
     #[inline]
     fn bootstrap(&mut self) {
         // The order that we register these events is vital to ensure that the constants are correct!
-        let on_add = Add::register_event_key(self);
+        let on_add = self.register_event_key::<Add>();
         assert_eq!(ADD, on_add);
 
-        let on_insert = Insert::register_event_key(self);
+        let on_insert = self.register_event_key::<Insert>();
         assert_eq!(INSERT, on_insert);
 
-        let on_replace = Replace::register_event_key(self);
+        let on_replace = self.register_event_key::<Replace>();
         assert_eq!(REPLACE, on_replace);
 
-        let on_remove = Remove::register_event_key(self);
+        let on_remove = self.register_event_key::<Remove>();
         assert_eq!(REMOVE, on_remove);
 
-        let on_despawn = Despawn::register_event_key(self);
+        let on_despawn = self.register_event_key::<Despawn>();
         assert_eq!(DESPAWN, on_despawn);
 
         // This sets up `Disabled` as a disabling component, via the FromWorld impl
@@ -889,7 +884,7 @@ impl World {
             .expect("ArchetypeId was retrieved from an EntityLocation and should correspond to an Archetype");
 
         Ok(archetype
-            .components()
+            .iter_components()
             .filter_map(|id| self.components().get_info(id)))
     }
 
diff --git a/crates/bevy_feathers/src/alpha_pattern.rs b/crates/bevy_feathers/src/alpha_pattern.rs
index 1a2732a2e57e8..9ea904e67331e 100644
--- a/crates/bevy_feathers/src/alpha_pattern.rs
+++ b/crates/bevy_feathers/src/alpha_pattern.rs
@@ -43,11 +43,11 @@ pub(crate) struct AlphaPattern;
 /// Observer to fill in the material handle (since we don't have access to the materials asset
 /// in the template)
 fn on_add_alpha_pattern(
-    ev: On<Add, AlphaPattern>,
+    add: On<Add, AlphaPattern>,
     mut q_material_node: Query<&mut MaterialNode<AlphaPatternMaterial>>,
     r_material: Res<AlphaPatternResource>,
 ) {
-    if let Ok(mut material) = q_material_node.get_mut(ev.entity()) {
+    if let Ok(mut material) = q_material_node.get_mut(add.entity) {
         material.0 = r_material.0.clone();
     }
 }
diff --git a/crates/bevy_feathers/src/font_styles.rs b/crates/bevy_feathers/src/font_styles.rs
index 96e76c5787ca3..47a967eea567f 100644
--- a/crates/bevy_feathers/src/font_styles.rs
+++ b/crates/bevy_feathers/src/font_styles.rs
@@ -45,18 +45,18 @@ impl InheritableFont {
 /// An observer which looks for changes to the `InheritableFont` component on an entity, and
 /// propagates downward the font to all participating text entities.
 pub(crate) fn on_changed_font(
-    ev: On<Insert, InheritableFont>,
+    insert: On<Insert, InheritableFont>,
     font_style: Query<&InheritableFont>,
     assets: Res<AssetServer>,
     mut commands: Commands,
 ) {
-    if let Ok(style) = font_style.get(ev.entity())
+    if let Ok(style) = font_style.get(insert.entity)
         && let Some(font) = match style.font {
             HandleOrPath::Handle(ref h) => Some(h.clone()),
             HandleOrPath::Path(ref p) => Some(assets.load::<Font>(p)),
         }
     {
-        commands.entity(ev.entity()).insert(Propagate(TextFont {
+        commands.entity(insert.entity).insert(Propagate(TextFont {
             font,
             font_size: style.font_size,
             ..Default::default()
diff --git a/crates/bevy_feathers/src/theme.rs b/crates/bevy_feathers/src/theme.rs
index 1fd095b764c8e..a57bb6e8620c4 100644
--- a/crates/bevy_feathers/src/theme.rs
+++ b/crates/bevy_feathers/src/theme.rs
@@ -101,7 +101,7 @@ pub(crate) fn update_theme(
 }
 
 pub(crate) fn on_changed_background(
-    ev: On<Insert, ThemeBackgroundColor>,
+    insert: On<Insert, ThemeBackgroundColor>,
     mut q_background: Query<
         (&mut BackgroundColor, &ThemeBackgroundColor),
         Changed<ThemeBackgroundColor>,
@@ -109,18 +109,18 @@ pub(crate) fn on_changed_background(
     theme: Res<UiTheme>,
 ) {
     // Update background colors where the design token has changed.
-    if let Ok((mut bg, theme_bg)) = q_background.get_mut(ev.entity()) {
+    if let Ok((mut bg, theme_bg)) = q_background.get_mut(insert.entity) {
         bg.0 = theme.color(theme_bg.0);
     }
 }
 
 pub(crate) fn on_changed_border(
-    ev: On<Insert, ThemeBorderColor>,
+    insert: On<Insert, ThemeBorderColor>,
     mut q_border: Query<(&mut BorderColor, &ThemeBorderColor), Changed<ThemeBorderColor>>,
     theme: Res<UiTheme>,
 ) {
     // Update background colors where the design token has changed.
-    if let Ok((mut border, theme_border)) = q_border.get_mut(ev.entity()) {
+    if let Ok((mut border, theme_border)) = q_border.get_mut(insert.entity) {
         border.set_all(theme.color(theme_border.0));
     }
 }
@@ -128,15 +128,15 @@ pub(crate) fn on_changed_border(
 /// An observer which looks for changes to the [`ThemeFontColor`] component on an entity, and
 /// propagates downward the text color to all participating text entities.
 pub(crate) fn on_changed_font_color(
-    ev: On<Insert, ThemeFontColor>,
+    insert: On<Insert, ThemeFontColor>,
     font_color: Query<&ThemeFontColor>,
     theme: Res<UiTheme>,
     mut commands: Commands,
 ) {
-    if let Ok(token) = font_color.get(ev.entity()) {
+    if let Ok(token) = font_color.get(insert.entity) {
         let color = theme.color(token.0);
         commands
-            .entity(ev.entity())
+            .entity(insert.entity)
             .insert(Propagate(TextColor(color)));
     }
 }
diff --git a/crates/bevy_input_focus/src/lib.rs b/crates/bevy_input_focus/src/lib.rs
index 9809a7627bd79..b7feec8b68976 100644
--- a/crates/bevy_input_focus/src/lib.rs
+++ b/crates/bevy_input_focus/src/lib.rs
@@ -140,9 +140,12 @@ pub struct InputFocusVisible(pub bool);
 /// To set up your own bubbling input event, add the [`dispatch_focused_input::<MyEvent>`](dispatch_focused_input) system to your app,
 /// in the [`InputFocusSystems::Dispatch`] system set during [`PreUpdate`].
 #[derive(EntityEvent, Clone, Debug, Component)]
-#[entity_event(traversal = WindowTraversal, auto_propagate)]
+#[entity_event(propagate = WindowTraversal, auto_propagate)]
 #[cfg_attr(feature = "bevy_reflect", derive(Reflect), reflect(Component, Clone))]
 pub struct FocusedInput<E: BufferedEvent + Clone> {
+    /// The entity that has received focused input.
+    #[event_target]
+    pub focused_entity: Entity,
     /// The underlying input event.
     pub input: E,
     /// The primary window entity.
@@ -152,8 +155,11 @@ pub struct FocusedInput<E: BufferedEvent + Clone> {
 /// An event which is used to set input focus. Trigger this on an entity, and it will bubble
 /// until it finds a focusable entity, and then set focus to it.
 #[derive(Clone, EntityEvent)]
-#[entity_event(traversal = WindowTraversal, auto_propagate)]
+#[entity_event(propagate = WindowTraversal, auto_propagate)]
 pub struct AcquireFocus {
+    /// The entity that has acquired focus.
+    #[event_target]
+    pub focused_entity: Entity,
     /// The primary window entity.
     window: Entity,
 }
@@ -265,38 +271,32 @@ pub fn dispatch_focused_input<E: BufferedEvent + Clone>(
             // Check if the focused entity is still alive
             if entities.contains(focused_entity) {
                 for ev in key_events.read() {
-                    commands.trigger_targets(
-                        FocusedInput {
-                            input: ev.clone(),
-                            window,
-                        },
+                    commands.trigger(FocusedInput {
                         focused_entity,
-                    );
+                        input: ev.clone(),
+                        window,
+                    });
                 }
             } else {
                 // If the focused entity no longer exists, clear focus and dispatch to window
                 focus.0 = None;
                 for ev in key_events.read() {
-                    commands.trigger_targets(
-                        FocusedInput {
-                            input: ev.clone(),
-                            window,
-                        },
+                    commands.trigger(FocusedInput {
+                        focused_entity: window,
+                        input: ev.clone(),
                         window,
-                    );
+                    });
                 }
             }
         } else {
             // If no element has input focus, then dispatch the input event to the primary window.
             // There should be only one primary window.
             for ev in key_events.read() {
-                commands.trigger_targets(
-                    FocusedInput {
-                        input: ev.clone(),
-                        window,
-                    },
+                commands.trigger(FocusedInput {
+                    focused_entity: window,
+                    input: ev.clone(),
                     window,
-                );
+                });
             }
         }
     }
@@ -422,7 +422,7 @@ mod tests {
         event: On<FocusedInput<KeyboardInput>>,
         mut query: Query<&mut GatherKeyboardEvents>,
     ) {
-        if let Ok(mut gather) = query.get_mut(event.entity()) {
+        if let Ok(mut gather) = query.get_mut(event.focused_entity) {
             if let Key::Character(c) = &event.input.logical_key {
                 gather.0.push_str(c.as_str());
             }
diff --git a/crates/bevy_input_focus/src/tab_navigation.rs b/crates/bevy_input_focus/src/tab_navigation.rs
index 2599054313b65..a490d00dda10e 100644
--- a/crates/bevy_input_focus/src/tab_navigation.rs
+++ b/crates/bevy_input_focus/src/tab_navigation.rs
@@ -316,22 +316,22 @@ impl TabNavigation<'_, '_> {
 
 /// Observer which sets focus to the nearest ancestor that has tab index, using bubbling.
 pub(crate) fn acquire_focus(
-    mut ev: On<AcquireFocus>,
+    mut acquire_focus: On<AcquireFocus>,
     focusable: Query<(), With<TabIndex>>,
     windows: Query<(), With<Window>>,
     mut focus: ResMut<InputFocus>,
 ) {
     // If the entity has a TabIndex
-    if focusable.contains(ev.entity()) {
+    if focusable.contains(acquire_focus.focused_entity) {
         // Stop and focus it
-        ev.propagate(false);
+        acquire_focus.propagate(false);
         // Don't mutate unless we need to, for change detection
-        if focus.0 != Some(ev.entity()) {
-            focus.0 = Some(ev.entity());
+        if focus.0 != Some(acquire_focus.focused_entity) {
+            focus.0 = Some(acquire_focus.focused_entity);
         }
-    } else if windows.contains(ev.entity()) {
+    } else if windows.contains(acquire_focus.focused_entity) {
         // Stop and clear focus
-        ev.propagate(false);
+        acquire_focus.propagate(false);
         // Don't mutate unless we need to, for change detection
         if focus.0.is_some() {
             focus.clear();
@@ -357,7 +357,7 @@ fn setup_tab_navigation(mut commands: Commands, window: Query<Entity, With<Prima
 }
 
 fn click_to_focus(
-    ev: On<Pointer<Press>>,
+    press: On<Pointer<Press>>,
     mut focus_visible: ResMut<InputFocusVisible>,
     windows: Query<Entity, With<PrimaryWindow>>,
     mut commands: Commands,
@@ -366,16 +366,17 @@ fn click_to_focus(
     // for every ancestor, but only for the original entity. Also, users may want to stop
     // propagation on the pointer event at some point along the bubbling chain, so we need our
     // own dedicated event whose propagation we can control.
-    if ev.entity() == ev.original_entity() {
+    if press.entity == press.original_event_target() {
         // Clicking hides focus
         if focus_visible.0 {
             focus_visible.0 = false;
         }
         // Search for a focusable parent entity, defaulting to window if none.
         if let Ok(window) = windows.single() {
-            commands
-                .entity(ev.entity())
-                .trigger(AcquireFocus { window });
+            commands.trigger(AcquireFocus {
+                focused_entity: press.entity,
+                window,
+            });
         }
     }
 }
diff --git a/crates/bevy_pbr/src/render/light.rs b/crates/bevy_pbr/src/render/light.rs
index 155f2b2f2b9e9..8bce0f4556bb6 100644
--- a/crates/bevy_pbr/src/render/light.rs
+++ b/crates/bevy_pbr/src/render/light.rs
@@ -614,30 +614,30 @@ pub struct LightViewEntities(EntityHashMap<Vec<Entity>>);
 
 // TODO: using required component
 pub(crate) fn add_light_view_entities(
-    event: On<Add, (ExtractedDirectionalLight, ExtractedPointLight)>,
+    add: On<Add, (ExtractedDirectionalLight, ExtractedPointLight)>,
     mut commands: Commands,
 ) {
-    if let Ok(mut v) = commands.get_entity(event.entity()) {
+    if let Ok(mut v) = commands.get_entity(add.entity) {
         v.insert(LightViewEntities::default());
     }
 }
 
 /// Removes [`LightViewEntities`] when light is removed. See [`add_light_view_entities`].
 pub(crate) fn extracted_light_removed(
-    event: On<Remove, (ExtractedDirectionalLight, ExtractedPointLight)>,
+    remove: On<Remove, (ExtractedDirectionalLight, ExtractedPointLight)>,
     mut commands: Commands,
 ) {
-    if let Ok(mut v) = commands.get_entity(event.entity()) {
+    if let Ok(mut v) = commands.get_entity(remove.entity) {
         v.try_remove::<LightViewEntities>();
     }
 }
 
 pub(crate) fn remove_light_view_entities(
-    event: On<Remove, LightViewEntities>,
+    remove: On<Remove, LightViewEntities>,
     query: Query<&LightViewEntities>,
     mut commands: Commands,
 ) {
-    if let Ok(entities) = query.get(event.entity()) {
+    if let Ok(entities) = query.get(remove.entity) {
         for v in entities.0.values() {
             for e in v.iter().copied() {
                 if let Ok(mut v) = commands.get_entity(e) {
diff --git a/crates/bevy_picking/src/events.rs b/crates/bevy_picking/src/events.rs
index 97e6bfad3b56d..18a1ec8145c1c 100644
--- a/crates/bevy_picking/src/events.rs
+++ b/crates/bevy_picking/src/events.rs
@@ -60,9 +60,11 @@ use crate::{
 /// The documentation for the [`pointer_events`] explains the events this module exposes and
 /// the order in which they fire.
 #[derive(BufferedEvent, EntityEvent, Clone, PartialEq, Debug, Reflect, Component)]
-#[entity_event(traversal = PointerTraversal, auto_propagate)]
+#[entity_event(propagate = PointerTraversal, auto_propagate)]
 #[reflect(Component, Debug, Clone)]
 pub struct Pointer<E: Debug + Clone + Reflect> {
+    /// The entity this pointer event happened for.
+    pub entity: Entity,
     /// The pointer that triggered this event
     pub pointer_id: PointerId,
     /// The location of the pointer during this event
@@ -124,11 +126,12 @@ impl<E: Debug + Clone + Reflect> core::ops::Deref for Pointer<E> {
 
 impl<E: Debug + Clone + Reflect> Pointer<E> {
     /// Construct a new `Pointer<E>` event.
-    pub fn new(id: PointerId, location: Location, event: E) -> Self {
+    pub fn new(id: PointerId, location: Location, event: E, entity: Entity) -> Self {
         Self {
             pointer_id: id,
             pointer_location: location,
             event,
+            entity,
         }
     }
 }
@@ -141,7 +144,7 @@ pub struct Cancel {
     pub hit: HitData,
 }
 
-/// Fires when a pointer crosses into the bounds of the [target entity](On::entity).
+/// Fires when a pointer crosses into the bounds of the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Over {
@@ -149,7 +152,7 @@ pub struct Over {
     pub hit: HitData,
 }
 
-/// Fires when a pointer crosses out of the bounds of the [target entity](On::entity).
+/// Fires when a pointer crosses out of the bounds of the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Out {
@@ -157,7 +160,7 @@ pub struct Out {
     pub hit: HitData,
 }
 
-/// Fires when a pointer button is pressed over the [target entity](On::entity).
+/// Fires when a pointer button is pressed over the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Press {
@@ -167,7 +170,7 @@ pub struct Press {
     pub hit: HitData,
 }
 
-/// Fires when a pointer button is released over the [target entity](On::entity).
+/// Fires when a pointer button is released over the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Release {
@@ -178,7 +181,7 @@ pub struct Release {
 }
 
 /// Fires when a pointer sends a pointer pressed event followed by a pointer released event, with the same
-/// [target entity](On::entity) for both events.
+/// [target entity](EntityEvent::event_target) for both events.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Click {
@@ -190,7 +193,7 @@ pub struct Click {
     pub duration: Duration,
 }
 
-/// Fires while a pointer is moving over the [target entity](On::entity).
+/// Fires while a pointer is moving over the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Move {
@@ -205,7 +208,7 @@ pub struct Move {
     pub delta: Vec2,
 }
 
-/// Fires when the [target entity](On::entity) receives a pointer pressed event followed by a pointer move event.
+/// Fires when the [target entity](EntityEvent::event_target) receives a pointer pressed event followed by a pointer move event.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct DragStart {
@@ -215,7 +218,7 @@ pub struct DragStart {
     pub hit: HitData,
 }
 
-/// Fires while the [target entity](On::entity) is being dragged.
+/// Fires while the [target entity](EntityEvent::event_target) is being dragged.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Drag {
@@ -237,7 +240,7 @@ pub struct Drag {
     pub delta: Vec2,
 }
 
-/// Fires when a pointer is dragging the [target entity](On::entity) and a pointer released event is received.
+/// Fires when a pointer is dragging the [target entity](EntityEvent::event_target) and a pointer released event is received.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct DragEnd {
@@ -252,49 +255,49 @@ pub struct DragEnd {
     pub distance: Vec2,
 }
 
-/// Fires when a pointer dragging the `dragged` entity enters the [target entity](On::entity).
+/// Fires when a pointer dragging the `dragged` entity enters the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct DragEnter {
     /// Pointer button pressed to enter drag.
     pub button: PointerButton,
-    /// The entity that was being dragged when the pointer entered the [target entity](On::entity).
+    /// The entity that was being dragged when the pointer entered the [target entity](EntityEvent::event_target).
     pub dragged: Entity,
     /// Information about the picking intersection.
     pub hit: HitData,
 }
 
-/// Fires while the `dragged` entity is being dragged over the [target entity](On::entity).
+/// Fires while the `dragged` entity is being dragged over the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct DragOver {
     /// Pointer button pressed while dragging over.
     pub button: PointerButton,
-    /// The entity that was being dragged when the pointer was over the [target entity](On::entity).
+    /// The entity that was being dragged when the pointer was over the [target entity](EntityEvent::event_target).
     pub dragged: Entity,
     /// Information about the picking intersection.
     pub hit: HitData,
 }
 
-/// Fires when a pointer dragging the `dragged` entity leaves the [target entity](On::entity).
+/// Fires when a pointer dragging the `dragged` entity leaves the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct DragLeave {
     /// Pointer button pressed while leaving drag.
     pub button: PointerButton,
-    /// The entity that was being dragged when the pointer left the [target entity](On::entity).
+    /// The entity that was being dragged when the pointer left the [target entity](EntityEvent::event_target).
     pub dragged: Entity,
     /// Information about the latest prior picking intersection.
     pub hit: HitData,
 }
 
-/// Fires when a pointer drops the `dropped` entity onto the [target entity](On::entity).
+/// Fires when a pointer drops the `dropped` entity onto the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct DragDrop {
     /// Pointer button released to drop.
     pub button: PointerButton,
-    /// The entity that was dropped onto the [target entity](On::entity).
+    /// The entity that was dropped onto the [target entity](EntityEvent::event_target).
     pub dropped: Entity,
     /// Information about the picking intersection.
     pub hit: HitData,
@@ -322,7 +325,7 @@ pub struct DragEntry {
     pub latest_pos: Vec2,
 }
 
-/// Fires while a pointer is scrolling over the [target entity](On::entity).
+/// Fires while a pointer is scrolling over the [target entity](EntityEvent::event_target).
 #[derive(Clone, PartialEq, Debug, Reflect)]
 #[reflect(Clone, PartialEq)]
 pub struct Scroll {
@@ -494,8 +497,13 @@ pub fn pointer_events(
             };
 
             // Always send Out events
-            let out_event = Pointer::new(pointer_id, location.clone(), Out { hit: hit.clone() });
-            commands.trigger_targets(out_event.clone(), hovered_entity);
+            let out_event = Pointer::new(
+                pointer_id,
+                location.clone(),
+                Out { hit: hit.clone() },
+                hovered_entity,
+            );
+            commands.trigger(out_event.clone());
             event_writers.out_events.write(out_event);
 
             // Possibly send DragLeave events
@@ -511,8 +519,9 @@ pub fn pointer_events(
                             dragged: *drag_target,
                             hit: hit.clone(),
                         },
+                        hovered_entity,
                     );
-                    commands.trigger_targets(drag_leave_event.clone(), hovered_entity);
+                    commands.trigger(drag_leave_event.clone());
                     event_writers.drag_leave_events.write(drag_leave_event);
                 }
             }
@@ -552,15 +561,21 @@ pub fn pointer_events(
                             dragged: *drag_target,
                             hit: hit.clone(),
                         },
+                        hovered_entity,
                     );
-                    commands.trigger_targets(drag_enter_event.clone(), hovered_entity);
+                    commands.trigger(drag_enter_event.clone());
                     event_writers.drag_enter_events.write(drag_enter_event);
                 }
             }
 
             // Always send Over events
-            let over_event = Pointer::new(pointer_id, location.clone(), Over { hit: hit.clone() });
-            commands.trigger_targets(over_event.clone(), hovered_entity);
+            let over_event = Pointer::new(
+                pointer_id,
+                location.clone(),
+                Over { hit: hit.clone() },
+                hovered_entity,
+            );
+            commands.trigger(over_event.clone());
             event_writers.over_events.write(over_event);
         }
     }
@@ -589,8 +604,9 @@ pub fn pointer_events(
                             button,
                             hit: hit.clone(),
                         },
+                        hovered_entity,
                     );
-                    commands.trigger_targets(pressed_event.clone(), hovered_entity);
+                    commands.trigger(pressed_event.clone());
                     event_writers.pressed_events.write(pressed_event);
                     // Also insert the press into the state
                     state
@@ -617,8 +633,9 @@ pub fn pointer_events(
                                 hit: hit.clone(),
                                 duration: now - *press_instant,
                             },
+                            hovered_entity,
                         );
-                        commands.trigger_targets(click_event.clone(), hovered_entity);
+                        commands.trigger(click_event.clone());
                         event_writers.click_events.write(click_event);
                     }
                     // Always send the Release event
@@ -629,8 +646,9 @@ pub fn pointer_events(
                             button,
                             hit: hit.clone(),
                         },
+                        hovered_entity,
                     );
-                    commands.trigger_targets(released_event.clone(), hovered_entity);
+                    commands.trigger(released_event.clone());
                     event_writers.released_events.write(released_event);
                 }
 
@@ -646,8 +664,9 @@ pub fn pointer_events(
                                 dropped: drag_target,
                                 hit: hit.clone(),
                             },
+                            *dragged_over,
                         );
-                        commands.trigger_targets(drag_drop_event.clone(), *dragged_over);
+                        commands.trigger(drag_drop_event.clone());
                         event_writers.drag_drop_events.write(drag_drop_event);
                     }
                     // Emit DragEnd
@@ -658,8 +677,9 @@ pub fn pointer_events(
                             button,
                             distance: drag.latest_pos - drag.start_pos,
                         },
+                        drag_target,
                     );
-                    commands.trigger_targets(drag_end_event.clone(), drag_target);
+                    commands.trigger(drag_end_event.clone());
                     event_writers.drag_end_events.write(drag_end_event);
                     // Emit DragLeave
                     for (dragged_over, hit) in state.dragging_over.iter() {
@@ -671,8 +691,9 @@ pub fn pointer_events(
                                 dragged: drag_target,
                                 hit: hit.clone(),
                             },
+                            *dragged_over,
                         );
-                        commands.trigger_targets(drag_leave_event.clone(), *dragged_over);
+                        commands.trigger(drag_leave_event.clone());
                         event_writers.drag_leave_events.write(drag_leave_event);
                     }
                 }
@@ -710,8 +731,9 @@ pub fn pointer_events(
                                 button,
                                 hit: hit.clone(),
                             },
+                            *press_target,
                         );
-                        commands.trigger_targets(drag_start_event.clone(), *press_target);
+                        commands.trigger(drag_start_event.clone());
                         event_writers.drag_start_events.write(drag_start_event);
                     }
 
@@ -729,8 +751,9 @@ pub fn pointer_events(
                                 distance: location.position - drag.start_pos,
                                 delta,
                             },
+                            *drag_target,
                         );
-                        commands.trigger_targets(drag_event.clone(), *drag_target);
+                        commands.trigger(drag_event.clone());
                         event_writers.drag_events.write(drag_event);
 
                         // Update drag position
@@ -751,8 +774,9 @@ pub fn pointer_events(
                                     dragged: *drag_target,
                                     hit: hit.clone(),
                                 },
+                                hovered_entity,
                             );
-                            commands.trigger_targets(drag_over_event.clone(), hovered_entity);
+                            commands.trigger(drag_over_event.clone());
                             event_writers.drag_over_events.write(drag_over_event);
                         }
                     }
@@ -771,8 +795,9 @@ pub fn pointer_events(
                             hit: hit.clone(),
                             delta,
                         },
+                        hovered_entity,
                     );
-                    commands.trigger_targets(move_event.clone(), hovered_entity);
+                    commands.trigger(move_event.clone());
                     event_writers.move_events.write(move_event);
                 }
             }
@@ -792,8 +817,9 @@ pub fn pointer_events(
                             y,
                             hit: hit.clone(),
                         },
+                        hovered_entity,
                     );
-                    commands.trigger_targets(scroll_event.clone(), hovered_entity);
+                    commands.trigger(scroll_event.clone());
                     event_writers.scroll_events.write(scroll_event);
                 }
             }
@@ -805,8 +831,9 @@ pub fn pointer_events(
                     .iter()
                     .flat_map(|h| h.iter().map(|(entity, data)| (*entity, data.to_owned())))
                 {
-                    let cancel_event = Pointer::new(pointer_id, location.clone(), Cancel { hit });
-                    commands.trigger_targets(cancel_event.clone(), hovered_entity);
+                    let cancel_event =
+                        Pointer::new(pointer_id, location.clone(), Cancel { hit }, hovered_entity);
+                    commands.trigger(cancel_event.clone());
                     event_writers.cancel_events.write(cancel_event);
                 }
                 // Clear the state for the canceled pointer
diff --git a/crates/bevy_picking/src/lib.rs b/crates/bevy_picking/src/lib.rs
index 58d2e96410329..887d8f772ea2e 100644
--- a/crates/bevy_picking/src/lib.rs
+++ b/crates/bevy_picking/src/lib.rs
@@ -53,15 +53,15 @@
 //!     commands.spawn(Transform::default())
 //!         // Spawn your entity here, e.g. a `Mesh3d`.
 //!         // When dragged, mutate the `Transform` component on the dragged target entity:
-//!         .observe(|event: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>| {
-//!             let mut transform = transforms.get_mut(event.entity()).unwrap();
-//!             transform.rotate_local_y(event.delta.x / 50.0);
+//!         .observe(|drag: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>| {
+//!             let mut transform = transforms.get_mut(drag.entity).unwrap();
+//!             transform.rotate_local_y(drag.delta.x / 50.0);
 //!         })
-//!         .observe(|event: On<Pointer<Click>>, mut commands: Commands| {
-//!             println!("Entity {} goes BOOM!", event.entity());
-//!             commands.entity(event.entity()).despawn();
+//!         .observe(|click: On<Pointer<Click>>, mut commands: Commands| {
+//!             println!("Entity {} goes BOOM!", click.entity);
+//!             commands.entity(click.entity).despawn();
 //!         })
-//!         .observe(|event: On<Pointer<Over>>, mut events: EventWriter<Greeting>| {
+//!         .observe(|over: On<Pointer<Over>>, mut events: EventWriter<Greeting>| {
 //!             events.write(Greeting);
 //!         });
 //! }
diff --git a/crates/bevy_remote/src/builtin_methods.rs b/crates/bevy_remote/src/builtin_methods.rs
index 42ae39887497b..16573b978a4ca 100644
--- a/crates/bevy_remote/src/builtin_methods.rs
+++ b/crates/bevy_remote/src/builtin_methods.rs
@@ -849,7 +849,7 @@ pub fn process_remote_query_request(In(params): In<Option<Value>>, world: &mut W
                 let all_optionals =
                     entity_ref
                         .archetype()
-                        .components()
+                        .iter_components()
                         .filter_map(|component_id| {
                             let info = world.components().get_info(component_id)?;
                             let type_id = info.type_id()?;
@@ -1262,7 +1262,7 @@ pub fn process_remote_list_components_request(
     // If `Some`, return all components of the provided entity.
     if let Some(BrpListComponentsParams { entity }) = params.map(parse).transpose()? {
         let entity = get_entity(world, entity)?;
-        for component_id in entity.archetype().components() {
+        for component_id in entity.archetype().iter_components() {
             let Some(component_info) = world.components().get_info(component_id) else {
                 continue;
             };
@@ -1316,7 +1316,7 @@ pub fn process_remote_list_components_watching_request(
     let entity_ref = get_entity(world, entity)?;
     let mut response = BrpListComponentsWatchingResponse::default();
 
-    for component_id in entity_ref.archetype().components() {
+    for component_id in entity_ref.archetype().iter_components() {
         let ticks = entity_ref
             .get_change_ticks_by_id(component_id)
             .ok_or(BrpError::internal("Failed to get ticks"))?;
diff --git a/crates/bevy_render/src/gpu_readback.rs b/crates/bevy_render/src/gpu_readback.rs
index 712479dd5326c..efb79a9f7ea8c 100644
--- a/crates/bevy_render/src/gpu_readback.rs
+++ b/crates/bevy_render/src/gpu_readback.rs
@@ -113,13 +113,17 @@ impl Readback {
 /// requested buffer or texture.
 #[derive(EntityEvent, Deref, DerefMut, Reflect, Debug)]
 #[reflect(Debug)]
-pub struct ReadbackComplete(pub Vec<u8>);
+pub struct ReadbackComplete {
+    pub entity: Entity,
+    #[deref]
+    pub data: Vec<u8>,
+}
 
 impl ReadbackComplete {
     /// Convert the raw bytes of the event to a shader type.
     pub fn to_shader_type<T: ShaderType + ReadFrom + Default>(&self) -> T {
         let mut val = T::default();
-        let mut reader = Reader::new::<T>(&self.0, 0).expect("Failed to create Reader");
+        let mut reader = Reader::new::<T>(&self.data, 0).expect("Failed to create Reader");
         T::read_from(&mut val, &mut reader);
         val
     }
@@ -234,8 +238,8 @@ fn sync_readbacks(
     max_unused_frames: Res<GpuReadbackMaxUnusedFrames>,
 ) {
     readbacks.mapped.retain(|readback| {
-        if let Ok((entity, buffer, result)) = readback.rx.try_recv() {
-            main_world.trigger_targets(ReadbackComplete(result), entity);
+        if let Ok((entity, buffer, data)) = readback.rx.try_recv() {
+            main_world.trigger(ReadbackComplete { data, entity });
             buffer_pool.return_buffer(&buffer);
             false
         } else {
diff --git a/crates/bevy_render/src/sync_world.rs b/crates/bevy_render/src/sync_world.rs
index f5cdff8fba38b..d9a8a430b28fe 100644
--- a/crates/bevy_render/src/sync_world.rs
+++ b/crates/bevy_render/src/sync_world.rs
@@ -1,10 +1,9 @@
 use bevy_app::Plugin;
 use bevy_derive::{Deref, DerefMut};
-use bevy_ecs::entity::EntityHash;
-use bevy_ecs::lifecycle::{Add, Remove};
 use bevy_ecs::{
     component::Component,
-    entity::{ContainsEntity, Entity, EntityEquivalent},
+    entity::{ContainsEntity, Entity, EntityEquivalent, EntityHash},
+    lifecycle::{Add, Remove},
     observer::On,
     query::With,
     reflect::ReflectComponent,
@@ -94,15 +93,15 @@ impl Plugin for SyncWorldPlugin {
     fn build(&self, app: &mut bevy_app::App) {
         app.init_resource::<PendingSyncEntity>();
         app.add_observer(
-            |event: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
-                pending.push(EntityRecord::Added(event.entity()));
+            |add: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
+                pending.push(EntityRecord::Added(add.entity));
             },
         );
         app.add_observer(
-            |event: On<Remove, SyncToRenderWorld>,
+            |remove: On<Remove, SyncToRenderWorld>,
              mut pending: ResMut<PendingSyncEntity>,
              query: Query<&RenderEntity>| {
-                if let Ok(e) = query.get(event.entity()) {
+                if let Ok(e) = query.get(remove.entity) {
                     pending.push(EntityRecord::Removed(*e));
                 };
             },
@@ -526,15 +525,15 @@ mod tests {
         main_world.init_resource::<PendingSyncEntity>();
 
         main_world.add_observer(
-            |event: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
-                pending.push(EntityRecord::Added(event.entity()));
+            |add: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
+                pending.push(EntityRecord::Added(add.entity));
             },
         );
         main_world.add_observer(
-            |event: On<Remove, SyncToRenderWorld>,
+            |remove: On<Remove, SyncToRenderWorld>,
              mut pending: ResMut<PendingSyncEntity>,
              query: Query<&RenderEntity>| {
-                if let Ok(e) = query.get(event.entity()) {
+                if let Ok(e) = query.get(remove.entity) {
                     pending.push(EntityRecord::Removed(*e));
                 };
             },
diff --git a/crates/bevy_render/src/view/window/screenshot.rs b/crates/bevy_render/src/view/window/screenshot.rs
index 19311f796d671..991ca9bcb23bc 100644
--- a/crates/bevy_render/src/view/window/screenshot.rs
+++ b/crates/bevy_render/src/view/window/screenshot.rs
@@ -39,9 +39,13 @@ use std::{
 use tracing::{error, info, warn};
 use wgpu::{CommandEncoder, Extent3d, TextureFormat};
 
-#[derive(EntityEvent, Deref, DerefMut, Reflect, Debug)]
+#[derive(EntityEvent, Reflect, Deref, DerefMut, Debug)]
 #[reflect(Debug)]
-pub struct ScreenshotCaptured(pub Image);
+pub struct ScreenshotCaptured {
+    pub entity: Entity,
+    #[deref]
+    pub image: Image,
+}
 
 /// A component that signals to the renderer to capture a screenshot this frame.
 ///
@@ -124,8 +128,8 @@ struct RenderScreenshotsSender(Sender<(Entity, Image)>);
 /// Saves the captured screenshot to disk at the provided path.
 pub fn save_to_disk(path: impl AsRef<Path>) -> impl FnMut(On<ScreenshotCaptured>) {
     let path = path.as_ref().to_owned();
-    move |event| {
-        let img = event.0.clone();
+    move |screenshot_captured| {
+        let img = screenshot_captured.image.clone();
         match img.try_into_dynamic() {
             Ok(dyn_img) => match image::ImageFormat::from_path(&path) {
                 Ok(format) => {
@@ -196,7 +200,7 @@ pub fn trigger_screenshots(
     let captured_screenshots = captured_screenshots.lock().unwrap();
     while let Ok((entity, image)) = captured_screenshots.try_recv() {
         commands.entity(entity).insert(Captured);
-        commands.trigger_targets(ScreenshotCaptured(image), entity);
+        commands.trigger(ScreenshotCaptured { image, entity });
     }
 }
 
diff --git a/crates/bevy_scene/src/dynamic_scene_builder.rs b/crates/bevy_scene/src/dynamic_scene_builder.rs
index ee0b15847a315..feddacfdfb091 100644
--- a/crates/bevy_scene/src/dynamic_scene_builder.rs
+++ b/crates/bevy_scene/src/dynamic_scene_builder.rs
@@ -283,7 +283,7 @@ impl<'w> DynamicSceneBuilder<'w> {
             };
 
             let original_entity = self.original_world.entity(entity);
-            for component_id in original_entity.archetype().components() {
+            for component_id in original_entity.archetype().iter_components() {
                 let mut extract_and_push = || {
                     let type_id = self
                         .original_world
diff --git a/crates/bevy_scene/src/scene.rs b/crates/bevy_scene/src/scene.rs
index 255f688673c86..db92bdc468431 100644
--- a/crates/bevy_scene/src/scene.rs
+++ b/crates/bevy_scene/src/scene.rs
@@ -119,7 +119,7 @@ impl Scene {
                     .get(&scene_entity.id())
                     .expect("should have previously spawned an entity");
 
-                for component_id in archetype.components() {
+                for component_id in archetype.iter_components() {
                     let component_info = self
                         .world
                         .components()
diff --git a/crates/bevy_scene/src/scene_spawner.rs b/crates/bevy_scene/src/scene_spawner.rs
index f3a9ab7e149de..76b47d62d86f2 100644
--- a/crates/bevy_scene/src/scene_spawner.rs
+++ b/crates/bevy_scene/src/scene_spawner.rs
@@ -30,6 +30,8 @@ use bevy_ecs::{
 #[derive(Clone, Copy, Debug, Eq, PartialEq, EntityEvent, Reflect)]
 #[reflect(Debug, PartialEq, Clone)]
 pub struct SceneInstanceReady {
+    /// The entity whose scene instance is ready.
+    pub entity: Entity,
     /// Instance which has been spawned.
     pub instance_id: InstanceId,
 }
@@ -506,12 +508,18 @@ impl SceneSpawner {
         for (instance_id, parent) in self.instances_ready.drain(..) {
             if let Some(parent) = parent {
                 // Defer via commands otherwise SceneSpawner is not available in the observer.
-                world
-                    .commands()
-                    .trigger_targets(SceneInstanceReady { instance_id }, parent);
+                world.commands().trigger(SceneInstanceReady {
+                    instance_id,
+                    entity: parent,
+                });
             } else {
                 // Defer via commands otherwise SceneSpawner is not available in the observer.
-                world.commands().trigger(SceneInstanceReady { instance_id });
+                // TODO: triggering this for PLACEHOLDER is suboptimal, but this scene system is on
+                // its way out, so lets avoid breaking people by making a second event.
+                world.commands().trigger(SceneInstanceReady {
+                    instance_id,
+                    entity: Entity::PLACEHOLDER,
+                });
             }
         }
     }
@@ -889,7 +897,7 @@ mod tests {
                     "`SceneInstanceReady` contains the wrong `InstanceId`"
                 );
                 assert_eq!(
-                    event.entity(),
+                    event.event_target(),
                     scene_entity.unwrap_or(Entity::PLACEHOLDER),
                     "`SceneInstanceReady` triggered on the wrong parent entity"
                 );
diff --git a/crates/bevy_ui/src/interaction_states.rs b/crates/bevy_ui/src/interaction_states.rs
index 88df5eebb9681..a5793ca778a57 100644
--- a/crates/bevy_ui/src/interaction_states.rs
+++ b/crates/bevy_ui/src/interaction_states.rs
@@ -18,15 +18,18 @@ use bevy_ecs::{
 #[derive(Component, Debug, Clone, Copy, Default)]
 pub struct InteractionDisabled;
 
-pub(crate) fn on_add_disabled(event: On<Add, InteractionDisabled>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn on_add_disabled(add: On<Add, InteractionDisabled>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(add.entity);
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_disabled();
     }
 }
 
-pub(crate) fn on_remove_disabled(event: On<Remove, InteractionDisabled>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn on_remove_disabled(
+    remove: On<Remove, InteractionDisabled>,
+    mut world: DeferredWorld,
+) {
+    let mut entity = world.entity_mut(remove.entity);
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.clear_disabled();
     }
@@ -45,8 +48,8 @@ pub struct Checkable;
 #[derive(Component, Default, Debug)]
 pub struct Checked;
 
-pub(crate) fn on_add_checkable(event: On<Add, Checked>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn on_add_checkable(add: On<Add, Checked>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(add.entity);
     let checked = entity.get::<Checked>().is_some();
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_toggled(match checked {
@@ -56,23 +59,23 @@ pub(crate) fn on_add_checkable(event: On<Add, Checked>, mut world: DeferredWorld
     }
 }
 
-pub(crate) fn on_remove_checkable(event: On<Add, Checked>, mut world: DeferredWorld) {
+pub(crate) fn on_remove_checkable(add: On<Add, Checked>, mut world: DeferredWorld) {
     // Remove the 'toggled' attribute entirely.
-    let mut entity = world.entity_mut(event.entity());
+    let mut entity = world.entity_mut(add.entity);
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.clear_toggled();
     }
 }
 
-pub(crate) fn on_add_checked(event: On<Add, Checked>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn on_add_checked(add: On<Add, Checked>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(add.entity);
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_toggled(accesskit::Toggled::True);
     }
 }
 
-pub(crate) fn on_remove_checked(event: On<Remove, Checked>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(event.entity());
+pub(crate) fn on_remove_checked(remove: On<Remove, Checked>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(remove.entity);
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_toggled(accesskit::Toggled::False);
     }
diff --git a/crates/bevy_winit/src/cursor/mod.rs b/crates/bevy_winit/src/cursor/mod.rs
index c946a5160fefb..d857111ba43b7 100644
--- a/crates/bevy_winit/src/cursor/mod.rs
+++ b/crates/bevy_winit/src/cursor/mod.rs
@@ -222,10 +222,10 @@ fn update_cursors(
 }
 
 /// Resets the cursor to the default icon when `CursorIcon` is removed.
-fn on_remove_cursor_icon(event: On<Remove, CursorIcon>, mut commands: Commands) {
+fn on_remove_cursor_icon(remove: On<Remove, CursorIcon>, mut commands: Commands) {
     // Use `try_insert` to avoid panic if the window is being destroyed.
     commands
-        .entity(event.entity())
+        .entity(remove.entity)
         .try_insert(PendingCursor(Some(CursorSource::System(
             convert_system_cursor_icon(SystemCursorIcon::Default),
         ))));
diff --git a/examples/3d/edit_material_on_gltf.rs b/examples/3d/edit_material_on_gltf.rs
index 2bc5a79d6da7d..9379a004b83e0 100644
--- a/examples/3d/edit_material_on_gltf.rs
+++ b/examples/3d/edit_material_on_gltf.rs
@@ -49,16 +49,16 @@ fn setup_scene(mut commands: Commands, asset_server: Res<AssetServer>) {
 }
 
 fn change_material(
-    event: On<SceneInstanceReady>,
+    scene_ready: On<SceneInstanceReady>,
     mut commands: Commands,
     children: Query<&Children>,
     color_override: Query<&ColorOverride>,
     mesh_materials: Query<(&MeshMaterial3d<StandardMaterial>, &GltfMaterialName)>,
     mut asset_materials: ResMut<Assets<StandardMaterial>>,
 ) {
-    info!("processing Scene Entity: {}", event.entity());
+    info!("processing Scene Entity: {}", scene_ready.entity);
     // Iterate over all children recursively
-    for descendant in children.iter_descendants(event.entity()) {
+    for descendant in children.iter_descendants(scene_ready.entity) {
         // Get the material id and name which were created from the glTF file information
         let Ok((id, material_name)) = mesh_materials.get(descendant) else {
             continue;
@@ -73,7 +73,7 @@ fn change_material(
             "LeatherPartsMat" => {
                 info!("editing LeatherPartsMat to use ColorOverride tint");
                 // Get the `ColorOverride` of the entity, if it does not have a color override, skip
-                let Ok(color_override) = color_override.get(event.entity()) else {
+                let Ok(color_override) = color_override.get(scene_ready.entity) else {
                     continue;
                 };
                 // Create a copy of the material and override base color
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 8a3314f4e285f..b3eaec1112b2d 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -159,7 +159,7 @@ fn setup(
 }
 
 fn add_raytracing_meshes_on_scene_load(
-    event: On<SceneInstanceReady>,
+    scene_ready: On<SceneInstanceReady>,
     children: Query<&Children>,
     mesh_query: Query<(
         &Mesh3d,
@@ -171,7 +171,7 @@ fn add_raytracing_meshes_on_scene_load(
     mut commands: Commands,
     args: Res<Args>,
 ) {
-    for descendant in children.iter_descendants(event.entity()) {
+    for descendant in children.iter_descendants(scene_ready.entity) {
         if let Ok((Mesh3d(mesh_handle), MeshMaterial3d(material_handle), material_name)) =
             mesh_query.get(descendant)
         {
diff --git a/examples/animation/animated_mesh.rs b/examples/animation/animated_mesh.rs
index 7ae660c30d224..466d53be2ff22 100644
--- a/examples/animation/animated_mesh.rs
+++ b/examples/animation/animated_mesh.rs
@@ -62,7 +62,7 @@ fn setup_mesh_and_animation(
 }
 
 fn play_animation_when_ready(
-    event: On<SceneInstanceReady>,
+    scene_ready: On<SceneInstanceReady>,
     mut commands: Commands,
     children: Query<&Children>,
     animations_to_play: Query<&AnimationToPlay>,
@@ -70,12 +70,12 @@ fn play_animation_when_ready(
 ) {
     // The entity we spawned in `setup_mesh_and_animation` is the trigger's target.
     // Start by finding the AnimationToPlay component we added to that entity.
-    if let Ok(animation_to_play) = animations_to_play.get(event.entity()) {
+    if let Ok(animation_to_play) = animations_to_play.get(scene_ready.entity) {
         // The SceneRoot component will have spawned the scene as a hierarchy
         // of entities parented to our entity. Since the asset contained a skinned
         // mesh and animations, it will also have spawned an animation player
         // component. Search our entity's descendants to find the animation player.
-        for child in children.iter_descendants(event.entity()) {
+        for child in children.iter_descendants(scene_ready.entity) {
             if let Ok(mut player) = players.get_mut(child) {
                 // Tell the animation player to start the animation and keep
                 // repeating it.
diff --git a/examples/animation/animated_mesh_events.rs b/examples/animation/animated_mesh_events.rs
index 776b8a0e21503..5898807cf45a3 100644
--- a/examples/animation/animated_mesh_events.rs
+++ b/examples/animation/animated_mesh_events.rs
@@ -3,7 +3,9 @@
 use std::{f32::consts::PI, time::Duration};
 
 use bevy::{
-    animation::AnimationTargetId, color::palettes::css::WHITE, light::CascadeShadowConfigBuilder,
+    animation::{AnimationEvent, AnimationTargetId},
+    color::palettes::css::WHITE,
+    light::CascadeShadowConfigBuilder,
     prelude::*,
 };
 use rand::{Rng, SeedableRng};
@@ -37,17 +39,19 @@ struct Animations {
     graph_handle: Handle<AnimationGraph>,
 }
 
-#[derive(EntityEvent, Reflect, Clone)]
-struct OnStep;
+#[derive(AnimationEvent, Reflect, Clone)]
+struct Step;
 
 fn observe_on_step(
-    event: On<OnStep>,
+    step: On<Step>,
     particle: Res<ParticleAssets>,
     mut commands: Commands,
     transforms: Query<&GlobalTransform>,
     mut seeded_rng: ResMut<SeededRng>,
-) {
-    let translation = transforms.get(event.entity()).unwrap().translation();
+) -> Result {
+    let translation = transforms
+        .get(step.trigger().animation_player)?
+        .translation();
     // Spawn a bunch of particles.
     for _ in 0..14 {
         let horizontal = seeded_rng.0.random::<Dir2>() * seeded_rng.0.random_range(8.0..12.0);
@@ -72,6 +76,7 @@ fn observe_on_step(
             },
         ));
     }
+    Ok(())
 }
 
 fn setup(
@@ -164,10 +169,10 @@ fn setup_scene_once_loaded(
         // You can determine the time an event should trigger if you know witch frame it occurs and
         // the frame rate of the animation. Let's say we want to trigger an event at frame 15,
         // and the animation has a frame rate of 24 fps, then time = 15 / 24 = 0.625.
-        running_animation.add_event_to_target(feet.front_left, 0.625, OnStep);
-        running_animation.add_event_to_target(feet.front_right, 0.5, OnStep);
-        running_animation.add_event_to_target(feet.back_left, 0.0, OnStep);
-        running_animation.add_event_to_target(feet.back_right, 0.125, OnStep);
+        running_animation.add_event_to_target(feet.front_left, 0.625, Step);
+        running_animation.add_event_to_target(feet.front_right, 0.5, Step);
+        running_animation.add_event_to_target(feet.back_left, 0.0, Step);
+        running_animation.add_event_to_target(feet.back_right, 0.125, Step);
 
         // Start the animation
 
diff --git a/examples/animation/animation_events.rs b/examples/animation/animation_events.rs
index 2834889d1a0a3..177f6c478153a 100644
--- a/examples/animation/animation_events.rs
+++ b/examples/animation/animation_events.rs
@@ -1,6 +1,7 @@
 //! Demonstrate how to use animation events.
 
 use bevy::{
+    animation::AnimationEvent,
     color::palettes::css::{ALICE_BLUE, BLACK, CRIMSON},
     post_process::bloom::Bloom,
     prelude::*,
@@ -11,26 +12,26 @@ fn main() {
         .add_plugins(DefaultPlugins)
         .add_systems(Startup, setup)
         .add_systems(Update, animate_text_opacity)
-        .add_observer(edit_message)
+        .add_observer(on_set_message)
         .run();
 }
 
 #[derive(Component)]
 struct MessageText;
 
-#[derive(EntityEvent, Clone)]
-struct MessageEvent {
+#[derive(AnimationEvent, Clone)]
+struct SetMessage {
     value: String,
     color: Color,
 }
 
-fn edit_message(
-    event: On<MessageEvent>,
+fn on_set_message(
+    set_message: On<SetMessage>,
     text: Single<(&mut Text2d, &mut TextColor), With<MessageText>>,
 ) {
     let (mut text, mut color) = text.into_inner();
-    text.0 = event.value.clone();
-    color.0 = event.color;
+    text.0 = set_message.value.clone();
+    color.0 = set_message.color;
 }
 
 fn setup(
@@ -72,14 +73,14 @@ fn setup(
     // Add events at the specified time.
     animation.add_event(
         0.0,
-        MessageEvent {
+        SetMessage {
             value: "HELLO".into(),
             color: ALICE_BLUE.into(),
         },
     );
     animation.add_event(
         1.0,
-        MessageEvent {
+        SetMessage {
             value: "BYE".into(),
             color: CRIMSON.into(),
         },
diff --git a/examples/animation/morph_targets.rs b/examples/animation/morph_targets.rs
index 63e374ed7b1b4..8a9ab855bcf3b 100644
--- a/examples/animation/morph_targets.rs
+++ b/examples/animation/morph_targets.rs
@@ -56,14 +56,14 @@ fn setup(
 }
 
 fn play_animation_when_ready(
-    event: On<SceneInstanceReady>,
+    scene_ready: On<SceneInstanceReady>,
     mut commands: Commands,
     children: Query<&Children>,
     animations_to_play: Query<&AnimationToPlay>,
     mut players: Query<&mut AnimationPlayer>,
 ) {
-    if let Ok(animation_to_play) = animations_to_play.get(event.entity()) {
-        for child in children.iter_descendants(event.entity()) {
+    if let Ok(animation_to_play) = animations_to_play.get(scene_ready.entity) {
+        for child in children.iter_descendants(scene_ready.entity) {
             if let Ok(mut player) = players.get_mut(child) {
                 player.play(animation_to_play.index).repeat();
 
diff --git a/examples/ecs/entity_disabling.rs b/examples/ecs/entity_disabling.rs
index 4036523d7d46a..5360649f28ff4 100644
--- a/examples/ecs/entity_disabling.rs
+++ b/examples/ecs/entity_disabling.rs
@@ -36,19 +36,18 @@ fn main() {
 struct DisableOnClick;
 
 fn disable_entities_on_click(
-    event: On<Pointer<Click>>,
+    click: On<Pointer<Click>>,
     valid_query: Query<&DisableOnClick>,
     mut commands: Commands,
 ) {
-    let clicked_entity = event.entity();
     // Windows and text are entities and can be clicked!
     // We definitely don't want to disable the window itself,
     // because that would cause the app to close!
-    if valid_query.contains(clicked_entity) {
+    if valid_query.contains(click.entity) {
         // Just add the `Disabled` component to the entity to disable it.
         // Note that the `Disabled` component is *only* added to the entity,
         // its children are not affected.
-        commands.entity(clicked_entity).insert(Disabled);
+        commands.entity(click.entity).insert(Disabled);
     }
 }
 
diff --git a/examples/ecs/error_handling.rs b/examples/ecs/error_handling.rs
index e7ec1b54a1a0a..a84cbcd20870a 100644
--- a/examples/ecs/error_handling.rs
+++ b/examples/ecs/error_handling.rs
@@ -123,12 +123,12 @@ fn setup(
 
 // Observer systems can also return a `Result`.
 fn fallible_observer(
-    event: On<Pointer<Move>>,
+    pointer_move: On<Pointer<Move>>,
     mut world: DeferredWorld,
     mut step: Local<f32>,
 ) -> Result {
     let mut transform = world
-        .get_mut::<Transform>(event.entity())
+        .get_mut::<Transform>(pointer_move.entity)
         .ok_or("No transform found.")?;
 
     *step = if transform.translation.x > 3. {
diff --git a/examples/ecs/observer_propagation.rs b/examples/ecs/observer_propagation.rs
index d995f24d794f5..2e89a5bb43aef 100644
--- a/examples/ecs/observer_propagation.rs
+++ b/examples/ecs/observer_propagation.rs
@@ -45,17 +45,16 @@ fn setup(mut commands: Commands) {
 //
 // We enable propagation by adding the event attribute and specifying two important pieces of information.
 //
-// - **traversal:**
-// Which component we want to propagate along. In this case, we want to "bubble" (meaning propagate
-// from child to parent) so we use the `ChildOf` component for propagation. The component supplied
-// must implement the `Traversal` trait.
+// - **propagate:**
+// Enables the default propagation behavior ("bubbling" up from child to parent using the ChildOf component).
 //
 // - **auto_propagate:**
 // We can also choose whether or not this event will propagate by default when triggered. If this is
 // false, it will only propagate following a call to `On::propagate(true)`.
 #[derive(Clone, Component, EntityEvent)]
-#[entity_event(traversal = &'static ChildOf, auto_propagate)]
+#[entity_event(propagate, auto_propagate)]
 struct Attack {
+    entity: Entity,
     damage: u16,
 }
 
@@ -70,23 +69,22 @@ struct Armor(u16);
 /// A normal bevy system that attacks a piece of the goblin's armor on a timer.
 fn attack_armor(entities: Query<Entity, With<Armor>>, mut commands: Commands) {
     let mut rng = rng();
-    if let Some(target) = entities.iter().choose(&mut rng) {
+    if let Some(entity) = entities.iter().choose(&mut rng) {
         let damage = rng.random_range(1..20);
-        commands.trigger_targets(Attack { damage }, target);
+        commands.trigger(Attack { damage, entity });
         info!("  Attack for {} damage", damage);
     }
 }
 
-fn attack_hits(event: On<Attack>, name: Query<&Name>) {
-    if let Ok(name) = name.get(event.entity()) {
+fn attack_hits(attack: On<Attack>, name: Query<&Name>) {
+    if let Ok(name) = name.get(attack.entity) {
         info!("Attack hit {}", name);
     }
 }
 
 /// A callback placed on [`Armor`], checking if it absorbed all the [`Attack`] damage.
-fn block_attack(mut event: On<Attack>, armor: Query<(&Armor, &Name)>) {
-    let (armor, name) = armor.get(event.entity()).unwrap();
-    let attack = event.event_mut();
+fn block_attack(mut attack: On<Attack>, armor: Query<(&Armor, &Name)>) {
+    let (armor, name) = armor.get(attack.entity).unwrap();
     let damage = attack.damage.saturating_sub(**armor);
     if damage > 0 {
         info!(" {} damage passed through {}", damage, name);
@@ -96,7 +94,7 @@ fn block_attack(mut event: On<Attack>, armor: Query<(&Armor, &Name)>) {
     } else {
         info!("  {} damage blocked by {}", attack.damage, name);
         // Armor stopped the attack, the event stops here.
-        event.propagate(false);
+        attack.propagate(false);
         info!("(propagation halted early)\n");
     }
 }
@@ -104,20 +102,19 @@ fn block_attack(mut event: On<Attack>, armor: Query<(&Armor, &Name)>) {
 /// A callback on the armor wearer, triggered when a piece of armor is not able to block an attack,
 /// or the wearer is attacked directly.
 fn take_damage(
-    event: On<Attack>,
+    attack: On<Attack>,
     mut hp: Query<(&mut HitPoints, &Name)>,
     mut commands: Commands,
     mut app_exit: EventWriter<AppExit>,
 ) {
-    let attack = event.event();
-    let (mut hp, name) = hp.get_mut(event.entity()).unwrap();
+    let (mut hp, name) = hp.get_mut(attack.entity).unwrap();
     **hp = hp.saturating_sub(attack.damage);
 
     if **hp > 0 {
         info!("{} has {:.1} HP", name, hp.0);
     } else {
         warn!(" {} has died a gruesome death", name);
-        commands.entity(event.entity()).despawn();
+        commands.entity(attack.entity).despawn();
         app_exit.write(AppExit::Success);
     }
 
diff --git a/examples/ecs/observers.rs b/examples/ecs/observers.rs
index 99e8d75e2aad6..b3159a116cead 100644
--- a/examples/ecs/observers.rs
+++ b/examples/ecs/observers.rs
@@ -1,4 +1,4 @@
-//! Demonstrates how to observe life-cycle triggers as well as define custom ones.
+//! Demonstrates how to observe events: both component lifecycle events and custom events.
 
 use bevy::{
     platform::collections::{HashMap, HashSet},
@@ -16,18 +16,18 @@ fn main() {
         // Observers are systems that run when an event is "triggered". This observer runs whenever
         // `ExplodeMines` is triggered.
         .add_observer(
-            |event: On<ExplodeMines>,
+            |explode_mines: On<ExplodeMines>,
              mines: Query<&Mine>,
              index: Res<SpatialIndex>,
              mut commands: Commands| {
                 // Access resources
-                for e in index.get_nearby(event.pos) {
+                for entity in index.get_nearby(explode_mines.pos) {
                     // Run queries
-                    let mine = mines.get(e).unwrap();
-                    if mine.pos.distance(event.pos) < mine.size + event.radius {
+                    let mine = mines.get(entity).unwrap();
+                    if mine.pos.distance(explode_mines.pos) < mine.size + explode_mines.radius {
                         // And queue commands, including triggering additional events
                         // Here we trigger the `Explode` event for entity `e`
-                        commands.trigger_targets(Explode, e);
+                        commands.trigger(Explode { entity });
                     }
                 }
             },
@@ -58,14 +58,20 @@ impl Mine {
     }
 }
 
+/// This is a normal [`Event`]. Any observer that watches for it will run when it is triggered.
 #[derive(Event)]
 struct ExplodeMines {
     pos: Vec2,
     radius: f32,
 }
 
+/// An [`EntityEvent`] is a specialized type of [`Event`] that can target a specific entity. In addition to
+/// running normal "top level" observers when it is triggered (which target _any_ entity that Explodes), it will
+/// also run any observers that target the _specific_ entity for that event.
 #[derive(EntityEvent)]
-struct Explode;
+struct Explode {
+    entity: Entity,
+}
 
 fn setup(mut commands: Commands) {
     commands.spawn(Camera2d);
@@ -110,36 +116,35 @@ fn setup(mut commands: Commands) {
     commands.spawn(observer);
 }
 
-fn on_add_mine(event: On<Add, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
-    let mine = query.get(event.entity()).unwrap();
+fn on_add_mine(add: On<Add, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
+    let mine = query.get(add.entity).unwrap();
     let tile = (
         (mine.pos.x / CELL_SIZE).floor() as i32,
         (mine.pos.y / CELL_SIZE).floor() as i32,
     );
-    index.map.entry(tile).or_default().insert(event.entity());
+    index.map.entry(tile).or_default().insert(add.entity);
 }
 
 // Remove despawned mines from our index
-fn on_remove_mine(event: On<Remove, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
-    let mine = query.get(event.entity()).unwrap();
+fn on_remove_mine(remove: On<Remove, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
+    let mine = query.get(remove.entity).unwrap();
     let tile = (
         (mine.pos.x / CELL_SIZE).floor() as i32,
         (mine.pos.y / CELL_SIZE).floor() as i32,
     );
     index.map.entry(tile).and_modify(|set| {
-        set.remove(&event.entity());
+        set.remove(&remove.entity);
     });
 }
 
-fn explode_mine(event: On<Explode>, query: Query<&Mine>, mut commands: Commands) {
-    // If a triggered event is targeting a specific entity you can access it with `.entity()`
-    let id = event.entity();
-    let Ok(mut entity) = commands.get_entity(id) else {
+fn explode_mine(explode: On<Explode>, query: Query<&Mine>, mut commands: Commands) {
+    // Explode is an EntityEvent. `explode.entity` is the entity that Explode was triggered for.
+    let Ok(mut entity) = commands.get_entity(explode.entity) else {
         return;
     };
-    info!("Boom! {} exploded.", id.index());
+    info!("Boom! {} exploded.", explode.entity);
     entity.despawn();
-    let mine = query.get(id).unwrap();
+    let mine = query.get(explode.entity).unwrap();
     // Trigger another explosion cascade.
     commands.trigger(ExplodeMines {
         pos: mine.pos,
diff --git a/examples/ecs/removal_detection.rs b/examples/ecs/removal_detection.rs
index 88d4c4a54dd74..1216c53df37cb 100644
--- a/examples/ecs/removal_detection.rs
+++ b/examples/ecs/removal_detection.rs
@@ -48,10 +48,9 @@ fn remove_component(
     }
 }
 
-fn react_on_removal(event: On<Remove, MyComponent>, mut query: Query<&mut Sprite>) {
+fn react_on_removal(remove: On<Remove, MyComponent>, mut query: Query<&mut Sprite>) {
     // The `Remove` event was automatically triggered for the `Entity` that had its `MyComponent` removed.
-    let entity = event.entity();
-    if let Ok(mut sprite) = query.get_mut(entity) {
+    if let Ok(mut sprite) = query.get_mut(remove.entity) {
         sprite.color = Color::srgb(0.5, 1., 1.);
     }
 }
diff --git a/examples/no_std/library/src/lib.rs b/examples/no_std/library/src/lib.rs
index 734417571d7b7..e9759efc1144c 100644
--- a/examples/no_std/library/src/lib.rs
+++ b/examples/no_std/library/src/lib.rs
@@ -106,7 +106,9 @@ struct DelayedComponentTimer(Timer);
 struct DelayedComponent<B: Bundle>(B);
 
 #[derive(EntityEvent)]
-struct Unwrap;
+struct Unwrap {
+    entity: Entity,
+}
 
 fn tick_timers(
     mut commands: Commands,
@@ -117,16 +119,14 @@ fn tick_timers(
         timer.tick(time.delta());
 
         if timer.just_finished() {
-            commands
-                .entity(entity)
-                .remove::<DelayedComponentTimer>()
-                .trigger(Unwrap);
+            commands.entity(entity).remove::<DelayedComponentTimer>();
+            commands.trigger(Unwrap { entity });
         }
     }
 }
 
 fn unwrap<B: Bundle>(event: On<Unwrap>, world: &mut World) {
-    if let Ok(mut target) = world.get_entity_mut(event.entity())
+    if let Ok(mut target) = world.get_entity_mut(event.event_target())
         && let Some(DelayedComponent(bundle)) = target.take::<DelayedComponent<B>>()
     {
         target.insert(bundle);
diff --git a/examples/picking/debug_picking.rs b/examples/picking/debug_picking.rs
index e117b1896a4bb..2f784ba8e0ece 100644
--- a/examples/picking/debug_picking.rs
+++ b/examples/picking/debug_picking.rs
@@ -48,13 +48,13 @@ fn setup_scene(
         .observe(on_click_spawn_cube)
         .observe(
             |out: On<Pointer<Out>>, mut texts: Query<&mut TextColor>| {
-                let mut text_color = texts.get_mut(out.entity()).unwrap();
+                let mut text_color = texts.get_mut(out.entity).unwrap();
                 text_color.0 = Color::WHITE;
             },
         )
         .observe(
             |over: On<Pointer<Over>>, mut texts: Query<&mut TextColor>| {
-                let mut color = texts.get_mut(over.entity()).unwrap();
+                let mut color = texts.get_mut(over.entity).unwrap();
                 color.0 = bevy::color::palettes::tailwind::CYAN_400.into();
             },
         );
@@ -102,7 +102,7 @@ fn on_click_spawn_cube(
 }
 
 fn on_drag_rotate(drag: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>) {
-    if let Ok(mut transform) = transforms.get_mut(drag.entity()) {
+    if let Ok(mut transform) = transforms.get_mut(drag.entity) {
         transform.rotate_y(drag.delta.x * 0.02);
         transform.rotate_x(drag.delta.y * 0.02);
     }
diff --git a/examples/picking/mesh_picking.rs b/examples/picking/mesh_picking.rs
index 806d4da7786f2..f51b544ee3f2a 100644
--- a/examples/picking/mesh_picking.rs
+++ b/examples/picking/mesh_picking.rs
@@ -163,8 +163,8 @@ fn update_material_on<E: EntityEvent>(
     // An observer closure that captures `new_material`. We do this to avoid needing to write four
     // versions of this observer, each triggered by a different event and with a different hardcoded
     // material. Instead, the event type is a generic, and the material is passed in.
-    move |trigger, mut query| {
-        if let Ok(mut material) = query.get_mut(trigger.entity()) {
+    move |event, mut query| {
+        if let Ok(mut material) = query.get_mut(event.event_target()) {
             material.0 = new_material.clone();
         }
     }
@@ -191,7 +191,7 @@ fn rotate(mut query: Query<&mut Transform, With<Shape>>, time: Res<Time>) {
 
 /// An observer to rotate an entity when it is dragged
 fn rotate_on_drag(drag: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>) {
-    let mut transform = transforms.get_mut(drag.entity()).unwrap();
+    let mut transform = transforms.get_mut(drag.entity).unwrap();
     transform.rotate_y(drag.delta.x * 0.02);
     transform.rotate_x(drag.delta.y * 0.02);
 }
diff --git a/examples/picking/simple_picking.rs b/examples/picking/simple_picking.rs
index 8538554df1a0f..ede13012535f3 100644
--- a/examples/picking/simple_picking.rs
+++ b/examples/picking/simple_picking.rs
@@ -26,12 +26,12 @@ fn setup_scene(
         ))
         .observe(on_click_spawn_cube)
         .observe(|out: On<Pointer<Out>>, mut texts: Query<&mut TextColor>| {
-            let mut text_color = texts.get_mut(out.entity()).unwrap();
+            let mut text_color = texts.get_mut(out.entity).unwrap();
             text_color.0 = Color::WHITE;
         })
         .observe(
             |over: On<Pointer<Over>>, mut texts: Query<&mut TextColor>| {
-                let mut color = texts.get_mut(over.entity()).unwrap();
+                let mut color = texts.get_mut(over.entity).unwrap();
                 color.0 = bevy::color::palettes::tailwind::CYAN_400.into();
             },
         );
@@ -78,7 +78,7 @@ fn on_click_spawn_cube(
 }
 
 fn on_drag_rotate(drag: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>) {
-    if let Ok(mut transform) = transforms.get_mut(drag.entity()) {
+    if let Ok(mut transform) = transforms.get_mut(drag.entity) {
         transform.rotate_y(drag.delta.x * 0.02);
         transform.rotate_x(drag.delta.y * 0.02);
     }
diff --git a/examples/picking/sprite_picking.rs b/examples/picking/sprite_picking.rs
index 09bfc34d438aa..cae4ba2e082a7 100644
--- a/examples/picking/sprite_picking.rs
+++ b/examples/picking/sprite_picking.rs
@@ -154,7 +154,7 @@ fn recolor_on<E: EntityEvent + Debug + Clone + Reflect>(
     color: Color,
 ) -> impl Fn(On<E>, Query<&mut Sprite>) {
     move |ev, mut sprites| {
-        let Ok(mut sprite) = sprites.get_mut(ev.entity()) else {
+        let Ok(mut sprite) = sprites.get_mut(ev.event_target()) else {
             return;
         };
         sprite.color = color;
diff --git a/examples/stress_tests/many_foxes.rs b/examples/stress_tests/many_foxes.rs
index b9f97a125f932..7e09cf69bb181 100644
--- a/examples/stress_tests/many_foxes.rs
+++ b/examples/stress_tests/many_foxes.rs
@@ -231,18 +231,18 @@ fn setup(
 
 // Once the scene is loaded, start the animation
 fn setup_scene_once_loaded(
-    event: On<SceneInstanceReady>,
+    scene_ready: On<SceneInstanceReady>,
     animations: Res<Animations>,
     foxes: Res<Foxes>,
     mut commands: Commands,
     children: Query<&Children>,
     mut players: Query<&mut AnimationPlayer>,
 ) {
-    for child in children.iter_descendants(event.entity()) {
+    for child in children.iter_descendants(scene_ready.entity) {
         if let Ok(mut player) = players.get_mut(child) {
             let playing_animation = player.play(animations.node_indices[0]).repeat();
             if !foxes.sync {
-                playing_animation.seek_to(event.entity().index() as f32 / 10.0);
+                playing_animation.seek_to(scene_ready.entity.index() as f32 / 10.0);
             }
             commands
                 .entity(child)
diff --git a/examples/testbed/3d.rs b/examples/testbed/3d.rs
index 173fae84a6218..a996b2c329a12 100644
--- a/examples/testbed/3d.rs
+++ b/examples/testbed/3d.rs
@@ -283,13 +283,13 @@ mod animation {
     }
 
     fn pause_animation_frame(
-        event: On<SceneInstanceReady>,
+        scene_ready: On<SceneInstanceReady>,
         children: Query<&Children>,
         mut commands: Commands,
         animation: Res<Animation>,
         mut players: Query<(Entity, &mut AnimationPlayer)>,
     ) {
-        for child in children.iter_descendants(event.entity()) {
+        for child in children.iter_descendants(scene_ready.entity) {
             if let Ok((entity, mut player)) = players.get_mut(child) {
                 let mut transitions = AnimationTransitions::new();
                 transitions
@@ -404,13 +404,13 @@ mod gltf_coordinate_conversion {
     }
 
     pub fn show_aabbs(
-        event: On<SceneInstanceReady>,
+        scene_ready: On<SceneInstanceReady>,
         mut commands: Commands,
         children: Query<&Children>,
         meshes: Query<(), With<Mesh3d>>,
     ) {
         for child in children
-            .iter_descendants(event.entity())
+            .iter_descendants(scene_ready.entity)
             .filter(|&e| meshes.contains(e))
         {
             commands.entity(child).insert(ShowAabbGizmo {
diff --git a/examples/ui/core_widgets_observers.rs b/examples/ui/core_widgets_observers.rs
index 873cef636db54..3601ecc5bdb48 100644
--- a/examples/ui/core_widgets_observers.rs
+++ b/examples/ui/core_widgets_observers.rs
@@ -158,7 +158,7 @@ fn button(asset_server: &AssetServer, on_click: Callback<In<Activate>>) -> impl
 }
 
 fn button_on_add_pressed(
-    event: On<Add, Pressed>,
+    add: On<Add, Pressed>,
     mut buttons: Query<
         (
             &Hovered,
@@ -172,7 +172,7 @@ fn button_on_add_pressed(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((hovered, disabled, mut color, mut border_color, children)) =
-        buttons.get_mut(event.entity())
+        buttons.get_mut(add.entity)
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -187,7 +187,7 @@ fn button_on_add_pressed(
 }
 
 fn button_on_remove_pressed(
-    event: On<Remove, Pressed>,
+    remove: On<Remove, Pressed>,
     mut buttons: Query<
         (
             &Hovered,
@@ -201,7 +201,7 @@ fn button_on_remove_pressed(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((hovered, disabled, mut color, mut border_color, children)) =
-        buttons.get_mut(event.entity())
+        buttons.get_mut(remove.entity)
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -216,7 +216,7 @@ fn button_on_remove_pressed(
 }
 
 fn button_on_add_disabled(
-    event: On<Add, InteractionDisabled>,
+    add: On<Add, InteractionDisabled>,
     mut buttons: Query<
         (
             Has<Pressed>,
@@ -230,7 +230,7 @@ fn button_on_add_disabled(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((pressed, hovered, mut color, mut border_color, children)) =
-        buttons.get_mut(event.entity())
+        buttons.get_mut(add.entity)
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -245,7 +245,7 @@ fn button_on_add_disabled(
 }
 
 fn button_on_remove_disabled(
-    event: On<Remove, InteractionDisabled>,
+    remove: On<Remove, InteractionDisabled>,
     mut buttons: Query<
         (
             Has<Pressed>,
@@ -259,7 +259,7 @@ fn button_on_remove_disabled(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((pressed, hovered, mut color, mut border_color, children)) =
-        buttons.get_mut(event.entity())
+        buttons.get_mut(remove.entity)
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -274,7 +274,7 @@ fn button_on_remove_disabled(
 }
 
 fn button_on_change_hover(
-    event: On<Insert, Hovered>,
+    insert: On<Insert, Hovered>,
     mut buttons: Query<
         (
             Has<Pressed>,
@@ -289,7 +289,7 @@ fn button_on_change_hover(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((pressed, hovered, disabled, mut color, mut border_color, children)) =
-        buttons.get_mut(event.entity())
+        buttons.get_mut(insert.entity)
     {
         if children.is_empty() {
             return;
@@ -421,12 +421,12 @@ fn slider(
 }
 
 fn slider_on_add_disabled(
-    event: On<Add, InteractionDisabled>,
+    add: On<Add, InteractionDisabled>,
     sliders: Query<(Entity, &Hovered), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut BackgroundColor, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, hovered)) = sliders.get(event.entity()) {
+    if let Ok((slider_ent, hovered)) = sliders.get(add.entity) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_bg, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -438,12 +438,12 @@ fn slider_on_add_disabled(
 }
 
 fn slider_on_remove_disabled(
-    event: On<Remove, InteractionDisabled>,
+    remove: On<Remove, InteractionDisabled>,
     sliders: Query<(Entity, &Hovered), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut BackgroundColor, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, hovered)) = sliders.get(event.entity()) {
+    if let Ok((slider_ent, hovered)) = sliders.get(remove.entity) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_bg, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -455,12 +455,12 @@ fn slider_on_remove_disabled(
 }
 
 fn slider_on_change_hover(
-    event: On<Insert, Hovered>,
+    insert: On<Insert, Hovered>,
     sliders: Query<(Entity, &Hovered, Has<InteractionDisabled>), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut BackgroundColor, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, hovered, disabled)) = sliders.get(event.entity()) {
+    if let Ok((slider_ent, hovered, disabled)) = sliders.get(insert.entity) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_bg, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -472,12 +472,12 @@ fn slider_on_change_hover(
 }
 
 fn slider_on_change_value(
-    event: On<Insert, SliderValue>,
+    insert: On<Insert, SliderValue>,
     sliders: Query<(Entity, &SliderValue, &SliderRange), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut Node, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, value, range)) = sliders.get(event.entity()) {
+    if let Ok((slider_ent, value, range)) = sliders.get(insert.entity) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_node, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -489,12 +489,12 @@ fn slider_on_change_value(
 }
 
 fn slider_on_change_range(
-    event: On<Insert, SliderRange>,
+    insert: On<Insert, SliderRange>,
     sliders: Query<(Entity, &SliderValue, &SliderRange), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut Node, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, value, range)) = sliders.get(event.entity()) {
+    if let Ok((slider_ent, value, range)) = sliders.get(insert.entity) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_node, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -577,23 +577,23 @@ fn checkbox(
 }
 
 fn checkbox_on_add_disabled(
-    event: On<Add, InteractionDisabled>,
+    add: On<Add, InteractionDisabled>,
     checkboxes: Query<(&Hovered, Has<Checked>, &Children), With<DemoCheckbox>>,
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, checked, children)) = checkboxes.get(event.entity()) {
+    if let Ok((hovered, checked, children)) = checkboxes.get(add.entity) {
         set_checkbox_style(children, &mut borders, &mut marks, true, hovered.0, checked);
     }
 }
 
 fn checkbox_on_remove_disabled(
-    event: On<Remove, InteractionDisabled>,
+    remove: On<Remove, InteractionDisabled>,
     checkboxes: Query<(&Hovered, Has<Checked>, &Children), With<DemoCheckbox>>,
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, checked, children)) = checkboxes.get(event.entity()) {
+    if let Ok((hovered, checked, children)) = checkboxes.get(remove.entity) {
         set_checkbox_style(
             children,
             &mut borders,
@@ -606,7 +606,7 @@ fn checkbox_on_remove_disabled(
 }
 
 fn checkbox_on_change_hover(
-    event: On<Insert, Hovered>,
+    insert: On<Insert, Hovered>,
     checkboxes: Query<
         (&Hovered, Has<InteractionDisabled>, Has<Checked>, &Children),
         With<DemoCheckbox>,
@@ -614,7 +614,7 @@ fn checkbox_on_change_hover(
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(event.entity()) {
+    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(insert.entity) {
         set_checkbox_style(
             children,
             &mut borders,
@@ -627,7 +627,7 @@ fn checkbox_on_change_hover(
 }
 
 fn checkbox_on_add_checked(
-    event: On<Add, Checked>,
+    add: On<Add, Checked>,
     checkboxes: Query<
         (&Hovered, Has<InteractionDisabled>, Has<Checked>, &Children),
         With<DemoCheckbox>,
@@ -635,7 +635,7 @@ fn checkbox_on_add_checked(
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(event.entity()) {
+    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(add.entity) {
         set_checkbox_style(
             children,
             &mut borders,
@@ -648,12 +648,12 @@ fn checkbox_on_add_checked(
 }
 
 fn checkbox_on_remove_checked(
-    event: On<Remove, Checked>,
+    remove: On<Remove, Checked>,
     checkboxes: Query<(&Hovered, Has<InteractionDisabled>, &Children), With<DemoCheckbox>>,
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, disabled, children)) = checkboxes.get(event.entity()) {
+    if let Ok((hovered, disabled, children)) = checkboxes.get(remove.entity) {
         set_checkbox_style(
             children,
             &mut borders,
diff --git a/examples/ui/directional_navigation.rs b/examples/ui/directional_navigation.rs
index 030b3c4237dfa..862d9140fd9c8 100644
--- a/examples/ui/directional_navigation.rs
+++ b/examples/ui/directional_navigation.rs
@@ -67,10 +67,10 @@ const FOCUSED_BORDER: Srgba = bevy::color::palettes::tailwind::BLUE_50;
 // In a real project, each button would also have its own unique behavior,
 // to capture the actual intent of the user
 fn universal_button_click_behavior(
-    mut event: On<Pointer<Click>>,
+    mut click: On<Pointer<Click>>,
     mut button_query: Query<(&mut BackgroundColor, &mut ResetTimer)>,
 ) {
-    let button_entity = event.entity();
+    let button_entity = click.entity;
     if let Ok((mut color, mut reset_timer)) = button_query.get_mut(button_entity) {
         // This would be a great place to play a little sound effect too!
         color.0 = PRESSED_BUTTON.into();
@@ -78,7 +78,7 @@ fn universal_button_click_behavior(
 
         // Picking events propagate up the hierarchy,
         // so we need to stop the propagation here now that we've handled it
-        event.propagate(false);
+        click.propagate(false);
     }
 }
 
@@ -380,31 +380,29 @@ fn interact_with_focused_button(
         .contains(&DirectionalNavigationAction::Select)
         && let Some(focused_entity) = input_focus.0
     {
-        commands.trigger_targets(
-            Pointer::<Click> {
-                // We're pretending that we're a mouse
-                pointer_id: PointerId::Mouse,
+        commands.trigger(Pointer::<Click> {
+            entity: focused_entity,
+            // We're pretending that we're a mouse
+            pointer_id: PointerId::Mouse,
+            // This field isn't used, so we're just setting it to a placeholder value
+            pointer_location: Location {
+                target: NormalizedRenderTarget::Image(bevy::camera::ImageRenderTarget {
+                    handle: Handle::default(),
+                    scale_factor: FloatOrd(1.0),
+                }),
+                position: Vec2::ZERO,
+            },
+            event: Click {
+                button: PointerButton::Primary,
                 // This field isn't used, so we're just setting it to a placeholder value
-                pointer_location: Location {
-                    target: NormalizedRenderTarget::Image(bevy::camera::ImageRenderTarget {
-                        handle: Handle::default(),
-                        scale_factor: FloatOrd(1.0),
-                    }),
-                    position: Vec2::ZERO,
-                },
-                event: Click {
-                    button: PointerButton::Primary,
-                    // This field isn't used, so we're just setting it to a placeholder value
-                    hit: HitData {
-                        camera: Entity::PLACEHOLDER,
-                        depth: 0.0,
-                        position: None,
-                        normal: None,
-                    },
-                    duration: Duration::from_secs_f32(0.1),
+                hit: HitData {
+                    camera: Entity::PLACEHOLDER,
+                    depth: 0.0,
+                    position: None,
+                    normal: None,
                 },
+                duration: Duration::from_secs_f32(0.1),
             },
-            focused_entity,
-        );
+        });
     }
 }
diff --git a/examples/ui/drag_to_scroll.rs b/examples/ui/drag_to_scroll.rs
index a3311766a08ea..7de099e02602a 100644
--- a/examples/ui/drag_to_scroll.rs
+++ b/examples/ui/drag_to_scroll.rs
@@ -39,28 +39,24 @@ fn setup(mut commands: Commands) {
             ScrollStart(Vec2::ZERO),
         ))
         .observe(
-            |
-            drag: On<Pointer<Drag>>,
+            |drag: On<Pointer<Drag>>,
              ui_scale: Res<UiScale>,
-             mut scroll_position_query: Query<(
-                &mut ScrollPosition,
-                &ScrollStart),
+             mut scroll_position_query: Query<
+                (&mut ScrollPosition, &ScrollStart),
                 With<ScrollableNode>,
-             >| {
+            >| {
                 if let Ok((mut scroll_position, start)) = scroll_position_query.single_mut() {
                     scroll_position.0 = (start.0 - drag.distance / ui_scale.0).max(Vec2::ZERO);
                 }
             },
         )
         .observe(
-            |
-            on: On<Pointer<DragStart>>,
-             mut scroll_position_query: Query<(
-                &ComputedNode,
-                &mut ScrollStart),
+            |drag_start: On<Pointer<DragStart>>,
+             mut scroll_position_query: Query<
+                (&ComputedNode, &mut ScrollStart),
                 With<ScrollableNode>,
             >| {
-                if on.entity() != on.original_entity() {
+                if drag_start.entity != drag_start.original_event_target() {
                     return;
                 }
                 if let Ok((computed_node, mut start)) = scroll_position_query.single_mut() {
@@ -68,30 +64,29 @@ fn setup(mut commands: Commands) {
                 }
             },
         )
-
         .with_children(|commands| {
             commands
-            .spawn(Node {
-                display: Display::Grid,
-                grid_template_rows: RepeatedGridTrack::px(w as i32, 100.),
-                grid_template_columns: RepeatedGridTrack::px(h as i32, 100.),
-                ..Default::default()
-            })
-            .with_children(|commands| {
-                for y in 0..h {
-                    for x in 0..w {
-                        let tile_color = if (x + y) % 2 == 1 {
-                            let hue = ((x as f32 / w as f32) * 270.0) + ((y as f32 / h as f32) * 90.0);
-                            Color::hsl(hue, 1., 0.5)
-                        } else {
-                            Color::BLACK
-                        };
-                        commands
-                            .spawn((
+                .spawn(Node {
+                    display: Display::Grid,
+                    grid_template_rows: RepeatedGridTrack::px(w as i32, 100.),
+                    grid_template_columns: RepeatedGridTrack::px(h as i32, 100.),
+                    ..default()
+                })
+                .with_children(|commands| {
+                    for y in 0..h {
+                        for x in 0..w {
+                            let tile_color = if (x + y) % 2 == 1 {
+                                let hue = ((x as f32 / w as f32) * 270.0)
+                                    + ((y as f32 / h as f32) * 90.0);
+                                Color::hsl(hue, 1., 0.5)
+                            } else {
+                                Color::BLACK
+                            };
+                            commands.spawn((
                                 Node {
                                     grid_row: GridPlacement::start(y + 1),
                                     grid_column: GridPlacement::start(x + 1),
-                                    ..Default::default()
+                                    ..default()
                                 },
                                 Pickable {
                                     should_block_lower: false,
@@ -100,18 +95,18 @@ fn setup(mut commands: Commands) {
                                 TileColor(tile_color),
                                 BackgroundColor(tile_color),
                             ))
-                            .observe(|on_enter: On<Pointer<Over>>, mut query: Query<&mut BackgroundColor>, | {
-                                if let Ok(mut background_color) = query.get_mut(on_enter.entity()) {
+                            .observe(|over: On<Pointer<Over>>, mut query: Query<&mut BackgroundColor>,| {
+                                if let Ok(mut background_color) = query.get_mut(over.entity) {
                                     background_color.0 = RED.into();
                                 }
                             })
-                            .observe(|on_enter: On<Pointer<Out>>, mut query: Query<(&mut BackgroundColor, &TileColor)>,| {
-                                if let Ok((mut background_color, tile_color)) = query.get_mut(on_enter.entity()) {
+                            .observe(|out: On<Pointer<Out>>, mut query: Query<(&mut BackgroundColor, &TileColor)>| {
+                                if let Ok((mut background_color, tile_color)) = query.get_mut(out.entity) {
                                     background_color.0 = tile_color.0;
                                 }
                             });
                         }
-                }
-            });
+                    }
+                });
         });
 }
diff --git a/examples/ui/render_ui_to_texture.rs b/examples/ui/render_ui_to_texture.rs
index f4d8d665f26a8..dee40811b73d3 100644
--- a/examples/ui/render_ui_to_texture.rs
+++ b/examples/ui/render_ui_to_texture.rs
@@ -102,21 +102,21 @@ fn setup(
                     BackgroundColor(BLUE.into()),
                 ))
                 .observe(
-                    |pointer: On<Pointer<Drag>>, mut nodes: Query<(&mut Node, &ComputedNode)>| {
-                        let (mut node, computed) = nodes.get_mut(pointer.entity()).unwrap();
+                    |drag: On<Pointer<Drag>>, mut nodes: Query<(&mut Node, &ComputedNode)>| {
+                        let (mut node, computed) = nodes.get_mut(drag.entity).unwrap();
                         node.left =
-                            Val::Px(pointer.pointer_location.position.x - computed.size.x / 2.0);
-                        node.top = Val::Px(pointer.pointer_location.position.y - 50.0);
+                            Val::Px(drag.pointer_location.position.x - computed.size.x / 2.0);
+                        node.top = Val::Px(drag.pointer_location.position.y - 50.0);
                     },
                 )
                 .observe(
-                    |pointer: On<Pointer<Over>>, mut colors: Query<&mut BackgroundColor>| {
-                        colors.get_mut(pointer.entity()).unwrap().0 = RED.into();
+                    |over: On<Pointer<Over>>, mut colors: Query<&mut BackgroundColor>| {
+                        colors.get_mut(over.entity).unwrap().0 = RED.into();
                     },
                 )
                 .observe(
-                    |pointer: On<Pointer<Out>>, mut colors: Query<&mut BackgroundColor>| {
-                        colors.get_mut(pointer.entity()).unwrap().0 = BLUE.into();
+                    |out: On<Pointer<Out>>, mut colors: Query<&mut BackgroundColor>| {
+                        colors.get_mut(out.entity).unwrap().0 = BLUE.into();
                     },
                 )
                 .with_children(|parent| {
diff --git a/examples/ui/scroll.rs b/examples/ui/scroll.rs
index a1f822f9680a1..6c9a2cbf0cd4a 100644
--- a/examples/ui/scroll.rs
+++ b/examples/ui/scroll.rs
@@ -40,8 +40,8 @@ fn send_scroll_events(
         }
 
         for pointer_map in hover_map.values() {
-            for entity in pointer_map.keys() {
-                commands.trigger_targets(Scroll { delta }, *entity);
+            for entity in pointer_map.keys().copied() {
+                commands.trigger(Scroll { entity, delta });
             }
         }
     }
@@ -49,25 +49,24 @@ fn send_scroll_events(
 
 /// UI scrolling event.
 #[derive(EntityEvent, Debug)]
-#[entity_event(auto_propagate, traversal = &'static ChildOf)]
+#[entity_event(propagate, auto_propagate)]
 struct Scroll {
+    entity: Entity,
     /// Scroll delta in logical coordinates.
     delta: Vec2,
 }
 
 fn on_scroll_handler(
-    mut event: On<Scroll>,
+    mut scroll: On<Scroll>,
     mut query: Query<(&mut ScrollPosition, &Node, &ComputedNode)>,
 ) {
-    let target = event.entity();
-    let delta = &mut event.delta;
-
-    let Ok((mut scroll_position, node, computed)) = query.get_mut(target) else {
+    let Ok((mut scroll_position, node, computed)) = query.get_mut(scroll.entity) else {
         return;
     };
 
     let max_offset = (computed.content_size() - computed.size()) * computed.inverse_scale_factor();
 
+    let delta = &mut scroll.delta;
     if node.overflow.x == OverflowAxis::Scroll && delta.x != 0. {
         // Is this node already scrolled all the way in the direction of the scroll?
         let max = if delta.x > 0. {
@@ -100,7 +99,7 @@ fn on_scroll_handler(
 
     // Stop propagating when the delta is fully consumed.
     if *delta == Vec2::ZERO {
-        event.propagate(false);
+        scroll.propagate(false);
     }
 }
 
@@ -172,9 +171,9 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                                         },
                                     ))
                                     .observe(
-                                        |event: On<Pointer<Press>>, mut commands: Commands| {
-                                            if event.event().button == PointerButton::Primary {
-                                                commands.entity(event.entity()).despawn();
+                                        |press: On<Pointer<Press>>, mut commands: Commands| {
+                                            if press.event().button == PointerButton::Primary {
+                                                commands.entity(press.entity).despawn();
                                             }
                                         },
                                     );
diff --git a/examples/ui/tab_navigation.rs b/examples/ui/tab_navigation.rs
index 57a9397f55199..cbc9a6babc7da 100644
--- a/examples/ui/tab_navigation.rs
+++ b/examples/ui/tab_navigation.rs
@@ -137,10 +137,10 @@ fn setup(mut commands: Commands) {
                                     )],
                                 ))
                                 .observe(
-                                    |mut event: On<Pointer<Click>>,
+                                    |mut click: On<Pointer<Click>>,
                                     mut focus: ResMut<InputFocus>| {
-                                        focus.0 = Some(event.entity());
-                                        event.propagate(false);
+                                        focus.0 = Some(click.entity);
+                                        click.propagate(false);
                                     },
                                 );
                         }
diff --git a/examples/ui/ui_drag_and_drop.rs b/examples/ui/ui_drag_and_drop.rs
index fe39b5cd3079d..fef7d0d8fd729 100644
--- a/examples/ui/ui_drag_and_drop.rs
+++ b/examples/ui/ui_drag_and_drop.rs
@@ -58,37 +58,37 @@ fn setup(mut commands: Commands) {
                             GlobalZIndex::default()
                         ))
                         .observe(move |on_over: On<Pointer<Over>>, mut query: Query<(&mut BackgroundColor, &mut BorderColor)>| {
-                            if let Ok((mut background_color, mut border_color)) = query.get_mut(on_over.entity()) {
+                            if let Ok((mut background_color, mut border_color)) = query.get_mut(on_over.event_target()) {
                                 background_color.0 = tile_color.lighter(0.1);
                                 border_color.set_all(tile_border_color.lighter(0.1));
                             }
                         })
                         .observe(move |on_out: On<Pointer<Out>>, mut query: Query<(&mut BackgroundColor, &mut BorderColor)>| {
-                            if let Ok((mut background_color, mut border_color)) = query.get_mut(on_out.entity()) {
+                            if let Ok((mut background_color, mut border_color)) = query.get_mut(on_out.event_target()) {
                                 background_color.0 = tile_color;
                                 border_color.set_all(tile_border_color);
                             }
                         })
                         .observe(|on_drag_start: On<Pointer<DragStart>>, mut query: Query<(&mut Outline, &mut GlobalZIndex)>| {
-                            if let Ok((mut outline, mut global_zindex, )) = query.get_mut(on_drag_start.entity()) {
+                            if let Ok((mut outline, mut global_zindex, )) = query.get_mut(on_drag_start.event_target()) {
                                 outline.color = Color::WHITE;
                                 global_zindex.0 = 1;
                             }
                         })
                         .observe(|on_drag: On<Pointer<Drag>>, mut query: Query<&mut UiTransform>| {
-                            if let Ok(mut transform) = query.get_mut(on_drag.entity()) {
+                            if let Ok(mut transform) = query.get_mut(on_drag.event_target()) {
                                 transform.translation = Val2::px(on_drag.distance.x, on_drag.distance.y);
                             }
                         })
                         .observe(move |on_drag_end: On<Pointer<DragEnd>>, mut query: Query<(&mut UiTransform, &mut Outline, &mut GlobalZIndex)>| {
-                            if let Ok((mut transform, mut outline, mut global_zindex)) = query.get_mut(on_drag_end.entity()) {
+                            if let Ok((mut transform, mut outline, mut global_zindex)) = query.get_mut(on_drag_end.event_target()) {
                                 transform.translation = Val2::ZERO;
                                 outline.color = Color::NONE;
                                 global_zindex.0 = 0;
                             }
                         })
                         .observe(|on_drag_drop: On<Pointer<DragDrop>>, mut query: Query<&mut Node>| {
-                            if let Ok([mut a, mut b]) = query.get_many_mut([on_drag_drop.entity(), on_drag_drop.dropped]) {
+                            if let Ok([mut a, mut b]) = query.get_many_mut([on_drag_drop.event_target(), on_drag_drop.dropped]) {
                                 core::mem::swap(&mut a.grid_row, &mut b.grid_row);
                                 core::mem::swap(&mut a.grid_column, &mut b.grid_column);
                             }
diff --git a/examples/ui/viewport_node.rs b/examples/ui/viewport_node.rs
index 2f16e553aab8a..b1623552d1e92 100644
--- a/examples/ui/viewport_node.rs
+++ b/examples/ui/viewport_node.rs
@@ -89,7 +89,7 @@ fn test(
 
 fn on_drag_viewport(drag: On<Pointer<Drag>>, mut node_query: Query<&mut Node>) {
     if matches!(drag.button, PointerButton::Secondary) {
-        let mut node = node_query.get_mut(drag.entity()).unwrap();
+        let mut node = node_query.get_mut(drag.entity).unwrap();
 
         if let (Val::Px(top), Val::Px(left)) = (node.top, node.left) {
             node.left = px(left + drag.delta.x);
@@ -100,7 +100,7 @@ fn on_drag_viewport(drag: On<Pointer<Drag>>, mut node_query: Query<&mut Node>) {
 
 fn on_drag_cuboid(drag: On<Pointer<Drag>>, mut transform_query: Query<&mut Transform>) {
     if matches!(drag.button, PointerButton::Primary) {
-        let mut transform = transform_query.get_mut(drag.entity()).unwrap();
+        let mut transform = transform_query.get_mut(drag.entity).unwrap();
         transform.rotate_y(drag.delta.x * 0.02);
         transform.rotate_x(drag.delta.y * 0.02);
     }
diff --git a/examples/usage/context_menu.rs b/examples/usage/context_menu.rs
index ec3c400063623..b593a2e0753ee 100644
--- a/examples/usage/context_menu.rs
+++ b/examples/usage/context_menu.rs
@@ -43,7 +43,7 @@ fn text_color_on_hover<T: Debug + Clone + Reflect>(
     move |mut event: On<Pointer<T>>,
           mut text_color: Query<&mut TextColor>,
           children: Query<&Children>| {
-        let Ok(children) = children.get(event.original_entity()) else {
+        let Ok(children) = children.get(event.original_event_target()) else {
             return;
         };
         event.propagate(false);
@@ -112,7 +112,7 @@ fn on_trigger_menu(event: On<OpenContextMenu>, mut commands: Commands) {
              menu_items: Query<&ContextMenuItem>,
              mut clear_col: ResMut<ClearColor>,
              mut commands: Commands| {
-                let target = event.original_entity();
+                let target = event.original_event_target();
 
                 if let Ok(item) = menu_items.get(target) {
                     clear_col.0 = item.0.into();
diff --git a/release-content/migration-guides/event_split.md b/release-content/migration-guides/event_split.md
index d30119f75a7db..14ec70cd4130d 100644
--- a/release-content/migration-guides/event_split.md
+++ b/release-content/migration-guides/event_split.md
@@ -1,14 +1,6 @@
 ---
-title: "`Event` trait split"
+title: "`Event` trait split / Rename"
 pull_requests: [19647]
 ---
 
-The `Event` trait was previously used for all types of events: "observer events" with and without targets,
-and "buffered events" using `EventReader` and `EventWriter`.
-
-Buffered events and targeted events have now been split into dedicated `BufferedEvent` and `EntityEvent` traits.
-An event with just the `Event` trait implemented only supports non-targeted APIs such as global observers and the `trigger` method.
-
-If an event is used with `trigger_targets` or an entity observer, make sure you have derived `EntityEvent` for it.
-
-If an event is used with `EventReader` or `EventWriter`, make sure you have derived `BufferedEvent` for it.
+"Buffered events" (things sent/read using `EventWriter` / `EventReader`) are now no longer referred to as "events", in the interest of conceptual clarity and learn-ability (see the release notes for rationale). "Event" as a concept (and the `Event` trait) are now used solely for "observable events". "Buffered events" are now known as "messages" and use the `Message` trait. `EventWriter`, `EventReader`, and `Events<E>`, are now known as `MessageWriter`, `MessageReader`, and `Messages<M>`. Types can be _both_ "messages" and "events" by deriving both `Message` and `Event`, but we expect most types to only be used in one context or the other.
diff --git a/release-content/migration-guides/merge_observerState_observer_single_component.md b/release-content/migration-guides/merge_observerState_observer_single_component.md
index c0365001bab02..165597a204f5f 100644
--- a/release-content/migration-guides/merge_observerState_observer_single_component.md
+++ b/release-content/migration-guides/merge_observerState_observer_single_component.md
@@ -8,7 +8,7 @@ now you can use `Observer::with_dynamic_runner` to build custom Observe.
 
 ```rust
 let observe = unsafe {
-    Observer::with_dynamic_runner(|mut world, trigger, ptr, propagate| {
+    Observer::with_dynamic_runner(|world, trigger_context, event_ptr, trigger_ptr| {
         // do something
     })
     .with_event(event_a)
diff --git a/release-content/migration-guides/observer_and_event_changes.md b/release-content/migration-guides/observer_and_event_changes.md
new file mode 100644
index 0000000000000..9c4d363ff0424
--- /dev/null
+++ b/release-content/migration-guides/observer_and_event_changes.md
@@ -0,0 +1,142 @@
+---
+title: Observer / Event API Changes
+pull_requests: [20731, 19440, 19596]
+---
+
+The observer "trigger" API has changed a bit to improve clarity and type-safety.
+
+```rust
+// Old
+commands.add_observer(|trigger: Trigger<OnAdd, Player>| {
+    info!("Spawned player {}", trigger.target());
+});
+
+// New
+commands.add_observer(|add: On<Add, Player>| {
+    info!("Spawned player {}", add.entity);
+});
+```
+
+The `Trigger` type used inside observers has been renamed to `On` to encourage developers to think about this parameter _as_ the event. We also recommend naming the variable after the event type (ex: `add`).
+
+To reduce repetition and improve readability, the `OnAdd`, `OnInsert`, `OnReplace`, `OnRemove`, and `OnDespawn`
+observer events have also been renamed to `Add`, `Insert`, `Replace`, `Remove`, and `Despawn` respectively.
+In rare cases where the `Add` event conflicts with the `std::ops::Add` trait, you may need to disambiguate,
+for example by using `ops::Add` for the trait. We encourage removing the "On" from custom events named `OnX`.
+
+Types implementing `Event` can no longer be triggered from _all contexts. By default `Event` is a "global" / "target-less" event.
+
+Events that target an entity should now derive `EntityEvent`, and they will now store the target entity _on_ the event type, which is accessible via `EntityEvent::event_target`. Additionally, `world.trigger_targets` has been removed in favor of a single `world.trigger` API:
+
+```rust
+// Old
+#[derive(Event)]
+struct Explode;
+
+world.trigger_targets(Explode, entity);
+
+// New
+#[derive(EntityEvent)]
+struct Explode {
+    entity: Entity
+}
+
+world.trigger(Explode { entity });
+```
+
+Triggering an entity event for multiple entities now requires multiple calls to `trigger`:
+
+```rust
+// Old
+world.trigger_targets(Explode, [e1, e2]);
+
+// New - Variant 1
+world.trigger(Explode { entity: e1 });
+world.trigger(Explode { entity: e2 });
+
+// New - Variant 2
+for entity in [e1, e2] {
+    world.trigger(Explode { entity });
+}
+```
+
+`On::target()` no longer exists for all event types. Instead, you should prefer accessing the "target entity" field on the events that target entities:
+
+```rust
+// Old
+commands.add_observer(|trigger: Trigger<Explode>| {
+    info!("{} exploded!", trigger.target());
+});
+
+// New
+commands.add_observer(|explode: On<Explode>| {
+    info!("{} exploded!", explode.entity);
+    // you can also use `EntityEvent::event_target`, but we encourage
+    // using direct field access when possible, for better documentation and clarity.
+    info!("{} exploded!", explode.event_target());
+});
+```
+
+"Propagation functions", such as `On::propagate` are now _only_ available on `On<E>` when `E: EntityEvent<Trigger = PropagateEntityTrigger>`.
+
+Enabling propagation is now down using, which defaults to `ChildOf` propagation:
+
+```rust
+#[derive(EntityEvent)]
+#[entity_event(propagate)]
+struct Click {
+    entity: Entity,
+}
+```
+
+Setting a custom propagation `Traversal` implementation now uses `propagate` instead of `traversal`:
+
+```rust
+// OLd
+#[derive(Event)]
+#[event(traversal = &'static ChildOf)]
+struct Click;
+
+// New
+#[derive(EntityEvent)]
+#[entity_event(propagate = &'static ChildOf)]
+struct Click {
+    entity: Entity,
+}
+```
+
+Animation events (used in `AnimationPlayer`) must now derive `AnimationEvent`. Accessing the animation player entity is now done via the `trigger()`.
+
+```rust
+// Old
+#[derive(Event)]
+struct SayMessage(String);
+
+animation.add_event(0.2, SayMessage("hello".to_string()));
+world.entity_mut(animation_player).observe(|trigger: Trigger<SayMessage>| {
+    println!("played on", trigger.target());
+})
+
+// New
+#[derive(AnimationEvent)]
+struct SayMessage(String);
+
+animation.add_event(0.2, SayMessage("hello".to_string()));
+world.entity_mut(animation_player).observe(|say_message: On<SayMessage>| {
+    println!("played on", say_message.trigger().animation_player);
+})
+```
+
+For "component lifecycle events", accessing _all_ of the components that triggered the event has changed:
+
+```rust
+// Old
+commands.add_observer(|trigger: Trigger<OnAdd, Player>| {
+    info!("{}", trigger.components());
+});
+
+// New
+commands.add_observer(|add: On<Add, Player>| {
+    info!("{}", add.trigger().components);
+});
+```
diff --git a/release-content/migration-guides/observer_triggers.md b/release-content/migration-guides/observer_triggers.md
deleted file mode 100644
index 6a2f7d298c594..0000000000000
--- a/release-content/migration-guides/observer_triggers.md
+++ /dev/null
@@ -1,32 +0,0 @@
----
-title: Observer Triggers
-pull_requests: [19440, 19596]
----
-
-The `Trigger` type used inside observers has been renamed to `On` for a cleaner API.
-
-```rust
-// Old
-commands.add_observer(|trigger: Trigger<OnAdd, Player>| {
-    info!("Spawned player {}", trigger.entity());
-});
-
-// New
-commands.add_observer(|event: On<Add, Player>| {
-    info!("Spawned player {}", event.entity());
-});
-```
-
-To reduce repetition and improve readability, the `OnAdd`, `OnInsert`, `OnReplace`, `OnRemove`, and `OnDespawn`
-observer events have also been renamed to `Add`, `Insert`, `Replace`, `Remove`, and `Despawn` respectively.
-In rare cases where the `Add` event conflicts with the `std::ops::Add` trait, you may need to disambiguate,
-for example by using `ops::Add` for the trait.
-
-Observers may be triggered on particular entities or globally.
-Previously, a global trigger would claim to trigger on a particular `Entity`, `Entity::PLACEHOLDER`.
-For correctness and transparency, triggers have been changed to `Option<Entity>`.
-
-`On::entity` (previously `Trigger::target`) now returns `Option<Entity>`, and `ObserverTrigger::target`
-is now of type `Option<Entity>`. If you were checking for `Entity::PLACEHOLDER`, migrate to handling the `None` case.
-If you were not checking for `Entity::PLACEHOLDER`, migrate to unwrapping, as `Entity::PLACEHOLDER`
-would have caused a panic before, at a later point.
diff --git a/release-content/release-notes/event_split.md b/release-content/release-notes/event_split.md
deleted file mode 100644
index a1b90f4edc514..0000000000000
--- a/release-content/release-notes/event_split.md
+++ /dev/null
@@ -1,121 +0,0 @@
----
-title: Event Split
-authors: ["@Jondolf"]
-pull_requests: [19647, 20101]
----
-
-In past releases, all event types were defined by simply deriving the `Event` trait:
-
-```rust
-#[derive(Event)]
-struct Speak {
-    message: String,
-}
-```
-
-You could then use the various event handling tools in Bevy to send and listen to the event. The common options include:
-
-- Use `trigger` to trigger the event and react to it with a global `Observer`
-- Use `trigger_targets` to trigger the event with specific entity target(s) and react to it with an entity `Observer` or global `Observer`
-- Use `EventWriter::write` to write the event to an event buffer and `EventReader::read` to read it at a later time
-
-The first two are observer APIs, while the third is a fully separate "buffered" API for pull-based event handling.
-All three patterns are fundamentally different in both the interface and usage. Despite the same event type being used everywhere,
-APIs are typically built to support only one of them.
-
-This has led to a lot of confusion and frustration for users. A common footgun was using a "buffered event" with an observer,
-or an observer event with `EventReader`, leaving the user wondering why the event is not being detected.
-
-**Bevy 0.17** aims to solve this ambiguity by splitting the event traits into `Event`, `EntityEvent`, and `BufferedEvent`.
-
-- `Event`: A shared trait for observer events.
-- `EntityEvent`: An `Event` that additionally supports targeting specific entities and propagating the event from one entity to another.
-- `BufferedEvent`: An event that supports usage with `EventReader` and `EventWriter` for pull-based event handling.
-
-## Using Events
-
-A basic `Event` can be defined like before, by deriving the `Event` trait.
-
-```rust
-#[derive(Event)]
-struct Speak {
-    message: String,
-}
-```
-
-You can then `trigger` the event, and use a global observer for reacting to it.
-
-```rust
-app.add_observer(|event: On<Speak>| {
-    println!("{}", event.message);
-});
-
-// ...
-
-commands.trigger(Speak {
-    message: "Hello!".to_string(),
-});
-```
-
-To allow an event to be targeted at entities and even propagated further, you can instead derive `EntityEvent`.
-It supports optionally specifying some options for propagation using the `event` attribute:
-
-```rust
-// When the `Damage` event is triggered on an entity, bubble the event up to ancestors.
-#[derive(EntityEvent)]
-#[entity_event(traversal = &'static ChildOf, auto_propagate)]
-struct Damage {
-    amount: f32,
-}
-```
-
-Every `EntityEvent` is also an `Event`, so you can still use `trigger` to trigger them globally.
-However, entity events also support targeted observer APIs such as `trigger_targets` and `observe`:
-
-```rust
-// Spawn an enemy entity.
-let enemy = commands.spawn((Enemy, Health(100.0))).id();
-
-// Spawn some armor as a child of the enemy entity.
-// When the armor takes damage, it will bubble the event up to the enemy,
-// which can then handle the event with its own observer.
-let armor_piece = commands
-    .spawn((ArmorPiece, Health(25.0), ChildOf(enemy)))
-    .observe(|event: On<Damage>, mut query: Query<&mut Health>| {
-        // Note: `On::entity` only exists because this is an `EntityEvent`.
-        let mut health = query.get(event.entity()).unwrap();
-        health.0 -= event.amount();
-    })
-    .id();
-
-// Trigger the `Damage` event on the armor piece.
-commands.trigger_targets(Damage { amount: 10.0 }, armor_piece);
-```
-
-To allow an event to be used with the buffered API, you can instead derive `BufferedEvent`:
-
-```rust
-#[derive(BufferedEvent)]
-struct Message(String);
-```
-
-The event can then be used with `EventReader`/`EventWriter`:
-
-```rust
-fn write_hello(mut writer: EventWriter<Message>) {
-    writer.write(Message("I hope these examples are alright".to_string()));
-}
-
-fn read_messages(mut reader: EventReader<Message>) {
-  // Process all buffered events of type `Message`.
-   for Message(message) in reader.read() {
-    println!("{message}");
-   }
-}
-```
-
-In summary:
-
-- Need a basic event you can trigger and observe? Derive `Event`!
-- Need the observer event to be targeted at an entity? Derive `EntityEvent`!
-- Need the event to be buffered and support the `EventReader`/`EventWriter` API? Derive `BufferedEvent`!
diff --git a/release-content/release-notes/observer_overhaul.md b/release-content/release-notes/observer_overhaul.md
index a2d716bc856fe..143585f798e0e 100644
--- a/release-content/release-notes/observer_overhaul.md
+++ b/release-content/release-notes/observer_overhaul.md
@@ -1,14 +1,158 @@
 ---
-title: Observer Overhaul
-authors: ["@Jondolf", "@alice-i-cecile", "@hukasu", "oscar-benderstone", "Zeophlite", "gwafotapa"]
-pull_requests: [19596, 19663, 19611, 19935, 20274]
+title: Event / Observer Overhaul
+authors: ["@cart, @Jondolf", "@alice-i-cecile", "@hukasu", "oscar-benderstone", "Zeophlite", "gwafotapa"]
+pull_requests: [20731, 19596, 19663, 19611, 19935, 20274]
 ---
 
-TODO: merge with Event split release notes
+Bevy's Observer API landed a few releases ago, and it has quickly become one of our most popular features. In **Bevy 0.17** we rearchitected and refined the Event and Observer APIs to be clearer, easier to use, and more performant. We plan on rolling out Bevy's next generation Scene / UI system in the near future, and observers are a key piece! We wanted to ensure they were in a better place for the next phase of Bevy development. The old API had some problems:
 
-## Rename `Trigger` to `On`
+1. **Concept names were confusing and ambiguous**: Events could be "observed", "buffered" in `Events` collections, or both. Knowing how to produce or consume a given [`Event`] required too much implied context: "do I write an Observer or use an EventReader system?", "do I trigger the event with or without targets?", what should the targets be?", etc. We need better, less ambiguous ways to refer to events.
+2. **The API was not "static" enough**: This relates to (1). Because a given [`Event`] type could be used by and produced for _any context_, we had to provide access to _every possible API_ for _every event type_. It should not be possible to trigger an "entity event" without an entity! An Observer of an event that was not designed to have a target entity should not have an `entity()` field! Every [`Event`] impl had to define an "entity propagation traversal", even it was not designed to propagate (and even if it didn't target entities at all!). Events should be self documenting, impossible to produce or consume in the wrong context, and should only encode the information that is necessary for that event.
+3. **The API did too much work**: Because events could be produced and used in any context, this meant that they all branched through code for every possible context. This incurred unnecessary overhead. It also resulted in lots of unnecessary codegen!
 
-In past releases, the observer API looked like this:
+In **Bevy 0.17** we have sorted out these issues without fundamentally changing the shape of the API. Migrations should generally be very straightforward.
+
+## The Rearchitecture
+
+The `Event` trait has been reframed / refocused to increase flexibility, make the API more static, and remove specialized cruft:
+
+```rust
+// Old: Bevy 0.16
+trait Event {
+    // this embedded configuration specific to "propagating entity events" in all events!
+    type Traversal: Traversal<Self>;
+    const AUTO_PROPAGATE: bool = false;
+    fn register_component_id(world: &mut World);
+    fn component_id(world: &World) -> Option<ComponentId>;
+}
+
+// New: Bevy 0.17
+trait Event {
+    type Trigger<'a>: Trigger<Self>;
+}
+```
+
+Every [`Event`] now has an associated [`Trigger`] implementation. The [`Trigger`] trait defines the behavior of `world.trigger()` for that event. [`Trigger`] defines which observers will run, the order they will run in, and the data that is passed to them.
+
+By representing this in the type system, we can constrain behaviors and data to _specific_ types of events statically, making it impossible to "misuse" an [`Event`].
+All of Bevy's existing "flavors" of events have been ported to the new [`Event`] / [`Trigger`] system.
+
+## `Event`: global by default
+
+At a glance, the default [`Event`] derive and usage hasn't changed much. Just some shorter / clearer naming. The old API looked like this:
+
+```rust
+#[derive(Event)]
+struct GameOver {
+    score: u32,
+}
+
+world.add_observer(|trigger: Trigger<GameOver>| {
+    info!("Game over! You scored {} points", trigger.score);
+});
+
+world.trigger(GameOver { score: 100 });
+```
+
+In **Bevy 0.17**, defining observers has only changed slightly:
+
+```rust
+
+world.add_observer(|game_over: On<GameOver>| {
+    info!("Game over! You scored {} points", game_over.score);
+});
+
+```
+
+`Trigger` is now `On`. `On` encourages developers to think of this parameter _as the event itself_. This is also reflected in the new naming convention, where we name the variable after the `Event` (ex: `game_over`) rather than the `Trigger` (ex: `trigger`).
+
+Internally things are a bit different though! The [`Event`] derive defaults to being "untargeted" / "global", by setting the `Event::Trigger` to [`GlobalTrigger`]. When it is triggered, only "untargeted" top-level observers will run, and there is _no way_ to trigger it in a different context (ex: events with a [`GlobalTrigger`] cannot target entities!).
+
+## `EntityEvent`: a dedicated trait for entity-targeting events
+
+In previous versions of Bevy, _any_ event could optionally be triggered for an entity. It looked like this:
+
+```rust
+#[derive(Event)]
+struct Click;
+
+world.trigger_targets(Click, entity);
+```
+
+In **Bevy 0.17**, if you want an [`Event`] to target an [`Entity`] (and thus trigger any observers watching for that specific entity), you derive [`EntityEvent`]:
+
+```rust
+#[derive(EntityEvent)]
+struct Click {
+    entity: Entity,
+}
+
+world.trigger(Click { entity });
+```
+
+Notice that `Click` now has the target entity as a field _on_ the [`Event`], and it now uses the same `world.trigger()` API that other events use. `world.trigger_targets` is no more ... every event is triggered using the same API!
+
+```rust
+// This observer will run for _all_ Click events targeting any entity
+world.add_observer(|mut click: On<Click>| {});
+
+/// This observer will only run for Click events triggered for `some_entity`
+world.entity_mut(some_entity).observe(|mut click: On<Click>| {});
+```
+
+[`EntityEvent`] is a new trait:
+
+```rust
+trait EntityEvent: Event {
+    fn event_target(&self) -> Entity;
+    fn event_target_mut(&mut self) -> &mut Entity;
+}
+```
+
+When it is derived, it defaults to setting the [`Event`] trigger to [`EntityTrigger`]. This will trigger all "untargeted" observers (`world.add_observer()`), just like [`GlobalTrigger`], but it will _also_ trigger any observers that target a specific entity (`world.entity_mut(some_entity).observe()`).
+
+Deriving [`EntityEvent`] will set the `entity_target` to a field named `entity` by default. In some cases (such as events that have multiple entity fields), it might make sense to use a more descriptive name. You can set the target using the `#[event_target]` field attribute:
+
+```rust
+#[derive(EntityEvent)]
+struct Attack {
+    // This will trigger `attacker` observers 
+    #[event_target]
+    attacker: Entity,
+    attacked: Entity,
+}
+```
+
+## EntityEvent Propagation
+
+An [`EntityEvent`] does not "propagate" by default (and they now statically have no access to APIs that control propagation). Propagation can be enabled using the `propagate` attribute (which defaults to using the [`ChildOf`] relationship to "bubble events up the hierarchy"):
+
+```rust
+#[derive(EntityEvent)]
+#[entity_event(propagate)]
+struct Click {
+    entity: Entity
+}
+```
+
+This will set the [`Event`]'s [`Trigger`] to [`PropagatingEntityTrigger`].
+
+This enables access to "propagation" functionality like this:
+
+```rust
+world.add_observer(|mut click: On<Click>| {
+    if SOME_CONDITION {
+        // stop the event from "bubbling up"
+        click.propagate(false);
+    }
+});
+```
+
+Bevy's `Pointer` events have always tracked the "original target" that an "entity event" was targeting. This was handy! We've enabled this functionality for every [`EntityEvent`] with [`PropagatingEntityTrigger`]: simply call `On::original_event_target`.
+
+## Component Lifecycle Events
+
+In past releases, the observer API for lifecycle events looked like this:
 
 ```rust
 app.add_observer(|trigger: Trigger<OnAdd, Player>| {
@@ -16,43 +160,85 @@ app.add_observer(|trigger: Trigger<OnAdd, Player>| {
 });
 ```
 
-In this example, the `Trigger` type contains information about the `OnAdd` event that was triggered
-for a `Player`.
+We've ported these over to the new system, and renamed them to match our new naming scheme (ex: `OnAdd` is now [`Add`]). They look like this now:
+
+```rust
+app.add_observer(|add: On<Add, Player>| {
+    info!("Added player {}", add.entity);
+});
+```
+
+Component lifecycle events are an [`EntityEvent`] (and thus store the target entity as a field). They use the [`EntityComponentsTrigger`], which allows them to be triggered for specific components on an entity.
+
+## AnimationEvent
 
-**Bevy 0.17** renames the `Trigger` type to `On`, and removes the `On` prefix from lifecycle events
-such as `OnAdd` and `OnRemove`:
+"Animation events" are custom events that are registered with an [`AnimationPlayer`] and triggered at a specific point in the animation. [`AnimationEvent`] is a new event sub-trait / derive (much like [`EntityEvent`]). Animation events use the [`AnimationEventTrigger`]. They behave like an [`EntityEvent`] (they observers on the [`AnimationPlayer`]), but they notably _do not store the entity on the event type_. This allows for directly registering them in [`AnimationPlayer`] without needing to set an entity target:
 
 ```rust
-app.add_observer(|event: On<Add, Player>| {
-    info!("Added player {}", event.entity());
+animation.add_event(
+    0.0,
+    PrintMessage("Hello".to_string()),
+);
+
+world.entity_mut(animation_player).observe(|print_message: On<PrintMessage>| {
+    // The `AnimationEventTrigger` still provides access to the animation_player entity
+    println!("{} says {}", print_message.trigger().animation_player, print_message.0);
 });
 ```
 
-This significantly improves readability and ergonomics, and is especially valuable in UI contexts
-where observers are very high-traffic APIs.
+## Custom Event Triggers
 
-One concern that may come to mind is that `Add` can sometimes conflict with the `core::ops::Add` trait.
-However, in practice these scenarios should be rare, and when you do get conflicts, it should be straightforward
-to disambiguate by using `ops::Add`, for example.
+The new [`Trigger`] trait also enables developers to implement their _own_ specialized [`Event`] [`Trigger`] logic.
 
-## Original targets
+The [`Event`] derive can specify a custom [`Trigger`] like this:
+
+```rust
+#[derive(Event)]
+#[event(trigger = CoolTrigger)
+struct Jump;
+```
+
+Alternatively, developers can create specialized event derives / traits, following the same pattern as `EntityEvent`:
+
+```rust
+trait CoolEvent: Event { }
+
+#[derive(CoolEvent)]
+struct Jump;
+
+// the derive above would generate this code:
+impl CoolEvent for Jump {}
+impl Event for Jump {
+    type Trigger<'s> = CoolTrigger; 
+}
+```
 
-`bevy_picking`'s `Pointer` events have always tracked the original target that an entity-event was targeting,
-allowing you to bubble events up your hierarchy to see if any of the parents care,
-then act on the entity that was actually picked in the first place.
+## Concept Clarity: Events vs Messages
 
-This was handy! We've enabled this functionality for all entity-events: simply call `On::original_entity`.
+In previous versions of Bevy, the [`Event`] trait was used for both "observable events" (handled with `Observer`) and "buffered events" (handled with `EventReader`). This made _some_ sense, as both concepts could be considered "events" in their own right. But they are also fundamentally _very_ different things functionally:
 
-## Expose name of the Observer's system
+1. "Observable events" are consumed one-by-one in Observers, which exist outside of a schedule. "Buffered events" are consumed by iterating over many of them in normal systems, which exist in one or more places inside a schedule.
+2. "Observable event" handlers are run _for_ developers. "Buffered event" consumers are responsible for dispatching handler logic themselves.
+3. "Observable events" are handled immediately. "Buffered events" are handled at some later moment in time (or not at all).
+4. "Observable events" need additional configuration to make them work (ex: `Event::Trigger`). "Buffered events" do not.
+5. "Observable events" incur a small amount of per-handler overhead. Handling "buffered events" is as fast as iterating an array.
 
-The name of the Observer's system is now accessible through `Observer::system_name`,
-this opens up the possibility for the debug tools to show more meaningful names for observers.
+Most importantly: there was _no way_ for consumers or producers of these events to know _how_ to handle them, just by looking at the type info. Consider some `ProcessingFinished` event from some 3rd party library. Events could either be "buffered" or "observed" (depending on what the sender of the event chooses), so the consumer has _no way_ to know how to consume `ProcessingFinished`. Is their observer not firing because the event isn't happening, or because the creator of the event was sending it as a buffered event instead of "triggering" it?
 
-## Use `EventKey` instead of `ComponentId`
+These are two completely separate systems, with different producer / consumer APIs, different performance considerations, and immediate vs deferred handling. The "things" being sent deserve different concept names to solidify conceptually (and at the type/API level) their intended purpose and context.
 
-Internally, each `Event` type would generate a `Component` type, allowing us to use the corresponding `ComponentId` to track the event.
-We have newtyped this to `EventKey` to help separate these concerns.
+In **Bevy 0.17**, [`Event`] is now _exclusively_ the name/trait for the concept of something that is "triggered" and "observed". [`Message`] is the name / trait of something that "buffered": it is "written" via a [`MessageWriter`] and "read" via a [`MessageReader`].
 
-## Watch multiple entities
+It is still possible to support both contexts by implementing _both traits_, but we expect that to be significantly less common than just choosing one.
 
-To watch multiple entities with the same observer you previously had to call `Observer::with_entity` or `Observer::watch_entity` for each entity. New methods `Observer::with_entities` and `Observer::watch_entities` have been added for your convenience.
+[`Event`]: https://dev-docs.bevy.org/bevy/ecs/event/trait.Event.html
+[`Trigger`]: `https://dev-docs.bevy.org/bevy/ecs/event/trait.Trigger.html`
+[`GlobalTrigger`]: `https://dev-docs.bevy.org/bevy/ecs/event/type.GlobalTrigger.html`
+[`EntityEvent`]: https://dev-docs.bevy.org/bevy/ecs/event/trait.EntityEvent.html
+[`ChildOf`]: https://dev-docs.bevy.org/bevy/ecs/hierarchy/struct.ChildOf.html
+[`PropagatingEntityTrigger`]: `https://dev-docs.bevy.org/bevy/ecs/event/type.PropagatingEntityTrigger.html`
+[`Add`]: https://dev-docs.bevy.org/bevy/ecs/lifecycle/struct.Add.html
+[`EntityComponentsTrigger`]: `https://dev-docs.bevy.org/bevy/ecs/event/type.EntityComponentsTrigger.html`
+[`AnimationPlayer`]: https://dev-docs.bevy.org/bevy/animation/struct.AnimationPlayer.html
+[`AnimationEvent`]: https://dev-docs.bevy.org/bevy/animation/trait.AnimationEvent.html
+[`AnimationEventTrigger`]: https://dev-docs.bevy.org/bevy/animation/type.AnimationEventTrigger.html
diff --git a/tests/window/desktop_request_redraw.rs b/tests/window/desktop_request_redraw.rs
index 5cabc42e23a39..299af50ed03f6 100644
--- a/tests/window/desktop_request_redraw.rs
+++ b/tests/window/desktop_request_redraw.rs
@@ -82,14 +82,12 @@ fn setup(
             AnimationActive,
         ))
         .observe(
-            |trigger: On<Pointer<Click>>, mut commands: Commands| match trigger.button {
+            |click: On<Pointer<Click>>, mut commands: Commands| match click.button {
                 PointerButton::Primary => {
-                    commands.entity(trigger.entity()).insert(AnimationActive);
+                    commands.entity(click.entity).insert(AnimationActive);
                 }
                 PointerButton::Secondary => {
-                    commands
-                        .entity(trigger.entity())
-                        .remove::<AnimationActive>();
+                    commands.entity(click.entity).remove::<AnimationActive>();
                 }
                 _ => {}
             },
