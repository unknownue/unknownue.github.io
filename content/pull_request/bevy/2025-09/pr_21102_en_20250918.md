+++
title = "#21102 Combine added and existing `ComponentId`s in a single allocation"
date = "2025-09-18T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-09/pr-21102-en-20250918" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-09/pr-21102-zh-cn-20250918" }}
labels = ["A-ECS", "C-Performance"]
+++

# Combine added and existing `ComponentId`s in a single allocation

## Basic Information
- **Title**: Combine added and existing `ComponentId`s in a single allocation
- **PR Link**: https://github.com/bevyengine/bevy/pull/21102
- **Author**: chescock
- **Status**: MERGED
- **Labels**: A-ECS, C-Performance, S-Ready-For-Final-Review
- **Created**: 2025-09-17T14:48:50Z
- **Merged**: 2025-09-18T04:27:30Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

Further shrink `ArchetypeAfterBundleInsert`, following #20626.  

Remove the need for a `collect()` when triggering `Insert` observers.  

## Solution

Combine the `added` and `existing` component id lists into a single boxed slice.  We need to store an additional length to recover the slices, but this means we store **one** pointer and two lengths instead of **two** pointers and two lengths, shrinking the size of `ArchetypeAfterBundleInsert` by one pointer.  

This also means we have a slice available for the full list of `inserted` components without having to copy them into a new `Vec`.  

## The Story of This Pull Request

This PR addresses a performance optimization in Bevy's ECS (Entity Component System) by improving how component IDs are stored and accessed during bundle insertion operations. The changes focus on reducing memory usage and eliminating unnecessary allocations when triggering observers.

The core issue was that `ArchetypeAfterBundleInsert` stored two separate boxed slices for tracking component IDs: one for added components and another for existing components. This required two separate pointer allocations and made it inefficient to access the combined list of inserted components, which required collecting both slices into a new Vec.

The solution combines both component ID lists into a single contiguous allocation while maintaining the ability to access the added and existing subsets separately. This is achieved by storing:
1. A single boxed slice containing all inserted component IDs (added components first, then existing ones)
2. A length value indicating where the added components end and existing components begin

This approach reduces the memory footprint of `ArchetypeAfterBundleInsert` by eliminating one pointer (from two pointers to one), and provides direct access to the combined inserted components without requiring additional allocations.

The implementation required changes to both the data structure definition and its usage sites. The `ArchetypeAfterBundleInsert` struct was modified to replace the separate `added` and `existing` fields with a combined `inserted` field and an `added_len` field. New accessor methods (`inserted()`, `added()`, `existing()`) were added to provide safe access to the different subsets of components.

In the bundle insertion logic, the changes eliminate the need for collecting component IDs into a temporary Vec when triggering INSERT observers. Instead, the code can now directly use the pre-allocated slice, improving performance by avoiding this allocation and copy operation.

The changes maintain backward compatibility in the API while providing significant memory and performance improvements. The optimization is particularly valuable in scenarios with frequent bundle insertions and many component observers.

## Visual Representation

```mermaid
graph LR
    A[ArchetypeAfterBundleInsert] --> B[inserted: Box<[ComponentId]>]
    A --> C[added_len: usize]
    B --> D[added components]
    B --> E[existing components]
```

## Key Files Changed

### `crates/bevy_ecs/src/archetype.rs` (+23/-15)

This file contains the core changes to the `ArchetypeAfterBundleInsert` data structure and its construction.

**Key changes:**
1. Replaced separate `added` and `existing` fields with combined `inserted` storage
2. Added `added_len` field to track the boundary between added and existing components
3. Implemented new accessor methods for safe slicing
4. Updated the bundle insertion logic to build the combined storage

```rust
// Before:
pub(crate) struct ArchetypeAfterBundleInsert {
    pub(crate) added: Box<[ComponentId]>,
    pub(crate) existing: Box<[ComponentId]>,
}

// After:
pub(crate) struct ArchetypeAfterBundleInsert {
    inserted: Box<[ComponentId]>,
    added_len: usize,
}

// New accessor methods:
pub(crate) fn inserted(&self) -> &[ComponentId] {
    &self.inserted
}

pub(crate) fn added(&self) -> &[ComponentId] {
    unsafe { self.inserted.get(..self.added_len).debug_checked_unwrap() }
}

pub(crate) fn existing(&self) -> &[ComponentId] {
    unsafe { self.inserted.get(self.added_len..).debug_checked_unwrap() }
}
```

### `crates/bevy_ecs/src/bundle/insert.rs` (+8/-12)

This file contains updates to the bundle insertion logic to use the new combined storage format.

**Key changes:**
1. Updated observer triggering code to use the new accessor methods
2. Eliminated the need for collecting component IDs into a Vec for INSERT events
3. Maintained the same observer behavior with improved performance

```rust
// Before (required collect()):
&mut EntityComponentsTrigger {
    components: &archetype_after_insert
        .iter_inserted()
        .collect::<Vec<_>>(),
}

// After (direct slice access):
&mut EntityComponentsTrigger {
    components: archetype_after_insert.inserted(),
}
```

## Further Reading

- [Bevy ECS Documentation](https://bevyengine.org/learn/ecs/)
- [Rust Slice Types](https://doc.rust-lang.org/book/ch04-03-slices.html)
- [Memory Allocation Optimization Patterns](https://rust-unofficial.github.io/patterns/patterns/performance/stack-allocated.html)
- [Previous PR #20626](https://github.com/bevyengine/bevy/pull/20626) - Previous optimization this builds upon