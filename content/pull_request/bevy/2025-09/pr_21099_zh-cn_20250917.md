+++
title = "#21099 Fix empty children regression"
date = "2025-09-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-09/pr-21099-en-20250917" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-09/pr-21099-zh-cn-20250917" }}
+++

# Fix empty children regression

## 基本信息
- **标题**: Fix empty children regression
- **PR链接**: https://github.com/bevyengine/bevy/pull/21099
- **作者**: CorvusPrudens
- **状态**: 已合并
- **标签**: C-Bug, A-ECS, S-Ready-For-Final-Review, P-Regression
- **创建时间**: 2025-09-17T01:18:24Z
- **合并时间**: 2025-09-17T17:04:21Z
- **合并者**: alice-i-cecile

## 描述翻译
### Objective

#18865 引入了一个回归问题，导致空的 `children!` 和 `related!` 宏调用无法正常工作。`recursive_spawn` 宏没有处理零输入的情况，因此编译器会拒绝 `children![]`。无论这是否特别有意义并不重要；在很多情况下，你可能希望代码即使在没有子实体时也能编译通过。

### Solution

在 `recursive_spawn` 宏中添加了一个处理零输入的情况，返回一个 unit 类型 `()`。这与之前 `children!` 和 `related!` 宏的行为完全一致。

## 这个PR的故事

这个PR解决了一个由先前修改引入的回归问题。在PR #18865中，对ECS系统的spawn机制进行了重构，但无意中破坏了对空children列表的支持。

问题的核心在于`recursive_spawn`宏的设计。这个宏使用递归模式来处理可变数量的参数，但它缺少对零参数情况的处理。当开发者使用`children![]`或`related![]`时，宏展开会失败，因为没有任何匹配的模式。

从技术角度看，这是一个典型的边界情况处理问题。虽然空的children列表在实际游戏逻辑中可能不常见，但保持API的一致性很重要。代码应该能够处理所有合理的输入情况，包括边界值。

解决方案很直接：在`recursive_spawn`宏中添加一个专门处理零参数的匹配臂。这个匹配臂简单地返回一个unit类型`()`，这与Rust中表示"无值"的惯例一致，也保持了与之前行为的兼容性。

```rust
// 新增的匹配臂处理零参数情况
() => { () };
```

为了确保修复的有效性，还添加了一个测试用例：

```rust
// 确保可以提及空的子实体集合
world.spawn(children![]);
```

这个测试验证了空的`children!`宏现在能够正常编译和执行，防止未来类似的回归问题。

从工程角度看，这个修复体现了几个重要原则：
1. **向后兼容性**：修复恢复了之前的行为，没有破坏现有代码
2. **边界情况处理**：即使是看似不重要的边界情况也值得正确处理
3. **测试验证**：通过测试确保修复的有效性和持久性

这个修改虽然很小，但对于维护代码库的健壮性和开发者体验很重要。它确保了API的一致性，让开发者能够更自由地使用宏而不必担心意外的编译错误。

## 可视化表示

```mermaid
graph TD
    A[children!宏调用] --> B{参数数量判断}
    B -->|0参数| C[recursive_spawn: () => ()]
    B -->|1参数| D[recursive_spawn: $a => Spawn($a)]
    B -->|多参数| E[recursive_spawn: 递归处理]
    C --> F[返回unit类型()]
    D --> G[返回Spawn包装]
    E --> H[返回元组结构]
```

## 关键文件更改

### `crates/bevy_ecs/src/spawn.rs` (+1/-0)
**修改目的**：在`recursive_spawn`宏中添加零参数情况的处理

```rust
// 新增的匹配臂，处理零参数情况
() => { () };
```

这个修改确保了当`children!`或`related!`宏被调用时不带任何参数时，宏能够正确展开并返回unit类型`()`。

### `crates/bevy_ecs/src/hierarchy.rs` (+3/-0)
**修改目的**：添加测试用例验证空children宏的功能

```rust
// 确保可以提及空的子实体集合
world.spawn(children![]);
```

这个测试用例验证了修复的有效性，确保空的`children!`宏调用能够正常编译和执行。

## 进一步阅读

- [Rust宏指南](https://doc.rust-lang.org/book/ch19-06-macros.html) - 了解Rust宏的工作原理
- [Bevy ECS文档](https://bevyengine.org/learn/books/ecs/) - 学习Bevy的实体组件系统
- [单元测试最佳实践](https://doc.rust-lang.org/book/ch11-01-writing-tests.html) - 了解如何编写有效的测试用例

## 完整代码差异

```diff
diff --git a/crates/bevy_ecs/src/hierarchy.rs b/crates/bevy_ecs/src/hierarchy.rs
index d325d5756cb1c..ad390db97bf72 100644
--- a/crates/bevy_ecs/src/hierarchy.rs
+++ b/crates/bevy_ecs/src/hierarchy.rs
@@ -808,6 +808,9 @@ mod tests {
     fn spawn_many_children() {
         let mut world = World::new();
 
+        // ensure an empty set can be mentioned
+        world.spawn(children![]);
+
         // 12 children should result in a flat tuple
         let id = world
             .spawn(children![(), (), (), (), (), (), (), (), (), (), (), ()])
diff --git a/crates/bevy_ecs/src/spawn.rs b/crates/bevy_ecs/src/spawn.rs
index e4b7340c9ccfc..b127c7f7dccb7 100644
--- a/crates/bevy_ecs/src/spawn.rs
+++ b/crates/bevy_ecs/src/spawn.rs
@@ -513,6 +513,7 @@ macro_rules! related {
 #[doc(hidden)]
 macro_rules! recursive_spawn {
     // direct expansion
+    () => { () };
     ($a:expr) => {
         $crate::spawn::Spawn($a)
     };
```