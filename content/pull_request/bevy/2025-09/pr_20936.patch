diff --git a/crates/bevy_animation/src/animation_curves.rs b/crates/bevy_animation/src/animation_curves.rs
index 0e1d5866df41b..ba77ec4b5ec56 100644
--- a/crates/bevy_animation/src/animation_curves.rs
+++ b/crates/bevy_animation/src/animation_curves.rs
@@ -817,7 +817,7 @@ pub enum EvaluatorId<'a> {
     Type(TypeId),
 }
 
-/// A low-level trait for use in [`crate::VariableCurve`] that provides fine
+/// A low-level trait for use in [`VariableCurve`](`crate::VariableCurve`) that provides fine
 /// control over how animations are evaluated.
 ///
 /// You can implement this trait when the generic [`AnimatableCurveEvaluator`]
@@ -834,7 +834,7 @@ pub enum EvaluatorId<'a> {
 /// either a (value, weight) pair or empty. *Value* here refers to an instance
 /// of the value being animated: for example, [`Vec3`] in the case of
 /// translation keyframes.  The stack stores intermediate values generated while
-/// evaluating the [`crate::graph::AnimationGraph`], while the blend register
+/// evaluating the [`AnimationGraph`](`crate::graph::AnimationGraph`), while the blend register
 /// stores the result of a blend operation.
 ///
 /// [`Vec3`]: bevy_math::Vec3
diff --git a/crates/bevy_animation/src/graph.rs b/crates/bevy_animation/src/graph.rs
index adb4a7c7ac541..916e11b9056da 100644
--- a/crates/bevy_animation/src/graph.rs
+++ b/crates/bevy_animation/src/graph.rs
@@ -299,7 +299,7 @@ pub struct ThreadedAnimationGraph {
     ///
     /// The node indices here are stored in postorder. Siblings are stored in
     /// descending order. This is because the
-    /// [`crate::animation_curves::AnimationCurveEvaluator`] uses a stack for
+    /// [`AnimationCurveEvaluator`](`crate::animation_curves::AnimationCurveEvaluator`) uses a stack for
     /// evaluation. Consider this graph:
     ///
     /// ```text
diff --git a/crates/bevy_asset/src/io/web.rs b/crates/bevy_asset/src/io/web.rs
index b0b297126bce6..50a261c8ce959 100644
--- a/crates/bevy_asset/src/io/web.rs
+++ b/crates/bevy_asset/src/io/web.rs
@@ -104,7 +104,7 @@ impl WebAssetReader {
         PathBuf::from(prefix).join(path)
     }
 
-    /// See [`crate::io::get_meta_path`]
+    /// See [`io::get_meta_path`](`crate::io::get_meta_path`)
     fn make_meta_uri(&self, path: &Path) -> PathBuf {
         let meta_path = crate::io::get_meta_path(path);
         self.make_uri(&meta_path)
diff --git a/crates/bevy_color/src/color_ops.rs b/crates/bevy_color/src/color_ops.rs
index a3266ba2d6911..5229a8d70bb98 100644
--- a/crates/bevy_color/src/color_ops.rs
+++ b/crates/bevy_color/src/color_ops.rs
@@ -112,7 +112,7 @@ pub trait Hue: Sized {
 /// Trait for manipulating the saturation of a color.
 ///
 /// When working with color spaces that do not have native saturation components
-/// the operations are performed in [`crate::Hsla`].
+/// the operations are performed in [`Hsla`](`crate::Hsla`).
 pub trait Saturation: Sized {
     /// Return a new version of this color with the saturation channel set to the given value.
     fn with_saturation(&self, saturation: f32) -> Self;
diff --git a/crates/bevy_picking/src/lib.rs b/crates/bevy_picking/src/lib.rs
index 266c0971822f9..58d2e96410329 100644
--- a/crates/bevy_picking/src/lib.rs
+++ b/crates/bevy_picking/src/lib.rs
@@ -283,7 +283,7 @@ pub type PickSet = PickingSystems;
 /// and the [`InteractionPlugin`], this is probably the plugin that will be most used.
 ///
 /// Note: for any of these plugins to work, they require a picking backend to be active,
-/// The picking backend is responsible to turn an input, into a [`crate::backend::PointerHits`]
+/// The picking backend is responsible to turn an input, into a [`PointerHits`](`crate::backend::PointerHits`)
 /// that [`PickingPlugin`] and [`InteractionPlugin`] will refine into [`bevy_ecs::observer::On`]s.
 #[derive(Default)]
 pub struct DefaultPickingPlugins;
diff --git a/crates/bevy_picking/src/pointer.rs b/crates/bevy_picking/src/pointer.rs
index 86af877362270..efbcb1c4260a6 100644
--- a/crates/bevy_picking/src/pointer.rs
+++ b/crates/bevy_picking/src/pointer.rs
@@ -2,7 +2,7 @@
 //!
 //! The picking system is built around the concept of a 'Pointer', which is an
 //! abstract representation of a user input with a specific screen location. The cursor
-//! and touch input is provided under [`crate::input`], but you can also implement
+//! and touch input is provided under [`input`](`crate::input`), but you can also implement
 //! your own custom pointers by supplying a unique ID.
 //!
 //! The purpose of this module is primarily to provide a common interface that can be
