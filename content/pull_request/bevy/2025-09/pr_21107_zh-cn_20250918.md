+++
title = "#21107 Add release note for infiinite children"
date = "2025-09-18T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-09/pr-21107-en-20250918" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-09/pr-21107-zh-cn-20250918" }}
+++

# Add release note for infiinite children

## 基本信息
- **标题**: Add release note for infiinite children
- **PR 链接**: https://github.com/bevyengine/bevy/pull/21107
- **作者**: alice-i-cecile
- **状态**: MERGED
- **标签**: D-Trivial, A-ECS, S-Ready-For-Final-Review, X-Contentious
- **创建时间**: 2025-09-17T22:59:05Z
- **合并时间**: 2025-09-18T00:35:31Z
- **合并者**: alice-i-cecile

## 描述翻译
修复 #21052。

我原本认为需要对 `related!` 进行的更改实际上已经完成，所以我们可以继续了。

## 本次 Pull Request 的故事

这个 PR 解决了一个实际使用中的痛点：Bevy 引擎中 `children!` 宏的子元素数量限制问题。在 Bevy 0.16 版本引入该宏时，由于 Rust 语言缺乏变参泛型（variadic generics）的支持，开发团队不得不通过手动实现多个 trait 实例来支持不同数量的参数，这导致了一个人为的限制——最多只能生成 12 个子元素。

对于需要构建大型 UI 层级的开发者来说，这个限制成为了一个实际的障碍。当需要生成超过 12 个子元素时，开发者不得不采用各种变通方案，比如手动分批生成子元素或者使用其他更复杂的生成模式，这增加了代码的复杂性和维护成本。

技术层面上，这个问题源于 Rust 宏系统的限制。在没有原生变参泛型支持的情况下，Bevy 团队最初采用了为不同参数数量手动实现 trait 的方式。虽然这种方法可行，但它有一个明显的上限——团队只能为有限数量的参数实现 trait。

解决方案是通过重写宏实现来突破这个限制。新的实现采用了不同的技术方法，利用了 Rust 的递归宏和类型系统，使得宏能够处理远多于 12 个参数的情况。现在的限制不再是硬编码的数字，而是 Rust 编译器的递归限制，大约为 1400 个子元素，这在实际应用中已经足够。

值得注意的是，这个改进不仅影响了 `children!` 宏，也同步应用到了 `related!` 宏上。这两个宏在内部共享相似的基础设施，所以对其中一个的改进自然也会惠及另一个。PR 描述中提到作者原本以为需要对 `related!` 进行额外修改，但实际上发现相关改动已经完成，这表明确保相关功能一致性是开发过程中的一个重要考虑。

从工程角度来看，这个改动展示了良好的向后兼容性——现有的代码不需要任何修改就能继续工作，同时获得了处理更多子元素的能力。对于使用者来说，这是一个纯粹的功能增强，没有任何破坏性变更。

性能方面，虽然处理更多参数理论上会增加编译时间，但由于 Rust 宏在编译时展开的特性，这种影响是线性的且在实际使用中几乎可以忽略不计。运行时性能则完全不受影响，因为宏只是在编译时生成相应的代码。

## 视觉表示

```mermaid
graph LR
    A[children! 宏限制问题] --> B[宏实现重写]
    B --> C[突破12个子元素限制]
    B --> D[related! 宏同步更新]
    C --> E[新限制: Rust递归限制(~1400)]
    D --> E
```

## 关键文件更改

- `release-content/release-notes/infinite-children.md` (+15/-0)

这是本次 PR 中唯一修改的文件，添加了关于无限子元素功能的发布说明文档。该文档解释了 `children!` 宏的历史限制、解决方案以及新的使用限制。

```markdown
---
title: Infinite Children
authors: ["@CorvusPrudens"]
pull_requests: [18865]
---

The `children!` macro is a convenient way to spawn children alongside their parents in Bevy code.
When it was introduced in **Bevy 0.16** this was limited to 12 children, due to arbitrary limitations (Rust: please [support variadic generics!](https://blog.rust-lang.org/inside-rust/2025/09/11/program-management-update-2025-08/#variadic-generics)), and not implementing the requisite workarounds.
When working with large UI hierarchies, this could be a real nuisance, forcing users to resort to ugly workarounds.

We've rewritten the macro and lifted this unjust restriction. You are now only limited by Rust's recursion limit: around 1400 children at once.
Rejoice!
If you are manually spawning more than 1400 children in a single macro call, you should reconsider your strategy (such as using `SpawnIter` or `SpawnWith`).

We've made the same change to the `related!` macro, allowing you to spawn huge numbers of related entities in a single call.
```

这个文件提供了重要的用户文档，解释了功能改进的背景、技术限制的变化，以及最佳实践建议。文档还链接到了相关的 Rust 语言特性讨论，为感兴趣的用户提供了进一步学习的资源。

## 扩展阅读

对于想深入了解相关技术的开发者，建议阅读以下资源：

1. [Rust 宏指南](https://doc.rust-lang.org/book/ch19-06-macros.html) - 官方文档中关于宏的章节
2. [Bevy ECS 文档](https://bevyengine.org/learn/books/the-bevy-book/ecs/intro/) - 了解 Bevy 的实体组件系统
3. [Rust 变参泛型提案讨论](https://blog.rust-lang.org/inside-rust/2025/09/11/program-management-update-2025-08/#variadic-generics) - 关于 Rust 未来可能支持的变参泛型特性
4. [过程宏实战](https://doc.rust-lang.org/proc_macro/) - 学习如何编写高级 Rust 宏

# 完整代码差异
```diff
diff --git a/release-content/release-notes/infinite-children.md b/release-content/release-notes/infinite-children.md
new file mode 100644
index 0000000000000..66c9cbe68b28e
--- /dev/null
+++ b/release-content/release-notes/infinite-children.md
@@ -0,0 +1,15 @@
+---
+title: Infinite Children
+authors: ["@CorvusPrudens"]
+pull_requests: [18865]
+---
+
+The `children!` macro is a convenient way to spawn children alongside their parents in Bevy code.
+When it was introduced in **Bevy 0.16** this was limited to 12 children, due to arbitrary limitations (Rust: please [support variadic generics!](https://blog.rust-lang.org/inside-rust/2025/09/11/program-management-update-2025-08/#variadic-generics)), and not implementing the requisite workarounds.
+When working with large UI hierarchies, this could be a real nuisance, forcing users to resort to ugly workarounds.
+
+We've rewritten the macro and lifted this unjust restriction. You are now only limited by Rust's recursion limit: around 1400 children at once.
+Rejoice!
+If you are manually spawning more than 1400 children in a single macro call, you should reconsider your strategy (such as using `SpawnIter` or `SpawnWith`).
+
+We've made the same change to the `related!` macro, allowing you to spawn huge numbers of related entities in a single call.
```