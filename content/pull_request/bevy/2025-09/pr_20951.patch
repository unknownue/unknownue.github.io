diff --git a/crates/bevy_anti_alias/src/taa/mod.rs b/crates/bevy_anti_alias/src/taa/mod.rs
index 1781f90d9935f..44aa6624c1111 100644
--- a/crates/bevy_anti_alias/src/taa/mod.rs
+++ b/crates/bevy_anti_alias/src/taa/mod.rs
@@ -1,6 +1,6 @@
 use bevy_app::{App, Plugin};
 use bevy_asset::{embedded_asset, load_embedded_asset, AssetServer, Handle};
-use bevy_camera::{Camera, Camera3d, Projection};
+use bevy_camera::{Camera, Camera3d};
 use bevy_core_pipeline::{
     core_3d::graph::{Core3d, Node3d},
     prepass::{DepthPrepass, MotionVectorPrepass, ViewPrepassTextures},
@@ -83,7 +83,7 @@ impl Plugin for TemporalAntiAliasPlugin {
     }
 }
 
-/// Component to apply temporal anti-aliasing to a 3D perspective camera.
+/// Component to apply temporal anti-aliasing to a 3D camera.
 ///
 /// Temporal anti-aliasing (TAA) is a form of image smoothing/filtering, like
 /// multisample anti-aliasing (MSAA), or fast approximate anti-aliasing (FXAA).
@@ -109,8 +109,6 @@ impl Plugin for TemporalAntiAliasPlugin {
 ///
 /// Any camera with this component must also disable [`Msaa`] by setting it to [`Msaa::Off`].
 ///
-/// [Currently](https://github.com/bevyengine/bevy/issues/8423), TAA cannot be used with [`bevy_camera::OrthographicProjection`].
-///
 /// TAA also does not work well with alpha-blended meshes, as it requires depth writing to determine motion.
 ///
 /// It is very important that correct motion vectors are written for everything on screen.
@@ -344,20 +342,15 @@ impl SpecializedRenderPipeline for TaaPipeline {
 }
 
 fn extract_taa_settings(mut commands: Commands, mut main_world: ResMut<MainWorld>) {
-    let mut cameras_3d = main_world.query::<(
-        RenderEntity,
-        &Camera,
-        &Projection,
-        Option<&mut TemporalAntiAliasing>,
-    )>();
-
-    for (entity, camera, camera_projection, taa_settings) in cameras_3d.iter_mut(&mut main_world) {
+    let mut cameras_3d =
+        main_world.query::<(RenderEntity, &Camera, Option<&mut TemporalAntiAliasing>)>();
+
+    for (entity, camera, taa_settings) in cameras_3d.iter_mut(&mut main_world) {
         let mut entity_commands = commands
             .get_entity(entity)
             .expect("Camera entity wasn't synced.");
         if let Some(mut taa_settings) = taa_settings
             && camera.is_active
-            && camera_projection.is_perspective()
         {
             entity_commands.insert(taa_settings.clone());
             taa_settings.reset = false;
diff --git a/crates/bevy_render/src/camera.rs b/crates/bevy_render/src/camera.rs
index 085e7733ad397..24047d86402c8 100644
--- a/crates/bevy_render/src/camera.rs
+++ b/crates/bevy_render/src/camera.rs
@@ -658,10 +658,6 @@ pub fn sort_cameras(
 /// A subpixel offset to jitter a perspective camera's frustum by.
 ///
 /// Useful for temporal rendering techniques.
-///
-/// Do not use with [`OrthographicProjection`].
-///
-/// [`OrthographicProjection`]: bevy_camera::OrthographicProjection
 #[derive(Component, Clone, Default, Reflect)]
 #[reflect(Default, Component, Clone)]
 pub struct TemporalJitter {
@@ -671,16 +667,14 @@ pub struct TemporalJitter {
 
 impl TemporalJitter {
     pub fn jitter_projection(&self, clip_from_view: &mut Mat4, view_size: Vec2) {
+        // https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/d7531ae47d8b36a5d4025663e731a47a38be882f/docs/techniques/media/super-resolution-temporal/jitter-space.svg
+        let mut jitter = (self.offset * vec2(2.0, -2.0)) / view_size;
+
+        // orthographic
         if clip_from_view.w_axis.w == 1.0 {
-            warn!(
-                "TemporalJitter not supported with OrthographicProjection. Use PerspectiveProjection instead."
-            );
-            return;
+            jitter *= vec2(clip_from_view.x_axis.x, clip_from_view.y_axis.y) * 0.5;
         }
 
-        // https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/d7531ae47d8b36a5d4025663e731a47a38be882f/docs/techniques/media/super-resolution-temporal/jitter-space.svg
-        let jitter = (self.offset * vec2(2.0, -2.0)) / view_size;
-
         clip_from_view.z_axis.x += jitter.x;
         clip_from_view.z_axis.y += jitter.y;
     }
