+++
title = "#20887 Change `bevy_math` to use `inline` instead of `inline(always)"
date = "2025-09-29T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-09/pr-20887-en-20250929" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-09/pr-20887-zh-cn-20250929" }}
+++

# 技术分析报告：将 `bevy_math` 的 `inline(always)` 改为 `inline`

## 基本信息
- **标题**: Change `bevy_math` to use `inline` instead of `inline(always)`
- **PR 链接**: https://github.com/bevyengine/bevy/pull/20887
- **作者**: greeble-dev
- **状态**: 已合并
- **标签**: C-Performance, S-Ready-For-Final-Review, A-Math, X-Contentious
- **创建时间**: 2025-09-05T14:33:09Z
- **合并时间**: 2025-09-29T23:15:59Z
- **合并者**: alice-i-cecile

## 描述翻译

### 目标
使 `bevy_math` 更接近推荐的 inlining 实践，避免调试器和优化大小的问题。

### 背景
一些 `bevy_math` 模块对几乎所有函数都应用了 `#[inline(always)]`。这对某些用户有不利影响 - 它可能阻止优化大小，并且可能阻止调试器步入函数。

我找不到任何建议默认使用 `inline(always)` 的来源 - 最常见的建议是"谨慎使用，仅在性能分析后使用"（示例：[std lib guide](https://std-dev-guide.rust-lang.org/policy/inline.html)）。我查看了 `bevy_math` 的历史记录，但没有找到解释为什么选择 `inline(always)` 的内容。

### 解决方案
此 PR 将所有 `#[inline(always)]` 实例更改为 `#[inline]`。

在优化构建中，这个更改不太可能产生任何差异 - 几乎所有函数都很小，无论如何它们都会被内联。基准测试显示没有差异。

在 `opt-level = 0` 构建中，这个更改有时会降低性能 - 一个数学密集的微基准测试出现了 -10% 的性能下降。但如果这能让用户在调试器中步入函数，这可以说是正确的权衡。

总的来说，我认为这对大多数用户来说是更安全的默认设置。`inline(always)` 有几个具体的不利因素，而 `inline` 有一些权衡但没有明显的不利因素。

这个更改还添加了一个新的 `bevy_math` 基准测试，其中包括一些受影响的函数。

### 替代方案
这个更改可以更进一步。

- 从较重的函数（如 `BoundingSphere::from_point_cloud`）中移除 `#[inline]`。
    - 可能有助于优化大小。我为了保持简单而保留了这些。
- 完全移除 `#[inline]`。
    - 我认为这可能是件好事，但需要更多测试，并且可能会有争议。

### 测试
```sh
cargo bench -p benches --bench math
```

此外：
- 检查了基准测试的反汇编以确认哪些内容被内联。
- 使用各种优化级别编译 `alien_cake_addict` 以检查没有主要的大小差异。

编辑：更多细节在 [评论 1](https://github.com/bevyengine/bevy/pull/20887#issuecomment-3261735671), [评论 2](https://github.com/bevyengine/bevy/pull/20887#issuecomment-3263596184)。

## 这个 PR 的故事

这个 PR 始于对 `bevy_math` 库中内联策略的重新审视。开发者在代码审查过程中注意到，该库广泛使用了 `#[inline(always)]` 属性，这违背了 Rust 社区关于内联的最佳实践。

### 问题背景
`inline(always)` 是一个强制性的内联指令，它告诉编译器无论函数大小如何都必须内联。虽然这可能在特定情况下提高性能，但它有几个显著的缺点：

1. **调试困难**：调试器无法步入被强制内联的函数
2. **代码膨胀**：阻止了优化大小的机会
3. **违反最佳实践**：Rust 标准库指南明确建议谨慎使用此属性

开发者调查了历史记录，但没有找到当初选择这种激进内联策略的具体原因。考虑到社区的最佳实践和实际用户反馈，决定重新评估这一决策。

### 解决方案设计
PR 作者采取了一个平衡的方法：将所有 `#[inline(always)]` 替换为 `#[inline]`。后者是一个提示性内联，编译器会根据自己的启发式算法决定是否内联，同时仍然考虑性能特征。

这个选择的合理性在于：
- 大多数数学函数都很小（几行代码），在优化构建中很可能会被内联
- 保留了调试能力
- 允许编译器在优化大小时做出更好的决策

### 实现细节
实现相对直接，但范围广泛。更改影响了 7 个主要模块，涉及数百个函数的内联属性修改。关键的变化模式是：

```rust
// 之前：
#[inline(always)]
pub fn some_math_function() { ... }

// 之后：
#[inline]
pub fn some_math_function() { ... }
```

为了验证更改的影响，作者添加了一个新的基准测试 `bounding.rs`，专门测试受影响的边界体积计算函数。这个基准测试模拟了真实世界的使用场景，包括点云边界计算和体积合并操作。

### 性能影响分析
基准测试结果显示：
- **优化构建**：没有可测量的性能差异
- **调试构建**：某些数学密集操作有约 10% 的性能下降

这种性能特征符合预期。在调试构建中，编译器不会积极内联，因此从强制内联改为提示性内联会导致更多函数调用开销。但在实际使用中，调试构建的性能通常不是主要关注点。

### 工程权衡
这个 PR 体现了典型的工程权衡：

**获得的收益**：
- 改善调试体验
- 符合社区最佳实践
- 为优化大小提供可能性

**付出的代价**：
- 调试构建中的轻微性能下降
- 需要重新验证性能特征

考虑到数学库在游戏引擎中的核心地位，这种保守的方法降低了风险，同时提供了实质性的开发体验改进。

## 可视化表示

```mermaid
graph TD
    A[inline(always)问题] --> B[调试困难]
    A --> C[代码膨胀]
    A --> D[违反最佳实践]
    
    E[解决方案] --> F[改为inline提示]
    F --> G[保持优化构建性能]
    F --> H[改善调试体验]
    F --> I[允许大小优化]
    
    J[验证] --> K[基准测试]
    J --> L[反汇编检查]
    J --> M[实际项目测试]
```

## 关键文件更改

### `crates/bevy_math/src/primitives/dim2.rs` (+133/-133)
这个文件包含了 2D 基本形状的实现，如圆形、椭圆、矩形等。所有函数的内联属性都从 `always` 改为普通提示。

**示例更改**：
```rust
// 之前：
#[inline(always)]
pub const fn new(radius: f32) -> Self {
    Self { radius }
}

// 之后：
#[inline]
pub const fn new(radius: f32) -> Self {
    Self { radius }
}
```

### `crates/bevy_math/src/primitives/dim3.rs` (+80/-80)
3D 基本形状的类似更改，包括球体、立方体、圆柱体等。

**示例更改**：
```rust
// 之前：
#[inline(always)]
pub const fn new(radius: f32) -> Self {
    Self { radius }
}

// 之后：
#[inline]
pub const fn new(radius: f32) -> Self {
    Self { radius }
}
```

### `crates/bevy_math/src/ops.rs` (+64/-64)
数学运算函数的包装器，包括三角函数、对数函数等。这个模块为不同的数学后端（std 和 libm）提供了统一的接口。

**示例更改**：
```rust
// 之前：
#[inline(always)]
pub fn powf(x: f32, y: f32) -> f32 {
    f32::powf(x, y)
}

// 之后：
#[inline]
pub fn powf(x: f32, y: f32) -> f32 {
    f32::powf(x, y)
}
```

### `crates/bevy_math/src/bounding/bounded2d/mod.rs` (+37/-37) 和 `bounded3d/mod.rs` (+36/-36)
2D 和 3D 边界体积计算的实现，包括 AABB 和边界圆/球体。这些是几何计算的核心组件。

**示例更改**：
```rust
// 之前：
#[inline(always)]
pub fn new(center: Vec2, half_size: Vec2) -> Self {
    debug_assert!(half_size.x >= 0.0 && half_size.y >= 0.0);
    Self { center, half_size }
}

// 之后：
#[inline]
pub fn new(center: Vec2, half_size: Vec2) -> Self {
    debug_assert!(half_size.x >= 0.0 && half_size.y >= 0.0);
    Self { center, half_size }
}
```

### 新基准测试：`benches/benches/bevy_math/bounding.rs`
新增的基准测试验证边界体积计算的性能，确保内联策略更改不会对关键路径产生负面影响。

```rust
c.bench_function(bench!("bounding"), |b| {
    b.iter(|| {
        let aabb = point_clouds
            .iter()
            .map(PointCloud::aabb)
            .reduce(|l, r| l.merge(&r));
        
        let sphere = point_clouds
            .iter()
            .map(PointCloud::sphere)
            .reduce(|l, r| l.merge(&r));
        
        black_box(aabb);
        black_box(sphere);
    });
});
```

## 进一步阅读

1. [Rust 标准库开发指南 - 内联策略](https://std-dev-guide.rust-lang.org/policy/inline.html)
2. [Rust 性能手册 - 内联](https://nnethercote.github.io/perf-book/inlining.html)
3. [Bevy 引擎数学库文档](https://docs.rs/bevy_math/latest/bevy_math/)
4. [LLVM 内联优化](https://llvm.org/docs/InlineOptimization.html)