diff --git a/crates/bevy_ui_render/src/lib.rs b/crates/bevy_ui_render/src/lib.rs
index 2f272449951d2..2eb662ae42fa1 100644
--- a/crates/bevy_ui_render/src/lib.rs
+++ b/crates/bevy_ui_render/src/lib.rs
@@ -1331,105 +1331,253 @@ pub fn prepare_uinodes(
 
             for item_index in 0..ui_phase.items.len() {
                 let item = &mut ui_phase.items[item_index];
-                if let Some(extracted_uinode) = extracted_uinodes
+                let Some(extracted_uinode) = extracted_uinodes
                     .uinodes
                     .get(item.index)
                     .filter(|n| item.entity() == n.render_entity)
-                {
-                    let mut existing_batch = batches.last_mut();
-
-                    if batch_image_handle == AssetId::invalid()
-                        || existing_batch.is_none()
-                        || (batch_image_handle != AssetId::default()
-                            && extracted_uinode.image != AssetId::default()
-                            && batch_image_handle != extracted_uinode.image)
-                    {
-                        if let Some(gpu_image) = gpu_images.get(extracted_uinode.image) {
-                            batch_item_index = item_index;
-                            batch_image_handle = extracted_uinode.image;
-
-                            let new_batch = UiBatch {
-                                range: vertices_index..vertices_index,
-                                image: extracted_uinode.image,
-                            };
+                else {
+                    batch_image_handle = AssetId::invalid();
+                    continue;
+                };
 
-                            batches.push((item.entity(), new_batch));
-
-                            image_bind_groups
-                                .values
-                                .entry(batch_image_handle)
-                                .or_insert_with(|| {
-                                    render_device.create_bind_group(
-                                        "ui_material_bind_group",
-                                        &ui_pipeline.image_layout,
-                                        &BindGroupEntries::sequential((
-                                            &gpu_image.texture_view,
-                                            &gpu_image.sampler,
-                                        )),
-                                    )
-                                });
+                let mut existing_batch = batches.last_mut();
 
-                            existing_batch = batches.last_mut();
-                        } else {
-                            continue;
-                        }
-                    } else if batch_image_handle == AssetId::default()
+                if batch_image_handle == AssetId::invalid()
+                    || existing_batch.is_none()
+                    || (batch_image_handle != AssetId::default()
                         && extracted_uinode.image != AssetId::default()
+                        && batch_image_handle != extracted_uinode.image)
+                {
+                    if let Some(gpu_image) = gpu_images.get(extracted_uinode.image) {
+                        batch_item_index = item_index;
+                        batch_image_handle = extracted_uinode.image;
+
+                        let new_batch = UiBatch {
+                            range: vertices_index..vertices_index,
+                            image: extracted_uinode.image,
+                        };
+
+                        batches.push((item.entity(), new_batch));
+
+                        image_bind_groups
+                            .values
+                            .entry(batch_image_handle)
+                            .or_insert_with(|| {
+                                render_device.create_bind_group(
+                                    "ui_material_bind_group",
+                                    &ui_pipeline.image_layout,
+                                    &BindGroupEntries::sequential((
+                                        &gpu_image.texture_view,
+                                        &gpu_image.sampler,
+                                    )),
+                                )
+                            });
+
+                        existing_batch = batches.last_mut();
+                    } else {
+                        continue;
+                    }
+                } else if batch_image_handle == AssetId::default()
+                    && extracted_uinode.image != AssetId::default()
+                {
+                    if let Some(ref mut existing_batch) = existing_batch
+                        && let Some(gpu_image) = gpu_images.get(extracted_uinode.image)
                     {
-                        if let Some(ref mut existing_batch) = existing_batch
-                            && let Some(gpu_image) = gpu_images.get(extracted_uinode.image)
-                        {
-                            batch_image_handle = extracted_uinode.image;
-                            existing_batch.1.image = extracted_uinode.image;
-
-                            image_bind_groups
-                                .values
-                                .entry(batch_image_handle)
-                                .or_insert_with(|| {
-                                    render_device.create_bind_group(
-                                        "ui_material_bind_group",
-                                        &ui_pipeline.image_layout,
-                                        &BindGroupEntries::sequential((
-                                            &gpu_image.texture_view,
-                                            &gpu_image.sampler,
-                                        )),
-                                    )
-                                });
+                        batch_image_handle = extracted_uinode.image;
+                        existing_batch.1.image = extracted_uinode.image;
+
+                        image_bind_groups
+                            .values
+                            .entry(batch_image_handle)
+                            .or_insert_with(|| {
+                                render_device.create_bind_group(
+                                    "ui_material_bind_group",
+                                    &ui_pipeline.image_layout,
+                                    &BindGroupEntries::sequential((
+                                        &gpu_image.texture_view,
+                                        &gpu_image.sampler,
+                                    )),
+                                )
+                            });
+                    } else {
+                        continue;
+                    }
+                }
+                match &extracted_uinode.item {
+                    ExtractedUiItem::Node {
+                        atlas_scaling,
+                        flip_x,
+                        flip_y,
+                        border_radius,
+                        border,
+                        node_type,
+                        rect,
+                        color,
+                    } => {
+                        let mut flags = if extracted_uinode.image != AssetId::default() {
+                            shader_flags::TEXTURED
                         } else {
-                            continue;
+                            shader_flags::UNTEXTURED
+                        };
+
+                        let mut uinode_rect = *rect;
+
+                        let rect_size = uinode_rect.size();
+
+                        let transform = extracted_uinode.transform;
+
+                        // Specify the corners of the node
+                        let positions = QUAD_VERTEX_POSITIONS
+                            .map(|pos| transform.transform_point2(pos * rect_size).extend(0.));
+                        let points = QUAD_VERTEX_POSITIONS.map(|pos| pos * rect_size);
+
+                        // Calculate the effect of clipping
+                        // Note: this won't work with rotation/scaling, but that's much more complex (may need more that 2 quads)
+                        let mut positions_diff = if let Some(clip) = extracted_uinode.clip {
+                            [
+                                Vec2::new(
+                                    f32::max(clip.min.x - positions[0].x, 0.),
+                                    f32::max(clip.min.y - positions[0].y, 0.),
+                                ),
+                                Vec2::new(
+                                    f32::min(clip.max.x - positions[1].x, 0.),
+                                    f32::max(clip.min.y - positions[1].y, 0.),
+                                ),
+                                Vec2::new(
+                                    f32::min(clip.max.x - positions[2].x, 0.),
+                                    f32::min(clip.max.y - positions[2].y, 0.),
+                                ),
+                                Vec2::new(
+                                    f32::max(clip.min.x - positions[3].x, 0.),
+                                    f32::min(clip.max.y - positions[3].y, 0.),
+                                ),
+                            ]
+                        } else {
+                            [Vec2::ZERO; 4]
+                        };
+
+                        let positions_clipped = [
+                            positions[0] + positions_diff[0].extend(0.),
+                            positions[1] + positions_diff[1].extend(0.),
+                            positions[2] + positions_diff[2].extend(0.),
+                            positions[3] + positions_diff[3].extend(0.),
+                        ];
+
+                        let points = [
+                            points[0] + positions_diff[0],
+                            points[1] + positions_diff[1],
+                            points[2] + positions_diff[2],
+                            points[3] + positions_diff[3],
+                        ];
+
+                        let transformed_rect_size = transform.transform_vector2(rect_size);
+
+                        // Don't try to cull nodes that have a rotation
+                        // In a rotation around the Z-axis, this value is 0.0 for an angle of 0.0 or π
+                        // In those two cases, the culling check can proceed normally as corners will be on
+                        // horizontal / vertical lines
+                        // For all other angles, bypass the culling check
+                        // This does not properly handles all rotations on all axis
+                        if transform.x_axis[1] == 0.0 {
+                            // Cull nodes that are completely clipped
+                            if positions_diff[0].x - positions_diff[1].x >= transformed_rect_size.x
+                                || positions_diff[1].y - positions_diff[2].y
+                                    >= transformed_rect_size.y
+                            {
+                                continue;
+                            }
+                        }
+                        let uvs = if flags == shader_flags::UNTEXTURED {
+                            [Vec2::ZERO, Vec2::X, Vec2::ONE, Vec2::Y]
+                        } else {
+                            let image = gpu_images
+                                .get(extracted_uinode.image)
+                                .expect("Image was checked during batching and should still exist");
+                            // Rescale atlases. This is done here because we need texture data that might not be available in Extract.
+                            let atlas_extent = atlas_scaling
+                                .map(|scaling| image.size_2d().as_vec2() * scaling)
+                                .unwrap_or(uinode_rect.max);
+                            if *flip_x {
+                                core::mem::swap(&mut uinode_rect.max.x, &mut uinode_rect.min.x);
+                                positions_diff[0].x *= -1.;
+                                positions_diff[1].x *= -1.;
+                                positions_diff[2].x *= -1.;
+                                positions_diff[3].x *= -1.;
+                            }
+                            if *flip_y {
+                                core::mem::swap(&mut uinode_rect.max.y, &mut uinode_rect.min.y);
+                                positions_diff[0].y *= -1.;
+                                positions_diff[1].y *= -1.;
+                                positions_diff[2].y *= -1.;
+                                positions_diff[3].y *= -1.;
+                            }
+                            [
+                                Vec2::new(
+                                    uinode_rect.min.x + positions_diff[0].x,
+                                    uinode_rect.min.y + positions_diff[0].y,
+                                ),
+                                Vec2::new(
+                                    uinode_rect.max.x + positions_diff[1].x,
+                                    uinode_rect.min.y + positions_diff[1].y,
+                                ),
+                                Vec2::new(
+                                    uinode_rect.max.x + positions_diff[2].x,
+                                    uinode_rect.max.y + positions_diff[2].y,
+                                ),
+                                Vec2::new(
+                                    uinode_rect.min.x + positions_diff[3].x,
+                                    uinode_rect.max.y + positions_diff[3].y,
+                                ),
+                            ]
+                            .map(|pos| pos / atlas_extent)
+                        };
+
+                        let color = color.to_f32_array();
+                        if let NodeType::Border(border_flags) = *node_type {
+                            flags |= border_flags;
                         }
-                    }
-                    match &extracted_uinode.item {
-                        ExtractedUiItem::Node {
-                            atlas_scaling,
-                            flip_x,
-                            flip_y,
-                            border_radius,
-                            border,
-                            node_type,
-                            rect,
-                            color,
-                        } => {
-                            let mut flags = if extracted_uinode.image != AssetId::default() {
-                                shader_flags::TEXTURED
-                            } else {
-                                shader_flags::UNTEXTURED
-                            };
-
-                            let mut uinode_rect = *rect;
-
-                            let rect_size = uinode_rect.size();
 
-                            let transform = extracted_uinode.transform;
+                        for i in 0..4 {
+                            ui_meta.vertices.push(UiVertex {
+                                position: positions_clipped[i].into(),
+                                uv: uvs[i].into(),
+                                color,
+                                flags: flags | shader_flags::CORNERS[i],
+                                radius: (*border_radius).into(),
+                                border: [border.left, border.top, border.right, border.bottom],
+                                size: rect_size.into(),
+                                point: points[i].into(),
+                            });
+                        }
 
-                            // Specify the corners of the node
-                            let positions = QUAD_VERTEX_POSITIONS
-                                .map(|pos| transform.transform_point2(pos * rect_size).extend(0.));
-                            let points = QUAD_VERTEX_POSITIONS.map(|pos| pos * rect_size);
+                        for &i in &QUAD_INDICES {
+                            ui_meta.indices.push(indices_index + i as u32);
+                        }
 
-                            // Calculate the effect of clipping
-                            // Note: this won't work with rotation/scaling, but that's much more complex (may need more that 2 quads)
-                            let mut positions_diff = if let Some(clip) = extracted_uinode.clip {
+                        vertices_index += 6;
+                        indices_index += 4;
+                    }
+                    ExtractedUiItem::Glyphs { range } => {
+                        let image = gpu_images
+                            .get(extracted_uinode.image)
+                            .expect("Image was checked during batching and should still exist");
+
+                        let atlas_extent = image.size_2d().as_vec2();
+
+                        for glyph in &extracted_uinodes.glyphs[range.clone()] {
+                            let color = glyph.color.to_f32_array();
+                            let glyph_rect = glyph.rect;
+                            let rect_size = glyph_rect.size();
+
+                            // Specify the corners of the glyph
+                            let positions = QUAD_VERTEX_POSITIONS.map(|pos| {
+                                extracted_uinode
+                                    .transform
+                                    .transform_point2(glyph.translation + pos * glyph_rect.size())
+                                    .extend(0.)
+                            });
+
+                            let positions_diff = if let Some(clip) = extracted_uinode.clip {
                                 [
                                     Vec2::new(
                                         f32::max(clip.min.x - positions[0].x, 0.),
@@ -1459,91 +1607,47 @@ pub fn prepare_uinodes(
                                 positions[3] + positions_diff[3].extend(0.),
                             ];
 
-                            let points = [
-                                points[0] + positions_diff[0],
-                                points[1] + positions_diff[1],
-                                points[2] + positions_diff[2],
-                                points[3] + positions_diff[3],
-                            ];
-
-                            let transformed_rect_size = transform.transform_vector2(rect_size);
-
-                            // Don't try to cull nodes that have a rotation
-                            // In a rotation around the Z-axis, this value is 0.0 for an angle of 0.0 or π
-                            // In those two cases, the culling check can proceed normally as corners will be on
-                            // horizontal / vertical lines
-                            // For all other angles, bypass the culling check
-                            // This does not properly handles all rotations on all axis
-                            if transform.x_axis[1] == 0.0 {
-                                // Cull nodes that are completely clipped
-                                if positions_diff[0].x - positions_diff[1].x
-                                    >= transformed_rect_size.x
-                                    || positions_diff[1].y - positions_diff[2].y
-                                        >= transformed_rect_size.y
-                                {
-                                    continue;
-                                }
+                            // cull nodes that are completely clipped
+                            let transformed_rect_size =
+                                extracted_uinode.transform.transform_vector2(rect_size);
+                            if positions_diff[0].x - positions_diff[1].x
+                                >= transformed_rect_size.x.abs()
+                                || positions_diff[1].y - positions_diff[2].y
+                                    >= transformed_rect_size.y.abs()
+                            {
+                                continue;
                             }
-                            let uvs = if flags == shader_flags::UNTEXTURED {
-                                [Vec2::ZERO, Vec2::X, Vec2::ONE, Vec2::Y]
-                            } else {
-                                let image = gpu_images.get(extracted_uinode.image).expect(
-                                    "Image was checked during batching and should still exist",
-                                );
-                                // Rescale atlases. This is done here because we need texture data that might not be available in Extract.
-                                let atlas_extent = atlas_scaling
-                                    .map(|scaling| image.size_2d().as_vec2() * scaling)
-                                    .unwrap_or(uinode_rect.max);
-                                if *flip_x {
-                                    core::mem::swap(&mut uinode_rect.max.x, &mut uinode_rect.min.x);
-                                    positions_diff[0].x *= -1.;
-                                    positions_diff[1].x *= -1.;
-                                    positions_diff[2].x *= -1.;
-                                    positions_diff[3].x *= -1.;
-                                }
-                                if *flip_y {
-                                    core::mem::swap(&mut uinode_rect.max.y, &mut uinode_rect.min.y);
-                                    positions_diff[0].y *= -1.;
-                                    positions_diff[1].y *= -1.;
-                                    positions_diff[2].y *= -1.;
-                                    positions_diff[3].y *= -1.;
-                                }
-                                [
-                                    Vec2::new(
-                                        uinode_rect.min.x + positions_diff[0].x,
-                                        uinode_rect.min.y + positions_diff[0].y,
-                                    ),
-                                    Vec2::new(
-                                        uinode_rect.max.x + positions_diff[1].x,
-                                        uinode_rect.min.y + positions_diff[1].y,
-                                    ),
-                                    Vec2::new(
-                                        uinode_rect.max.x + positions_diff[2].x,
-                                        uinode_rect.max.y + positions_diff[2].y,
-                                    ),
-                                    Vec2::new(
-                                        uinode_rect.min.x + positions_diff[3].x,
-                                        uinode_rect.max.y + positions_diff[3].y,
-                                    ),
-                                ]
-                                .map(|pos| pos / atlas_extent)
-                            };
 
-                            let color = color.to_f32_array();
-                            if let NodeType::Border(border_flags) = *node_type {
-                                flags |= border_flags;
-                            }
+                            let uvs = [
+                                Vec2::new(
+                                    glyph.rect.min.x + positions_diff[0].x,
+                                    glyph.rect.min.y + positions_diff[0].y,
+                                ),
+                                Vec2::new(
+                                    glyph.rect.max.x + positions_diff[1].x,
+                                    glyph.rect.min.y + positions_diff[1].y,
+                                ),
+                                Vec2::new(
+                                    glyph.rect.max.x + positions_diff[2].x,
+                                    glyph.rect.max.y + positions_diff[2].y,
+                                ),
+                                Vec2::new(
+                                    glyph.rect.min.x + positions_diff[3].x,
+                                    glyph.rect.max.y + positions_diff[3].y,
+                                ),
+                            ]
+                            .map(|pos| pos / atlas_extent);
 
                             for i in 0..4 {
                                 ui_meta.vertices.push(UiVertex {
                                     position: positions_clipped[i].into(),
                                     uv: uvs[i].into(),
                                     color,
-                                    flags: flags | shader_flags::CORNERS[i],
-                                    radius: (*border_radius).into(),
-                                    border: [border.left, border.top, border.right, border.bottom],
+                                    flags: shader_flags::TEXTURED | shader_flags::CORNERS[i],
+                                    radius: [0.0; 4],
+                                    border: [0.0; 4],
                                     size: rect_size.into(),
-                                    point: points[i].into(),
+                                    point: [0.0; 2],
                                 });
                             }
 
@@ -1554,116 +1658,10 @@ pub fn prepare_uinodes(
                             vertices_index += 6;
                             indices_index += 4;
                         }
-                        ExtractedUiItem::Glyphs { range } => {
-                            let image = gpu_images
-                                .get(extracted_uinode.image)
-                                .expect("Image was checked during batching and should still exist");
-
-                            let atlas_extent = image.size_2d().as_vec2();
-
-                            for glyph in &extracted_uinodes.glyphs[range.clone()] {
-                                let color = glyph.color.to_f32_array();
-                                let glyph_rect = glyph.rect;
-                                let rect_size = glyph_rect.size();
-
-                                // Specify the corners of the glyph
-                                let positions = QUAD_VERTEX_POSITIONS.map(|pos| {
-                                    extracted_uinode
-                                        .transform
-                                        .transform_point2(
-                                            glyph.translation + pos * glyph_rect.size(),
-                                        )
-                                        .extend(0.)
-                                });
-
-                                let positions_diff = if let Some(clip) = extracted_uinode.clip {
-                                    [
-                                        Vec2::new(
-                                            f32::max(clip.min.x - positions[0].x, 0.),
-                                            f32::max(clip.min.y - positions[0].y, 0.),
-                                        ),
-                                        Vec2::new(
-                                            f32::min(clip.max.x - positions[1].x, 0.),
-                                            f32::max(clip.min.y - positions[1].y, 0.),
-                                        ),
-                                        Vec2::new(
-                                            f32::min(clip.max.x - positions[2].x, 0.),
-                                            f32::min(clip.max.y - positions[2].y, 0.),
-                                        ),
-                                        Vec2::new(
-                                            f32::max(clip.min.x - positions[3].x, 0.),
-                                            f32::min(clip.max.y - positions[3].y, 0.),
-                                        ),
-                                    ]
-                                } else {
-                                    [Vec2::ZERO; 4]
-                                };
-
-                                let positions_clipped = [
-                                    positions[0] + positions_diff[0].extend(0.),
-                                    positions[1] + positions_diff[1].extend(0.),
-                                    positions[2] + positions_diff[2].extend(0.),
-                                    positions[3] + positions_diff[3].extend(0.),
-                                ];
-
-                                // cull nodes that are completely clipped
-                                let transformed_rect_size =
-                                    extracted_uinode.transform.transform_vector2(rect_size);
-                                if positions_diff[0].x - positions_diff[1].x
-                                    >= transformed_rect_size.x.abs()
-                                    || positions_diff[1].y - positions_diff[2].y
-                                        >= transformed_rect_size.y.abs()
-                                {
-                                    continue;
-                                }
-
-                                let uvs = [
-                                    Vec2::new(
-                                        glyph.rect.min.x + positions_diff[0].x,
-                                        glyph.rect.min.y + positions_diff[0].y,
-                                    ),
-                                    Vec2::new(
-                                        glyph.rect.max.x + positions_diff[1].x,
-                                        glyph.rect.min.y + positions_diff[1].y,
-                                    ),
-                                    Vec2::new(
-                                        glyph.rect.max.x + positions_diff[2].x,
-                                        glyph.rect.max.y + positions_diff[2].y,
-                                    ),
-                                    Vec2::new(
-                                        glyph.rect.min.x + positions_diff[3].x,
-                                        glyph.rect.max.y + positions_diff[3].y,
-                                    ),
-                                ]
-                                .map(|pos| pos / atlas_extent);
-
-                                for i in 0..4 {
-                                    ui_meta.vertices.push(UiVertex {
-                                        position: positions_clipped[i].into(),
-                                        uv: uvs[i].into(),
-                                        color,
-                                        flags: shader_flags::TEXTURED | shader_flags::CORNERS[i],
-                                        radius: [0.0; 4],
-                                        border: [0.0; 4],
-                                        size: rect_size.into(),
-                                        point: [0.0; 2],
-                                    });
-                                }
-
-                                for &i in &QUAD_INDICES {
-                                    ui_meta.indices.push(indices_index + i as u32);
-                                }
-
-                                vertices_index += 6;
-                                indices_index += 4;
-                            }
-                        }
                     }
-                    existing_batch.unwrap().1.range.end = vertices_index;
-                    ui_phase.items[batch_item_index].batch_range_mut().end += 1;
-                } else {
-                    batch_image_handle = AssetId::invalid();
                 }
+                existing_batch.unwrap().1.range.end = vertices_index;
+                ui_phase.items[batch_item_index].batch_range_mut().end += 1;
             }
         }
 
