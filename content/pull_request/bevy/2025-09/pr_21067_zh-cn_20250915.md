+++
title = "#21067 Run release exporter in ci"
date = "2025-09-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-09/pr-21067-en-20250915" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-09/pr-21067-zh-cn-20250915" }}
+++

# Run release exporter in ci

## 基本信息
- **标题**: Run release exporter in ci  
- **PR链接**: https://github.com/bevyengine/bevy/pull/21067  
- **作者**: mockersf  
- **状态**: 已合并  
- **标签**: C-Feature, A-Build-System, S-Ready-For-Final-Review, D-Straightforward  
- **创建时间**: 2025-09-15T21:06:09Z  
- **合并时间**: 2025-09-15T22:26:18Z  
- **合并者**: alice-i-cecile  

## 描述翻译
**目标**
- 让添加了无法解析的发布内容的PR失败

**解决方案**
- 给导出工具添加检查模式
- 在CI中运行它

**测试**
- 在 https://github.com/bevyengine/bevy/pull/21065 合并之前，这个PR应该会失败

## 这个PR的故事

这个PR解决了一个实际的工程问题：确保Bevy项目的发布内容（release notes和migration guides）在合并前格式正确且可解析。在之前的流程中，如果有人提交了格式错误的发布内容，这个问题可能直到实际发布时才会被发现，导致发布流程中断。

问题的核心在于需要一个自动化检查机制。开发者采取了务实的方法：复用现有的导出工具(`export-content`)，为其添加一个轻量级的检查模式，然后在CI流水线中集成这个检查。

从实现上看，这个方案体现了良好的软件工程实践。首先在`app.rs`中进行了代码重构，将内容加载逻辑提取到独立的`Content`结构体中：

```rust
// File: tools/export-content/src/app.rs
// 重构前:
impl App {
    pub fn new() -> Result<App> {
        let exe_dir = env::current_exe()...;
        let content_dir = exe_dir.join("../../content");
        // 直接加载内容的逻辑...
    }
}

// 重构后:
pub struct Content {
    content_dir: PathBuf,
    migration_guides: Vec<Entry>,
    release_notes: Vec<Entry>,
}

impl Content {
    pub fn load() -> Result<Self> {
        // 独立的内容加载逻辑
    }
}

impl App {
    pub fn new() -> Result<App> {
        let Content { content_dir, release_notes, migration_guides } = Content::load()?;
        // 使用已加载的内容初始化UI
    }
}
```

这种重构实现了关注点分离 - `Content`结构体负责纯粹的内容加载和解析，而`App`结构体专注于UI展示。这使得同一个加载逻辑可以在交互式模式和CI检查模式中共享。

然后在`main.rs`中添加了简单的命令行参数解析：

```rust
// File: tools/export-content/src/main.rs
// 新增的检查模式:
fn main() -> Result<()> {
    let check = std::env::args().any(|arg| arg == "--check");
    if check {
        Content::load().unwrap();
        return Ok(());
    }
    // 原有的交互式模式逻辑...
}
```

最后在CI配置中添加了相应的检查任务：

```yaml
# File: .github/workflows/ci.yml
# 新增的CI任务:
check-release-content:
  runs-on: ubuntu-latest
  timeout-minutes: 30
  steps:
    - uses: actions/checkout@v5
    - uses: dtolnay/rust-toolchain@stable
    - name: Check Release Content
      shell: bash
      run: |
        cargo run --package export-content -- --check
```

这个设计的巧妙之处在于其简洁性和复用性。没有创建新的工具或复杂的配置，而是通过最小化的改动扩展了现有工具的功能。检查模式本质上只是运行内容加载逻辑并在遇到解析错误时返回非零退出码，这正是CI系统所需的。

从技术角度看，这个实现展示了几个值得注意的模式：
1. **单一职责原则**：通过重构将内容加载与UI展示分离
2. **命令行工具设计**：通过简单的参数切换不同操作模式
3. **CI集成**：利用标准的退出码机制与CI系统交互

这个改动的影响很直接：现在任何包含格式错误发布内容的PR都会在CI阶段失败，从而提前发现问题，避免影响发布流程。这是一个典型的防御性编程实践，通过自动化检查来保证代码库质量。

## 可视化表示

```mermaid
graph TD
    A[CI Workflow] --> B[check-release-content job]
    B --> C[cargo run --package export-content -- --check]
    C --> D[Content::load()]
    D --> E[解析release notes]
    D --> F[解析migration guides]
    E --> G[验证格式正确性]
    F --> G
    G --> H{解析成功?}
    H -->|是| I[退出码: 0]
    H -->|否| J[退出码: 1]
    J --> K[CI任务失败]
```

## 关键文件变更

**tools/export-content/src/app.rs** (+26/-5)
- 重构内容加载逻辑，提取到独立的`Content`结构体
- 实现内容加载与UI展示的关注点分离

```rust
// 关键变更: 新增Content结构体
pub struct Content {
    content_dir: PathBuf,
    migration_guides: Vec<Entry>,
    release_notes: Vec<Entry>,
}

impl Content {
    pub fn load() -> Result<Self> {
        // 独立的内容加载逻辑
    }
}
```

**.github/workflows/ci.yml** (+11/-0)
- 添加新的CI任务来检查发布内容格式
- 使用稳定的Rust工具链运行检查

```yaml
check-release-content:
  runs-on: ubuntu-latest
  timeout-minutes: 30
  steps:
    - uses: actions/checkout@v5
    - uses: dtolnay/rust-toolchain@stable
    - name: Check Release Content
      shell: bash
      run: |
        cargo run --package export-content -- --check
```

**tools/export-content/src/main.rs** (+8/-0)
- 添加命令行参数解析支持`--check`标志
- 在检查模式下只验证内容而不启动UI

```rust
// 新增检查模式逻辑
let check = std::env::args().any(|arg| arg == "--check");
if check {
    Content::load().unwrap();
    return Ok(());
}
```

## 扩展阅读

- [GitHub Actions 官方文档](https://docs.github.com/en/actions) - 深入了解CI/CD工作流配置
- [Rust 命令行参数解析最佳实践](https://rust-cli.github.io/book/) - 学习更复杂的CLI工具开发
- [Bevy 引擎内容管理系统](https://github.com/bevyengine/bevy/tree/main/content) - 了解发布内容的具体格式和结构