+++
title = "#20940 add reflection serialization example"
date = "2025-09-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-09/pr-20940-en-20250909" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-09/pr-20940-zh-cn-20250909" }}
labels = ["C-Examples", "A-Reflection"]
+++

# Title
add reflection serialization example

## Basic Information
- **Title**: add reflection serialization example
- **PR Link**: https://github.com/bevyengine/bevy/pull/20940
- **Author**: ChristopherBiscardi
- **Status**: MERGED
- **Labels**: C-Examples, S-Ready-For-Final-Review, A-Reflection
- **Created**: 2025-09-09T19:09:21Z
- **Merged**: 2025-09-09T22:51:37Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

It is a very common[0] misconception that serde's Serialize/Deserialize derives are required for reflection (de)serialization. This is not true, and can lead to unexpectedly changing the serialization behavior in a way that doesn't get exposed via reflection information. Having an example to point to would be a useful resource when talking about this.

[0]: This is why Avian has Serialize/Deserialize on all types, including marker types; This also cropped up in PRs to new BRP functionality.

## Solution

Implement an example showing deserialization and serialization for a type that only implements `Reflect`, and not serde's `Serialize` or `Deserialize`.

## Testing

```
cargo run --example serialization
2025-09-09T19:08:28.258523Z  INFO serialization: reflect_value=DynamicStruct(serialization::Player { health: 50, name: "BevyPlayerOne" })
2025-09-09T19:08:28.258770Z  INFO serialization: player=serialization::Player { name: "BevyPlayerOne", health: 50 }
2025-09-09T19:08:28.259382Z  INFO serialization: json="{\"serialization::Player\":{\"name\":\"BevyPlayerSerialize\",\"health\":80}}"
```

## The Story of This Pull Request

This PR addresses a common misconception in the Bevy ecosystem regarding reflection-based serialization. Many developers incorrectly believe that serde's `Serialize` and `Deserialize` traits are required for (de)serialization when working with reflected types. This misunderstanding can lead to unintended serialization behavior changes that aren't exposed through reflection metadata.

The solution implements a clear, practical example demonstrating how Bevy's reflection system enables serialization and deserialization without requiring serde's traits. The example shows a `Player` struct that only derives `Reflect`, not serde's traits, and demonstrates both serialization to JSON and deserialization from JSON using Bevy's reflection utilities.

The implementation uses two key components from Bevy's reflection system:
1. `ReflectDeserializer` for converting JSON data into dynamic reflected values
2. `ReflectSerializer` for converting reflected values back to JSON

The example also demonstrates how to convert between dynamic reflected values and concrete types using `ReflectFromReflect`, showing the complete round-trip workflow from JSON → dynamic reflection → concrete type → JSON.

This approach provides several benefits:
- Clarifies that serde traits are optional for reflection-based serialization
- Demonstrates proper use of Bevy's reflection serialization utilities
- Serves as a reference for developers encountering similar serialization requirements
- Helps prevent accidental coupling to serde's serialization behavior

## Visual Representation

```mermaid
graph LR
    A[JSON Data] --> B[ReflectDeserializer]
    B --> C[Dynamic Reflect Value]
    C --> D[ReflectFromReflect]
    D --> E[Concrete Type]
    E --> F[ReflectSerializer]
    F --> G[JSON Output]
```

## Key Files Changed

### examples/reflection/serialization.rs (+75/-0)
This new example file demonstrates reflection-based serialization without serde traits:

```rust
//! Illustrates how "reflection" serialization works in Bevy.
//!
//! Deriving `Reflect` will also register `SerializationData`,
//! which powers reflect (de)serialization.
//! Serializing reflected data *does not* require deriving serde's
//! Serialize and Deserialize implementations.

use bevy::{
    prelude::*,
    reflect::serde::{ReflectDeserializer, ReflectSerializer},
};
use serde::de::DeserializeSeed;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, (deserialize, serialize).chain())
        .run();
}

/// Deriving `Reflect` includes reflecting `SerializationData`
#[derive(Reflect)]
pub struct Player {
    name: String,
    health: u32,
}

const PLAYER_JSON: &str = r#"{
    "serialization::Player": {
        "name": "BevyPlayerOne",
        "health": 50
    }
}"#;

fn deserialize(type_registry: Res<AppTypeRegistry>) {
    let type_registry = type_registry.read();

    // a serde_json::Value that might have come from an API
    let value: serde_json::Value = serde_json::from_str(PLAYER_JSON).unwrap();

    // alternatively, `TypedReflectDeserializer` can be used if the type
    // is known.
    let deserializer = ReflectDeserializer::new(&type_registry);
    // deserialize
    let reflect_value = deserializer.deserialize(value).unwrap();
    // If Player implemented additional functionality, like Component,
    // this reflect_value could be used with commands.insert_reflect
    info!(?reflect_value);

    // `FromReflect` and `ReflectFromReflect` can yield a concrete value.
    let type_id = reflect_value.get_represented_type_info().unwrap().type_id();
    let reflect_from_reflect = type_registry
        .get_type_data::<ReflectFromReflect>(type_id)
        .unwrap();
    let player: Box<dyn Reflect> = reflect_from_reflect
        .from_reflect(reflect_value.as_partial_reflect())
        .unwrap();
    info!(?player);
}

fn serialize(type_registry: Res<AppTypeRegistry>) {
    let type_registry = type_registry.read();

    // a concrete value
    let value = Player {
        name: "BevyPlayerSerialize".to_string(),
        health: 80,
    };

    // By default, all derived `Reflect` types can be serialized using serde. No need to derive
    // Serialize!
    let serializer = ReflectSerializer::new(&value, &type_registry);
    let json = serde_json::to_string(&serializer).unwrap();
    info!(?json);
}
```

### Cargo.toml (+11/-0)
Added the new example to the project configuration:

```toml
[[example]]
name = "serialization"
path = "examples/reflection/serialization.rs"
doc-scrape-examples = true

[package.metadata.example.serialization]
name = "Serialization"
description = "Demonstrates serialization and deserialization using reflection without serde's Serialize/Deserialize traits"
category = "Reflection"
wasm = false
```

### examples/README.md (+1/-0)
Added documentation reference for the new example:

```markdown
[Serialization](../examples/reflection/serialization.rs) | Demonstrates serialization and deserialization using reflection without serde's Serialize/Deserialize traits
```

## Further Reading

- [Bevy Reflection Documentation](https://docs.rs/bevy/latest/bevy/reflect/index.html)
- [Serde Integration in Bevy Reflection](https://docs.rs/bevy/latest/bevy/reflect/serde/index.html)
- [Reflect Trait Documentation](https://docs.rs/bevy/latest/bevy/reflect/trait.Reflect.html)
- [FromReflect Trait Documentation](https://docs.rs/bevy/latest/bevy/reflect/trait.FromReflect.html)