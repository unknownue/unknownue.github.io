diff --git a/crates/bevy_time/src/virt.rs b/crates/bevy_time/src/virt.rs
index 146c754891859..45fa4c23eb987 100644
--- a/crates/bevy_time/src/virt.rs
+++ b/crates/bevy_time/src/virt.rs
@@ -20,8 +20,9 @@ use crate::{real::Real, time::Time};
 /// in order to prevent unexpected behavior in cases where updates do not happen
 /// at regular intervals (e.g. coming back after the program was suspended a long time).
 ///
-/// The virtual clock can be paused by calling [`pause()`](Time::pause) and
-/// unpaused by calling [`unpause()`](Time::unpause). When the game clock is
+/// The virtual clock can be paused by calling [`pause()`](Time::pause),
+/// unpaused by calling [`unpause()`](Time::unpause), or toggled by calling
+/// [`toggle()`](Time::toggle). When the game clock is
 /// paused [`delta()`](Time::delta) will be zero on each update, and
 /// [`elapsed()`](Time::elapsed) will not grow.
 /// [`effective_speed()`](Time::effective_speed) will return `0.0`. Calling
@@ -203,13 +204,19 @@ impl Time<Virtual> {
         self.context_mut().relative_speed = ratio;
     }
 
+    /// Stops the clock if it is running, otherwise resumes the clock.
+    #[inline]
+    pub fn toggle(&mut self) {
+        self.context_mut().paused ^= true;
+    }
+
     /// Stops the clock, preventing it from advancing until resumed.
     #[inline]
     pub fn pause(&mut self) {
         self.context_mut().paused = true;
     }
 
-    /// Resumes the clock if paused.
+    /// Resumes the clock.
     #[inline]
     pub fn unpause(&mut self) {
         self.context_mut().paused = false;
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 6449b40d2bb66..0eb6aa0514abd 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -224,11 +224,7 @@ fn add_raytracing_meshes_on_scene_load(
 
 fn pause_scene(mut time: ResMut<Time<Virtual>>, key_input: Res<ButtonInput<KeyCode>>) {
     if key_input.just_pressed(KeyCode::Space) {
-        if time.is_paused() {
-            time.unpause();
-        } else {
-            time.pause();
-        }
+        time.toggle();
     }
 }
 
diff --git a/examples/time/virtual_time.rs b/examples/time/virtual_time.rs
index c9c6bd112b65a..55343cfe9ee5a 100644
--- a/examples/time/virtual_time.rs
+++ b/examples/time/virtual_time.rs
@@ -21,7 +21,7 @@ fn main() {
                 change_time_speed::<1>.run_if(input_just_pressed(KeyCode::ArrowUp)),
                 change_time_speed::<-1>.run_if(input_just_pressed(KeyCode::ArrowDown)),
                 (update_virtual_time_info_text, update_real_time_info_text)
-                    // update the texts on a timer to make them more readable
+                    // update the texts on a timer to make them more readable.
                     // `on_timer` run condition uses `Virtual` time meaning it's scaled
                     // and would result in the UI updating at different intervals based
                     // on `Time<Virtual>::relative_speed` and `Time<Virtual>::is_paused()`
@@ -96,7 +96,7 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>, mut time: ResMu
                 RealTime,
             ),
             (
-                Text::new("CONTROLS\nUn/Pause: Space\nSpeed+: Up\nSpeed-: Down"),
+                Text::new("CONTROLS\n(Un)pause: Space\nSpeed+: Up\nSpeed-: Down"),
                 TextFont {
                     font_size,
                     ..default()
@@ -163,13 +163,9 @@ fn change_time_speed<const DELTA: i8>(mut time: ResMut<Time<Virtual>>) {
     time.set_relative_speed(time_speed);
 }
 
-/// pause or resume `Relative` time
+/// Pause or resume `Relative` time
 fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
-    if time.is_paused() {
-        time.unpause();
-    } else {
-        time.pause();
-    }
+    time.toggle();
 }
 
 /// Update the `Real` time info text
