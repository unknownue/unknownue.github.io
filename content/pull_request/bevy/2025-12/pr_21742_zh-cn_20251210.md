+++
title = "#21742 Change a function system to be exclusive"
date = "2025-12-10T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21742-en-20251210" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21742-zh-cn-20251210" }}
+++

# Title

## 基本信息
- **标题**: Change a function system to be exclusive
- **PR 链接**: https://github.com/bevyengine/bevy/pull/21742
- **作者**: hymm
- **状态**: 已合并
- **标签**: C-Feature, A-ECS, S-Ready-For-Final-Review, X-Contentious
- **创建时间**: 2025-11-04T22:37:20Z
- **合并时间**: 2025-12-09T23:50:10Z
- **合并者**: alice-i-cecile

## 描述翻译

# 目标
- 我正在尝试使用一个将多个系统组合成一个可调度系统的库，但当时没有一种方法来将一个函数系统（function system）标记为独占运行。

## 解决方案
- 在 `SystemMeta` 中添加一个方法来设置独占标志。请注意，这个 PR 没有添加任何简单设置此标志的方法。你必须创建一个自定义的系统参数（system param）才能设置它。
- 添加一个系统参数来标记一个函数系统为独占运行。

## 测试
- 尚未测试。唯一担心的是它与执行器（executor）如何交互，但理论上这应该可以工作，因为标志是执行器判断系统是否独占的唯一方式。

## 这个 Pull Request 的故事

这个 PR 始于一个具体且实用的开发需求。作者 `hymm` 正在尝试使用一个库，该库的目标是将多个系统组合成一个单一的系统，以便进行调度。在这个过程中，他发现现有的 Bevy ECS 框架缺少一个关键功能：无法将一个普通的函数系统标记为“独占系统（exclusive system）”。

在 Bevy 的 ECS 架构中，系统（System）是执行逻辑的基本单元。默认情况下，多个系统可以并行运行，只要它们访问的 World 数据不冲突（即满足数据并行性）。然而，有些操作需要独占访问整个 World，例如执行需要原子性保证的复杂世界操作，或者加载/卸载资源。为此，Bevy 提供了“独占系统”的概念，它要求调度器（scheduler）在运行时不允许任何其他系统同时执行。通常，独占系统是通过实现 `ExclusiveSystem` trait 来创建的，但这通常涉及更复杂的手动系统状态管理。

作者遇到的瓶颈是：当他尝试通过高阶系统组合（例如使用第三方库）来动态创建系统时，他需要一种方式，能够将组合产生的最终函数系统标记为独占的。现有的 API 没有提供直接从函数系统定义内部将其标记为独占的途径。

**解决方案的核心思路**是巧妙地利用现有的系统参数（SystemParam）机制。在 Bevy 中，系统函数的参数会被自动推导为系统参数，每个参数类型在系统初始化时都会有机会配置系统的元数据（SystemMeta）。因此，解决方案是引入一个新的、零开销的标记类型（marker type）作为系统参数。当这个类型出现在系统函数的签名中时，它会在系统初始化阶段将系统标记为独占。

具体实现分为两步：
1.  在 `SystemMeta` 中添加一个公开的 `set_exclusive` 方法，用于设置内部的 `EXCLUSIVE` 标志位。
2.  创建一个新的 `ExclusiveMarker` 系统参数类型。其 `init_access` 方法的实现就是调用 `system_meta.set_exclusive()`。

这个设计的巧妙之处在于其非侵入性和一致性。它没有修改函数系统（`FunctionSystem`）本身的任何构建逻辑，也没有增加新的 trait 或复杂的配置选项。它完全复用现有的、开发者已经熟悉的“通过函数参数声明系统行为”的模式。例如，使用 `ResMut` 参数会自动为系统添加对资源的可变访问，而使用 `ExclusiveMarker` 则自动将系统标记为独占。这使得 API 非常直观。

从技术实现细节来看，`ExclusiveMarker` 本身是一个空结构体，包含一个 `PhantomData` 以满足类型约束。它实现了 `SystemParam` trait，但其 `get_param` 方法返回的实例不包含任何实际数据，因此运行时开销为零。同时，因为它不读取任何世界（World）状态，所以也安全地实现了 `ReadOnlySystemParam` trait。这与另一个类似的标记类型 `NonSendMarker`（用于强制系统在主线程运行）的设计模式是一致的。

这个改动的影响是直接的：现在，任何第三方库或高级系统组合工具，只要能在最终生成的系统函数签名中插入 `ExclusiveMarker` 参数，就可以创建出行为正确的独占系统。这为 Bevy 生态中更灵活、更强大的系统组合模式打开了大门。

不过，正如作者在描述中指出的，这个 PR 只提供了底层机制，并没有提供一个“简单”的包装器或宏来方便地设置它。要使用这个功能，开发者需要理解系统参数的工作原理，并手动将 `ExclusiveMarker` 添加到函数签名中。这体现了 Bevy 项目“提供底层构建块”的哲学，更高级的语法糖可以留给社区或后续的 PR 来实现。

## 可视化关系图

```mermaid
graph TD
    A[开发者需求: 组合库创建独占系统] --> B{缺少标记函数系统为独占的API}
    B --> C[解决方案: 新增 ExclusiveMarker 系统参数]
    C --> D[实现 SystemParam for ExclusiveMarker]
    D --> E[在 init_access 中调用 system_meta.set_exclusive()]
    E --> F[系统被标记 SystemStateFlags::EXCLUSIVE]
    F --> G[调度器识别并独占执行该系统]
    C -.-> H[复用现有模式<br/>如 ResMut, NonSendMarker]
    H --> D
```

## 关键文件更改

1.  `crates/bevy_ecs/src/system/system_param.rs` (+34/-0)
    - **目的**：定义新的 `ExclusiveMarker` 系统参数类型，作为标记函数系统为独占运行的手段。
    - **关键代码**：
      ```rust
      /// A dummy type to tell the executor to run the system exclusively.
      pub struct ExclusiveMarker(PhantomData<()>);

      // SAFETY: No world access.
      unsafe impl SystemParam for ExclusiveMarker {
          type State = ();
          type Item<'w, 's> = Self;

          #[inline]
          fn init_state(_world: &mut World) -> Self::State {}

          fn init_access(
              _state: &Self::State,
              system_meta: &mut SystemMeta,
              _component_access_set: &mut FilteredAccessSet,
              _world: &mut World,
          ) {
              system_meta.set_exclusive(); // 关键调用：设置独占标志
          }

          #[inline]
          unsafe fn get_param<'world, 'state>(
              _state: &'state mut Self::State,
              _system_meta: &SystemMeta,
              _world: UnsafeWorldCell<'world>,
              _change_tick: Tick,
          ) -> Self::Item<'world, 'state> {
              Self(PhantomData) // 零开销，仅返回标记实例
          }
      }

      // SAFETY: Does not read any world state
      unsafe impl ReadOnlySystemParam for ExclusiveMarker {}
      ```

2.  `crates/bevy_ecs/src/system/function_system.rs` (+5/-0)
    - **目的**：在 `SystemMeta` 中提供设置独占标志的公开方法。
    - **关键代码**：
      ```rust
      impl SystemMeta {
          // ... 其他方法 ...

          /// Mark the system to run exclusively. i.e. no other systems will run at the same time.
          pub fn set_exclusive(&mut self) {
              self.flags |= SystemStateFlags::EXCLUSIVE; // 设置标志位
          }
      }
      ```

3.  `crates/bevy_ecs/src/system/mod.rs` (+20/-2)
    - **目的**：1) 导出新类型 `ExclusiveMarker`；2) 添加集成测试验证功能。
    - **关键更改**：
        - **导出**：在 `system` 模块的导出列表中添加了 `ExclusiveMarker`。
        - **测试**：添加了 `function_system_as_exclusive` 测试用例，演示了如何使用 `ExclusiveMarker`，并验证了系统被正确标记为独占。
        ```rust
        #[test]
        fn function_system_as_exclusive() {
            let mut world = World::default();
            world.insert_resource(SystemRan::No);

            // 系统函数通过参数声明需要独占运行
            fn sys(_marker: ExclusiveMarker, mut system_ran: ResMut<SystemRan>) {
                *system_ran = SystemRan::Yes;
            }

            let mut sys = IntoSystem::into_system(sys);
            sys.initialize(&mut world);
            assert!(sys.is_exclusive()); // 验证系统已被标记为独占

            run_system(&mut world, sys);
            assert_eq!(*world.resource::<SystemRan>(), SystemRan::Yes);
        }
        ```

## 延伸阅读

1.  **Bevy 官方文档 - 系统 (Systems)**: 了解 Bevy ECS 中系统的基本概念、系统参数和系统调度。
    - 链接：https://bevy-cheatbook.github.io/programming/systems.html
2.  **Bevy 官方文档 - 独占系统 (Exclusive Systems)**: 深入了解独占系统的设计原理、使用场景以及与普通系统的区别。
    - 链接：https://bevy-cheatbook.github.io/programming/exclusive.html
3.  **Rust 中的 PhantomData**: 理解 `PhantomData` 在泛型编程和标记类型中的作用，这对于理解 `ExclusiveMarker` 的实现至关重要。
    - 链接：https://doc.rust-lang.org/std/marker/struct.PhantomData.html
4.  **Bevy `NonSendMarker` 源码**: 研究另一个类似的标记类型 `NonSendMarker`，可以更好地理解 Bevy 中利用系统参数来配置系统行为的模式。
    - 文件：`crates/bevy_ecs/src/system/system_param.rs` (位于 `ExclusiveMarker` 实现下方)

# 完整代码差异
<details>
<summary>点击展开/折叠完整差异</summary>

```diff
diff --git a/crates/bevy_ecs/src/system/function_system.rs b/crates/bevy_ecs/src/system/function_system.rs
index 5f6653be39834..4aeb704ecf9f2 100644
--- a/crates/bevy_ecs/src/system/function_system.rs
+++ b/crates/bevy_ecs/src/system/function_system.rs
@@ -105,6 +105,11 @@ impl SystemMeta {
     pub fn set_has_deferred(&mut self) {
         self.flags |= SystemStateFlags::DEFERRED;
     }
+
+    /// Mark the system to run exclusively. i.e. no other systems will run at the same time.
+    pub fn set_exclusive(&mut self) {
+        self.flags |= SystemStateFlags::EXCLUSIVE;
+    }
 }
 
 // TODO: Actually use this in FunctionSystem. We should probably only do this once Systems are constructed using a World reference
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index eeecf4b7ac5db..f729731ea327a 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -418,8 +418,8 @@ mod tests {
             SystemCondition,
         },
         system::{
-            Commands, In, InMut, IntoSystem, Local, NonSend, NonSendMut, ParamSet, Query, Res,
-            ResMut, Single, StaticSystemParam, System, SystemState,
+            Commands, ExclusiveMarker, In, InMut, IntoSystem, Local, NonSend, NonSendMut, ParamSet,
+            Query, Res, ResMut, Single, StaticSystemParam, System, SystemState,
         },
         world::{DeferredWorld, EntityMut, FromWorld, World},
     };
@@ -1049,6 +1049,24 @@ mod tests {
         assert_eq!(*world.resource::<SystemRan>(), SystemRan::Yes);
     }
 
+    #[test]
+    fn function_system_as_exclusive() {
+        let mut world = World::default();
+
+        world.insert_resource(SystemRan::No);
+
+        fn sys(_marker: ExclusiveMarker, mut system_ran: ResMut<SystemRan>) {
+            *system_ran = SystemRan::Yes;
+        }
+
+        let mut sys = IntoSystem::into_system(sys);
+        sys.initialize(&mut world);
+        assert!(sys.is_exclusive());
+
+        run_system(&mut world, sys);
+        assert_eq!(*world.resource::<SystemRan>(), SystemRan::Yes);
+    }
+
     #[test]
     fn removal_tracking() {
         let mut world = World::new();
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index 8e99259149b67..bc58aa7d85b94 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -1309,6 +1309,40 @@ unsafe impl<T: SystemBuffer> SystemParam for Deferred<'_, T> {
     }
 }
 
+/// A dummy type to tell the executor to run the system exclusively.
+pub struct ExclusiveMarker(PhantomData<()>);
+
+// SAFETY: No world access.
+unsafe impl SystemParam for ExclusiveMarker {
+    type State = ();
+    type Item<'w, 's> = Self;
+
+    #[inline]
+    fn init_state(_world: &mut World) -> Self::State {}
+
+    fn init_access(
+        _state: &Self::State,
+        system_meta: &mut SystemMeta,
+        _component_access_set: &mut FilteredAccessSet,
+        _world: &mut World,
+    ) {
+        system_meta.set_exclusive();
+    }
+
+    #[inline]
+    unsafe fn get_param<'world, 'state>(
+        _state: &'state mut Self::State,
+        _system_meta: &SystemMeta,
+        _world: UnsafeWorldCell<'world>,
+        _change_tick: Tick,
+    ) -> Self::Item<'world, 'state> {
+        Self(PhantomData)
+    }
+}
+
+// SAFETY: Does not read any world state
+unsafe impl ReadOnlySystemParam for ExclusiveMarker {}
+
 /// A dummy type that is [`!Send`](Send), to force systems to run on the main thread.
 pub struct NonSendMarker(PhantomData<*mut ()>);
 
```
</details>