+++
title = "#22254 Make sure swapchain texture views are dropped."
date = "2025-12-26T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22254-en-20251226" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22254-zh-cn-20251226" }}
+++

# Title

## 基本信息
- **标题**: Make sure swapchain texture views are dropped.
- **PR链接**: https://github.com/bevyengine/bevy/pull/22254
- **作者**: tychedelia
- **状态**: 已合并 (MERGED)
- **标签**: A-Rendering, P-Crash, S-Ready-For-Final-Review, P-Regression
- **创建时间**: 2025-12-24T04:43:33Z
- **合并时间**: 2025-12-26T21:57:52Z
- **合并者**: james7132

## 描述翻译

修复 https://github.com/bevyengine/bevy/issues/22225

取代了 https://github.com/bevyengine/bevy/pull/22242，代码量更少。

由于目前无法访问软件渲染器，尚未进行测试。

## 此 Pull Request 的故事

这个 PR 的故事始于一个回归性崩溃（regression crash），其根本原因与渲染管线中一种关键资源的生命周期管理不当有关。具体来说，当用户调整游戏窗口大小或更改显示模式时，Bevy 的渲染器未能正确销毁旧的 swapchain 纹理视图（swapchain texture view），导致底层的图形 API（wgpu）在后续操作中抛出验证错误，最终引发应用程序崩溃。

### 问题与背景

问题的核心在于窗口大小或呈现模式（`PresentMode`）发生变化时的资源清理逻辑。在图形渲染中，swapchain 是一系列缓冲区，用于在屏幕上显示图像。当窗口被调整大小时，必须重新创建整个 swapchain，包括其关联的纹理和纹理视图。如果旧的纹理视图没有被显式地释放（dropped），它们会继续持有对底层 GPU 资源的引用，当 wgpu 尝试在后续帧中使用新创建的资源时，会因为检测到旧资源仍然“存活”而产生冲突，触发安全性和验证检查，最终导致崩溃。

问题 #22225 报告了在特定条件下（例如使用软件渲染器 wgpu 后端）会发生这种崩溃。这是一个回归问题，意味着之前可以正常工作的功能被新引入的更改破坏了，因此被标记为高优先级（P-Crash, P-Regression）。

### 解决方案的思路

为了解决这个问题，我们需要确保在窗口配置发生变化时，所有引用到旧 swapchain 资源的组件都能被及时清理。之前的一个尝试（PR #22242）已经识别了这个问题，但当前 PR 的作者 tychedelia 提出了一个更简洁、侵入性更小的解决方案。

该方案的核心逻辑是：在渲染系统安排中，插入一个专门的清理步骤。这个步骤会在创建新的 surface 和 swapchain（`create_surfaces` 系统）*之前*运行。它会检查所有带有 `ViewTarget` 组件的相机（`Camera`），如果这些相机所关联的窗口（`Window`）的尺寸或呈现模式发生了变化，就主动移除该相机上的 `ViewTarget` 组件。

移除 `ViewTarget` 组件是关键。`ViewTarget` 内部持有了对 swapchain 纹理视图的引用。移除这个组件会触发 Bevy 的 ECS（实体组件系统）机制，导致 `ViewTarget` 被丢弃（drop）。在其 `Drop` 实现中，它会释放其内部持有的 `TextureView` 资源。这样，在 `create_surfaces` 系统为窗口创建全新的 swapchain 纹理时，旧的视图资源已经被清理干净，避免了资源冲突。

### 实现细节

实现主要分为两部分，分别在两个文件中进行。

**第一部分：在视图管理系统中添加清理逻辑 (`crates/bevy_render/src/view/mod.rs`)**

首先，在 `ViewPlugin` 的 `build` 函数中，一个新的系统 `cleanup_view_targets_for_resize` 被添加到渲染系统集（`RenderSystems::ManageViews`）中。重要的是，它的执行顺序被设定在 `create_surfaces` 系统*之前*。这确保了清理操作发生在创建新资源之前。

```rust
// 文件：crates/bevy_render/src/view/mod.rs
// 系统调度部分
cleanup_view_targets_for_resize
    .in_set(RenderSystems::ManageViews)
    .before(create_surfaces),
```

接下来，实现了该系统函数本身：
```rust
pub fn cleanup_view_targets_for_resize(
    mut commands: Commands,
    windows: Res<ExtractedWindows>,
    cameras: Query<(Entity, &ExtractedCamera), With<ViewTarget>>,
) {
    for (entity, camera) in &cameras {
        if let Some(NormalizedRenderTarget::Window(window_ref)) = &camera.target
            && let Some(window) = windows.get(&window_ref.entity())
            && (window.size_changed || window.present_mode_changed)
        {
            commands.entity(entity).remove::<ViewTarget>();
        }
    }
}
```
该系统的工作原理如下：
1.  它查询所有**拥有** `ViewTarget` 组件的实体，并获取其 `Entity` 标识符和 `ExtractedCamera` 数据。
2.  对于每个这样的相机，它检查其渲染目标（`camera.target`）是否是一个窗口（`NormalizedRenderTarget::Window`）。
3.  如果是，则通过 `window_ref` 找到对应的 `ExtractedWindow` 资源。
4.  检查该窗口的 `size_changed` 或 `present_mode_changed` 标志是否为 `true`。这些标志由窗口管理系统在检测到变化时设置。
5.  如果任一标志为真，说明窗口的渲染基础已改变。此时，系统使用 `commands.entity(entity).remove::<ViewTarget>()` 来安排移除该相机实体上的 `ViewTarget` 组件。

**第二部分：增强现有的 Surface 创建逻辑 (`crates/bevy_render/src/view/window/mod.rs`)**

尽管移除 `ViewTarget` 组件会间接导致其持有的 `TextureView` 被丢弃，但为了确保万无一失（正如代码注释所说，“to be safe”），作者在 `create_surfaces` 函数中增加了一行显式的清理代码。

```rust
// 文件：crates/bevy_render/src/view/window/mod.rs
// 在 create_surfaces 函数中，准备重建 swapchain 之前：
// normally this is dropped on present but we double check here to be safe as failure to
// drop it will cause validation errors in wgpu
drop(window.swap_chain_texture.take());
drop(window.swap_chain_texture_view.take()); // <-- 新增的一行
```
这里，`window.swap_chain_texture_view` 是一个 `Option<TextureView>`。调用 `.take()` 会取出 `Option` 中的值（如果存在），并在原位置留下 `None`。取出的值如果没有被其他变量持有，会立刻离开作用域并被丢弃（drop）。这行代码直接确保了存储在 `ExtractedWindow` 结构体中的纹理视图引用被立即释放，与 swapchain 纹理本身的处理方式保持一致。

### 技术洞察

这个 PR 展示了在实时图形编程中管理资源生命周期的一个经典模式：**显式销毁先于重新创建**。当 GPU 资源的配置（如尺寸、格式）发生变更时，不能简单地用新资源覆盖旧句柄，必须遵循“销毁 -> 创建”的顺序。

1.  **基于 ECS 的响应式清理**：解决方案巧妙地利用了 ECS 的查询和命令机制。它不是去追踪每个具体的纹理视图，而是追踪持有这些视图的**组件**（`ViewTarget`）。当窗口状态变化时，通过移除组件来触发资源的释放。这种方式与 Bevy 的数据驱动架构风格高度一致。
2.  **防御性编程**：在 `create_surfaces` 中添加的显式 `drop` 调用是一种防御性编程实践。虽然理论上 `ViewTarget` 的移除应该已经处理了问题，但在资源管理的关键路径上增加一道保险，可以防止因其他未知的代码路径或未来的修改而导致的资源泄漏。
3.  **最小化变更**：与之前的解决方案（PR #22242）相比，这个方案没有引入新的资源类型或复杂的同步逻辑，而是复用现有的状态标志（`size_changed`, `present_mode_changed`）和组件生命周期，实现了更简洁、更不容易出错的修复。这符合软件工程中“最小化修改”的原则。

### 影响

这个修复直接解决了报告中的崩溃问题，恢复了软件渲染器等场景下的窗口调整大小功能的稳定性。从代码库健康度来看，它：
*   **修复了一个严重的回归性缺陷**（P-Crash, P-Regression）。
*   **增强了资源管理的健壮性**，为未来可能引入的类似资源生命周期问题提供了清晰的解决范例。
*   **几乎没有性能开销**：新增的系统只在窗口尺寸或模式实际发生变化时才执行少量逻辑，对每一帧的常规渲染流程没有影响。

此外，这个案例也强调了在图形编程中，尤其是在像 wgpu 这样严格进行验证的现代图形 API 下，对资源生命周期保持警惕的重要性。任何资源泄漏或双重占用都可能导致从性能下降到程序崩溃的严重后果。

## 视觉表示

```mermaid
graph TD
    subgraph “渲染系统调度 (RenderSystems::ManageViews)”
        A[cleanup_view_targets_for_resize] --> B[create_surfaces]
    end
    
    subgraph “cleanup_view_targets_for_resize”
        C[查询所有带 ViewTarget 的相机] --> D{相机目标是否为窗口且窗口状态已变?}
        D -- 是 --> E[命令：移除该相机的 ViewTarget 组件]
        D -- 否 --> F[跳过]
    end
    
    subgraph “create_surfaces”
        G[显式 drop swap_chain_texture_view] --> H[创建新的 Swapchain 和 Surface]
    end
    
    E -.->|导致 ViewTarget 被 Drop| I[释放持有的 TextureView 资源]
    G --> I
    I --> J[wgpu 验证通过，无资源冲突]
    J --> K[成功渲染新帧]
```

## 关键文件变更

### `crates/bevy_render/src/view/mod.rs` (+18/-0)
**变更内容及原因**：此文件添加了一个新的系统 `cleanup_view_targets_for_resize`，并将其注册到渲染插件中。该系统负责在窗口大小或呈现模式改变时，移除相关相机上的 `ViewTarget` 组件，以触发旧的 swapchain 纹理视图资源的释放。

**关键代码片段**：
```rust
// 系统被添加到插件中
cleanup_view_targets_for_resize
    .in_set(RenderSystems::ManageViews)
    .before(create_surfaces),

// 新增的系统函数实现
pub fn cleanup_view_targets_for_resize(
    mut commands: Commands,
    windows: Res<ExtractedWindows>,
    cameras: Query<(Entity, &ExtractedCamera), With<ViewTarget>>,
) {
    for (entity, camera) in &cameras {
        if let Some(NormalizedRenderTarget::Window(window_ref)) = &camera.target
            && let Some(window) = windows.get(&window_ref.entity())
            && (window.size_changed || window.present_mode_changed)
        {
            commands.entity(entity).remove::<ViewTarget>();
        }
    }
}
```
**与 PR 目标的关系**：这是解决方案的核心逻辑，通过响应式地移除组件来管理资源生命周期。

### `crates/bevy_render/src/view/window/mod.rs` (+1/-0)
**变更内容及原因**：在 `create_surfaces` 函数中增加了一行代码，显式丢弃（drop）存储在窗口数据中的 `swap_chain_texture_view`。这是一种防御性措施，确保在重建 swapchain 之前，旧的纹理视图引用被绝对清除。

**关键代码片段**：
```rust
// 在 create_surfaces 函数内部，准备重建配置之前：
// normally this is dropped on present but we double check here to be safe as failure to
// drop it will cause validation errors in wgpu
drop(window.swap_chain_texture.take());
drop(window.swap_chain_texture_view.take()); // 新增行
```
**与 PR 目标的关系**：这是解决方案的补充保障，直接在资源创建点确保旧资源的清理，与主要系统逻辑形成双重保险。

## 扩展阅读

*   **wgpu 资源生命周期**：要深入理解为何不释放资源会导致崩溃，可以阅读 [wgpu 的文档](https://docs.rs/wgpu/latest/wgpu/) 中关于 `Texture`, `TextureView` 以及 Swapchain 管理的部分。理解 wgpu 的“安全”和“验证”层对编写健壮的渲染代码至关重要。
*   **Bevy 渲染架构**：了解 Bevy 的渲染器如何组织系统、资源和阶段，可以参考 [Bevy 官方书籍的渲染章节](https://bevyengine.org/learn/)。特别是关于 `RenderSet`、`Extract` 阶段和 `ViewTarget` 组件的部分。
*   **ECS 模式中的资源管理**：这个 PR 是利用 ECS 模式进行资源生命周期管理的优秀案例。可以研究 Bevy 代码库中其他组件如何实现 `Drop` trait，以及如何利用系统调度顺序来管理复杂的依赖关系。