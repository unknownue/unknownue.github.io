+++
title = "#22295 Solari: More examples, fix emissive"
date = "2025-12-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22295-en-20251230" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22295-zh-cn-20251230" }}
+++

# Solari: More examples, fix emissive

## 基本信息
- **标题**: Solari: More examples, fix emissive
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22295
- **作者**: JMS55
- **状态**: 已合并
- **标签**: C-Bug, A-Rendering, C-Examples, S-Ready-For-Final-Review
- **创建时间**: 2025-12-29T02:28:48Z
- **合并时间**: 2025-12-30T01:56:11Z
- **合并者**: alice-i-cecile

## 描述翻译
* 在 Solari 示例中添加了一个小型性能分析覆盖层，用于计时 Solari 不同 GPU 工作部分的耗时（未添加 DLSS-RR 计时，因为 wgpu timestamp 在当前 wgpu_hal 工作中无法正常工作，我需要单独修复这个问题）。
* 在 Solari 示例中添加了一个多光源压力测试（100 个光源），灵感来自 https://x.com/Roystoncinemo/status/1841917611833229411。目前实用性有限，但这将成为 Solari 0.19 版本的一个重点。
* 修改了发射光照，使其应用曝光，就像 `emissive_exposure_weight` 始终设置为 1.0 一样（StandardMaterial 默认设置为 0.0，我不确定这是否是个好主意，但这是另一个话题）。如果不这样做，发射材质的网格会渲染得异常明亮，以至于溢出纹理并破坏 DLSS-RR。我认为新行为更符合人们的预期，现在也与路径追踪器的结果一致。
<img width="3206" height="1875" alt="image" src="https://github.com/user-attachments/assets/af3990d6-ae2d-4520-a7cd-f04041685152" />

## 本次 Pull Request 的技术叙事

这个 PR 主要解决 Solari 实时渲染系统中的一个具体问题：发射材质（emissive materials）的亮度处理不正确，导致在启用 DLSS 光线重建（Ray Reconstruction）时画面异常。与此同时，作者还添加了两个重要的辅助功能：一个用于性能分析（profiling）的覆盖层，以及一个用于未来性能优化的多光源压力测试场景。

**问题的核心是曝光计算顺序**。在修复之前，发射材质的颜色被直接添加到最终像素颜色中，而这个加法操作发生在乘以曝光值之前。这意味着，无论场景的整体曝光如何调整，发射材质的绝对亮度都不会改变。在 Solari 这种高动态范围（HDR）渲染器中，发射材质的亮度值通常设置得非常高（例如线性空间下的 20000），以模拟真实的光源。如果不应用曝光，这些巨大的值会直接写入渲染目标，导致颜色值远超 1.0（即“溢出”或“clamp”），这不仅破坏了 HDR 效果，还会干扰像 DLSS-RR 这样的后处理技术，因为这些技术依赖于合理的亮度范围来正常工作。

解决方案非常直接：将曝光乘法的步骤移到像素颜色计算的最后。修改发生在两个关键的计算着色器文件中：
1.  `restir_di.wgsl` (直接光照): 将 `pixel_color *= view.exposure;` 移到了 `pixel_color += surface.material.emissive;` 之后。
2.  `restir_gi.wgsl` (间接光照): 同样确保了最终的 `pixel_color` 在包含了发射贡献后乘以曝光。

这个改动在概念上相当于将材质的 `emissive_exposure_weight` 参数强制设为 1.0，确保发射材质与场景中的其他光照一样，响应相机的曝光设置。这使得视觉效果更符合直觉，并与离线路径追踪器（pathtracer）的结果保持一致，为开发者提供了可靠的可视化参考。

除了这个核心修复，PR 还引入了**细粒度的 GPU 性能分析工具**。在 `node.rs` 中，原来单一的 `pass_span` 被替换为多个独立的 `time_span`，分别用于测量 Solari 渲染管线中的不同阶段：
- `presample_light_tiles` (光源图块预采样)
- `world_cache` (世界缓存更新)
- `direct_lighting` (直接光照)
- `diffuse_indirect_lighting` (漫反射间接光照)
- `specular_indirect_lighting` (镜面反射间接光照)

这些计时数据通过 Bevy 的诊断（Diagnostics）系统暴露出来。为了展示这些数据，作者在 `solari.rs` 示例中创建了一个新的 `PerformanceText` UI 组件。该组件在 `update_performance_text` 系统中查询这些诊断路径，并将每个阶段的平均 GPU 耗时（以毫秒为单位）格式化成清晰的文本覆盖层，显示在屏幕右上角。这是一个非常实用的工具，它允许开发者快速识别渲染管线中的性能瓶颈。作者也注明，由于技术限制，DLSS-RR 的计时暂时无法添加。

最后，PR 前瞻性地构建了一个**多光源压力测试场景**（通过 `--many-lights` 命令行参数启用）。`setup_many_lights` 函数使用随机数生成了包含 200 个随机立方体和 100 个高亮度发射材质球体的场景。这个场景的目的是为了极限测试 Solari 在处理大量动态光源时的性能，这是为 Solari 0.19 版本性能优化工作做准备。它模拟了现实游戏中可能出现的复杂光照环境，为后续的算法改进和性能调优提供了基准测试场景。

总而言之，这个 PR 同时处理了渲染正确性、开发者工具和未来性能优化的基础设施。发射光照的修复解决了当前版本的一个渲染错误；性能分析覆盖层为开发者提供了关键的洞察工具；而多光源测试场景则为下一个重大版本的性能冲刺奠定了基础。

## 视觉表示

```mermaid
graph TD
    subgraph “示例/工具增强”
        A[examples/3d/solari.rs] --> B[添加 PerformanceText UI]
        A --> C[添加多光源测试场景 setup_many_lights]
        B --> D[查询 DiagnosticsStore]
    end

    subgraph “核心渲染修复”
        E[crates/bevy_solari/src/realtime/node.rs] --> F[细粒度GPU计时]
        G[crates/bevy_solari/src/realtime/restir_di.wgsl] --> H[调整曝光计算顺序]
        I[crates/bevy_solari/src/realtime/restir_gi.wgsl] --> H
    end

    D --> E
    H --> J[修复发射材质过亮问题]
    C --> K[为性能优化提供基准]
```

## 关键文件更改

- `examples/3d/solari.rs` (+268/-11)
- `crates/bevy_solari/src/realtime/node.rs` (+16/-3)
- `crates/bevy_solari/src/realtime/restir_gi.wgsl` (+12/-5)
- `crates/bevy_solari/src/realtime/restir_di.wgsl` (+1/-1)

1.  **文件**: `examples/3d/solari.rs`
    - **描述**: 这是改动最大的文件，主要新增了两大功能：性能分析文本UI和多光源测试场景的初始化逻辑。同时重构了原有的文本更新逻辑以支持多种文本类型。
    - **关键代码片段 (新增性能文本组件和系统)**:
        ```rust
        #[derive(Component)]
        struct PerformanceText; // 新增组件用于标记性能文本

        fn update_performance_text(
            mut text: Single<&mut Text, With<PerformanceText>>,
            diagnostics: Res<DiagnosticsStore>,
        ) {
            // ... 查询如 "render/solari_lighting/direct_lighting/elapsed_gpu" 等诊断路径
            // 并格式化输出每个阶段的耗时
        }
        ```
    - **关键代码片段 (新增多光源场景设置)**:
        ```rust
        fn setup_many_lights(...) {
            // ... 使用随机数生成器创建平面、200个随机立方体和100个发射材质球体
            for _ in 0..100 {
                commands.spawn((
                    // ...
                    MeshMaterial3d(
                        materials.add(StandardMaterial {
                            emissive: Color::linear_rgb(
                                rng.random::<f32>() * 20000.0, // 高亮度值
                                rng.random::<f32>() * 20000.0,
                                rng.random::<f32>() * 20000.0,
                            )
                            .into(),
                            ..default()
                        }),
                    ),
                    // ...
                ));
            }
        }
        ```
    - **与PR目的的关系**: 直接实现了 PR 描述中提到的“性能分析覆盖层”和“多光源压力测试”。

2.  **文件**: `crates/bevy_solari/src/realtime/node.rs`
    - **描述**: 将原本笼统的 GPU 通道计时拆分为多个细粒度的阶段计时，为性能分析提供数据。
    - **关键代码片段 (修改后)**:
        ```rust
        // 原先只有一个 pass_span
        // let pass_span = diagnostics.pass_span(&mut pass, "solari_lighting");

        // 修改为多个独立的 time_span
        let d = diagnostics.time_span(&mut pass, "solari_lighting/presample_light_tiles");
        pass.set_pipeline(presample_light_tiles_pipeline);
        // ... dispatch work
        d.end(&mut pass); // 结束当前阶段计时

        let d = diagnostics.time_span(&mut pass, "solari_lighting/world_cache");
        // ... 后续阶段类似
        ```
    - **与PR目的的关系**: 为性能分析覆盖层提供底层计时数据源。

3.  **文件**: `crates/bevy_solari/src/realtime/restir_di.wgsl`
    - **描述**: 修正了直接光照着色器中曝光与发射颜色的计算顺序。
    - **关键代码片段 (修改后)**:
        ```rust
        // 修改前：
        // pixel_color *= view.exposure;
        // pixel_color *= brdf;
        // pixel_color += surface.material.emissive;

        // 修改后：
        pixel_color *= brdf;
        pixel_color += surface.material.emissive; // 先加入发射颜色
        pixel_color *= view.exposure;             // 再统一应用曝光
        ```
    - **与PR目的的关系**: 这是修复发射材质过亮问题的核心改动之一。

4.  **文件**: `crates/bevy_solari/src/realtime/restir_gi.wgsl`
    - **描述**: 同样修正了间接光照着色器中的曝光计算顺序，并调整了空间重采样（spatial resampling）中可见性（visibility）计算的逻辑位置，涉及一个关于准确性与稳定性的权衡。
    - **关键代码片段 (曝光修改)**:
        ```rust
        // 发射颜色在 evaluate_diffuse_brdf 等函数中已包含在 surface.material 内
        // 最终 pixel_color 的计算隐含了曝光在最后应用（与 restir_di.wgsl 统一）
        ```
    - **关键代码片段 (空间重采样逻辑调整)**:
        ```rust
        // 修改涉及在 BIASED_RESAMPLING 宏定义下，将可见性追踪移到合并 reservoir 之后再进行存储
        // 这会影响阴影的稳定性和准确性
        combined_reservoir.unbiased_contribution_weight *= trace_point_visibility(...);

        #ifdef BIASED_RESAMPLING
        gi_reservoirs_a[pixel_index] = combined_reservoir; // 存储应用了可见性的结果
        #endif
        ```
    - **与PR目的的关系**: 配合完成发射光照修复，并包含了一项独立但相关的渲染算法微调。

## 进一步阅读
- **Bevy Solari**: 了解 Bevy 引擎中实时光线追踪/重光照系统的整体架构。
- **WGSL (WebGPU Shading Language)**: 了解此次 PR 中修改的着色器所使用的语言。
- **ReSTIR GI**: 学习该 PR 中实现的“重采样时空重要性采样全局光照”算法的基本原理。
- **曝光（Exposure）与色调映射（Tone Mapping）**: 了解 HDR 渲染中曝光控制的重要性。
- **GPU 性能分析（GPU Profiling）**: 学习如何使用类似此次 PR 中添加的计时工具来分析图形程序的性能瓶颈。