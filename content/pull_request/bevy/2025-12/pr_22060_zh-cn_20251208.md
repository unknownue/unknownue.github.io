+++
title = "#22060 Fix macOS panic when exiting from exclusive fullscreen"
date = "2025-12-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22060-en-20251208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22060-zh-cn-20251208" }}
+++

# Title

## 基本资料
- **标题**: Fix macOS panic when exiting from exclusive fullscreen
- **PR链接**: https://github.com/bevyengine/bevy/pull/22060
- **作者**: natepiano
- **状态**: 已合并
- **标签**: A-Windowing, O-MacOS, S-Needs-Review
- **创建时间**: 2025-12-08T01:47:18Z
- **合并时间**: 2025-12-08T21:33:59Z
- **合并者**: mockersf

## 描述翻译

# 目标（Objective）

修复在 macOS 上，当应用程序处于独占全屏（exclusive fullscreen）模式时退出导致的 panic（恐慌）。

## 解决方案（Solution）

在 `fn exiting` 函数中，事件循环返回之前，从 `WINIT_WINDOWS` 线程局部存储（TLS）中移除窗口（Drop windows）。

panic 的发生原因是：
1. `WINIT_WINDOWS` 存储在 TLS 中
2. 窗口在 TLS 销毁期间（事件循环退出后）被丢弃（dropped）
3. winit 的 `Window::drop` 方法会为独占全屏窗口调用 `set_fullscreen(None)`
4. macOS 会发送一个回调（callback），该回调试图访问正在被销毁的 TLS

通过在 `fn exiting` 中清空窗口，它们会在事件循环仍处于活动状态时被丢弃，从而避免了 TLS 访问问题。

## 测试（Testing）

- 在 macOS 26.1 (Sequoia) 搭配 M2 Max 上测试
- 运行 `cargo run --example monitor_info`，然后按 Cmd+Q 退出
- 未修复时：panic 并提示 “cannot access a Thread Local Storage value during or after destruction”
- 修复后：正常退出
- Windows 系统不受影响

## The Story of This Pull Request

这次修复源于 macOS 平台上一个特定的、导致应用崩溃的竞态条件（race condition）。问题场景非常具体：当用户通过 Command+Q（或类似方式）退出一个正处于独占全屏模式的 Bevy 应用时，应用会发生 panic，错误信息指向线程局部存储（Thread Local Storage， TLS）的非法访问。

问题的根源在于 Bevy 窗口生命周期的销毁顺序与 macOS 系统回调（callback）之间的微妙时序。在 Bevy 的 `bevy_winit` 集成中，所有由 `winit` 库创建的 `Window` 实例都被集中存储在一个名为 `WINIT_WINDOWS` 的线程局部变量中。这是一个 `RefCell<Vec<Rc<winit::window::Window>>>`。事件循环（event loop）运行在持有此 TLS 的同一线程上。

当用户退出应用时，事件循环进入 `exiting` 阶段，随后结束。根据 Rust 的 drop 顺序，`WINIT_WINDOWS` 这个 TLS 本身会在事件循环结束后才被销毁。然而，`WINIT_WINDOWS` 中存储的 `Rc<Window>` 的析构（`Drop`）也会在此时触发。这里就出现了关键问题：当 `winit::window::Window` 被丢弃时，它的 `drop` 实现会尝试调用 `set_fullscreen(None)` 来清理独占全屏状态。在 macOS 上，这个清理操作会触发一个系统回调。这个回调的执行路径尝试访问 `WINIT_WINDOWS` TLS —— 但此时，事件循环已经结束，TLS 本身可能正处于销毁过程中（即“during or after destruction”的状态）。尝试访问一个正在被销毁的 TLS 是未定义行为，Rust 的运行时（runtime）会因此触发 panic。

开发者 `natepiano` 的解决方案直接且巧妙：改变窗口被丢弃的**时机**。他观察到，只要在 TLS 被销毁之前、事件循环还未完全退出的时间点提前丢弃窗口，就能避免上述竞态条件。Bevy 的 `WinitAppRunnerState` 实现了 `winit` 的 `ApplicationHandler` trait，其中包含一个 `exiting` 方法。这个方法在事件循环决定退出后、但尚未返回之前被调用。此时，事件循环仍然有效，TLS 也绝对安全可用。

因此，解决方案就是在 `exiting` 方法中手动清空 `WINIT_WINDOWS` 中的列表。通过调用 `windows.clear()`，`Vec` 中所有 `Rc<Window>` 的引用计数在此刻减少。如果某个 `Window` 没有被其他地方持有（通常情况就是如此），其引用计数会变为零，`drop` 方法会立即执行。由于这一切都发生在 `exiting` 函数体内，事件循环仍在运行，macOS 的清理回调可以安全地访问 TLS，从而避免了 panic。

这是一个典型的“通过调整资源释放顺序来解决平台特定竞态条件”的案例。代码改动极小（仅增加了3行），但效果显著。它精准地拦截了问题发生的路径，而没有引入复杂的同步机制或改变整体架构。这种修复方式体现了对底层库（winit）行为、平台（macOS）特性和 Rust 所有权/析构顺序的深入理解。对于其他开发者而言，这是一个重要的教训：当处理系统级回调或中断时，需要特别注意全局状态（如 TLS）的生命周期，确保回调执行期间其依赖的上下文仍然有效。

## 视觉呈现

```mermaid
graph TD
    subgraph "事件循环生命周期"
        A[事件循环运行中] --> B{收到退出事件}
        B --> C[调用 `exiting` 方法]
        C --> D[事件循环结束 / TLS 销毁]
    end

    subgraph "修复前的问题路径"
        D --> E[触发 Window::drop]
        E --> F[调用 set_fullscreen(None)]
        F --> G[macOS 发送清理回调]
        G --> H[回调尝试访问 WINIT_WINDOWS TLS]
        H --> I[⛔ PANIC: TLS 已销毁]
    end

    subgraph "修复后的路径"
        C --> J[手动清空 WINIT_WINDOWS]
        J --> K[触发 Window::drop]
        K --> L[调用 set_fullscreen(None)]
        L --> M[macOS 发送清理回调]
        M --> N[回调安全访问 WINIT_WINDOWS TLS]
        N --> O[✅ 正常退出]
    end
```

## 关键文件更改

**crates/bevy_winit/src/state.rs** (+4/-0)

1.  **变更描述及原因**：
    在 `WinitAppRunnerState` 实现的 `exiting` 方法中增加了三行代码。目的是在事件循环（event loop）仍然活跃、线程局部存储（TLS）确定安全可访问时，主动丢弃（drop）所有由 `winit` 管理的窗口。这解决了在 macOS 上，因窗口析构触发系统回调而访问正在销毁的 TLS 所引发的 panic。

2.  **代码片段**：
    ```rust
    // File: crates/bevy_winit/src/state.rs
    // 上下文: 在 `impl<M: Message> ApplicationHandler<M> for WinitAppRunnerState<M>` 块中
    fn exiting(&mut self, _event_loop: &ActiveEventLoop) {
        // 新增代码开始
        // Drop windows while event loop is still active, before TLS destruction.
        // Prevents panic on macOS when exiting from exclusive fullscreen.
        WINIT_WINDOWS.with(|ww| ww.borrow_mut().windows.clear());
        // 新增代码结束

        let world = self.world_mut();
        world.clear_all();
    }
    ```

3.  **与 PR 目的的关系**：
    这是本 PR 引入的唯一变更，直接实现了解决方案。`WINIT_WINDOWS.with(...)` 访问线程局部变量，`ww.borrow_mut().windows.clear()` 获取可变借用并清空内部的 `Vec`。清空操作会导致其中 `Rc<winit::window::Window>` 的引用计数减少，如果没有其他引用，则会立即触发 `Drop` 实现。由于此时仍在 `exiting` 函数调用栈内，TLS 访问是安全的，从而切断了导致 panic 的链条。

## 延伸阅读

1.  **Rust 官方文档 - `std::thread::LocalKey`**: 了解线程局部存储（TLS）在 Rust 中如何工作及其安全约束。
    [https://doc.rust-lang.org/std/thread/struct.LocalKey.html](https://doc.rust-lang.org/std/thread/struct.LocalKey.html)

2.  **`winit` 库的 `Window` 文档**: 理解 `winit::window::Window` 的 API，特别是其 `set_fullscreen` 方法和 `Drop` 实现的行为。
    [https://docs.rs/winit/latest/winit/window/struct.Window.html](https://docs.rs/winit/latest/winit/window/struct.Window.html)

3.  **Bevy 之书 - 窗口（Windowing）**: 了解 Bevy 引擎中窗口管理的基本概念和与 `winit` 的集成方式。
    [https://bevy-cheatbook.github.io/platforms/windowing.html](https://bevy-cheatbook.github.io/platforms/windowing.html)

# Full Code Diff
diff --git a/crates/bevy_winit/src/state.rs b/crates/bevy_winit/src/state.rs
index 08c9e36535bfa..9e347651f57e4 100644
--- a/crates/bevy_winit/src/state.rs
+++ b/crates/bevy_winit/src/state.rs
@@ -496,6 +496,10 @@ impl<M: Message> ApplicationHandler<M> for WinitAppRunnerState<M> {
     }
 
     fn exiting(&mut self, _event_loop: &ActiveEventLoop) {
+        // Drop windows while event loop is still active, before TLS destruction.
+        // Prevents panic on macOS when exiting from exclusive fullscreen.
+        WINIT_WINDOWS.with(|ww| ww.borrow_mut().windows.clear());
+
         let world = self.world_mut();
         world.clear_all();
     }