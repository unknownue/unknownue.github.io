diff --git a/crates/bevy_math/src/bounding/bounded3d/mod.rs b/crates/bevy_math/src/bounding/bounded3d/mod.rs
index f973d464d3558..cbfdb1d4f3909 100644
--- a/crates/bevy_math/src/bounding/bounded3d/mod.rs
+++ b/crates/bevy_math/src/bounding/bounded3d/mod.rs
@@ -72,6 +72,14 @@ impl Aabb3d {
         }
     }
 
+    /// Constructs an AABB from its minimum and maximum extent.
+    #[inline]
+    pub fn from_min_max(min: impl Into<Vec3A>, max: impl Into<Vec3A>) -> Self {
+        let (min, max) = (min.into(), max.into());
+        debug_assert!(min.x <= max.x && min.y <= max.y && min.z <= max.z);
+        Self { min, max }
+    }
+
     /// Computes the smallest [`Aabb3d`] containing the given set of points,
     /// transformed by the rotation and translation of the given isometry.
     ///
diff --git a/crates/bevy_mesh/src/mesh.rs b/crates/bevy_mesh/src/mesh.rs
index ca224d6e286eb..ea6482b1421c8 100644
--- a/crates/bevy_mesh/src/mesh.rs
+++ b/crates/bevy_mesh/src/mesh.rs
@@ -2165,7 +2165,7 @@ impl Mesh {
                 min = Vec3::min(min, v);
                 max = Vec3::max(max, v);
             }
-            self.final_aabb = Some(Aabb3d::new(min, max));
+            self.final_aabb = Some(Aabb3d::from_min_max(min, max));
         }
 
         Ok(Self {
@@ -2523,6 +2523,7 @@ mod tests {
     use crate::mesh::{Indices, MeshWindingInvertError, VertexAttributeValues};
     use crate::PrimitiveTopology;
     use bevy_asset::RenderAssetUsages;
+    use bevy_math::bounding::Aabb3d;
     use bevy_math::primitives::Triangle3d;
     use bevy_math::Vec3;
     use bevy_transform::components::Transform;
@@ -2878,6 +2879,29 @@ mod tests {
         );
     }
 
+    #[test]
+    fn take_gpu_data_calculates_aabb() {
+        let mut mesh = Mesh::new(
+            PrimitiveTopology::TriangleList,
+            RenderAssetUsages::default(),
+        );
+        mesh.insert_attribute(
+            Mesh::ATTRIBUTE_POSITION,
+            vec![
+                [-0.5, 0., 0.],
+                [-1., 0., 0.],
+                [-1., -1., 0.],
+                [-0.5, -1., 0.],
+            ],
+        );
+        mesh.insert_indices(Indices::U32(vec![0, 1, 2, 2, 3, 0]));
+        mesh = mesh.take_gpu_data().unwrap();
+        assert_eq!(
+            mesh.final_aabb,
+            Some(Aabb3d::from_min_max([-1., -1., 0.], [-0.5, 0., 0.]))
+        );
+    }
+
     #[cfg(feature = "serialize")]
     #[test]
     fn serialize_deserialize_mesh() {
