+++
title = "#22207 Adds ability to pause in gizmo examples"
date = "2025-12-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22207-en-20251230" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22207-zh-cn-20251230" }}
labels = ["C-Examples", "A-Gizmos", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Adds ability to pause in gizmo examples
- **PR Link**: https://github.com/bevyengine/bevy/pull/22207
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: C-Examples, S-Ready-For-Final-Review, A-Gizmos, D-Straightforward
- **Created**: 2025-12-20T06:20:39Z
- **Merged**: 2025-12-30T00:15:31Z
- **Merged By**: mockersf

## Description Translation

# Objective

- Fixes #22203

## Solution

- Utilize the virtual clock to pause time! Use the real time clock in config as well, though, since increasing and decreasing line widths scales happens with elapsed time deltas.
- I did not include an indicator for when the scenes are paused / unpaused since it seems there is at least one thing constantly moving in the two scenes unless they are paused. (the 2d example has that constantly rotating oval, and the 3d example has that constantly moving grid gizmo in the air)

## Testing

- Did you test these changes? If so, how?
I ran both the affected examples:
`cargo run --example 3d_gizmos --features=“free_camera”`
`cargo run --example 2d_gizmos`
Pausing works as expected, and increasing/decreasing line widths while paused still works

## The Story of This Pull Request

This PR addresses issue #22203, which requested a pause feature for the Bevy engine's gizmo examples. The developer implemented a clean solution that maintains functionality while adding the requested feature.

The core problem was straightforward: users needed a way to pause the animated examples to better inspect the gizmo drawings. The 2D example has a constantly rotating oval, and the 3D example has a moving grid gizmo, making it difficult to examine details while everything is in motion.

The developer chose to leverage Bevy's time system architecture, which provides two types of time resources: `Time<Virtual>` for game logic time (which can be paused) and `Time<Real>` for real-world wall clock time (which always advances). This distinction was crucial because the examples needed to handle two different requirements simultaneously: pausing the animations while still allowing line width adjustments to work when paused.

In the original implementation, the `update_config` function used a generic `Time` resource for line width adjustments:
```rust
fn update_config(
    mut config_store: ResMut<GizmoConfigStore>,
    keyboard: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,  // Generic time resource
)
```

The challenge was that if the developer simply added pausing using the virtual clock, the line width adjustments would also stop working when paused because they depended on time deltas. The solution was to split the time usage: use `Time<Real>` for line width adjustments and `Time<Virtual>` for pausing the example animations.

The implementation modified both `update_config` functions to accept two time resources:
```rust
fn update_config(
    mut config_store: ResMut<GizmoConfigStore>,
    keyboard: Res<ButtonInput<KeyCode>>,
    real_time: Res<Time<Real>>,        // For line width adjustments
    mut virtual_time: ResMut<Time<Virtual>>,  // For pausing
)
```

This separation ensures that pressing arrow keys to adjust line widths continues to work based on real time elapsed, even when the virtual clock is paused. The developer then added spacebar handling to toggle the pause state:

```rust
if keyboard.just_pressed(KeyCode::Space) {
    if virtual_time.is_paused() {
        virtual_time.unpause();
    } else {
        virtual_time.pause();
    }
}
```

The developer also updated the on-screen instructions in both examples to inform users about the new pause functionality, adding the line: "Press 'Spacebar' to toggle pause".

An important design decision was to not add a visual indicator for the pause state. The rationale was that users could easily determine if the scene was paused by observing whether the constantly moving elements (the rotating oval in 2D or moving grid in 3D) were stationary. This kept the implementation minimal and avoided adding UI complexity to what are primarily demonstration examples.

The changes demonstrate a good understanding of Bevy's time system architecture. By using both real and virtual time appropriately, the implementation maintains all existing functionality while adding the requested feature. This approach is particularly useful in game development scenarios where you might want to pause game logic but continue processing input or UI updates.

## Visual Representation

```mermaid
graph TD
    A[User presses Spacebar] --> B{Check virtual time state}
    B -->|Paused| C[Call virtual_time.unpause()]
    B -->|Running| D[Call virtual_time.pause()]
    
    E[User adjusts line width] --> F{Check virtual time state}
    F -->|Paused| G[Use Time<Real> delta]
    F -->|Running| G
    
    H[Time<Real>] --> G
    I[Time<Virtual>] --> J[Example animations]
    
    C --> K[Animations resume]
    D --> L[Animations pause]
    G --> M[Line width updates]
```

## Key Files Changed

### `examples/gizmos/2d_gizmos.rs` (+15/-6)

**Changes:** Added pause functionality using Bevy's virtual clock system while maintaining line width adjustment using real time.

**Key modifications:**

1. Updated instructions text:
```rust
// Before:
"Press 'J' / 'K' to cycle through line joins",

// After:
"Press 'J' / 'K' to cycle through line joins\n\
Press 'Spacebar' to toggle pause",
```

2. Modified function signature and time usage:
```rust
// Before:
fn update_config(
    mut config_store: ResMut<GizmoConfigStore>,
    keyboard: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
)

// After:
fn update_config(
    mut config_store: ResMut<GizmoConfigStore>,
    keyboard: Res<ButtonInput<KeyCode>>,
    real_time: Res<Time<Real>>,
    mut virtual_time: ResMut<Time<Virtual>>,
)
```

3. Updated line width calculations to use real time:
```rust
// Before:
config.line.width += 5. * time.delta_secs();

// After:
config.line.width += 5. * real_time.delta_secs();
```

4. Added pause toggle logic:
```rust
if keyboard.just_pressed(KeyCode::Space) {
    if virtual_time.is_paused() {
        virtual_time.unpause();
    } else {
        virtual_time.pause();
    }
}
```

### `examples/gizmos/3d_gizmos.rs` (+15/-6)

**Changes:** Applied the same pause functionality to the 3D gizmo example.

**Key modifications:**

1. Updated instructions text (same pattern as 2D example).

2. Modified function signature and time usage (same pattern as 2D example).

3. Updated line width calculations to use real time (same pattern as 2D example).

4. Added pause toggle logic (same pattern as 2D example).

The changes in both files follow identical patterns, ensuring consistency across the examples.

## Further Reading

1. [Bevy Time Documentation](https://docs.rs/bevy/latest/bevy/time/struct.Time.html) - Official documentation for Bevy's time system
2. [Bevy Virtual Time Example](https://github.com/bevyengine/bevy/blob/main/examples/time/virtual_time.rs) - Example demonstrating virtual time usage
3. [Game Loop and Time Step Patterns](https://gafferongames.com/post/fix_your_timestep/) - In-depth article on game timing
4. [Bevy Gizmos Documentation](https://docs.rs/bevy/latest/bevy/gizmos/index.html) - Official gizmo system documentation