+++
title = "#22105 Make it possible to statically construct gizmo buffers"
date = "2025-12-14T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22105-en-20251214" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22105-zh-cn-20251214" }}
labels = ["D-Trivial", "A-Gizmos"]
+++

# Title

## Basic Information
- **Title**: Make it possible to statically construct gizmo buffers
- **PR Link**: https://github.com/bevyengine/bevy/pull/22105
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: D-Trivial, S-Ready-For-Final-Review, A-Gizmos
- **Created**: 2025-12-13T09:32:13Z
- **Merged**: 2025-12-14T21:47:22Z
- **Merged By**: alice-i-cecile

## Description Translation
- 目标
  - 为实现某些特定功能，支持静态构造gizmo缓冲区
- 解决方案
  - 公开一个const构造函数
- 测试
  - 

## The Story of This Pull Request

这个PR的核心是为`GizmoBuffer`结构体添加一个`const`构造函数。在Bevy引擎中，Gizmo（小工具）用于在场景中绘制调试形状，比如线条、球体或矩形。`GizmoBuffer`是存储这些待渲染图形数据的容器。

开发者发现，当需要创建一个编译时已知的、不可变的`GizmoBuffer`实例时，缺少直接的方式。虽然`GizmoBuffer`已经实现了`Default` trait，其`default()`方法会返回一个空的、启用的缓冲区，但`default()`方法本身不是`const`的。这意味着它不能在编译时被求值，无法用于需要常量表达式（const context）的场景，例如静态（`static`）变量的初始化，或者作为另一个常量的一部分。

问题的关键点在于，`GizmoBuffer`的内部字段（如`list_positions: Vec<Vec3>`）是动态分配的`Vec`类型。在Rust中，`Vec::new()`本身就是一个`const`函数（从Rust 1.39开始）。这意味着创建一个空的`Vec`是可以在编译时完成的。`GizmoBuffer`的其他字段，如布尔值`enabled`，也是可以在编译时确定的。因此，理论上整个结构体的构造可以完全在编译期完成。

解决方案非常直接：为`GizmoBuffer`添加一个`pub const fn new() -> Self`方法。这个方法简单地返回一个结构体字面量，将所有字段初始化为其“空”状态：`enabled`设为`true`，所有向量都调用`Vec::new()`。由于`Vec::new()`是`const`的，这个`new`函数也就可以被标记为`const`。

一个值得注意的实现细节是，开发者同时重构了现有的`Default`实现，使其调用新的`new()`方法。这样做有两大好处：
1.  **消除重复代码**：避免在两个地方重复编写相同的初始化逻辑，符合DRY（Don‘t Repeat Yourself）原则。
2.  **保证行为一致**：确保无论通过`Default::default()`还是`GizmoBuffer::new()`创建的实例，其初始状态都是完全相同的。

这个改动非常小，但很有意义。它提升了API的灵活性，允许开发者在更多上下文中使用`GizmoBuffer`。例如，现在可以这样写：
```rust
static MY_STATIC_GIZMO_BUFFER: GizmoBuffer<MyConfig, MyClear> = GizmoBuffer::new();
```
如果未来需要扩展`GizmoBuffer`的字段，只需在一个地方（即`new`方法）更新初始化逻辑即可，维护成本更低。

从技术角度来看，这个PR展示了如何在Rust中设计支持静态初始化的数据结构。关键在于确保结构体的所有字段都有`const`构造函数。对于包含`Vec`或其它集合类型的结构体，只要这些集合的“空”构造函数是`const`的，那么包裹它们的结构体也可以提供`const`构造函数。这是一种很实用的模式，可以增强库的易用性和性能（避免了运行时初始化的开销）。

## Visual Representation

```mermaid
graph TD
    A[调用者] -->|需要编译时常量| B[GizmoBuffer::new()]
    B -->|返回| C[构造好的 GizmoBuffer 实例]
    D[Default::default()] -->|内部调用| B
    C -->|字段| E[enabled: true]
    C -->|字段| F[list_positions: Vec::new()]
    C -->|字段| G[其他空 Vec 字段]
```

## Key Files Changed

### `crates/bevy_gizmos/src/gizmos.rs`
这个文件是本次PR唯一修改的文件。主要改动是为`GizmoBuffer`结构体添加了一个公共的、常量构造函数`new`，并将原有的`Default`实现改为使用这个新函数。

**关键修改：**
```rust
// 在 impl Default for GizmoBuffer 中
fn default() -> Self {
    GizmoBuffer::new() // 改为调用新的 new 方法
}

// 新增的 impl 块和 new 方法
impl<Config, Clear> GizmoBuffer<Config, Clear>
where
    Config: GizmoConfigGroup,
    Clear: 'static + Send + Sync,
{
    /// Constructs an empty `GizmoBuffer`.
    pub const fn new() -> Self {
        GizmoBuffer {
            enabled: true,
            list_positions: Vec::new(),
            // ... 其他字段也初始化为 Vec::new()
        }
    }
}
```
**修改说明：**
1.  将`Default::default`的实现委托给新的`new`方法，保持了行为的一致性并减少了代码重复。
2.  新增的`const fn new()`方法允许在编译时构造一个空的`GizmoBuffer`实例，提高了API的灵活性。

## Further Reading
1.  Rust Reference: [Const functions](https://doc.rust-lang.org/reference/const_eval.html#const-functions) - 关于Rust中常量函数的官方文档。
2.  Rust Blog: [Announcing Rust 1.39.0](https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html) - 宣布`Vec::new()`等成为`const fn`的版本公告。
3.  Bevy Gizmos Documentation: [Bevy Gizmos](https://docs.rs/bevy_gizmos/latest/bevy_gizmos/) - Bevy Gizmos模块的API文档。

# Full Code Diff
```
diff --git a/crates/bevy_gizmos/src/gizmos.rs b/crates/bevy_gizmos/src/gizmos.rs
index 3d666cbbf51fe..074a9232e6b79 100644
--- a/crates/bevy_gizmos/src/gizmos.rs
+++ b/crates/bevy_gizmos/src/gizmos.rs
@@ -308,6 +308,17 @@ where
     Clear: 'static + Send + Sync,
 {
     fn default() -> Self {
+        GizmoBuffer::new()
+    }
+}
+
+impl<Config, Clear> GizmoBuffer<Config, Clear>
+where
+    Config: GizmoConfigGroup,
+    Clear: 'static + Send + Sync,
+{
+    /// Constructs an empty `GizmoBuffer`.
+    pub const fn new() -> Self {
         GizmoBuffer {
             enabled: true,
             list_positions: Vec::new(),
```