+++
title = "#22033 Solari: More accurate ReSTIR DI resampling"
date = "2025-12-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22033-en-20251209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22033-zh-cn-20251209" }}
+++

# Title

## 基本信息
- **标题**: Solari: More accurate ReSTIR DI resampling
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22033
- **作者**: JMS55
- **状态**: 已合并
- **标签**: A-Rendering, S-Ready-For-Final-Review, C-Refinement
- **创建时间**: 2025-12-05T03:16:10Z
- **合并时间**: 2025-12-09T18:40:55Z
- **合并者**: alice-i-cecile

## 描述翻译
此 PR 对 Solari 的 ReSTIR DI 实现做了两项改进：
* 在水库合并时增加了多重重要性采样 (MIS)，这提高了自发光光源的亮度，使其更接近路径追踪的参考结果。
* 对着色时使用的最终水库样本进行可见性测试，但**不对**用于重采样的样本进行此测试。这极大地提高了阴影精度，但不幸的代价是更高的噪点。

## 此 PR 的故事

这个 PR 旨在解决 Bevy Solari 中 ReSTIR DI 实现的两个关键准确性问题。ReSTIR DI 的核心思想是跨时间和空间重用光照样本（存储在“水库”中），以降低噪点。然而，之前的实现在两个环节上存在偏差：一是合并来自不同表面的水库时未正确加权，二是阴影的可见性测试时机不当。

首先看问题。在光照计算中，当合并来自前一帧（时间重用）或相邻像素（空间重用）的水库时，代码需要评估每个水库中存储的样本对当前着色点的贡献。原始的 `merge_reservoirs` 函数仅使用当前着色点的表面信息（位置、法线、BRDF）来评估所有水库样本的贡献。这忽略了样本原本是从不同表面位置采样的事实。这种简化导致在合并来自不同几何位置的水库时，权重计算不准确，从而低估了特别是自发光表面等光源的贡献。

第二个问题是关于阴影。为了稳定性和降低噪点，之前的实现在重用阶段（即水库合并和重采样时）跳过了对样本的可见性测试。只有在最终着色阶段，才会对选出的样本进行可见性测试。这种做法是有偏的：它使得那些在实际着色点不可见，但在重采样点“可见”（因为未测试）的样本有机会被选中。这导致阴影“泄漏”或过于柔和，尤其是在物体边缘附近，阴影会延伸到本不该有的地方。

开发者采取的解决方案直接针对这两个偏差来源。

对于第一个问题，解决方案是在水库合并中引入多重重要性采样 (MIS)。具体实现是重构了 `merge_reservoirs` 函数。现在，该函数不仅接受两个水库 (`Reservoir`) 作为输入，还需要传入它们各自对应的表面信息（世界坐标、法线、漫反射 BRDF）。在计算权重时，代码会分别计算：
1.  样本 A 在表面 A 上的贡献。
2.  样本 B 在表面 A 上的贡献。
3.  样本 A 在表面 B 上的贡献。
4.  样本 B 在表面 B 上的贡献。

```wgsl
// Contributions for resampling
let canonical_contribution_canonical_sample = reservoir_contribution(canonical_reservoir, canonical_world_position, canonical_world_normal, canonical_diffuse_brdf);
let canonical_contribution_other_sample = reservoir_contribution(other_reservoir, canonical_world_position, canonical_world_normal, canonical_diffuse_brdf);

// Extra contributions for MIS
let other_contribution_canonical_sample = reservoir_contribution(canonical_reservoir, other_world_position, other_world_normal, other_diffuse_brdf);
let other_contribution_other_sample = reservoir_contribution(other_reservoir, other_world_position, other_world_normal, other_diffuse_brdf);
```

然后，使用 `balance_heuristic` 函数基于这些贡献来计算每个样本的 MIS 权重，最后进行加权重采样。这使得合并过程能更公平地对待来自不同表面的样本，从而更准确地估计光照，特别是提升了自发光物体的亮度。

为了传递这些额外的表面信息，代码引入了 `NeighborInfo` 结构体。`load_temporal_reservoir` 和 `load_spatial_reservoir` 函数现在返回这个结构体，而不仅仅是 `Reservoir`。这确保了在合并时能访问到水库来源处的几何信息。

对于第二个阴影问题，开发者调整了可见性测试的逻辑。现在，在空间重采样阶段 (`spatial_and_shade`)，代码会先合并水库，然后**立即**对合并后的水库样本进行可见性测试。测试结果用于修正水库的权重 (`unbiased_contribution_weight`)。

```wgsl
if reservoir_valid(combined_reservoir) {
    let resolved_light_sample = resolve_light_sample(combined_reservoir.sample, light_sources[combined_reservoir.sample.light_id >> 16u]);
    combined_reservoir.unbiased_contribution_weight *= trace_light_visibility(surface.world_position, resolved_light_sample.world_position);
}
```

关键在于，这个可见性测试的结果**仅用于最终的着色计算**，而**不用于**后续的（空间）重采样过程。这是通过一个条件编译开关 `BIASED_RESAMPLING` 来控制的。当启用有偏重采样时（默认？），可见性测试**后**才存储水库以供后续像素重用；当启用无偏模式时，可见性测试**前**就存储水库。

```wgsl
// More accuracy, less stability
#ifndef BIASED_RESAMPLING
    store_reservoir_a(global_id.xy, combined_reservoir);
#endif

// ... 可见性测试 ...

// More stability, less accuracy (shadows extend further out than they should)
#ifdef BIASED_RESAMPLING
    store_reservoir_a(global_id.xy, combined_reservoir);
#endif
```

这种设计明确揭示了工程上的权衡：如果希望阴影更准确（无偏），就必须接受更高的噪点，因为不可见的样本不会被传播给邻居。如果希望画面更稳定（有偏），就可以传播更多样本（包括那些可能不可见的），但代价是阴影质量下降。

此外，PR 中还包含了一些配套改动：
1.  将 `balance_heuristic` 函数从 `restir_gi.wgsl` 移到了共享的 `sampling.wgsl` 中，并增加了对负值的防护 (`max(0.0, ...)`)，防止除零或负权重。
2.  在 `world_cache_query.wgsl` 中为世界缓存查询添加了一个可选的、条件编译的抖动禁用开关 (`NO_JITTER_WORLD_CACHE`)，这可能用于调试或性能分析。
3.  修正了 `specular_gi.wgsl` 中一个 MIS 权重函数的返回值，确保其非负。

这次修改的核心是从一个简化、有偏的 ReSTIR DI 实现，朝着更正确、更无偏的方向演进。开发者没有隐藏其中的权衡，而是通过代码结构和注释清晰地展示了“准确性 vs 稳定性”这一实时渲染中的经典矛盾。新增的 `BIASED_RESAMPLING` 开关为用户提供了选择权，而改进的 MIS 合并逻辑则在任何情况下都能提升光照估计的准确性。这些改变使得 Solari 的渲染结果更接近路径追踪的参考图像，为追求更高质量渲染的用户提供了更好的基础。

## 可视化表示

```mermaid
graph TD
    subgraph “初始与时间阶段 (initial_and_temporal)”
        A[初始采样] --> B[生成初始水库]
        C[加载上一帧水库] --> D{几何相似?}
        D -- 是 --> E[构建NeighborInfo: 水库 + 表面信息]
        D -- 否 --> F[返回空NeighborInfo]
        B --> G[merge_reservoirs 带MIS]
        E --> G
        G --> H[存储合并水库到Buffer B]
    end

    subgraph “空间与着色阶段 (spatial_and_shade)”
        I[加载Buffer B水库] --> J[加载空间邻居]
        J --> K{几何相似?}
        K -- 是 --> L[构建NeighborInfo]
        K -- 否 --> M[返回空NeighborInfo]
        L --> N[merge_reservoirs 带MIS]
        I --> N
        N --> O[得到合并水库]

        O -- BIASED_RESAMPLING未定义 --> P[存储水库到Buffer A (供下一帧用)]
        O --> Q[测试样本可见性]
        Q --> R[更新水库权重]
        R -- BIASED_RESAMPLING已定义 --> S[存储水库到Buffer A (供下一帧用)]

        O --> T[计算BRDF与光照]
        R --> T
        T --> U[输出最终颜色]
    end

    H --> I
    P --> C
    S --> C
```

## 关键文件变更

1.  **`crates/bevy_solari/src/realtime/restir_di.wgsl` (+76/-41)**
    *   **变更与原因**: 这是本次 PR 的核心文件，实现了 ReSTIR DI 的主要算法。更改引入了多重重要性采样 (MIS) 到水库合并过程，并重构了代码以支持在合并时使用不同表面的信息。
    *   **关键代码片段 - `merge_reservoirs` 函数签名变更**:
        ```wgsl
        // 之前:
        fn merge_reservoirs(
            canonical_reservoir: Reservoir,
            other_reservoir: Reservoir,
            world_position: vec3<f32>,
            world_normal: vec3<f32>,
            diffuse_brdf: vec3<f32>,
            rng: ptr<function, u32>,
        ) -> ReservoirMergeResult

        // 之后:
        fn merge_reservoirs(
            canonical_reservoir: Reservoir,
            canonical_world_position: vec3<f32>,
            canonical_world_normal: vec3<f32>,
            canonical_diffuse_brdf: vec3<f32>,
            other_reservoir: Reservoir,
            other_world_position: vec3<f32>,
            other_world_normal: vec3<f32>,
            other_diffuse_brdf: vec3<f32>,
            rng: ptr<function, u32>,
        ) -> ReservoirMergeResult
        ```
    *   **关键代码片段 - 新增 `NeighborInfo` 结构体**:
        ```wgsl
        struct NeighborInfo {
            reservoir: Reservoir,
            world_position: vec3<f32>,
            world_normal: vec3<f32>,
            diffuse_brdf: vec3<f32>,
        }
        ```
    *   **关键代码片段 - 可见性测试与条件存储**:
        ```wgsl
        // More accuracy, less stability
        #ifndef BIASED_RESAMPLING
            store_reservoir_a(global_id.xy, combined_reservoir);
        #endif

        if reservoir_valid(combined_reservoir) {
            let resolved_light_sample = resolve_light_sample(combined_reservoir.sample, light_sources[combined_reservoir.sample.light_id >> 16u]);
            combined_reservoir.unbiased_contribution_weight *= trace_light_visibility(surface.world_position, resolved_light_sample.world_position);
        }

        // More stability, less accuracy (shadows extend further out than they should)
        #ifdef BIASED_RESAMPLING
            store_reservoir_a(global_id.xy, combined_reservoir);
        #endif
        ```
    *   **与 PR 的关系**: 这些变更是实现更准确的 MIS 合并和可配置的阴影精度的核心。

2.  **`crates/bevy_solari/src/realtime/world_cache_query.wgsl` (+8/-5)**
    *   **变更与原因**: 在世界缓存查询函数中增加了一个条件编译开关，允许禁用位置抖动。
    *   **关键代码片段**:
        ```wgsl
        // https://tomclabault.github.io/blog/2025/regir, jitter_world_position_tangent_plane
        #ifndef NO_JITTER_WORLD_CACHE
            let TBN = orthonormalize(world_normal);
            let offset = (rand_vec2f(rng) * 2.0 - 1.0) * cell_size * 0.5;
            world_position += offset.x * TBN[0] + offset.y * TBN[1];
            cell_size = get_cell_size(world_position, view_position);
        #endif
        ```
    *   **与 PR 的关系**: 这是一个辅助性改动，可能用于调试或性能分析，与主功能无直接关联。

3.  **`crates/bevy_solari/src/scene/sampling.wgsl` (+6/-2)**
    *   **变更与原因**: 将 `balance_heuristic` 函数标准化并增加了对负值的防护，使其行为更稳健。
    *   **关键代码片段**:
        ```wgsl
        // 之前:
        fn balance_heuristic(f: f32, g: f32) -> f32 {
            return f / (f + g);
        }

        // 之后:
        fn balance_heuristic(f: f32, g: f32) -> f32 {
            let sum = f + g;
            if sum == 0.0 {
                return 0.0;
            }
            return max(0.0, f / sum);
        }
        ```
    *   **与 PR 的关系**: `restir_di.wgsl` 中新的 MIS 逻辑依赖此函数，确保权重计算安全。

4.  **`crates/bevy_solari/src/realtime/restir_gi.wgsl` (+1/-9)**
    *   **变更与原因**: 删除了本地的 `balance_heuristic` 函数实现，改为导入共享版本。
    *   **关键代码片段**:
        ```wgsl
        // 删除的本地实现
        // fn balance_heuristic(x: f32, y: f32) -> f32 { ... }
        ```
    *   **与 PR 的关系**: 代码重构，统一工具函数，避免重复。

5.  **`crates/bevy_solari/src/realtime/specular_gi.wgsl` (+1/-1)**
    *   **变更与原因**: 修正 `nee_mis_weight` 函数，直接返回 `power_heuristic` 的结果。
    *   **关键代码片段**:
        ```wgsl
        // 之前:
        return max(0.0, power_heuristic(p_light, p_bounce));
        // 之后:
        return power_heuristic(p_light, p_bounce);
        ```
    *   **与 PR 的关系**: 细微修正，确保 `power_heuristic` 函数（现在内部调用 `balance_heuristic`）的非负性逻辑一致。

## 延伸阅读

*   **论文《Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting》**: 这是 ReSTIR DI 的原始论文，详细阐述了算法的理论基础和实现细节。
*   **多重重要性采样 (Multiple Importance Sampling, MIS)**: 了解 MIS 的概念对于理解此 PR 中权重计算的改进至关重要。可以参考《Physically Based Rendering: From Theory To Implementation》等相关书籍。
*   **Bevy 官方文档 - 渲染部分**: 了解 Bevy 的渲染架构和 ECS 如何与 Solari 这样的渲染后端交互。
*   **WGSL 语言规范**: 由于修改主要发生在 WGSL 着色器代码中，熟悉 WGSL 语法和特性（如结构体、函数指针、原子操作等）有助于深入理解代码。
*   **实时全局光照与降噪技术**: ReSTIR 是实时降噪和光照估计领域的重要技术，了解其变种（如 ReSTIR GI）和相关技术（如 SVGF, ASVGF）可以拓宽视野。