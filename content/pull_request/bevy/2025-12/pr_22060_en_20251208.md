+++
title = "#22060 Fix macOS panic when exiting from exclusive fullscreen"
date = "2025-12-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22060-en-20251208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22060-zh-cn-20251208" }}
labels = ["A-Windowing", "O-MacOS"]
+++

# Title
## Basic Information
- **Title**: Fix macOS panic when exiting from exclusive fullscreen
- **PR Link**: https://github.com/bevyengine/bevy/pull/22060
- **Author**: natepiano
- **Status**: MERGED
- **Labels**: A-Windowing, O-MacOS, S-Needs-Review
- **Created**: 2025-12-08T01:47:18Z
- **Merged**: 2025-12-08T21:33:59Z
- **Merged By**: mockersf

## Description Translation
# Objective

Fix panic on macOS when exiting an app while in exclusive fullscreen mode.

## Solution

Drop windows from `WINIT_WINDOWS` TLS in `fn exiting` before the event loop returns.

The panic occurs because:
1. `WINIT_WINDOWS` is stored in TLS
2. Windows are dropped during TLS destruction (after event loop exits)
3. winit's `Window::drop` calls `set_fullscreen(None)` for exclusive fullscreen
4. macOS sends a callback that tries to access TLS already being destroyed

By clearing windows in `fn exiting`, they're dropped while the event loop is still active, avoiding the TLS access issue.

## Testing

- Tested on macOS 26.1 (Sequoia) with M2 Max
- Run `cargo run --example monitor_info`, then Cmd+Q to quit
- Without fix: panic with "cannot access a Thread Local Storage value during or after destruction"
- With fix: clean exit
- Windows is unaffected

## The Story of This Pull Request

This PR addresses a specific, platform-specific crash that occurs on macOS when an application exits while in exclusive fullscreen mode. The problem stems from a subtle interaction between macOS windowing APIs, Rust's thread-local storage (TLS) destruction order, and the Bevy game engine's window management.

The core issue is a timing problem during application shutdown. When a Bevy application using winit for window management exits, several cleanup steps occur in sequence. Windows are managed in a thread-local data structure called `WINIT_WINDOWS`, which stores active window handles. During normal cleanup, when the event loop ends and the main thread exits, Rust begins destroying thread-local variables. However, on macOS, when a window in exclusive fullscreen mode is dropped, the winit library attempts to switch the window out of exclusive fullscreen by calling `set_fullscreen(None)`. This macOS system call triggers an asynchronous callback that needs to access the `WINIT_WINDOWS` TLS to complete the operation. By this point, Rust is already in the process of destroying TLS, leading to the panic "cannot access a Thread Local Storage value during or after destruction."

The fix is straightforward but carefully targeted. Instead of allowing windows to be dropped during TLS destruction (after the event loop has exited), we proactively clear the windows from the `WINIT_WINDOWS` TLS in the `exiting` callback. This callback runs while the event loop is still active, before TLS destruction begins. By dropping the windows at this earlier point in the shutdown sequence, the macOS callbacks can safely access the TLS because it hasn't started being torn down yet.

From an architectural perspective, this solution works within Bevy's existing event handling pattern. The `exiting` function is already called by winit as part of the event loop lifecycle, making it the appropriate place to perform cleanup that needs to happen before TLS destruction. The implementation adds just four lines of code that clear the windows collection, allowing them to be dropped immediately rather than during TLS cleanup.

The fix demonstrates an important principle in cross-platform Rust development: platform-specific edge cases often emerge from subtle interactions between system APIs, library cleanup routines, and Rust's ownership/destruction semantics. In this case, the macOS windowing system's asynchronous callback model conflicts with Rust's deterministic destruction order. The solution elegantly reconciles these by aligning the window cleanup with the appropriate point in the event loop lifecycle.

Testing confirms the fix works as intended. On macOS 26.1 with an M2 Max processor, running the `monitor_info` example and quitting with Cmd+Q previously caused a panic with the TLS destruction error. With this fix, the application exits cleanly. The change is scoped to only affect macOS behavior—Windows and other platforms remain unaffected because they don't have the same TLS destruction timing issue with fullscreen exit callbacks.

This type of fix is characteristic of low-level windowing system integration work, where platform-specific behaviors must be carefully accounted for. The solution is minimal and surgical, addressing only the specific timing issue without introducing broader architectural changes or affecting other platforms.

## Visual Representation

```mermaid
graph TD
    A[Application Exit Initiated] --> B[Event Loop enters exiting phase]
    B --> C{WINIT_WINDOWS.clear() called}
    C --> D[Windows dropped normally]
    D --> E[TLS destruction begins]
    E --> F[Clean shutdown]
    
    G[Original Bug Path] --> H[Event Loop exits]
    H --> I[TLS destruction begins]
    I --> J[Window.drop() called]
    J --> K[macOS callback triggered]
    K --> L[TLS access during destruction]
    L --> M[PANIC: cannot access TLS]
```

## Key Files Changed

- `crates/bevy_winit/src/state.rs` (+4/-0)

The only file modified in this PR contains the fix for the macOS panic. The change adds a call to clear the windows from thread-local storage during the `exiting` callback, ensuring they're dropped before TLS destruction begins.

```rust
// File: crates/bevy_winit/src/state.rs
// Before:
fn exiting(&mut self, _event_loop: &ActiveEventLoop) {
    let world = self.world_mut();
    world.clear_all();
}

// After:
fn exiting(&mut self, _event_loop: &ActiveEventLoop) {
    // Drop windows while event loop is still active, before TLS destruction.
    // Prevents panic on macOS when exiting from exclusive fullscreen.
    WINIT_WINDOWS.with(|ww| ww.borrow_mut().windows.clear());

    let world = self.world_mut();
    world.clear_all();
}
```

The change adds three lines: a comment explaining the purpose, and the actual call to clear the windows from the `WINIT_WINDOWS` thread-local storage. The `WINIT_WINDOWS.with(|ww| ...)` pattern accesses the thread-local variable, and `ww.borrow_mut().windows.clear()` empties the collection of windows, causing them to be dropped immediately. This ensures that when macOS triggers callbacks during window cleanup, the TLS is still accessible.

## Further Reading

1. **Rust Thread Local Storage Documentation**: The Rust Book's section on thread-local storage explains how `thread_local!` macro works and its destruction semantics.

2. **winit Window Management**: The winit crate's documentation on window lifecycle and platform-specific behaviors, particularly around fullscreen transitions on macOS.

3. **macOS Window Server Programming Guide**: Apple's documentation on NSWindow and fullscreen transitions, which explains the callback mechanism that triggers during fullscreen exit.

4. **Bevy Winit Integration**: The Bevy engine's winit integration code for understanding how window management is structured across different platforms.

5. **Memory Safety in Async Callbacks**: Articles on Rust's approach to memory safety when dealing with asynchronous system callbacks, particularly during cleanup phases.