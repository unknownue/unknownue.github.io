+++
title = "#22227 Make `LoadContext::finish` add all dependencies, and avoid a second texture load in GltfLoader."
date = "2025-12-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22227-en-20251230" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22227-zh-cn-20251230" }}
labels = ["A-Assets", "D-Modest", "A-glTF", "C-Refinement"]
+++

# Title

## Basic Information
- **Title**: Make `LoadContext::finish` add all dependencies, and avoid a second texture load in GltfLoader.
- **PR Link**: https://github.com/bevyengine/bevy/pull/22227
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: A-Assets, S-Ready-For-Final-Review, D-Modest, A-glTF, C-Refinement
- **Created**: 2025-12-22T05:17:19Z
- **Merged**: 2025-12-30T01:09:24Z
- **Merged By**: alice-i-cecile

## Description Translation

### 目标

- glTF 加载器之前对纹理进行了两次加载：第一次执行所有预期的解析和加载。第二次会**故意**尝试执行相同的加载，以 A) 避免进行第二次加载，B) 将句柄作为材质的具体依赖项添加 - 这样材质在所有纹理加载完成之前不会被视为"已加载且依赖项就绪"。
- 通常情况下，一个资产可能持有另一个资产的句柄，但根据 `LoadContext`，这个句柄不被视为依赖项。
- 此外，`StandardMaterial` 中的一些句柄缺少 `#[dependency]` 属性。

### 解决方案

- 为 `StandardMaterial` 中的所有句柄添加 `#[dependency]` 属性。
- 使 glTF 各项异性扩展也使用与其他扩展相同的 `parse_material_extension_texture` 函数（现有实现完全匹配）。
- 使 `LoadContext::finish` 使用 `VisitDependencies` 更新依赖项列表。
- 将纹理句柄列表通过 `GltfLoader` 传递，并在需要时克隆句柄。

### 测试

- 在 `bevy_asset` 中添加测试以验证依赖项跟踪是否有效 - 这部分在 PR 的其他更改之前也会失败。
- 运行了 `load_gltf` 示例，仍然正常工作。不过这不会显示依赖项跟踪是否正常工作。

## The Story of This Pull Request

这个PR主要解决了Bevy资产系统中两个相关的问题：glTF加载器对纹理的重复加载，以及依赖项跟踪的不一致性。

### 问题背景和动机

在原始的glTF加载实现中，存在一个效率问题和逻辑问题。当加载glTF材质时，系统会对每个纹理进行两次加载尝试：第一次是实际的解析和加载，第二次是**故意**尝试执行相同的加载。这第二次尝试有两个目的：首先是为了避免重复加载（如果纹理已经加载过），其次是为了将纹理句柄作为材质的依赖项添加，确保材质在所有纹理加载完成之前不被标记为"已加载且依赖项就绪"。

这种做法不仅效率低下（需要进行两次尝试），而且在逻辑上也存在问题。更根本的问题是，资产系统中的依赖项跟踪机制存在缺口：一个资产可以持有另一个资产的句柄，但如果这个句柄不是通过同一 `LoadContext` 加载的，它就不会被自动识别为依赖项。

### 技术解决方案

这个PR通过三个主要修改来解决这些问题：

1. **统一依赖项跟踪**：修改 `LoadContext::finish` 方法，使其在完成资产加载时自动收集资产中的所有依赖项。这是通过调用资产的 `visit_dependencies` 方法实现的，该方法会遍历资产中所有标记为 `#[dependency]` 的字段。

2. **消除纹理重复加载**：重构glTF加载器，使其在加载阶段一次性获取所有纹理句柄，然后将这些句柄传递给材质加载函数。这样，材质可以直接使用已经加载的纹理句柄，而不需要尝试第二次加载。

3. **完善依赖项标记**：为 `StandardMaterial` 中所有之前缺少 `#[dependency]` 属性的纹理句柄字段添加该属性，确保依赖项跟踪系统能够正确识别这些依赖关系。

### 核心实现细节

#### LoadContext::finish 的修改

关键的变化发生在 `crates/bevy_asset/src/loader.rs` 中：

```rust
// Before:
pub fn finish<A: Asset>(self, value: A) -> LoadedAsset<A> {
    LoadedAsset {
        value,
        dependencies: self.dependencies,
        // ...
    }
}

// After:
pub fn finish<A: Asset>(mut self, value: A) -> LoadedAsset<A> {
    // 此时，我们假设资产/子资产已经"锁定"且不会被更改，
    // 因此可以确保所有依赖项都被包含（以防句柄被使用但没有通过此LoadContext加载）。
    value.visit_dependencies(&mut |asset_id| {
        let (type_id, index) = match asset_id {
            UntypedAssetId::Index { type_id, index } => (type_id, index),
            // UUID资产无法加载，直接忽略此ID
            UntypedAssetId::Uuid { .. } => return,
        };
        self.dependencies
            .insert(ErasedAssetIndex { index, type_id });
    });
    LoadedAsset {
        value,
        dependencies: self.dependencies,
        // ...
    }
}
```

这个修改确保了即使资产句柄不是通过当前 `LoadContext` 加载的，只要它们被标记为 `#[dependency]`，就会被正确识别为依赖项。

#### glTF加载器的重构

glTF加载器的重构更为复杂。以前，材质加载函数 `load_material` 直接接收 `LoadContext` 和 `Document`，并负责加载纹理。现在，它改为接收预加载的纹理句柄列表：

```rust
// Before:
fn load_material(
    material: &Material,
    load_context: &mut LoadContext,
    document: &Document,
    is_scale_inverted: bool,
) -> Handle<StandardMaterial>

// After:
fn load_material(
    material: &Material,
    textures: &[Handle<Image>],
    is_scale_inverted: bool,
    asset_path: AssetPath<'_>,
) -> (String, StandardMaterial)
```

这个改变有以下几个重要影响：
1. 材质加载不再负责加载纹理，而是直接从 `textures` 数组中获取句柄
2. 函数现在返回材质标签和材质本身，而不是直接插入到 `LoadContext` 中
3. 调用者负责使用 `add_labeled_asset` 将材质添加到上下文中

#### 扩展的统一处理

PR还统一了glTF扩展对纹理的处理方式。例如，`khr_materials_anisotropy` 扩展现在使用与其他扩展相同的 `parse_material_extension_texture` 函数：

```rust
// Before: 有自己的纹理加载逻辑
let (anisotropy_channel, anisotropy_texture) = extension
    .get("anisotropyTexture")
    .and_then(|value| value::from_value::<Info>(value.clone()).ok())
    .map(|json_info| {
        (
            uv_channel(material, "anisotropy", json_info.tex_coord),
            texture_handle_from_info(&json_info, document, load_context),
        )
    })
    .unzip();

// After: 使用统一的函数
let (anisotropy_channel, anisotropy_texture) = parse_material_extension_texture(
    material,
    extension,
    "anisotropyTexture",
    "anisotropy",
    textures,
    asset_path,
);
```

### 测试验证

为了确保依赖项跟踪的正确性，PR添加了一个专门的测试 `asset_dependency_is_tracked_when_not_loaded`。这个测试验证了即使依赖项不是通过子资产的 `LoadContext` 加载的，它仍然会被正确跟踪。测试创建了一个具有依赖项的资产，其中依赖项在根上下文中加载，但句柄被放入子资产中。测试验证了子资产在依赖项加载完成前不会被标记为"已加载且依赖项就绪"。

### 技术影响和考量

这个PR的实现有几个重要的技术考量：

1. **性能改进**：通过消除纹理的重复加载尝试，减少了glTF加载过程中的冗余操作。虽然第二次加载尝试通常不会实际加载数据（如果纹理已缓存），但仍然涉及查找和检查，现在这些开销被完全消除了。

2. **架构清晰度**：将纹理加载职责与材质加载职责分离，使代码更加模块化。材质加载函数现在只关注如何构建材质，而不关心如何获取纹理句柄。

3. **依赖项跟踪的完整性**：修改确保所有通过 `#[dependency]` 标记的句柄都会被正确跟踪，无论它们是如何被获取的。这对于确保资产加载状态的正确性至关重要。

4. **向后兼容性**：虽然实现方式发生了变化，但外部API和行为保持不变，确保了现有代码的兼容性。

这个PR展示了资产系统中依赖项跟踪的重要性，以及如何通过合理的架构设计避免冗余操作。它解决了glTF加载中的一个具体问题，同时也改进了整个资产系统的健壮性。

## Visual Representation

```mermaid
graph TD
    A[GltfLoader] --> B[加载所有纹理]
    B --> C[创建textures数组]
    C --> D[加载材质]
    D --> E[使用textures数组<br>而非LoadContext加载纹理]
    E --> F[创建StandardMaterial]
    F --> G[标记所有纹理句柄为#[dependency]]
    G --> H[LoadContext::finish]
    H --> I[自动收集所有依赖项]
    I --> J[正确跟踪材质依赖关系]
```

## Key Files Changed

### `crates/bevy_asset/src/loader.rs` (+80/-0)
**修改说明**：修改了 `LoadContext::finish` 方法，使其在完成资产加载时自动调用 `visit_dependencies` 来收集所有依赖项。

**关键代码修改**：
```rust
pub fn finish<A: Asset>(mut self, value: A) -> LoadedAsset<A> {
    value.visit_dependencies(&mut |asset_id| {
        let (type_id, index) = match asset_id {
            UntypedAssetId::Index { type_id, index } => (type_id, index),
            UntypedAssetId::Uuid { .. } => return,
        };
        self.dependencies
            .insert(ErasedAssetIndex { index, type_id });
    });
    LoadedAsset {
        value,
        dependencies: self.dependencies,
        // ...
    }
}
```

### `crates/bevy_gltf/src/loader/mod.rs` (+263/-241)
**修改说明**：重构了glTF加载器，使其在加载阶段一次性获取所有纹理句柄，然后将这些句柄传递给材质加载函数，避免了纹理的重复加载。

**关键代码修改**：
```rust
// 加载材质的函数签名变化
fn load_material(
    material: &Material,
    textures: &[Handle<Image>],  // 新增参数：预加载的纹理句柄
    is_scale_inverted: bool,
    asset_path: AssetPath<'_>,
) -> (String, StandardMaterial)  // 返回类型变为元组

// 在加载器主循环中使用纹理句柄
let handle = {
    let (label, material) = load_material(
        &material,
        &texture_handles,  // 传递纹理句柄数组
        false,
        load_context.path().clone(),
    );
    load_context.add_labeled_asset(label, material)
};
```

### `crates/bevy_gltf/src/loader/gltf_ext/texture.rs` (+2/-65)
**修改说明**：移除了不再使用的纹理加载函数，因为现在纹理加载统一在加载器主循环中处理。

**关键代码删除**：
```rust
// 删除了以下函数：
pub(crate) fn texture_handle_from_info(...)
pub(crate) fn texture_handle(...)
pub(crate) fn texture_label(...)
```

### `crates/bevy_gltf/src/loader/extensions/khr_materials_anisotropy.rs` (+15/-23)
**修改说明**：统一了各项异性扩展的纹理处理方式，使其使用与其他扩展相同的 `parse_material_extension_texture` 函数。

**关键代码修改**：
```rust
// 函数签名变化
pub(crate) fn parse(
    material: &Material,
    textures: &[Handle<Image>],  // 新增参数
    asset_path: AssetPath<'_>,   // 新增参数
) -> Option<AnisotropyExtension>

// 使用统一的纹理解析函数
let (anisotropy_channel, anisotropy_texture) = parse_material_extension_texture(
    material,
    extension,
    "anisotropyTexture",
    "anisotropy",
    textures,
    asset_path,
);
```

### `crates/bevy_pbr/src/pbr_material.rs`
**修改说明**：为 `StandardMaterial` 中所有之前缺少 `#[dependency]` 属性的纹理句柄字段添加该属性。

**关键代码修改**：
```rust
// 为多个纹理句柄字段添加 #[dependency] 属性
#[dependency]
pub diffuse_transmission_texture: Option<Handle<Image>>;

#[dependency]
pub specular_transmission_texture: Option<Handle<Image>>;

#[dependency]
pub thickness_texture: Option<Handle<Image>>;

// ... 以及其他类似字段
```

## Further Reading

1. **Bevy Asset System Documentation**: 了解Bevy资产系统的基本概念和设计原理
2. **glTF 2.0 Specification**: 理解glTF格式的详细规范和各扩展的工作原理
3. **Rust Attribute Macros**: 学习 `#[dependency]` 等属性宏的工作原理
4. **Dependency Tracking in Game Engines**: 了解游戏引擎中资产依赖项跟踪的常见模式和最佳实践