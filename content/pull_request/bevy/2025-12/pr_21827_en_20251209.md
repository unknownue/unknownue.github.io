+++
title = "#21827 Add vertical slider support to bevy_ui_widgets slider"
date = "2025-12-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21827-en-20251209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21827-zh-cn-20251209" }}
labels = ["C-Feature", "A-UI", "D-Straightforward"]
+++

# Title
Add vertical slider support to bevy_ui_widgets slider

## Basic Information
- **Title**: Add vertical slider support to bevy_ui_widgets slider
- **PR Link**: https://github.com/bevyengine/bevy/pull/21827
- **Author**: DuckyBlender
- **Status**: MERGED
- **Labels**: C-Feature, A-UI, S-Ready-For-Final-Review, X-Uncontroversial, D-Straightforward
- **Created**: 2025-11-13T15:37:03Z
- **Merged**: 2025-12-09T05:40:08Z
- **Merged By**: alice-i-cecile

## Description

# Objective

- Fixes the issue of vertical sliders not being functional. Previously, when creating a vertical slider, the slider drag behavior was still horizontal, meaning dragging left/right would change the value instead of dragging up/down. Additionally, clicking on the slider track was offset and didn't correctly map to the clicked position.

## Solution

The slider widget now automatically detects its orientation based on the node's dimensions (`height > width` for vertical, otherwise horizontal) and adjusts its interaction behavior accordingly:

1. **Orientation Detection**: Added automatic detection of slider orientation by comparing `node.size().y` to `node.size().x` in both `slider_on_pointer_down` and `slider_on_drag` functions.

2. **Drag Direction Fix**: 
   - For vertical sliders, the drag calculation now uses the Y-axis (`distance.y`) instead of X-axis
   - The Y coordinate is properly inverted (since screen Y increases downward) to match expected behavior (dragging up increases value)
   - Thumb size calculation uses `thumb.size().y` for vertical sliders instead of always using `thumb.size().x`

3. **Click Position Fix**:
   - Fixed coordinate conversion from Bevy's center-origin coordinate system to top/left-origin coordinates
   - For vertical sliders: converts `local_pos.y` from `[-height/2, +height/2]` to `[0, height]` before calculating the slider value
   - Accounts for thumb size offset to center the calculation properly
   - Inverts the Y coordinate for vertical sliders since Y increases downward

4. **Track Size Calculation**: Uses `node.size().y - thumb_size` for vertical sliders and `node.size().x - thumb_size` for horizontal sliders when calculating the available track space.

The changes are backward compatible - horizontal sliders continue to work exactly as before, and the orientation detection is transparent to users of the API.

## Testing

- **Manual Testing**: Created test application with both vertical and horizontal sliders to verify:
  - Vertical sliders respond correctly to vertical drag movements (up = increase, down = decrease)
  - Horizontal sliders continue to work correctly with horizontal drag movements
  - Clicking anywhere on the slider track correctly snaps to that position for both orientations
  - Thumb positioning updates correctly during drag operations
  - Multiple sliders can coexist without interfering with each other

- **Edge Cases Tested**:
  - Clicking at the very top/bottom of vertical sliders
  - Clicking at the very left/right of horizontal sliders
  - Dragging from one extreme to the other
  - Rapid clicking and dragging interactions

**Areas that may need more testing**:
- Sliders with non-standard aspect ratios (very wide vertical sliders or very tall horizontal sliders)
- Sliders with custom transforms/rotations applied
- Sliders in nested UI hierarchies with complex transforms

**How reviewers can test**:
1. Create a vertical slider (height > width) and verify:
   - Dragging up increases the value
   - Dragging down decreases the value
   - Clicking anywhere on the track snaps to that exact position
2. Create a horizontal slider (width > height) and verify it still works as before
3. Test with multiple sliders of both orientations simultaneously

**Platforms tested**:
- macOS (Apple Silicon)

## Showcase

### Before
- Vertical sliders were unusable - dragging would move horizontally instead of vertically
- Clicking on vertical slider tracks was offset, with clicks near the bottom snapping to the middle instead

https://github.com/user-attachments/assets/9bda83e7-f46b-4626-9df3-a558526a8ab2

### After
- Vertical sliders work correctly with intuitive up/down drag behavior
- Clicking anywhere on the slider track accurately snaps to the clicked position
- Both vertical and horizontal sliders work seamlessly together

https://github.com/user-attachments/assets/cca24288-4cbc-4ceb-828f-9ce7a735ade0

### Code Example

```rust
// Vertical slider - now works correctly!
commands.spawn((
    Node {
        width: Val::Px(12.0),
        height: Val::Px(300.0),  // height > width = vertical
        ..default()
    },
    Slider::default(),
    SliderValue(50.0),
    SliderRange::new(0.0, 100.0),
    // ... thumb and track children
));

// Horizontal slider - continues to work as before
commands.spawn((
    Node {
        width: Val::Px(300.0),
        height: Val::Px(12.0),  // width > height = horizontal
        ..default()
    },
    Slider::default(),
    SliderValue(50.0),
    SliderRange::new(0.0, 100.0),
    // ... thumb and track children
));
```

The orientation is automatically detected based on the node dimensions - no API changes required!

## The Story of This Pull Request

The Bevy UI slider widget had a fundamental limitation: it only worked horizontally. When developers tried to create vertical sliders by making the container taller than wide, the slider's interaction logic would incorrectly interpret vertical movements as horizontal ones, making vertical sliders unusable. This PR fixes that by implementing automatic orientation detection and adjusting the slider's interaction logic accordingly.

The problem was straightforward: the original slider implementation assumed all sliders were horizontal. The drag calculation used only the X-axis distance, and the click position calculation assumed a left-to-right coordinate system. For vertical sliders, this meant dragging left/right would change the value (incorrectly), and clicking on the track would map to the wrong position due to coordinate system mismatches.

The solution approach was to detect orientation based on the node's aspect ratio. If the node's height is greater than its width, the slider is treated as vertical; otherwise, it's horizontal. This heuristic is simple, intuitive, and requires no API changes - developers can create vertical sliders simply by making their containers taller than wide.

The implementation modifies two key functions in the slider system: `slider_on_pointer_down` (handles track clicks) and `slider_on_drag` (handles thumb dragging). In both functions, we first determine the orientation:

```rust
let is_vertical = node.size().y > node.size().x;
```

For drag calculations, we now use the appropriate axis based on orientation:
```rust
let drag_distance = if is_vertical { distance.y } else { distance.x };
```

This is important because screen coordinates in Bevy (and most graphics systems) have Y increasing downward, so for vertical sliders, dragging up (negative Y) should increase the value, which requires inverting the Y coordinate.

The track click calculation required more substantial changes. For horizontal sliders, the original code converted from Bevy's center-origin coordinate system (where (0,0) is at the center of the node) to a left-origin system (where 0 is at the left edge). For vertical sliders, we needed to do a similar conversion but for the Y-axis, and also invert the direction since screen Y increases downward:

```rust
if is_vertical {
    // For vertical sliders: bottom-to-top (0 at bottom, max at top)
    // local_pos.y ranges from -height/2 (top) to +height/2 (bottom)
    let y_from_bottom = (node.size().y / 2.0) - local_pos.y;
    let adjusted_y = y_from_bottom - thumb_size / 2.0;
    adjusted_y * range.span() / track_size + range.start()
} else {
    // For horizontal sliders: convert from center-origin to left-origin
    let x_from_left = local_pos.x + node.size().x / 2.0;
    let adjusted_x = x_from_left - thumb_size / 2.0;
    adjusted_x * range.span() / track_size + range.start()
}
```

The thumb size calculation also needed to consider orientation, since a thumb might have different dimensions for vertical vs horizontal sliders:

```rust
.find_map(|child_id| {
    q_thumb.get(child_id).ok().map(|thumb| {
        if is_vertical {
            thumb.size().y
        } else {
            thumb.size().x
        }
    })
})
```

One subtle but important change was in the `slider_on_drag` function: the query no longer includes `SliderValue` as a component to fetch. This is because the value is computed from the drag offset and doesn't need to be read from the component. Instead, a `ValueChange` event is always triggered with the new value, which allows the value to be updated elsewhere in the system.

The PR also adds a comprehensive example (`vertical_slider.rs`) that demonstrates both vertical and horizontal sliders working together. This example includes value labels that update in real-time, visual feedback for hover and drag states, and proper styling for both orientations.

From an architectural perspective, this implementation maintains backward compatibility while adding new functionality. Horizontal sliders continue to work exactly as before, and the orientation detection happens automatically without requiring developers to specify it. The changes are localized to the slider interaction logic and don't affect the broader UI system.

However, there are some limitations to the current approach. The orientation detection based on aspect ratio might not work correctly for sliders with non-standard transforms (like rotations) or in complex UI hierarchies. Also, the heuristic assumes that a taller-than-wide slider should be vertical, which might not always be the desired behavior for custom slider designs.

The impact of this PR is significant for Bevy's UI capabilities. Vertical sliders are a common UI component in applications ranging from audio editors to game settings menus. By fixing this issue, Bevy now provides a complete slider widget that works in both orientations, making it more suitable for a wider range of applications.

## Visual Representation

```mermaid
graph TD
    A[Slider Interaction System] --> B{Orientation Detection}
    B -->|Height > Width| C[Vertical Slider Logic]
    B -->|Width > Height| D[Horizontal Slider Logic]
    
    C --> E[Track Click: Y-axis calculation]
    C --> F[Drag: distance.y]
    C --> G[Thumb Size: thumb.size().y]
    
    D --> H[Track Click: X-axis calculation]
    D --> I[Drag: distance.x]
    D --> J[Thumb Size: thumb.size().x]
    
    E --> K[ValueChange Event]
    F --> K
    H --> K
    I --> K
    
    K --> L[UI Update]
    L --> M[Thumb Position Update]
    L --> N[Value Label Update]
```

## Key Files Changed

### `crates/bevy_ui_widgets/src/slider.rs` (+60/-17)
This is the core file that implements the slider widget's interaction logic. The changes add orientation detection and adjust calculations for vertical sliders.

**Key modifications:**
```rust
// Before (in slider_on_pointer_down):
let thumb_size = q_children
    .iter_descendants(press.entity)
    .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
    .unwrap_or(0.0);

let track_width = node.size().x - thumb_size;
let click_val = if track_width > 0. {
    local_pos.x * range.span() / track_width + range.center()
} else {
    0.
};

// After:
// Detect orientation: vertical if height > width
let is_vertical = node.size().y > node.size().x;

let thumb_size = q_children
    .iter_descendants(press.entity)
    .find_map(|child_id| {
        q_thumb.get(child_id).ok().map(|thumb| {
            if is_vertical {
                thumb.size().y
            } else {
                thumb.size().x
            }
        })
    })
    .unwrap_or(0.0);

let track_size = if is_vertical {
    node.size().y - thumb_size
} else {
    node.size().x - thumb_size
};

let click_val = if track_size > 0. {
    if is_vertical {
        // For vertical sliders: bottom-to-top (0 at bottom, max at top)
        let y_from_bottom = (node.size().y / 2.0) - local_pos.y;
        let adjusted_y = y_from_bottom - thumb_size / 2.0;
        adjusted_y * range.span() / track_size + range.start()
    } else {
        // For horizontal sliders: convert from center-origin to left-origin
        let x_from_left = local_pos.x + node.size().x / 2.0;
        let adjusted_x = x_from_left - thumb_size / 2.0;
        adjusted_x * range.span() / track_size + range.start()
    }
} else {
    range.center()
};
```

### `examples/ui/vertical_slider.rs` (+313/-0)
A new example file demonstrating vertical and horizontal sliders with value labels and visual feedback.

**Key sections:**
```rust
// Vertical slider bundle
fn vertical_slider() -> impl Bundle {
    (
        Node {
            width: px(12),
            height: px(200),  // height > width = vertical
            ..default()
        },
        // ... slider components and children
    )
}

// Horizontal slider bundle  
fn horizontal_slider() -> impl Bundle {
    (
        Node {
            height: px(12),
            width: px(200),  // width > height = horizontal
            ..default()
        },
        // ... slider components and children
    )
}

// Thumb positioning based on orientation
if is_vertical {
    thumb_node.bottom = percent(position);
} else {
    thumb_node.left = percent(position);
}
```

### `Cargo.toml` (+12/-0) and `examples/README.md` (+1/-0)
Configuration changes to add the new example to the project and documentation.

## Further Reading

1. **Bevy UI Coordinates**: Understanding Bevy's coordinate system (center origin vs top-left origin) is crucial for UI development. The [Bevy UI documentation](https://bevyengine.org/learn/book/features/ui/) covers this in detail.

2. **Slider Widget Design Patterns**: For more advanced slider implementations, consider studying how other UI frameworks handle sliders with custom tracks, multiple thumbs (range sliders), and touch interactions.

3. **Coordinate Transformations in Computer Graphics**: The mathematics behind coordinate system transformations (world space, screen space, local space) is fundamental to graphics programming. Resources like [LearnOpenGL's Transformations chapter](https://learnopengl.com/Getting-started/Transformations) provide a good foundation.

4. **Event-Driven Architecture in Bevy**: This PR uses Bevy's event system (`ValueChange` event) to communicate value changes. Understanding Bevy's ECS and event systems is essential for developing complex interactive widgets.