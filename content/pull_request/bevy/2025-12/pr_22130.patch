diff --git a/crates/bevy_dev_tools/Cargo.toml b/crates/bevy_dev_tools/Cargo.toml
index 36854b3f5088e..9d1506356e215 100644
--- a/crates/bevy_dev_tools/Cargo.toml
+++ b/crates/bevy_dev_tools/Cargo.toml
@@ -10,7 +10,7 @@ keywords = ["bevy"]
 
 [features]
 bevy_ci_testing = ["serde", "ron"]
-screenrecording = ["x264"]
+screenrecording = ["dep:x264"]
 webgl = ["bevy_render/webgl"]
 webgpu = ["bevy_render/webgpu"]
 
@@ -40,6 +40,8 @@ bevy_state = { path = "../bevy_state", version = "0.18.0-dev" }
 serde = { version = "1.0", features = ["derive"], optional = true }
 ron = { version = "0.12", optional = true }
 tracing = { version = "0.1", default-features = false, features = ["std"] }
+
+[target.'cfg(not(target_os = "windows"))'.dependencies]
 x264 = { version = "0.5.0", optional = true }
 
 [lints]
diff --git a/crates/bevy_dev_tools/src/easy_screenshot.rs b/crates/bevy_dev_tools/src/easy_screenshot.rs
index 4b5933038313e..84f93e9879820 100644
--- a/crates/bevy_dev_tools/src/easy_screenshot.rs
+++ b/crates/bevy_dev_tools/src/easy_screenshot.rs
@@ -1,25 +1,13 @@
 #[cfg(feature = "screenrecording")]
 use core::time::Duration;
 use std::time::{SystemTime, UNIX_EPOCH};
-#[cfg(feature = "screenrecording")]
-use std::{fs::File, io::Write, sync::mpsc::channel};
 
 use bevy_app::{App, Plugin, Update};
 use bevy_ecs::prelude::*;
-#[cfg(feature = "screenrecording")]
-use bevy_image::Image;
 use bevy_input::{common_conditions::input_just_pressed, keyboard::KeyCode};
-#[cfg(feature = "screenrecording")]
-use bevy_render::view::screenshot::ScreenshotCaptured;
 use bevy_render::view::screenshot::{save_to_disk, Screenshot};
-#[cfg(feature = "screenrecording")]
-use bevy_time::Time;
 use bevy_window::{PrimaryWindow, Window};
-#[cfg(feature = "screenrecording")]
-use tracing::info;
-#[cfg(feature = "screenrecording")]
-use x264::{Colorspace, Encoder, Setup};
-#[cfg(feature = "screenrecording")]
+#[cfg(all(not(target_os = "windows"), feature = "screenrecording"))]
 pub use x264::{Preset, Tune};
 
 /// File format the screenshot will be saved in
@@ -82,6 +70,50 @@ impl Plugin for EasyScreenshotPlugin {
     }
 }
 
+/// Placeholder
+#[cfg(all(target_os = "windows", feature = "screenrecording"))]
+pub enum Preset {
+    /// Placeholder
+    Ultrafast,
+    /// Placeholder
+    Superfast,
+    /// Placeholder
+    Veryfast,
+    /// Placeholder
+    Faster,
+    /// Placeholder
+    Fast,
+    /// Placeholder
+    Medium,
+    /// Placeholder
+    Slow,
+    /// Placeholder
+    Slower,
+    /// Placeholder
+    Veryslow,
+    /// Placeholder
+    Placebo,
+}
+
+/// Placeholder
+#[cfg(all(target_os = "windows", feature = "screenrecording"))]
+pub enum Tune {
+    /// Placeholder
+    None,
+    /// Placeholder
+    Film,
+    /// Placeholder
+    Animation,
+    /// Placeholder
+    Grain,
+    /// Placeholder
+    StillImage,
+    /// Placeholder
+    Psnr,
+    /// Placeholder
+    Ssim,
+}
+
 #[cfg(feature = "screenrecording")]
 /// Add this plugin to your app to enable easy screen recording.
 pub struct EasyScreenRecordPlugin {
@@ -107,13 +139,6 @@ impl Default for EasyScreenRecordPlugin {
     }
 }
 
-#[cfg(feature = "screenrecording")]
-enum RecordCommand {
-    Start(String, Preset, Tune),
-    Stop,
-    Frame(Image),
-}
-
 #[cfg(feature = "screenrecording")]
 /// Controls screen recording
 #[derive(Message)]
@@ -126,90 +151,118 @@ pub enum RecordScreen {
 
 #[cfg(feature = "screenrecording")]
 impl Plugin for EasyScreenRecordPlugin {
+    #[cfg_attr(
+        target_os = "windows",
+        expect(unused_variables, reason = "not working on windows")
+    )]
     fn build(&self, app: &mut App) {
-        let (tx, rx) = channel::<RecordCommand>();
+        #[cfg(target_os = "windows")]
+        {
+            tracing::warn!("Screen recording is not currently supported on Windows: see https://github.com/bevyengine/bevy/issues/22132");
+        }
+        #[cfg(not(target_os = "windows"))]
+        {
+            use bevy_image::Image;
+            use bevy_render::view::screenshot::ScreenshotCaptured;
+            use bevy_time::Time;
+            use std::{fs::File, io::Write, sync::mpsc::channel};
+            use tracing::info;
+            use x264::{Colorspace, Encoder, Setup};
 
-        let frame_time = self.frame_time;
+            enum RecordCommand {
+                Start(String, Preset, Tune),
+                Stop,
+                Frame(Image),
+            }
 
-        std::thread::spawn(move || {
-            let mut encoder: Option<Encoder> = None;
-            let mut setup = None;
-            let mut file: Option<File> = None;
-            let mut frame = 0;
-            loop {
-                let Ok(next) = rx.recv() else {
-                    break;
-                };
-                match next {
-                    RecordCommand::Start(name, preset, tune) => {
-                        info!("starting recording at {}", name);
-                        file = Some(File::create(name).unwrap());
-                        setup = Some(Setup::preset(preset, tune, false, true).high());
-                    }
-                    RecordCommand::Stop => {
-                        info!("stopping recording");
-                        if let Some(encoder) = encoder.take() {
-                            let mut flush = encoder.flush();
-                            let mut file = file.take().unwrap();
-                            while let Some(result) = flush.next() {
-                                let (data, _) = result.unwrap();
-                                file.write_all(data.entirety()).unwrap();
-                            }
+            let (tx, rx) = channel::<RecordCommand>();
+
+            let frame_time = self.frame_time;
+
+            std::thread::spawn(move || {
+                let mut encoder: Option<Encoder> = None;
+                let mut setup = None;
+                let mut file: Option<File> = None;
+                let mut frame = 0;
+                loop {
+                    let Ok(next) = rx.recv() else {
+                        break;
+                    };
+                    match next {
+                        RecordCommand::Start(name, preset, tune) => {
+                            info!("starting recording at {}", name);
+                            file = Some(File::create(name).unwrap());
+                            setup = Some(Setup::preset(preset, tune, false, true).high());
                         }
-                    }
-                    RecordCommand::Frame(image) => {
-                        if let Some(setup) = setup.take() {
-                            let mut new_encoder = setup
-                                .fps((1000 / frame_time.as_millis()) as u32, 1)
-                                .build(Colorspace::RGB, image.width() as i32, image.height() as i32)
-                                .unwrap();
-                            let headers = new_encoder.headers().unwrap();
-                            file.as_mut()
-                                .unwrap()
-                                .write_all(headers.entirety())
-                                .unwrap();
-                            encoder = Some(new_encoder);
+                        RecordCommand::Stop => {
+                            info!("stopping recording");
+                            if let Some(encoder) = encoder.take() {
+                                let mut flush = encoder.flush();
+                                let mut file = file.take().unwrap();
+                                while let Some(result) = flush.next() {
+                                    let (data, _) = result.unwrap();
+                                    file.write_all(data.entirety()).unwrap();
+                                }
+                            }
                         }
-                        if let Some(encoder) = encoder.as_mut() {
-                            let pts = (frame_time.as_millis() * frame) as i64;
-
-                            frame += 1;
-                            let (data, _) = encoder
-                                .encode(
-                                    pts,
-                                    x264::Image::rgb(
+                        RecordCommand::Frame(image) => {
+                            if let Some(setup) = setup.take() {
+                                let mut new_encoder = setup
+                                    .fps((1000 / frame_time.as_millis()) as u32, 1)
+                                    .build(
+                                        Colorspace::RGB,
                                         image.width() as i32,
                                         image.height() as i32,
-                                        &image.try_into_dynamic().unwrap().to_rgb8(),
-                                    ),
-                                )
-                                .unwrap();
-                            file.as_mut().unwrap().write_all(data.entirety()).unwrap();
+                                    )
+                                    .unwrap();
+                                let headers = new_encoder.headers().unwrap();
+                                file.as_mut()
+                                    .unwrap()
+                                    .write_all(headers.entirety())
+                                    .unwrap();
+                                encoder = Some(new_encoder);
+                            }
+                            if let Some(encoder) = encoder.as_mut() {
+                                let pts = (frame_time.as_millis() * frame) as i64;
+
+                                frame += 1;
+                                let (data, _) = encoder
+                                    .encode(
+                                        pts,
+                                        x264::Image::rgb(
+                                            image.width() as i32,
+                                            image.height() as i32,
+                                            &image.try_into_dynamic().unwrap().to_rgb8(),
+                                        ),
+                                    )
+                                    .unwrap();
+                                file.as_mut().unwrap().write_all(data.entirety()).unwrap();
+                            }
                         }
                     }
                 }
-            }
-        });
+            });
 
-        let frame_time = self.frame_time;
+            let frame_time = self.frame_time;
 
-        app.add_message::<RecordScreen>().add_systems(
-            Update,
-            (
-                (move |mut messages: MessageWriter<RecordScreen>, mut recording: Local<bool>| {
-                    *recording = !*recording;
-                    if *recording {
-                        messages.write(RecordScreen::Start);
-                    } else {
-                        messages.write(RecordScreen::Stop);
-                    }
-                })
-                .run_if(input_just_pressed(self.toggle)),
-                {
-                    let tx = tx.clone();
-                    let preset = self.preset;
-                    let tune = self.tune;
-                    move |mut commands: Commands,
+            app.add_message::<RecordScreen>().add_systems(
+                Update,
+                (
+                    (move |mut messages: MessageWriter<RecordScreen>,
+                           mut recording: Local<bool>| {
+                        *recording = !*recording;
+                        if *recording {
+                            messages.write(RecordScreen::Start);
+                        } else {
+                            messages.write(RecordScreen::Stop);
+                        }
+                    })
+                    .run_if(input_just_pressed(self.toggle)),
+                    {
+                        let tx = tx.clone();
+                        let preset = self.preset;
+                        let tune = self.tune;
+                        move |mut commands: Commands,
                           mut recording: Local<bool>,
                           mut messages: MessageReader<RecordScreen>,
                           window: Single<&Window, With<PrimaryWindow>>,
@@ -251,9 +304,10 @@ impl Plugin for EasyScreenRecordPlugin {
                             );
                         }
                     }
-                },
-            )
-                .chain(),
-        );
+                    },
+                )
+                    .chain(),
+            );
+        }
     }
 }
diff --git a/release-content/release-notes/easy_marketing_material.md b/release-content/release-notes/easy_marketing_material.md
index 953db7e9dcaf2..943a9b26a61e7 100644
--- a/release-content/release-notes/easy_marketing_material.md
+++ b/release-content/release-notes/easy_marketing_material.md
@@ -7,3 +7,5 @@ pull_requests: [21235, 21237]
 Bevy can take a screenshot of what's rendered since 0.11. This is now easier to setup to help you create marketing material, so that you can take screenshot with consistent formatting with the new `EasyScreenshotPlugin`. With its default settings, once you add this plugin to your application, a PNG screenshot will be taken when you press the `PrintScreen` key. You can change the trigger key, or the screenshot format between PNG, JPEG or BMP.
 
 It is now possible to record a movie from Bevy, with the new `EasyScreenRecordPlugin`. This plugins add a toggle key, space bar by default, that will toggle screen recording. Recording can also be started and stopped programmatically with the `RecordScreen` messages.
+
+Screen recording is not working for now on Windows.
