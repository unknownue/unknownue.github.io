+++
title = "#22026 Replace path canonicalize with our own version."
date = "2025-12-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22026-en-20251215" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22026-zh-cn-20251215" }}
labels = ["C-Bug", "A-Assets", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Replace path canonicalize with our own version.
- **PR Link**: https://github.com/bevyengine/bevy/pull/22026
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: C-Bug, A-Assets, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2025-12-04T05:47:53Z
- **Merged**: 2025-12-14T22:32:54Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- Renaming a file does not send a rename event to the asset system, meaning that renamed files are not detected!
- In #18023 we canonicalized the file path to work with asset folder paths that were relative. However `canonicalize` only works if the path actually exists! During a rename the old path no longer exists, so `canonicalize` fails and so we just silently `continue`.

## Solution

- Instead of using `canonicalize`, we write our own implementation using the `std::path::absolute` which uses the environment's current directory to create an absolute path (but doesn't collapse `..`), and then use our `normalize_path` to collapse `..` into a "canonical path".
    - The advantage is that this doesn't interact with the filesystem at all, so **any** path will be able to be resolved - including the file that was renamed (even thought that file path no longer exists).
    - The disadvantage is that this no longer resolves symbolic links - I don't see this as a big problem since I doubt our behavior makes sense in that case (a sym link will probably just send us out of the assets dir and give us a file path we won't know how to deal with).

## Testing

- I ran the `asset_processing` example. I made sure that renaming an asset or directory resulted in a rename event.
- I also tried changing the `asset_processing` example to use a relative path like #18022. Changes were correctly detected!
- I also checked that the embedded_watcher feature still works by making sure that one of our embedded shaders were hot-reloaded.

## The Story of This Pull Request

This PR addresses a critical bug in Bevy's asset watcher where file rename operations were not being detected. The issue stemmed from how the asset system handles paths during file system events.

The problem occurred when the asset watcher tried to process rename events. When a file is renamed, the operating system sends two pieces of information: the old path (which no longer exists) and the new path. In the previous implementation, the code attempted to canonicalize these paths using Rust's `std::fs::canonicalize()` method. However, `canonicalize()` has a significant limitation: it requires the path to actually exist on the filesystem. During a rename operation, the old path doesn't exist anymore, causing `canonicalize()` to fail. When this happened, the code would silently continue, effectively dropping the rename event and preventing the asset system from noticing the change.

This bug was particularly problematic for developers using hot reloading during development, as renaming assets is a common operation that should trigger asset updates. The issue was introduced in PR #18023, which added canonicalization to handle relative paths in asset folders, but didn't account for the filesystem dependency of canonicalization.

The solution implemented here replaces the filesystem-dependent `canonicalize()` with a purely computational approach. The new `make_absolute_path()` function combines two operations: first, it uses `std::path::absolute()` to convert a path to an absolute form using the current working directory, then it applies Bevy's existing `normalize_path()` function to collapse `..` components. This approach has several advantages:

1. **No filesystem interaction**: Since `std::path::absolute()` doesn't check if paths exist, it can process paths that refer to files that have been renamed or deleted.
2. **Consistent behavior**: The normalization is now purely computational and deterministic, not dependent on the current state of the filesystem.
3. **Preserves existing functionality**: The `normalize_path()` function already handles the path normalization needs, so this is a natural extension of existing infrastructure.

There's one trade-off: this approach no longer resolves symbolic links. The PR author correctly notes that this is acceptable because symbolic links in asset directories would likely cause more problems than they solve. When a symbolic link points outside the asset directory, the asset system wouldn't know how to handle it properly anyway.

The implementation required changes in two key areas. First, the `FileWatcher::new()` method now uses `make_absolute_path()` instead of `normalize_path().canonicalize()`. Second, the event processing logic in `new_asset_event_debouncer()` was updated to convert all event paths to absolute paths at the start of processing, avoiding repeated filesystem calls and ensuring consistent handling.

This change demonstrates an important principle in systems programming: when dealing with filesystem events, you often need to handle paths that refer to non-existent files. The previous implementation assumed all paths would exist, which is a common but incorrect assumption when processing filesystem events that describe state changes.

## Visual Representation

```mermaid
graph TD
    A[File System Events] --> B[Asset Watcher]
    B --> C[Path Processing]
    C --> D{Path exists on filesystem?}
    D -->|Yes| E[Old: canonicalize() works]
    D -->|No (e.g., renamed files)| F[New: make_absolute_path() works]
    E --> G[Process event]
    F --> G
    G --> H[Asset System Updates]
```

## Key Files Changed

### `crates/bevy_asset/src/io/file/file_watcher.rs` (+52/-55)

This file contains the core changes to fix the asset watcher bug. The main modifications include:

1. **Added `make_absolute_path()` function**: A new helper function that replaces `canonicalize()` with a filesystem-independent approach.

2. **Updated `FileWatcher::new()`**: Changed from using `normalize_path().canonicalize()` to the new `make_absolute_path()`.

3. **Refactored event processing**: Updated `new_asset_event_debouncer()` to pre-process all event paths to absolute form at the start of event handling.

Key code changes:

```rust
// Before: Using canonicalize() which requires paths to exist
let root = normalize_path(&path).canonicalize()?;

// After: Using make_absolute_path() which works for non-existent paths
let root = make_absolute_path(&path)?;
```

```rust
// New function: makes paths absolute without filesystem interaction
fn make_absolute_path(path: &Path) -> Result<PathBuf, std::io::Error> {
    // We use `normalize` + `absolute` instead of `canonicalize` to avoid reading the filesystem to
    // resolve the path. This also means that paths that no longer exist can still become absolute
    // (e.g., a file that was renamed will have the "old" path no longer exist).
    Ok(normalize_path(&std::path::absolute(path)?))
}
```

```rust
// Event processing: paths are made absolute early in the pipeline
let paths = event
    .paths
    .iter()
    .map(PathBuf::as_path)
    .map(|p| {
        make_absolute_path(p).expect("paths from the debouncer are valid")
    })
    .collect::<Vec<_>>();
```

```rust
// FileEventHandler::get_path no longer tries to canonicalize
fn get_path(&self, absolute_path: &Path) -> Option<(PathBuf, bool)> {
    // Before: absolute_path.canonicalize().ok()?;
    // After: Direct use of the already absolute path
    Some(get_asset_path(&self.root, absolute_path))
}
```

These changes ensure that rename events are properly detected and processed, fixing the original bug while maintaining support for relative paths.

## Further Reading

1. **Rust Standard Library Path Documentation**: The `std::path` module documentation explains the difference between `absolute()`, `canonicalize()`, and other path operations.
2. **Bevy Asset System Documentation**: Understanding how Bevy's asset system works with filesystem events and hot reloading.
3. **notify crate**: The underlying filesystem notification library used by Bevy, which provides the raw events that this PR processes.
4. **PR #18023**: The original PR that introduced canonicalization, providing context for why this change was initially made.
5. **Filesystem Event Handling Patterns**: General patterns for handling filesystem events in long-running applications, particularly around edge cases like renames and deletions.