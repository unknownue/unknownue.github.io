+++
title = "#22028 Increase the number of supported clustered decals if the `PARTIALLY_BOUND_BINDING_ARRAY` `wgpu` feature is present."
date = "2025-12-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22028-en-20251208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22028-zh-cn-20251208" }}
labels = ["A-Rendering"]
+++

# Title

## Basic Information
- **Title**: Increase the number of supported clustered decals if the `PARTIALLY_BOUND_BINDING_ARRAY` `wgpu` feature is present.
- **PR Link**: https://github.com/bevyengine/bevy/pull/22028
- **Author**: pcwalton
- **Status**: MERGED
- **Labels**: A-Rendering, S-Ready-For-Final-Review
- **Created**: 2025-12-04T16:50:53Z
- **Merged**: 2025-12-08T00:29:56Z
- **Merged By**: mockersf

## Description Translation

The current clustered decal code predates `PARTIALLY_BOUND_BINDING_ARRAY` support in `wgpu`. As a result, only 8 clustered decals are allowed in the scene in order to avoid paying a high cost even if no decals of that type are present. This limitation makes Bevy's current clustered decal support insufficient for many use cases (e.g. bullet holes), so this patch increases the limit from 8 to 1024 if the `wgpu` features include `PARTIALLY_BOUND_BINDING_ARRAY`.

## The Story of This Pull Request

This PR addresses a limitation in Bevy's clustered decal system where only 8 decals could be rendered per view. The limitation existed because the original implementation was written before wgpu supported partially bound binding arrays. Without this feature, binding arrays had to be fully populated to their maximum size even when many slots were unused, which incurred unnecessary overhead. To avoid performance penalties, the developers had set a conservative limit of 8 decals.

The problem became apparent in practical scenarios like rendering bullet holes, where many more decals are needed to create convincing visual effects. With only 8 decals available, the system was insufficient for realistic use cases. The solution leverages the now-available `PARTIALLY_BOUND_BINDING_ARRAY` wgpu feature, which allows binding arrays to be partially populated without requiring unused slots to be filled with placeholder resources.

The implementation replaces a hardcoded `MAX_VIEW_DECALS` constant with a `max_view_decals()` function that dynamically determines the limit based on the available wgpu features. On platforms supporting partially bound binding arrays, the limit increases to 1024, which provides a reasonable ceiling for most use cases while preventing shaders from becoming too slow with excessive numbers of decals. On platforms without this feature, the limit remains at 8 to maintain performance by avoiding the overhead of padding binding arrays.

The changes are minimal but strategic. The `get_bind_group_layout_entries()` function now calls `max_view_decals(render_device)` to determine the count for the texture binding array. In the bind group preparation code, the logic for padding the texture views array to its maximum length is now conditional—it only performs padding when `PARTIALLY_BOUND_BINDING_ARRAY` is not supported. This optimization eliminates unnecessary texture view allocations on platforms that support the feature.

The 1024 limit was chosen as a reasonable upper bound that accommodates typical use cases like bullet holes while providing a failsafe to prevent performance degradation. The implementation demonstrates how to conditionally leverage newer GPU features while maintaining backward compatibility with older hardware.

## Visual Representation

```mermaid
graph TD
    A[RenderDevice features check] --> B{PARTIALLY_BOUND_BINDING_ARRAY supported?}
    B -->|Yes| C[max_view_decals() returns 1024]
    B -->|No| D[max_view_decals() returns 8]
    C --> E[Binding array created with 1024 slots]
    D --> F[Binding array created with 8 slots]
    F --> G[Array padded with fallback textures]
    E --> H[No padding needed]
```

## Key Files Changed

### `crates/bevy_pbr/src/decal/clustered.rs` (+33/-12)

This file contains the core implementation changes for clustered decals. The modifications replace the hardcoded decal limit with a dynamic one based on GPU capabilities.

**Key changes:**

1. **Removed constant and added dynamic function**:
   The hardcoded `MAX_VIEW_DECALS` constant was removed and replaced with a `max_view_decals()` function that checks for the `PARTIALLY_BOUND_BINDING_ARRAY` feature.

```rust
// Before:
pub(crate) const MAX_VIEW_DECALS: usize = 8;

// After: (the constant was removed entirely)
// The functionality moved to the max_view_decals() function
```

2. **Updated binding layout creation**:
   The `get_bind_group_layout_entries()` function now uses the dynamic limit instead of the hardcoded constant.

```rust
// Before:
binding_types::texture_2d(TextureSampleType::Float { filterable: true })
    .count(NonZero::<u32>::new(MAX_VIEW_DECALS as u32).unwrap()),

// After:
binding_types::texture_2d(TextureSampleType::Float { filterable: true })
    .count(NonZero::<u32>::new(max_view_decals(render_device)).unwrap()),
```

3. **Conditional padding logic**:
   The padding of texture views to fill the binding array is now conditional based on feature support.

```rust
// Before (always padded):
while texture_views.len() < MAX_VIEW_DECALS {
    texture_views.push(&*fallback_image.d2.texture_view);
}

// After (conditional padding):
if !render_device
    .features()
    .contains(WgpuFeatures::PARTIALLY_BOUND_BINDING_ARRAY)
{
    let max_view_decals = max_view_decals(render_device);
    while texture_views.len() < max_view_decals as usize {
        texture_views.push(&*fallback_image.d2.texture_view);
    }
}
```

4. **New feature-checking function**:
   Added the `max_view_decals()` function that determines the limit based on GPU capabilities.

```rust
fn max_view_decals(render_device: &RenderDevice) -> u32 {
    if render_device
        .features()
        .contains(WgpuFeatures::PARTIALLY_BOUND_BINDING_ARRAY)
    {
        1024
    } else {
        8
    }
}
```

## Further Reading

1. **WebGPU and wgpu Documentation**:
   - [WebGPU Specification](https://www.w3.org/TR/webgpu/)
   - [wgpu Documentation](https://docs.rs/wgpu/latest/wgpu/)

2. **Binding Arrays and Partial Binding**:
   - [WebGPU Binding Model](https://www.w3.org/TR/webgpu/#binding-model)
   - [Partially Bound Binding Arrays in Vulkan](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#features-partiallyBound)

3. **Clustered Forward Rendering**:
   - [Clustered Shading Presentation](http://www.humus.name/Articles/PracticalClusteredShading.pdf)
   - [Bevy PBR Documentation](https://docs.rs/bevy_pbr/latest/bevy_pbr/)

4. **Performance Considerations for Binding Arrays**:
   - [GPU-Driven Rendering Pipelines](https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-reservoir-resampling/)
   - [Bindless Texture Best Practices](https://developer.nvidia.com/blog/bindless-texturing-for-deferred-rendering-and-decals/)