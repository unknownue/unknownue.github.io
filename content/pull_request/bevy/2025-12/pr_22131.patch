diff --git a/crates/bevy_gltf/src/loader/extensions/mod.rs b/crates/bevy_gltf/src/loader/extensions/mod.rs
index d024f39175c94..370b767f723b1 100644
--- a/crates/bevy_gltf/src/loader/extensions/mod.rs
+++ b/crates/bevy_gltf/src/loader/extensions/mod.rs
@@ -99,18 +99,11 @@ pub trait GltfExtensionHandler: Send + Sync {
     }
 
     /// Called when an individual texture is processed
-    /// Unlike other hooks, this hook does not receive its glTF
-    /// object due to internal constraints.
     #[expect(
         unused,
         reason = "default trait implementations do not use the arguments because they are no-ops"
     )]
-    fn on_texture(
-        &mut self,
-        extension_data: Option<&serde_json::Map<String, serde_json::Value>>,
-        texture: Handle<bevy_image::Image>,
-    ) {
-    }
+    fn on_texture(&mut self, gltf_texture: &gltf::Texture, texture: Handle<bevy_image::Image>) {}
 
     /// Called when an individual material is processed
     #[expect(
diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
index 68e5eb41dc69d..d18324a3ba9b0 100644
--- a/crates/bevy_gltf/src/loader/mod.rs
+++ b/crates/bevy_gltf/src/loader/mod.rs
@@ -644,10 +644,7 @@ impl GltfLoader {
                 image.process_loaded_texture(load_context, &mut texture_handles);
                 // let extensions handle texture data
                 for extension in extensions.iter_mut() {
-                    extension.on_texture(
-                        texture.extensions(),
-                        texture_handles.last().unwrap().clone(),
-                    );
+                    extension.on_texture(&texture, texture_handles.last().unwrap().clone());
                 }
             }
         } else {
@@ -658,9 +655,8 @@ impl GltfLoader {
                         let asset_path = load_context.path().clone();
                         let linear_textures = &linear_textures;
                         let buffer_data = &buffer_data;
-                        let extension_data = gltf_texture.extensions().map(ToOwned::to_owned);
                         scope.spawn(async move {
-                            let result = load_image(
+                            load_image(
                                 gltf_texture,
                                 buffer_data,
                                 linear_textures,
@@ -669,23 +665,19 @@ impl GltfLoader {
                                 default_sampler,
                                 settings,
                             )
-                            .await;
-                            (extension_data, result)
+                            .await
                         });
                     });
                 })
                 .into_iter()
-                .for_each(|(extension_data, result)| match result {
+                // order is preserved if the futures are only spawned from the root scope
+                .zip(gltf.textures())
+                .for_each(|(result, texture)| match result {
                     Ok(image) => {
                         image.process_loaded_texture(load_context, &mut texture_handles);
                         // let extensions handle texture data
-                        // We do this differently here because of the IoTaskPool vs
-                        // gltf::Texture lifetimes
                         for extension in extensions.iter_mut() {
-                            extension.on_texture(
-                                extension_data.as_ref(),
-                                texture_handles.last().unwrap().clone(),
-                            );
+                            extension.on_texture(&texture, texture_handles.last().unwrap().clone());
                         }
                     }
                     Err(err) => {
