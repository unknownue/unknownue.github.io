+++
title = "#21408 Refactor `EntityEvent` to support `ContainsEntity`, unlocking the use of kinded entities with observers"
date = "2025-12-16T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21408-en-20251216" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21408-zh-cn-20251216" }}
labels = ["A-ECS", "M-Migration-Guide", "X-Controversial", "D-Modest", "S-Needs-SME"]
+++

# Title

## Basic Information
- **Title**: Refactor `EntityEvent` to support `ContainsEntity`, unlocking the use of kinded entities with observers
- **PR Link**: https://github.com/bevyengine/bevy/pull/21408
- **Author**: Zeenobit
- **Status**: MERGED
- **Labels**: A-ECS, M-Migration-Guide, X-Controversial, D-Modest, S-Needs-SME
- **Created**: 2025-10-05T21:39:30Z
- **Merged**: 2025-12-16T02:21:14Z
- **Merged By**: cart

## Description Translation

这个PR与 #21384 相关。

# 目标

此次更改的目标是让 `EntityEvent` 能够与任何实现 `ContainsEntity` 的类实体类型一起工作。

## 解决方案

- 将 `EntityEvent::event_target` 的返回类型从 `Entity` 改为 `&impl ContainsEntity`
- 在所有适当的调用点使用 `event_target().entity()` 而不是 `event_target()`
- 将 `EntityEvent::event_target_mut` 重构为 `EntityEvent::set_event_target`

我目前对这个解决方案还不完全满意，但开这个PR是为了讨论接下来的选择。

主要问题围绕 `set_event_target`。为了实现这个功能，我们需要底层类型能够从实体构造。从用户的角度来看，这可能并不总是安全的（例如，对于 `Instance<T>` 就不安全）。

根据我对系统的理解，事件的目标只有在事件传播的情况下才会被改变，这是合理的。

为了解决这个问题，我建议将 `EntityEvents` 标记为**不可变的**或不是；或者"不可传播的"或不是（我接受其他术语！:P）。

这将允许我们将 `set_event_target` 实现为 `unreachable()!`，并在用户尝试传播此类事件时抛出错误。我们甚至可能通过编译时检查来强制执行，但这需要额外的复杂性（主要是以不同排列组合的 `trigger_*` 方法族的形式）。

## 测试

- 添加了 `test_derive_entity_event` 来覆盖所有排列组合

## The Story of This Pull Request

这个PR的核心问题是Bevy的实体事件系统缺乏灵活性。原来的`EntityEvent` trait直接使用`Entity`类型作为事件目标，这限制了系统使用更复杂的"类实体"类型，比如带有类型的实体包装器（kinded entities）或者特定的实体标识符。

在原始设计中，`EntityEvent` trait有两个方法：
- `event_target(&self) -> Entity`：获取事件目标实体
- `event_target_mut(&mut self) -> &mut Entity`：获取事件目标的可变引用

这种设计有几个限制：
1. 只能使用原始的`Entity`类型，不能使用实现了`ContainsEntity` trait的自定义类型
2. `event_target_mut`方法允许在事件触发过程中修改目标，这可能不是所有情况都需要的
3. 对于事件传播（propagation）场景，需要修改目标实体，但并非所有事件类型都支持这种操作

开发者采取了分步解决方案。首先，将`event_target`方法改为返回实现了`ContainsEntity` trait的类型，而不是具体的`Entity`。这使得任何实现了该trait的类型都可以作为事件目标。

```rust
// 之前：
fn event_target(&self) -> Entity;

// 之后：
fn event_target(&self) -> &impl ContainsEntity;
```

然后，为了处理事件传播场景，开发者引入了新的`SetEntityEventTarget` trait，将设置目标实体的操作分离出来：

```rust
pub trait SetEntityEventTarget: EntityEvent {
    fn set_event_target(&mut self, entity: Entity);
}
```

这个分离是关键的设计决策。通过将可变操作移到单独的trait中，默认情况下所有`EntityEvent`都是不可变的。只有在需要事件传播功能时，事件类型才需要实现`SetEntityEventTarget`。

在事件传播的具体实现中，`PropagateEntityTrigger`现在要求事件实现`SetEntityEventTarget`，并使用`set_event_target`方法来更新目标：

```rust
// 之前使用 event_target_mut
*event.event_target_mut() = current_entity;

// 之后使用 set_event_target
event.set_event_target(current_entity);
```

在宏层面，`derive(EntityEvent)`现在会根据是否标记了`#[entity_event(propagate)]`来条件性地实现`SetEntityEventTarget`：

```rust
// 在宏实现中
let set_entity_event_target_impl = if propagate {
    quote! {
        impl #impl_generics #bevy_ecs_path::event::SetEntityEventTarget for #struct_name #type_generics #where_clause {
            fn set_event_target(&mut self, entity: #bevy_ecs_path::entity::Entity) {
                self.#entity_field = Into::into(entity);
            }
        }
    }
} else {
    quote! {}
};
```

这种条件性实现确保了只有明确标记为可传播的事件才能被传播。对于使用自定义类型作为事件目标的情况，只有当该类型实现了`From<Entity>`时，才能支持传播。

测试用例`test_derive_entity_event`展示了各种组合：
- 常规实体事件（不可变）
- 可传播的实体事件
- 使用自定义`ContainsEntity`类型的不可变事件
- 使用实现了`From<Entity>`的自定义类型的可传播事件

这个PR的技术难点在于平衡灵活性和安全性。通过引入`SetEntityEventTarget` trait，系统现在可以：
1. 支持任何实现了`ContainsEntity`的类型作为事件目标
2. 默认情况下保证事件不可变性
3. 仅在明确需要时启用事件传播功能
4. 为不支持传播的事件类型提供编译时保护

迁移指南明确指出，原来使用`event_target_mut`的代码需要调整为使用新的trait系统。这个改变是向后兼容的，因为不可变事件仍然可以工作，只有需要传播功能的事件才需要额外实现`SetEntityEventTarget`。

## Visual Representation

```mermaid
graph TD
    A[EntityEvent trait] --> B[event_target method]
    A --> C[Requires ContainsEntity]
    D[SetEntityEventTarget trait] --> E[set_event_target method]
    F[Event Propagation] --> D
    G[#[derive(EntityEvent)] macro] --> H[Conditional SetEntityEventTarget impl]
    H --> I[propagate attribute controls implementation]
    C --> J[Enables kinded entities]
    E --> K[Enables event retargeting]
```

## Key Files Changed

### 1. `crates/bevy_ecs/src/event/mod.rs` (+163/-3)

这是主要的实现文件，包含了trait定义的变化和新增的测试用例。

**关键变化：**
- 修改了`EntityEvent` trait，移除了`event_target_mut`方法
- 新增了`SetEntityEventTarget` trait来处理事件目标的可变操作
- 更新了文档说明新的设计模式
- 添加了全面的测试用例来验证各种实体事件配置

```rust
// 之前：
pub trait EntityEvent: Event {
    fn event_target(&self) -> Entity;
    fn event_target_mut(&mut self) -> &mut Entity;
}

// 之后：
pub trait EntityEvent: Event {
    fn event_target(&self) -> Entity;
}

pub trait SetEntityEventTarget: EntityEvent {
    fn set_event_target(&mut self, entity: Entity);
}
```

### 2. `crates/bevy_ecs/macros/src/event.rs` (+15/-5)

这是派生宏的实现文件，负责自动生成实体事件的实现代码。

**关键变化：**
- 根据`propagate`属性条件性地生成`SetEntityEventTarget`实现
- 更新`event_target`方法实现以使用`ContainsEntity::entity()`

```rust
// 宏现在根据propagate标志生成不同的代码
let set_entity_event_target_impl = if propagate {
    quote! {
        impl #impl_generics #bevy_ecs_path::event::SetEntityEventTarget for #struct_name #type_generics #where_clause {
            fn set_event_target(&mut self, entity: #bevy_ecs_path::entity::Entity) {
                self.#entity_field = Into::into(entity);
            }
        }
    }
} else {
    quote! {}
};
```

### 3. `crates/bevy_ecs/src/event/trigger.rs` (+3/-2)

这个文件处理事件触发逻辑，特别是事件传播机制。

**关键变化：**
- 更新`PropagateEntityTrigger`以使用新的`set_event_target`方法
- 在trait约束中添加`SetEntityEventTarget`要求

```rust
// 之前：
*event.event_target_mut() = current_entity;

// 之后：
event.set_event_target(current_entity);
```

### 4. `release-content/migration-guides/immutable-entity-events.md` (+11/-0)

新增的迁移指南，解释了API变化和对现有代码的影响。

**内容：**
```markdown
The mutable methods of `EntityEvent` (`EntityEvent::from` and `EntityEvent::event_target_mut`)
have been moved to a separate trait: `SetEntityEventTarget`

This makes all `EntityEvents` immutable by default.

`SetEntityEventTarget` is implemented automatically for propagated events (e.g. `#[entity_event(propagate)]`).
```

## Further Reading

1. **Bevy ECS Event System Documentation**: 了解Bevy事件系统的基本原理
2. **Entity Component System Patterns**: 学习ECS架构中事件处理的常见模式
3. **Rust Trait Design Patterns**: 深入理解如何使用trait来构建灵活的API
4. **Type-driven API Design in Rust**: 学习如何通过类型系统设计安全且易用的API