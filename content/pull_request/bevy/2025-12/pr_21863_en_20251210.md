+++
title = "#21863 Fix immediate nested loaded assets not loading their dependencies."
date = "2025-12-10T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21863-en-20251210" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21863-zh-cn-20251210" }}
labels = ["C-Bug", "D-Trivial", "A-Assets"]
+++

# Fix immediate nested loaded assets not loading their dependencies

## Basic Information
- **Title**: Fix immediate nested loaded assets not loading their dependencies.
- **PR Link**: https://github.com/bevyengine/bevy/pull/21863
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: C-Bug, D-Trivial, A-Assets, S-Ready-For-Final-Review
- **Created**: 2025-11-16T22:00:32Z
- **Merged**: 2025-12-09T23:50:10Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

- Previously if you loaded an immediate nested asset, it would **not** load any of its dependencies. This means that you could have handles in your asset that would never load.
- Fixes #20988

## Solution

- Propagate loading dependencies to immediate asset loads.
- I also deduped some test App setup code.

## Testing

- Added a test.

One case that does have a slightly undesirable effect is when you immediately-load an asset, take some data from it (but no dependency handles), and then drop the immediately-loaded asset. This change will now also initiate a dependency load, even though we won't use it.

However, A) it is much more surprising to have a handle that will never be loaded, B) we should end up cancelling the dependency load once we drop the handle, so we shouldn't pay too much of the cost of loading.

## The Story of This Pull Request

The asset system in Bevy provides two ways to load assets during asset processing: deferred loading and immediate loading. When an asset loader needs to reference another asset, it typically uses `load_context.load(asset_path)` for deferred loading, which returns a `Handle` that will be populated asynchronously. However, sometimes you need to load an asset synchronously within the loading process - for example, when you need data from that asset to construct the current asset. This is done using `load_context.loader().immediate().load(asset_path)`.

The bug in PR #21863 was subtle but significant. When using immediate loading, the dependencies of the immediately-loaded asset were not being loaded. This meant that if you had an asset that immediately-loaded another asset which itself had dependencies, those nested dependencies would never start loading. The result was asset handles that would remain in the "NotLoaded" state indefinitely.

Consider this scenario:
1. Asset A (ImmediateNested) loads asset B immediately
2. Asset B (DeferredNested) has a dependency on asset C, loaded with `load_context.load("c.txt")`
3. Without the fix, asset C would never load, even though asset B's handle to C is valid

The root cause was in the `LoadContext::immediate()` method. When performing an immediate load, it was calling `load_internal()` with `should_load_dependencies: false`. This made sense for some contexts like asset preprocessing, but not for the general case of immediate loading during normal asset loading. The fix was straightforward: propagate the current context's `should_load_dependencies` flag to the immediate load.

However, this change has a trade-off. If you immediately-load an asset, extract some data from it (without keeping dependency handles), and then drop the asset, the system will now also load its dependencies unnecessarily. The PR author acknowledges this but argues it's acceptable because:
1. It's more surprising and problematic to have handles that never load
2. The dependency load should be cancelled when the handle is dropped, minimizing the performance impact

To ensure the fix worked correctly, a comprehensive test was added that creates a chain of assets: an immediate-loaded asset that references a deferred-loaded asset that has its own dependency. The test verifies that all assets in the chain load correctly.

The PR also includes significant test refactoring. Many tests were creating App instances with similar setup code for in-memory asset storage. The author extracted a `create_app()` helper function that sets up a basic asset app with an in-memory file system, reducing code duplication and making tests more maintainable.

## Visual Representation

```mermaid
graph TD
    A[ImmediateNestedLoader] -->|immediate().load()| B[DeferredNestedLoader]
    B -->|load()| C[TrivialLoader]
    
    D[Before Fix] -->|Problem| E[Dependency C never loads]
    F[After Fix] -->|Solution| G[should_load_dependencies: true propagates]
    G --> H[All dependencies load correctly]
    
    I[Asset A] --> J[Asset B]
    J --> K[Asset C]
    K --> L[All assets load]
```

## Key Files Changed

### 1. `crates/bevy_asset/src/loader.rs`
**What changed**: Modified the `load_internal` call in the `immediate()` method to pass through the `should_load_dependencies` flag from the current context.

**Why**: To ensure that immediate asset loads trigger dependency loading when appropriate.

```rust
// File: crates/bevy_asset/src/loader.rs
// Before:
let (handle, loaded_asset) = self
    .asset_server
    .load_internal(
        asset_path,
        meta,
        loader,
        reader,
        false,  // Hardcoded false - dependencies won't load
        self.populate_hashes,
    )
    .await?;

// After:
let (handle, loaded_asset) = self
    .asset_server
    .load_internal(
        asset_path,
        meta,
        loader,
        reader,
        self.should_load_dependencies,  // Use context's flag
        self.populate_hashes,
    )
    .await?;
```

### 2. `crates/bevy_asset/src/lib.rs`
**What changed**: Added a new test `immediate_nested_asset_loads_dependency` and refactored test setup code to reduce duplication.

**Why**: To verify the fix works correctly and improve test maintainability.

**Key test addition**:
```rust
#[test]
fn immediate_nested_asset_loads_dependency() {
    let (mut app, dir) = create_app();
    
    // Test setup with three asset types:
    // 1. ImmediateNested - loads DeferredNested immediately
    // 2. DeferredNested - loads TestAsset (dependency)
    // 3. TestAsset - simple asset
    
    // ... loader implementations ...
    
    dir.insert_asset_text(Path::new("a.immediate"), "b.defer");
    dir.insert_asset_text(Path::new("b.defer"), "c.txt");
    dir.insert_asset_text(Path::new("c.txt"), "hiya");
    
    let server = app.world().resource::<AssetServer>().clone();
    let immediate_handle: Handle<ImmediateNested> = server.load("a.immediate");
    
    // Run until all assets are loaded
    run_app_until(&mut app, |world| {
        let immediate_assets = world.resource::<Assets<ImmediateNested>>();
        let immediate = immediate_assets.get(&immediate_handle)?;
        
        let test_asset_handle = immediate.0.clone();
        world
            .resource::<Assets<TestAsset>>()
            .get(&test_asset_handle)?;
        
        // The immediate asset is loaded, and the asset it got from 
        // its immediate load is also loaded.
        Some(())
    });
}
```

**Refactoring**: Created a `create_app()` helper function that replaces repeated test setup code:

```rust
/// Creates a basic asset app and an in-memory file system.
fn create_app() -> (App, Dir) {
    let mut app = App::new();
    let dir = Dir::default();
    let dir_clone = dir.clone();
    app.register_asset_source(
        AssetSourceId::Default,
        AssetSourceBuilder::new(move || {
            Box::new(MemoryAssetReader {
                root: dir_clone.clone(),
            })
        }),
    )
    .add_plugins((
        TaskPoolPlugin::default(),
        AssetPlugin::default(),
        DiagnosticsPlugin,
    ));
    (app, dir)
}
```

## Further Reading

1. [Bevy Asset System Documentation](https://docs.rs/bevy_asset/latest/bevy_asset/) - Comprehensive guide to Bevy's asset system
2. [Issue #20988](https://github.com/bevyengine/bevy/issues/20988) - The original bug report that prompted this fix
3. [Bevy Assets Example](https://github.com/bevyengine/bevy/blob/main/examples/asset/asset_loading.rs) - Example showing different asset loading patterns
4. [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/) - Understanding async/await patterns used in asset loaders