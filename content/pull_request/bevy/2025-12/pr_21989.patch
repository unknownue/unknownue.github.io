diff --git a/assets/shaders/array_texture.wgsl b/assets/shaders/array_texture.wgsl
index 1bc6c46c404bf..73dfadba20c06 100644
--- a/assets/shaders/array_texture.wgsl
+++ b/assets/shaders/array_texture.wgsl
@@ -1,5 +1,6 @@
 #import bevy_pbr::{
     forward_io::VertexOutput,
+    mesh_functions,
     mesh_view_bindings::view,
     pbr_types::{STANDARD_MATERIAL_FLAGS_DOUBLE_SIDED_BIT, PbrInput, pbr_input_new},
     pbr_functions as fns,
@@ -15,7 +16,9 @@ fn fragment(
     @builtin(front_facing) is_front: bool,
     mesh: VertexOutput,
 ) -> @location(0) vec4<f32> {
-    let layer = i32(mesh.world_position.x) & 0x3;
+    // Determine which layer of the array texture to sample from based on the
+    // mesh tag which originates from the MeshTag component on the entity.
+    let layer = mesh_functions::get_tag(mesh.instance_index);
 
     // Prepare a 'processed' StandardMaterial by sampling all textures to resolve
     // the material members
diff --git a/examples/shader/array_texture.rs b/examples/shader/array_texture.rs
index b91872725ab3a..e17763dde132a 100644
--- a/examples/shader/array_texture.rs
+++ b/examples/shader/array_texture.rs
@@ -1,17 +1,23 @@
-//! This example illustrates how to create a texture for use with a `texture_2d_array<f32>` shader
-//! uniform variable.
+//! This example illustrates how to create a texture for use with a
+//! `texture_2d_array<f32>` shader uniform variable and then how to sample from
+//! that texture in the shader by using a `MeshTag` component on the mesh
+//! entity.
 
 use bevy::{
     image::{ImageArrayLayout, ImageLoaderSettings},
+    mesh::MeshTag,
     prelude::*,
     reflect::TypePath,
     render::render_resource::AsBindGroup,
     shader::ShaderRef,
 };
 
-/// This example uses a shader source file from the assets subdirectory
+/// This example uses a shader source file from the assets subdirectory.
 const SHADER_ASSET_PATH: &str = "shaders/array_texture.wgsl";
 
+/// Corresponds to the number of layers in the array texture.
+const TEXTURE_COUNT: u32 = 4;
+
 fn main() {
     App::new()
         .add_plugins((
@@ -19,6 +25,7 @@ fn main() {
             MaterialPlugin::<ArrayTextureMaterial>::default(),
         ))
         .add_systems(Startup, setup)
+        .add_systems(Update, update_mesh_tags)
         .run();
 }
 
@@ -32,7 +39,9 @@ fn setup(
     let array_texture = asset_server.load_with_settings(
         "textures/array_texture.png",
         |settings: &mut ImageLoaderSettings| {
-            settings.array_layout = Some(ImageArrayLayout::RowCount { rows: 4 });
+            settings.array_layout = Some(ImageArrayLayout::RowCount {
+                rows: TEXTURE_COUNT,
+            });
         },
     );
 
@@ -48,18 +57,37 @@ fn setup(
         Transform::from_xyz(5.0, 5.0, 5.0).looking_at(Vec3::new(1.5, 0.0, 0.0), Vec3::Y),
     ));
 
-    // Spawn some cubes using the array texture
+    // Spawn some cubes using the array texture.
     let mesh_handle = meshes.add(Cuboid::default());
     let material_handle = materials.add(ArrayTextureMaterial { array_texture });
     for x in -5..=5 {
         commands.spawn((
             Mesh3d(mesh_handle.clone()),
             MeshMaterial3d(material_handle.clone()),
+            // Pass a different mesh tag to allow selecting different layers of
+            // the array texture in the shader.
+            MeshTag(x as u32 % TEXTURE_COUNT),
             Transform::from_xyz(x as f32 + 0.5, 0.0, 0.0),
         ));
     }
 }
 
+fn update_mesh_tags(time: Res<Time>, mut query: Query<&mut MeshTag>, mut timer: Local<Timer>) {
+    // Initialize the timer on the first run.
+    if timer.duration().is_zero() {
+        *timer = Timer::from_seconds(1.5, TimerMode::Repeating);
+    }
+
+    timer.tick(time.delta());
+    if timer.just_finished() {
+        for mut tag in query.iter_mut() {
+            // Cycle through the texture layers to demonstrate that we can
+            // select different layers of the array texture at runtime.
+            tag.0 = (tag.0 + 1) % TEXTURE_COUNT;
+        }
+    }
+}
+
 #[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
 struct ArrayTextureMaterial {
     #[texture(0, dimension = "2d_array")]
