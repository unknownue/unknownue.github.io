+++
title = "#20647 Optimize BundleInserter::insert compile time"
date = "2025-12-16T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-20647-en-20251216" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-20647-zh-cn-20251216" }}
labels = ["A-ECS", "C-Performance", "S-Needs-Benchmarking", "D-Unsafe"]
+++

# Title

## Basic Information
- **Title**: Optimize BundleInserter::insert compile time
- **PR Link**: https://github.com/bevyengine/bevy/pull/20647
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: A-ECS, C-Performance, S-Needs-Benchmarking, D-Unsafe, S-Needs-Review
- **Created**: 2025-08-19T00:57:46Z
- **Merged**: 2025-12-16T02:11:04Z
- **Merged By**: cart

## Description Translation

# Objective

- Optimize clean compile time by 10%

## Solution

- Factor out non-generic code from generic function that is called a lot

Main: (92s total)
<img width="769" height="988" alt="image" src="https://github.com/user-attachments/assets/3faaa4bc-bd0c-4664-a9e2-9c14a5156a97" />

This PR: (82s total)
<img width="694" height="951" alt="image" src="https://github.com/user-attachments/assets/1797e26a-9516-4180-af2a-3671ed908ee3" />

## The Story of This Pull Request

This PR addresses a common performance issue in Rust projects that make heavy use of generics: compile time bloat due to excessive monomorphization. The problem was observed in Bevy's ECS system, specifically in the `BundleInserter::insert` method, which is a critical path for entity component manipulation.

The core issue was straightforward but had significant impact. The `BundleInserter::insert` method is generic over the type of bundle being inserted (`T: DynamicBundle`). Every time this method is called with a different bundle type, the Rust compiler generates a separate copy (monomorphizes) of the entire function body. While this generic implementation is necessary for type safety and performance at runtime, it creates compile time overhead because much of the function's logic doesn't actually depend on the specific bundle type `T`.

The developer measured compile times before and after the change, showing a reduction from 92 seconds to 82 seconds for a clean build—a 10% improvement. This is significant in a large codebase like Bevy where compile times directly impact developer productivity.

The solution approach was to identify and extract the non-generic portions of the `insert` method into separate helper functions. By doing this, only the parts that truly depend on the generic type parameter `T` remain in the monomorphized code, while the common logic is compiled only once. This is a standard technique in Rust optimization known as "extracting non-generic code from generic functions."

The implementation involved creating two new helper methods: `before_insert` and `after_insert`. The `before_insert` method handles all the preparation work that doesn't depend on the specific bundle type, including:
- Triggering replace observers when in `InsertMode::Replace`
- Determining whether the entity stays in the same archetype, moves to a new archetype in the same table, or moves to a new archetype in a new table
- Allocating space in tables and updating entity locations

The `after_insert` method handles post-insertion logic that also doesn't depend on the bundle type, including:
- Triggering add observers
- Triggering remove observers for components that were replaced
- Handling relationship hooks

The core generic operation—writing the actual component data into storage—remains in the main `insert` method via the `write_components` call, which must be monomorphized for each bundle type since it handles the actual component data.

A key technical detail in the implementation is the use of `#[cfg_attr(not(debug_assertions), inline(always))]` on the helper functions. This ensures that in release builds, these functions are always inlined to avoid any runtime performance penalty from the additional function calls. In debug builds, they're not forced to inline, which helps with compile time and debugging. This demonstrates a careful balance between compile time optimization and runtime performance.

The refactoring also required careful handling of unsafe code. The original `insert` method had multiple safety requirements documented, and these were preserved and properly distributed between the new helper functions. The `before_insert` method returns several values needed by the generic `write_components` call, including references to the sparse sets, table, and the computed table row.

From an architectural perspective, this change doesn't alter the behavior of the ECS system—it only changes how the code is organized for compilation. The runtime behavior remains identical, which is verified by existing tests. The main benefit is reduced binary size (due to less duplicated code) and faster compilation times.

The impact of this change extends beyond just the immediate compile time improvement. It also sets a precedent for similar optimizations elsewhere in the codebase. Other generic functions that have significant non-generic portions could benefit from the same pattern. Additionally, the cleaner separation of concerns makes the code slightly more maintainable, with the generic and non-generic logic more clearly separated.

## Visual Representation

```mermaid
graph TD
    A[Original insert method] --> B[Fully monomorphized<br>for each bundle type]
    A --> C[New approach]
    C --> D[before_insert (non-generic)]
    C --> E[write_components (generic)]
    C --> F[after_insert (non-generic)]
    
    B --> G[92s compile time]
    D --> H[Compiled once]
    E --> I[Compiled per bundle type]
    F --> J[Compiled once]
    H --> K[82s compile time]
    I --> K
    J --> K
```

## Key Files Changed

### `crates/bevy_ecs/src/bundle/insert.rs` (+124/-67)

This file contains the `BundleInserter` implementation, which handles inserting bundles (groups of components) into entities. The main change refactors the `insert` method to extract non-generic code into separate helper functions.

**Key modifications:**

1. **Extracted `before_insert` method**: This non-generic method handles the preparatory work before writing component data.

```rust
// New helper method
#[cfg_attr(not(debug_assertions), inline(always))]
unsafe fn before_insert<'a>(
    entity: Entity,
    location: EntityLocation,
    insert_mode: InsertMode,
    caller: MaybeLocation,
    relationship_hook_mode: RelationshipHookMode,
    mut table: NonNull<Table>,
    mut archetype: NonNull<Archetype>,
    archetype_after_insert: &ArchetypeAfterBundleInsert,
    world: &'a UnsafeWorldCell<'w>,
    archetype_move_type: &'a mut ArchetypeMoveType,
) -> (
    &'a Archetype,
    EntityLocation,
    &'a mut SparseSets,
    &'a mut Table,
    TableRow,
) {
    // ... non-generic preparation code ...
}
```

2. **Extracted `after_insert` method**: This non-generic method handles cleanup and observer triggering after component data is written.

```rust
// New helper method
#[cfg_attr(not(debug_assertions), inline(always))]
fn after_insert(
    entity: Entity,
    insert_mode: InsertMode,
    caller: MaybeLocation,
    relationship_hook_mode: RelationshipHookMode,
    archetype_after_insert: &ArchetypeAfterBundleInsert,
    new_archetype: &Archetype,
    mut deferred_world: crate::world::DeferredWorld<'_>,
) {
    // ... non-generic cleanup code ...
}
```

3. **Refactored `insert` method**: The main method now orchestrates the two helper methods and the generic `write_components` call.

```rust
// Refactored insert method
#[inline]
pub(crate) unsafe fn insert<T: DynamicBundle>(
    &mut self,
    entity: Entity,
    location: EntityLocation,
    bundle: MovingPtr<'_, T>,
    insert_mode: InsertMode,
    caller: MaybeLocation,
    relationship_hook_mode: RelationshipHookMode,
) -> EntityLocation {
    let archetype_after_insert = self.archetype_after_insert.as_ref();

    let (new_archetype, new_location) = {
        // Non-generic prelude extracted to improve compile time
        let (new_archetype, new_location, sparse_sets, table, table_row) = Self::before_insert(
            entity,
            location,
            insert_mode,
            caller,
            relationship_hook_mode,
            self.table,
            self.archetype,
            archetype_after_insert,
            &self.world,
            &mut self.archetype_move_type,
        );

        // Generic part remains here
        self.bundle_info.as_ref().write_components(
            table,
            sparse_sets,
            archetype_after_insert,
            archetype_after_insert.required_components.iter(),
            entity,
            table_row,
            self.change_tick,
            bundle,
            insert_mode,
            caller,
        );

        (new_archetype, new_location)
    };

    // Non-generic postlude extracted to improve compile time
    Self::after_insert(
        entity,
        insert_mode,
        caller,
        relationship_hook_mode,
        archetype_after_insert,
        new_archetype,
        deferred_world,
    );

    new_location
}
```

## Further Reading

1. **Rust Performance Book - Compile Times**: Official documentation on optimizing Rust compile times
2. **Monomorphization in Rust**: Understanding how Rust handles generics at compile time
3. **Bevy ECS Architecture**: Documentation on Bevy's Entity Component System design
4. **Inline Attributes in Rust**: When and how to use inline attributes for performance optimization