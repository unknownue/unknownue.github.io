+++
title = "#13797 Implement the infrastructure needed to support portals and mirrors."
date = "2025-12-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-13797-en-20251209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-13797-zh-cn-20251209" }}
+++

# Title

## 基本资料
- **标题**: Implement the infrastructure needed to support portals and mirrors.
- **PR 链接**: https://github.com/bevyengine/bevy/pull/13797
- **作者**: pcwalton
- **状态**: 已合并
- **标签**: C-Feature, A-Rendering, S-Ready-For-Final-Review, A-Math, M-Release-Note
- **创建时间**: 2024-06-10T18:55:21Z
- **合并时间**: 2025-12-09T23:32:50Z
- **合并者**: alice-i-cecile

## 描述翻译
实现支持门户（portals）和镜子（mirrors）所需的基础设施。

Bevy 目前支持多摄像头（multiple cameras）和渲染到离屏渲染目标（off-screen render targets），因此有人可能会天真地认为引擎已经支持门户和镜子了。然而，Bevy 目前缺少实现门户和镜子的两个关键功能：

1. Bevy 既不支持自定义裁剪平面（custom clip planes），也不支持倾斜裁剪平面（oblique clip planes）。这阻碍了构建正确的门户或镜子，因为与门户平面相交的网格必须被裁剪才能正确渲染。

2. Bevy 不支持反转剔除模式（invert the culling mode）的相机，因此跨越平面反射的网格将会内外颠倒地渲染。

本 PR 解决了上述两个问题：

1. 本次提交在 `PerspectiveProjection` 上引入了一个新字段 `near_clip_plane`，允许应用程序指定一个自定义的近平面。该功能完全启用了 [Lengyel 倾斜裁剪](https://terathon.com/lengyel/Lengyel-Oblique.pdf)，这是实现自定义近裁剪平面的最优方式。它使我们无需支持自定义裁剪平面，而后者在硬件中通常实现效率低下。

2. 本补丁在 `Camera` 组件上添加了一个新字段 `invert_culling`。该字段导致 Bevy 渲染器在渲染该相机可见的对象时反转前向面（front face）设置。当与相机上适当设置的 [Householder 矩阵](https://en.wikipedia.org/wiki/Householder_transformation) 结合使用时，这允许正确渲染跨平面反射的对象。

此外，本 PR 在 `bevy_math::mat3` 中添加了一个新函数 `reflection_matrix`。这会生成将对象跨平面反射的矩阵，适合编码到 `Transform` 中。为了方便使用，已完整记录。

最后，添加了一个新示例 `mirror`。这个示例是一个可工作的镜子的完整实例，它结合了带有 Householder 矩阵的相机、倾斜投影、反向剔除以及自定义材质，来渲染一个动画网格及其平面反射。鼠标可以移动相机和网格，并且存储镜中世界渲染内容的离屏渲染目标会在用户调整窗口大小时正确调整大小。

<img width="2564" height="1500" alt="Screenshot 2025-12-05 212155" src="https://github.com/user-attachments/assets/35652b58-a9a5-415a-bdff-367889a23b9f" />

## 本次 Pull Request 的故事

这个 PR 解决了在 Bevy 中实现逼真的镜面或传送门效果时遇到的两个核心渲染问题。虽然引擎已具备多相机和渲染到纹理的能力，但要正确渲染一个“反射世界”或“传送门另一侧的世界”，还需要处理几何体在镜面处的裁剪以及反射导致的三角形缠绕顺序反转。本次修改通过添加两个相互配合的核心功能来解决这些问题。

**问题与背景**
问题的核心在于，当使用第二个相机来渲染一个虚拟的“反射世界”时，这个世界的观察视锥体（frustum）需要被镜面平面严格裁剪。标准的近裁剪平面是垂直于观察方向的，而镜面可能是任意角度的，因此需要一个通用的“倾斜近裁剪平面”功能。此外，对世界应用反射变换（例如通过一个 Householder 矩阵）会翻转每个三角形的顶点顺序（缠绕顺序， winding order）。在大多数渲染管线中，默认的背面剔除（backface culling）会剔除顺时针（或逆时针）缠绕的三角形。反射后，原本应该被剔除的背面变成了正面，导致物体看起来是“透明”或缺失的。因此，需要一种方法来告诉渲染器：“对这个相机看到的物体，反转你的剔除逻辑”。

**解决方案与实现**
解决方案分为数学层、数据层和渲染管线层。

首先，在数据层扩展了两个核心结构体。在 `crates/bevy_camera/src/camera.rs` 中，为 `Camera` 组件添加了一个 `invert_culling: bool` 字段。这是一个直观的开关，其文档清楚地说明了它用于处理反射导致的缠绕顺序翻转。同时，在 `crates/bevy_camera/src/projection.rs` 中，为 `PerspectiveProjection` 结构体添加了 `near_clip_plane: Vec4` 字段。这个 `Vec4` 以齐次坐标形式 `(nx, ny, nz, d)` 定义了一个平面，其中 `(nx, ny, nz)` 是观察空间中的单位法线（指向相机外侧），`d` 是平面到原点的负距离（即 `-(n·q)`，`q` 是平面上任意一点）。默认值 `(0,0,-1,-near)` 对应着标准的近平面。

最关键的部分是实现倾斜裁剪。这个功能没有通过硬件扩展（如 `GL_CLIP_DISTANCE`）实现，而是采用了更高效、更广泛兼容的软件方法：修改投影矩阵。在 `PerspectiveProjection` 的 `get_clip_from_view` 和相关方法中，在生成标准透视矩阵后，会调用一个新的私有方法 `adjust_perspective_matrix_for_clip_plane`。这个方法实现了 Lengyel 在 2005 年论文《Oblique Depth Projection and View Frustum Clipping》中描述的算法。算法的核心思想是：当用户指定了一个任意的近裁剪平面 `C` 后，需要调整投影矩阵的第三行（在 Vulkan 反转 Z 的约定下，这行对应于近/远平面的定义），使得变换后的视锥体能够紧密贴合这个自定义平面 `C`，同时保持远平面在无穷远处。PR 中的代码注释非常详尽，逐步推导了在 Bevy 使用的坐标系（Reversed-Z, Infinite Far）下，如何从原始论文的公式进行转换，最终计算出新的矩阵行 `M'₃ = (0,0,-1,0) - aC`，其中缩放因子 `a = -Qz / (C·Q)`，`Q` 是视锥体在自定义平面相反方向上的一个角点。这个修改是纯数学的，发生在 CPU 端构建矩阵时，对 GPU 渲染管线是透明的，兼容性极佳。

为了方便用户构建反射变换，在数学库中添加了工具函数。在新建的 `crates/bevy_math/src/mat3.rs` 中，提供了 `reflection_matrix(plane_normal: Vec3) -> Mat3A` 函数。它返回一个 3x3 的 Householder 反射矩阵 `I - 2 * n * nᵀ`，其中 `n` 是平面法线。用户可以将其与平移矩阵组合，构建出完整的反射世界变换。

**管线集成与材质适配**
有了数据，下一步是让渲染管线感知这些新属性。`Camera` 的 `invert_culling` 字段需要通过提取系统传播。在 `crates/bevy_render/src/camera.rs` 的 `extract_cameras` 系统中，该字段被复制到了 `ExtractedView` 中（相应地在 `crates/bevy_render/src/view/mod.rs` 的 `ExtractedView` 结构体中也添加了该字段）。接着，在准备渲染管线时，这个信息被编码到一个管线密钥（Pipeline Key）中。在 `crates/bevy_pbr/src/render/mesh.rs` 中，`MeshPipelineKey` 这个位标志（bitflags）添加了一个新的标志 `INVERT_CULLING` (第 23 位)。在 `check_views_need_specialization` 和 `prepare_deferred_lighting_pipelines` 等系统中，会根据 `ExtractedView.invert_culling` 来设置这个密钥。

最后，在材质处理阶段响应这个密钥。修改位于 `crates/bevy_pbr/src/pbr_material.rs` 的 `Material::specialize` 方法中。原先的剔除模式逻辑只考虑材质自身的 `CULL_FRONT` 和 `CULL_BACK` 标志。新的逻辑加入了对 `MeshPipelineKey::INVERT_CULLING` 的检查，形成了一个三元匹配关系：当视图需要反转剔除时，材质请求剔除前面就变成实际剔除后面，反之亦然。这个逻辑清晰地实现了“为这个视图翻转所有材质的剔除规则”的语义。

**示例：把所有部分组合起来**
新的示例 `examples/3d/mirror.rs` 是本次功能的最佳实践文档。它创建了一个场景，包含一个主相机、一个地面、一个动画狐狸模型，以及一个镜面平面。其核心工作流程在 `calculate_mirror_camera_transform_and_projection` 函数中：
1.  **反射相机变换**：使用 `reflection_matrix(Vec3::NEG_Z)` 生成一个绕 Z=0 平面反射的矩阵，然后乘以主相机的世界变换矩阵，得到反射相机的世界变换。注意这里使用矩阵乘法而非组合 `Transform`，以避免非均匀缩放的问题。
2.  **倾斜裁剪平面**：计算镜面在观察空间中的法线，以及主相机到镜面的有符号距离。这两个值构成了 `near_clip_plane` 的四个分量，用于初始化反射相机的 `PerspectiveProjection`。
3.  **反转剔除**：将反射相机 `Camera` 组件的 `invert_culling` 设为 `true`。
4.  **渲染目标**：反射相机渲染到一个动态创建的 `Image` 渲染目标。
5.  **镜面显示**：镜面本身使用一个自定义的 `ExtendedMaterial`。其扩展部分 `ScreenSpaceTextureExtension` 使用了新的着色器 `assets/shaders/screen_space_texture_material.wgsl`。这个着色器的关键操作是 `textureLoad(emissive_texture, vec2<i32>(floor(in.position.xy)), 0)`，它直接使用片元的屏幕空间坐标来采样反射相机的渲染结果（存储在 `emissive_texture` 中），从而将反射图像“贴”到镜面网格上，实现了完美的屏幕空间对齐效果。

此外，示例还处理了窗口大小变化时动态调整渲染目标分辨率、用户通过鼠标交互控制相机或狐狸模型等细节，展示了一个生产级功能所需的所有环节。

**影响与总结**
本次 PR 为 Bevy 引擎增加了实现高级光学效果（镜子、水面反射、传送门）的基础设施。其实现具有以下特点：
- **非侵入性**：新功能通过可选字段添加，不影响现有代码。
- **性能友好**：倾斜裁剪在 CPU 端通过修改矩阵实现，无需 GPU 特殊配置或多次渲染通道。
- **概念清晰**：`invert_culling` 和 `near_clip_plane` 的概念直接对应图形学中的已知问题和解法。
- **文档完备**：核心结构字段、数学函数和示例都配有详细注释和文档。
它为社区开发相关插件和效果奠定了坚实基础，是图形功能模块一个非常标准的增量演进范例。

## 可视化关系图

```mermaid
graph TB
    subgraph “用户接口/数据层”
        A[Camera.invert_culling]
        B[PerspectiveProjection.near_clip_plane]
        M[bevy_math::reflection_matrix]
    end

    subgraph “渲染提取阶段”
        C[ExtractedView.invert_culling]
    end

    subgraph “管线准备阶段”
        D[MeshPipelineKey.INVERT_CULLING]
    end

    subgraph “材质/渲染阶段”
        E[StandardMaterial.specialize 剔除逻辑]
        F[投影矩阵调整]
        G[ScreenSpaceTextureMaterial 示例着色器]
    end

    A --> C
    B --> F
    M -->|用于构建反射相机| F
    C --> D
    D --> E
    F -->|产生最终裁剪矩阵| G
```

## 关键文件变更

1.  **`crates/bevy_camera/src/camera.rs`** (+9/-0)
    - **变更原因**：为 `Camera` 组件添加 `invert_culling` 字段，作为控制视图级剔除反转的开关。
    - **关键代码**:
        ```rust
        // 在 Camera 结构体中新增字段
        /// Whether to switch culling mode so that materials that request backface
        /// culling cull front faces, and vice versa.
        ///
        /// This is typically used for cameras that mirror the world that they
        /// render across a plane, because doing that flips the winding of each
        /// polygon.
        ///
        /// This setting doesn't affect materials that disable backface culling.
        pub invert_culling: bool,
        ```
    - **与 PR 目标的关联**：这是实现反射渲染所需两个核心功能之一（反转剔除）的数据载体。

2.  **`crates/bevy_camera/src/projection.rs`** (+106/-4)
    - **变更原因**：在 `PerspectiveProjection` 中添加对自定义/倾斜近裁剪平面的支持，并实现 Lengyel 算法来调整投影矩阵。
    - **关键代码** (节选):
        ```rust
        // 新增字段
        pub near_clip_plane: Vec4,

        // 在 get_clip_from_view 等方法中调用调整函数
        fn get_clip_from_view(&self) -> Mat4 {
            let mut matrix =
                Mat4::perspective_infinite_reverse_rh(self.fov, self.aspect_ratio, self.near);
            self.adjust_perspective_matrix_for_clip_plane(&mut matrix);
            matrix
        }

        // 核心的倾斜裁剪算法实现
        fn adjust_perspective_matrix_for_clip_plane(&self, matrix: &mut Mat4) {
            if self.near_clip_plane == vec4(0.0, 0.0, -1.0, -self.near) {
                return;
            }
            let c = self.near_clip_plane;
            let q_prime = vec4(c.x.signum(), c.y.signum(), 0.0, 1.0);
            let q = matrix.inverse() * q_prime;
            let a = -q.z / c.dot(q);
            let m3_prime = Vec4::NEG_Z - c * a;
            matrix.x_axis.z = m3_prime.x;
            matrix.y_axis.z = m3_prime.y;
            matrix.z_axis.z = m3_prime.z;
            matrix.w_axis.z = m3_prime.w;
        }
        ```
    - **与 PR 目标的关联**：这是实现门户和镜子所需两个核心功能之二（自定义裁剪平面）的核心实现，通过修改投影矩阵实现高效裁剪。

3.  **`crates/bevy_math/src/mat3.rs`** (+30/-0)
    - **变更原因**：提供一个工具函数来生成反射变换矩阵，方便用户构建镜子或对称世界。
    - **关键代码**:
        ```rust
        pub fn reflection_matrix(plane_normal: Vec3) -> Mat3A {
            let n_nt = Mat3A::from_cols(
                Vec3A::from(plane_normal) * plane_normal.x,
                Vec3A::from(plane_normal) * plane_normal.y,
                Vec3A::from(plane_normal) * plane_normal.z,
            );
            Mat3A::IDENTITY - n_nt * 2.0
        }
        ```
    - **与 PR 目标的关联**：为构建反射相机的变换提供了必要的数学工具，是使用 `invert_culling` 和 `near_clip_plane` 功能的前提步骤之一。

4.  **`crates/bevy_pbr/src/pbr_material.rs`** (+13/-9)
    - **变更原因**：修改标准材质的管线特化（specialize）逻辑，使其能够响应视图级别的 `INVERT_CULLING` 标志，从而动态翻转剔除面。
    - **关键代码**:
        ```rust
        // 修改后的剔除模式判断逻辑
        descriptor.primitive.cull_mode = match (
            key.bind_group_data.contains(StandardMaterialKey::CULL_FRONT),
            key.bind_group_data.contains(StandardMaterialKey::CULL_BACK),
            key.mesh_key.contains(MeshPipelineKey::INVERT_CULLING),
        ) {
            (true, false, false) | (false, true, true) => Some(Face::Front),
            (false, true, false) | (true, false, true) => Some(Face::Back),
            _ => None,
        };
        ```
    - **与 PR 目标的关联**：这是将 `invert_culling` 数据最终影响 GPU 渲染行为的关键环节，确保了反射相机中的物体能被正确剔除。

5.  **`examples/3d/mirror.rs`** (+677/-0) 与 **`assets/shaders/screen_space_texture_material.wgsl`** (+37/-0)
    - **变更原因**：创建一个完整的、可工作的镜子示例，展示如何组合运用本次 PR 引入的所有新功能。
    - **关键代码** (节选自 `mirror.rs`):
        ```rust
        // 计算反射相机的变换和投影
        let (mirror_camera_transform, mirror_camera_projection) =
            calculate_mirror_camera_transform_and_projection(
                camera_transform,
                camera_projection,
                mirror_transform,
            );
        // 创建反射相机，启用反转剔除
        commands.spawn((
            Camera3d::default(),
            Camera {
                invert_culling: true, // <- 关键设置
                ..default()
            },
            mirror_camera_transform,
            Projection::Perspective(mirror_camera_projection), // <- 包含 near_clip_plane
            MirrorCamera,
        ));
        ```
    - **关键代码** (节选自 `screen_space_texture_material.wgsl`):
        ```wgsl
        // 使用屏幕坐标直接采样反射纹理
        pbr_input.material.emissive = vec4(
            textureLoad(emissive_texture, vec2<i32>(floor(in.position.xy)), 0).rgb,
            0.0
        );
        ```
    - **与 PR 目标的关联**：示例是本次 PR 功能的综合演示和验收测试，展示了从数学计算、相机配置、渲染目标管理到最终屏幕合成的完整流程。新增的着色器是实现屏幕空间反射显示的关键组件。

## 延伸阅读

1.  **Lengyel, Eric. “Oblique Depth Projection and View Frustum Clipping.” *Journal of Game Development*, vol. 1, no. 2, 2005.** - 这是实现倾斜裁剪平面的核心论文，PR 中的算法直接基于此论文并适配了 Vulkan 坐标系。
2.  **Wikipedia: [Householder transformation](https://en.wikipedia.org/wiki/Householder_transformation)** - 详细解释了 Householder 反射变换的数学原理，这是生成反射矩阵的基础。
3.  **《Real-Time Rendering, 4th Edition》** - 第三部分“渲染管线”中关于裁剪、坐标系变换和投影的章节，有助于深入理解裁剪平面的概念和投影矩阵的作用。
4.  **Bevy 官方文档关于 [Camera](https://docs.rs/bevy/latest/bevy/camera/struct.Camera.html) 和 [Projection](https://docs.rs/bevy/latest/bevy/camera/projection/trait.CameraProjection.html) 的部分** - 结合本次 PR 的改动，可以更好地理解 Bevy 相机系统的工作机制。
5.  **OpenGL / Vulkan 图形 API 规范中关于裁剪平面（Clip Planes）和剔除（Culling）的章节** - 有助于理解这些功能在底层硬件和驱动层面的支持情况，以及为何软件实现（如本 PR）有时是更优选择。