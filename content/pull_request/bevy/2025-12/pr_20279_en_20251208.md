+++
title = "#20279 UI material z-offset override"
date = "2025-12-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-20279-en-20251208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-20279-zh-cn-20251208" }}
labels = ["C-Feature", "D-Trivial", "A-UI"]
+++

# Title

## Basic Information
- **Title**: UI material z-offset override
- **PR Link**: https://github.com/bevyengine/bevy/pull/20279
- **Author**: ickshonpe
- **Status**: MERGED
- **Labels**: C-Feature, D-Trivial, A-UI, S-Ready-For-Final-Review
- **Created**: 2025-07-25T00:15:31Z
- **Merged**: 2025-12-08T21:55:16Z
- **Merged By**: mockersf

## Description Translation
# Objective

In #20237 the swatch implementation uses a child node to display the foreground color because UI materials have a higher local z offset than everything else.

## Solution

Add a `stack_z_offset` function to the `UiMaterial` trait that can be overriden to set a custom z-offset.

## The Story of This Pull Request

This PR addresses a specific rendering ordering issue in Bevy's UI system. The problem emerged from PR #20237, which implemented a swatch UI component. The developer encountered an issue where UI materials always render with a higher z-offset than regular UI elements, making it impossible to layer child nodes on top of material-based parent elements within the same UI hierarchy.

The core issue was architectural: UI materials use a fixed z-offset value (`stack_z_offsets::MATERIAL`) that places them above all other UI elements in the rendering order. This fixed offset was hardcoded in the rendering pipeline, making it impossible for custom UI materials to control their rendering depth relative to their child nodes.

The developer took a clean, minimal approach by adding configurability at the trait level. Rather than changing the rendering pipeline to support dynamic offsets or introducing complex configuration systems, they extended the `UiMaterial` trait with a new method `stack_z_offset()` that returns the z-offset for that material type. This maintains the existing default behavior while allowing materials to override the offset when needed.

The implementation demonstrates a classic Rust pattern: adding a default trait method that can be overridden by implementors. The `UiMaterial` trait already had several default methods for shader configuration, so this fits naturally into the existing design. The key insight was that by making this a static method (called with `M::stack_z_offset()`), each material type can define its own constant offset, maintaining compile-time determinism while providing flexibility.

In `ui_material.rs`, the new trait method provides the default implementation that returns the existing constant:
```rust
fn stack_z_offset() -> f32 {
    crate::stack_z_offsets::MATERIAL
}
```

The real impact comes in `ui_material_pipeline.rs`, where the rendering system uses this method instead of the hardcoded constant:
```rust
// Before:
sort_key: FloatOrd(extracted_uinode.stack_index as f32 + stack_z_offsets::MATERIAL),

// After:
sort_key: FloatOrd(extracted_uinode.stack_index as f32 + M::stack_z_offset()),
```

This change is subtle but powerful. It allows UI material authors to control their rendering order relative to child nodes, which was previously impossible. For the swatch example from PR #20237, this means the foreground color can now be implemented directly within the material rather than requiring a separate child node, simplifying the UI hierarchy and improving performance.

The solution is elegant because it maintains backward compatibility—existing materials continue to work without modification—while solving a real-world problem that was forcing developers to create workarounds. It also follows Rust's philosophy of making zero-cost abstractions: the trait method call is statically resolved at compile time, so there's no runtime overhead compared to the previous hardcoded constant.

## Visual Representation

```mermaid
graph TD
    A[UiMaterial Trait] --> B[stack_z_offset method]
    B --> C[Default: returns MATERIAL constant]
    B --> D[Can be overridden by implementors]
    E[Render Pipeline] --> F[Uses M::stack_z_offset()]
    F --> G[Controls rendering order]
    G --> H[Enables proper layering with child nodes]
```

## Key Files Changed

### `crates/bevy_ui_render/src/ui_material.rs` (+4/-0)
1. **What changed**: Added a new `stack_z_offset()` method to the `UiMaterial` trait with a default implementation that returns the existing `MATERIAL` constant.
2. **Why**: To provide a way for UI materials to customize their z-offset for rendering order.
3. **Code snippet**:
```rust
fn stack_z_offset() -> f32 {
    crate::stack_z_offsets::MATERIAL
}
```

### `crates/bevy_ui_render/src/ui_material_pipeline.rs` (+1/-1)
1. **What changed**: Modified the rendering pipeline to use the trait method `M::stack_z_offset()` instead of the hardcoded constant `stack_z_offsets::MATERIAL`.
2. **Why**: To allow each material type to control its own z-offset, enabling proper layering with child UI nodes.
3. **Code snippet**:
```rust
// Before:
sort_key: FloatOrd(extracted_uinode.stack_index as f32 + stack_z_offsets::MATERIAL),

// After:
sort_key: FloatOrd(extracted_uinode.stack_index as f32 + M::stack_z_offset()),
```

## Further Reading

1. [Bevy UI Rendering Documentation](https://docs.rs/bevy_ui_render/latest/bevy_ui_render/) - For understanding the UI rendering pipeline
2. [Bevy Materials System](https://bevyengine.org/learn/book/next/features/materials/) - General information about Bevy's material system
3. [Rust Trait Default Methods](https://doc.rust-lang.org/book/ch10-02-traits.html) - For understanding how default trait methods work
4. [PR #20237](https://github.com/bevyengine/bevy/pull/20237) - The original swatch implementation that motivated this change