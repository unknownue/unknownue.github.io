diff --git a/Cargo.toml b/Cargo.toml
index aa3982b0c3a12..5adaeb5bad60c 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -10,7 +10,7 @@ keywords = ["game", "engine", "gamedev", "graphics", "bevy"]
 license = "MIT OR Apache-2.0"
 repository = "https://github.com/bevyengine/bevy"
 documentation = "https://docs.rs/bevy"
-rust-version = "1.88.0"
+rust-version = "1.89.0"
 
 [workspace]
 resolver = "2"
diff --git a/crates/bevy_ecs/Cargo.toml b/crates/bevy_ecs/Cargo.toml
index 98b9c33bb07c8..14da777c6900d 100644
--- a/crates/bevy_ecs/Cargo.toml
+++ b/crates/bevy_ecs/Cargo.toml
@@ -8,7 +8,7 @@ repository = "https://github.com/bevyengine/bevy"
 license = "MIT OR Apache-2.0"
 keywords = ["ecs", "game", "bevy"]
 categories = ["game-engines", "data-structures"]
-rust-version = "1.86.0"
+rust-version = "1.89.0"
 
 [features]
 default = ["std", "bevy_reflect", "async_executor", "backtrace"]
diff --git a/crates/bevy_ecs/src/error/bevy_error.rs b/crates/bevy_ecs/src/error/bevy_error.rs
index c290e249b2cfd..352162ae826a1 100644
--- a/crates/bevy_ecs/src/error/bevy_error.rs
+++ b/crates/bevy_ecs/src/error/bevy_error.rs
@@ -191,10 +191,10 @@ mod tests {
 
         // On mac backtraces can start with Backtrace::create
         let mut skip = false;
-        if let Some(line) = lines.peek() {
-            if &line[6..] == "std::backtrace::Backtrace::create" {
-                skip = true;
-            }
+        if let Some(line) = lines.peek()
+            && &line[6..] == "std::backtrace::Backtrace::create"
+        {
+            skip = true;
         }
 
         if skip {
@@ -212,10 +212,10 @@ mod tests {
             let line = lines.next().unwrap();
             assert_eq!(&line[6..], expected);
             let mut skip = false;
-            if let Some(line) = lines.peek() {
-                if line.starts_with("             at") {
-                    skip = true;
-                }
+            if let Some(line) = lines.peek()
+                && line.starts_with("             at")
+            {
+                skip = true;
             }
 
             if skip {
@@ -225,19 +225,19 @@ mod tests {
 
         // on linux there is a second call_once
         let mut skip = false;
-        if let Some(line) = lines.peek() {
-            if &line[6..] == "core::ops::function::FnOnce::call_once" {
-                skip = true;
-            }
+        if let Some(line) = lines.peek()
+            && &line[6..] == "core::ops::function::FnOnce::call_once"
+        {
+            skip = true;
         }
         if skip {
             lines.next().unwrap();
         }
         let mut skip = false;
-        if let Some(line) = lines.peek() {
-            if line.starts_with("             at") {
-                skip = true;
-            }
+        if let Some(line) = lines.peek()
+            && line.starts_with("             at")
+        {
+            skip = true;
         }
 
         if skip {
diff --git a/crates/bevy_ecs/src/storage/blob_array.rs b/crates/bevy_ecs/src/storage/blob_array.rs
index 3ef2e5a90d007..bab0aad03c443 100644
--- a/crates/bevy_ecs/src/storage/blob_array.rs
+++ b/crates/bevy_ecs/src/storage/blob_array.rs
@@ -42,7 +42,10 @@ impl BlobArray {
     ) -> Self {
         if capacity == 0 {
             let align = NonZeroUsize::new(item_layout.align()).expect("alignment must be > 0");
-            let data = bevy_ptr::dangling_with_align(align);
+
+            // Create a dangling pointer with the given alignment.
+            let data = NonNull::without_provenance(align);
+
             Self {
                 item_layout,
                 drop: drop_fn,
diff --git a/crates/bevy_ptr/src/lib.rs b/crates/bevy_ptr/src/lib.rs
index e76fcc9f57250..f59a02496afda 100644
--- a/crates/bevy_ptr/src/lib.rs
+++ b/crates/bevy_ptr/src/lib.rs
@@ -12,7 +12,6 @@ use core::{
     fmt::{self, Debug, Formatter, Pointer},
     marker::PhantomData,
     mem::{self, ManuallyDrop, MaybeUninit},
-    num::NonZeroUsize,
     ops::{Deref, DerefMut},
     ptr::{self, NonNull},
 };
@@ -1139,16 +1138,6 @@ impl<'a, T> From<&'a [T]> for ThinSlicePtr<'a, T> {
     }
 }
 
-/// Creates a dangling pointer with specified alignment.
-/// See [`NonNull::dangling`].
-pub const fn dangling_with_align(align: NonZeroUsize) -> NonNull<u8> {
-    debug_assert!(align.is_power_of_two(), "Alignment must be power of two.");
-    // SAFETY: The pointer will not be null, since it was created
-    // from the address of a `NonZero<usize>`.
-    // TODO: use https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.with_addr once stabilized
-    unsafe { NonNull::new_unchecked(ptr::null_mut::<u8>().wrapping_add(align.get())) }
-}
-
 mod private {
     use core::cell::UnsafeCell;
 
diff --git a/release-content/migration-guides/remove_dangling_with_align.md b/release-content/migration-guides/remove_dangling_with_align.md
new file mode 100644
index 0000000000000..71fbd10e859c9
--- /dev/null
+++ b/release-content/migration-guides/remove_dangling_with_align.md
@@ -0,0 +1,14 @@
+---
+title: Remove `bevy::ptr::dangling_with_align()`
+pull_requests: [21822]
+---
+
+`bevy::ptr::dangling_with_align()` has been removed. Use `NonNull::without_provenance()` instead:
+
+```rust
+// 0.17
+let ptr = dangling_with_align(align);
+
+// 0.18
+let ptr = NonNull::without_provenance(align);
+```
