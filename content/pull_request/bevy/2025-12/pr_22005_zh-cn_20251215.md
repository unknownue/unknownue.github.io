+++
title = "#22005 Make BRP builtins utilities `parse` and `parse_some` public"
date = "2025-12-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22005-en-20251215" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22005-zh-cn-20251215" }}
+++

# 标题
Make BRP builtins utilities `parse` and `parse_some` public

## 基本信息
- **标题**: Make BRP builtins utilities `parse` and `parse_some` public
- **PR链接**: https://github.com/bevyengine/bevy/pull/22005
- **作者**: Nilirad
- **状态**: 已合并
- **标签**: D-Trivial, C-Usability, S-Ready-For-Final-Review, A-Networking
- **创建时间**: 2025-12-02T10:04:45Z
- **合并时间**: 2025-12-15T02:38:26Z
- **合并者**: alice-i-cecile

## 描述翻译
# 目标

内置的BRP方法在解析工具中频繁使用 `parse` 和 `parse_some`。将它们公开允许用户在自己的代码中使用它们。

## 解决方案

将两个函数设为 `pub`。

## 测试

我认为测试不是必需的，特别是因为文档字符串没有链接到任何地方。

## 本次PR的故事

在Bevy引擎的远程模块（`bevy_remote`）中，BRP（Bevy Remote Protocol）内置方法提供了核心的网络通信功能。这些内置方法在处理JSON-RPC请求和响应时，需要频繁地解析`serde_json::Value`类型的数据。开发者在实现这些内置方法时，编写了两个工具函数来统一处理这种解析逻辑：`parse` 和 `parse_some`。

**问题与背景**
`parse` 函数负责将一个 `serde_json::Value` 反序列化为任何实现了 `Deserialize` trait 的类型 `T`，并在失败时返回一个格式化的 `BrpError`。`parse_some` 函数则是对 `Option<Value>` 的包装，处理值为 `None` 的情况。在本次PR修改之前，这两个函数被定义为模块私有的（`fn`），这意味着只有`builtin_methods.rs`文件内的其他函数可以调用它们。

然而，在实际开发中，当用户需要在自己的自定义BRP方法或扩展功能中执行相同的JSON解析操作时，他们不得不重新实现完全相同的错误处理和类型转换逻辑。这导致了代码重复，并且如果BRP的错误码或错误信息格式发生改变，用户的代码将无法同步更新，从而可能引发不一致的行为。这是一个典型的工具函数可见性不足导致的可用性问题。

**解决方案与实现**
解决这个问题的方法非常直接且成本很低：将这两个内部工具函数的可见性从私有（`fn`）提升为公开（`pub fn`）。这样做遵循了Rust模块系统的一个常见模式：当某个内部辅助函数被证明具有通用价值时，将其公开可以为库的使用者提供便利，并促进代码一致性。

具体的修改只涉及两个关键字。在 `crates/bevy_remote/src/builtin_methods.rs` 文件中：
1.  将 `fn parse` 改为 `pub fn parse`。
2.  将 `fn parse_some` 改为 `pub fn parse_some`。

这个修改是向后兼容的。原有的、调用这两个函数的内部代码完全不受影响，因为它们原本就在同一模块内，已经拥有访问权限。修改只是将访问权限扩展到了模块外部。

**技术细节与考量**
这两个函数的设计本身是健壮的：
- `parse` 函数使用了 `for<'de> Deserialize<'de>` 的高阶trait bound（HRTB），这确保类型 `T` 能够被任何生命周期的数据反序列化，这是处理从网络接收的、生命周期可能不确定的数据时的标准做法。
- 错误处理是统一的：任何 `serde_json::from_value` 产生的错误都会被转换为一个具有特定 `error_codes::INVALID_PARAMS` 代码的 `BrpError`。`parse_some` 在输入为 `None` 时也会返回一个结构相同的错误。这种一致性对于网络协议的错误响应至关重要。

通过公开这两个函数，用户现在可以像下面这样使用它们：
```rust
use bevy_remote::builtin_methods::{parse, parse_some};

// 解析一个明确的 JSON Value
let my_struct: MyStruct = parse(some_value)?;

// 解析一个可能为 None 的 Option<Value>
let my_other_struct: MyOtherStruct = parse_some(some_optional_value)?;
```
这消除了用户自己编写错误处理逻辑的需要，并确保了他们产生的错误与Bevy远程协议内置方法产生的错误在格式上完全一致。

**影响**
这个改动虽然很小，但显著提升了 `bevy_remote` crate 的开发者体验（DX）。它体现了良好的API设计实践：识别出内部重复使用的、逻辑稳定的工具函数，并将其作为公共API的一部分提供出去。这减少了使用该库的开发者的样板代码，降低了出错几率，并提高了整个生态系统中错误处理的一致性。由于改动只是增加了可见性，没有改变任何行为，因此风险极低，这也是PR作者和审阅者认为无需额外测试的原因。

## 视觉表示

```mermaid
graph TD
    subgraph “crates/bevy_remote/src/builtin_methods.rs”
        A[私有函数 parse] -->|修改为| B[公开函数 parse]
        C[私有函数 parse_some] -->|修改为| D[公开函数 parse_some]
    end
    
    E[BRP内置方法] --> B
    E --> D
    F[用户自定义代码] -.->|之前无法访问| B
    F -->|现在可以访问| B
    F -->|现在可以访问| D
```

## 关键文件变更

- **文件**: `crates/bevy_remote/src/builtin_methods.rs` (+2/-2)

该文件包含了Bevy远程协议（BRP）的所有内置方法实现。本次PR修改了两个内部工具函数的可见性，使其可被模块外部的用户代码使用。

**代码片段**:
```rust
// 文件：crates/bevy_remote/src/builtin_methods.rs
// 修改前（第466行）：
fn parse<T: for<'de> Deserialize<'de>>(value: Value) -> Result<T, BrpError> {
    serde_json::from_value(value).map_err(|err| BrpError {
        code: error_codes::INVALID_PARAMS,
        message: err.to_string(),
    })
}

// 修改后：
pub fn parse<T: for<'de> Deserialize<'de>>(value: Value) -> Result<T, BrpError> {
    serde_json::from_value(value).map_err(|err| BrpError {
        code: error_codes::INVALID_PARAMS,
        message: err.to_string(),
    })
}
```

```rust
// 文件：crates/bevy_remote/src/builtin_methods.rs
// 修改前（第475行）：
fn parse_some<T: for<'de> Deserialize<'de>>(value: Option<Value>) -> Result<T, BrpError> {
    match value {
        Some(value) => parse(value),
        None => Err(BrpError {
            code: error_codes::INVALID_PARAMS,
            message: "Missing parameters".to_string(),
        }),
    }
}

// 修改后：
pub fn parse_some<T: for<'de> Deserialize<'de>>(value: Option<Value>) -> Result<T, BrpError> {
    match value {
        Some(value) => parse(value),
        None => Err(BrpError {
            code: error_codes::INVALID_PARAMS,
            message: "Missing parameters".to_string(),
        }),
    }
}
```
这些变更直接服务于PR的目标：将已经广泛在BRP内部使用的、成熟的解析工具暴露给公共API，提升代码的复用性和一致性。

## 延伸阅读
- **[Rust Book: 使用 `pub` 控制可见性](https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#controlling-visibility-with-pub)**: 了解Rust中模块和可见性的基本规则。
- **[Serde JSON](https://docs.serde.rs/serde_json/)**: 了解 `serde_json::from_value` 函数以及如何操作 `Value` 枚举类型。
- **[Rust 高级特性：HRTB](https://doc.rust-lang.org/nomicon/hrtb.html)**: 深入理解 `for<'de> Deserialize<'de>` 这种高阶trait bound的含义和使用场景。
- **[API 设计指南：何时将内部函数公开](https://rust-lang.github.io/api-guidelines/)**: 更广泛的API设计原则，包括识别哪些内部功能可以作为公共API的一部分。

## 完整代码差异
```diff
diff --git a/crates/bevy_remote/src/builtin_methods.rs b/crates/bevy_remote/src/builtin_methods.rs
index abe8881731fc0..7c3164cb82e15 100644
--- a/crates/bevy_remote/src/builtin_methods.rs
+++ b/crates/bevy_remote/src/builtin_methods.rs
@@ -463,7 +463,7 @@ pub struct BrpQueryRow {
 }
 
 /// A helper function used to parse a `serde_json::Value`.
-fn parse<T: for<'de> Deserialize<'de>>(value: Value) -> Result<T, BrpError> {
+pub fn parse<T: for<'de> Deserialize<'de>>(value: Value) -> Result<T, BrpError> {
     serde_json::from_value(value).map_err(|err| BrpError {
         code: error_codes::INVALID_PARAMS,
         message: err.to_string(),
@@ -472,7 +472,7 @@ fn parse<T: for<'de> Deserialize<'de>>(value: Value) -> Result<T, BrpError> {
 }
 
 /// A helper function used to parse a `serde_json::Value` wrapped in an `Option`.
-fn parse_some<T: for<'de> Deserialize<'de>>(value: Option<Value>) -> Result<T, BrpError> {
+pub fn parse_some<T: for<'de> Deserialize<'de>>(value: Option<Value>) -> Result<T, BrpError> {
     match value {
         Some(value) => parse(value),
         None => Err(BrpError {
```