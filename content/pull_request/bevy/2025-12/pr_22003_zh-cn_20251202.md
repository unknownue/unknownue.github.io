+++
title = "#22003 Add debug_group to render graph"
date = "2025-12-02T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22003-en-20251202" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22003-zh-cn-20251202" }}
labels = ["C-Feature", "A-Rendering", "D-Modest"]
+++

# Title
Add debug_group to render graph

## Basic Information
- **Title**: Add debug_group to render graph
- **PR Link**: https://github.com/bevyengine/bevy/pull/22003
- **Author**: IceSentry
- **Status**: MERGED
- **Labels**: C-Feature, A-Rendering, D-Modest, S-Needs-Review
- **Created**: 2025-12-02T05:42:55Z
- **Merged**: 2025-12-02T17:58:12Z
- **Merged By**: mockersf

## Description Translation

### 目标（Objective）
- 调试包含多个摄像头的应用可能会非常麻烦，因为一眼很难看出哪个渲染通道（pass）属于哪个摄像头。
- wgpu 暴露了一个功能，可以设置 debug_group，用于在成组的渲染通道和绘制命令周围添加标签。

### 解决方案（Solution）
- 向渲染图（render graph）暴露 debug_group 功能。
    - 每个子图（sub graph）现在都可以指定一个 debug group。
- 为每个摄像头添加一个新的调试组标签，包含摄像头序号（order）和实体ID。
- 我还将新的 debug_group 添加到了 tracy span 中，以便更轻松地查看哪个 span 与哪个摄像头相关联。

### 测试（Testing）
- 我测试了 `3d_scene` 和 `split_screen` 示例。

---

### 效果展示（Showcase）

这是之前的样子：
<img width="1626" height="98" alt="ngfx-ui_cH0BZAQWh9" src="https://github.com/user-attachments/assets/ef8cdb59-f402-45cd-b2f9-90d315e8e411" />

这是在 Nvidia NSight 中应用了新的调试组标签后 `split_screen` 示例的样子。可以清楚地看到每个摄像头都被明确标识。
<img width="1933" height="125" alt="ngfx-ui_t4L2AheYS3" src="https://github.com/user-attachments/assets/980c4c7f-c933-44b8-8bfb-34406221bf06" />

## The Story of This Pull Request

**问题与背景**：在开发使用多摄像头的图形应用时，调试渲染流程是一个常见的痛点。例如，在分屏（split screen）或画中画等场景中，多个摄像头会触发各自的渲染子图。当我们在 GPU 性能分析工具（如 Nvidia NSight Graphics 或 RenderDoc）中查看渲染命令队列时，各个摄像头产生的渲染通道（pass）和绘制（draw）命令会混杂在一起，缺乏明确的归属标识。这使得开发者难以快速定位某个特定摄像头的性能瓶颈或渲染错误。虽然 Bevy 的渲染图本身有结构，但这个结构信息并没有向下传递到 wgpu 的命令编码器（command encoder）层面，因此无法在 GPU 调试工具中显示。

**解决方案思路**：现代图形 API（如 Vulkan/Metal/D3D12）及其抽象（如 wgpu）普遍支持调试组（debug group）或事件标记（event marker）功能。这允许开发者在命令缓冲区中插入带文本标签的范围，这些范围会在性能分析工具中高亮显示。这个 PR 的核心思路就是将 wgpu 的 `push_debug_group` 和 `pop_debug_group` 功能集成到 Bevy 渲染图的执行流程中。通过为每个执行的子图（特别是摄像头驱动的子图）附加一个可读的标签，就能在工具中清晰地划分出不同摄像头的渲染工作。

**实现细节**：这个功能的实现涉及渲染图数据结构和执行流程的多个层面。首先，需要在渲染图执行的上下文信息中增加一个字段来携带调试组标签。这体现在 `RunSubGraph` 结构体中新增的 `debug_group: Option<String>` 字段。这个结构体用于在节点（Node）执行过程中请求运行一个子图。

```rust
// crates/bevy_render/src/render_graph/context.rs
pub struct RunSubGraph {
    pub sub_graph: InternedRenderSubGraph,
    pub inputs: Vec<SlotValue>,
    pub view_entity: Option<Entity>,
    pub debug_group: Option<String>, // 新增字段
}
```

相应地，`RenderGraphContext::run_sub_graph` 方法的签名也进行了更新，增加了一个 `debug_group` 参数，使得节点在调用时可以传入标签。

```rust
pub fn run_sub_graph(
    &mut self,
    name: impl RenderSubGraph,
    inputs: Vec<SlotValue>,
    view_entity: Option<Entity>,
    debug_group: Option<String>, // 新增参数
) -> Result<(), RunSubGraphError>
```

最关键的执行逻辑位于 `RenderGraphRunner::run_graph` 函数中。这个函数负责实际遍历和执行一个（子）图的所有节点。在这里，函数签名也增加了 `debug_group` 参数。在执行图的开头和结尾，分别调用了 wgpu 的 `push_debug_group` 和 `pop_debug_group` 方法，从而将标签范围应用到该图执行期间发出的所有 GPU 命令上。

```rust
// crates/bevy_render/src/renderer/graph_runner.rs
if let Some(debug_group) = debug_group.as_ref() {
    render_context
        .command_encoder()
        .push_debug_group(debug_group);
}
// ... 执行图的所有节点逻辑 ...
if debug_group.is_some() {
    render_context.command_encoder().pop_debug_group();
}
```

为了让调试信息更有用，需要为特定的子图生成有意义的标签。`CameraDriverNode` 是驱动每个摄像头渲染的核心节点。它在为每个摄像头运行其专属的渲染子图时，现在会构造一个格式为 `"Camera {order} ({entity})"` 的字符串作为 `debug_group` 传入。这使得在分析工具中，每个摄像头的渲染块都能被清晰地标记上其序号和实体 ID。

```rust
// crates/bevy_render/src/render_graph/camera_driver_node.rs
graph.run_sub_graph(
    camera.render_graph,
    vec![],
    Some(sorted_camera.entity),
    Some(format!(
        "Camera {} ({})",
        sorted_camera.order, sorted_camera.entity
    )),
)?;
```

这个改动是向后兼容的。对于其他不关心调试组的子图调用点，例如 `RunGraphOnViewNode` 和 `RunUiSubgraphOnUiViewNode`，只需要传入 `None` 即可，保持了 API 的简洁性。

**技术考量与扩展性**：这个实现巧妙地利用了现有的 `Option<String>` 类型，使功能成为可选项，避免了在不使用时的开销。同时，它将标签信息也添加到了可选的 `tracy` 性能分析 span 中，为 CPU 端的性能分析也提供了更强的上下文关联性。整个设计是非侵入式的，它为渲染图系统增加了一个强大的调试功能，而不会影响正常的渲染逻辑。未来，其他需要独立标识的渲染子图也可以方便地利用这个机制。

**影响**：这个 PR 显著改善了 Bevy 应用在多摄像头场景下的可调试性。开发者现在可以使用行业标准的 GPU 调试工具直观地观察不同摄像头的渲染负载和耗时，极大地提升了定位渲染问题和进行性能优化的效率。它实现了一个小而精的功能，解决了开发中的实际痛点。

## Visual Representation

```mermaid
graph TD
    subgraph “Render Graph Execution”
        A[CameraDriverNode.run] --> B[调用 graph.run_sub_graph]
        B --> C[传递 Camera Label]
    end

    subgraph “Graph Runner”
        D[run_graph 函数] --> E{debug_group?}
        E -->|Some| F[command_encoder.push_debug_group]
        E -->|None| G[跳过]
        F --> H[执行子图节点]
        G --> H
        H --> I[command_encoder.pop_debug_group]
    end

    subgraph “GPU Profiler (e.g., NSight)”
        J[显示标记的渲染命令块]
    end

    C --> D
    F --> J
```

## Key Files Changed

1.  **`crates/bevy_render/src/renderer/graph_runner.rs` (+20/-3)**
    *   **修改描述与目的**：这是渲染图运行器的核心。修改了 `run_graph` 函数的签名和逻辑，使其能够接收并在执行前后调用 `push_debug_group` 和 `pop_debug_group`。这是将标签实际应用到 GPU 命令流的关键位置。
    *   **关键代码**：
        ```rust
        // 修改了函数签名，增加了 debug_group 参数
        fn run_graph(
            graph: &RenderGraph,
            sub_graph: Option<InternedRenderSubGraph>,
            render_context: &mut RenderContext,
            world: &World,
            inputs: &[SlotValue],
            view_entity: Option<Entity>,
            debug_group: Option<String>, // 新增
        ) -> Result<(), RenderGraphRunnerError>

        // 在执行开始时，如果有标签就压入调试组
        if let Some(debug_group) = debug_group.as_ref() {
            render_context
                .command_encoder()
                .push_debug_group(debug_group);
        }

        // 在处理 RunSubGraph 命令时，递归调用 run_graph 并传递其 debug_group
        Err(RenderGraphRunnerError::SubGraph(
                run_sub_graph.sub_graph,
                Box::new(Self::run_graph(
                    sub_graph,
                    Some(run_sub_graph.sub_graph),
                    render_context,
                    world,
                    &run_sub_graph.inputs,
                    run_sub_graph.view_entity,
                    run_sub_graph.debug_group, // 传递下去
                )?),
            ))

        // 在执行结束时，弹出调试组
        if debug_group.is_some() {
            render_context.command_encoder().pop_debug_group();
        }
        ```

2.  **`crates/bevy_render/src/render_graph/camera_driver_node.rs` (+9/-1)**
    *   **修改描述与目的**：为每个摄像头渲染时生成有意义的调试标签（包含摄像头序号和实体ID），并传递给 `run_sub_graph` 调用。这是为具体用例（摄像头）提供标签的核心节点。
    *   **关键代码**：
        ```rust
        // 修改了 run_sub_graph 调用，添加了第四个参数：调试组标签
        graph.run_sub_graph(
            camera.render_graph,
            vec![],
            Some(sorted_camera.entity),
            Some(format!( // 新增：构造标签
                "Camera {} ({})",
                sorted_camera.order, sorted_camera.entity
            )),
        )?;
        ```

3.  **`crates/bevy_render/src/render_graph/context.rs` (+3/-0)**
    *   **修改描述与目的**：在 `RunSubGraph` 指令结构体和 `run_sub_graph` 方法签名中添加 `debug_group` 字段/参数，使得调试标签信息可以在渲染图节点间传递。
    *   **关键代码**：
        ```rust
        pub struct RunSubGraph {
            // ... 其他字段
            pub debug_group: Option<String>, // 新增字段
        }

        pub fn run_sub_graph(
            &mut self,
            name: impl RenderSubGraph,
            inputs: Vec<SlotValue>,
            view_entity: Option<Entity>,
            debug_group: Option<String>, // 新增参数
        ) -> Result<(), RunSubGraphError>
        ```

4.  **`crates/bevy_render/src/render_graph/node.rs` (+1/-1)**
    *   **修改描述与目的**：更新 `RunGraphOnViewNode` 节点的 `run` 方法，以符合新的 `run_sub_graph` API（传入 `None` 作为 `debug_group`）。这是一个保持 API 兼容性的必要修改。
    *   **关键代码**：
        ```rust
        // 修改前：
        graph.run_sub_graph(self.sub_graph, vec![], Some(graph.view_entity()))?;
        // 修改后：
        graph.run_sub_graph(self.sub_graph, vec![], Some(graph.view_entity()), None)?;
        ```

5.  **`crates/bevy_ui_render/src/lib.rs` (+1/-1)**
    *   **修改描述与目的**：与 `node.rs` 中的修改类似，更新 UI 渲染子图的运行节点 `RunUiSubgraphOnUiViewNode`，以适应 API 变化。
    *   **关键代码**：
        ```rust
        // 修改前：
        graph.run_sub_graph(SubGraphUi, vec![], Some(ui_camera_view.0))?;
        // 修改后：
        graph.run_sub_graph(SubGraphUi, vec![], Some(ui_camera_view.0), None)?;
        ```

## Further Reading
1.  **wgpu Documentation on Debugging**: [The `wgpu::CommandEncoder::push_debug_group` method](https://docs.rs/wgpu/latest/wgpu/struct.CommandEncoder.html#method.push_debug_group) 提供了该功能的底层 API 细节。
2.  **NVIDIA Nsight Graphics Documentation**: [关于“工具接口”和“API 调试”的部分](https://docs.nvidia.com/nsight-graphics/UserGuide/index.html) 详细解释了如何在像 Nsight 这样的工具中利用调试组信息。
3.  **Bevy Render Graph Documentation**: Bevy 官方文档中关于 [渲染图](https://bevyengine.org/learn/advanced-topics/render-graph/) 的部分，有助于理解这个 PR 所修改的系统的基本架构和概念。