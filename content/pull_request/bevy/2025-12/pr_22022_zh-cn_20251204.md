+++
title = "#22022 Ignore text buffer metrics"
date = "2025-12-04T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22022-en-20251204" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22022-zh-cn-20251204" }}
+++

# Title

## 基本情报
- **标题**: Ignore text buffer metrics
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22022
- **作者**: ickshonpe
- **状态**: 已合并
- **标签**: C-Performance, C-Code-Quality, A-Text, D-Straightforward, S-Needs-Review
- **创建时间**: 2025-12-03T13:39:37Z
- **合并时间**: 2025-12-04T02:57:54Z
- **合并者**: cart

## 描述翻译

# 目标

由于我们为每个文本段落设置了显式的字体大小和行高属性，传递给文本缓冲区的 `Metrics` 值无关紧要。我们可以只用一些虚拟值初始化缓冲区，然后忽略它。

## 解决方案

* 将文本缓冲区初始化为一些虚拟值。
* 移除在文本更新期间收集和设置度量标准的代码。

## 本次 PR 的故事

本次 PR 的核心是一个小而精的优化，它源于对 Bevy 文本渲染管线中一个特定参数实际用途的深入理解。故事始于开发者观察到，在准备渲染文本时，系统会额外执行一些看似必要但实际冗余的计算。

**问题与背景**
在 Bevy 的文本渲染系统中，`TextPipeline` 负责处理文本组件，并将它们转换为底层文本布局库 `cosmic-text` 可以理解的格式。在之前的实现中，当构建文本布局时，代码会遍历所有文本段落(`TextSection`)，不仅加载字体，还会计算整个文本块中最大的`font_size`和`line_height`。

```rust
// 旧代码片段 (crates/bevy_text/src/pipeline.rs)
let mut max_font_size: f32 = 0.;
let mut max_line_height: f32 = 0.0;
// ... 在循环中
max_font_size = max_font_size.max(text_font.font_size);
max_line_height = max_line_height.max(line_height.eval(text_font.font_size));
```
计算出的这两个最大值随后被用来构造一个 `cosmic_text::Metrics` 对象，并传递给 `cosmic_text::Buffer`。
```rust
let mut metrics = Metrics::new(max_font_size, max_line_height).scale(scale_factor as f32);
// 防止为零的hack
metrics.font_size = metrics.font_size.max(0.000001);
metrics.line_height = metrics.line_height.max(0.000001);
// ...
buffer.set_metrics_and_size(font_system, metrics, bounds.width, bounds.height);
```
这里存在一个效率问题：为了得到这两个最大值，代码必须遍历所有段落并执行比较操作。然而，关键在于 `cosmic_text::Buffer` 的 `set_rich_text` 方法（最终被调用来设置文本内容）并不使用这个 `Metrics` 对象来进行实际的布局计算。`Metrics` 参数主要用于在未显式设置样式的情况下提供默认值。但在 Bevy 的 `Text` 组件中，每个 `TextSection` 都已经明确指定了 `font_size` 和 `line_height`。因此，这个费心计算的 `max_font_size` 和 `max_line_height` 在后续布局过程中根本不起作用，成了一次无用的计算。

**解决方案与实现**
解决方案非常直接：既然这些计算出的值不会被使用，那就完全移除它们。开发者采取了两个步骤来实现这个优化。

首先，在初始化文本缓冲区时，不再使用可能为0的值（这会导致 panic，所以之前有 `max(0.000001)` 的 hack），而是直接使用一个无害的默认值。
```diff
// crates/bevy_text/src/text.rs
impl Default for CosmicBuffer {
    fn default() -> Self {
-        Self(Buffer::new_empty(Metrics::new(0.0, 0.000001)))
+        Self(Buffer::new_empty(Metrics::new(20.0, 20.0)))
    }
}
```
将默认值从 `(0.0, 0.000001)` 改为 `(20.0, 20.0)` 移除了一个潜在的 panic 风险，并使初始化逻辑更加清晰和健壮。

其次，也是最主要的变化，在 `TextPipeline` 更新文本布局的核心逻辑中，移除了所有与收集和设置 `Metrics` 相关的代码。
```diff
// crates/bevy_text/src/pipeline.rs
-        let mut max_font_size: f32 = 0.;
-        let mut max_line_height: f32 = 0.0;
         let mut spans: Vec<(usize, &str, &TextFont, FontFaceInfo, Color, LineHeight)> =
             core::mem::take(&mut self.spans_buffer)
                 .into_iter()
                 .collect();
```
在遍历文本段落的循环中，相关的更新代码被移除：
```diff
-            // Get max font size for use in cosmic Metrics.
-            max_font_size = max_font_size.max(text_font.font_size);
-            max_line_height = max_line_height.max(line_height.eval(text_font.font_size));
```
最终，不再构造 `Metrics` 对象，也不再调用需要它的 `set_metrics_and_size` 方法，而是直接调用更简单的 `set_size` 方法。
```diff
-        let mut metrics = Metrics::new(max_font_size, max_line_height).scale(scale_factor as f32);
-        metrics.font_size = metrics.font_size.max(0.000001);
-        metrics.line_height = metrics.line_height.max(0.000001);
        // ...
-        buffer.set_metrics_and_size(font_system, metrics, bounds.width, bounds.height);
+        buffer.set_size(font_system, bounds.width, bounds.height);
```

**技术洞察与影响**
这个改动是一个典型的“删除无用代码”的优化。它展示了深入理解所依赖库（此处为 `cosmic-text`）API 契约的重要性。开发者意识到，在 Bevy 的用例中，显式定义的段落级样式覆盖了缓冲区级的默认 `Metrics`，这使得相关的计算和传递变得多余。

从性能角度看，这个优化移除了每个文本更新周期中的一次 `O(n)` 循环遍历（用于计算最大值），以及相关的浮点数比较和赋值操作。虽然对于单个文本组件来说增益可能很小，但在具有大量动态文本实体的场景中，这些节省的累积效应是有益的。

从代码质量角度看，这个 PR 简化了逻辑，消除了不必要的变量和计算步骤，使 `TextPipeline` 的 `queue_text` 函数更加清晰，专注于其核心职责——准备字体和构建 `cosmic-text` 所需的跨度信息。同时，它也移除了一个为了规避 `Metrics` 为零导致 panic 而存在的 hack（`max(0.000001)`），使代码更加健壮和直观。

最终，这个改动没有改变任何渲染行为，因为被移除的逻辑本身就不影响最终输出。它是一个纯粹的性能和代码清洁度优化，体现了优秀的软件工程实践：在确保功能正确的前提下，持续审视并简化实现。

## 可视化表示

```mermaid
graph TD
    A[Text 组件] --> B[TextPipeline]
    B --> C{处理文本段落}
    C --> D[加载字体/构建Span]
    
    subgraph “修改前”
        E[计算最大 font_size/line_height]
        F[构造 Metrics 对象]
        G[Buffer.set_metrics_and_size]
    end
    
    subgraph “修改后”
        H[使用固定默认 Metrics]
        I[Buffer.set_size]
    end
    
    D -. 修改前路径 .-> E
    E --> F
    F --> G
    
    D -. 修改后路径 .-> I
    H --> I
    
    G --> J[cosmic-text 布局]
    I --> J
```

## 关键文件变更

**1. `crates/bevy_text/src/pipeline.rs` (+1/-14)**
这是本次优化的核心文件，移除了文本布局过程中收集和设置 `Metrics` 的全部逻辑。
*   **变更摘要**：删除了用于计算最大字体大小和行高的变量与循环内累加代码，移除了基于这些值构造 `Metrics` 对象的逻辑，并将缓冲区设置方法从 `set_metrics_and_size` 替换为 `set_size`。
*   **关键代码对比**:
    ```rust
    // 修改前片段:
    let mut max_font_size: f32 = 0.;
    let mut max_line_height: f32 = 0.0;
    // ... 在循环中 ...
    max_font_size = max_font_size.max(text_font.font_size);
    max_line_height = max_line_height.max(line_height.eval(text_font.font_size));
    // ... 循环后 ...
    let mut metrics = Metrics::new(max_font_size, max_line_height).scale(scale_factor as f32);
    metrics.font_size = metrics.font_size.max(0.000001);
    metrics.line_height = metrics.line_height.max(0.000001);
    buffer.set_metrics_and_size(font_system, metrics, bounds.width, bounds.height);

    // 修改后状态:
    // 以上变量声明和计算全部被删除
    buffer.set_size(font_system, bounds.width, bounds.height);
    ```

**2. `crates/bevy_text/src/text.rs` (+1/-1)**
这个文件修改了 `CosmicBuffer` 默认实例所使用的 `Metrics` 初始值。
*   **变更摘要**：将默认的 `Metrics` 从 `(0.0, 0.000001)` 更改为 `(20.0, 20.0)`。
*   **关键代码对比**:
    ```rust
    // 修改前:
    impl Default for CosmicBuffer {
        fn default() -> Self {
            Self(Buffer::new_empty(Metrics::new(0.0, 0.000001)))
        }
    }
    
    // 修改后:
    impl Default for CosmicBuffer {
        fn default() -> Self {
            Self(Buffer::new_empty(Metrics::new(20.0, 20.0)))
        }
    }
    ```
*   **与整体的关系**：这个改动是配套的优化。由于 `pipeline.rs` 中的逻辑不再依赖动态计算的 `Metrics`，缓冲区的初始值就可以是一个任意的、非零的合法值。使用 `(20.0, 20.0)` 这样的普通值比 `(0.0, 0.000001)` 这样的特殊值更清晰，也移除了之前为确保 `font_size` 不为零而存在的 `max` 操作的必要性。

## 延伸阅读

*   **[cosmic-text 仓库](https://github.com/pop-os/cosmic-text)**: 了解 Bevy 使用的底层文本布局和渲染库，特别是 `Buffer`、`Metrics` 和 `set_rich_text` 的 API 文档，有助于理解本次优化的依据。
*   **[Bevy 官方文档 - Text](https://docs.rs/bevy/latest/bevy/text/index.html)**: 深入了解 Bevy 中 `Text`、`TextSection` 和 `TextStyle` 组件的结构和用法。
*   **“死代码消除 (Dead Code Elimination)”**: 这是一种常见的编译器优化技术，但本 PR 体现的是在源代码级别手动识别和移除不产生效果的逻辑，是编写高效代码的重要理念。