+++
title = "#22116 Use slice `last` instead of iter `last"
date = "2025-12-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22116-en-20251215" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22116-zh-cn-20251215" }}
labels = ["D-Trivial", "C-Code-Quality", "A-glTF"]
+++

# Title
Use slice `last` instead of iter `last`

## Basic Information
- **Title**: Use slice `last` instead of iter `last
- **PR Link**: https://github.com/bevyengine/bevy/pull/22116
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: D-Trivial, C-Code-Quality, S-Needs-Review, A-glTF
- **Created**: 2025-12-15T04:26:31Z
- **Merged**: 2025-12-15T09:01:42Z
- **Merged By**: mockersf

## Description Translation
# Objective

- Followup to #22106.

## Solution

- Use slice `last` instead of iter `last` for better performance - we don't need to iterate just to find the last element.

## The Story of This Pull Request

This pull request represents a straightforward micro-optimization in Bevy's glTF loader. The issue was about using the most efficient method to access the last element of a collection. In two places within the glTF loading code, the developer used an iterator-based approach with `iter().last()` to get the last texture handle from a collection.

The original code looked like this:
```rust
texture_handles.iter().last().unwrap().clone()
```

The problem with this approach is that it creates an iterator over the entire collection just to access the last element. While for small collections this overhead is minimal, it's an unnecessary abstraction that adds overhead to every call. The `iter().last()` chain works by creating an iterator and then iterating through all elements until it reaches the last one, even though we know we want direct access to the last element.

The solution is simple and direct: use the `last()` method available directly on slices. This method has the same signature and behavior but avoids creating an intermediate iterator. The optimized code becomes:
```rust
texture_handles.last().unwrap().clone()
```

This change builds on a previous optimization in PR #22106, indicating a pattern of identifying and eliminating small inefficiencies throughout the codebase. The author recognized that these two locations in the glTF loader were performing the same suboptimal pattern that had been addressed elsewhere.

The implementation is minimal - just two lines changed in a single file. Both changes are identical in nature, replacing `iter().last()` with `last()`. This consistency makes the code easier to read and maintains a uniform style across the codebase.

From a technical perspective, this change improves performance by:
1. Eliminating the creation of an iterator object
2. Avoiding the iterator's internal state management
3. Reducing function call overhead

While the performance improvement for individual calls is small, these optimizations accumulate and demonstrate good coding practices. The `last()` method on slices uses direct indexing (or pointer arithmetic) to access the final element, which is constant time O(1) and more efficient than creating and traversing an iterator.

The changes fit cleanly into the existing architecture without any ripple effects. The method signatures remain the same, and the behavior is identical. This is a classic example of a micro-optimization that improves code clarity while providing a small performance benefit.

For other developers, this PR serves as a reminder to use the most direct API available for common operations. When working with Rust collections, it's worth checking if there's a dedicated method on the collection itself before reaching for iterator combinators, especially for simple operations like getting the first or last element.

## Visual Representation

```mermaid
graph TD
    A[glTF Loading Process] --> B[Texture Processing]
    B --> C[Call Extension Handlers]
    C --> D[Get Last Texture Handle]
    D --> E{Method Used}
    E -->|Before| F[iter().last()]
    E -->|After| G[slice.last()]
    
    F --> H[Creates Iterator]
    H --> I[Iterates to End]
    I --> J[Returns Element]
    
    G --> K[Direct Access]
    K --> J
    
    J --> L[Clone and Pass to Extension]
```

## Key Files Changed

**crates/bevy_gltf/src/loader/mod.rs** (+2/-2)
This file contains the glTF loader implementation that handles loading and processing glTF files in Bevy.

**Change 1: Line 649**
- **Before**: `texture_handles.iter().last().unwrap().clone()`
- **After**: `texture_handles.last().unwrap().clone()`

**Change 2: Line 687**
- **Before**: `texture_handles.iter().last().unwrap().clone()`
- **After**: `texture_handles.last().unwrap().clone()`

Both changes follow the same pattern: when processing texture extensions in the glTF loader, the code needs to pass the last texture handle to extension handlers. The original implementation unnecessarily created an iterator to access this element. The optimized version uses the direct `last()` method available on slices, which is more efficient and clearer in intent.

The changes are in the `GltfLoader` implementation, specifically in the methods that handle texture loading and extension processing. Both locations are within loops that iterate over textures and their extensions, so the optimization applies to every texture processed during glTF loading.

## Further Reading

1. **Rust Slice Documentation**: [https://doc.rust-lang.org/std/primitive.slice.html](https://doc.rust-lang.org/std/primitive.slice.html) - Official documentation for slice methods including `last()`.
2. **Rust Iterator Documentation**: [https://doc.rust-lang.org/std/iter/trait.Iterator.html](https://doc.rust-lang.org/std/iter/trait.Iterator.html) - Understanding iterator methods and their performance characteristics.
3. **Bevy glTF Loading**: [https://github.com/bevyengine/bevy/tree/main/crates/bevy_gltf](https://github.com/bevyengine/bevy/tree/main/crates/bevy_gltf) - The glTF loader implementation in Bevy.
4. **Related PR #22106**: [https://github.com/bevyengine/bevy/pull/22106](https://github.com/bevyengine/bevy/pull/22106) - Previous optimization that addressed similar patterns in the codebase.
5. **Rust Performance Patterns**: [https://nnethercote.github.io/perf-book/](https://nnethercote.github.io/perf-book/) - The Rust Performance Book for understanding optimization patterns in Rust.

# Full Code Diff
```diff
diff --git a/crates/bevy_gltf/src/loader/mod.rs b/crates/bevy_gltf/src/loader/mod.rs
index e4ecf35f814d4..68e5eb41dc69d 100644
--- a/crates/bevy_gltf/src/loader/mod.rs
+++ b/crates/bevy_gltf/src/loader/mod.rs
@@ -646,7 +646,7 @@ impl GltfLoader {
                 for extension in extensions.iter_mut() {
                     extension.on_texture(
                         texture.extensions(),
-                        texture_handles.iter().last().unwrap().clone(),
+                        texture_handles.last().unwrap().clone(),
                     );
                 }
             }
@@ -684,7 +684,7 @@ impl GltfLoader {
                         for extension in extensions.iter_mut() {
                             extension.on_texture(
                                 extension_data.as_ref(),
-                                texture_handles.iter().last().unwrap().clone(),
+                                texture_handles.last().unwrap().clone(),
                             );
                         }
                     }
```