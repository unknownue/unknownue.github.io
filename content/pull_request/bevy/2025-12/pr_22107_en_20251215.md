+++
title = "#22107 Global Gizmos"
date = "2025-12-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22107-en-20251215" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22107-zh-cn-20251215" }}
labels = ["C-Feature", "A-Gizmos"]
+++

# Global Gizmos

## Basic Information
- **Title**: Global Gizmos
- **PR Link**: https://github.com/bevyengine/bevy/pull/22107
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: C-Feature, S-Ready-For-Final-Review, A-Gizmos
- **Created**: 2025-12-13T15:18:25Z
- **Merged**: 2025-12-15T21:12:20Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- use gizmos in non-system contexts, such as deep in a math library or callback without ecs access.
- kind of upstream https://github.com/atlv24/glizmo
- builds off of https://github.com/bevyengine/bevy/pull/22105

## Solution

- mutex + deref

## Testing

- 

## The Story of This Pull Request

This PR addresses a practical limitation in Bevy's gizmo system: the inability to draw debug shapes from code that doesn't have access to the ECS. Previously, gizmos could only be used within Bevy systems where you could access the `Gizmos` resource through ECS queries. This meant that utility libraries, mathematical functions, or callbacks that needed to visualize debug information couldn't easily integrate with Bevy's debugging tools.

The solution implemented here is straightforward and follows a common pattern in Rust for global mutable state: a mutex-protected static variable. The core idea is to provide a global buffer where gizmo data can be written from anywhere in the codebase, then flush that buffer into the main `Gizmos` resource during the regular frame processing.

Looking at the implementation, the developer created a new module `global.rs` that defines a static `GLOBAL_GIZMO` mutex wrapping a `GizmoBuffer`. This buffer uses the default `DefaultGizmoConfigGroup` configuration and doesn't include a render phase (indicated by the `()` type parameter). The `gizmo()` function provides access to this global buffer by returning the mutex guard, which implements `DerefMut` to transparently expose the `GizmoBuffer` API.

The synchronization mechanism is minimal but effective. The mutex ensures thread-safe access to the global buffer, while the `flush_global_gizmos` system, scheduled to run in the `Last` schedule just before `GizmoMeshSystems`, swaps out the accumulated gizmo data into the main `Gizmos` resource. This swap operation using `mem::swap` is efficient—it moves the data out of the mutex-protected buffer with minimal allocation overhead, leaving an empty buffer ready for the next frame's debug drawing.

The architectural choice to use a separate buffer that gets swapped each frame aligns well with Bevy's ECS-centric design. It avoids directly modifying the ECS resource from outside the ECS, maintaining clear ownership boundaries. The plugin approach integrates cleanly into Bevy's existing gizmo system, requiring only minimal changes to the main `lib.rs` to add the new plugin.

One important consideration is performance: while the mutex introduces some synchronization overhead, it's acceptable for debug drawing functionality that's typically used during development and debugging sessions. The swap-and-extend approach in the flush system is efficient, and the mutex is only locked briefly during the swap operation and when external code calls `gizmo()` to draw something.

## Visual Representation

```mermaid
graph LR
    A[External Code] -->|calls gizmo().draw()| B[Global Gizmo Buffer]
    B -->|swap/extend in Last schedule| C[Main Gizmos Resource]
    C -->|processed by| D[GizmoMeshSystems]
    D -->|generates| E[Render Data]
```

## Key Files Changed

1. **crates/bevy_gizmos/src/global.rs** (+48/-0): This new file implements the global gizmo functionality.

   ```rust
   // File: crates/bevy_gizmos/src/global.rs
   use std::sync::Mutex;
   
   use bevy_app::{App, Last, Plugin};
   use bevy_ecs::schedule::IntoScheduleConfigs;
   
   use crate::{
       config::DefaultGizmoConfigGroup,
       gizmos::{GizmoBuffer, Gizmos},
       GizmoMeshSystems,
   };
   
   static GLOBAL_GIZMO: Mutex<GizmoBuffer<DefaultGizmoConfigGroup, ()>> =
       Mutex::new(GizmoBuffer::new());
   
   /// Lets you use bevy gizmos outside of systems.
   pub struct GlobalGizmosPlugin;
   
   impl Plugin for GlobalGizmosPlugin {
       fn build(&self, app: &mut App) {
           app.add_systems(Last, flush_global_gizmos.before(GizmoMeshSystems));
       }
   }
   
   fn flush_global_gizmos(mut gizmos: Gizmos) {
       let mut buffer = GizmoBuffer::new();
       {
           core::mem::swap(&mut buffer, &mut GLOBAL_GIZMO.lock().unwrap());
       }
       gizmos.strip_positions.extend(buffer.strip_positions);
       gizmos.strip_colors.extend(buffer.strip_colors);
       gizmos.list_positions.extend(buffer.list_positions);
       gizmos.list_colors.extend(buffer.list_colors);
   }
   
   /// A global gizmo context for use outside of bevy systems.
   ///
   /// # Example
   /// ```
   /// # use bevy_gizmos::prelude::*;
   /// # use bevy_math::prelude::*;
   /// # use bevy_color::palettes::basic::WHITE;
   /// fn draw() {
   ///     gizmo().sphere(Isometry3d::IDENTITY, 0.5, WHITE);
   /// }
   /// ```
   pub fn gizmo() -> impl core::ops::DerefMut<Target = GizmoBuffer<DefaultGizmoConfigGroup, ()>> {
       GLOBAL_GIZMO.lock().unwrap()
   }
   ```

2. **crates/bevy_gizmos/src/lib.rs** (+3/-1): Modified to include the new module and plugin.

   ```rust
   // File: crates/bevy_gizmos/src/lib.rs
   // Before (relevant excerpt):
   // mod global; // Not present
   // ...
   // impl Plugin for GizmoPlugin {
   //     fn build(&self, app: &mut App) {
   //         // ...
   //         app.add_plugins(aabb::AabbGizmoPlugin);
   //         // ...
   //     }
   // }
   
   // After:
   mod global; // Added
   
   // In prelude module:
   pub use crate::global::gizmo; // Added to exports
   
   // In Plugin implementation:
   app.add_plugins((aabb::AabbGizmoPlugin, global::GlobalGizmosPlugin));
   ```

## Further Reading

- [Rust `std::sync::Mutex` documentation](https://doc.rust-lang.org/std/sync/struct.Mutex.html) - Understanding the synchronization primitive used
- [Bevy Gizmos documentation](https://docs.rs/bevy_gizmos/latest/bevy_gizmos/) - Official documentation for Bevy's gizmo system
- [PR #22105: GizmoBuffer abstraction](https://github.com/bevyengine/bevy/pull/22105) - The foundational PR this builds upon
- [Bevy Plugin system](https://bevy-cheatbook.github.io/programming/plugins.html) - How plugins work in Bevy's architecture
- [Global state patterns in Rust](https://fettblog.eu/global-state-in-rust/) - Various approaches to managing global state