diff --git a/crates/bevy_ecs/src/bundle/insert.rs b/crates/bevy_ecs/src/bundle/insert.rs
index cc6d852d0f705..116480694913b 100644
--- a/crates/bevy_ecs/src/bundle/insert.rs
+++ b/crates/bevy_ecs/src/bundle/insert.rs
@@ -16,7 +16,7 @@ use crate::{
     observer::Observers,
     query::DebugCheckedUnwrap as _,
     relationship::RelationshipHookMode,
-    storage::{Storages, Table},
+    storage::{SparseSets, Storages, Table, TableRow},
     world::{unsafe_world_cell::UnsafeWorldCell, World},
 };
 
@@ -137,37 +137,36 @@ impl<'w> BundleInserter<'w> {
         inserter
     }
 
-    /// # Safety
-    /// - `entity` must currently exist in the source archetype for this inserter.
-    /// - `location` must be `entity`'s location in the archetype.
-    /// - `T` must match this [`BundleInserter`] type used to create
-    /// - If `T::Effect: !NoBundleEffect.`, then [`apply_effect`] must be called at most once on
-    ///   `bundle` after this function before returning to user-space safe code.
-    /// - The value pointed to by `bundle` must not be accessed for anything other than [`apply_effect`]
-    ///   or dropped.
-    ///
-    /// [`apply_effect`]: crate::bundle::DynamicBundle::apply_effect
-    #[inline]
-    pub(crate) unsafe fn insert<T: DynamicBundle>(
-        &mut self,
+    // A non-generic prelude to insert used to minimize duplicated monomorphized code.
+    // In combination with after_insert, this can reduce compile time of bevy by 10%.
+    // We inline in release to avoid a minor perf loss.
+    #[cfg_attr(not(debug_assertions), inline(always))]
+    unsafe fn before_insert<'a>(
         entity: Entity,
         location: EntityLocation,
-        bundle: MovingPtr<'_, T>,
         insert_mode: InsertMode,
         caller: MaybeLocation,
         relationship_hook_mode: RelationshipHookMode,
-    ) -> EntityLocation {
-        let bundle_info = self.bundle_info.as_ref();
-        let archetype_after_insert = self.archetype_after_insert.as_ref();
-        let archetype = self.archetype.as_ref();
-
+        mut table: NonNull<Table>,
+        mut archetype: NonNull<Archetype>,
+        archetype_after_insert: &ArchetypeAfterBundleInsert,
+        world: &'a UnsafeWorldCell<'w>,
+        archetype_move_type: &'a mut ArchetypeMoveType,
+    ) -> (
+        &'a Archetype,
+        EntityLocation,
+        &'a mut SparseSets,
+        &'a mut Table,
+        TableRow,
+    ) {
         // SAFETY: All components in the bundle are guaranteed to exist in the World
         // as they must be initialized before creating the BundleInfo.
         unsafe {
             // SAFETY: Mutable references do not alias and will be dropped after this block
-            let mut deferred_world = self.world.into_deferred();
+            let mut deferred_world = world.into_deferred();
 
             if insert_mode == InsertMode::Replace {
+                let archetype = archetype.as_ref();
                 if archetype.has_replace_observer() {
                     // SAFETY: the REPLACE event_key corresponds to the Replace event's type
                     deferred_world.trigger_raw(
@@ -189,41 +188,34 @@ impl<'w> BundleInserter<'w> {
             }
         }
 
-        let table = self.table.as_mut();
+        let table = table.as_mut();
 
         // SAFETY: Archetype gets borrowed when running the on_replace observers above,
         // so this reference can only be promoted from shared to &mut down here, after they have been ran
-        let archetype = self.archetype.as_mut();
+        let archetype = archetype.as_mut();
 
-        let (new_archetype, new_location) = match &mut self.archetype_move_type {
+        match archetype_move_type {
             ArchetypeMoveType::SameArchetype => {
                 // SAFETY: Mutable references do not alias and will be dropped after this block
                 let sparse_sets = {
-                    let world = self.world.world_mut();
+                    let world = world.world_mut();
                     &mut world.storages.sparse_sets
                 };
 
-                bundle_info.write_components(
-                    table,
+                (
+                    &*archetype,
+                    location,
                     sparse_sets,
-                    archetype_after_insert,
-                    archetype_after_insert.required_components.iter(),
-                    entity,
+                    table,
                     location.table_row,
-                    self.change_tick,
-                    bundle,
-                    insert_mode,
-                    caller,
-                );
-
-                (archetype, location)
+                )
             }
             ArchetypeMoveType::NewArchetypeSameTable { new_archetype } => {
                 let new_archetype = new_archetype.as_mut();
 
                 // SAFETY: Mutable references do not alias and will be dropped after this block
                 let (sparse_sets, entities) = {
-                    let world = self.world.world_mut();
+                    let world = world.world_mut();
                     (&mut world.storages.sparse_sets, &mut world.entities)
                 };
 
@@ -244,20 +236,14 @@ impl<'w> BundleInserter<'w> {
                 }
                 let new_location = new_archetype.allocate(entity, result.table_row);
                 entities.update_existing_location(entity.index(), Some(new_location));
-                bundle_info.write_components(
-                    table,
+
+                (
+                    &*new_archetype,
+                    new_location,
                     sparse_sets,
-                    archetype_after_insert,
-                    archetype_after_insert.required_components.iter(),
-                    entity,
+                    table,
                     result.table_row,
-                    self.change_tick,
-                    bundle,
-                    insert_mode,
-                    caller,
-                );
-
-                (new_archetype, new_location)
+                )
             }
             ArchetypeMoveType::NewArchetypeNewTable {
                 new_archetype,
@@ -268,7 +254,7 @@ impl<'w> BundleInserter<'w> {
 
                 // SAFETY: Mutable references do not alias and will be dropped after this block
                 let (archetypes_ptr, sparse_sets, entities) = {
-                    let world = self.world.world_mut();
+                    let world = world.world_mut();
                     let archetype_ptr: *mut Archetype = world.archetypes.archetypes.as_mut_ptr();
                     (
                         archetype_ptr,
@@ -326,27 +312,100 @@ impl<'w> BundleInserter<'w> {
                     }
                 }
 
-                bundle_info.write_components(
-                    new_table,
+                (
+                    &*new_archetype,
+                    new_location,
                     sparse_sets,
-                    archetype_after_insert,
-                    archetype_after_insert.required_components.iter(),
-                    entity,
+                    new_table,
                     move_result.new_row,
-                    self.change_tick,
-                    bundle,
-                    insert_mode,
-                    caller,
-                );
-
-                (new_archetype, new_location)
+                )
             }
+        }
+    }
+
+    /// # Safety
+    /// - `entity` must currently exist in the source archetype for this inserter.
+    /// - `location` must be `entity`'s location in the archetype.
+    /// - `T` must match this [`BundleInserter`] type used to create
+    /// - If `T::Effect: !NoBundleEffect.`, then [`apply_effect`] must be called at most once on
+    ///   `bundle` after this function before returning to user-space safe code.
+    /// - The value pointed to by `bundle` must not be accessed for anything other than [`apply_effect`]
+    ///   or dropped.
+    ///
+    /// [`apply_effect`]: crate::bundle::DynamicBundle::apply_effect
+    #[inline]
+    pub(crate) unsafe fn insert<T: DynamicBundle>(
+        &mut self,
+        entity: Entity,
+        location: EntityLocation,
+        bundle: MovingPtr<'_, T>,
+        insert_mode: InsertMode,
+        caller: MaybeLocation,
+        relationship_hook_mode: RelationshipHookMode,
+    ) -> EntityLocation {
+        let archetype_after_insert = self.archetype_after_insert.as_ref();
+
+        let (new_archetype, new_location) = {
+            // Non-generic prelude extracted to improve compile time by minimizing monomorphized code.
+            let (new_archetype, new_location, sparse_sets, table, table_row) = Self::before_insert(
+                entity,
+                location,
+                insert_mode,
+                caller,
+                relationship_hook_mode,
+                self.table,
+                self.archetype,
+                archetype_after_insert,
+                &self.world,
+                &mut self.archetype_move_type,
+            );
+
+            self.bundle_info.as_ref().write_components(
+                table,
+                sparse_sets,
+                archetype_after_insert,
+                archetype_after_insert.required_components.iter(),
+                entity,
+                table_row,
+                self.change_tick,
+                bundle,
+                insert_mode,
+                caller,
+            );
+
+            (new_archetype, new_location)
         };
 
-        let new_archetype = &*new_archetype;
         // SAFETY: We have no outstanding mutable references to world as they were dropped
-        let mut deferred_world = unsafe { self.world.into_deferred() };
+        let deferred_world = unsafe { self.world.into_deferred() };
+
+        // Non-generic postlude extracted to improve compile time by minimizing monomorphized code.
+        Self::after_insert(
+            entity,
+            insert_mode,
+            caller,
+            relationship_hook_mode,
+            archetype_after_insert,
+            new_archetype,
+            deferred_world,
+        );
 
+        new_location
+    }
+
+    // A non-generic postlude to insert used to minimize duplicated monomorphized code.
+    // In combination with before_insert, this can reduce compile time of bevy by 10%.
+    // We inline in release to avoid a minor perf loss.
+    #[cfg_attr(not(debug_assertions), inline(always))]
+    fn after_insert(
+        entity: Entity,
+        insert_mode: InsertMode,
+        caller: MaybeLocation,
+        relationship_hook_mode: RelationshipHookMode,
+        archetype_after_insert: &ArchetypeAfterBundleInsert,
+        new_archetype: &Archetype,
+        mut deferred_world: crate::world::DeferredWorld<'_>,
+    ) {
         // SAFETY: All components in the bundle are guaranteed to exist in the World
         // as they must be initialized before creating the BundleInfo.
         unsafe {
@@ -413,8 +472,6 @@ impl<'w> BundleInserter<'w> {
                 }
             }
         }
-
-        new_location
     }
 
     #[inline]
