+++
title = "#22165 Add name to pass span to make the error better"
date = "2025-12-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22165-en-20251217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22165-zh-cn-20251217" }}
labels = ["A-Rendering", "C-Usability", "S-Ready-For-For-Review", "D-Straightforward"]
+++

# Title
PR #22165: 为渲染诊断错误信息添加 Pass 名称，提升调试体验

## Basic Information
- **Title**: Add name to pass span to make the error better
- **PR Link**: https://github.com/bevyengine/bevy/pull/22165
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: A-Rendering, C-Usability, S-Ready-For-For-Review, D-Straightforward
- **Created**: 2025-12-17T14:03:42Z
- **Merged**: 2025-12-17T19:12:15Z
- **Merged By**: alice-i-cecile

## Description Translation
**目标**
- 错误信息非常模糊

**解决方案**
- 名称使用 Cow，因此我们可以零成本克隆并传递给错误格式化。

**测试**
- 我使用此功能调试了 #22164

## The Story of This Pull Request

这个 PR 源于开发者在调试另一个问题时遇到的实际痛点。在调试 #22164 的过程中，作者发现渲染诊断系统中的错误信息不够具体，导致定位问题效率低下。

Bevy 渲染系统包含一个诊断模块（diagnostic），用于跟踪渲染过程中各个 Pass（渲染阶段）的执行时间。系统使用 `PassSpanGuard` 来记录一个 Pass 的开始和结束。这个守卫实现了 Drop trait，其设计初衷是：如果守卫在离开作用域时没有被显式调用 `end()` 方法，说明开发者忘记了结束这个 Pass 的时间记录，这通常是一个编程错误，因此会触发 panic。

**问题所在**
修改前的 `PassSpanGuard` 在 panic 时仅提示 "PassSpanScope::end was never called"。这个错误信息是泛泛的，没有指出是哪个具体的 Pass 出了问题。在复杂的渲染管线中，可能有多个 Pass 同时被记录，当这个 panic 发生时，开发者需要额外的时间和努力去回溯代码，找出具体是哪个 Pass 的守卫没有正确结束。

**解决方案分析**
PR 作者采用了直接且成本较低的方案。关键在于 `PassSpanGuard` 的创建是通过 `RecordDiagnostics::pass_span` 方法，该方法已经接收了一个表示 Pass 名称的参数 `name`，其类型为 `Into<Cow<'static, str>>`。`Cow`（写时复制）是一个智能指针，可以高效地处理字符串的所有权和借用。

解决方案的核心步骤是：
1. 在 `pass_span` 方法内部，将传入的 `name` 转换为 `Cow<'static, str>` 后，进行一次克隆（`clone()`）。
2. 将克隆后的名称存储在新建的 `PassSpanGuard` 结构体中。
3. 在 `PassSpanGuard` 的 `Drop` 实现中，将存储的名称插入到 panic 信息中。

**技术细节与考量**
```rust
// 修改前
panic!("PassSpanScope::end was never called")

// 修改后
panic!("PassSpanGuard::end was never called for {}", self.name)
```
这里有几个值得注意的工程决策：
1. **零成本克隆的利用**：由于 `name` 是 `Cow<'static, str>` 类型，对其调用 `.clone()` 通常是低成本的。如果 `Cow` 内部是 `Borrowed(&'static str)`，克隆只是复制指针；如果是 `Owned(String)`，则会克隆字符串。考虑到 Pass 名称通常是静态字符串字面量，大部分情况下开销极小。
2. **错误信息精确性**：新的错误信息直接包含了出问题的 Pass 名称，使得开发者能够立即定位到问题代码段，显著提升调试效率。
3. **错误文本修正**：作者在修改 panic 信息时，还修正了一个小错误：将 "PassSpanScope" 更正为 "PassSpanGuard"，与实际结构体名称保持一致，提高了代码的一致性。

这个改动虽然很小，但体现了良好的软件工程实践：**让错误信息具有可操作性**。它直接解决了开发者在实际工作中遇到的痛点，改善了 API 的用户体验（UX），并且实现方式简洁、高效，几乎没有引入额外的运行时开销。这种改进对于提高大型、复杂系统（如游戏引擎）的开发效率和可维护性具有重要意义。

## Visual Representation

```mermaid
graph TD
    A[开发者调用 RecordDiagnostics::pass_span] --> B[创建 PassSpanGuard]
    B --> C{守卫是否正常调用 .end()?}
    C -->|是| D[正常结束，记录时间]
    C -->|否，守卫被 Drop| E[触发 Panic]
    E --> F[输出包含 Pass 名称的错误信息]
    F --> G[开发者快速定位问题代码]
```

## Key Files Changed

**crates/bevy_render/src/diagnostic/mod.rs** (+5/-2)
这个文件是渲染诊断系统的核心，负责性能测量和时间记录。

1. **修改点 1：`RecordDiagnostics::pass_span` 方法**
   - **目的**：捕获并存储 Pass 名称到守卫中。
   - **实现**：将传入的 `name` 克隆一份，一份用于开始记录，一份存入守卫。

```rust
// Before:
pub fn pass_span<P, N>(&self, pass: P, name: N) -> PassSpanGuard<'_, Self, P>
where
    P: Pass,
    N: Into<Cow<'static, str>>,
{
    self.begin_pass_span(pass, name.into());
    PassSpanGuard {
        recorder: self,
        marker: PhantomData,
    }
}

// After:
pub fn pass_span<P, N>(&self, pass: P, name: N) -> PassSpanGuard<'_, Self, P>
where
    P: Pass,
    N: Into<Cow<'static, str>>,
{
    let name = name.into();
    self.begin_pass_span(pass, name.clone());
    PassSpanGuard {
        recorder: self,
        name,
        marker: PhantomData,
    }
}
```

2. **修改点 2：`PassSpanGuard` 结构体**
   - **目的**：为守卫添加存储 Pass 名称的能力。
   - **实现**：新增 `name: Cow<'static, str>` 字段。

```rust
// 新增字段
pub struct PassSpanGuard<'a, R: ?Sized, P> {
    recorder: &'a R,
    name: Cow<'static, str>, // 新增
    marker: PhantomData<P>,
}
```

3. **修改点 3：`Drop for PassSpanGuard` 实现**
   - **目的**：在 panic 信息中包含具体是哪个 Pass 未正确结束。
   - **实现**：在 panic 宏中格式化输出 `self.name`。

```rust
// Before:
impl<R: ?Sized, P> Drop for PassSpanGuard<'_, R, P> {
    fn drop(&mut self) {
        panic!("PassSpanScope::end was never called")
    }
}

// After:
impl<R: ?Sized, P> Drop for PassSpanGuard<'_, R, P> {
    fn drop(&mut self) {
        panic!("PassSpanGuard::end was never called for {}", self.name)
    }
}
```

## Further Reading

1. **Rust 中的 Cow 类型**：`std::borrow::Cow` 官方文档，了解其写时复制语义和高效处理字符串的策略。
2. **RAII 模式与 Drop trait**：理解 Rust 中资源获取即初始化的模式，以及 Drop trait 如何确保资源清理。
3. **Bevy 渲染管线架构**：深入了解 Bevy 的 ECS 架构和渲染管线中 Pass 的概念及其作用。
4. **Effective Error Messages**：关于如何设计对开发者友好的错误信息的通用准则和实践。