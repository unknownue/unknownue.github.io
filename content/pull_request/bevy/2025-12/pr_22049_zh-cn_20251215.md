+++
title = "#22049 single query per node in UI picking backend"
date = "2025-12-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22049-en-20251215" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22049-zh-cn-20251215" }}
+++

# Title

## 基本信息
- **标题**: single query per node in UI picking backend 
- **PR链接**: https://github.com/bevyengine/bevy/pull/22049
- **作者**: ickshonpe
- **状态**: 已合并
- **标签**: D-简单, A-UI, C-代码质量, S-准备最终评审, A-拾取
- **创建时间**: 2025-12-06T21:53:59Z
- **合并时间**: 2025-12-15T02:13:04Z
- **合并者**: alice-i-cecile

## 描述翻译

# 目标

UI 拾取后端（picking backend）对节点数据进行了两次查询。通过将相机实体和拾取数据存储在 `hit_nodes` 中而非进行第二次查询，来简化 `ui_picking`。

## 解决方案

将相机实体和拾取数据存储在 `hit_nodes` 中，而不是再次查询它们。

## 这个 PR 的故事

这个 PR 解决了一个在 Bevy 引擎 UI 拾取系统中发现的代码质量问题。问题的核心是性能优化和代码简化：UI 拾取后端在为每个节点计算拾取结果时，对同一数据进行了两次查询。

在分析原始的 `ui_picking` 函数时，开发人员注意到系统在处理每个潜在的悬停节点时，首先会查询一次来构建 `hit_nodes` 列表。然后在后续处理阶段，对于列表中的每个节点，系统会再次通过 `pickable_query` 查询来获取 `Pickable` 组件数据，以判断该节点是否应该阻止下层节点的交互。

这种设计存在两个问题。首先，它造成了不必要的性能开销，因为同一实体的相同组件数据被查询了两次。在包含大量 UI 元素的场景中，这种重复查询会累积成可观的性能损失。其次，从代码质量角度看，这种模式不够简洁，增加了代码的复杂性和维护成本。

开发人员提出的解决方案很直接：在第一次查询时就获取所有需要的数据，并存储起来供后续使用。具体来说，修改了 `hit_nodes` 哈希映射的值类型，从 `Vec<(Entity, Entity, Vec2)>` 扩展为 `Vec<(Entity, Entity, Option<Pickable>, Vec2)>`。新增的第三个元素用于存储 `Pickable` 组件的克隆。

这种修改带来了几个好处。首先，它消除了第二次查询，直接将性能开销减半。其次，它使代码逻辑更加清晰，因为节点的拾取行为数据现在与节点实体、相机实体和坐标位置一起存储，形成了一组完整的数据包。

在实现细节上，开发人员使用了 `.cloned()` 方法来获取 `Pickable` 组件的可选克隆。这是必要的，因为 `Option<&Pickable>` 不能直接存储在需要所有权的地方。通过克隆组件，我们可以在后续处理中直接使用这个数据，而不需要再次查询。

这个优化遵循了常见的数据局部性（data locality）原则：将相关的数据放在一起处理，减少对缓存的压力。虽然单个 `Pickable` 组件可能很小，但在大规模 UI 场景中，这种优化可以显著减少内存访问次数。

从架构角度看，这个 PR 保持了现有的 API 和系统行为不变，只是内部实现得到了优化。这意味着现有的 UI 拾取功能完全不受影响，所有测试应该继续通过。

最终，这个 PR 展示了一个典型的微优化模式：识别并消除冗余操作。虽然每个节点节省的查询看起来很小，但在游戏引擎这样的性能敏感系统中，这些小的优化累加在一起可以产生显著的性能提升。这种优化特别有价值，因为它在不增加复杂性的情况下提升了性能，实际上还简化了代码结构。

## 视觉表示

```mermaid
graph TD
    A[ui_picking 系统开始] --> B[第一次查询: 获取节点和相机数据]
    B --> C[构建 hit_nodes 映射<br/>包含实体、相机、Pickable、位置]
    C --> D[处理每个 (相机, 指针) 组合]
    D --> E[直接使用存储的 Pickable 数据]
    E --> F[确定交互阻断行为]
    F --> G[系统结束]
    
    H[原始流程: 第二次查询] -.->|已消除| E
```

## 关键文件更改

### `crates/bevy_ui/src/picking_backend.rs` (+6/-3)

这个文件包含了 UI 拾取后端的主要逻辑。PR 修改了这个文件以减少重复查询。

**主要变化：**
1. 扩展了 `hit_nodes` 哈希映射的类型，包含 `Pickable` 组件数据
2. 在构建 `hit_nodes` 时存储 `Pickable` 组件的克隆
3. 在后续处理中直接使用存储的数据，而不是重新查询

**代码修改：**

```rust
// 修改前：hit_nodes 只存储实体和位置
let mut hit_nodes = HashMap::<(Entity, PointerId), Vec<(Entity, Entity, Vec2)>>::default();

// 修改后：hit_nodes 现在也存储 Pickable 组件
let mut hit_nodes =
    HashMap::<(Entity, PointerId), Vec<(Entity, Entity, Option<Pickable>, Vec2)>>::default();
```

```rust
// 修改前：在 hit_nodes 中只存储文本实体、相机实体和位置
.push((
    text_entity,
    camera_entity,
    node.transform.inverse().transform_point2(*cursor_position)
        / node.node.size(),
));

// 修改后：现在也存储 pickable 组件的克隆
.push((
    text_entity,
    camera_entity,
    node.pickable.cloned(),
    node.transform.inverse().transform_point2(*cursor_position)
        / node.node.size(),
));
```

```rust
// 修改前：后续处理时需要重新查询 Pickable 组件
if let Ok(pickable) = pickable_query.get(*hovered_node) {
    // If an entity has a `Pickable` component, we will use that as the source of truth.
    if pickable.should_block_lower {
        break;
    }
}

// 修改后：直接使用存储的 Pickable 数据
if let Some(pickable) = pickable {
    // If an entity has a `Pickable` component, we will use that as the source of truth.
    if pickable.should_block_lower {
        break;
    }
}
```

## 扩展阅读

- [Bevy ECS 查询文档](https://docs.rs/bevy_ecs/latest/bevy_ecs/system/struct.Query.html) - 了解 Bevy 的查询系统如何工作
- [数据局部性原则](https://en.wikipedia.org/wiki/Locality_of_reference) - 优化内存访问模式的基础知识
- [Bevy UI 系统](https://bevyengine.org/learn/book/plugins/ui/) - Bevy 官方文档中的 UI 系统介绍
- [性能优化模式](https://gameprogrammingpatterns.com/optimization-patterns.html) - 游戏开发中的常见优化模式

# 完整代码差异

```
diff --git a/crates/bevy_ui/src/picking_backend.rs b/crates/bevy_ui/src/picking_backend.rs
index 1028cfb6b0e5a..d3648ced54f90 100644
--- a/crates/bevy_ui/src/picking_backend.rs
+++ b/crates/bevy_ui/src/picking_backend.rs
@@ -149,7 +149,8 @@ pub fn ui_picking(
     }
 
     // The list of node entities hovered for each (camera, pointer) combo
-    let mut hit_nodes = HashMap::<(Entity, PointerId), Vec<(Entity, Entity, Vec2)>>::default();
+    let mut hit_nodes =
+        HashMap::<(Entity, PointerId), Vec<(Entity, Entity, Option<Pickable>, Vec2)>>::default();
 
     // prepare an iterator that contains all the nodes that have the cursor in their rect,
     // from the top node to the bottom one. this will also reset the interaction to `None`
@@ -222,6 +223,7 @@ pub fn ui_picking(
                             .push((
                                 text_entity,
                                 camera_entity,
+                                node.pickable.cloned(),
                                 node.transform.inverse().transform_point2(*cursor_position)
                                     / node.node.size(),
                             ));
@@ -240,6 +242,7 @@ pub fn ui_picking(
                         .push((
                             node_entity,
                             camera_entity,
+                            node.pickable.cloned(),
                             node.transform.inverse().transform_point2(*cursor_position)
                                 / node.node.size(),
                         ));
@@ -254,13 +257,13 @@ pub fn ui_picking(
         let mut picks = Vec::new();
         let mut depth = 0.0;
 
-        for (hovered_node, camera_entity, position) in hovered {
+        for (hovered_node, camera_entity, pickable, position) in hovered {
             picks.push((
                 *hovered_node,
                 HitData::new(*camera_entity, depth, Some(position.extend(0.0)), None),
             ));
 
-            if let Ok(pickable) = pickable_query.get(*hovered_node) {
+            if let Some(pickable) = pickable {
                 // If an entity has a `Pickable` component, we will use that as the source of truth.
                 if pickable.should_block_lower {
                     break;
```