+++
title = "#22258 Add toggle function for virtual time"
date = "2025-12-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22258-en-20251230" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22258-zh-cn-20251230" }}
labels = ["C-Usability", "A-Time"]
+++

# Title

## Basic Information
- **Title**: Add toggle function for virtual time
- **PR Link**: https://github.com/bevyengine/bevy/pull/22258
- **Author**: GitGhillie
- **Status**: MERGED
- **Labels**: C-Usability, S-Ready-For-Final-Review, A-Time
- **Created**: 2025-12-24T14:33:00Z
- **Merged**: 2025-12-30T01:23:41Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

I was looking at the diff of https://github.com/bevyengine/bevy/pull/22207 and noticed there is a bit of code duplication.

## Solution

Move the toggle functionality into a function, update the examples.

## Testing

- Tested by running the examples and toggling time.

## The Story of This Pull Request

This PR addresses a straightforward but common pattern in time management: toggling between paused and unpaused states. The author was reviewing PR #22207 and noticed repeated code patterns where developers manually checked the paused state and then called either `pause()` or `unpause()`. This pattern appeared in multiple places, creating unnecessary duplication.

The solution is simple and practical: add a `toggle()` method to the `Time<Virtual>` struct. This method uses a boolean XOR operation (`^= true`) to invert the paused state. The implementation is minimal - just one line of code - but it significantly improves API ergonomics by providing a single method call for the common toggle operation.

The developer updated the existing examples to use this new method. In both `examples/3d/solari.rs` and `examples/time/virtual_time.rs`, the manual toggle logic was replaced with a single call to `time.toggle()`. This reduces the code from 4-5 lines down to 1 line in each case, making the examples cleaner and demonstrating the proper use of the new API.

The documentation was also updated to reflect this new functionality. The Rustdoc comment for the `Time<Virtual>` struct now mentions the `toggle()` method alongside `pause()` and `unpause()`, and the method itself has a clear documentation string explaining its behavior.

This change follows good API design principles. By providing a dedicated toggle method, the Bevy engine reduces boilerplate code for users and prevents potential bugs from incorrect manual implementations. The use of a bitwise XOR operation is an efficient way to toggle a boolean value, and the inline attribute ensures there's no performance penalty for using this convenience method.

The impact is primarily on developer experience and code maintainability. Existing code continues to work unchanged, but developers can now opt into the cleaner toggle API. The examples serve as documentation for this new feature, showing best practices for time management in Bevy applications.

## Visual Representation

```mermaid
graph TD
    A[Time&lt;Virtual&gt; struct] --> B[pause() method]
    A --> C[unpause() method]
    A --> D[toggle() method]
    D --> E[Uses boolean XOR]
    B --> F[Examples updated]
    C --> F
    D --> F
    F --> G[solari.rs example]
    F --> H[virtual_time.rs example]
```

## Key Files Changed

### `crates/bevy_time/src/virt.rs` (+10/-3)
This is the main implementation file where the `toggle()` method was added to the `Time<Virtual>` struct.

**Key changes:**
1. Updated the struct documentation to mention the new `toggle()` method
2. Added the `toggle()` method implementation
3. Added documentation for the `unpause()` method

**Code snippets:**
```rust
// File: crates/bevy_time/src/virt.rs
// Before (documentation):
// The virtual clock can be paused by calling [`pause()`](Time::pause) and
// unpaused by calling [`unpause()`](Time::unpause). When the game clock is

// After (documentation):
// The virtual clock can be paused by calling [`pause()`](Time::pause),
// unpaused by calling [`unpause()`](Time::unpause), or toggled by calling
// [`toggle()`](Time::toggle). When the game clock is

// New method added:
/// Stops the clock if it is running, otherwise resumes the clock.
#[inline]
pub fn toggle(&mut self) {
    self.context_mut().paused ^= true;
}

// Before (unpause documentation):
/// Resumes the clock if paused.

// After (unpause documentation):
/// Resumes the clock.
```

### `examples/3d/solari.rs` (+1/-5)
This example demonstrates 3D rendering with ray tracing and includes time control functionality.

**Key change:**
1. Replaced manual pause/unpause logic with a single `toggle()` call

**Code snippets:**
```rust
// File: examples/3d/solari.rs
// Before:
fn pause_scene(mut time: ResMut<Time<Virtual>>, key_input: Res<ButtonInput<KeyCode>>) {
    if key_input.just_pressed(KeyCode::Space) {
        if time.is_paused() {
            time.unpause();
        } else {
            time.pause();
        }
    }
}

// After:
fn pause_scene(mut time: ResMut<Time<Virtual>>, key_input: Res<ButtonInput<KeyCode>>) {
    if key_input.just_pressed(KeyCode::Space) {
        time.toggle();
    }
}
```

### `examples/time/virtual_time.rs` (+4/-8)
This example specifically demonstrates virtual time functionality and serves as documentation for the time system.

**Key changes:**
1. Replaced manual toggle logic with `toggle()` method
2. Updated control text from "Un/Pause" to "(Un)pause" for clarity
3. Fixed a comment punctuation issue

**Code snippets:**
```rust
// File: examples/time/virtual_time.rs
// Before (control text):
Text::new("CONTROLS\nUn/Pause: Space\nSpeed+: Up\nSpeed-: Down"),

// After (control text):
Text::new("CONTROLS\n(Un)pause: Space\nSpeed+: Up\nSpeed-: Down"),

// Before (comment):
// update the texts on a timer to make them more readable

// After (comment):
// update the texts on a timer to make them more readable.

// Before (toggle function):
fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
    if time.is_paused() {
        time.unpause();
    } else {
        time.pause();
    }
}

// After (toggle function):
fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
    time.toggle();
}
```

## Further Reading

1. **Bevy Time System Documentation**: For more information on Bevy's time management, see the [Bevy Time API documentation](https://docs.rs/bevy_time/latest/bevy_time/)
2. **Bitwise Operations in Rust**: The XOR operator (`^`) used in the toggle implementation is explained in the [Rust Book chapter on operators](https://doc.rust-lang.org/book/appendix-02-operators.html)
3. **API Design Principles**: For background on API design patterns that motivated this change, see Joshua Bloch's "Effective Java" (principles apply to API design in any language)
4. **Previous PR #22207**: The PR that inspired this refactoring, which can provide context for the code duplication that was observed

# Full Code Diff

```
diff --git a/crates/bevy_time/src/virt.rs b/crates/bevy_time/src/virt.rs
index 146c754891859..45fa4c23eb987 100644
--- a/crates/bevy_time/src/virt.rs
+++ b/crates/bevy_time/src/virt.rs
@@ -20,8 +20,9 @@ use crate::{real::Real, time::Time};
 /// in order to prevent unexpected behavior in cases where updates do not happen
 /// at regular intervals (e.g. coming back after the program was suspended a long time).
 ///
-/// The virtual clock can be paused by calling [`pause()`](Time::pause) and
-/// unpaused by calling [`unpause()`](Time::unpause). When the game clock is
+/// The virtual clock can be paused by calling [`pause()`](Time::pause),
+/// unpaused by calling [`unpause()`](Time::unpause), or toggled by calling
+/// [`toggle()`](Time::toggle). When the game clock is
 /// paused [`delta()`](Time::delta) will be zero on each update, and
 /// [`elapsed()`](Time::elapsed) will not grow.
 /// [`effective_speed()`](Time::effective_speed) will return `0.0`. Calling
@@ -203,13 +204,19 @@ impl Time<Virtual> {
         self.context_mut().relative_speed = ratio;
     }
 
+    /// Stops the clock if it is running, otherwise resumes the clock.
+    #[inline]
+    pub fn toggle(&mut self) {
+        self.context_mut().paused ^= true;
+    }
+
     /// Stops the clock, preventing it from advancing until resumed.
     #[inline]
     pub fn pause(&mut self) {
         self.context_mut().paused = true;
     }
 
-    /// Resumes the clock if paused.
+    /// Resumes the clock.
     #[inline]
     pub fn unpause(&mut self) {
         self.context_mut().paused = false;
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 6449b40d2bb66..0eb6aa0514abd 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -224,11 +224,7 @@ fn add_raytracing_meshes_on_scene_load(
 
 fn pause_scene(mut time: ResMut<Time<Virtual>>, key_input: Res<ButtonInput<KeyCode>>) {
     if key_input.just_pressed(KeyCode::Space) {
-        if time.is_paused() {
-            time.unpause();
-        } else {
-            time.pause();
-        }
+        time.toggle();
     }
 }
 
diff --git a/examples/time/virtual_time.rs b/examples/time/virtual_time.rs
index c9c6bd112b65a..55343cfe9ee5a 100644
--- a/examples/time/virtual_time.rs
+++ b/examples/time/virtual_time.rs
@@ -21,7 +21,7 @@ fn main() {
                 change_time_speed::<1>.run_if(input_just_pressed(KeyCode::ArrowUp)),
                 change_time_speed::<-1>.run_if(input_just_pressed(KeyCode::ArrowDown)),
                 (update_virtual_time_info_text, update_real_time_info_text)
-                    // update the texts on a timer to make them more readable
+                    // update the texts on a timer to make them more readable.
                     // `on_timer` run condition uses `Virtual` time meaning it's scaled
                     // and would result in the UI updating at different intervals based
                     // on `Time<Virtual>::relative_speed` and `Time<Virtual>::is_paused()`
@@ -96,7 +96,7 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>, mut time: ResMu
                 RealTime,
             ),
             (
-                Text::new("CONTROLS\nUn/Pause: Space\nSpeed+: Up\nSpeed-: Down"),
+                Text::new("CONTROLS\n(Un)pause: Space\nSpeed+: Up\nSpeed-: Down"),
                 TextFont {
                     font_size,
                     ..default()
@@ -163,13 +163,9 @@ fn change_time_speed<const DELTA: i8>(mut time: ResMut<Time<Virtual>>) {
     time.set_relative_speed(time_speed);
 }
 
-/// pause or resume `Relative` time
+/// Pause or resume `Relative` time
 fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
-    if time.is_paused() {
-        time.unpause();
-    } else {
-        time.pause();
-    }
+    time.toggle();
 }
 
 /// Update the `Real` time info text
```