+++
title = "#22159 Prevent the transaction log for a bevy_asset test from writing to the file system."
date = "2025-12-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22159-en-20251217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22159-zh-cn-20251217" }}
labels = ["A-Assets", "C-Testing", "D-Straightforward"]
+++

# Title
**Prevent the transaction log for a bevy_asset test from writing to the file system.**

## Basic Information
- **Title**: Prevent the transaction log for a bevy_asset test from writing to the file system.
- **PR Link**: https://github.com/bevyengine/bevy/pull/22159
- **Author**: andriyDev
- **Status**: MERGED
- **Labels**: A-Assets, S-Ready-For-Final-Review, C-Testing, D-Straightforward
- **Created**: 2025-12-17T01:50:33Z
- **Merged**: 2025-12-17T19:25:39Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- bevy_asset tests are writing to the filesystem!

## Solution

- Share the impl of `create_app` with more tests.
- Set the transaction log for this one test to also use the fake transasction log (same thing as #21476).

## The Story of This Pull Request

The issue was straightforward: a unit test in the Bevy asset system was writing to the actual filesystem during test execution. This is problematic for several reasons. Tests that write to the filesystem can create side effects that affect other tests, leave temporary files that need cleanup, and generally violate the principle of test isolation. In continuous integration environments, this can cause flaky tests or permission issues.

The problem was identified in a specific test within the asset processor module. The asset processor uses a transaction log to track processing operations, and by default, this log writes to disk. During testing, we want to avoid any actual filesystem I/O.

The solution approached this from two angles. First, the PR expanded the use of an existing helper function called `create_app()` that was already designed to create test applications with safe configurations. This function was originally defined in `lib.rs` but was only scoped to that module's tests. The fix made this function `pub(crate)` so it could be shared across multiple test modules.

Second, the PR specifically addressed the transaction log issue by ensuring that the problematic test used a fake transaction log implementation. This was done by extracting the existing fake transaction log implementation into a reusable function and calling it in the test setup.

Looking at the code changes, the pattern becomes clear. In `lib.rs`, the `create_app()` function was updated to be publicly accessible within the crate. More importantly, it configures the `AssetPlugin` with specific overrides that disable filesystem interactions:

```rust
pub(crate) fn create_app() -> (App, Dir) {
    let mut app = App::new();
    let dir = Dir::default();
    let dir_clone = dir.clone();
    
    app.register_asset_source(
        AssetSourceId::Default,
        AssetSourceBuilder::new(move || Box::new(MemoryAssetReader { root: dir_clone.clone() })),
    )
    .add_plugins((
        TaskPoolPlugin::default(),
        AssetPlugin {
            watch_for_changes_override: Some(false),
            use_asset_processor_override: Some(false),
            ..Default::default()
        },
        DiagnosticsPlugin,
    ));
    (app, dir)
}
```

The key configuration here is `watch_for_changes_override: Some(false)` and `use_asset_processor_override: Some(false)`. These settings prevent the asset system from watching for file changes and using the asset processor, both of which would involve filesystem access.

Several test modules were then updated to use this shared `create_app()` function instead of creating their own App instances with the default `AssetPlugin`. The changes in `asset_changed.rs`, `handle.rs`, and `reflect.rs` show this pattern consistently: tests that previously created their own App with `AssetPlugin::default()` now use `create_app().0` to get a pre-configured App instance.

The more complex part of the fix was in `processor/tests.rs`. Here, a test called `only_reprocesses_wrong_hash_on_startup` was still writing to the filesystem because it was using a transaction log. The solution was to extract the existing fake transaction log implementation into a helper function and apply it to this test:

```rust
fn set_fake_transaction_log(app: &mut App) {
    /// A dummy transaction log factory that just creates [`FakeTransactionLog`].
    struct FakeTransactionLogFactory;
    
    impl ProcessorTransactionLogFactory for FakeTransactionLogFactory {
        fn read(&self) -> BoxedFuture<'_, Result<Vec<LogEntry>, BevyError>> {
            Box::pin(async move { Ok(vec![]) })
        }
        
        fn create_new_log(
            &self,
        ) -> BoxedFuture<'_, Result<Box<dyn ProcessorTransactionLog>, BevyError>> {
            Box::pin(async move { Ok(Box::new(FakeTransactionLog) as _) })
        }
    }
    
    /// A dummy transaction log that just drops every log.
    struct FakeTransactionLog;
    
    impl ProcessorTransactionLog for FakeTransactionLog {
        fn begin_processing<'a>(
            &'a mut self,
            _asset: &'a AssetPath<'_>,
        ) -> BoxedFuture<'a, Result<(), BevyError>> {
            Box::pin(async move { Ok(()) })
        }
        
        fn end_processing<'a>(
            &'a mut self,
            _asset: &'a AssetPath<'_>,
        ) -> BoxedFuture<'a, Result<(), BevyError>> {
            Box::pin(async move { Ok(()) })
        }
        
        fn unrecoverable(&mut self) -> BoxedFuture<'_, Result<(), BevyError>> {
            Box::pin(async move { Ok(()) })
        }
    }
    
    app.world()
        .resource::<AssetProcessor>()
        .data()
        .set_log_factory(Box::new(FakeTransactionLogFactory))
        .unwrap();
}
```

This fake transaction log implements the required traits but does nothing - it returns empty results and succeeds on all operations without touching the filesystem. The function is then called in two places: in the existing `create_app_with_asset_processor` function and in the specific test that was causing the problem.

The technical insight here is about test design in systems that normally interact with external resources. The pattern of creating fake implementations (like the `FakeTransactionLog`) is standard practice for unit testing. What's notable in this PR is the systematic approach: rather than just fixing the one problematic test, the developer also shared existing infrastructure (`create_app()`) to prevent similar issues in other tests.

From an architectural perspective, this change improves test reliability and performance. Tests that don't touch the filesystem run faster and are more predictable. It also demonstrates good software engineering practice: when you find a bug in one test, look for similar patterns in other tests that might have the same issue.

The impact is straightforward: more reliable tests that don't have side effects on the filesystem. This makes the test suite more suitable for continuous integration environments and prevents intermittent test failures caused by filesystem state.

## Visual Representation

```mermaid
graph TD
    A[Test modules needing App setup] --> B[create_app() helper]
    B --> C[MemoryAssetReader]
    B --> D[AssetPlugin with overrides]
    D --> E[watch_for_changes_override: false]
    D --> F[use_asset_processor_override: false]
    G[processor/tests.rs] --> H[set_fake_transaction_log()]
    H --> I[FakeTransactionLogFactory]
    I --> J[FakeTransactionLog]
```

## Key Files Changed

### `crates/bevy_asset/src/lib.rs` (+32/-4)
This file contains the main change: making the `create_app()` function `pub(crate)` and updating its configuration. The function now properly configures the `AssetPlugin` to avoid filesystem access.

**Key change:**
```rust
// Before:
fn create_app() -> (App, Dir) {
    // ... implementation with default AssetPlugin
}

// After:
pub(crate) fn create_app() -> (App, Dir) {
    // ... implementation with AssetPlugin configured to avoid filesystem access
    AssetPlugin {
        watch_for_changes_override: Some(false),
        use_asset_processor_override: Some(false),
        ..Default::default()
    },
}
```

### `crates/bevy_asset/src/processor/tests.rs` (+53/-45)
This file contains the extraction of the fake transaction log into a helper function and its application to the problematic test.

**Key change:**
```rust
// New helper function extracted from existing code:
fn set_fake_transaction_log(app: &mut App) {
    // Implementation of FakeTransactionLogFactory and FakeTransactionLog
    // ...
}

// Called in the existing function:
fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor {
    // ... setup code
    set_fake_transaction_log(&mut app);
    // ...
}

// And in the specific test:
fn only_reprocesses_wrong_hash_on_startup() {
    let mut app = App::new();
    // ... setup
    set_fake_transaction_log(&mut app);
    // ... rest of test
}
```

### `crates/bevy_asset/src/asset_changed.rs` (+9/-12)
Updated tests to use the shared `create_app()` function instead of creating their own App with default plugins.

**Key change:**
```rust
// Before:
fn run_app<Marker>(system: impl IntoSystem<(), (), Marker>) {
    let mut app = App::new();
    app.add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
        .init_asset::<MyAsset>()
        .add_systems(Update, system);
    app.update();
}

// After:
fn run_app<Marker>(system: impl IntoSystem<(), (), Marker>) {
    let mut app = create_app().0;
    app.init_asset::<MyAsset>().add_systems(Update, system);
    app.update();
}
```

### `crates/bevy_asset/src/handle.rs` (+5/-5) and `crates/bevy_asset/src/reflect.rs` (+3/-5)
Similar updates to use `create_app()` instead of creating App instances with default plugins.

## Further Reading

1. **Bevy Asset System Documentation**: The Bevy book's section on assets provides context for how the asset system works: https://bevyengine.org/learn/book/features/assets/

2. **Test Isolation Patterns**: Martin Fowler's article on test isolation discusses why avoiding filesystem access in tests is important: https://martinfowler.com/bliki/UnitTest.html

3. **Mock Objects in Rust**: The Rust programming language doesn't have built-in mocking frameworks like some other languages, but patterns like the fake implementation shown here are common. The "mockall" crate is a popular choice for more complex mocking needs.

4. **Previous Related PR**: PR #21476 mentioned in the description shows a similar fix for transaction logs in tests, establishing a pattern that this PR follows.

5. **Bevy Plugin System**: Understanding how Bevy plugins work is helpful for understanding the configuration changes in this PR: https://bevyengine.org/learn/book/plugins/