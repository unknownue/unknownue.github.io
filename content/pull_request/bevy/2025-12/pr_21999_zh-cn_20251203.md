+++
title = "#21999 Fix dragging-over panic"
date = "2025-12-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21999-en-20251203" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21999-zh-cn-20251203" }}
+++

# 标题
Fix dragging-over panic

## 基本信息
- **标题**: Fix dragging-over panic
- **PR链接**: https://github.com/bevyengine/bevy/pull/21999
- **作者**: ickshonpe
- **状态**: MERGED
- **标签**: C-Bug, P-Crash, C-Code-Quality, S-Ready-For-Final-Review, P-Regression, M-Migration-Guide, A-Picking
- **创建时间**: 2025-12-01T15:40:09Z
- **合并时间**: 2025-12-03T01:28:36Z
- **合并人**: alice-i-cecile

## 描述翻译
**目标**
存在的问题：

* 如果一个拖拽操作在已经悬停的实体上开始，`picking_events` 系统不会将该悬停实体添加到 `PointerButtonState` 中的 `dragging_over` 映射中。这会导致当指针移动时，`picking_events` 试图为这个悬停实体更新不存在的 `dragging_over` 状态，从而引发 panic。

* `DragEnter` 事件未在 `DragStart` 时被分发。这似乎不理想。虽然拖拽没有跨越几何边界，但它确实导致了被拖拽经过的实体进入一个“被拖拽经过”的状态。

修复 #21998

**解决方案**
* 在每一帧处理任何 `PointerInput` 之前，为所有悬停的实体更新 `dragging_state`。
* 重构了 `DragEnter` 的分发逻辑。现在，当拖拽在一个已悬停的实体上开始时，也会触发 `DragEnter` 事件。

**测试**
使用拖拽事件的示例应该不再 panic：

```
cargo run --example standard_widgets --features="experimental_bevy_ui_widgets"
```

```
cargo run --example ui_drag_and_drop
````

## 这个PR的故事

这次提交修复了 Bevy 引擎中 `bevy_picking` 模块一个与拖拽事件相关的崩溃问题。问题的核心在于状态管理的不一致，这为运行时 panic 创造了条件。

**问题与背景**
在合并这个 PR 之前，Bevy 的拾取系统（picking system）存在一个错误。当一个指针在某个实体上悬停时，会触发 `Over` 事件。如果用户此时按下鼠标按钮并开始拖拽（即 `DragStart`），系统会开始跟踪被拖拽的实体。然而，旧代码在处理这种情况时有一个疏漏：它没有将当前悬停的实体（如果不同于被拖拽的实体）记录为“正在被拖拽经过”（`dragging_over`）的状态。这个 `dragging_over` 状态保存在 `PointerButtonState` 结构的一个映射中。

这个疏漏的直接后果是，当指针在拖拽过程中移动时，系统会遍历 `dragging_over` 映射中的实体来发送 `DragOver` 事件。如果悬停的实体未被正确添加到此映射，代码 `*state.dragging_over.get_mut(&hovered_entity).unwrap() = hit.clone();` 会尝试获取一个不存在的条目，并调用 `unwrap()`，从而导致 panic。这是典型的“状态未初始化”错误。

此外，还存在一个逻辑上的不一致：`DragEnter` 事件本应在实体“进入”被拖拽状态时触发，但旧代码只在指针从外部移入一个实体时才触发，而在拖拽操作直接从一个已悬停的实体上开始时却不触发。

**解决方案与实现**
作者采取了两个关键步骤来解决这个问题，主要是修改了 `crates/bevy_picking/src/events.rs` 中的 `pointer_events` 系统。

1.  **统一的状态初始化**：首先，作者重组了事件处理逻辑的流程。在旧的代码中，检查悬停和更新 `dragging_over` 状态的逻辑与分发 `DragEnter` 和 `Over` 事件的逻辑紧密耦合，并且仅在实体从“未悬停”变为“悬停”时执行。新代码将这两部分解耦。
    现在，对于每个指针的每个悬停实体，代码会首先更新其 `dragging_over` 状态（如果存在拖拽中的实体），并检查是否需要分发 `DragEnter` 事件。然后，再独立判断是否需要分发 `Over` 事件。这种分离确保了无论悬停状态是否是新产生的，`dragging_over` 映射都会被正确维护。更新状态的核心逻辑移到了循环的更前面：
    ```rust
    for button in PointerButton::iter() {
        let state = pointer_state.get_mut(pointer_id, button);
        // 仅当有实体被拖拽时才更新 `dragging_over` 状态。
        // 仅当此 `hovered_entity` 之前没有 `dragging_over` 状态时才为其分发 DragEnter 事件。
        if !state.dragging.is_empty()
            && state
                .dragging_over
                .insert(hovered_entity, hit.clone())
                .is_none()
        {
            // ... 分发 DragEnter 事件
        }
    }
    ```
    这段代码保证了在每一帧的开始，所有当前悬停的实体（只要存在拖拽操作）都会被加入到 `dragging_over` 映射中。`HashMap::insert` 返回 `Option`，我们通过检查其是否为 `None` 来判断这是否是一个新条目，从而决定是否分发 `DragEnter` 事件。这个方法很巧妙，用一次操作同时完成了状态设置和事件触发条件的判断。

2.  **处理拖拽开始时的情况**：其次，作者修复了 `DragStart` 处理逻辑中的一个遗漏。在旧代码中，当检测到拖拽开始时，它只发送 `DragStart` 事件和开始发送 `Drag` 事件。新代码在触发 `DragStart` 后，立即添加了一段逻辑来处理当前悬停的实体（不包括被拖拽的实体本身）：
    ```rust
    // 插入拖拽经过状态并为悬停实体发送 DragEnter 事件。
    for (hovered_entity, hit) in hover_map
        .get(&pointer_id)
        .iter()
        .flat_map(|h| h.iter().map(|(entity, data)| (*entity, data.to_owned())))
        .filter(|(hovered_entity, _)| *hovered_entity != *press_target)
    {
        // 在此处插入 `dragging_over` 状态可确保 `DragEnter` 事件不会被分发两次。
        state.dragging_over.insert(hovered_entity, hit.clone());
        let drag_enter_event = Pointer::new(...);
        commands.trigger(drag_enter_event.clone());
        message_writers.drag_enter_events.write(drag_enter_event);
    }
    ```
    这里主动将悬停实体插入 `dragging_over` 映射并触发 `DragEnter` 事件。注释明确指出，这个主动插入操作是为了防止后续在“统一状态初始化”步骤中再次触发相同的 `DragEnter` 事件（因为 `insert` 会返回 `Some`，条件 `is_none()` 为假）。这体现了对事件流和状态生命周期的精细控制。

**影响与总结**
这些更改带来了两个明确的改进：
*   **消除了崩溃**：通过确保 `dragging_over` 映射在任何 `DragOver` 事件尝试更新它之前都已包含所有相关的悬停实体，彻底解决了 panic 问题。
*   **改进了事件语义**：`DragEnter` 事件现在能更准确地反映交互状态。无论指针是通过移动进入一个实体，还是直接在一个已悬停的实体上开始拖拽，该实体都会收到 `DragEnter` 事件，逻辑上更加一致。

从工程角度看，这个修复展示了处理状态机（state machine）时的一个常见最佳实践：在状态转换的边界，要明确、一致地初始化所有相关的衍生状态。同时，它也提醒我们，对于像 `HashMap::insert` 这样返回有用信息的 API，充分利用其返回值可以简化逻辑并避免错误。

由于这个更改影响了 `DragEnter` 事件的触发条件（行为变更），作者还创建了一个迁移指南文件 (`release-content/migration-guides/dragenter-now-fires-on-drag-starts.md`)，清晰地告知开发者这一变化，这是管理公共API变更的负责任的做法。

## 视觉表示

```mermaid
graph TD
    subgraph “每一帧开始”
        A[pointer_events 系统] --> B[遍历所有指针的 hover_map];
        B --> C{指针位置有效？};
        C -- 是 --> D[为每个按钮更新 dragging_over 状态];
        D --> E{有拖拽实体且为新条目？};
        E -- 是 --> F[分发 DragEnter 事件];
        E -- 否 --> G[跳过];
        C -- 否 --> H[记录日志并继续];
    end
    subgraph “处理 PointerInput::Press”
        I[检测到拖拽开始] --> J[分发 DragStart 事件];
        J --> K[为其他悬停实体插入 dragging_over 状态];
        K --> L[分发 DragEnter 事件];
    end
    subgraph “处理 PointerInput::Move (拖拽中)”
        M[遍历 dragging_over 映射] --> N[分发 DragOver 事件];
    end

    F -.-> N
    L -.-> N
```

## 关键文件更改

1.  `crates/bevy_picking/src/events.rs` (+53/-22)
    - **更改描述与原因**：这是修复的核心文件。修改了 `pointer_events` 系统函数，主要重组了更新 `dragging_over` 状态和触发 `DragEnter` 事件的逻辑，并确保在拖拽开始时也为当前悬停的实体触发 `DragEnter`。目的是修复 panic 并完善事件分发逻辑。
    - **关键代码片段**:
        ```rust
        // 之前（简化）: 只在实体从“未悬停”变为“悬停”时，才尝试插入 dragging_over 并发送 DragEnter。
        if !previous_hover_map.get(&pointer_id).iter().any(...) {
            // 获取 location...
            for button in PointerButton::iter() {
                let state = pointer_state.get_mut(pointer_id, button);
                for drag_target in state.dragging.keys() {
                    state.dragging_over.insert(hovered_entity, hit.clone()); // 无条件插入
                    // 发送 DragEnter...
                }
            }
            // 发送 Over...
        }

        // 之后: 先为所有悬停实体处理 dragging_over 和 DragEnter。
        // 获取 location...
        for button in PointerButton::iter() {
            let state = pointer_state.get_mut(pointer_id, button);
            // 有拖拽实体且是新条目时才插入和发送事件
            if !state.dragging.is_empty()
                && state.dragging_over.insert(hovered_entity, hit.clone()).is_none()
            {
                for drag_target in state.dragging.keys() {
                    // 发送 DragEnter...
                }
            }
        }
        // 然后独立判断是否发送 Over 事件。
        if !previous_hover_map.get(&pointer_id).iter().any(...) {
            // 发送 Over...
        }

        // 新增: 在 DragStart 处理块中，主动为其他悬停实体触发 DragEnter。
        // (在 commands.trigger(drag_start_event.clone()); 之后)
        for (hovered_entity, hit) in hover_map.get(&pointer_id)... {
            state.dragging_over.insert(hovered_entity, hit.clone()); // 主动插入
            let drag_enter_event = Pointer::new(...);
            commands.trigger(drag_enter_event.clone());
            message_writers.drag_enter_events.write(drag_enter_event);
        }
        ```

2.  `release-content/migration-guides/dragenter-now-fires-on-drag-starts.md` (+6/-0)
    - **更改描述与原因**：这是一个新增的迁移指南文件。因为 PR 修改了 `DragEnter` 事件的触发行为（现在在拖拽开始时也会触发），这是一个可能影响现有用户代码的变更。创建此文件是为了在发布说明中告知开发者这一行为变化，帮助他们调整自己的事件处理逻辑。
    - **关键代码片段**:
        ```markdown
        ---
        title: "DragEnter now fires on drag starts"
        pull_requests: [21999]
        ---

        `DragEnter` now also fires when a drag starts over an already hovered entity.
        ```

## 延伸阅读

*   **原始 Issue**: [#21998](https://github.com/bevyengine/bevy/issues/21998) - 详细描述了触发 panic 的具体场景和错误堆栈。
*   **Bevy Picking 官方文档**: 查看 [Bevy 官方文档](https://docs.rs/bevy_picking/latest/bevy_picking/) 中关于 `Pointer`, `DragStart`, `DragEnter`, `DragOver` 等事件和组件的说明，以全面理解拾取系统的工作机制。
*   **状态管理模式**: 这个修复本质上是关于UI交互状态（悬停、拖拽）的一致性维护。可以了解其他游戏引擎或UI框架（如React的State、Flutter的`GestureDetector`）如何处理类似复杂交互状态，以加深理解。