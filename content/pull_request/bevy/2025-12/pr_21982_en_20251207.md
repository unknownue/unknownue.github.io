+++
title = "#21982 Fix unsound `&EntityMutExcept` to `FilteredEntityMut` conversion"
date = "2025-12-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21982-en-20251207" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21982-zh-cn-20251207" }}
labels = ["C-Bug", "D-Trivial", "A-ECS", "P-Unsound"]
+++

# Title

## Basic Information
- **Title**: Fix unsound `&EntityMutExcept` to `FilteredEntityMut` conversion
- **PR Link**: https://github.com/bevyengine/bevy/pull/21982
- **Author**: ItsDoot
- **Status**: MERGED
- **Labels**: C-Bug, D-Trivial, A-ECS, S-Ready-For-Final-Review, P-Unsound
- **Created**: 2025-11-30T11:11:07Z
- **Merged**: 2025-12-07T19:10:07Z
- **Merged By**: mockersf

## Description Translation
This is already in English, so including the original description exactly as-is:

# Objective

Fix an effectively `& &mut` -> `&mut` conversion.

## Solution

Switch it to `&mut &mut` -> `&mut`.

## The Story of This Pull Request

This PR addresses a soundness issue in Bevy's ECS (Entity Component System) where a type conversion was incorrectly allowing immutable references to produce mutable handles. The problem was subtle but critical for maintaining Rust's borrowing guarantees.

**The Problem and Context**

In Bevy's ECS, `EntityMutExcept` is a type that provides mutable access to an entity while excluding access to certain components (specified by a `Bundle`). This is useful when you need to work with an entity but want to ensure you don't accidentally modify specific components. The `FilteredEntityMut` type is a more general mutable entity handle that can filter component access based on arbitrary conditions.

The issue was in the `From` implementation that allowed converting a shared reference (`&EntityMutExcept`) into a `FilteredEntityMut`. This created a soundness violation because:
- `EntityMutExcept` internally contains mutable access to entity data
- Taking an immutable reference (`&EntityMutExcept`) doesn't guarantee exclusive access to the underlying entity
- Converting this to `FilteredEntityMut` would then allow mutable operations through what was originally an immutable reference

In Rust terms, this was effectively trying to convert `& &mut T` into `&mut T`, which violates Rust's borrowing rules. The compiler's borrow checker might not catch this because the conversion happens through trait implementations rather than direct type conversions.

**The Solution Approach**

The fix is straightforward and correct: change the `From` implementation to require a mutable reference (`&mut EntityMutExcept`) instead of an immutable reference. This ensures that when you convert to a `FilteredEntityMut`, you must already have exclusive mutable access to the `EntityMutExcept`, which then properly transfers that exclusivity to the `FilteredEntityMut`.

This aligns with Rust's ownership and borrowing principles:
- If you have an immutable reference, you can only perform immutable operations
- If you need to perform mutable operations, you need a mutable reference
- Converting between handle types shouldn't bypass these guarantees

**The Implementation**

The implementation change is minimal but critical. In `crates/bevy_ecs/src/world/entity_access/except.rs`, the `From` implementation for `FilteredEntityMut` was changed from accepting `&EntityMutExcept` to accepting `&mut EntityMutExcept`:

```rust
// Before: Unsound conversion from immutable reference
impl<'w, 's, B: Bundle> From<&'w EntityMutExcept<'_, 's, B>> for FilteredEntityMut<'w, 's> {
    fn from(value: &'w EntityMutExcept<'_, 's, B>) -> Self {
        // SAFETY:
        // - The FilteredEntityMut has the same component access as the given EntityMutExcept.
        unsafe { FilteredEntityMut::new(value.entity, value.access) }
    }
}

// After: Sound conversion requiring mutable reference
impl<'w, 's, B: Bundle> From<&'w mut EntityMutExcept<'_, 's, B>> for FilteredEntityMut<'w, 's> {
    fn from(value: &'w mut EntityMutExcept<'_, 's, B>) -> Self {
        // SAFETY:
        // - The FilteredEntityMut has the same component access as the given EntityMutExcept.
        unsafe { FilteredEntityMut::new(value.entity, value.access) }
    }
}
```

The safety comment remains valid because the safety invariants of `FilteredEntityMut::new` don't depend on whether the input reference is mutable or immutable. What changes is the soundness of the conversion itself - by requiring a mutable reference, we ensure proper exclusivity.

**Technical Insights**

This fix demonstrates several important Rust concepts:

1. **Reference Mutability and Aliasing**: Rust's borrow checker prevents data races by enforcing that either you have one mutable reference or multiple immutable references, but not both. The original code violated this by allowing mutable access through what appeared to be an immutable reference path.

2. **Type Conversions and Safety**: Even when using `unsafe` blocks for performance or implementation reasons, the public API must maintain Rust's safety guarantees. The `unsafe` block here is for creating the `FilteredEntityMut`, but the conversion trait implementation itself must ensure proper preconditions.

3. **Entity Component System Patterns**: In ECS systems, entity handles often need to propagate access permissions correctly. This fix ensures that access control flows properly through the conversion chain.

**The Impact**

This fix prevents potential undefined behavior in code that uses `EntityMutExcept` and converts it to `FilteredEntityMut`. Without this fix, concurrent systems could potentially have mutable access to the same entity data, leading to data races or other memory safety issues.

The impact is primarily on code correctness rather than performance or features. Code that was previously using the conversion with immutable references will now need to use mutable references, which may require adjusting call sites to ensure proper borrowing. This is a breaking change for that specific API usage, but necessary for soundness.

The labels on the PR tell the story: it's marked as a bug (`C-Bug`), trivial in implementation complexity (`D-Trivial`), related to ECS (`A-ECS`), and most importantly, addressing unsoundness (`P-Unsound`). Unsoundness fixes are typically high priority in Rust projects because they affect the fundamental safety guarantees of the language.

## Visual Representation

```mermaid
graph TD
    A[&EntityMutExcept] -->|Previously: Unsound| B[FilteredEntityMut<br/>(mutable access)]
    C[&mut EntityMutExcept] -->|Now: Sound| B
    
    style A stroke:#f66,stroke-width:2px
    style C stroke:#6f6,stroke-width:2px
    style B stroke:#333,stroke-width:2px
```

This diagram shows the problematic conversion path (in red) that was fixed, and the correct conversion path (in green) that now properly requires mutable access.

## Key Files Changed

**File: `crates/bevy_ecs/src/world/entity_access/except.rs`**
- **Change**: Modified the `From<&EntityMutExcept>` implementation to `From<&mut EntityMutExcept>` for `FilteredEntityMut`
- **Reason**: To fix a soundness issue where immutable references could be converted to mutable handles
- **Impact**: Ensures proper borrowing rules are maintained when converting between entity handle types

**Code Change:**
```rust
// Before (unsound):
impl<'w, 's, B: Bundle> From<&'w EntityMutExcept<'_, 's, B>> for FilteredEntityMut<'w, 's> {
    fn from(value: &'w EntityMutExcept<'_, 's, B>) -> Self {
        // SAFETY:
        // - The FilteredEntityMut has the same component access as the given EntityMutExcept.
        unsafe { FilteredEntityMut::new(value.entity, value.access) }
    }
}

// After (sound):
impl<'w, 's, B: Bundle> From<&'w mut EntityMutExcept<'_, 's, B>> for FilteredEntityMut<'w, 's> {
    fn from(value: &'w mut EntityMutExcept<'_, 's, B>) -> Self {
        // SAFETY:
        // - The FilteredEntityMut has the same component access as the given EntityMutExcept.
        unsafe { FilteredEntityMut::new(value.entity, value.access) }
    }
}
```

## Further Reading

1. **Rustonomicon - Subtyping and Variance**: https://doc.rust-lang.org/nomicon/subtyping.html
   - Explains Rust's type system rules around references and mutability

2. **The Rust Reference - Unsafety**: https://doc.rust-lang.org/reference/unsafety.html
   - Details what constitutes unsafe code and the responsibilities of unsafe blocks

3. **Bevy ECS Documentation - Entity References**: https://bevyengine.org/learn/ecs/entity-references/
   - Bevy's documentation on entity handles and access patterns

4. **Rust API Guidelines - Type Conversions**: https://rust-lang.github.io/api-guidelines/naming.html#conversions-use-as_-to_-into_-conventions-c-conv
   - Best practices for implementing conversion traits in Rust

5. **Common Rust Lifetime Misconceptions**: https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md
   - Helpful for understanding common pitfalls with references and lifetimes

# Full Code Diff
```
diff --git a/crates/bevy_ecs/src/world/entity_access/except.rs b/crates/bevy_ecs/src/world/entity_access/except.rs
index 92d372e26bd81..6a2261dbf2186 100644
--- a/crates/bevy_ecs/src/world/entity_access/except.rs
+++ b/crates/bevy_ecs/src/world/entity_access/except.rs
@@ -429,8 +429,8 @@ where
     }
 }
 
-impl<'w, 's, B: Bundle> From<&'w EntityMutExcept<'_, 's, B>> for FilteredEntityMut<'w, 's> {
-    fn from(value: &'w EntityMutExcept<'_, 's, B>) -> Self {
+impl<'w, 's, B: Bundle> From<&'w mut EntityMutExcept<'_, 's, B>> for FilteredEntityMut<'w, 's> {
+    fn from(value: &'w mut EntityMutExcept<'_, 's, B>) -> Self {
         // SAFETY:
         // - The FilteredEntityMut has the same component access as the given EntityMutExcept.
         unsafe { FilteredEntityMut::new(value.entity, value.access) }
```