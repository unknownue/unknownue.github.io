+++
title = "#22107 Global Gizmos"
date = "2025-12-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22107-en-20251215" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22107-zh-cn-20251215" }}
labels = ["C-Feature", "A-Gizmos"]
+++

# Title: Global Gizmos

## Basic Information
- **Title**: Global Gizmos
- **PR Link**: https://github.com/bevyengine/bevy/pull/22107
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: C-Feature, S-Ready-For-Final-Review, A-Gizmos
- **Created**: 2025-12-13T15:18:25Z
- **Merged**: 2025-12-15T21:12:20Z
- **Merged By**: alice-i-cecile

## Description Translation

**Objective**
- 在非系统上下文中使用gizmos，例如在数学库深处或没有ECS访问权限的回调函数中
- 某种程度上是https://github.com/atlv24/glizmo的上游版本
- 基于https://github.com/bevyengine/bevy/pull/22105构建

**Solution**
- mutex + deref

**Testing**
- 

## The Story of This Pull Request

这个PR解决了Bevy引擎中Gizmos系统的一个关键限制：只能在拥有ECS访问权限的系统（system）中使用。在实际开发中，开发者经常需要在非ECS上下文中绘制调试图形，例如在数学计算库中、在回调函数中，或是在没有系统参数访问权限的任何地方。

问题的核心在于，原有的`Gizmos`资源只能通过系统参数访问，这限制了它的使用场景。开发者需要一种全局访问的方式，能够从任何代码位置绘制gizmos，而不仅仅是在系统内部。

解决方案采用了简单直接的方法：使用静态互斥锁（static Mutex）包装一个全局的`GizmoBuffer`。这个设计包含几个关键部分：

首先，在`global.rs`中定义了一个静态变量`GLOBAL_GIZMO`，它是一个`Mutex<GizmoBuffer<DefaultGizmoConfigGroup, ()>>`。选择`Mutex`是因为需要线程安全的内部可变性——多个线程可能同时尝试绘制gizmos。

```rust
static GLOBAL_GIZMO: Mutex<GizmoBuffer<DefaultGizmoConfigGroup, ()>> =
    Mutex::new(GizmoBuffer::new());
```

公开的API是一个简单的函数`gizmo()`，它返回一个实现了`DerefMut<Target = GizmoBuffer<DefaultGizmoConfigGroup, ()>>`的类型。这使得调用者可以直接使用所有标准的Gizmo绘制方法。

```rust
pub fn gizmo() -> impl core::ops::DerefMut<Target = GizmoBuffer<DefaultGizmoConfigGroup, ()>> {
    GLOBAL_GIZMO.lock().unwrap()
}
```

使用示例展示了这个API的简洁性：
```rust
fn draw() {
    gizmo().sphere(Isometry3d::IDENTITY, 0.5, WHITE);
}
```

然而，仅有全局缓冲区还不够。由于全局gizmos在任意时间被绘制，它们需要被收集并最终渲染到屏幕上。这就是`GlobalGizmosPlugin`的作用所在。

该插件在`Last`调度阶段添加了一个系统`flush_global_gizmos`，并确保它在`GizmoMeshSystems`之前运行。这个系统负责每帧将全局缓冲区的内容传输到主`Gizmos`资源中。

```rust
fn flush_global_gizmos(mut gizmos: Gizmos) {
    let mut buffer = GizmoBuffer::new();
    {
        core::mem::swap(&mut buffer, &mut GLOBAL_GIZMO.lock().unwrap());
    }
    gizmos.strip_positions.extend(buffer.strip_positions);
    gizmos.strip_colors.extend(buffer.strip_colors);
    gizmos.list_positions.extend(buffer.list_positions);
    gizmos.list_colors.extend(buffer.list_colors);
}
```

使用`mem::swap`而不是直接获取所有权的原因是效率考虑——它避免了不必要的内存分配。交换操作将全局缓冲区的内容移出，同时留下一个新的空缓冲区供下一帧使用。

从架构角度来看，这个实现建立在PR #22105的基础上，该PR可能已经重构了Gizmo系统，使其更适合这种扩展。全局gizmos系统与现有的ECS-based系统无缝集成，不会破坏现有的工作流程。

性能方面需要注意，使用全局互斥锁意味着全局gizmos绘制可能会成为多线程环境中的争用点。但考虑到gizmos主要用于调试和开发，这种开销通常是可接受的。如果需要在性能关键的生产代码中使用gizmos，可能仍需使用传统的系统参数方式。

这个PR体现了良好的API设计原则：它为特定用例提供了一个简洁的解决方案，而不影响现有API的稳定性。开发者在需要时可以选择使用全局gizmos，而在系统内部则继续使用标准的`Gizmos`参数。

## Visual Representation

```mermaid
graph TB
    subgraph "Global Context"
        A[任意代码位置] --> B[调用 gizmo() 函数]
    end
    
    subgraph "Frame Start"
        C[静态 GLOBAL_GIZMO] --> D[Mutex锁保护]
        D --> E[GizmoBuffer]
    end
    
    subgraph "Frame End (Last阶段)"
        F[flush_global_gizmos 系统] --> G[交换缓冲区内容]
        G --> H[主Gizmos资源]
    end
    
    B --> E
    E --> G
    H --> I[GizmoMeshSystems]
    I --> J[渲染到屏幕]
```

## Key Files Changed

### 1. `crates/bevy_gizmos/src/global.rs` (+48/-0)
这是新增的文件，包含了全局gizmos功能的核心实现。

**关键代码：**
```rust
// 全局静态gizmo缓冲区
static GLOBAL_GIZMO: Mutex<GizmoBuffer<DefaultGizmoConfigGroup, ()>> =
    Mutex::new(GizmoBuffer::new());

// 插件系统
impl Plugin for GlobalGizmosPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Last, flush_global_gizmos.before(GizmoMeshSystems));
    }
}

// 全局gizmo访问函数
pub fn gizmo() -> impl core::ops::DerefMut<Target = GizmoBuffer<DefaultGizmoConfigGroup, ()>> {
    GLOBAL_GIZMO.lock().unwrap()
}
```

### 2. `crates/bevy_gizmos/src/lib.rs` (+3/-1)
修改了主库文件以集成新的全局功能。

**修改内容：**
```rust
// 添加了global模块
mod global;

// 在prelude中导出gizmo函数
pub mod prelude {
    // ...
    pub use crate::global::gizmo;
}

// 在插件中添加GlobalGizmosPlugin
impl Plugin for GizmoPlugin {
    fn build(&self, app: &mut App) {
        // ...
        app.add_plugins((aabb::AabbGizmoPlugin, global::GlobalGizmosPlugin));
    }
}
```

## Further Reading

1. **Bevy ECS调度系统**：了解Bevy的调度阶段，特别是`Last`阶段的作用
2. **Rust的Mutex和线程安全**：理解`std::sync::Mutex`的工作原理和使用场景
3. **Deref Trait模式**：研究Rust中通过`Deref`和`DerefMut`traits实现的智能指针模式
4. **Bevy Gizmos系统架构**：查看PR #22105了解Gizmo系统的底层重构
5. **静态变量的线程安全**：学习Rust中`static`变量与同步原语的结合使用