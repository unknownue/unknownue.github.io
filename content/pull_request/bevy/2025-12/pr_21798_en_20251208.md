+++
title = "#21798 Implement world.trigger_event remote method"
date = "2025-12-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21798-en-20251208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21798-zh-cn-20251208" }}
labels = ["C-Feature", "A-Dev-Tools"]
+++

# Title
Implement world.trigger_event remote method

## Basic Information
- **Title**: Implement world.trigger_event remote method
- **PR Link**: https://github.com/bevyengine/bevy/pull/21798
- **Author**: Lancelotbronner
- **Status**: MERGED
- **Labels**: C-Feature, S-Ready-For-Final-Review, A-Dev-Tools, X-Uncontroversial
- **Created**: 2025-11-10T06:57:09Z
- **Merged**: 2025-12-08T22:01:20Z
- **Merged By**: mockersf

## Description Translation

# Objective

Tools using `bevy_remote` will be able to identify (via the schema) and trigger events.

- [x] Document `bevy_ecs/src/reflect/event.rs`

## Solution

I've added a method `world.trigger_event`, added `Event` to the schema's reflection metadata and `ReflectEvent` to allow this.

## Testing

I have copied the (tested) code from my game but have NOT tested this branch yet.
I am new to Rust/Cargo and need to go to sleep now, I'll figure this out and test it tomorrow.

---

## Showcase

Here's what I needed to add to my game in order to allow my editor to access and trigger an event:

```rust
#[derive(Event, Reflect)]
#[reflect(Event)]
pub struct AssignToRoute {
    pub vehicle: Entity,
    pub route: Entity,
    pub origin: Entity,
}
```

Here's a screenshot of my editor using this feature:

<img width="1463" height="967" alt="Screenshot 2025-11-10 at 1 40 42 AM" src="https://github.com/user-attachments/assets/7696ddb8-3552-4e0d-a78f-6178c0c66cbb" />

## The Story of This Pull Request

This pull request addresses a specific gap in Bevy's remote tooling capabilities. The developer was building an external editor that needed to interact with a running Bevy application through the `bevy_remote` system. While the remote API already provided methods for manipulating components and resources, it lacked a way to trigger events, which are a fundamental part of Bevy's ECS architecture for handling one-shot occurrences.

The core problem was straightforward: external tools couldn't trigger events in a remote Bevy application. This limitation meant that editors couldn't simulate game interactions or send commands to the application via events. The developer needed this functionality for their editor to assign vehicles to routes in their game, as shown in the showcase example.

The solution follows Bevy's existing patterns for reflection and remote APIs. The implementation adds three main components:

1. **Event reflection infrastructure** similar to what already existed for components and resources
2. **A new remote method** `world.trigger_event` that uses this reflection
3. **Schema updates** so remote tools can discover which events are available

Looking at the implementation, the developer created a new `ReflectEvent` type in `bevy_ecs/src/reflect/event.rs`. This follows the same pattern as `ReflectComponent` and `ReflectResource` - it provides a way to work with events through runtime type information rather than compile-time generics. The `ReflectEvent` struct contains a function pointer that knows how to trigger an event of a specific type given a reflected representation of that event.

The key insight here is that events in Bevy need to be triggered through their specific `Event` trait implementation, but when working remotely, we only know the type at runtime. The `ReflectEvent` implementation bridges this gap by using `from_reflect_with_fallback` to deserialize the event data and then calling `world.trigger()` with the deserialized event.

In the remote layer, the new `process_remote_trigger_event_request` function handles incoming requests. It looks up the event type in the type registry, finds its `ReflectEvent` implementation, deserializes the event payload if provided (or uses a default), and triggers the event. This follows the same error handling patterns as existing remote methods - if the event type isn't found or isn't reflectable, appropriate errors are returned.

The implementation also includes comprehensive documentation in the new event reflection module, explaining how `ReflectEvent` works and when developers might need to create custom implementations. This is important because the pattern mirrors existing reflection types in Bevy, and the documentation helps maintain consistency across the codebase.

One interesting detail is the test included in `builtin_methods.rs`. It shows how the feature works end-to-end: defining a reflectable event, setting up an observer to detect when the event is triggered, then using the remote method to trigger it and verifying the observer was called. This test pattern is consistent with existing tests in the module and provides confidence that the implementation works correctly.

The impact of this change is that external tools can now fully interact with Bevy applications through events, not just through component and resource manipulation. This completes the remote API's coverage of Bevy's core ECS concepts and enables more sophisticated tooling. For example, game editors can now send commands to the game, debugging tools can simulate specific scenarios, and automation scripts can trigger events as part of testing pipelines.

## Visual Representation

```mermaid
graph TD
    A[Remote Client] -->|BRP Request| B[bevy_remote]
    B -->|world.trigger_event| C[process_remote_trigger_event_request]
    C --> D[TypeRegistry]
    D -->|Lookup| E[ReflectEvent]
    E -->|Trigger| F[World]
    F -->|Event Observer| G[Game Systems]
    
    H[Event Definition] -->|#[reflect(Event)]| I[Type Registration]
    I --> D
```

## Key Files Changed

### `crates/bevy_ecs/src/reflect/event.rs` (+76/-0)
This new file adds event reflection capabilities to match existing component and resource reflection patterns. It defines `ReflectEvent` and `ReflectEventFns` structs that allow triggering events through runtime type information.

Key code:
```rust
pub struct ReflectEvent(ReflectEventFns);

pub struct ReflectEventFns {
    trigger: fn(&mut World, &dyn PartialReflect, &TypeRegistry),
}

impl ReflectEvent {
    pub fn trigger(&self, world: &mut World, event: &dyn PartialReflect, registry: &TypeRegistry) {
        (self.0.trigger)(world, event, registry);
    }
}
```

### `crates/bevy_remote/src/builtin_methods.rs` (+94/-4)
This file adds the new remote method implementation. It includes the request parameter struct, the handler function, and a comprehensive test.

Key additions:
```rust
pub const BRP_TRIGGER_EVENT_METHOD: &str = "world.trigger_event";

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
struct BrpTriggerEventParams {
    pub event: String,
    pub value: Option<Value>,
}

pub fn process_remote_trigger_event_request(
    In(params): In<Option<Value>>,
    world: &mut World,
) -> BrpResult {
    // Implementation handles event lookup and triggering
}
```

### `crates/bevy_remote/src/lib.rs` (+15/-1)
Updated to document the new remote method and register it in the `RemotePlugin`.

Key change:
```rust
// Added to method registration in RemotePlugin
.with_method(
    builtin_methods::BRP_TRIGGER_EVENT_METHOD,
    builtin_methods::process_remote_trigger_event_request,
)
```

### `crates/bevy_remote/src/schemas/mod.rs` (+2/-1)
Updated to include `ReflectEvent` in schema metadata so remote tools can discover available events.

Key change:
```rust
data_types.map_type_data::<ReflectEvent>("Event");
```

### `crates/bevy_ecs/src/lib.rs` (+1/-1)
Updated the prelude to export `ReflectEvent` when the `bevy_reflect` feature is enabled.

Key change:
```rust
pub use crate::reflect::{
    AppTypeRegistry, ReflectComponent, ReflectEvent, ReflectFromWorld, ReflectResource,
};
```

## Further Reading

- [Bevy ECS Events Documentation](https://bevyengine.org/learn/book/events/) - Official guide to Bevy's event system
- [Bevy Reflection System](https://bevyengine.org/learn/book/reflection/) - How Bevy's reflection system works
- [Bevy Remote API](https://github.com/bevyengine/bevy/tree/main/crates/bevy_remote) - Source code and examples for remote tooling
- [Serde JSON](https://docs.serde.rs/serde_json/) - JSON serialization used in remote protocol