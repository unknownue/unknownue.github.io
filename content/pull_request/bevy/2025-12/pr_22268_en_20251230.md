+++
title = "#22268 gltf extension handler release notes"
date = "2025-12-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22268-en-20251230" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22268-zh-cn-20251230" }}
labels = ["C-Docs", "A-glTF"]
+++

# Title
gltf extension handler release notes

## Basic Information
- **Title**: gltf extension handler release notes
- **PR Link**: https://github.com/bevyengine/bevy/pull/22268
- **Author**: ChristopherBiscardi
- **Status**: MERGED
- **Labels**: C-Docs, S-Ready-For-Final-Review, A-glTF
- **Created**: 2025-12-25T17:39:56Z
- **Merged**: 2025-12-30T21:17:08Z
- **Merged By**: alice-i-cecile

## Description Translation
Release notes for #22106

## The Story of This Pull Request

The Bevy engine's glTF loader had a limitation: its ability to handle glTF extensions was hardcoded into the engine itself. Before version 0.18, if you wanted to use a glTF extension like `KHR_lights_punctual`, the code to parse and apply that data was baked directly into Bevy's core glTF loading logic. This worked for the extensions Bevy officially supported, but it created a rigid architecture. Game developers or community members couldn't easily add support for new or custom glTF extensions without modifying the engine's source code. The problem was a lack of extensibility in a critical asset pipeline.

This PR addresses that problem not by changing the engine's code, but by documenting the solution that was implemented in a previous PR (#22106). That solution introduced a public API for userspace extension handling. The core change was the addition of the `GltfExtensionHandler` trait, which allows developers to write their own logic to process glTF data as it loads. This is a significant architectural shift. Instead of the loader having a fixed set of capabilities, it now provides hooks for custom logic.

The documentation created in this PR explains the concept and its practical applications. A key technical point clarified is the distinction between glTF "Extras" and "Extensions." Bevy already handled "Extras" well (arbitrary user data often added in tools like Blender), storing them in `GltfExtras` components. "Extensions," however, are a more formal and powerful mechanism defined by the glTF specification for adding new types of data and objects. The new handler system specifically targets these extensions.

The implementation of a `GltfExtensionHandler` is stateful. It processes data during the glTF loading sequence, which means it can interact with the standard loading pipeline. This is powerful because to meaningfully process extension data, a handler often also needs to understand and potentially modify the standard assets being created, like meshes, materials, and animations. The release notes outline several concrete use cases: inserting custom Bevy components onto entities, converting 3D meshes to 2D, building `AnimationGraph`s, replacing standard materials, and inserting lightmaps.

To ground the explanation, the documentation includes a case study of the [Skein](https://github.com/rust-adventure/skein) project. Skein defines its own glTF extension to embed Bevy component data directly into glTF files authored in Blender. With a corresponding `GltfExtensionHandler`, Skein can read those files and have the components ready on entities immediately when a scene is spawned. This demonstrates the system's value for creating workflows between content creation tools and the game engine.

Finally, the notes point developers to two new examples added alongside the feature. These examples serve as practical starting points: one shows how to build and attach an `AnimationGraph`, and the other demonstrates converting 3D assets to 2D. The inclusion of runnable examples (`cargo run --example gltf_extension_animation_graph`) completes the story, providing both the conceptual framework and the executable code needed for adoption.

## Visual Representation

```mermaid
graph TD
    subgraph "glTF Loading Pipeline"
        A[glTF File] --> B[Bevy glTF Loader]
        B --> C[Standard Processing<br/>(Meshes, Materials, etc.)]
        B --> D[`GltfExtensionHandler` Trait]
    end

    D --> E[Custom Handler 1<br/>e.g., Insert Components]
    D --> F[Custom Handler 2<br/>e.g., Convert 3D to 2D]
    D --> G[Custom Handler N...]

    C --> H[Final Entity/Scene]
    E --> H
    F --> H
    G --> H
```

## Key Files Changed

**File: `release-content/release-notes/gltf_extension_handling.md` (+53/-0)**

This is a new file created to document the `GltfExtensionHandler` feature for the Bevy 0.18 release. It explains the problem solved, the new capability, and provides practical guidance for developers.

Key modifications (the entire file is new):
```markdown
---
title: "Userspace glTF Extension Handling"
authors: ["@christopherbiscardi"]
pull_requests: [22106]
---

Prior to 0.18, the code to handle extensions like `KHR_lights_punctual` was hardcoded into Bevy's glTF loader.
In 0.18, users may implement the `GltfExtensionHandler` trait to do stateful processing of glTF data as it loads.
Processing _extension_ data is only half the story here because to process extension data you also have to be able to process the non-extension data like meshes, materials, animations, and more.

Extension handlers can be written for wide variety of use cases, including:

- Insert Bevy Component data on entities
- Convert all `Mesh3d` components to `Mesh2d`
- Build `AnimationGraph`s and insert them on animation roots
- Replace `StandardMaterial` with custom materials
- Insert lightmaps

## Extras vs Extensions

glTF has two mechanisms for extending glTF files with additional user data: Extras and Extensions.

**Extras** are meant to be arbitrary application-specific data, often authored by users directly in tools like Blender's custom properties.
Extras are historically well supported by Bevy; If you add a custom property in Blender that data will end up in one of the `GltfExtras` components on the relevant `Entity`.

**Extensions** are meant for data that can be shared across applications.
They are more flexible, allowing for new data in more places inside a glTF file, and more powerful as a result.
Extensions can add new object types, such as `lights` from the `KHR_lights_punctual` extension, as well as arbitrary buffers, data that is at the root of the glTF file, and more.

More examples of extensions can be found in the [KhronosGroup git repo](https://github.com/KhronosGroup/glTF/blob/7bbd90978cad06389eee3a36882c5ef2f2039faf/extensions/README.md)

## Case Study

Extensions typically require an application that is _producing_ the data as well as _consuming_ the data.

For example: [Skein](https://github.com/rust-adventure/skein) defines a glTF extension that allows adding Bevy Components to glTF objects.
This is most commonly produced by Blender and consumed by Skein's `GltfExtensionHandler` in Bevy.
These components are then inserted on entities in a scene at the same time built-in components like `Transform` and `Mesh3d` are.

Using glTF Extensions for this data means that other level editors like Trenchbroom can also write the same format to glTF files.
Any third party software that writes component data into a glTF file can use Skein's `GltfExtensionHandler`, resulting in components being "ready-to-go" when spawning `Scene`s.

## New Examples

Two new examples show off use cases:

- The first builds an `AnimationGraph` and inserts it onto the animation root in a Scene, which means it is now accessible to play animations using the `AnimationPlayer` on the same `Entity` later when that Scene is spawned.
- The second uses a `GltfExtensionHandler` to switch the 3d Mesh and Material components for their 2d counterparts. This is useful if you're using software like Blender to build 2d worlds.

```shell
cargo run --example gltf_extension_animation_graph
cargo run --example gltf_extension_mesh_2d
```
```

## Further Reading

1. **The glTF 2.0 Specification**: The official [Khronos glTF 2.0 Specification](https://github.com/KhronosGroup/glTF/tree/main/specification/2.0) is the authoritative source for understanding the Extras and Extensions mechanisms.
2. **Bevy Examples**: The Bevy repository's [examples](https://github.com/bevyengine/bevy/tree/main/examples) directory, specifically the new `gltf_extension_animation_graph` and `gltf_extension_mesh_2d` examples, provide concrete Rust implementations.
3. **PR #22106**: The original implementation pull request that added the `GltfExtensionHandler` trait to Bevy's codebase.
4. **Skein Project**: The [Skein repository](https://github.com/rust-adventure/skein) offers a real-world case study of defining a custom glTF extension and building a handler for it.