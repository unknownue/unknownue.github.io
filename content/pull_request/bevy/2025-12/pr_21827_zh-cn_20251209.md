+++
title = "#21827 Add vertical slider support to bevy_ui_widgets slider"
date = "2025-12-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21827-en-20251209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21827-zh-cn-20251209" }}
labels = ["C-Feature", "A-UI", "D-Straightforward"]
+++

# Add vertical slider support to bevy_ui_widgets slider

## Basic Information
- **Title**: Add vertical slider support to bevy_ui_widgets slider
- **PR Link**: https://github.com/bevyengine/bevy/pull/21827
- **Author**: DuckyBlender
- **Status**: MERGED
- **Labels**: C-Feature, A-UI, S-Ready-For-Final-Review, X-Uncontroversial, D-Straightforward
- **Created**: 2025-11-13T15:37:03Z
- **Merged**: 2025-12-09T05:40:08Z
- **Merged By**: alice-i-cecile

## 描述翻译

### 目标

- 修复垂直滑块无法正常工作的问题。之前创建垂直滑块时，滑块拖动行为仍然是水平的，意味着左右拖动会改变值而不是上下拖动。此外，点击滑块轨道的位置存在偏移，无法正确映射到点击位置。

### 解决方案

滑块控件现在根据节点尺寸自动检测方向（`高度 > 宽度` 为垂直方向，否则为水平方向），并相应调整交互行为：

1. **方向检测**：在 `slider_on_pointer_down` 和 `slider_on_drag` 函数中，通过比较 `node.size().y` 和 `node.size().x` 添加了滑块方向自动检测。

2. **拖动方向修复**：
   - 对于垂直滑块，拖动计算现在使用 Y 轴（`distance.y`）而不是 X 轴
   - Y 坐标被正确反转（因为屏幕 Y 向下增加）以匹配预期行为（向上拖动增加值）
   - 滑块尺寸计算对垂直滑块使用 `thumb.size().y`，而不是总是使用 `thumb.size().x`

3. **点击位置修复**：
   - 修复了从 Bevy 的中心原点坐标系到左上角原点坐标系的坐标转换
   - 对于垂直滑块：在计算滑块值之前，将 `local_pos.y` 从 `[-高度/2, +高度/2]` 转换为 `[0, 高度]`
   - 考虑滑块尺寸偏移以正确居中计算
   - 对垂直滑块反转 Y 坐标，因为 Y 向下增加

4. **轨道尺寸计算**：计算可用轨道空间时，垂直滑块使用 `node.size().y - thumb_size`，水平滑块使用 `node.size().x - thumb_size`。

这些更改向后兼容 - 水平滑块继续像以前一样工作，方向检测对 API 用户是透明的。

### 测试

- **手动测试**：创建了包含垂直和水平滑块的测试应用程序以验证：
  - 垂直滑块正确响应垂直拖拽动作（向上 = 增加，向下 = 减少）
  - 水平滑块继续正确工作，响应水平拖拽动作
  - 点击滑块轨道上的任意位置都能正确跳转到该位置（两种方向）
  - 滑块位置在拖拽操作期间正确更新
  - 多个滑块可以共存而不互相干扰

- **测试的边缘情况**：
  - 点击垂直滑块的最顶部/最底部
  - 点击水平滑块的最左侧/最右侧
  - 从一个极端拖拽到另一个极端
  - 快速点击和拖拽交互

**可能需要更多测试的领域**：
- 具有非标准宽高比的滑块（非常宽的垂直滑块或非常高的水平滑块）
- 应用了自定义变换/旋转的滑块
- 具有复杂变换的嵌套 UI 层次结构中的滑块

**审阅者如何测试**：
1. 创建垂直滑块（高度 > 宽度）并验证：
   - 向上拖动增加值
   - 向下拖动减少值
   - 点击轨道任意位置都能跳转到该确切位置
2. 创建水平滑块（宽度 > 高度）并验证其仍然像以前一样工作
3. 同时测试多个两种方向的滑块

**测试平台**：
- macOS（Apple Silicon）

### 展示

#### 之前
- 垂直滑块无法使用 - 拖动会水平移动而不是垂直移动
- 点击垂直滑块轨道有偏移，点击底部附近会跳转到中间

https://github.com/user-attachments/assets/9bda83e7-f46b-4626-9df3-a558526a8ab2

#### 之后
- 垂直滑块正常工作，具有直观的上下拖动行为
- 点击滑块轨道任意位置都能准确跳转到点击位置
- 垂直和水平滑块无缝协同工作

https://github.com/user-attachments/assets/cca24288-4cbc-4ceb-828f-9ce7a735ade0

### 代码示例

```rust
// 垂直滑块 - 现在可以正常工作！
commands.spawn((
    Node {
        width: Val::Px(12.0),
        height: Val::Px(300.0),  // 高度 > 宽度 = 垂直
        ..default()
    },
    Slider::default(),
    SliderValue(50.0),
    SliderRange::new(0.0, 100.0),
    // ... 滑块和轨道的子元素
));

// 水平滑块 - 继续像以前一样工作
commands.spawn((
    Node {
        width: Val::Px(300.0),
        height: Val::Px(12.0),  // 宽度 > 高度 = 水平
        ..default()
    },
    Slider::default(),
    SliderValue(50.0),
    SliderRange::new(0.0, 100.0),
    // ... 滑块和轨道的子元素
));
```

方向基于节点尺寸自动检测 - 无需 API 更改！

## 这个 PR 的故事

这个 PR 解决了一个直接的 UI 组件问题：Bevy 的 `bevy_ui_widgets` 滑块控件原本只支持水平方向。当开发者尝试创建垂直滑块时，交互行为仍然是水平的 - 左右拖动会改变滑块值，而不是上下拖动。这本质上破坏了垂直滑块的可用性，限制了 UI 设计的灵活性。

问题源于滑块交互逻辑的硬编码假设。在 `slider.rs` 的 `slider_on_pointer_down` 和 `slider_on_drag` 函数中，所有计算都基于 X 轴坐标进行，忽略了节点的实际方向。这意味着垂直滑块的点击位置映射和拖拽方向都不正确。

解决方案采用了简单而有效的方法：根据节点的宽高比自动检测方向。核心逻辑是 `let is_vertical = node.size().y > node.size().x;`。这个检测在两个关键函数中重复使用，确保交互处理的一致性。

实现中的关键洞察是需要处理坐标系转换。对于垂直滑块，有几点需要注意：
1. 屏幕 Y 坐标向下增加，而用户期望向上拖动时值增加
2. Bevy 使用中心原点坐标系，而滑块计算需要左上角原点
3. 滑块位置计算需要根据方向使用不同的轴

在 `slider_on_pointer_down` 函数中，点击位置计算根据方向进行了分支：
- 水平滑块：`local_pos.x + node.size().x / 2.0` 将中心原点转换为左原点
- 垂直滑块：`(node.size().y / 2.0) - local_pos.y` 进行坐标反转和原点转换

`slider_on_drag` 函数也进行了类似的调整，根据方向使用 `distance.x` 或 `distance.y`。值得注意的是，代码还移除了对 `SliderValue` 的查询，改为直接触发 `ValueChange` 事件，这简化了逻辑并确保一致性。

一个微妙但重要的细节是滑块大小的获取方式。原来总是使用 `thumb.size().x`，现在根据方向选择 `thumb.size().y`（垂直）或 `thumb.size().x`（水平）。这确保了轨道空间计算正确，考虑了滑块在不同方向上的实际尺寸。

PR 还包含了一个新的示例文件 `vertical_slider.rs`，展示了如何使用垂直和水平滑块。这个示例不仅演示了功能，还提供了滑块视觉反馈和值标签的完整实现模式。它使用了 `observe(slider_self_update)` 来确保滑块值变化时自动更新，这是 Bevy 响应式 UI 模式的典型用法。

从工程角度看，这个实现有几个优点：
1. **向后兼容**：水平滑块的行为完全不变
2. **自动检测**：无需新的 API 参数，方向由布局决定
3. **最小改动**：只修改了必要的计算逻辑，没有重构整个系统

潜在的限制包括对非常规宽高比的处理（例如，接近正方形的滑块可能会被错误分类），以及不支持显式指定方向。对于大多数用例，自动检测是足够的，但如果需要更精确的控制，未来可能需要添加 `SliderOrientation` 组件。

这个修复使 Bevy 的滑块控件达到了现代 UI 库的基本标准，支持双向操作。对于构建复杂 UI 界面的开发者来说，这是一个重要的可用性改进，特别是对于音量控制、亮度调节等需要垂直滑块的场景。

## 可视化关系图

```mermaid
graph TD
    A[UI Slider Widget] --> B[slider_on_pointer_down]
    A --> C[slider_on_drag]
    
    B --> D{检测方向: node.size().y > node.size().x?}
    D -->|垂直| E[使用Y轴坐标<br>反转Y方向<br>调整坐标原点]
    D -->|水平| F[使用X轴坐标<br>保持现有逻辑]
    
    C --> G{检测方向: node.size().y > node.size().x?}
    G -->|垂直| H[使用distance.y<br>调整滑块尺寸计算]
    G -->|水平| I[使用distance.x<br>保持现有逻辑]
    
    E --> J[更新SliderValue]
    F --> J
    H --> K[触发ValueChange事件]
    I --> K
```

## 主要文件更改

### `crates/bevy_ui_widgets/src/slider.rs` (+60/-17)
这是核心修改文件，实现了垂直滑块支持。

**关键修改：方向检测和条件逻辑**

```rust
// 添加方向检测
let is_vertical = node.size().y > node.size().x;

// 滑块大小根据方向选择
let thumb_size = q_children
    .iter_descendants(press.entity)
    .find_map(|child_id| {
        q_thumb.get(child_id).ok().map(|thumb| {
            if is_vertical {
                thumb.size().y  // 垂直滑块使用高度
            } else {
                thumb.size().x  // 水平滑块使用宽度
            }
        })
    })
    .unwrap_or(0.0);

// 根据方向选择轨道尺寸
let track_size = if is_vertical {
    node.size().y - thumb_size
} else {
    node.size().x - thumb_size
};

// 垂直滑块的点击位置计算
if is_vertical {
    // 对于垂直滑块：从下到上（底部为0，顶部为最大值）
    // local_pos.y 范围从 -height/2（顶部）到 +height/2（底部）
    let y_from_bottom = (node.size().y / 2.0) - local_pos.y;
    let adjusted_y = y_from_bottom - thumb_size / 2.0;
    adjusted_y * range.span() / track_size + range.start()
} else {
    // 对于水平滑块：从中心原点到左原点转换
    let x_from_left = local_pos.x + node.size().x / 2.0;
    let adjusted_x = x_from_left - thumb_size / 2.0;
    adjusted_x * range.span() / track_size + range.start()
}
```

**拖动处理的修改：**
```rust
// 移除了对SliderValue的查询，直接触发事件
if let Ok((node, range, precision, transform, drag, disabled)) = q_slider.get_mut(event.entity)

// 根据方向选择拖动距离
let drag_distance = if is_vertical { distance.y } else { distance.x };

// 根据方向选择滑块尺寸
let slider_size = if is_vertical {
    ((node.size().y - thumb_size) * node.inverse_scale_factor).max(1.0)
} else {
    ((node.size().x - thumb_size) * node.inverse_scale_factor).max(1.0)
};
```

### `examples/ui/vertical_slider.rs` (+313/-0)
新增的示例文件，展示了垂直和水平滑块的使用。

**垂直滑块定义：**
```rust
fn vertical_slider() -> impl Bundle {
    (
        Node {
            width: px(12),
            height: px(200),  // 高度 > 宽度 = 垂直滑块
            ..default()
        },
        // ... 其他组件
    )
}
```

**滑块视觉更新逻辑：**
```rust
fn update_slider_visuals(...) {
    for (slider_ent, value, range, hovered, drag_state, is_vertical) in sliders.iter() {
        // ...
        if is_vertical {
            thumb_node.bottom = percent(position);  // 垂直滑块使用bottom属性
        } else {
            thumb_node.left = percent(position);    // 水平滑块使用left属性
        }
        // ...
    }
}
```

### `Cargo.toml` (+12/-0)
添加了新示例的配置：
```toml
[[example]]
name = "vertical_slider"
path = "examples/ui/vertical_slider.rs"
doc-scrape-examples = true
required-features = ["experimental_bevy_ui_widgets"]
```

### `examples/README.md` (+1/-0)
在示例列表中添加了垂直滑块示例：
```markdown
[Vertical Slider](../examples/ui/vertical_slider.rs) | Simple example showing vertical and horizontal slider widgets with snap behavior and value labels
```

## 扩展阅读

- [Bevy UI 官方文档](https://bevyengine.org/learn/quick-start/ui/) - Bevy UI 系统的基础知识
- [响应式 UI 设计模式](https://bevy-cheatbook.github.io/programming/ui.html) - Bevy 中的响应式 UI 编程模式
- [坐标系统转换](https://en.wikipedia.org/wiki/Coordinate_system) - 不同坐标系统之间的转换原理
- [UI 控件交互设计](https://developer.apple.com/design/human-interface-guidelines/controls) - 平台无关的 UI 控件交互最佳实践