+++
title = "#22157 Revert \"Fix: Clears directional navigation map between rebuilds\""
date = "2025-12-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22157-en-20251217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22157-zh-cn-20251217" }}
labels = ["C-Bug", "A-UI", "P-Regression"]
+++

# Title
Revert "Fix: Clears directional navigation map between rebuilds"

## Basic Information
- **Title**: Revert "Fix: Clears directional navigation map between rebuilds"
- **PR Link**: https://github.com/bevyengine/bevy/pull/22157
- **Author**: alice-i-cecile
- **Status**: MERGED
- **Labels**: C-Bug, A-UI, P-Regression, S-Needs-Review
- **Created**: 2025-12-17T00:23:13Z
- **Merged**: 2025-12-17T02:49:54Z
- **Merged By**: cart

## Description Translation
这将撤销提交 `545a97d67cdb87237e0bc5f02ecd17ec7e4b5c24`，也即 #22124。

# 目标

这次的“治疗”比“疾病”本身更糟：丢失手动添加的导航边比在重绘时出错更严重。

修复 #22136。

## 解决方案

目前，我们先进行回滚，然后再寻找更好的解决方案。现在，用户可以通过手动调用 [`clear`](https://docs.rs/bevy/latest/bevy/input_focus/directional_navigation/struct.DirectionalNavigationMap.html#method.clear) 方法来获得此前的行为。

重新打开了 #21949。

## The Story of This Pull Request

这个故事始于 Bevy 引擎 UI 系统中一个关于方向性导航（directional navigation）的问题。方向性导航允许用户使用键盘方向键或控制器 D-pad 在 UI 元素间移动焦点。系统内部维护一个 `DirectionalNavigationMap`，它是一个图（graph），记录了哪些 UI 元素（节点）之间通过哪些方向可以导航。

问题的核心是系统如何更新这个导航图。当 UI 布局发生变化时（例如，元素被添加、移除或移动），系统需要重建导航关系。这里存在一个权衡：导航图应该完全由系统自动生成（auto-generated），还是允许开发者手动添加或覆盖特定的导航路径？Bevy 的设计选择了后者，提供了手动添加“边”（edges）的 API，这对于创建复杂的、非线性的导航流至关重要。

最初的问题（#21949）是，在两次 UI 重建之间，导航图没有被完全清理。这意味着如果一个 UI 实体（entity）被移除了，但之前指向它的导航边可能仍然残留在图中，导致系统尝试导航到一个不存在的实体，引发错误。为了解决这个问题，PR #22124 被引入。其解决方案简单直接：在每次自动重建之前，调用 `directional_nav_map.clear()` 来清空整个导航图。从逻辑上看，这确保了图的干净，不会包含陈旧的边。

然而，这个看似正确的修复引入了一个更严重的回归（#22136）。因为 `clear()` 方法会清除导航图中的所有边，包括那些由开发者通过 `add_edge` 等方法手动添加的边。这使得手动边在每次 UI 重建（例如窗口调整大小触发布局重算）后都会丢失，破坏了手动导航的持久性。对于依赖手动边来定义复杂导航逻辑的应用程序来说，这完全破坏了功能。根据 PR 作者的判断，“丢失手动边比在重绘时出错更严重”。

因此，当前的 PR #22157 做出了一个务实的工程决策：回滚（revert）有问题的修复（#22124）。这本质上是一种撤退，承认当前的解决方案副作用过大，不可接受。通过回滚，系统恢复到之前的状态，即自动重建不会清除手动边，但代价是可能遗留一些指向已移除实体的“僵尸边”，导致运行时错误（panic）。作者在描述中明确指出，这是一个临时措施。用户如果确实需要清除行为，可以显式调用 `DirectionalNavigationMap::clear()` 方法。

从工程角度看，这次回滚凸显了几个关键点：
1.  **API 契约的重要性**：`DirectionalNavigationMap` 提供了公开的 `add_edge` 等方法，这意味着它承诺会持久化存储这些手动添加的数据。一个内部系统（`auto_rebuild_ui_navigation_graph`）在不加区分的情况下清除所有数据，违反了这一契约。
2.  **问题复杂性的权衡**：原始问题（#21949）是关于数据一致性（清除旧边），而新引入的问题是功能完整性（保留手动边）。在两者暂时无法兼得的情况下，团队选择了优先保障功能完整性，将数据一致性问题降级为已知但可接受的错误（运行时 panic 相较于功能完全失效，可能更容易被追踪和临时规避）。
3.  **明确的未来路径**：PR 没有试图立即提出新的、更复杂的解决方案，而是明确回滚，并声明未来会寻找更好的方案。这避免了在时间压力下做出可能同样有问题的仓促设计。一个潜在的更好方案可能是让导航图能够区分“自动生成的边”和“手动设置的边”，并只在前者区域执行清理操作。

总之，这是一个关于 bug 修复如何不慎引入更严重回归的典型案例，以及开发团队如何通过果断回滚来管理风险和维护系统稳定性的标准操作。

## Visual Representation

这个 PR 主要涉及方向性导航系统内部数据的管理流程。

```mermaid
graph TD
    subgraph “UI 状态”
        A[UI 实体添加/移除/移动]
    end

    A --> B[触发 auto_rebuild_ui_navigation_graph 系统]

    subgraph “PR #22124 (已回滚)”
        B --> C{调用 map.clear}
        C --> D[清除所有边<br>包括手动添加的]
    end

    subgraph “PR #22157 (当前状态)”
        B --> E[跳过 map.clear]
        E --> F[保留手动边]
        F --> G[可能遗留指向已移除实体的边]
    end

    D --> H[结果：手动边丢失<br>功能损坏]
    G --> I[结果：可能 panic<br>但功能基础可用]
```

## Key Files Changed

仅有一个文件被修改，移除了导致问题的一行关键代码。

- `crates/bevy_input_focus/src/directional_navigation.rs` (+0/-2)

该文件包含了方向性导航的核心逻辑。被移除的两行代码位于 `auto_rebuild_ui_navigation_graph` 系统函数中，该系统负责在 UI 变化时自动重新构建导航图。

```rust
// File: crates/bevy_input_focus/src/directional_navigation.rs
// 函数：auto_rebuild_ui_navigation_graph
// Before PR #22157 (即在有问题的 #22124 之后):
fn auto_rebuild_ui_navigation_graph(
    // ... 参数省略 ...
) {
    // ... 前面的代码收集节点 ...

    // clear the old nav map between rebuilds to ensure any removed entities' edges are pruned
    directional_nav_map.clear(); // <-- 这行被移除
    auto_generate_navigation_edges(&mut directional_nav_map, &nodes, &config);
}

// After PR #22157 (回滚后):
fn auto_rebuild_ui_navigation_graph(
    // ... 参数省略 ...
) {
    // ... 前面的代码收集节点 ...

    // (clear() 调用已被移除)
    auto_generate_navigation_edges(&mut directional_nav_map, &nodes, &config);
}
```
**修改说明**：
移除了对 `directional_nav_map.clear()` 的调用。这行代码是在 PR #22124 中添加的，意图是在每次自动重建前清空导航图，以清除指向已不存在实体的边。然而，这个操作过于粗暴，同时清除了开发者手动添加的导航边，导致了功能回归。此次回滚直接移除了这行代码，使系统行为恢复到添加该行之前的状态。`auto_generate_navigation_edges` 函数现在会在现有的导航图（包含手动边）基础上添加或更新自动生成的边，但不会处理旧自动边的清理问题。

## Further Reading

1.  **原问题 Issue**: [#21949 - `DirectionalNavigation` edges are not cleared between rebuilds, leading to panics when nodes are removed](https://github.com/bevyengine/bevy/issues/21949) - 理解最初需要解决的问题。
2.  **被回滚的 PR**: [#22124 - Fix: Clears directional navigation map between rebuilds](https://github.com/bevyengine/bevy/pull/22124) - 查看引起回归的具体修复细节。
3.  **回归问题 Issue**: [#22136 - Manual navigation edges get cleared when using auto navigation](https://github.com/bevyengine/bevy/issues/22136) - 了解 `clear()` 调用引入的严重副作用。
4.  **Bevy 方向性导航文档**: [DirectionalNavigationMap API 文档](https://docs.rs/bevy/latest/bevy/input_focus/directional_navigation/struct.DirectionalNavigationMap.html) - 了解导航图的完整接口，包括 `add_edge`, `clear` 等方法。
5.  **软件工程中的“回滚”**: 这是一个常见的风险管理策略。当修复引入不可接受的新 bug 时，迅速回滚到已知的稳定状态通常比尝试即时修复新 bug 更稳妥。