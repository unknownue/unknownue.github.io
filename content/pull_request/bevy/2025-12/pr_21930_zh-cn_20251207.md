+++
title = "#21930 将存储的 `ScheduleBuildPass` 从 `BTreeMap` 替换为 `IndexMap`"
date = "2025-12-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21930-en-20251207" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21930-zh-cn-20251207" }}
+++

# Title: 将存储的 `ScheduleBuildPass` 从 `BTreeMap` 替换为 `IndexMap`

## 基本信息
- **标题**: Replace `BTreeMap` with `IndexMap` for stored `ScheduleBuildPass`es
- **PR链接**: https://github.com/bevyengine/bevy/pull/21930
- **作者**: ItsDoot
- **状态**: 已合并
- **标签**: C-Bug, A-ECS, S-Ready-For-Final-Review, D-Straightforward
- **创建时间**: 2025-11-24T08:43:19Z
- **合并时间**: 2025-12-07T23:13:05Z
- **合并者**: mockersf

## 描述翻译

### 目标
- 这是 #20115 的一部分

我们目前将 schedule build passes（调度构建通行证）存储为 `BTreeMap<TypeId, _>`；然而 `TypeId` 对我们来说没有有用的排序，并且会在不同编译之间发生变化。

### 解决方案
切换到 `IndexMap<TypeId, _>`，这样我们可以按照插入顺序进行迭代。

### 测试
添加了一个测试以确保一致的迭代顺序。

## 这个PR的故事

这个PR的核心是一个数据结构的变更，但其背后涉及到了Bevy ECS调度系统构建过程中的一个重要设计考虑。故事开始于开发者注意到在调度图（ScheduleGraph）中，构建通行证（ScheduleBuildPass）的存储方式存在一个潜在问题。

在当前的实现中，`ScheduleGraph` 使用 `BTreeMap<TypeId, Box<dyn ScheduleBuildPassObj>>` 来存储构建通行证。选择 `BTreeMap` 的通常原因是它提供了按键排序的迭代能力。然而，这里的关键在于键的类型是 `TypeId`，而 `TypeId` 的特性导致了问题。

`TypeId` 是Rust编译器为每个类型生成的唯一标识符，但它有两个重要特性：
1. 它没有语义上有用的排序 - `TypeId` 的内部表示是编译器决定的，不能保证反映类型的任何逻辑顺序
2. 它在不同的编译会话中可能变化 - 这意味着同一类型的 `TypeId` 在不同时间编译时可能不同

第一个特性意味着 `BTreeMap` 提供的排序功能在这里没有实际用处，因为我们不能依赖 `TypeId` 的排序来获得任何有意义的顺序。第二个特性则带来了更严重的问题：如果迭代顺序依赖于 `TypeId`，那么不同的编译可能导致不同的构建通行证执行顺序，这可能会影响系统的行为一致性。

开发者选择了 `IndexMap` 作为解决方案。`IndexMap` 是 `indexmap` crate 提供的数据结构，它结合了哈希表的快速查找和按插入顺序迭代的能力。对于这个用例来说，这是一个理想的选择，因为：

1. **保持插入顺序**：构建通行证按照它们被添加到调度中的顺序执行，这是用户期望的行为
2. **O(1)的查找性能**：与 `BTreeMap` 的 O(log n) 相比，哈希表提供了更好的查找性能
3. **稳定性**：迭代顺序不再依赖于可能变化的 `TypeId` 值

在实现方面，变更相当直接。主要修改包括：
- 将 `BTreeMap` 替换为 `IndexMap<TypeId, Box<dyn ScheduleBuildPassObj>, FixedHasher>`
- 更新 `remove_build_pass` 方法使用 `IndexMap::shift_remove` 而不是 `BTreeMap::remove`
- 添加必要的导入（`indexmap::IndexMap` 和 `bevy_platform::hash::FixedHasher`）

这里的一个技术细节是使用了 `FixedHasher` 作为哈希器。`FixedHasher` 是Bevy提供的一个确定性哈希器，它确保相同的输入在不同运行中产生相同的哈希值，这对于可重现的构建过程很重要。

为了验证变更的正确性，开发者添加了一个测试 `build_pass_iteration_order`。这个测试创建了三个测试通行证（Pass<0>、Pass<1>、Pass<2>）并按顺序添加到调度中，然后验证迭代顺序与插入顺序一致。测试还确认了默认的 `AutoInsertApplyDeferredPass` 始终在用户添加的通行证之前。

这个变更虽然看起来简单，但它解决了调度系统中的一个重要一致性问题。通过确保构建通行证总是按照插入顺序执行，无论编译环境如何变化，系统的行为都保持可预测和一致。这是一个很好的示例，展示了如何通过选择合适的数据结构来解决潜在的系统行为不一致问题。

## 视觉表示

```mermaid
graph TD
    A[ScheduleGraph.passes: BTreeMap<TypeId, Box<dyn ScheduleBuildPassObj>>] --> B{问题: TypeId排序无意义且不稳定}
    B --> C[解决方案: 改用IndexMap]
    C --> D[IndexMap<TypeId, Box<dyn ScheduleBuildPassObj>, FixedHasher>]
    D --> E[优势1: 按插入顺序迭代]
    D --> F[优势2: O(1)查找性能]
    D --> G[优势3: 迭代顺序稳定]
```

## 关键文件更改

### `crates/bevy_ecs/src/schedule/schedule.rs` (+64/-6)

这是唯一被修改的文件，主要更改了 `ScheduleGraph` 结构体中 `passes` 字段的类型。

**修改1：导入变更**
```rust
// 之前：
use bevy_platform::collections::{HashMap, HashSet};

// 之后：
use bevy_platform::{
    collections::{HashMap, HashSet},
    hash::FixedHasher,
};
use indexmap::IndexMap;
```

添加了 `FixedHasher` 和 `IndexMap` 的导入。

**修改2：ScheduleGraph结构体定义**
```rust
// 之前：
pub struct ScheduleGraph {
    // ...
    passes: BTreeMap<TypeId, Box<dyn ScheduleBuildPassObj>>,
}

// 之后：
pub struct ScheduleGraph {
    // ...
    passes: IndexMap<TypeId, Box<dyn ScheduleBuildPassObj>, FixedHasher>,
}
```

**修改3：remove_build_pass方法**
```rust
// 之前：
pub fn remove_build_pass<T: ScheduleBuildPass>(&mut self) {
    self.graph.passes.remove(&TypeId::of::<T>());
}

// 之后：
pub fn remove_build_pass<T: ScheduleBuildPass>(&mut self) {
    self.graph.passes.shift_remove(&TypeId::of::<T>());
}
```

从 `remove` 改为 `shift_remove` 以保持索引顺序。

**修改4：添加测试验证迭代顺序**
```rust
#[test]
fn build_pass_iteration_order() {
    #[derive(Debug)]
    struct Pass<const N: usize>;

    impl<const N: usize> ScheduleBuildPass for Pass<N> {
        // ... 实现省略
    }

    let mut schedule = Schedule::default();
    schedule.add_build_pass(Pass::<0>);
    schedule.add_build_pass(Pass::<1>);
    schedule.add_build_pass(Pass::<2>);

    let pass_order: Vec<TypeId> = schedule.graph().passes.keys().cloned().collect();

    assert_eq!(
        pass_order,
        vec![
            TypeId::of::<AutoInsertApplyDeferredPass>(),
            TypeId::of::<Pass<0>>(),
            TypeId::of::<Pass<1>>(),
            TypeId::of::<Pass<2>>()
        ]
    );
}
```

这个测试验证了通行证按照插入顺序迭代，并且默认的 `AutoInsertApplyDeferredPass` 在最前面。

## 进一步阅读

1. **IndexMap文档**: https://docs.rs/indexmap/latest/indexmap/
2. **TypeId的Rust文档**: https://doc.rust-lang.org/std/any/struct.TypeId.html
3. **Bevy的FixedHasher**: 了解Bevy如何实现确定性哈希
4. **Bevy ECS调度系统**: 了解调度构建通行证在Bevy ECS中的作用
5. **Rust中的哈希表实现**: 理解不同哈希表实现的性能特征

## 完整代码差异

```diff
diff --git a/crates/bevy_ecs/src/schedule/schedule.rs b/crates/bevy_ecs/src/schedule/schedule.rs
index ddcd844cb19cf..18a2ffa8d8771 100644
--- a/crates/bevy_ecs/src/schedule/schedule.rs
+++ b/crates/bevy_ecs/src/schedule/schedule.rs
@@ -4,19 +4,23 @@
 )]
 use alloc::{
     boxed::Box,
-    collections::{BTreeMap, BTreeSet},
+    collections::BTreeSet,
     format,
     string::{String, ToString},
     vec,
     vec::Vec,
 };
-use bevy_platform::collections::{HashMap, HashSet};
+use bevy_platform::{
+    collections::{HashMap, HashSet},
+    hash::FixedHasher,
+};
 use bevy_utils::{default, TypeIdMap};
 use core::{
     any::{Any, TypeId},
     fmt::{Debug, Write},
 };
 use fixedbitset::FixedBitSet;
+use indexmap::IndexMap;
 use log::{info, warn};
 use pass::ScheduleBuildPassObj;
 use thiserror::Error;
@@ -465,7 +469,7 @@ impl Schedule {
 
     /// Remove a custom build pass.
     pub fn remove_build_pass<T: ScheduleBuildPass>(&mut self) {
-        self.graph.passes.remove(&TypeId::of::<T>());
+        self.graph.passes.shift_remove(&TypeId::of::<T>());
     }
 
     /// Changes miscellaneous build settings.
@@ -697,7 +701,7 @@ pub struct ScheduleGraph {
     anonymous_sets: usize,
     changed: bool,
     settings: ScheduleBuildSettings,
-    passes: BTreeMap<TypeId, Box<dyn ScheduleBuildPassObj>>,
+    passes: IndexMap<TypeId, Box<dyn ScheduleBuildPassObj>, FixedHasher>,
 }
 
 impl ScheduleGraph {
@@ -1580,14 +1584,17 @@ pub struct ScheduleNotInitialized;
 
 #[cfg(test)]
 mod tests {
+    use alloc::{vec, vec::Vec};
+    use core::any::TypeId;
+
     use bevy_ecs_macros::ScheduleLabel;
 
     use crate::{
         error::{ignore, panic, DefaultErrorHandler, Result},
         prelude::{ApplyDeferred, IntoSystemSet, Res, Resource},
         schedule::{
-            tests::ResMut, IntoScheduleConfigs, Schedule, ScheduleBuildSettings,
-            ScheduleCleanupPolicy, SystemSet,
+            passes::AutoInsertApplyDeferredPass, tests::ResMut, IntoScheduleConfigs, Schedule,
+            ScheduleBuildPass, ScheduleBuildSettings, ScheduleCleanupPolicy, SystemSet,
         },
         system::Commands,
         world::World,
@@ -2565,4 +2572,55 @@ mod tests {
         let conflicts = schedule.graph().conflicting_systems();
         assert!(conflicts.is_empty());
     }
+
+    #[test]
+    fn build_pass_iteration_order() {
+        #[derive(Debug)]
+        struct Pass<const N: usize>;
+
+        impl<const N: usize> ScheduleBuildPass for Pass<N> {
+            type EdgeOptions = ();
+            fn add_dependency(
+                &mut self,
+                _from: crate::schedule::NodeId,
+                _to: crate::schedule::NodeId,
+                _options: Option<&Self::EdgeOptions>,
+            ) {
+            }
+            fn build(
+                &mut self,
+                _world: &mut World,
+                _graph: &mut super::ScheduleGraph,
+                _dependency_flattened: &mut crate::schedule::graph::Dag<crate::schedule::SystemKey>,
+            ) -> core::result::Result<(), crate::schedule::ScheduleBuildError> {
+                Ok(())
+            }
+            fn collapse_set(
+                &mut self,
+                _set: crate::schedule::SystemSetKey,
+                _systems: &bevy_platform::collections::HashSet<crate::schedule::SystemKey>,
+                _dependency_flattening: &crate::schedule::graph::DiGraph<crate::schedule::NodeId>,
+            ) -> impl Iterator<Item = (crate::schedule::NodeId, crate::schedule::NodeId)>
+            {
+                core::iter::empty()
+            }
+        }
+
+        let mut schedule = Schedule::default();
+        schedule.add_build_pass(Pass::<0>);
+        schedule.add_build_pass(Pass::<1>);
+        schedule.add_build_pass(Pass::<2>);
+
+        let pass_order: Vec<TypeId> = schedule.graph().passes.keys().cloned().collect();
+
+        assert_eq!(
+            pass_order,
+            vec![
+                TypeId::of::<AutoInsertApplyDeferredPass>(),
+                TypeId::of::<Pass<0>>(),
+                TypeId::of::<Pass<1>>(),
+                TypeId::of::<Pass<2>>()
+            ]
+        );
+    }
 }
```