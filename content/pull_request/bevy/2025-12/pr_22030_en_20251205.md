+++
title = "#22030 Inline register_type_data to cut down on binary size"
date = "2025-12-05T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22030-en-20251205" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22030-zh-cn-20251205" }}
labels = ["C-Performance", "A-Reflection"]
+++

# Title

## Basic Information
- **Title**: Inline register_type_data to cut down on binary size
- **PR Link**: https://github.com/bevyengine/bevy/pull/22030
- **Author**: cart
- **Status**: MERGED
- **Labels**: C-Performance, S-Ready-For-Final-Review, A-Reflection
- **Created**: 2025-12-04T22:54:25Z
- **Merged**: 2025-12-05T02:56:08Z
- **Merged By**: cart

## Description Translation
# Objective

My [TypeData dependencies](#22016 ) PR regressed native binary size by ~8mb.

(thank you [twitcher](https://github.com/bevyengine/twitcher/))

<img width="858" height="306" alt="image" src="https://github.com/user-attachments/assets/e6d86c67-33f6-4280-bee4-49771014b678" />

## Solution

- Inline `register_type_data`, which restores the original binary size:
  - `release breakout` before #22016: 127.3mb
  - `release breakout` after #22016: 136.4mb
  - `release breakout` after this PR: 127.4mb

## The Story of This Pull Request

This PR addresses a binary size regression introduced by a previous change (#22016). The problem was straightforward: adding TypeData dependencies functionality increased the compiled binary size by approximately 8MB, as measured by the `twitcher` tool which tracks Bevy's binary size changes.

The core issue was that the `register_type_data` function in the reflection system wasn't being inlined by the compiler. When this function is called repeatedly during type registration, each call site generates separate machine code for the function body. For a system like Bevy's reflection that registers many types at startup, this code duplication accumulates and significantly increases binary size.

The solution was simple and effective: add the `#[inline]` attribute to the `register_type_data` function. This attribute tells the Rust compiler to inline the function body at each call site. While inlining typically increases binary size by duplicating code, in this specific case it actually reduces overall size. The reason is that the function is generic over two type parameters (`T` and `V`), and without inlining, the compiler generates a separate copy of the function for each combination of type parameters used throughout the codebase. By marking it as inline, the compiler can perform better cross-call-site optimizations and potentially eliminate redundant code generation.

The implementation change is minimal but impactful:
```rust
#[inline]
pub fn register_type_data<T: TypeData + FromType<V>, V>(&mut self) {
    self.insert(T::from_type());
    T::insert_dependencies(self);
}
```

The `#[inline]` attribute is a hint to the compiler, not a command. The compiler may choose to ignore it, but in practice, for small functions like this one (just two method calls), compilers typically respect the hint. The function's two operations are straightforward: it creates a TypeData instance using `T::from_type()` and inserts it, then calls `T::insert_dependencies(self)` to handle any dependent type data registrations.

From an architectural perspective, this change doesn't affect the reflection system's behavior or API. It's purely an optimization that reduces binary bloat. The TypeData system allows types to register additional metadata, and this function is a core part of that registration process. By optimizing its code generation, we minimize the overhead of Bevy's reflection system without changing its functionality.

The performance impact is clear from the measurements: the binary size for the `release breakout` example dropped from 136.4MB back down to 127.4MB, essentially returning to the pre-regression size of 127.3MB. This 8MB reduction represents about 6.6% of the total binary size, a significant improvement for a one-line change.

This PR demonstrates an important optimization technique: sometimes adding `#[inline]` to small, frequently-called generic functions can reduce binary size by allowing the compiler to better optimize across call sites. It also shows the value of continuous binary size monitoring in projects like Bevy, where even seemingly minor changes can have noticeable impacts on distribution size.

## Visual Representation

```mermaid
graph TD
    A[Type Registration System] --> B[register_type_data function]
    B --> C[Without #[inline]]
    B --> D[With #[inline]]
    C --> E[Multiple copies generated]
    D --> F[Inlined at call sites]
    E --> G[Larger binary size: 136.4MB]
    F --> H[Smaller binary size: 127.4MB]
```

## Key Files Changed

### `crates/bevy_reflect/src/type_registry.rs` (+1/-0)

This file contains the core type registration system for Bevy's reflection. The change adds the `#[inline]` attribute to the `register_type_data` method.

**Key Modification:**
```rust
// Before:
pub fn register_type_data<T: TypeData + FromType<V>, V>(&mut self) {
    self.insert(T::from_type());
    T::insert_dependencies(self);
}

// After:
#[inline]
pub fn register_type_data<T: TypeData + FromType<V>, V>(&mut self) {
    self.insert(T::from_type());
    T::insert_dependencies(self);
}
```

The method signature and implementation remain unchanged. Only the `#[inline]` attribute is added. This method is part of the `TypeRegistration` struct's implementation and is used during type registration to insert type-specific data and its dependencies into the registry.

The change relates directly to the PR's purpose by optimizing code generation for this frequently-called method, reducing binary size without altering functionality.

## Further Reading

1. **Rust Inlining Documentation**: The Rust Reference section on inline attributes provides detailed information about when and how to use `#[inline]` effectively.
2. **Bevy Reflection System**: Understanding Bevy's reflection system helps contextualize why this function is called so frequently during type registration.
3. **Compiler Optimization Techniques**: Resources on cross-call-site optimization and code duplication trade-offs in compiled languages.
4. **Binary Size Optimization**: General techniques for reducing binary size in Rust applications, including profile-guided optimization and link-time optimization.
5. **Previous PR #22016**: The TypeData dependencies PR that introduced the binary size regression, providing context for why this optimization was necessary.