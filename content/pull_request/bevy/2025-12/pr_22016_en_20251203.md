+++
title = "#22016 TypeData dependencies"
date = "2025-12-03T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22016-en-20251203" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22016-zh-cn-20251203" }}
labels = ["C-Usability", "A-Reflection", "D-Modest"]
+++

# TypeData dependencies

## Basic Information
- **Title**: TypeData dependencies
- **PR Link**: https://github.com/bevyengine/bevy/pull/22016
- **Author**: cart
- **Status**: MERGED
- **Labels**: C-Usability, A-Reflection, X-Uncontroversial, D-Modest, S-Needs-Review
- **Created**: 2025-12-03T01:11:23Z
- **Merged**: 2025-12-03T20:41:05Z
- **Merged By**: cart

## Description Translation
# Objective

The proposed ["Resources as entities"](https://github.com/bevyengine/bevy/pull/20934 ) PR makes Resource implement Component. This creates a situation where we need to do:

```rust
#[derive(Resource, Reflect)]
#[reflect(Resource, Component)]
struct Thing;
```

I'm of the mind that we should add the ability for TypeData to have "dependencies". Ex `reflect(Resource)` implies `reflect(Component)`. For "subtrait" types, I think supporting this is logical / users would appreciate it.

## Solution

1. Add a new `FromType<T>::insert_dependencies` function with a default impl (which makes this a non-breaking change). This does kind of overload the `FromType` trait (ex: a name like `GetTypeData` might be better with this new context), but this is a pretty niche trait / piece of functionality, and I like the idea of not breaking people.
2. Add a new `TypeRegistration::register_type_data<T, V>` function, which initializes the TypeData `T` for a given type `V` , inserts that type data, and also inserts any dependent type data using `insert_dependencies`.
3. Adjust the `Reflect` macro to use `register_type_data` instead of `insert(FromType::<Self>::from_type())`

This makes it possible to do the following:

```rust
impl<R: Resource + FromReflect + TypePath> FromType<R> for ReflectResource {
    fn from_type() -> Self {
        ReflectResource
    }

    fn insert_dependencies(type_registration: &mut TypeRegistration) {
        type_registration.register_type_data::<ReflectComponent, R>();
    }
}
```

Which then allows dropping `reflect(Component)`:

```rust
#[derive(Resource, Reflect)]
#[reflect(Resource)]
struct Thing;
```

## Testing

I added a unit test :stuck_out_tongue_winking_eye: 

## The Story of This Pull Request

This pull request addresses a usability issue in Bevy's reflection system that was anticipated from an upcoming change in another PR (#20934). The core problem relates to how derived traits are reflected when one trait inherits from another.

In the planned "Resources as entities" architecture, `Resource` will implement `Component`. This creates a scenario where types that implement both traits would require duplicate reflection annotations:

```rust
#[derive(Resource, Reflect)]
#[reflect(Resource, Component)]  // Both must be specified
struct Thing;
```

The developer identified this as a poor user experience. When a type implements a trait that inherits from another trait, users reasonably expect that reflecting the subtrait should automatically imply reflection of the supertrait. This is particularly relevant for the relationship where `Resource: Component`.

The solution introduces the concept of **TypeData dependencies**. The implementation follows a conservative approach that maintains backward compatibility while solving the problem. The developer made three key changes:

First, they extended the `FromType<T>` trait with a new optional method `insert_dependencies`. This method has a default empty implementation, making the change non-breaking. The method allows TypeData implementations to specify what other TypeData should be automatically registered when they are registered.

Second, they added a new `register_type_data` method to `TypeRegistration`. This method consolidates the process of registering TypeData and its dependencies into a single call. It first inserts the primary TypeData, then calls `insert_dependencies` to handle any dependencies.

Third, they updated the `Reflect` derive macro to use this new `register_type_data` method instead of directly inserting TypeData. This ensures that all TypeData registration goes through the dependency-aware path.

The technical implementation is straightforward but effective. Here's the key addition to the `FromType` trait:

```rust
pub trait FromType<T> {
    fn from_type() -> Self;
    
    /// Inserts [`TypeData`] dependencies of this [`TypeData`].
    /// This is especially useful for trait [`TypeData`] that has a supertrait (ex: `A: B`).
    /// When the [`TypeData`] for `A` is inserted, the `B` [`TypeData`] will also be inserted.
    fn insert_dependencies(_type_registration: &mut TypeRegistration) {}
}
```

The new `register_type_data` method provides a clean API:

```rust
pub fn register_type_data<T: TypeData + FromType<V>, V>(&mut self) {
    self.insert(T::from_type());
    T::insert_dependencies(self);
}
```

The practical impact is significant for user experience. After this change, the `ReflectResource` implementation can be updated to automatically register `ReflectComponent`:

```rust
impl<R: Resource + FromReflect + TypePath> FromType<R> for ReflectResource {
    fn from_type() -> Self {
        ReflectResource
    }

    fn insert_dependencies(type_registration: &mut TypeRegistration) {
        type_registration.register_type_data::<ReflectComponent, R>();
    }
}
```

This allows users to write cleaner code:

```rust
#[derive(Resource, Reflect)]
#[reflect(Resource)]  // Component is automatically implied
struct Thing;
```

The developer included a comprehensive unit test that demonstrates the functionality works as expected. The test creates two dummy TypeData structs (`ReflectA` and `ReflectB`), where `ReflectA` depends on `ReflectB`. When a type is registered with `ReflectA`, the test verifies that both `ReflectA` and `ReflectB` are present in the registration.

The approach is pragmatic. The developer acknowledges that the `FromType` trait name might not be ideal for its expanded role (suggesting `GetTypeData` as a better alternative), but chose to avoid breaking changes. This demonstrates good judgment in balancing API design purity against practical considerations.

## Visual Representation

```mermaid
graph TD
    A[Reflect Macro] --> B[register_type_data]
    B --> C[TypeData::from_type]
    B --> D[TypeData::insert_dependencies]
    D --> E[register_type_data for dependencies]
    E --> F[Recursive dependency resolution]
    
    G[Before: #[reflect(Resource, Component)]]
    H[After: #[reflect(Resource)]]
    
    G -->|Manual| I[Both registered separately]
    H -->|Automatic| J[Resource triggers Component registration]
```

## Key Files Changed

### `crates/bevy_reflect/src/type_registry.rs` (+11/-0)
**Purpose**: Adds the core functionality for TypeData dependencies.

**Key Changes**:
1. Added `register_type_data` method to `TypeRegistration` that handles both TypeData insertion and dependency resolution
2. Added default `insert_dependencies` method to `FromType` trait

**Code Snippet**:
```rust
/// Inserts the [`TypeData`] instance of `T` created for `V`, and inserts any
/// [`TypeData`] dependencies for that combination of `T` and `V`.
pub fn register_type_data<T: TypeData + FromType<V>, V>(&mut self) {
    self.insert(T::from_type());
    T::insert_dependencies(self);
}

/// Inserts [`TypeData`] dependencies of this [`TypeData`].
/// This is especially useful for trait [`TypeData`] that has a supertrait (ex: `A: B`).
/// When the [`TypeData`] for `A` is inserted, the `B` [`TypeData`] will also be inserted.
fn insert_dependencies(_type_registration: &mut TypeRegistration) {}
```

### `crates/bevy_reflect/derive/src/registration.rs` (+1/-1)
**Purpose**: Updates the `Reflect` derive macro to use the new dependency-aware registration.

**Key Changes**: Changed the macro-generated code from direct `insert` calls to `register_type_data` calls.

**Code Snippet**:
```rust
// Before:
#(registration.insert::<#registration_data>(#bevy_reflect_path::FromType::<Self>::from_type());)*

// After:
#(registration.register_type_data::<#registration_data, Self>();)*
```

### `crates/bevy_reflect/src/lib.rs` (+30/-0)
**Purpose**: Adds a comprehensive unit test for the new TypeData dependency feature.

**Key Changes**: Added `type_data_dependency` test that verifies dependencies are automatically registered.

**Code Snippet**:
```rust
#[test]
fn type_data_dependency() {
    #[derive(Reflect)]
    #[reflect(A)]
    struct X;

    #[derive(Clone)]
    struct ReflectA;

    impl<T> FromType<T> for ReflectA {
        fn from_type() -> Self {
            ReflectA
        }

        fn insert_dependencies(type_registration: &mut TypeRegistration) {
            type_registration.insert(ReflectB);
        }
    }

    #[derive(Clone)]
    struct ReflectB;

    let mut registry = TypeRegistry::new();
    registry.register::<X>();

    let registration = registry.get(TypeId::of::<X>()).unwrap();
    assert!(registration.data::<ReflectA>().is_some());
    assert!(registration.data::<ReflectB>().is_some());
}
```

## Further Reading

1. [Bevy Reflection System Documentation](https://docs.rs/bevy_reflect/latest/bevy_reflect/) - Official documentation for Bevy's reflection system
2. [Type Registration in Bevy](https://bevy-cheatbook.github.io/programming/reflection.html) - Practical guide to using reflection in Bevy
3. [Rust Traits and Inheritance](https://doc.rust-lang.org/book/ch10-02-traits.html) - Official Rust documentation on traits
4. [PR #20934: Resources as entities](https://github.com/bevyengine/bevy/pull/20934) - The related PR that motivated this change