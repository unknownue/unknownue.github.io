+++
title = "#22146 Suppress Warnings for unused code in bevy_gizmos_render"
date = "2025-12-16T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22146-en-20251216" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22146-zh-cn-20251216" }}
labels = ["D-Trivial", "C-Code-Quality", "A-Gizmos"]
+++

# Title

## Basic Information
- **Title**: Suppress Warnings for unused code in bevy_gizmos_render
- **PR Link**: https://github.com/bevyengine/bevy/pull/22146
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: D-Trivial, C-Code-Quality, S-Ready-For-Final-Review, A-Gizmos
- **Created**: 2025-12-16T02:26:33Z
- **Merged**: 2025-12-16T05:17:50Z
- **Merged By**: alice-i-cecile

## Description Translation
**目标**
- 修复 #22137

**解决方案**
添加 `expect` 属性来抑制运行 `cargo build -p bevy_gizmos_render` 后产生的警告。所有警告都源于当 `bevy_pbr` 或 `bevy_sprite_render` 特性均未启用时未被使用的字段/结构体/函数（它们仅在 `pipeline_2d` 或 `pipeline_3d` 中的插件被添加时使用），因此 `expect` 属性被限定在该特定条件下。

**测试**
- 你测试过这些改动吗？如果是，如何测试的？
运行 `cargo build -p bevy_gizmos_render` 不再产生警告。
运行 `cargo clippy` 不再产生警告。

## The Story of This Pull Request

在 Rust 项目中，一个干净的编译输出（零警告）是维护代码质量和开发者体验的重要标准。PR #22146 解决了一个具体问题：在构建 `bevy_gizmos_render` crate 时，当某些可选特性未被启用时，编译器会产生关于未使用代码（dead code 或 unused variables）的警告。这些警告本身是良性的，但会干扰开发，降低 CI 检查的严谨性，并可能掩盖其他真正的问题。

问题的根源在于条件编译。`bevy_gizmos_render` crate 包含用于渲染 2D 和 3D 辅助线（gizmos）的代码。这部分代码的实际使用依赖于更高级别的渲染后端，具体来说，就是 `bevy_pbr`（用于 3D 基于物理的渲染）和 `bevy_sprite_render`（用于 2D 精灵渲染）这两个特性。当用户通过 Cargo 特性选择不包含这两个渲染后端时（例如 `cargo build -p bevy_gizmos_render`），crate 中专门为这些后端准备的数据结构（如 `GpuLineGizmo`）、渲染命令（如 `DrawLineGizmo`）和函数就会变得未被引用，从而触发 Rust 编译器的 `dead_code` 和 `unused_variables` 提示。

开发者的解决思路非常直接：使用 `#[expect]` 属性。`#[expect]` 是 Rust 中一个相对较新的 lint 控制属性，它比传统的 `#[allow(...)]` 更具表达性。`#[allow(...)]` 会无条件地抑制指定 lint 的警告，而 `#[expect(...)]` 则表达了一种*预期*：开发者预期此处会产生一个 lint 警告。如果该警告确实出现了，它会被抑制；如果未来代码变更导致该警告不再出现（例如，代码被使用了），`#[expect]` 属性本身会产生一个警告，提示开发者这个“预期”已经落空，应该移除该属性。这避免了 `#[allow(...)]` 可能导致的“已允许但已过时”的警告被永久忽略。

在这个 PR 中，开发者将 `#[expect]` 与条件编译属性 `#[cfg_attr(...)]` 结合使用，实现了精准的警告抑制。具体做法是：仅当 `bevy_pbr` 和 `bevy_sprite_render` 特性都未启用时（`not(any(feature = "..."))`），才为相关项添加 `expect(dead_code)` 或 `expect(unused_variables)` 属性。这样，在“全特性”构建下（即至少启用了一个渲染后端），这些代码被正常使用，不会触发警告，`expect` 属性也不生效；在“最小化”构建下，代码未被使用，触发警告，但该警告被预期的 `expect` 属性静默处理，保持了构建输出的清洁。

例如，对于 `GpuLineGizmo` 结构体，修改后的代码如下：
```rust
#[cfg_attr(
    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
    expect(
        dead_code,
        reason = "fields are unused when bevy_pbr and bevy_sprite_render are both disabled."
    )
)]
#[derive(Debug, Clone)]
struct GpuLineGizmo {
    list_position_buffer: Buffer,
    // ... 其他字段
}
```
这个修改清晰地传达了意图：这个结构体在特定条件下未被使用，我们知道这一点，并且这是符合预期的。

这种方法的优势在于它的精确性和自文档性。它没有简单地全局禁用某些 lint，而是将警告抑制的范围严格限制在由特性标志定义的、逻辑上合理的场景内。同时，`reason` 参数提供了清晰的解释，说明了为什么这段代码可能未被使用，这对未来的代码阅读者和维护者非常有帮助。

从工程实践角度看，这个 PR 展示了在条件编译场景下管理编译器警告的良好模式。它维护了“零警告”的严格标准，同时避免了因使用 `#[allow(...)]` 而可能隐藏的真正问题。虽然改动本身是琐碎的（主要添加属性），但它提升了项目的整体代码卫生状况和开发者体验。在 CI/CD 流程中，一个没有无关警告的构建日志更容易让人专注于真正的错误或新引入的警告。

## Visual Representation

```mermaid
graph TD
    subgraph "Crate: bevy_gizmos_render"
        A[Gizmo Rendering Code<br>e.g., GpuLineGizmo, DrawLineGizmo]
    end

    subgraph "Optional Features (Conditional Compilation)"
        B[Feature: bevy_pbr]
        C[Feature: bevy_sprite_render]
    end

    subgraph "Rust Compiler & Lints"
        D[dead_code/unused_variables lint]
    end

    E[#[expect] Attribute]

    A -- Used by --> B
    A -- Used by --> C
    A -- Not used if both B and C are off --> D
    E -- Conditionally applied via #[cfg_attr] to suppress --> D
    B & C -- Control activation of --> E
```

## Key Files Changed

### 1. `crates/bevy_gizmos_render/src/lib.rs`
**修改内容与原因**：此文件包含了 gizmo 渲染的核心逻辑。修改为多个仅在特定特性启用时才被使用的结构体、函数和变量添加了 `#[cfg_attr(..., expect(...))]` 属性，以抑制在禁用相关特性时的未使用代码警告。

**关键代码示例**：
```rust
// 修改1：在 extract_gizmo_data 函数中，处理可能未使用的 `handle` 变量
#[cfg_attr(
    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
    expect(
        unused_variables,
        reason = "`handle` is unused when bevy_pbr and bevy_sprite_render are both disabled."
    )
)]
let Some(handle) = handle
else {
    continue;
};

// 修改2：为 GpuLineGizmo 结构体添加属性
#[cfg_attr(
    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
    expect(
        dead_code,
        reason = "fields are unused when bevy_pbr and bevy_sprite_render are both disabled."
    )
)]
#[derive(Debug, Clone)]
struct GpuLineGizmo { ... }

// 类似地，为多个 RenderCommand 实现结构体（如 SetLineGizmoBindGroup, DrawLineGizmo）和函数（line_gizmo_vertex_buffer_layouts）添加了相同的属性。
```
**与PR目标的关联**：这些修改直接解决了在构建时由条件编译产生的 `dead_code` 和 `unused_variables` 警告，是本次修复的主要部分。

### 2. `crates/bevy_gizmos_render/src/retained.rs`
**修改内容与原因**：此文件处理保留模式（retained mode）的 gizmo 数据提取。修改为一个在特定条件下未使用的 `render_layers` 变量添加了 `#[expect(unused_variables)]` 属性。

**关键代码示例**：
```rust
pub(crate) fn extract_linegizmos(...) {
    let mut values = Vec::with_capacity(*previous_len);
    #[cfg_attr(
        not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
        expect(
            unused_variables,
            reason = "`render_layers` is unused when bevy_pbr and bevy_sprite_render are both disabled."
        )
    )]
    for (entity, gizmo, transform, render_layers) in &query {
        // ... 循环体
    }
}
```
**与PR目标的关联**：这个修改同样是为了消除特定构建配置下的编译器警告，确保整个 `bevy_gizmos_render` crate 的构建输出是干净的。

## Further Reading
1.  **Rust `#[expect]` 属性**: [The Rust Reference - Lint Attributes](https://doc.rust-lang.org/reference/attributes/diagnostics.html#lint-attributes) 中关于 `expect` 的部分，解释了其与 `allow` 的区别。
2.  **条件编译 (`#[cfg]` 和 `#[cfg_attr]`)**: [The Rust Reference - Conditional Compilation](https://doc.rust-lang.org/reference/conditional-compilation.html) 详细说明了如何在 Rust 中基于特性、平台等条件包含或排除代码。
3.  **Bevy 引擎的渲染架构**: 了解 Bevy 的 ECS（实体-组件-系统）模式和渲染阶段如何工作，有助于理解为什么这些 gizmo 渲染结构与 `bevy_pbr` 和 `bevy_sprite_render` 特性深度耦合。
4.  **Rust Clippy Lints**: [Rust Clippy Lints](https://rust-lang.github.io/rust-clippy/master/) 是 Rust 的代码检查工具，`dead_code` 和 `unused_variables` 是其中的标准 lint。了解这些 lint 有助于编写更清晰的代码。

# Full Code Diff
*(Provided in the user's request, included here for completeness.)*