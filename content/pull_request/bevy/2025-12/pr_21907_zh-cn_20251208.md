+++
title = "#21907 Solari: Improve specular GI"
date = "2025-12-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21907-en-20251208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21907-zh-cn-20251208" }}
+++

# Solari: Improve specular GI

## 基本信息
- **标题**: Solari: Improve specular GI
- **PR链接**: https://github.com/bevyengine/bevy/pull/21907
- **作者**: JMS55
- **状态**: 已合并
- **标签**: A-Rendering, S-Ready-For-Final-Review, D-Complex, C-Refinement
- **创建时间**: 2025-11-21T19:47:20Z
- **合并时间**: 2025-12-07T23:57:22Z
- **合并者**: james7132

## 描述翻译
这个PR改进了镜面反射全局光照（specular GI）的实现。核心思路是：只在粗糙（rough）表面和非首次反弹（non-first-bounce）表面回退使用世界缓存（world cache），而在其他情况下采样直接光照（direct lighting）。

主分支当前效果：
<img width="3206" height="1875" alt="image" src="https://github.com/user-attachments/assets/1247d357-d190-4fdc-a7b3-396d42478b99" />

本PR的效果：
<img width="3206" height="1875" alt="image" src="https://github.com/user-attachments/assets/927bca68-4cac-4aef-87d5-dce079eb54af" />

路径追踪（pathtraced）参考效果：
<img width="3206" height="1875" alt="image" src="https://github.com/user-attachments/assets/d6668bde-521c-47c7-b4d5-0ba6c8db5cc8" />

修复了 https://github.com/bevyengine/bevy/issues/21967。

## 本次PR的技术故事

这个PR主要解决Bevy渲染引擎中Solari模块的specular GI（镜面反射全局光照）质量问题。在之前的实现中，specular GI在处理粗糙表面时存在过度依赖世界缓存（world cache）的问题，导致镜面反射效果不够准确，特别是在处理直接光照时缺乏正确的多重重要性采样（Multiple Importance Sampling, MIS）权重计算。

问题的核心在于原先的算法策略：对于粗糙表面，系统会直接使用ReSTIR GI的蓄水池（reservoir）结果，这虽然性能较好，但牺牲了光照精度。而在路径追踪过程中，对于非首次反弹的粗糙表面，也会过早终止路径并回退到世界缓存查询，这忽略了直接光照采样的可能性，导致能量损失和视觉上的不准确。

开发者JMS55采取的解决方案是基于材质的粗糙度（roughness）来动态选择光照计算策略。具体来说：

1. 对于粗糙度高于`DIFFUSE_GI_REUSE_ROUGHNESS_THRESHOLD`（0.4）的表面，继续复用ReSTIR GI蓄水池的数据，因为这近似于漫反射行为
2. 对于粗糙度介于0.4和镜面阈值之间的表面，在非首次反弹时使用世界缓存，但同时增加了直接光照采样
3. 对于接近镜面的表面（粗糙度≤0.001且金属度>0.9999），按照完美镜面反射处理

技术实现上的关键改进包括：

- 在`trace_glossy_path`函数中重构了路径追踪逻辑，将自发光（emissive）贡献、直接光照采样（NEE）和世界缓存查询按正确的顺序组织
- 引入了两个MIS权重计算函数：`emissive_mis_weight`用于自发光表面的权重计算，`nee_mis_weight`用于直接光照的权重计算
- 在采样模块中，为`LightContribution`结构体添加了`brdf_rays_can_hit`字段，用于指示BRDF采样光线是否能击中光源，这是正确计算MIS权重的关键信息
- 对于接近完美的镜面反射（粗糙度≤0.01），优化了GGX VNDF采样函数，直接返回反射方向而不是进行复杂的采样计算

这些改变的工程考虑是平衡性能和质量。世界缓存查询是相对廉价的操作，但直接光照采样能提供更准确的光照效果。通过粗糙度阈值来区分使用场景，在保持实时性能的同时显著提升了视觉质量。

从代码架构角度看，这个PR保持了Solari模块的模块化设计。光照计算的核心逻辑仍然集中在`specular_gi.wgsl`中，但通过更精细的条件分支和权重计算，使得算法能更好地处理不同材质属性的表面。

性能方面，增加的直接光照采样会带来一定的计算开销，但由于只针对特定粗糙度范围的表面，且通过MIS权重减少了噪声，整体上在质量和性能间取得了良好的平衡。路径追踪器（pathtracer）中的相应修改也确保了离线渲染和实时渲染之间的一致性。

## 视觉表示

```mermaid
graph TD
    A[specular_gi.wgsl<br/>主渲染入口] --> B{粗糙度判断}
    B -->|粗糙度>0.4| C[复用ReSTIR GI蓄水池]
    B -->|粗糙度≤0.4| D[trace_glossy_path<br/>路径追踪]
    
    D --> E{是否首次反弹}
    E -->|否| F[计算自发光贡献<br/>使用MIS权重]
    E -->|是| G[跳过自发光<br/>(由ReSTIR DI处理)]
    
    D --> H{粗糙度判断}
    H -->|粗糙度>0.4| I[使用世界缓存<br/>终止路径]
    H -->|粗糙度≤0.4| J[采样直接光照<br/>NEE with MIS]
    
    J --> K[GGX VNDF采样<br/>下一反弹方向]
    K --> D
    
    F --> L[sampling.wgsl<br/>辅助函数]
    J --> L
    I --> M[world_cache查询]
    
    N[pathtracer.wgsl<br/>路径追踪器] --> O[使用random_emissive_light_pdf]
    N --> P[改进直接光照MIS权重]
```

## 关键文件变更

### `crates/bevy_solari/src/realtime/specular_gi.wgsl` (+56/-13)

这是本次PR的核心文件，包含了specular GI计算的主要逻辑重构。

**主要变更**：
1. 引入了两个粗糙度阈值常量，用于区分不同渲染策略
2. 完全重写了`trace_glossy_path`函数，重新组织路径追踪流程
3. 新增了`emissive_mis_weight`和`nee_mis_weight`函数用于MIS权重计算

**关键代码片段**：
```wgsl
// 新增的阈值常量
const DIFFUSE_GI_REUSE_ROUGHNESS_THRESHOLD: f32 = 0.4;
const WORLD_CACHE_TERMINATION_ROUGHNESS_THRESHOLD: f32 = 0.4;

// 重构后的trace_glossy_path函数核心逻辑
fn trace_glossy_path(initial_ray_origin: vec3<f32>, initial_wi: vec3<f32>, rng: ptr<function, u32>) -> vec3<f32> {
    // ... 初始化代码
    
    for (var i = 0u; i < 3u; i += 1u) {
        // ... 光线追踪代码
        
        // 自发光贡献（跳过首次反弹）
        if i != 0u {
            radiance += throughput * emissive_mis_weight(p_bounce, ray_hit, surface_perfectly_specular) * ray_hit.material.emissive;
        }
        
        // 完美镜面表面判断
        surface_perfectly_specular = ray_hit.material.roughness <= 0.001 && ray_hit.material.metallic > 0.9999;
        
        if ray_hit.material.roughness > WORLD_CACHE_TERMINATION_ROUGHNESS_THRESHOLD && i != 0u {
            // 粗糙表面：使用世界缓存并终止路径
            let diffuse_brdf = ray_hit.material.base_color / PI;
            radiance += throughput * diffuse_brdf * query_world_cache(...);
            break;
        } else if !surface_perfectly_specular {
            // 非完美镜面：采样直接光照（NEE）
            let direct_lighting = sample_random_light(...);
            let direct_lighting_brdf = evaluate_brdf(...);
            let mis_weight = nee_mis_weight(...);
            radiance += throughput * mis_weight * direct_lighting.radiance * direct_lighting.inverse_pdf * direct_lighting_brdf;
        }
        
        // ... 继续下一反弹的采样
    }
    
    return radiance;
}
```

### `crates/bevy_solari/src/pathtracer/pathtracer.wgsl` (+9/-4)

路径追踪器中的相应修改，确保离线渲染和实时渲染的一致性。

**主要变更**：
1. 将`random_light_pdf`替换为`random_emissive_light_pdf`
2. 在直接光照采样中添加了对`brdf_rays_can_hit`的检查

**关键代码片段**：
```wgsl
// 自发光PDF计算函数的更新
let p_light = random_emissive_light_pdf(ray_hit);

// 直接光照MIS权重的改进
mis_weight = 1.0;
if direct_lighting.brdf_rays_can_hit {
    let pdf_of_bounce = brdf_pdf(wo, direct_lighting.wi, ray_hit);
    mis_weight = power_heuristic(1.0 / direct_lighting.inverse_pdf, pdf_of_bounce);
}
```

### `crates/bevy_solari/src/scene/sampling.wgsl` (+8/-4)

采样辅助函数的改进。

**主要变更**：
1. 在`sample_ggx_vndf`函数中添加了对极低粗糙度的优化处理
2. `LightContribution`结构体新增`brdf_rays_can_hit`字段
3. 将`random_light_pdf`重命名为`random_emissive_light_pdf`并修正PDF计算

**关键代码片段**：
```wgsl
// GGX VNDF采样函数的优化
fn sample_ggx_vndf(wi_tangent: vec3<f32>, roughness: f32, rng: ptr<function, u32>) -> vec3<f32> {
    if roughness <= 0.01 {
        return vec3(-wi_tangent.xy, wi_tangent.z);
    }
    // ... 原有采样逻辑
}

// 结构体字段新增
struct LightContribution {
    radiance: vec3<f32>,
    inverse_pdf: f32,
    wi: vec3<f32>,
    brdf_rays_can_hit: bool,  // 新增字段
}

// 自发光PDF计算函数的修正
fn random_emissive_light_pdf(hit: ResolvedRayHitFull) -> f32 {
    let light_count = arrayLength(&light_sources);
    return 1.0 / (f32(light_count) * f32(hit.triangle_count) * hit.triangle_area);
}
```

## 扩展阅读

1. **多重重要性采样（Multiple Importance Sampling, MIS）**：
   - Veach, E., & Guibas, L. J. (1995). "Optimally combining sampling techniques for Monte Carlo rendering." SIGGRAPH.
   - 这是理解本次PR中权重计算的理论基础

2. **GGX BRDF和VNDF采样**：
   - Heitz, E. (2018). "Sampling the GGX Distribution of Visible Normals." Journal of Computer Graphics Techniques.
   - 解释了`sample_ggx_vndf`和`ggx_vndf_pdf`函数的数学原理

3. **ReSTIR GI算法**：
   - Ouyang, Y., et al. (2021). "ReSTIR GI: Path Resampling for Real-Time Path Tracing." SIGGRAPH.
   - Solari中使用的实时全局光照算法的核心论文

4. **实时渲染中的镜面反射全局光照**：
   - McGuire, M. (2017). "Scaling the Graphics Pipeline." SIGGRAPH Courses.
   - 提供了实时渲染中处理复杂光照问题的实用技术

5. **Bevy引擎渲染架构**：
   - Bevy官方文档中的渲染部分，特别是关于Solari模块的设计理念和实现细节

# Full Code Diff
完整代码差异见原始PR链接：https://github.com/bevyengine/bevy/pull/21907