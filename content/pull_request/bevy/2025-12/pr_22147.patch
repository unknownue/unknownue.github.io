diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
index 4205f18212515..6f09e087967e3 100644
--- a/crates/bevy_asset/src/lib.rs
+++ b/crates/bevy_asset/src/lib.rs
@@ -1979,391 +1979,6 @@ mod tests {
         });
     }
 
-    #[test]
-    fn error_on_immediate_load_of_self_path() {
-        let (mut app, dir, _source_events) = create_app_with_source_event_sender();
-        let asset_server = app.world().resource::<AssetServer>().clone();
-
-        // Extension "rsp" for Recursive Self Path (RSP).
-        dir.insert_asset_text(Path::new("abc.rsp"), "");
-
-        #[derive(TypePath)]
-        struct ImmediateSelfLoader;
-
-        impl AssetLoader for ImmediateSelfLoader {
-            type Asset = TestAsset;
-            type Error = crate::loader::LoadDirectError;
-            type Settings = ();
-
-            async fn load(
-                &self,
-                _: &mut dyn Reader,
-                _: &Self::Settings,
-                load_context: &mut LoadContext<'_>,
-            ) -> Result<Self::Asset, Self::Error> {
-                let asset_path = load_context.path().clone();
-                let loaded_asset = load_context
-                    .loader()
-                    .immediate()
-                    .load::<TestAsset>(asset_path)
-                    .await?;
-                load_context.add_loaded_labeled_asset("myself".to_string(), loaded_asset);
-                Ok(TestAsset)
-            }
-
-            fn extensions(&self) -> &[&str] {
-                &["rsp"]
-            }
-        }
-
-        app.init_asset::<TestAsset>()
-            .register_asset_loader(ImmediateSelfLoader);
-
-        let handle: Handle<TestAsset> = asset_server.load("abc.rsp");
-
-        run_app_until(&mut app, |_world| match asset_server.load_state(&handle) {
-            LoadState::Loading => None,
-            LoadState::Failed(err) => {
-                assert!(
-                    format!("{:?}", &err).contains("RequestedSelfPath"),
-                    "Error did not contain RequestedSelfPath: {:?}",
-                    &err
-                );
-                Some(())
-            }
-            state => panic!("Unexpected asset state: {state:?}"),
-        });
-    }
-
-    #[test]
-    fn error_on_unknown_type_immediate_load_of_self_path() {
-        let (mut app, dir, _source_events) = create_app_with_source_event_sender();
-        let asset_server = app.world().resource::<AssetServer>().clone();
-
-        dir.insert_asset_text(Path::new("abc.rsp"), "");
-
-        #[derive(TypePath)]
-        struct ImmediateSelfLoader;
-
-        impl AssetLoader for ImmediateSelfLoader {
-            type Asset = TestAsset;
-            type Error = crate::loader::LoadDirectError;
-            type Settings = ();
-
-            async fn load(
-                &self,
-                _: &mut dyn Reader,
-                _: &Self::Settings,
-                load_context: &mut LoadContext<'_>,
-            ) -> Result<Self::Asset, Self::Error> {
-                let asset_path = load_context.path().clone();
-                let loaded_asset = load_context
-                    .loader()
-                    .immediate()
-                    .with_unknown_type()
-                    .load(asset_path)
-                    .await?;
-                let Ok(loaded_asset) = loaded_asset.downcast::<TestAsset>() else {
-                    panic!("Could not downcast to `TestAsset`")
-                };
-                load_context.add_loaded_labeled_asset("myself".to_string(), loaded_asset);
-                Ok(TestAsset)
-            }
-
-            fn extensions(&self) -> &[&str] {
-                &["rsp"]
-            }
-        }
-
-        app.init_asset::<TestAsset>()
-            .register_asset_loader(ImmediateSelfLoader);
-
-        let handle: Handle<TestAsset> = asset_server.load("abc.rsp");
-
-        run_app_until(&mut app, |_world| match asset_server.load_state(&handle) {
-            LoadState::Loading => None,
-            LoadState::Failed(err) => {
-                assert!(
-                    format!("{:?}", &err).contains("RequestedSelfPath"),
-                    "Error did not contain RequestedSelfPath: {:?}",
-                    &err
-                );
-                Some(())
-            }
-            state => panic!("Unexpected asset state: {state:?}"),
-        });
-    }
-
-    /// This is not a statement of intent but of behavior: One may load their
-    /// own path deferred without error. It has the correct handle to itself.
-    /// And it can reload.
-    #[test]
-    fn no_error_on_deferred_load_of_self_path() {
-        let (mut app, dir, source_events) = create_app_with_source_event_sender();
-        let asset_server = app.world().resource::<AssetServer>().clone();
-
-        dir.insert_asset_text(Path::new("abc.rsp"), "");
-
-        #[derive(Asset, TypePath)]
-        pub struct TestAsset(Handle<TestAsset>);
-
-        #[derive(TypePath)]
-        struct DeferredSelfLoader;
-
-        impl AssetLoader for DeferredSelfLoader {
-            type Asset = TestAsset;
-            type Error = crate::loader::LoadDirectError;
-            type Settings = ();
-
-            async fn load(
-                &self,
-                _: &mut dyn Reader,
-                _: &Self::Settings,
-                load_context: &mut LoadContext<'_>,
-            ) -> Result<Self::Asset, Self::Error> {
-                let asset_path = load_context.path().clone();
-                let loaded_asset = load_context.load::<TestAsset>(asset_path);
-                Ok(TestAsset(loaded_asset))
-            }
-
-            fn extensions(&self) -> &[&str] {
-                &["rsp"]
-            }
-        }
-
-        app.init_asset::<TestAsset>()
-            .register_asset_loader(DeferredSelfLoader);
-
-        let handle: Handle<TestAsset> = asset_server.load("abc.rsp");
-
-        run_app_until(&mut app, |world| match asset_server.load_state(&handle) {
-            LoadState::Loading => None,
-            LoadState::Loaded => {
-                let test_assets = world.resource::<Assets<TestAsset>>();
-                let asset = test_assets.get(&handle).unwrap();
-                assert_eq!(handle, asset.0);
-                Some(())
-            }
-            state => panic!("Unexpected asset state: {state:?}"),
-        });
-
-        run_app_until(&mut app, |world| {
-            let messages = collect_asset_events(world);
-            if messages.is_empty() {
-                return None;
-            }
-            assert_eq!(
-                messages,
-                [
-                    AssetEvent::LoadedWithDependencies { id: handle.id() },
-                    AssetEvent::Added { id: handle.id() }
-                ]
-            );
-            Some(())
-        });
-
-        // Sending an asset event should result in the asset being reloaded - resulting in a
-        // "Modified" message.
-        source_events
-            .send_blocking(AssetSourceEvent::ModifiedAsset(PathBuf::from("abc.rsp")))
-            .unwrap();
-
-        run_app_until(&mut app, |world| {
-            let messages = collect_asset_events(world);
-            if messages.is_empty() {
-                return None;
-            }
-            assert_eq!(
-                messages,
-                [
-                    AssetEvent::LoadedWithDependencies { id: handle.id() },
-                    AssetEvent::Modified { id: handle.id() }
-                ]
-            );
-            Some(())
-        });
-    }
-
-    #[test]
-    fn no_error_on_read_bytes_of_self_path() {
-        let (mut app, dir, source_events) = create_app_with_source_event_sender();
-        let asset_server = app.world().resource::<AssetServer>().clone();
-
-        dir.insert_asset_text(Path::new("abc.rsp"), "");
-
-        #[derive(TypePath)]
-        struct ReadBytesSelfLoader;
-
-        impl AssetLoader for ReadBytesSelfLoader {
-            type Asset = TestAsset;
-            type Error = crate::loader::LoadDirectError;
-            type Settings = ();
-
-            async fn load(
-                &self,
-                _: &mut dyn Reader,
-                _: &Self::Settings,
-                load_context: &mut LoadContext<'_>,
-            ) -> Result<Self::Asset, Self::Error> {
-                let asset_path = load_context.path().clone();
-                let _bytes = load_context.read_asset_bytes(asset_path).await.unwrap();
-                Ok(TestAsset)
-            }
-
-            fn extensions(&self) -> &[&str] {
-                &["rsp"]
-            }
-        }
-
-        app.init_asset::<TestAsset>()
-            .register_asset_loader(ReadBytesSelfLoader);
-
-        let handle: Handle<TestAsset> = asset_server.load("abc.rsp");
-
-        run_app_until(&mut app, |_world| match asset_server.load_state(&handle) {
-            LoadState::Loading => None,
-            LoadState::Loaded => Some(()),
-            state => panic!("Unexpected asset state: {state:?}"),
-        });
-
-        run_app_until(&mut app, |world| {
-            let messages = collect_asset_events(world);
-            if messages.is_empty() {
-                return None;
-            }
-            assert_eq!(
-                messages,
-                [
-                    AssetEvent::LoadedWithDependencies { id: handle.id() },
-                    AssetEvent::Added { id: handle.id() }
-                ]
-            );
-            Some(())
-        });
-
-        // Sending an asset event should result in the asset being reloaded - resulting in a
-        // "Modified" message.
-        source_events
-            .send_blocking(AssetSourceEvent::ModifiedAsset(PathBuf::from("abc.rsp")))
-            .unwrap();
-
-        run_app_until(&mut app, |world| {
-            let messages = collect_asset_events(world);
-            if messages.is_empty() {
-                return None;
-            }
-            assert_eq!(
-                messages,
-                [
-                    AssetEvent::LoadedWithDependencies { id: handle.id() },
-                    AssetEvent::Modified { id: handle.id() }
-                ]
-            );
-            Some(())
-        });
-    }
-
-    /// This is not a statement of intent but of behavior: One may load
-    /// their self path deferred of unknown type without error. It has the same
-    /// asset index as the original handle, but not the same type. And it can
-    /// reload.
-    #[test]
-    fn no_error_on_unknown_type_deferred_load_of_self_path() {
-        let (mut app, dir, source_events) = create_app_with_source_event_sender();
-        let asset_server = app.world().resource::<AssetServer>().clone();
-
-        dir.insert_asset_text(Path::new("abc.rsp"), "");
-
-        #[derive(Asset, TypePath)]
-        pub struct TestAssetUD(Handle<crate::LoadedUntypedAsset>);
-
-        #[derive(TypePath)]
-        struct ImmediateSelfLoader;
-
-        impl AssetLoader for ImmediateSelfLoader {
-            type Asset = TestAssetUD;
-            type Error = crate::loader::LoadDirectError;
-            type Settings = ();
-
-            async fn load(
-                &self,
-                _: &mut dyn Reader,
-                _: &Self::Settings,
-                load_context: &mut LoadContext<'_>,
-            ) -> Result<Self::Asset, Self::Error> {
-                let asset_path = load_context.path().clone();
-                let untyped_handle: Handle<crate::LoadedUntypedAsset> =
-                    load_context.loader().with_unknown_type().load(asset_path);
-
-                Ok(TestAssetUD(untyped_handle))
-            }
-
-            fn extensions(&self) -> &[&str] {
-                &["rsp"]
-            }
-        }
-
-        app.init_asset::<TestAssetUD>()
-            .register_asset_loader(ImmediateSelfLoader);
-
-        let handle: Handle<TestAssetUD> = asset_server.load("abc.rsp");
-
-        run_app_until(&mut app, |world| match asset_server.load_state(&handle) {
-            LoadState::Loading => None,
-            LoadState::Loaded => {
-                let asset_id = {
-                    let test_assets = world.resource::<Assets<TestAssetUD>>();
-                    let asset = test_assets.get(&handle).unwrap();
-                    asset.0.id()
-                };
-                let untyped = world.resource::<Assets<crate::LoadedUntypedAsset>>();
-                if let Some(untyped_handle) = untyped.get(asset_id) {
-                    assert_eq!(handle.id(), untyped_handle.handle.id());
-                    Some(())
-                } else {
-                    None
-                }
-            }
-            state => panic!("Unexpected asset state: {state:?}"),
-        });
-
-        run_app_until(&mut app, |world| {
-            let messages = collect_asset_events(world);
-            if messages.is_empty() {
-                return None;
-            }
-            assert_eq!(
-                messages,
-                [
-                    AssetEvent::LoadedWithDependencies { id: handle.id() },
-                    AssetEvent::Added { id: handle.id() }
-                ]
-            );
-            Some(())
-        });
-
-        // Sending an asset event should result in the asset being reloaded - resulting in a
-        // "Modified" message.
-        source_events
-            .send_blocking(AssetSourceEvent::ModifiedAsset(PathBuf::from("abc.rsp")))
-            .unwrap();
-
-        run_app_until(&mut app, |world| {
-            let messages = collect_asset_events(world);
-            if messages.is_empty() {
-                return None;
-            }
-            assert_eq!(
-                messages,
-                [
-                    AssetEvent::LoadedWithDependencies { id: handle.id() },
-                    AssetEvent::Modified { id: handle.id() }
-                ]
-            );
-            Some(())
-        });
-    }
-
     // validate the Asset derive macro for various asset types
     #[derive(Asset, TypePath)]
     pub struct TestAsset;
diff --git a/crates/bevy_asset/src/loader.rs b/crates/bevy_asset/src/loader.rs
index 90da8ab9cc20e..e00e57cb27045 100644
--- a/crates/bevy_asset/src/loader.rs
+++ b/crates/bevy_asset/src/loader.rs
@@ -306,8 +306,6 @@ pub enum LoadDirectError {
         dependency: AssetPath<'static>,
         error: AssetLoadError,
     },
-    #[error("The asset at path `{0:?}` requested to immediately load itself recursively, but this is not supported")]
-    RequestedSelfPath(AssetPath<'static>),
 }
 
 /// An error that occurs while deserializing [`AssetMeta`].
@@ -510,9 +508,7 @@ impl<'a> LoadContext<'a> {
                 path: path.path().to_path_buf(),
                 source,
             })?;
-        if self.asset_path != path {
-            self.loader_dependencies.insert(path.clone_owned(), hash);
-        }
+        self.loader_dependencies.insert(path.clone_owned(), hash);
         Ok(bytes)
     }
 
@@ -538,11 +534,6 @@ impl<'a> LoadContext<'a> {
         loader: &dyn ErasedAssetLoader,
         reader: &mut dyn Reader,
     ) -> Result<ErasedLoadedAsset, LoadDirectError> {
-        if self.asset_path == path {
-            return Err(LoadDirectError::RequestedSelfPath(
-                self.asset_path.clone_owned(),
-            ));
-        }
         let loaded_asset = self
             .asset_server
             .load_with_meta_loader_and_reader(
diff --git a/crates/bevy_asset/src/loader_builders.rs b/crates/bevy_asset/src/loader_builders.rs
index a1f76f7d95f11..f842d26a50f81 100644
--- a/crates/bevy_asset/src/loader_builders.rs
+++ b/crates/bevy_asset/src/loader_builders.rs
@@ -9,7 +9,6 @@ use crate::{
 };
 use alloc::{borrow::ToOwned, boxed::Box, sync::Arc};
 use core::any::TypeId;
-use tracing::debug;
 
 // Utility type for handling the sources of reader references
 enum ReaderRef<'a> {
@@ -305,8 +304,6 @@ impl NestedLoader<'_, '_, StaticTyped, Deferred> {
     /// [`with_unknown_type`]: Self::with_unknown_type
     pub fn load<'c, A: Asset>(self, path: impl Into<AssetPath<'c>>) -> Handle<A> {
         let path = path.into().to_owned();
-
-        let is_self_path = *self.load_context.path() == path;
         let handle = if self.load_context.should_load_dependencies {
             self.load_context.asset_server.load_with_meta_transform(
                 path,
@@ -321,15 +318,8 @@ impl NestedLoader<'_, '_, StaticTyped, Deferred> {
         };
         // `load_with_meta_transform` and `get_or_create_path_handle` always returns a Strong
         // variant, so we are safe to unwrap.
-        if !is_self_path {
-            let index = (&handle).try_into().unwrap();
-            self.load_context.dependencies.insert(index);
-        } else {
-            debug!(
-                "Asset from path `{:?}` loaded its self path",
-                self.load_context.path()
-            );
-        }
+        let index = (&handle).try_into().unwrap();
+        self.load_context.dependencies.insert(index);
         handle
     }
 }
@@ -377,7 +367,6 @@ impl NestedLoader<'_, '_, UnknownTyped, Deferred> {
     /// This will infer the asset type from metadata.
     pub fn load<'p>(self, path: impl Into<AssetPath<'p>>) -> Handle<LoadedUntypedAsset> {
         let path = path.into().to_owned();
-        let is_self_path = *self.load_context.path() == path;
         let handle = if self.load_context.should_load_dependencies {
             self.load_context
                 .asset_server
@@ -390,15 +379,7 @@ impl NestedLoader<'_, '_, UnknownTyped, Deferred> {
         // `load_unknown_type_with_meta_transform` and `get_or_create_path_handle` always returns a
         // Strong variant, so we are safe to unwrap.
         let index = (&handle).try_into().unwrap();
-
-        if !is_self_path {
-            self.load_context.dependencies.insert(index);
-        } else {
-            debug!(
-                "Asset from path `{:?}` of unknown type loaded its self path",
-                self.load_context.path()
-            );
-        }
+        self.load_context.dependencies.insert(index);
         handle
     }
 }
@@ -421,9 +402,6 @@ impl<'builder, 'reader, T> NestedLoader<'_, '_, T, Immediate<'builder, 'reader>>
         if path.label().is_some() {
             return Err(LoadDirectError::RequestedSubasset(path.clone()));
         }
-        if self.load_context.path() == path {
-            return Err(LoadDirectError::RequestedSelfPath(path.clone()));
-        }
         self.load_context
             .asset_server
             .write_infos()
diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs
index 559ca73f5d4bf..77a1cd55af3d4 100644
--- a/crates/bevy_asset/src/server/mod.rs
+++ b/crates/bevy_asset/src/server/mod.rs
@@ -1788,13 +1788,6 @@ pub fn handle_internal_asset_events(world: &mut World) {
         ) {
             if let Some(dependents) = infos.loader_dependents.get(asset_path) {
                 for dependent in dependents {
-                    assert_ne!(
-                        asset_path, dependent,
-                        "The asset path `{}` contains itself as a dependent.",
-                        &asset_path
-                    );
-                    // If the above assertion fails, the following code would
-                    // cause a stackoverflow.
                     paths_to_reload.insert(dependent.to_owned());
                     queue_ancestors(dependent, infos, paths_to_reload);
                 }
