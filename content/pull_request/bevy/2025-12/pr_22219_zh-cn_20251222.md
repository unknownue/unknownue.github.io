+++
title = "#22219 Small `text` example refactor"
date = "2025-12-22T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22219-en-20251222" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22219-zh-cn-20251222" }}
labels = ["D-Trivial", "C-Examples", "C-Code-Quality"]
+++

# Title

## Basic Information
- **Title**: Small `text` example refactor
- **PR Link**: https://github.com/bevyengine/bevy/pull/22219
- **Author**: ickshonpe
- **Status**: MERGED
- **Labels**: D-Trivial, C-Examples, C-Code-Quality, S-Ready-For-Final-Review, S-Needs-Review
- **Created**: 2025-12-21T12:02:31Z
- **Merged**: 2025-12-22T20:07:47Z
- **Merged By**: james7132

## Description Translation
# 目标

在`text`示例中，只对`font`参数进行特性控制（feature gate），而不是对整个组件包（component bundle）。

## The Story of This Pull Request

这个PR是一个小型重构，它改进了Bevy引擎UI示例中处理条件编译的方式。其核心是将特性开关（feature gate）的应用范围从整个组件元组（tuple）精确地缩小到一个具体的结构体字段上。

**问题与背景**
在修改前的代码`examples/ui/text.rs`中，有一个根据`default_font`特性是否存在来设置不同文本样式的逻辑。原来的实现使用了`cfg!`宏在运行时进行判断，并根据判断结果创建了两个几乎完全相同的组件元组。这两个元组的唯一区别在于`TextFont`结构体中的`font`字段：当`default_font`特性启用时，该字段使用默认值；当特性未启用时，则需要从资源服务器加载一个字体文件。

这种方法虽然功能正确，但存在代码重复（DRY原则 violation）和清晰度问题。两个分支的代码结构高度相似，只有局部差异，却重复了`TextFont`的整个初始化、`TextColor`的设置以及元组的包裹结构。这使得代码更难阅读和维护。

**解决方案**
作者采用了更符合Rust惯例的做法：直接在结构体字段上使用条件编译属性 `#[cfg(...)]`。新的实现移除了`if cfg!... else ...`的分支逻辑，而是构建了一个统一的`TextFont`结构体。在这个结构体的定义中，`font`字段被标记为`#[cfg(not(feature = "default_font"))]`。这意味着只有当`default_font`特性**未被**启用时，`font: asset_server.load(...)`这行代码才会被编译进去。如果`default_font`特性被启用，那么这一行代码在编译期就会被完全移除，`font`字段将使用其`Default::default()`的值。

**技术细节与实现**
让我们看一个具体的代码对比。重构前的代码逻辑是这样的：
```rust
if cfg!(feature = "default_font") {
    (
        TextFont { font_size: 33.0, ..default() }, // 使用默认字体
        TextColor(GOLD.into()),
    )
} else {
    (
        TextFont {
            font: asset_server.load("fonts/FiraMono-Medium.ttf"), // 加载字体
            font_size: 33.0,
            ..Default::default()
        },
        TextColor(GOLD.into()),
    )
}
```
重构后，代码被简化为：
```rust
(
    TextFont {
        #[cfg(not(feature = "default_font"))]
        font: asset_server.load("fonts/FiraMono-Medium.ttf"), // 条件编译此行
        font_size: 33.0,
        ..Default::default()
    },
    TextColor(GOLD.into()),
)
```

这种改变有几个好处：
1.  **消除重复**：`TextFont`的初始化、`font_size`的设置、`TextColor`的包裹现在都只出现一次。
2.  **编译期决策**：条件判断从运行时（`cfg!`宏在运行时求值）移到了编译期（`#[cfg]`属性），这虽然对性能影响微乎其微，但更符合习惯。
3.  **意图更清晰**：代码明确地展示了“仅在缺少默认字体特性时才加载字体”这一意图，所有的条件逻辑都紧挨着受影响的字段。
4.  **可维护性**：如果需要修改`font_size`或颜色，现在只需要修改一个地方。

**影响与总结**
这个PR虽然修改量很小（+10行，-20行），但它是一个典型的代码质量（Code Quality）提升案例。它展示了如何运用Rust语言的特性来编写更简洁、更声明式的代码。这种“将条件编译应用于最小必要范围”的模式，是Rust生态中处理特性依赖的最佳实践之一，有助于保持代码库的整洁和可读性。对于Bevy这样的游戏引擎，示例代码的清晰度尤为重要，因为它直接面向开发者，是学习和参考的第一手资料。这个重构使得`text`示例成为一个更好的、展示如何在Bevy中条件化使用资源的范例。

## Visual Representation

```mermaid
graph TD
    subgraph "重构前: 条件控制整个Bundle"
        A[cfg! 宏判断] --> B{default_font?}
        B -->|Yes| C[创建Bundle A<br/>font: default()]
        B -->|No| D[创建Bundle B<br/>font: asset_server.load(...)]
        C --> E[产生两个逻辑分支]
        D --> E
    end

    subgraph "重构后: 条件控制单个字段"
        F[单一代码路径] --> G[创建TextFont结构体]
        G --> H[font字段]
        H --> I[#[cfg(not(default_font))]]
        I -->|条件为真时编译| J[font: asset_server.load(...)]
        I -->|条件为假时忽略| K[font 使用 Default 值]
    end
```

## Key Files Changed

### `examples/ui/text.rs`
1.  **描述与原因**：重构了`setup`函数中创建文本组件的逻辑。将原来基于`cfg!`宏在两个完整组件包之间选择的模式，改为使用`#[cfg]`属性只在`TextFont.font`字段上进行条件编译。这使得代码更简洁，消除了重复，并更好地符合Rust的惯用法。
2.  **代码片段**：
```rust
// 重构前 (关键逻辑部分)
if cfg!(feature = "default_font") {
    (
        TextFont {
            font_size: 33.0,
            // If no font is specified, the default font (a minimal subset of FiraMono) will be used.
            ..default()
        },
        TextColor(GOLD.into()),
    )
} else {
    (
        // "default_font" feature is unavailable, load a font to use instead.
        TextFont {
            font: asset_server.load("fonts/FiraMono-Medium.ttf"),
            font_size: 33.0,
            ..Default::default()
        },
        TextColor(GOLD.into()),
    )
}

// 重构后
(
    TextFont {
        // If the "default_font" feature is unavailable, load a font to use instead.
        #[cfg(not(feature = "default_font"))]
        font: asset_server.load("fonts/FiraMono-Medium.ttf"),
        font_size: 33.0,
        ..Default::default()
    },
    TextColor(GOLD.into()),
)
```
3.  **与PR目的的关系**：这是本次PR的唯一修改文件，直接实现了描述中的目标——“只对`font`参数进行特性控制，而不是对整个组件包”。

## Further Reading
- **Rust Book: 条件编译 (`#[cfg]`)**：了解`#[cfg]`属性及其各种用法是理解此重构的基础。
- **Rust By Example: cfg**：通过实例学习`cfg!`宏和`#[cfg]`属性的区别与应用场景。
- **Bevy 官方文档：Asset Server**：了解Bevy中如何加载和管理资源，如本例中的字体文件。
- **《Clean Code》中关于“代码重复”的章节**：理解为何消除重复代码是提升软件质量的重要原则。