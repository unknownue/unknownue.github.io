+++
title = "#22041 Use mesh bounds center for transparent/transmissive sorting"
date = "2025-12-15T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22041-en-20251215" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22041-zh-cn-20251215" }}
+++

# Title
#22041：使用网格边界中心进行透明/透射排序

## 基本信息
- **标题**: Use mesh bounds center for transparent/transmissive sorting
- **PR链接**: https://github.com/bevyengine/bevy/pull/22041
- **作者**: venhelhardt
- **状态**: 已合并
- **标签**: A-Rendering, S-Ready-For-Final-Review, D-Modest
- **创建时间**: 2025-12-05T23:14:50Z
- **合并时间**: 2025-12-14T22:32:54Z
- **合并者**: alice-i-cecile

## 描述翻译
透明和透射渲染阶段之前使用来自 GlobalTransform 的实例平移（translation）作为排序位置。当网格几何体以"世界类似"坐标创作且实例变换是单位矩阵或接近单位矩阵时（在建筑/CAD风格内容中常见），这种方法会失效。在这种情况下，多个透明实例最终具有相同的平移，导致错误的绘制顺序。

此更改引入了基于网格边界的世界空间中心而非原始平移进行排序的方法。局部边界中心按网格/实例存储，并在构建排序键时通过实例的世界变换进行变换。这增加了少量每网格/实例数据，但在真实场景中产生更正确的透明和透射渲染。

# 目标
目前，Bevy中的透明和透射渲染阶段使用GlobalTransform的平移对实例进行排序。这仅在网格原点是几何体位置的良好代理时才有效。在许多实际情况（特别是CAD/建筑类内容）中，网格数据以"世界类似"坐标创作，实例`Transform`是单位矩阵。在这种设置下，按平移排序会导致透明/透射对象的绘制顺序错误。

我建议将排序键从`GlobalTransform.translation`切换到每个实例的网格边界的世界空间中心。

## 解决方案
不再使用`GlobalTransform.translation`作为透明/透射阶段的排序位置，而是使用网格边界的世界空间中心：

1. 为每个渲染网格存储局部空间边界中心（例如，在`RenderMeshInstanceShared`中作为从网格`Aabb`派生的`center: Vec3`）。
2. 对于每个实例，通过应用实例变换计算世界空间中心。
3. 在构建透明和透射阶段的排序键时，将此世界空间中心用作视图空间中的距离/深度计算的位置。

这样：
- 排序尊重几何体的实际空间位置
- 正确处理网格内具有烘焙"世界类似"坐标的实例
- 透明对象的绘制顺序在真实场景中变得更加稳定和视觉正确

主要权衡：
- 在`RenderMeshInstanceShared`中添加Vec3中心（通常增加12或16字节，取决于对齐方式）
- 对于每个实例，我们需要将局部边界中心变换到世界空间以计算排序键

### 替代方法及其缺点
理论上，可以通过**烘焙**网格来解决这个问题：
- 将网格重新围绕其局部边界框中心居中
- 调整实例`Transform`将其移回原位

然而，这有几个缺点：
- 需要修改每个网格的顶点数据（昂贵且容易出错）
- 需要复制网格或引入一次性编辑，这对实例化和内存不利
- 使资产工作流程复杂化（工具、导出器、管线）
- 仍然无法解决动态或程序生成的内容问题

在实践中，这不是一个可扩展或便捷的解决方案。

### 次要问题：深度相等时的不稳定排序
当前排序还存在另一个相关问题：当两个透明/透射实例最终具有相同的视图空间深度（例如，它们的中心投影到同一深度平面）时，绘制顺序变得不稳定。这会导致可见的闪烁，因为`RenderEntity`项的内部顺序在帧之间不能保证稳定。

在实践中，这很容易发生，特别是当多个透明实例共享相同或非常相似的排序深度时，它们在提取的渲染列表中的相对顺序可能会在帧之间变化。

为了解决这个问题，我建议使用确定性平局决胜键扩展排序键，例如实体的主索引。从概念上讲，排序键变为：
- 主要：视图空间深度（或距离）
- 次要：稳定的每实体索引

这确保具有相同深度的实例在帧之间保持一致的绘制顺序，消除闪烁，同时保持预期的基于深度的排序行为。

## 测试
- 您是否测试了这些更改？如果是，如何测试的？
```sh
cargo run -p ci -- test
cargo run -p ci -- doc
cargo run -p ci -- compile
```
- 是否有任何部分需要更多测试？不确定
- 其他人（评审者）如何测试您的更改？他们需要了解什么特定信息吗？
运行此"示例"
```rust
use bevy::{
    camera_controller::free_camera::{FreeCamera, FreeCameraPlugin},
    prelude::*,
};

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(FreeCameraPlugin)
        .add_systems(Startup, setup)
        .add_systems(Update, view_orient)
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let material = materials.add(StandardMaterial {
        base_color: Color::srgb_u8(150, 250, 150).with_alpha(0.7),
        alpha_mode: AlphaMode::Blend,
        ..default()
    });
    let mesh = Cuboid::new(3., 3., 1.)
        .mesh()
        .build()
        .translated_by(Vec3::new(1.5, 1.5, 0.5));

    // Cuboids grids
    for k in -1..=0 {
        let z_offset = k as f32 * 3.;

        for i in 0..3 {
            let x_offset = i as f32 * 3.25;

            for j in 0..3 {
                let y_offset = j as f32 * 3.25;

                commands.spawn((
                    Mesh3d(
                        meshes.add(
                            mesh.clone()
                                .translated_by(Vec3::new(x_offset, y_offset, z_offset)),
                        ),
                    ),
                    MeshMaterial3d(material.clone()),
                ));
            }
        }
    }

    // Cuboids at the center share the same position and are equidistant from the camera
    {
        commands.spawn((
            Mesh3d(meshes.add(mesh.clone().translated_by(Vec3::new(3.25, 3.25, 3.)))),
            MeshMaterial3d(material.clone()),
        ));
        commands.spawn((
            Mesh3d(meshes.add(mesh.clone().translated_by(Vec3::new(3.25, 3.25, 3.)))),
            MeshMaterial3d(materials.add(StandardMaterial {
                base_color: Color::srgb_u8(150, 150, 250).with_alpha(0.6),
                alpha_mode: AlphaMode::Blend,
                ..default()
            })),
        ));
        commands.spawn((
            Mesh3d(meshes.add(mesh.clone().translated_by(Vec3::new(3.25, 3.25, 3.)))),
            MeshMaterial3d(materials.add(StandardMaterial {
                base_color: Color::srgb_u8(250, 150, 150).with_alpha(0.5),
                alpha_mode: AlphaMode::Blend,
                ..default()
            })),
        ));
    }

    commands.spawn((PointLight::default(), Transform::from_xyz(-3., 10., 4.5)));
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(-3., 12., 15.).looking_at(Vec3::new(4.75, 4.75, 0.), Vec3::Y),
        FreeCamera::default(),
    ));
    commands.spawn((
        Node {
            position_type: PositionType::Absolute,
            padding: UiRect::all(px(10)),
            ..default()
        },
        GlobalZIndex(i32::MAX),
        children![(
            Text::default(),
            children![
                (TextSpan::new("1 - 3D view\n")),
                (TextSpan::new("2 - Front view\n")),
                (TextSpan::new("3 - Top view\n")),
                (TextSpan::new("4 - Right view\n")),
            ]
        )],
    ));
}

fn view_orient(
    input: Res<ButtonInput<KeyCode>>,
    mut camera_xform: Single<&mut Transform, With<Camera>>,
) {
    let xform = if input.just_pressed(KeyCode::Digit1) {
        Some(Transform::from_xyz(-3., 12., 15.).looking_at(Vec3::new(4.75, 4.75, 0.), Vec3::Y))
    } else if input.just_pressed(KeyCode::Digit2) {
        Some(Transform::from_xyz(4.75, 4.75, 15.).looking_at(Vec3::new(4.75, 4.75, 0.), Vec3::Y))
    } else if input.just_pressed(KeyCode::Digit3) {
        Some(Transform::from_xyz(4.75, 18., -1.).looking_at(Vec3::new(4.75, 0., -1.), Vec3::NEG_Z))
    } else if input.just_pressed(KeyCode::Digit4) {
        Some(Transform::from_xyz(-15., 4.75, -1.).looking_at(Vec3::new(0., 4.75, -1.), Vec3::Y))
    } else {
        None
    };

    if let Some(xform) = xform {
        camera_xform.set_if_neq(xform);
    }
}
```
- 如果相关，您在哪些平台上测试了这些更改，有哪些重要平台您无法测试？MacOS

---

## 展示
在我对建筑模型（窗户、玻璃等）的测试中，从基于平移的排序切换到基于边界中心的排序显著改善了视觉结果。之前出现混合错误或渲染不正确的透明表面现在以更预期的顺序渲染。

### 当前：
https://youtu.be/WjDjPAoKK6w

### 按aabb中心排序：
https://youtu.be/-Sl4GOXp_vQ

### 按aabb中心 + 平局决胜键排序：
https://youtu.be/0aQhkSKxECo

## 本次PR的故事

### 问题和背景
在3D渲染中，透明和透射材质的对象需要按从后到前的顺序绘制，以确保颜色正确混合。Bevy之前使用实体`GlobalTransform`中的`translation`分量作为排序位置。这种方法假设网格的原点（通常是(0,0,0)）是几何体的合理代表位置。

然而在实际应用中，特别是在建筑信息模型（BIM）和计算机辅助设计（CAD）领域，网格数据经常以"世界类似"坐标创作。这意味着网格顶点已经处于它们在世界空间中的最终位置，而实体的变换矩阵是单位矩阵。在这种情况下，多个不同的透明实例可能共享相同的`translation`值（都是(0,0,0)），但它们的几何体实际位于不同的世界空间位置。

这种不匹配导致排序错误，进而引起视觉伪影——透明对象的混合顺序不正确，可能出现闪烁或不自然的颜色叠加。

### 解决方案方法
开发者提出了一个直观的解决方案：使用网格边界框（axis-aligned bounding box, AABB）的世界空间中心作为排序位置，而不是变换矩阵的平移分量。这需要：

1. 在网格预处理阶段计算局部边界框中心
2. 在渲染时将此局部中心变换到世界空间
3. 使用世界空间中心计算视图空间深度

这种方法更好地代表了网格的实际空间位置，即使对于使用单位变换矩阵的实例也能正确工作。

在考虑替代方案时，开发者评估了"烘焙"方法：将网格重新居中并调整变换矩阵。这种方法需要修改顶点数据，不利于实例化，且增加了工作流程复杂性。相比之下，基于边界中心的方法只需添加少量内存开销（每个实例一个Vec3）和计算开销（每个实例一次矩阵变换）。

### 实现细节
实现分为几个关键部分：

首先，在`RenderMeshInstanceShared`结构中添加了`center`字段，用于存储局部边界框中心：

```rust
// crates/bevy_pbr/src/render/mesh.rs
pub struct RenderMeshInstanceShared {
    // ... 现有字段
    pub center: Vec3,  // 新增字段
}
```

这个中心值在创建`RenderMeshInstanceShared`时从网格的`Aabb`计算得到：

```rust
// 修改后的构造函数签名
pub fn new(
    // ... 现有参数
    aabb: Option<&Aabb>,  // 新增参数
) -> Self {
    // ...
    center: aabb.map_or(Vec3::ZERO, |aabb| aabb.center.into()),
}
```

对于CPU构建路径，在`render_mesh_queue_data`方法中计算世界空间中心：

```rust
let world_from_local = &render_mesh_instance.transforms.world_from_local;
let center = world_from_local
    .matrix3
    .mul_vec3(render_mesh_instance.shared.center)
    + world_from_local.translation;
```

对于GPU构建路径，在`RenderMeshInstanceGpuBuilder`中计算世界空间中心：

```rust
let world_from_local = &self.world_from_local;
let center =
    world_from_local.matrix3.mul_vec3(self.shared.center) + world_from_local.translation;
```

排序距离计算现在使用世界空间中心而不是平移。在`material.rs`中的变化：

```rust
// 之前：
let distance = rangefinder.distance_translation(&mesh_instance.translation)

// 之后：
let distance = rangefinder.distance(&mesh_instance.center)
```

`ViewRangefinder3d`的接口也相应简化，现在只提供一个接受世界空间位置的`distance`方法：

```rust
// crates/bevy_render/src/render_phase/rangefinder.rs
#[inline]
pub fn distance(&self, position: &Vec3) -> f32 {
    self.view_from_world_row_2.dot(position.extend(1.0))
}
```

### 技术洞察
这个PR展示了几个重要的工程原则：

1. **语义正确性重于简单性**：虽然使用`translation`更简单，但不能正确反映几何体的实际位置。使用边界中心提供了更好的语义匹配。

2. **数据驱动设计**：通过在`RenderMeshInstanceShared`中存储预计算的局部中心，避免了每次排序时重新计算边界框的需要。这是典型的空间换时间权衡。

3. **接口简化**：重构后的`ViewRangefinder3d::distance`方法现在接受通用的世界空间位置，而不是特定类型的变换数据。这减少了API的复杂性并提高了可重用性。

4. **向后兼容性**：对于没有边界框的网格，代码默认使用`Vec3::ZERO`作为中心，这保持了向后兼容性。

5. **性能考量**：每个实例增加了一次3x3矩阵乘法运算，这在现代GPU上通常是微不足道的。内存开销也很小——每个实例大约增加16字节。

### 影响
这个PR带来的主要改进包括：

1. **正确性提升**：CAD/BIM风格的透明内容现在可以正确排序和渲染，解决了实际工作流程中的痛点。

2. **视觉质量改善**：透明对象混合更加自然，减少了视觉伪影。

3. **代码清晰度**：`ViewRangefinder3d`接口简化，职责更加明确。

4. **扩展性**：基于边界中心的方法为未来可能的优化（如层次化排序）奠定了基础。

虽然增加了少量计算和内存开销，但对于透明渲染的质量提升来说，这是一个合理的权衡。这个更改特别有价值，因为它解决了真实世界内容创作工作流程中的一个具体问题。

## 视觉表示

```mermaid
graph TB
    A[网格数据<br/>包含AABB] --> B[RenderMeshInstanceShared<br/>存储局部center]
    B --> C[CPU构建路径]
    B --> D[GPU构建路径]
    
    C --> E[在extract阶段<br/>计算世界空间center]
    D --> F[在prepare阶段<br/>计算世界空间center]
    
    E --> G[RenderMeshQueueData<br/>包含世界空间center]
    F --> G
    
    G --> H[ViewRangefinder3d.distance()<br/>计算视图空间深度]
    H --> I[排序透明/透射实例]
    I --> J[正确渲染顺序]
```

## 关键文件更改

### `crates/bevy_pbr/src/render/mesh.rs` (+41/-13)
这个文件包含了核心数据结构的更改。主要变化包括：

1. 在`RenderMeshInstanceShared`中添加了`center`字段
2. 更新了构造函数以接受并计算局部边界中心
3. 修改了`RenderMeshInstanceGpu`和`RenderMeshQueueData`以使用世界空间中心而非平移

```rust
// 关键变化示例：
pub struct RenderMeshInstanceShared {
    // ...
    pub center: Vec3,  // 新增：局部边界中心
}

pub struct RenderMeshQueueData<'a> {
    pub shared: &'a RenderMeshInstanceShared,
    pub center: Vec3,  // 之前是translation，现在是世界空间中心
    // ...
}
```

### `crates/bevy_render/src/render_phase/rangefinder.rs` (+8/-19)
简化了`ViewRangefinder3d`的API，移除特定于变换的方法，统一为接受世界空间位置的方法：

```rust
// 之前有两个方法：
pub fn distance_translation(&self, translation: &Vec3) -> f32
pub fn distance(&self, transform: &Mat4) -> f32

// 现在只有一个方法：
pub fn distance(&self, position: &Vec3) -> f32
```

### `crates/bevy_pbr/src/material.rs` (+2/-2)
更新了透明和透射材质的排序调用：

```rust
// 之前：
let distance = rangefinder.distance_translation(&mesh_instance.translation)

// 之后：
let distance = rangefinder.distance(&mesh_instance.center)
```

### 示例文件
更新了两个高级着色器示例以使用新的API：

- `examples/shader_advanced/custom_render_phase.rs` (+1/-1)
- `examples/shader_advanced/custom_shader_instancing.rs` (+1/-1)

## 进一步阅读

1. **透明排序算法**：深入了解3D图形中透明对象排序的各种方法和技术
2. **边界体积层次**：学习BVH等数据结构如何加速空间查询和排序
3. **Bevy渲染架构**：研究Bevy的ECS渲染系统设计
4. **计算机图形学基础**：了解视图变换、投影变换和深度缓冲的工作原理