+++
title = "#22031 Support non-sRGB image formats for `RenderTarget::Image`"
date = "2025-12-09T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22031-en-20251209" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22031-zh-cn-20251209" }}
labels = ["C-Bug", "A-Rendering"]
+++

# Support non-sRGB image formats for `RenderTarget::Image`

## Basic Information
- **Title**: Support non-sRGB image formats for `RenderTarget::Image`
- **PR Link**: https://github.com/bevyengine/bevy/pull/22031
- **Author**: bonsairobo
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, S-Ready-For-Final-Review
- **Created**: 2025-12-05T01:03:33Z
- **Merged**: 2025-12-09T18:56:05Z
- **Merged By**: alice-i-cecile

## Description Translation

### 目标
- 修复 #15201 

### 解决方案
- 看起来存在一些混淆，`OutputColorAttachment::format`可能与实际的底层纹理格式（`OutputColorAttachment::view`的）不同。这最终会导致`BlitPipeline`上的纹理格式不匹配。我移除了`OutputColorAttachment::format`字段来解决这个冲突。
- 同样处理了`ManualTextureView`。

### 测试
- #15201提供的重现步骤不再导致WGPU验证错误。
- 我在原生平台和WebGPU上测试了`pbr`示例，它仍然像以前一样工作。

### 后续工作
尽管WGPU验证错误已修复，但在`headless_renderer`示例中对GPU图像使用非sRGB纹理格式时，输出图像似乎有错误的伽马值。我认为这是因为该示例在没有伽马校正的情况下对GPU图像进行逐字节复制到CPU图像；而`image`库在保存图像时假设了非线性色彩空间。

我认为不需要在这个PR中修复这个问题，但最终让`bevy_image::Image::try_into_dynamic`在处理线性色彩图像保存时处理伽马校正可能会很好。

<details>
<summary>这里你可以看到一个对比</summary>
使用sRGB
<img width="1920" height="1080" alt="with_srgb" src="https://github.com/user-attachments/assets/b6d96072-2754-4fc3-bb5a-fc2994e65dc0" />

不使用sRGB
<img width="1920" height="1080" alt="no_srgb" src="https://github.com/user-attachments/assets/46f83f85-2202-40f6-9a68-85bdf4631494" />
</details>

## The Story of This Pull Request

这个PR解决的问题是：当使用非sRGB图像格式作为`RenderTarget::Image`时，会触发WGPU验证错误。具体问题出现在纹理格式的同步上。

问题的核心在于存在两套不一致的纹理格式数据。在渲染系统中，`OutputColorAttachment`结构体存储了一个`format`字段，但这个字段可能与底层纹理视图的实际格式不同步。当渲染流水线（特别是`BlitPipeline`）试图使用这两个格式信息时，就会出现不匹配的情况，导致WGPU验证错误。

开发者bonsairobo采用了直接且有效的解决方案：移除多余的格式字段，直接从纹理视图的底层纹理获取格式信息。这样可以保证格式信息的一致性，因为纹理对象本身存储了确切的格式信息。

在实现上，主要修改了几个关键组件。首先移除了`OutputColorAttachment`的`format`字段，这样创建`OutputColorAttachment`时只需要提供纹理视图，格式信息在需要时从纹理视图中获取。同样的修改也应用于`ManualTextureView`，移除了它的`format`字段，并重命名了构造函数以反映这一变化。

这种修改有几个技术考虑。首先，它消除了数据不一致的可能性。以前，如果某个地方更新了纹理格式但没有更新`OutputColorAttachment::format`，就会导致不匹配。现在格式信息总是与纹理本身保持一致。其次，这个修改简化了API，因为用户不再需要手动指定格式参数。

然而，这个修改也带来了一些变化点。例如在`prepare_view_attachments`函数中，之前代码会为某些格式添加sRGB后缀，现在这个逻辑被移除了。这是因为纹理视图的格式应该已经包含了正确的色彩空间信息，不需要再进行转换。

还有一个重要的技术细节是关于`view_formats`的设置。在纹理创建时，之前代码会为某些格式（如`Bgra8Unorm`和`Rgba8Unorm`）添加sRGB变体作为视图格式。在这个PR中，这个逻辑被完全移除，将`view_formats`设为空切片。这可能是为了简化处理，因为纹理视图的格式现在直接从纹理获取，不需要额外的转换层。

在截图处理代码中也有相应的修改。之前代码在创建`OutputColorAttachment`时会给格式添加sRGB后缀，现在直接使用纹理视图创建，不需要指定格式。对于`ManualTextureView`，格式信息同样从纹理视图中获取。

这个修复解决了一个具体的问题，但也暴露了另一个相关的问题：当使用非sRGB格式时，图像保存可能会产生不正确的伽马值。这是因为图像库假设图像数据在非线性色彩空间中，而直接从线性色彩空间的纹理复制数据没有进行伽马校正。这个问题被留作后续改进，因为它超出了当前PR的范围。

总的来说，这个PR通过简化数据存储和确保格式信息的一致性，解决了非sRGB渲染目标的兼容性问题。修改虽然涉及多个文件，但核心思想是一致的：移除冗余的格式字段，直接从纹理源获取格式信息。

## Visual Representation

```mermaid
graph TD
    A[RenderTarget::Image] --> B[OutputColorAttachment]
    B --> C{格式同步问题}
    C --> D[BlitPipeline验证错误]
    C --> E[解决方案:移除冗余格式字段]
    E --> F[OutputColorAttachment::format字段]
    E --> G[ManualTextureView::format字段]
    F --> H[从TextureView.texture().format()获取]
    G --> I[从TextureView.texture().format()获取]
    H --> J[格式一致性]
    I --> J
```

## Key Files Changed

### `crates/bevy_render/src/texture/manual_texture_view.rs` (+3/-10)
这个文件移除了`ManualTextureView`结构体的`format`字段，并简化了构造函数。不再需要从外部指定格式，而是直接从纹理视图获取。

```rust
// 修改前:
pub struct ManualTextureView {
    pub texture_view: TextureView,
    pub size: UVec2,
    pub format: TextureFormat,
}

impl ManualTextureView {
    pub fn with_default_format(texture_view: TextureView, size: UVec2) -> Self {
        Self {
            texture_view,
            size,
            format: TextureFormat::bevy_default(),
        }
    }
}

// 修改后:
pub struct ManualTextureView {
    pub texture_view: TextureView,
    pub size: UVec2,
}

impl ManualTextureView {
    pub fn new(texture_view: TextureView, size: UVec2) -> Self {
        Self { texture_view, size }
    }
}
```

### `crates/bevy_render/src/texture/texture_attachment.rs` (+2/-4)
移除了`OutputColorAttachment`的`format`字段，简化了构造函数。格式信息现在从纹理视图的底层纹理获取。

```rust
// 修改前:
pub struct OutputColorAttachment {
    pub view: TextureView,
    pub format: TextureFormat,
    is_first_call: Arc<AtomicBool>,
}

impl OutputColorAttachment {
    pub fn new(view: TextureView, format: TextureFormat) -> Self {
        Self {
            view,
            format,
            is_first_call: Arc::new(AtomicBool::new(true)),
        }
    }
}

// 修改后:
pub struct OutputColorAttachment {
    pub view: TextureView,
    is_first_call: Arc<AtomicBool>,
}

impl OutputColorAttachment {
    pub fn new(view: TextureView) -> Self {
        Self {
            view,
            is_first_call: Arc::new(AtomicBool::new(true)),
        }
    }
}
```

### `crates/bevy_render/src/view/mod.rs` (+3/-10)
修改了`ViewTarget::out_texture_format`方法，现在从纹理视图的纹理获取格式。同时简化了`prepare_view_attachments`函数中的`OutputColorAttachment`创建逻辑。

```rust
// ViewTarget::out_texture_format 修改:
// 修改前:
pub fn out_texture_format(&self) -> TextureFormat {
    self.out_texture.format
}

// 修改后:
pub fn out_texture_format(&self) -> TextureFormat {
    self.out_texture.view.texture().format()
}

// prepare_view_attachments 中的修改:
// 修改前:
.map(|(view, format)| {
    OutputColorAttachment::new(view.clone(), format.add_srgb_suffix())
})

// 修改后:
.map(OutputColorAttachment::new)
```

### `crates/bevy_render/src/camera.rs` (+3/-3)
修改了`NormalizedRenderTargetExt`实现，对于`TextureView`类型的渲染目标，现在从纹理视图的纹理获取格式。

```rust
// 修改前:
NormalizedRenderTarget::TextureView(id) => {
    manual_texture_views.get(id).map(|tex| tex.format)
}

// 修改后:
NormalizedRenderTarget::TextureView(id) => manual_texture_views
    .get(id)
    .map(|view| view.texture_view.texture().format()),
```

### `crates/bevy_render/src/view/window/screenshot.rs` (+5/-5)
在截图处理中相应地修改了`OutputColorAttachment`的创建方式，移除了手动指定格式的逻辑。

```rust
// 修改前（多个位置）:
OutputColorAttachment::new(texture_view.clone(), format.add_srgb_suffix())

// 修改后（多个位置）:
OutputColorAttachment::new(texture_view.clone())
```

## Further Reading

1. **WGPU纹理格式文档**: https://docs.rs/wgpu/latest/wgpu/enum.TextureFormat.html
2. **色彩空间与伽马校正**: 了解sRGB和线性色彩空间之间的区别对于理解这个PR的后续工作很重要
3. **Bevy渲染管线架构**: 理解Bevy如何管理渲染目标和纹理视图有助于理解这个修改的影响范围
4. **纹理视图与纹理的关系**: 在图形API中，纹理视图是对纹理的特定解释，可以有不同的格式和维度