+++
title = "#22258 Add toggle function for virtual time"
date = "2025-12-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22258-en-20251230" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22258-zh-cn-20251230" }}
+++

# Title

## Basic Information
- **标题**: Add toggle function for virtual time
- **PR链接**: https://github.com/bevyengine/bevy/pull/22258
- **作者**: GitGhillie
- **状态**: 已合并
- **标签**: C-Usability, S-Ready-For-Final-Review, A-Time
- **创建时间**: 2025-12-24T14:33:00Z
- **合并时间**: 2025-12-30T01:23:41Z
- **合并者**: alice-i-cecile

## 描述翻译
# 目标

在查看 https://github.com/bevyengine/bevy/pull/22207 的diff时，我注意到存在一些代码重复。

## 解决方案

将切换功能移动到一个函数中，并更新示例。

## 测试

- 通过运行示例并切换时间来测试。

## 这个Pull Request的故事

这个PR源于一个简单的观察：在Bevy引擎的时间管理代码中存在重复的逻辑模式。开发者在查看另一个PR (#22207) 的差异时，注意到多个地方都在实现相同的暂停/恢复切换逻辑。这种重复不仅增加了代码维护成本，也给使用API的开发者带来了不必要的认知负担。

### 问题与背景

在Bevy的时间管理系统中，`Time<Virtual>`类型用于管理虚拟时间。虚拟时间可以独立于真实时间运行，允许开发者控制游戏的时间流逝速度，这在实现游戏暂停、快进或慢动作效果时非常有用。系统提供了`pause()`和`unpause()`方法来分别暂停和恢复时间。

然而，在实际使用中，一个常见的需求是切换时间的暂停状态——如果时间正在运行就暂停它，如果已经暂停就恢复它。在添加`toggle()`方法之前，开发者需要在代码中手动实现这个逻辑：

```rust
if time.is_paused() {
    time.unpause();
} else {
    time.pause();
}
```

这种模式在多个示例代码中重复出现，包括`virtual_time.rs`和`solari.rs`。虽然这个逻辑很简单，但重复的代码违反了DRY（Don't Repeat Yourself）原则，增加了维护成本。如果未来需要修改切换逻辑，必须在所有出现的地方进行修改。

### 解决方案方法

解决方案直接而有效：在`Time<Virtual>`类型上添加一个`toggle()`方法，将所有重复的切换逻辑统一到一个地方。这种方法有几个优势：

1. **消除重复代码**：将相同的逻辑从多个调用点移动到单个方法中
2. **提高API可用性**：为常见的操作模式提供专用方法
3. **保持向后兼容性**：现有的`pause()`和`unpause()`方法保持不变

技术实现上，`toggle()`方法使用XOR（异或）操作来切换布尔值，这是一种高效且简洁的实现方式：`self.context_mut().paused ^= true;`

### 实现细节

在`virt.rs`文件中，添加了`toggle()`方法：

```rust
/// Stops the clock if it is running, otherwise resumes the clock.
#[inline]
pub fn toggle(&mut self) {
    self.context_mut().paused ^= true;
}
```

这个方法的设计考虑了性能，使用了`#[inline]`属性提示编译器内联这个简单的方法。XOR操作(`^= true`)是切换布尔值的标准方法：如果`paused`是`true`，它变为`false`；如果是`false`，变为`true`。

同时，更新了相关的文档注释，明确指出`toggle()`方法的存在：

```rust
/// The virtual clock can be paused by calling [`pause()`](Time::pause),
/// unpaused by calling [`unpause()`](Time::unpause), or toggled by calling
/// [`toggle()`](Time::toggle).
```

在示例文件中，用新的`toggle()`方法替换了重复的切换逻辑。例如，在`virtual_time.rs`中：

```rust
// 之前:
fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
    if time.is_paused() {
        time.unpause();
    } else {
        time.pause();
    }
}

// 之后:
fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
    time.toggle();
}
```

### 技术洞察

这个PR展示了几个重要的软件工程原则：

1. **DRY原则**：通过识别和消除重复代码，提高了代码库的可维护性
2. **API设计**：通过为常见用例提供便利方法，改善了API的可用性
3. **渐进式改进**：保持向后兼容性，不破坏现有代码

`toggle()`方法的实现虽然简单，但体现了良好的API设计思维。它为开发者提供了更直观的操作方式——当用户想要切换状态时，他们可以调用`toggle()`而不是编写条件判断。

此外，这个更改还间接改善了代码的可读性。`time.toggle()`比条件判断更清晰地表达了意图：读者立即明白这是在切换状态，而不需要解析`if-else`逻辑。

### 影响

这个更改的影响是多方面的：

1. **减少代码量**：三个文件中总共减少了11行代码（+15/-26的净变化）
2. **提高可维护性**：切换逻辑现在集中在一处，未来如果需要修改，只需更改一个地方
3. **更好的开发者体验**：使用`Time<Virtual>`的开发者现在有一个更简洁的方法来切换时间状态
4. **一致性**：所有示例现在使用相同的API，为新开发者提供了更好的学习体验

从架构角度来看，这个更改保持了Bevy时间系统的简洁性和一致性。`toggle()`方法自然扩展了现有的`pause()`/`unpause()`方法对，没有引入复杂的依赖或破坏现有的抽象。

## 可视化表示

```mermaid
graph TD
    A[Time<Virtual>类型] --> B[现有方法]
    A --> C[新增方法]
    B --> D[pause()]
    B --> E[unpause()]
    C --> F[toggle()]
    
    G[示例代码] --> H[virtual_time.rs]
    G --> I[solari.rs]
    
    F -->|替换| H
    F -->|替换| I
```

## 关键文件更改

### 1. `crates/bevy_time/src/virt.rs` (+10/-3)

**变化描述**: 添加了`toggle()`方法并更新了相关文档

**关键代码片段**:
```rust
// 在Time<Virtual>实现中添加:
/// Stops the clock if it is running, otherwise resumes the clock.
#[inline]
pub fn toggle(&mut self) {
    self.context_mut().paused ^= true;
}

// 文档更新:
/// The virtual clock can be paused by calling [`pause()`](Time::pause),
/// unpaused by calling [`unpause()`](Time::unpause), or toggled by calling
/// [`toggle()`](Time::toggle).
```

**关联性**: 这是核心变更，为虚拟时间添加了切换功能

### 2. `examples/time/virtual_time.rs` (+4/-8)

**变化描述**: 用新的`toggle()`方法替换了手动切换逻辑

**关键代码片段**:
```rust
// 之前:
fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
    if time.is_paused() {
        time.unpause();
    } else {
        time.pause();
    }
}

// 之后:
fn toggle_pause(mut time: ResMut<Time<Virtual>>) {
    time.toggle();
}
```

**关联性**: 展示了新API在实际使用中的简洁性

### 3. `examples/3d/solari.rs` (+1/-5)

**变化描述**: 同样用`toggle()`替换了手动切换逻辑

**关键代码片段**:
```rust
// 之前:
if key_input.just_pressed(KeyCode::Space) {
    if time.is_paused() {
        time.unpause();
    } else {
        time.pause();
    }
}

// 之后:
if key_input.just_pressed(KeyCode::Space) {
    time.toggle();
}
```

**关联性**: 证明了新API在不同上下文中的适用性

## 进一步阅读

1. **Bevy时间系统文档**: [https://docs.rs/bevy_time/latest/bevy_time/](https://docs.rs/bevy_time/latest/bevy_time/)
2. **Rust的XOR操作符**: 了解`^=`操作符在布尔值切换中的应用
3. **API设计原则**: 关于如何设计易用且一致的API
4. **DRY原则**: 深入了解Don't Repeat Yourself原则及其在软件工程中的应用
5. **Bevy示例代码库**: 查看其他时间管理示例以了解虚拟时间的更多用法