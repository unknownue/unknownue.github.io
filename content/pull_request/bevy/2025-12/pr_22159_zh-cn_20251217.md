+++
title = "#22159 Prevent the transaction log for a bevy_asset test from writing to the file system."
date = "2025-12-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22159-en-20251217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22159-zh-cn-20251217" }}
+++

# Prevent the transaction log for a bevy_asset test from writing to the file system.

## 基本信息
- **标题**: Prevent the transaction log for a bevy_asset test from writing to the file system.
- **PR 链接**: https://github.com/bevyengine/bevy/pull/22159
- **作者**: andriyDev
- **状态**: 已合并
- **标签**: A-Assets, S-Ready-For-Review, C-Testing, D-Straightforward
- **创建时间**: 2025-12-17T01:50:33Z
- **合并时间**: 2025-12-17T19:25:39Z
- **合并者**: alice-i-cecile

## 描述翻译
### 目标
- bevy_asset 测试正在写入文件系统！

### 解决方案
- 与更多测试共享 `create_app` 的实现。
- 为此测试设置事务日志以使用假的事务日志（与 #21476 相同）。

## 这个 PR 的故事

这个问题起源于一个具体的测试问题：bevy_asset 模块的测试用例正在意外地向文件系统写入事务日志文件。在测试环境中，这会产生几个负面影响：测试可能留下残留文件，影响测试环境的清洁度；如果多个测试并行运行，可能会产生文件冲突；更重要的是，它违背了单元测试的隔离性原则——测试不应该依赖于或修改外部文件系统。

问题的核心在于测试中创建的 App 实例使用了默认配置的 `AssetPlugin`，而这个插件会启用资产处理器的事务日志功能，该日志默认会写入磁盘。虽然之前已经有 PR #21476 引入了假事务日志（fake transaction log）的解决方案，但并非所有测试都应用了这种模式。

这个 PR 采取了两个系统性的解决方案：

1. **推广已有的测试工具函数**：将 `lib.rs` 中已有的 `create_app()` 测试工具函数公开（`pub(crate)`），并让多个测试文件改用这个统一的函数来创建测试环境。这个函数的核心优势在于它预先配置了内存文件系统和禁用了文件监视及资产处理器，从根本上避免了文件系统操作。

2. **应用假事务日志到遗漏的测试**：在 `processor/tests.rs` 中，提取出设置假事务日志的逻辑为一个独立的 `set_fake_transaction_log()` 函数，并应用到之前遗漏的测试 `only_reprocesses_wrong_hash_on_startup` 中。这个假事务日志实现了所有必要的方法，但实际操作都是空操作，避免了任何磁盘写入。

从技术实现上看，这个 PR 展示了一个典型的测试代码重构模式：识别出产生副作用（side effects）的代码模式，提取出无副作用的替代方案，然后在多个地方重用这个方案。`create_app()` 函数不仅解决了事务日志问题，还统一了测试环境的配置，包括使用内存资产读取器（`MemoryAssetReader`）和禁用不需要的插件功能。

在 `lib.rs` 中，对 `create_app()` 的修改包括将其可见性从私有改为 `pub(crate)`，并在创建 `AssetPlugin` 时明确设置：
```rust
AssetPlugin {
    watch_for_changes_override: Some(false),
    use_asset_processor_override: Some(false),
    ..Default::default()
}
```
这两个 `override` 设置为 `Some(false)` 确保了即使全局配置不同，测试中也不会启用文件监视和资产处理器。

对于使用资产处理器的测试场景（在 `processor/tests.rs` 中），PR 通过 `set_fake_transaction_log()` 函数注入了假的事务日志工厂和日志实例。这些假实现满足 trait 要求但不执行实际的文件操作：

```rust
impl ProcessorTransactionLog for FakeTransactionLog {
    fn begin_processing<'a>(
        &'a mut self,
        _asset: &'a AssetPath<'_>,
    ) -> BoxedFuture<'a, Result<(), BevyError>> {
        Box::pin(async move { Ok(()) })
    }
    // ... 其他方法类似
}
```

这个 PR 的影响是直接的：所有相关的测试现在都完全在内存中运行，不接触文件系统。这提高了测试的可靠性、运行速度，并确保了测试的隔离性。从代码质量角度看，它也减少了重复的测试样板代码，使测试意图更加清晰——现在测试可以专注于业务逻辑，而不是环境配置。

## 视觉表示

```mermaid
graph TD
    A[测试文件] --> B{使用哪种方式创建App?}
    B -->|旧方式| C[直接创建App + 默认AssetPlugin]
    C --> D[写入文件系统 ❌]
    B -->|新方式| E[使用create_app()函数]
    E --> F[预配置的AssetPlugin]
    F --> G[内存文件系统 ✓]
    F --> H[禁用文件监视 ✓]
    F --> I[禁用资产处理器 ✓]
    E --> J[特殊测试需要资产处理器]
    J --> K[使用set_fake_transaction_log()]
    K --> L[假事务日志 ✓]
```

## 关键文件更改

### 1. `crates/bevy_asset/src/lib.rs`
**更改描述**: 将 `create_app` 测试辅助函数公开，并在其中预配置 `AssetPlugin` 以避免文件系统操作。

**关键代码片段**:
```rust
// 之前: 私有函数
fn create_app() -> (App, Dir)

// 之后: 公开的函数
pub(crate) fn create_app() -> (App, Dir) {
    let mut app = App::new();
    // ... 设置内存文件系统
    app.add_plugins((
        TaskPoolPlugin::default(),
        AssetPlugin {
            watch_for_changes_override: Some(false),  // 禁用文件监视
            use_asset_processor_override: Some(false), // 禁用资产处理器
            ..Default::default()
        },
        DiagnosticsPlugin,
    ));
    (app, dir)
}
```

### 2. `crates/bevy_asset/src/asset_changed.rs`
**更改描述**: 将测试中的 App 创建方式从直接创建改为使用 `create_app()` 函数。

**关键代码片段**:
```rust
// 之前
let mut app = App::new();
app.add_plugins((TaskPoolPlugin::default(), AssetPlugin::default()))
    .init_asset::<MyAsset>();

// 之后
let mut app = create_app().0;
app.init_asset::<MyAsset>();
```

### 3. `crates/bevy_asset/src/processor/tests.rs`
**更改描述**: 提取假事务日志设置逻辑为独立函数，并应用到遗漏的测试中。

**关键代码片段**:
```rust
// 新增的共享函数
fn set_fake_transaction_log(app: &mut App) {
    // 定义 FakeTransactionLogFactory 和 FakeTransactionLog
    // 设置到 AssetProcessor 中
}

// 在 create_app_with_asset_processor 中使用
fn create_app_with_asset_processor(extra_sources: &[String]) -> AppWithProcessor {
    // ... 创建 app 的代码
    set_fake_transaction_log(&mut app); // 新增这行
}

// 在 only_reprocesses_wrong_hash_on_startup 测试中使用
#[test]
fn only_reprocesses_wrong_hash_on_startup() {
    let mut app = App::new();
    // ... 配置 app
    set_fake_transaction_log(&mut app); // 新增这行
    // ... 测试逻辑
}
```

### 4. `crates/bevy_asset/src/handle.rs`
**更改描述**: 测试改用 `create_app()` 函数。

### 5. `crates/bevy_asset/src/reflect.rs`
**更改描述**: 测试改用 `create_app()` 函数。

## 进一步阅读
- [Bevy 资产系统文档](https://docs.rs/bevy_asset/latest/bevy_asset/) - 了解 Bevy 的资产管理系统
- [测试中的依赖注入和模拟](https://en.wikipedia.org/wiki/Dependency_injection) - 理解如何在测试中替换真实依赖
- [Rust 测试组织最佳实践](https://doc.rust-lang.org/book/ch11-03-test-organization.html) - 学习如何组织测试代码