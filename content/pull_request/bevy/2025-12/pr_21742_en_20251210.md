+++
title = "#21742 Change a function system to be exclusive"
date = "2025-12-10T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21742-en-20251210" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21742-zh-cn-20251210" }}
labels = ["C-Feature", "A-ECS", "X-Contentious"]
+++

# Change a function system to be exclusive

## Basic Information
- **Title**: Change a function system to be exclusive
- **PR Link**: https://github.com/bevyengine/bevy/pull/21742
- **Author**: hymm
- **Status**: MERGED
- **Labels**: C-Feature, A-ECS, S-Ready-For-Final-Review, X-Contentious
- **Created**: 2025-11-04T22:37:20Z
- **Merged**: 2025-12-09T23:50:10Z
- **Merged By**: alice-i-cecile

## Description Translation
The original description is in English, so it is included as-is:

# Objective

- I was experimenting with a library for combining multiple systems into one system that could be scheduled, but there wasn't a way of marking a function system run exclusively.

## Solution

- Add a method to `SystemMeta` to set the exclusive flag. Note that this PR doesn't add anyway to actually set the flag easily. You would have to create a custom system param to be able to set it.
- Add a system param to mark a function system to run exclusively.

## Testing

- Haven't tested. The one worry would be how it interacts with the executor, but in theory this should just work, since the flag is the only way the executor knows that a system is exclusive or not.

## The Story of This Pull Request

This PR addresses a specific need in Bevy's Entity Component System (ECS): the ability to mark a function system as exclusive. In Bevy, exclusive systems have unique access to the entire `World` and cannot run concurrently with other systems. This is important for operations that require full control over the world state, but previously, there was no straightforward way to mark a regular function system as exclusive.

The author was working on a library that combines multiple systems into one schedulable unit and encountered the limitation that function systems couldn't be easily marked as exclusive. The existing `SystemMeta` struct already tracks system flags through `SystemStateFlags`, which includes an `EXCLUSIVE` flag, but there was no public API to set this flag for function systems.

The solution is implemented in two parts. First, a new method `set_exclusive()` is added to `SystemMeta` in `function_system.rs`. This method simply sets the `EXCLUSIVE` flag in the system's state flags, following the same pattern as the existing `set_has_deferred()` method.

Second, a new system parameter `ExclusiveMarker` is introduced in `system_param.rs`. This is a "dummy" type that implements the `SystemParam` trait. When this parameter is included in a function system's signature, it triggers the system to be marked as exclusive during initialization. The key mechanism is in the `init_access` method of the `SystemParam` implementation for `ExclusiveMarker`, which calls `system_meta.set_exclusive()`.

This approach follows Bevy's existing patterns for system parameters that modify system behavior without actually providing data. For example, `NonSendMarker` is a similar dummy parameter that forces systems to run on the main thread. The `ExclusiveMarker` parameter is designed to be zero-cost at runtime - it's a unit struct with a phantom data field, and its `get_param` method returns the marker without performing any actual world access.

The implementation maintains safety by marking `ExclusiveMarker` with the appropriate unsafe traits. It implements `SystemParam` with minimal state (an empty tuple for `State`), and since it doesn't access any world data, it also safely implements `ReadOnlySystemParam`. The `init_access` method is where the actual marking happens, which occurs during system initialization before execution.

To verify the functionality, a test is added in `mod.rs` that demonstrates using `ExclusiveMarker` in a function system. The test creates a simple system that takes `ExclusiveMarker` as a parameter, initializes it, verifies that the system is marked as exclusive via `is_exclusive()`, and then runs the system to ensure it functions correctly.

One important note from the PR description is that this implementation doesn't provide a high-level API for marking systems as exclusive. Users must explicitly include `ExclusiveMarker` in their system function signatures. This is intentional - it follows Bevy's philosophy of making system constraints explicit in the type signature rather than relying on external configuration.

The author mentions concerns about how this interacts with the executor but notes that in theory it should work since the flag is the primary mechanism the executor uses to determine if a system is exclusive. This is correct - Bevy's scheduler already respects the `EXCLUSIVE` flag when determining system execution order and parallelism.

This change is relatively small but extends Bevy's ECS capabilities in a meaningful way. It provides a clean, type-safe mechanism for marking function systems as exclusive that integrates well with Bevy's existing system parameter infrastructure and follows established patterns in the codebase.

## Visual Representation

```mermaid
graph TD
    A[Function System Definition] --> B[Includes ExclusiveMarker parameter]
    B --> C[System initialization calls init_access]
    C --> D[SystemMeta.set_exclusive() called]
    D --> E[EXCLUSIVE flag set in SystemStateFlags]
    E --> F[Scheduler respects exclusive flag]
    F --> G[System runs exclusively]
```

## Key Files Changed

### `crates/bevy_ecs/src/system/function_system.rs` (+5/-0)
Added the `set_exclusive()` method to `SystemMeta` to allow setting the exclusive flag.

```rust
/// Mark the system to run exclusively. i.e. no other systems will run at the same time.
pub fn set_exclusive(&mut self) {
    self.flags |= SystemStateFlags::EXCLUSIVE;
}
```

This change provides the low-level API to mark a system as exclusive by setting the appropriate flag in the system's metadata.

### `crates/bevy_ecs/src/system/system_param.rs` (+34/-0)
Added the `ExclusiveMarker` system parameter type that allows function systems to be marked as exclusive.

```rust
/// A dummy type to tell the executor to run the system exclusively.
pub struct ExclusiveMarker(PhantomData<()>);

// SAFETY: No world access.
unsafe impl SystemParam for ExclusiveMarker {
    type State = ();
    type Item<'w, 's> = Self;

    #[inline]
    fn init_state(_world: &mut World) -> Self::State {}

    fn init_access(
        _state: &Self::State,
        system_meta: &mut SystemMeta,
        _component_access_set: &mut FilteredAccessSet,
        _world: &mut World,
    ) {
        system_meta.set_exclusive();
    }

    #[inline]
    unsafe fn get_param<'world, 'state>(
        _state: &'state mut Self::State,
        _system_meta: &SystemMeta,
        _world: UnsafeWorldCell<'world>,
        _change_tick: Tick,
    ) -> Self::Item<'world, 'state> {
        Self(PhantomData)
    }
}

// SAFETY: Does not read any world state
unsafe impl ReadOnlySystemParam for ExclusiveMarker {}
```

This is the core implementation that allows systems to self-identify as exclusive through their parameter list. The `init_access` method is the key hook that calls the newly added `set_exclusive()` method.

### `crates/bevy_ecs/src/system/mod.rs` (+20/-2)
Added a test to verify the exclusive system functionality works correctly.

```rust
#[test]
fn function_system_as_exclusive() {
    let mut world = World::default();

    world.insert_resource(SystemRan::No);

    fn sys(_marker: ExclusiveMarker, mut system_ran: ResMut<SystemRan>) {
        *system_ran = SystemRan::Yes;
    }

    let mut sys = IntoSystem::into_system(sys);
    sys.initialize(&mut world);
    assert!(sys.is_exclusive());

    run_system(&mut world, sys);
    assert_eq!(*world.resource::<SystemRan>(), SystemRan::Yes);
}
```

This test demonstrates the usage pattern: including `ExclusiveMarker` as a parameter marks the system as exclusive, and the system functions normally otherwise. The test also updated the import statements to include `ExclusiveMarker`.

## Further Reading

1. Bevy ECS System Execution: https://bevyengine.org/learn/book/ecs/system-execution/
2. Bevy System Parameters: https://bevyengine.org/learn/book/ecs/system-params/
3. Bevy Exclusive Systems Documentation: https://bevyengine.org/learn/book/ecs/exclusive-systems/
4. Rust PhantomData Pattern: https://doc.rust-lang.org/std/marker/struct.PhantomData.html
5. Bevy SystemParam Trait Documentation: https://docs.rs/bevy_ecs/latest/bevy_ecs/system/trait.SystemParam.html

# Full Code Diff
```diff
diff --git a/crates/bevy_ecs/src/system/function_system.rs b/crates/bevy_ecs/src/system/function_system.rs
index 5f6653be39834..4aeb704ecf9f2 100644
--- a/crates/bevy_ecs/src/system/function_system.rs
+++ b/crates/bevy_ecs/src/system/function_system.rs
@@ -105,6 +105,11 @@ impl SystemMeta {
     pub fn set_has_deferred(&mut self) {
         self.flags |= SystemStateFlags::DEFERRED;
     }
+
+    /// Mark the system to run exclusively. i.e. no other systems will run at the same time.
+    pub fn set_exclusive(&mut self) {
+        self.flags |= SystemStateFlags::EXCLUSIVE;
+    }
 }
 
 // TODO: Actually use this in FunctionSystem. We should probably only do this once Systems are constructed using a World reference
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index eeecf4b7ac5db..f729731ea327a 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -418,8 +418,8 @@ mod tests {
             SystemCondition,
         },
         system::{
-            Commands, In, InMut, IntoSystem, Local, NonSend, NonSendMut, ParamSet, Query, Res,
-            ResMut, Single, StaticSystemParam, System, SystemState,
+            Commands, ExclusiveMarker, In, InMut, IntoSystem, Local, NonSend, NonSendMut, ParamSet,
+            Query, Res, ResMut, Single, StaticSystemParam, System, SystemState,
         },
         world::{DeferredWorld, EntityMut, FromWorld, World},
     };
@@ -1049,6 +1049,24 @@ mod tests {
         assert_eq!(*world.resource::<SystemRan>(), SystemRan::Yes);
     }
 
+    #[test]
+    fn function_system_as_exclusive() {
+        let mut world = World::default();
+
+        world.insert_resource(SystemRan::No);
+
+        fn sys(_marker: ExclusiveMarker, mut system_ran: ResMut<SystemRan>) {
+            *system_ran = SystemRan::Yes;
+        }
+
+        let mut sys = IntoSystem::into_system(sys);
+        sys.initialize(&mut world);
+        assert!(sys.is_exclusive());
+
+        run_system(&mut world, sys);
+        assert_eq!(*world.resource::<SystemRan>(), SystemRan::Yes);
+    }
+
     #[test]
     fn removal_tracking() {
         let mut world = World::new();
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index 8e99259149b67..bc58aa7d85b94 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -1309,6 +1309,40 @@ unsafe impl<T: SystemBuffer> SystemParam for Deferred<'_, T> {
     }
 }
 
+/// A dummy type to tell the executor to run the system exclusively.
+pub struct ExclusiveMarker(PhantomData<()>);
+
+// SAFETY: No world access.
+unsafe impl SystemParam for ExclusiveMarker {
+    type State = ();
+    type Item<'w, 's> = Self;
+
+    #[inline]
+    fn init_state(_world: &mut World) -> Self::State {}
+
+    fn init_access(
+        _state: &Self::State,
+        system_meta: &mut SystemMeta,
+        _component_access_set: &mut FilteredAccessSet,
+        _world: &mut World,
+    ) {
+        system_meta.set_exclusive();
+    }
+
+    #[inline]
+    unsafe fn get_param<'world, 'state>(
+        _state: &'state mut Self::State,
+        _system_meta: &SystemMeta,
+        _world: UnsafeWorldCell<'world>,
+        _change_tick: Tick,
+    ) -> Self::Item<'world, 'state> {
+        Self(PhantomData)
+    }
+}
+
+// SAFETY: Does not read any world state
+unsafe impl ReadOnlySystemParam for ExclusiveMarker {}
+
 /// A dummy type that is [`!Send`](Send), to force systems to run on the main thread.
 pub struct NonSendMarker(PhantomData<*mut ()>);
```