+++
title = "#22165 Add name to pass span to make the error better"
date = "2025-12-17T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22165-en-20251217" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22165-zh-cn-20251217" }}
labels = ["A-Rendering", "C-Usability", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Add name to pass span to make the error better
- **PR Link**: https://github.com/bevyengine/bevy/pull/22165
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: A-Rendering, C-Usability, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2025-12-17T14:03:42Z
- **Merged**: 2025-12-17T19:12:15Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

- The error is very vague

## Solution

- Name is cow, so we can clone for free and pass it along to format in error.

## Testing

- i used this to debug #22164

## The Story of This Pull Request

The PR addresses a debugging issue within Bevy's rendering diagnostics system. When a `PassSpanGuard` is dropped without explicitly calling its `end()` method, the system panics to alert developers about an unclosed rendering pass span. However, the original panic message provided minimal context, making debugging difficult.

The problem manifests when tracking rendering passes in Bevy's diagnostic system. The `PassSpanGuard` struct implements the RAII pattern to measure the duration of rendering passes. When a pass scope isn't properly ended, the guard's `Drop` implementation triggers a panic. The previous error message simply stated `"PassSpanScope::end was never called"`, which lacked identifying information about which specific pass failed to close. This was particularly problematic when debugging complex rendering pipelines with multiple passes.

The solution leverages the existing pass name, which is already passed into the `pass_span()` method. The implementation stores a clone of the `Cow<'static, str>` name within the guard struct. Since `Cow` can cheaply clone borrowed strings (especially static string literals), this adds minimal overhead while significantly improving debuggability.

The key change is in the `pass_span()` method implementation, which now:
1. Takes ownership of the name by converting it into a `Cow`
2. Clones the name (cheap for static strings)
3. Stores the cloned name in the guard struct
4. Includes the name in the panic message when dropped prematurely

This approach maintains the existing API while enhancing the error reporting. The use of `Cow` ensures that for static string literals (common for pass names), no heap allocation occurs. The cloning is essentially free in those cases, making this a zero-cost improvement for typical usage.

The author mentions using this improvement to debug PR #22164, demonstrating the practical value of the change. Better error messages reduce debugging time and improve developer experience when working with Bevy's rendering diagnostics system.

## Visual Representation

```mermaid
graph TD
    A[pass_span() Method] --> B[Create PassSpanGuard]
    B --> C{PassSpanGuard Dropped}
    C -->|end() called| D[Record Timing]
    C -->|end() NOT called| E[Panic with Pass Name]
    
    subgraph "Key Data Flow"
        F[Pass Name: Cow<str>] --> A
        A --> G[Clone Name]
        G --> B
        B --> E
    end
```

## Key Files Changed

### `crates/bevy_render/src/diagnostic/mod.rs` (+5/-2)

**What changed and why**: The `PassSpanGuard` struct now stores the pass name to include it in panic messages when the guard is dropped without calling `end()`. This provides better debugging context.

**Code changes**:

```rust
// Before:
pub fn pass_span<P, N>(&self, pass: P, name: N) -> PassSpanGuard<'_, Self, P>
where
    P: Pass,
    N: Into<Cow<'static, str>>,
{
    self.begin_pass_span(pass, name.into());
    PassSpanGuard {
        recorder: self,
        marker: PhantomData,
    }
}

// In Drop implementation for PassSpanGuard:
fn drop(&mut self) {
    panic!("PassSpanScope::end was never called")
}
```

```rust
// After:
pub fn pass_span<P, N>(&self, pass: P, name: N) -> PassSpanGuard<'_, Self, P>
where
    P: Pass,
    N: Into<Cow<'static, str>>,
{
    let name = name.into();
    self.begin_pass_span(pass, name.clone());
    PassSpanGuard {
        recorder: self,
        name,  // Store the name in the guard
        marker: PhantomData,
    }
}

// In Drop implementation for PassSpanGuard:
fn drop(&mut self) {
    panic!("PassSpanGuard::end was never called for {}", self.name)
}
```

**Relation to PR purpose**: These changes directly implement the solution described - storing the pass name in the guard and including it in panic messages for better debugging.

## Further Reading

1. [Rust's Cow (Copy on Write) type](https://doc.rust-lang.org/std/borrow/enum.Cow.html) - Understanding how `Cow` enables cheap cloning
2. [RAII (Resource Acquisition Is Initialization) pattern](https://doc.rust-lang.org/rust-by-example/scope/raii.html) - The pattern used by `PassSpanGuard`
3. [Bevy's Render Graph documentation](https://github.com/bevyengine/bevy/blob/main/crates/bevy_render/src/render_graph/mod.rs) - For understanding how rendering passes work in Bevy
4. [Error handling best practices in Rust](https://doc.rust-lang.org/book/ch09-00-error-handling.html) - Context on providing meaningful error messages

# Full Code Diff

```
diff --git a/crates/bevy_render/src/diagnostic/mod.rs b/crates/bevy_render/src/diagnostic/mod.rs
index 885b343e86039..d2425d3e80b65 100644
--- a/crates/bevy_render/src/diagnostic/mod.rs
+++ b/crates/bevy_render/src/diagnostic/mod.rs
@@ -105,9 +105,11 @@ pub trait RecordDiagnostics: Send + Sync {
         P: Pass,
         N: Into<Cow<'static, str>>,
     {
-        self.begin_pass_span(pass, name.into());
+        let name = name.into();
+        self.begin_pass_span(pass, name.clone());
         PassSpanGuard {
             recorder: self,
+            name,
             marker: PhantomData,
         }
     }
@@ -152,6 +154,7 @@ impl<R: ?Sized, E> Drop for TimeSpanGuard<'_, R, E> {
 /// Will panic on drop unless [`PassSpanGuard::end`] is called.
 pub struct PassSpanGuard<'a, R: ?Sized, P> {
     recorder: &'a R,
+    name: Cow<'static, str>,
     marker: PhantomData<P>,
 }
 
@@ -165,7 +168,7 @@ impl<R: RecordDiagnostics + ?Sized, P: Pass> PassSpanGuard<'_, R, P> {
 
 impl<R: ?Sized, P> Drop for PassSpanGuard<'_, R, P> {
     fn drop(&mut self) {
-        panic!("PassSpanScope::end was never called")
+        panic!("PassSpanGuard::end was never called for {}", self.name)
     }
 }
 
```