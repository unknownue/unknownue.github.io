+++
title = "#21885 Prevent WebGL builds from crashing on startup when using FpsOverlayPlugin"
date = "2025-12-08T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-21885-en-20251208" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-21885-zh-cn-20251208" }}
labels = ["C-Bug", "A-Rendering", "O-WebGL2", "D-Straightforward", "S-Waiting-on-Author"]
+++

# Title: Prevent WebGL builds from crashing on startup when using FpsOverlayPlugin

## Basic Information
- **Title**: Prevent WebGL builds from crashing on startup when using FpsOverlayPlugin
- **PR Link**: https://github.com/bevyengine/bevy/pull/21885
- **Author**: it-me-joda
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, O-WebGL2, D-Straightforward, S-Waiting-on-Author
- **Created**: 2025-11-19T18:21:43Z
- **Merged**: 2025-12-08T12:19:16Z
- **Merged By**: mockersf

## 描述翻译

### 目标
- 修复 #21362
- FrameTimeGraph 使用的材质在 WebGL（而非 WebGPU）环境下会导致崩溃，即使 FrameTimeGraph 被禁用。我们需要在为 WASM 构建时阻止 FrameTimeGraph 被创建。

### 解决方案
- 如果构建目标是为仅支持 WebGL 的 WASM，我们跳过 FrameTimeGraph 的创建。此外，如果 FrameTimeGraph 被启用，我们会提供一个警告来告知用户 FrameTimeGraph 在 WebGL 上不受支持。

### 测试
- 我使用了问题报告中提供的复现方法。

## 这个PR的故事

这个PR解决了Bevy开发工具中一个直接影响WebGL平台稳定性的具体问题。用户报告称，在WebGL构建中启动游戏时，如果使用了 `FpsOverlayPlugin`，游戏会在启动时立即崩溃。值得注意的是，即使覆盖层配置中禁用了帧时间图（FrameTimeGraph），崩溃仍然会发生。

问题的根源在于 `FpsOverlayPlugin` 的初始化逻辑。在 `setup` 函数中，插件会无条件地为帧时间图创建一个 `FrametimeGraphMaterial` 材质。这个材质内部使用了 `ShaderStorageBuffer`，而 Shader Storage Buffer Object (SSBO) 在 WebGL 2.0 中是一个可选特性，并非所有环境都支持。因此，在仅支持WebGL的WASM构建中，尝试创建和使用此材质会导致WebGL上下文错误，进而引发崩溃。

从代码来看，之前的逻辑试图通过将UI节点的 `display` 属性设置为 `Display::None` 来处理禁用状态。然而，这只是在渲染时隐藏了节点，材质资源本身仍然被创建并添加到 `Assets<FrametimeGraphMaterial>` 集合中。材质的创建和其内部缓冲区的初始化，在WebGL环境下就已经触发了不支持的API调用。

解决方案采用了条件编译（`#[cfg(...)]`）来从根本上避免在不受支持的环境中创建问题资源。核心逻辑添加在 `crates/bevy_dev_tools/src/fps_overlay.rs` 文件的 `setup` 函数中。

首先，代码检查构建目标是否为 `wasm32` 且未启用 `webgpu` 特性（这大致等同于“仅WebGL”环境）。如果满足此条件且用户试图启用帧时间图，则通过 `tracing::warn!` 宏记录一条警告信息，告知用户该功能不受支持。

```rust
#[cfg(all(target_arch = "wasm32", not(feature = "webgpu")))]
{
    if overlay_config.frame_time_graph_config.enabled {
        use tracing::warn;
        warn!("Frame time graph is not supported with WebGL. Consider if WebGPU is viable for your usecase.");
    }
}
```

其次，通过另一个条件编译块 `#[cfg(not(all(target_arch = "wasm32", not(feature = "webgpu"))))]`，将原本创建帧时间图UI节点和材质的所有逻辑包裹起来。这意味着，在“非仅WebGL”的环境下（例如原生目标、或启用WebGPU的WASM目标），原有逻辑正常执行；而在“仅WebGL”的WASM环境下，整个创建代码块被编译器完全移除，确保了相关的材质和缓冲区资源不会被初始化。

这是一个直接且有效的修复策略。它没有尝试在运行时动态检测WebGL对SSBO的支持（这可能复杂且不可靠），而是利用了Rust编译时特性系统和条件编译的优点，将不兼容的代码路径在构建阶段就排除掉。

为了使条件编译能够正常工作，PR还对Cargo.toml文件进行了必要的修改。在 `bevy_dev_tools` 的 `Cargo.toml` 中，新增了 `webgl` 和 `webgpu` 两个特性，它们分别依赖于 `bevy_render` crate 的对应特性。这允许开发者在选择渲染后端时，将选择传递到开发工具中。

```toml
[features]
webgl = ["bevy_render/webgl"]
webgpu = ["bevy_render/webgpu"]
```

接着，在 `bevy_internal` 的 `Cargo.toml` 中，将新定义的 `bevy_dev_tools?/webgl` 和 `bevy_dev_tools?/webgpu` 依赖分别添加到全局的 `webgl` 和 `webgpu` 特性集合中。这样，当用户通过 `bevy` 的 `features = ["webgl"]` 进行构建时，这个特性会自动传递给 `bevy_dev_tools`，从而激活其内部的 `webgl` 特性，使得条件编译能够做出正确的判断。

这个修复的直接影响是，WebGL构建不会再因为 `FpsOverlayPlugin` 而崩溃。对于需要帧时间图功能的WebGL用户，他们现在会收到一个明确的警告，而不是一个令人困惑的崩溃。从工程角度看，这个PR展示了如何利用Rust的条件编译来优雅地处理平台特定的功能限制。它也强调了在涉及图形API的代码中，资源创建本身（而不仅仅是资源使用）就可能触发平台兼容性问题，需要在设计插件初始化逻辑时仔细考虑。

## 可视化表示

```mermaid
graph TD
    subgraph “构建配置”
        A[用户: cargo build --features webgl]
        B[用户: cargo build --features webgpu]
    end
    
    A --> C[bevy_internal/webgl 特性启用]
    B --> D[bevy_internal/webgpu 特性启用]
    
    C --> E[bevy_dev_tools/webgl 特性启用]
    D --> F[bevy_dev_tools/webgpu 特性启用]
    
    subgraph “条件编译路径”
        E --> G{是 wasm32 且非 webgpu?}
        F --> G
        
        G -->|是 仅WebGL| H[跳过创建 FrameTimeGraph]
        G -->|否| I[正常创建 FrameTimeGraph]
    end
```

## 关键文件变更

### 1. `crates/bevy_dev_tools/src/fps_overlay.rs` (+39/-28)
**变更描述及原因**：这是实现修复的核心文件。通过添加条件编译逻辑，在WebGL环境下阻止`FrameTimeGraph`及其关联材质的创建，从而避免使用不受支持的Shader Storage Buffer Object (SSBO)导致崩溃。

**关键代码修改**：
```rust
// 修改发生在 setup 函数内，原创建 FrameTimeGraph 的代码被条件编译块包裹。

// 新增：在仅WebGL环境下，如果用户启用了图形，则发出警告。
#[cfg(all(target_arch = "wasm32", not(feature = "webgpu")))]
{
    if overlay_config.frame_time_graph_config.enabled {
        use tracing::warn;
        warn!("Frame time graph is not supported with WebGL. Consider if WebGPU is viable for your usecase.");
    }
}
// 新增：仅在非仅WebGL环境下，才执行原有的创建逻辑。
#[cfg(not(all(target_arch = "wasm32", not(feature = "webgpu"))))]
{
    let font_size = overlay_config.text_config.font_size;
    p.spawn((
        Node {
            // ... 原有节点属性
        },
        Pickable::IGNORE,
        MaterialNode::from(frame_time_graph_materials.add(FrametimeGraphMaterial {
            values: buffers.add(ShaderStorageBuffer {
                // ... 原有缓冲区初始化
            }),
            config: FrameTimeGraphConfigUniform::new(...),
        })),
        FrameTimeGraph,
    ));
}
```
**与PR目标的关系**：这个修改直接实现了“阻止创建”的目标，通过编译器确保有问题的代码不会出现在WebGL构建产物中。

### 2. `crates/bevy_dev_tools/Cargo.toml` (+2/-0)
**变更描述及原因**：为`bevy_dev_tools` crate定义本地特性`webgl`和`webgpu`，使其能够感知并传播用户选择的渲染后端。

**关键代码修改**：
```toml
[features]
bevy_ci_testing = ["serde", "ron"]
webgl = ["bevy_render/webgl"]  # 新增行
webgpu = ["bevy_render/webgpu"]  # 新增行
```
**与PR目标的关系**：使`fps_overlay.rs`中的条件编译`#[cfg(not(feature = "webgpu"))]`能够正常工作，依赖`bevy_render`的对应特性来确定当前激活的后端。

### 3. `crates/bevy_internal/Cargo.toml` (+2/-0)
**变更描述及原因**：将`bevy_dev_tools`的新特性整合到`bevy`主crate的全局特性集合中，确保用户选择`bevy`的`webgl`或`webgpu`特性时，能正确传递到开发工具模块。

**关键代码修改**：
```toml
webgl = [
  # ... 其他依赖
  "bevy_dev_tools?/webgl",  # 新增行
]

webgpu = [
  # ... 其他依赖
  "bevy_dev_tools?/webgpu",  # 新增行
]
```
**与PR目标的关系**：确保了整个特性依赖链的完整性，使最终用户无需关心内部crate的细节，只需通过`bevy`的特性即可控制所有相关模块的行为。

## 延伸阅读

1.  **WebGL 2.0 规范与可选特性**：了解为什么SSBO在WebGL中是可选的，有助于理解此类平台兼容性问题的根本原因。可以查阅[WebGL 2.0 Specification](https://www.khronos.org/registry/webgl/specs/latest/2.0/)中关于可选扩展的部分。
2.  **Rust 条件编译 (`#[cfg]`)**：Rust官方文档中关于[条件编译](https://doc.rust-lang.org/reference/conditional-compilation.html)的章节，详细解释了如何基于目标平台、特性等条件来包含或排除代码。
3.  **Cargo 特性与特性传播**：Cargo手册中关于[特性](https://doc.rust-lang.org/cargo/reference/features.html)的部分，解释了如何定义特性、指定依赖关系以及特性如何在工作区中传递。这对于管理复杂项目的跨平台构建配置至关重要。
4.  **Bevy 渲染后端抽象**：可以通过Bevy的源码了解其如何抽象不同的渲染后端（如WebGL、WebGPU、Vulkan、DirectX等），以及插件如何适配这些后端。这有助于设计更具普适性的跨平台代码。