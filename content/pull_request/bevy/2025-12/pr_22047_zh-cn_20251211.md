+++
title = "#22047 UI per text section picking"
date = "2025-12-11T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22047-en-20251211" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22047-zh-cn-20251211" }}
+++

# Title

## 基本信息
- **标题**: UI per text section picking
- **PR链接**: https://github.com/bevyengine/bevy/pull/22047
- **作者**: ickshonpe
- **状态**: 已合并
- **标签**: C-Feature, A-UI, S-Ready-For-Final-Review, M-Migration-Guide, A-Text, M-Release-Note, D-Modest, A-Picking
- **创建时间**: 2025-12-06T20:20:52Z
- **合并时间**: 2025-12-11T02:16:28Z
- **合并者**: alice-i-cecile

## 描述翻译
该PR实现了UI文本的逐段（per-section）拾取功能。

### 目标
允许按文本段（text section）进行拾取。

修复 #17477

### 解决方案
在 `ui_picking` 中，当指针下方有包含文本组件的节点时，不再将 `Text` 节点的实体添加到 `hit_nodes` 列表中。相反，遍历其 `TextLayoutInfo` 组件中的文本段边界矩形列表，以查找指针悬停在哪个文本段上，并将该段的实体ID添加到 `hit_nodes` 列表中。

* 向 `NodeQuery` 添加可选的文本组件。
* 新的辅助函数 `pick_ui_text_section`。查找文本段是否被悬停并返回其ID。
* 当文本段被悬停时，将其实体添加到 `hit_nodes`。
* 将目标相机实体添加到 `hit_nodes`，而不是第二次查询它。
* 当被拾取的节点是文本节点且启用了 `require_markers` 时，检查命中的文本段实体是否具有 `Pickable` 组件，而不是检查文本节点。

这个设计未来可能需要更改以支持文本选择和复制。但目前似乎没有必要因此使事情复杂化。

### 测试
我在 `TextBackgroundColors` 示例的文本实体上添加了观察者（observers）。当指针悬停在文本段上时，观察者将该文本段的文本颜色变为白色。

```bash
cargo run --example text_background_colors
```

## 这个PR的故事

这个PR解决了一个关于UI文本拾取的具体问题。在Bevy 0.17及之前的版本中，整个Text节点作为一个统一的矩形区域响应指针事件（如悬停、点击）。这意味着即使指针仅悬停在文本节点内的空白区域，也会触发该节点的拾取事件。对于由多个文本段（Text Section）组成的富文本节点，开发者无法区分用户交互是针对哪个具体文本段的。问题 #17477 指出了这一限制。

解决方案的核心思路是将拾取粒度从整个Text节点细化到其内部的各个文本段。这需要利用现有的文本布局信息（`TextLayoutInfo`），该组件存储了每个文本段在节点局部坐标系中的边界矩形（bounds）。主要的修改集中在UI拾取后端（`ui_picking` 系统）的逻辑中。

首先，`NodeQuery` 被扩展以包含可选的 `TextLayoutInfo` 和 `ComputedTextBlock` 组件。这样，在遍历UI节点时，可以识别出哪些节点包含文本。

关键的改变发生在拾取检测循环内。当遇到一个包含文本组件的节点时，代码不再简单地检查指针是否在节点的整体边界矩形内，而是调用一个新的辅助函数 `pick_ui_text_section`。这个函数接收指针在节点局部空间中的坐标，并遍历 `TextLayoutInfo` 中所有文本段的几何信息（run_geometry），检查指针是否落在某个文本段的边界矩形内。如果找到匹配的文本段，就返回该文本段对应的实体（Entity）。这个实体来自于 `ComputedTextBlock`，它存储了每个文本段对应的实体映射。

如果找到了被悬停的文本段，代码会检查是否需要 `Pickable` 标记（`require_markers`），如果需要，则查询该文本段实体（而非文本节点实体）是否具有 `Pickable` 组件。通过检查后，文本段实体、相机实体以及局部坐标会被作为一个三元组 `(text_entity, camera_entity, position)` 添加到 `hit_nodes` 哈希表中。

这个改变带来了一个重要的行为变化：Text节点中文本内容之外的空白区域不再可拾取。这对于某些依赖于整个节点矩形区域交互的现有项目可能是一个突破性变更（breaking change）。因此，PR附带了迁移指南，建议如果需要恢复旧版行为，可以使用一个中间父节点来拦截指针事件。

性能方面，这个实现增加了对每个文本节点遍历其文本段列表的开销，但考虑到文本段数量通常有限，且拾取检测本身已涉及复杂的空间计算，这个额外开销应该是可接受的。同时，PR还进行了一项小的优化：将相机实体直接存储在 `hit_nodes` 中，避免了对每个悬停节点重复查询相机实体。

从架构角度看，这个修改保持了UI拾取系统的模块化。新增的 `pick_ui_text_section` 函数职责单一，且拾取逻辑的主体流程结构清晰。作者也明确指出，当前的实现是为后续更复杂的功能（如文本选择、复制）做准备，但现阶段避免了过度设计。

最后，为了演示新功能，PR修改了 `text_background_colors` 示例。为每个文本段实体添加了观察者（observers），当指针悬停（`Pointer<Over>`）或移出（`Pointer<Out>`）时，分别改变文本颜色。这直观地展示了每个文本段现在可以独立响应悬停事件。

总结来说，这个PR通过利用现有的文本布局数据，以相对较小的改动实现了细粒度的文本段拾取，提升了UI交互的精确性，并为未来的文本交互功能奠定了基础。

## 可视化关系图

```mermaid
graph TD
    A[Pointer Event] --> B[ui_picking System]
    B --> C{Node contains Text?}
    C -->|Yes| D[pick_ui_text_section Function]
    C -->|No| E[Standard Node Picking]
    D --> F[Iterate Text Section Bounds]
    F --> G{Found matching section?}
    G -->|Yes| H[Add Text Section Entity to hit_nodes]
    G -->|No| I[Skip (non-text area)]
    E --> J[Add Node Entity to hit_nodes]
    H --> K[Generate PointerHits]
    J --> K
    I --> K
```

## 关键文件变更

### 1. `crates/bevy_ui/src/picking_backend.rs` (+55/-15)
这是实现核心逻辑的文件。主要修改包括扩展 `NodeQuery` 以包含文本组件，修改 `hit_nodes` 的数据结构以存储文本段实体和相机实体，以及添加新的文本段拾取函数。

#### 关键修改：
```rust
// 修改后的 NodeQuery 结构，增加了 text_node 字段
pub struct NodeQuery {
    // ... 其他字段
    target_camera: &'static ComputedUiTargetCamera,
    text_node: Option<(&'static TextLayoutInfo, &'static ComputedTextBlock)>,
}

// hit_nodes 现在存储三元组 (实体, 相机实体, 局部坐标)
let mut hit_nodes = HashMap::<(Entity, PointerId), Vec<(Entity, Entity, Vec2)>>::default();

// 新增的文本段拾取辅助函数
fn pick_ui_text_section(
    uinode: &ComputedNode,
    global_transform: &UiGlobalTransform,
    point: Vec2,
    text_layout_info: &TextLayoutInfo,
    text_block: &ComputedTextBlock,
) -> Option<Entity> {
    // 将点转换到节点局部空间
    let local_point = global_transform
        .try_inverse()
        .map(|transform| transform.transform_point2(point) + 0.5 * uinode.size())?;

    // 遍历所有文本段几何信息，检查点是否在边界内
    for run in text_layout_info.run_geometry.iter() {
        if run.bounds.contains(local_point) {
            return text_block.entities().get(run.span_index).map(|e| e.entity);
        }
    }
    None
}
```

### 2. `examples/ui/text_background_colors.rs` (+24/-9)
这个示例文件被修改以演示新的文本段拾取功能。为每个生成的文本段实体添加了观察者，用于在悬停时改变文本颜色。

#### 关键修改：
```rust
// 为每个文本段 spawn 时添加观察者
commands
    .spawn((...)) // 文本段组件
    .observe(
        |event: On<Pointer<Over>>, mut query: Query<&mut TextColor>| {
            if let Ok(mut text_color) = query.get_mut(event.entity) {
                text_color.0 = Color::WHITE;
            }
        },
    )
    .observe(
        |event: On<Pointer<Out>>, mut query: Query<&mut TextColor>| {
            if let Ok(mut text_color) = query.get_mut(event.entity) {
                text_color.0 = Color::BLACK;
            }
        },
    );
```

### 3. `release-content/migration-guides/the_non-text_areas_of_text_nodes_are_no_longer_pickable.md` (+7/-0)
这是一个新的迁移指南文件，通知用户关于Text节点拾取行为的突破性变更。

#### 内容：
```markdown
---
title: "The non-text areas of UI `Text` nodes are no longer pickable"
pull_requests: [22047]
---

Only the sections of `Text` node's containing text are pickable now, the non-text areas of the node do not register pointer hits.
To replicate Bevy 0.17's picking behavior, use an intermediate parent node to intercept the pointer hits.
```

### 4. `release-content/release-notes/per_text_section_picking.md` (+7/-0)
这是一个新的发布说明文件，记录了这个新功能。

#### 内容：
```markdown
---
title: "UI per text section picking"
authors: ["@ickshonpe"]
pull_requests: [22047]
---

Individual text sections belonging to UI text nodes are now pickable and can be given observers.
```

## 进一步阅读

1. **Bevy UI Picking 文档**: 了解UI拾取系统的基础工作原理。
2. **Bevy Observers 系统**: 学习如何使用观察者（observers）响应事件，这是示例中使用的模式。
3. **Bevy Text 模块**: 深入了解 `TextLayoutInfo`、`ComputedTextBlock` 等文本组件的结构和用途。
4. **问题 #17477**: 查看引发此PR的原始问题和相关讨论。