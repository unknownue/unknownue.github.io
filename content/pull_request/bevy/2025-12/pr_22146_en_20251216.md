+++
title = "#22146 Suppress Warnings for unused code in bevy_gizmos_render"
date = "2025-12-16T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22146-en-20251216" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22146-zh-cn-20251216" }}
labels = ["D-Trivial", "C-Code-Quality", "A-Gizmos"]
+++

# Title: Suppress Warnings for unused code in bevy_gizmos_render

## Basic Information
- **Title**: Suppress Warnings for unused code in bevy_gizmos_render
- **PR Link**: https://github.com/bevyengine/bevy/pull/22146
- **Author**: kfc35
- **Status**: MERGED
- **Labels**: D-Trivial, C-Code-Quality, S-Ready-For-Final-Review, A-Gizmos
- **Created**: 2025-12-16T02:26:33Z
- **Merged**: 2025-12-16T05:17:50Z
- **Merged By**: alice-i-cecile

## Description Translation

# Objective

- Fixes #22137 

## Solution

Add `expect`'s to suppress the warnings generated after running `cargo build -p bevy_gizmos_render`. All of the warnings stem from fields/structs/functions that go unused if neither the `bevy_pbr` or `bevy_sprite_render` features are on (they are only used if either the plugin in `pipeline_2d` or `pipeline_3d` are added), so the expects are gated to that particular circumstance.

## Testing

- Did you test these changes? If so, how?
Running `cargo build -p bevy_gizmos_render` emits no warnings
Running `cargo clippy` emits no warnings

## The Story of This Pull Request

This PR addresses a straightforward but important code quality issue: eliminating compiler warnings when building the `bevy_gizmos_render` crate with certain feature configurations. The problem emerged when building without either the `bevy_pbr` or `bevy_sprite_render` features enabled. In this configuration, several structs, functions, and variables become unused, triggering Rust's standard dead code and unused variable warnings.

The developer faced a common problem in feature-gated codebases: code that's conditionally compiled based on features can appear unused when those features are disabled. While the code is technically correct and will be used when the appropriate features are enabled, the compiler sees it as dead code in the current configuration. This creates noise in build outputs and can obscure legitimate warnings.

The solution approach is methodical and precise. Instead of using `#[allow(...)]` attributes, which would suppress warnings unconditionally, the developer used `#[expect(...)]` attributes gated with `#[cfg_attr(...)]`. This approach has several advantages: it only suppresses warnings when the specific conditions are met (both `bevy_pbr` and `bevy_sprite_render` features disabled), and it uses `expect` rather than `allow`, which is the newer, more intentional way to handle expected warnings in Rust.

The implementation shows careful attention to detail. The developer didn't just blanket-allow all warnings; they analyzed each warning source and applied targeted suppressions. The pattern used throughout is:

```rust
#[cfg_attr(
    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
    expect(
        dead_code,
        reason = "struct is not constructed when bevy_pbr and bevy_sprite_render are both disabled."
    )
)]
```

This configuration attribute applies the `expect` attribute only when neither feature is enabled. The reason strings provide clear documentation about why the code appears unused in this configuration.

Looking at the specific changes, we can see they fall into three categories:

1. **Unused variable warnings**: In `extract_gizmo_data()` and `extract_linegizmos()`, the `handle` and `render_layers` variables are only used when the render pipelines are available. When features are disabled, these variables are still declared but never used.

2. **Dead code warnings**: Several structs like `GpuLineGizmo`, `LineGizmoUniformBindgroup`, `SetLineGizmoBindGroup`, `DrawLineGizmo`, and `DrawLineJointGizmo` are only constructed when the render pipelines exist. Without those features, the struct definitions exist but are never instantiated.

3. **Unused function warnings**: The `line_gizmo_vertex_buffer_layouts()` and `line_joint_gizmo_vertex_buffer_layouts()` functions are only called from code that's feature-gated.

The technical insight here is understanding how Bevy's renderer is modularized. The `bevy_gizmos_render` crate provides rendering infrastructure for gizmos, but it can work with either the 3D PBR pipeline (`bevy_pbr`) or the 2D sprite pipeline (`bevy_sprite_render`). When neither is enabled, the rendering code has nothing to hook into, so much of it becomes dead code. However, the code needs to remain present for when either feature is enabled.

The impact of these changes is purely about code quality and developer experience. By eliminating false positive warnings, developers get cleaner build outputs. This makes it easier to spot legitimate warnings and maintains a professional standard for the codebase. The use of `expect` with clear reasoning also serves as documentation, explaining to future maintainers why certain code might appear unused.

From an engineering perspective, this PR demonstrates good practices for handling feature-gated code in Rust:
- Using `expect` over `allow` for intentional warning suppression
- Gating suppressions with precise conditions
- Providing clear reason strings
- Addressing warnings individually rather than with blanket suppressions

## Visual Representation

```mermaid
graph TD
    A[bevy_gizmos_render crate] --> B{Features enabled?}
    B -->|bevy_pbr or bevy_sprite_render| C[Rendering code used]
    B -->|Neither feature| D[Rendering code unused]
    D --> E[Compiler warnings]
    E --> F[PR adds #[expect] attributes]
    F --> G[Clean builds]
    
    subgraph "Feature-gated Structures"
        H[GpuLineGizmo]
        I[LineGizmoUniformBindgroup]
        J[SetLineGizmoBindGroup]
        K[DrawLineGizmo]
        L[DrawLineJointGizmo]
    end
    
    subgraph "Feature-gated Functions"
        M[line_gizmo_vertex_buffer_layouts]
        N[line_joint_gizmo_vertex_buffer_layouts]
    end
    
    subgraph "Conditionally Used Variables"
        O[handle in extract_gizmo_data]
        P[render_layers in extract_linegizmos]
    end
    
    H --> D
    I --> D
    J --> D
    K --> D
    L --> D
    M --> D
    N --> D
    O --> D
    P --> D
```

## Key Files Changed

### `crates/bevy_gizmos_render/src/lib.rs` (+58/-1)

This file contains the main rendering logic for gizmos. The changes add `#[cfg_attr]` with `#[expect]` attributes to suppress warnings for code that's only used when either `bevy_pbr` or `bevy_sprite_render` features are enabled.

Key modifications:
1. **Line 147-156**: Added conditional expectation for unused variable warning on `handle` in `extract_gizmo_data()` function.

```rust
#[cfg_attr(
    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
    expect(
        unused_variables,
        reason = "`handle` is unused when bevy_pbr and bevy_sprite_render are both disabled."
    )
)]
let Some(handle) = handle
else {
    continue;
};
```

2. **Line 223-229**: Added conditional expectation for dead code warning on `GpuLineGizmo` struct.

3. **Line 290-296**: Added conditional expectation for dead code warning on `LineGizmoUniformBindgroup` struct.

4. **Line 320-326**: Added conditional expectation for dead code warning on `SetLineGizmoBindGroup` struct.

5. **Line 354-360**: Added conditional expectation for dead code warning on `DrawLineGizmo` struct.

6. **Line 420-426**: Added conditional expectation for dead code warning on `DrawLineJointGizmo` struct.

7. **Line 498-504**: Added conditional expectation for dead code warning on `line_gizmo_vertex_buffer_layouts()` function.

8. **Line 559-565**: Added conditional expectation for dead code warning on `line_joint_gizmo_vertex_buffer_layouts()` function.

### `crates/bevy_gizmos_render/src/retained.rs` (+7/-0)

This file handles retained mode gizmo rendering. The change adds a conditional expectation for an unused variable warning.

Key modification:
1. **Line 25-33**: Added conditional expectation for unused variable warning on `render_layers` in `extract_linegizmos()` function.

```rust
#[cfg_attr(
    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
    expect(
        unused_variables,
        reason = "`render_layers` is unused when bevy_pbr and bevy_sprite_render are both disabled."
    )
)]
for (entity, gizmo, transform, render_layers) in &query {
```

## Further Reading

1. **Rust's `#[expect]` attribute**: [The Rust Reference - Attributes](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-expect-attribute)
2. **Conditional compilation in Rust**: [The Rust Reference - Conditional Compilation](https://doc.rust-lang.org/reference/conditional-compilation.html)
3. **Bevy's feature system**: [Bevy's Cargo Features documentation](https://github.com/bevyengine/bevy/blob/main/docs/plugins_guidelines.md#cargo-features)
4. **Rust's lint system**: [Rustc Book - Lints](https://doc.rust-lang.org/rustc/lints/index.html)
5. **Bevy's renderer architecture**: [Bevy's rendering documentation](https://bevy-cheatbook.github.io/programming/rendering.html)

## Full Code Diff

```
diff --git a/crates/bevy_gizmos_render/src/lib.rs b/crates/bevy_gizmos_render/src/lib.rs
index 42e73e9192c00..c69977e115828 100755
--- a/crates/bevy_gizmos_render/src/lib.rs
+++ b/crates/bevy_gizmos_render/src/lib.rs
@@ -147,7 +147,15 @@ fn extract_gizmo_data(
             continue;
         }
 
-        let Some(handle) = handle else {
+        #[cfg_attr(
+            not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+            expect(
+                unused_variables,
+                reason = "`handle` is unused when bevy_pbr and bevy_sprite_render are both disabled."
+            )
+        )]
+        let Some(handle) = handle
+        else {
             continue;
         };
 
@@ -215,6 +223,13 @@ struct LineGizmoUniform {
     _padding: bevy_math::Vec3,
 }
 
+#[cfg_attr(
+    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+    expect(
+        dead_code,
+        reason = "fields are unused when bevy_pbr and bevy_sprite_render are both disabled."
+    )
+)]
 #[derive(Debug, Clone)]
 struct GpuLineGizmo {
     list_position_buffer: Buffer,
@@ -275,6 +290,13 @@ struct LineGizmoUniformBindgroupLayout {
     layout: BindGroupLayoutDescriptor,
 }
 
+#[cfg_attr(
+    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+    expect(
+        dead_code,
+        reason = "fields are unused when bevy_pbr and bevy_sprite_render are both disabled."
+    )
+)]
 #[derive(Resource)]
 struct LineGizmoUniformBindgroup {
     bindgroup: BindGroup,
@@ -298,6 +320,13 @@ fn prepare_line_gizmo_bind_group(
     }
 }
 
+#[cfg_attr(
+    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+    expect(
+        dead_code,
+        reason = "struct is not constructed when bevy_pbr and bevy_sprite_render are both disabled."
+    )
+)]
 struct SetLineGizmoBindGroup<const I: usize>;
 
 impl<const I: usize, P: PhaseItem> RenderCommand<P> for SetLineGizmoBindGroup<I> {
@@ -325,6 +354,13 @@ impl<const I: usize, P: PhaseItem> RenderCommand<P> for SetLineGizmoBindGroup<I>
     }
 }
 
+#[cfg_attr(
+    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+    expect(
+        dead_code,
+        reason = "struct is not constructed when bevy_pbr and bevy_sprite_render are both disabled."
+    )
+)]
 struct DrawLineGizmo<const STRIP: bool>;
 
 impl<P: PhaseItem, const STRIP: bool> RenderCommand<P> for DrawLineGizmo<STRIP> {
@@ -384,6 +420,13 @@ impl<P: PhaseItem, const STRIP: bool> RenderCommand<P> for DrawLineGizmo<STRIP>
     }
 }
 
+#[cfg_attr(
+    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+    expect(
+        dead_code,
+        reason = "struct is not constructed when bevy_pbr and bevy_sprite_render are both disabled."
+    )
+)]
 struct DrawLineJointGizmo;
 
 impl<P: PhaseItem> RenderCommand<P> for DrawLineJointGizmo {
@@ -455,6 +498,13 @@ impl<P: PhaseItem> RenderCommand<P> for DrawLineJointGizmo {
     }
 }
 
+#[cfg_attr(
+    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+    expect(
+        dead_code,
+        reason = "function is unused when bevy_pbr and bevy_sprite_render are both disabled."
+    )
+)]
 fn line_gizmo_vertex_buffer_layouts(strip: bool) -> Vec<VertexBufferLayout> {
     use VertexFormat::*;
     let mut position_layout = VertexBufferLayout {
@@ -509,6 +559,13 @@ fn line_gizmo_vertex_buffer_layouts(strip: bool) -> Vec<VertexBufferLayout> {
     }
 }
 
+#[cfg_attr(
+    not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+    expect(
+        dead_code,
+        reason = "function is unused when bevy_pbr and bevy_sprite_render are both disabled."
+    )
+)]
 fn line_joint_gizmo_vertex_buffer_layouts() -> Vec<VertexBufferLayout> {
     use VertexFormat::*;
     let mut position_layout = VertexBufferLayout {
diff --git a/crates/bevy_gizmos_render/src/retained.rs b/crates/bevy_gizmos_render/src/retained.rs
index d31746a931860..d9130fb69dc72 100644
--- a/crates/bevy_gizmos_render/src/retained.rs
+++ b/crates/bevy_gizmos_render/src/retained.rs
@@ -25,6 +25,13 @@ pub(crate) fn extract_linegizmos(
     query: Extract<Query<(Entity, &Gizmo, &GlobalTransform, Option<&RenderLayers>)>>,
 ) {
     let mut values = Vec::with_capacity(*previous_len);
+    #[cfg_attr(
+        not(any(feature = "bevy_pbr", feature = "bevy_sprite_render")),
+        expect(
+            unused_variables,
+            reason = "`render_layers` is unused when bevy_pbr and bevy_sprite_render are both disabled."
+        )
+    )]
     for (entity, gizmo, transform, render_layers) in &query {
         let joints_resolution = if let GizmoLineJoint::Round(resolution) = gizmo.line_config.joints
         {
```