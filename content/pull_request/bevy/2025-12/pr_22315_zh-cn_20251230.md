+++
title = "#22315 Small code size improvement"
date = "2025-12-30T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22315-en-20251230" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22315-zh-cn-20251230" }}
+++

# Title

## 基本信息
- **标题**: Small code size improvement
- **PR链接**: https://github.com/bevyengine/bevy/pull/22315
- **作者**: goodartistscopy
- **状态**: 已合并
- **标签**: C-Performance, A-Picking
- **创建时间**: 2025-12-30T12:38:18Z
- **合并时间**: 2025-12-30T19:34:55Z
- **合并人**: james7132

## 描述翻译
### 目标
- 略微改进代码大小

### 解决方案
- `ray_mesh_intersection<T>()` 的无索引版本不关心索引类型，任何 `TryInto<usize>` 的类型都可以。
- 通过避免在现有版本可用时再单态化另一个 `ray_mesh_intersection<T>` 版本（使用 `T=usize`），我们可以在代码大小（以及推测的编译时间）上获得小幅改进。

### 测试
- 构建了 `mesh_ray_cast` 示例，其按预期工作。

---
收益确实很小（在开发构建中为 0.8kB，在发布构建中为 3kB，在大小优化构建中为噪声（4B））。

### 展示
使用 `cargo bloat` 来可视化差异。开发配置文件确认生成的函数实例减少了一个：
```sh
> # 之前 (dev)
> cargo bloat --filter "ray_mesh_intersection$" --example mesh_ray_cast
File .text   Size        Crate Name
0.0%  0.0%   856B bevy_picking bevy_picking::mesh_picking::ray_cast::intersections::ray_mesh_intersection
0.0%  0.0%   856B bevy_picking bevy_picking::mesh_picking::ray_cast::intersections::ray_mesh_intersection
0.0%  0.0%   856B bevy_picking bevy_picking::mesh_picking::ray_cast::intersections::ray_mesh_intersection
0.0%  0.0% 2.5KiB              filtered data size, the file size is 263.3MiB

> # 之后 (dev)
> cargo bloat --filter "ray_mesh_intersection$" --example mesh_ray_cast
File .text Size        Crate Name
0.0%  0.0%   856B bevy_picking bevy_picking::mesh_picking::ray_cast::intersections::ray_mesh_intersection
0.0%  0.0%   856B bevy_picking bevy_picking::mesh_picking::ray_cast::intersections::ray_mesh_intersection
0.0%  0.0% 1.7KiB              filtered data size, the file size is 263.3MiB
```

在发布版本中，该函数被内联到 `ray_intersection_over_mesh()` 中，后者减小了 3kB：
```sh
> # 之前 (release)
> cargo bloat --release --filter "ray_intersection_over_mesh$" --example mesh_ray_cast
File .text   Size        Crate Name
0.0%  0.0% 5.3KiB bevy_picking bevy_picking::mesh_picking::ray_cast::intersections::ray_intersection_over_mesh
0.0%  0.0% 5.3KiB              filtered data size, the file size is 100.7MiB

> # 之后 (release)
> cargo bloat --release --filter "ray_intersection_over_mesh$" --example mesh_ray_cast
File .text   Size        Crate Name
0.0%  0.0% 2.3KiB bevy_picking bevy_picking::mesh_picking::ray_cast::intersections::ray_intersection_over_mesh
0.0%  0.0% 2.3KiB              filtered data size, the file size is 100.7MiB
```

## 本次 Pull Request 的故事

本次 PR 源于一个观察：在 Bevy 引擎的网格拾取（mesh picking）系统中，存在一个不必要的泛型（generic）函数单态化（monomorphization），这导致了编译后二进制文件体积的轻微增加。

问题出现在 `ray_intersection_over_mesh` 函数中，该函数负责根据网格索引类型调度到不同的 `ray_mesh_intersection` 实现。具体来说，当网格没有索引（`Indices::None`）时，代码原本显式地使用 `ray_mesh_intersection::<usize>`。而同时，对于 `Indices::U32` 的情况，代码调用的是 `ray_mesh_intersection` 并传入 `u32` 类型的切片。`ray_mesh_intersection` 是一个泛型函数，其泛型参数 `T` 代表索引类型。在 Rust 的编译模型中，泛型函数会为每个实际使用的具体类型生成一个独立的机器代码副本，这个过程称为单态化。

开发者 `goodartistscopy` 注意到，`ray_mesh_intersection` 函数的实现并不直接操作原始类型 `T`，而是通过 `TryInto<usize>` trait bound 将索引转换为 `usize` 再进行计算。这意味着，对于函数的核心逻辑而言，任何能够成功转换为 `usize` 的类型 `T` 都是等效的。因此，之前分别为 `usize` 和 `u32` 生成两个单态化版本是冗余的。

解决方案非常直接：统一使用同一种具体的类型参数来调用泛型函数，从而让编译器只生成一个代码副本。开发者将无索引情况下的调用从 `ray_mesh_intersection::<usize>` 改为了 `ray_mesh_intersection::<u32>`。这样，无论网格是否有 `u32` 索引，还是根本没有索引，最终都使用 `T=u32` 这一种单态化实例。`u32` 类型本身就实现了 `TryInto<usize>`，因此完全满足函数的要求。

从技术实现来看，这行修改（见下方 Key Files Changed 部分）虽然微小，但其背后的逻辑体现了对 Rust 编译特性和性能优化的深入理解。通过避免不必要的代码重复，达到了减少最终二进制体积的目的。`cargo bloat` 工具的输出数据证实了优化的效果：在开发构建（dev profile）中，`ray_mesh_intersection` 函数的实例数量从 3 个减少到 2 个，过滤后的数据大小减少了 0.8KB。在发布构建（release profile）中，由于编译器积极的优化和内联，这种减少体现在了调用方函数 `ray_intersection_over_mesh` 上，其大小从 5.3KB 显著下降到了 2.3KB，节省了 3KB。

这次改动是一个典型的“微优化”（micro-optimization），它不改变任何运行时逻辑或API，纯粹通过更高效地利用语言特性来改善编译结果。它提醒我们，在编写泛型代码时，需要考虑单态化带来的代码膨胀成本，并尽可能通过统一类型参数或使用动态分发（dynamic dispatch）来规避不必要的膨胀，尤其是在性能敏感或对二进制大小有严格要求的场景中。

## 视觉表示

```mermaid
graph TD
    subgraph “优化前 (Before)”
        A[ray_intersection_over_mesh] --> B{匹配 Indices}
        B -- “Indices::U32” --> C[“调用 ray_mesh_intersection (T=u32)”]
        B -- “Indices::None” --> D[“调用 ray_mesh_intersection (T=usize)”]
        C --> E[“生成两份单态化代码”]
        D --> E
    end

    subgraph “优化后 (After)”
        F[ray_intersection_over_mesh] --> G{匹配 Indices}
        G -- “Indices::U32” --> H[“调用 ray_mesh_intersection (T=u32)”]
        G -- “Indices::None” --> I[“调用 ray_mesh_intersection (T=u32)”]
        H --> J[“仅生成一份单态化代码”]
        I --> J
    end

    style E fill:#f9f,stroke:#333
    style J fill:#bbf,stroke:#333
```

## 关键文件更改

- `crates/bevy_picking/src/mesh_picking/ray_cast/intersections.rs` (+1/-1)

1.  **描述与原因**：此文件包含网格与射线相交检测的核心逻辑。修改了 `ray_intersection_over_mesh` 函数，使其在没有网格索引（`None`）的情况下，使用 `u32` 而非 `usize` 作为泛型参数来调用 `ray_mesh_intersection`。原因是 `ray_mesh_intersection` 内部仅要求索引类型可转换为 `usize`（通过 `TryInto<usize>`），统一使用 `u32` 可以避免编译器为 `usize` 生成一个冗余的函数单态化实例，从而减小二进制大小。

2.  **代码片段**：
    ```rust
    // File: crates/bevy_picking/src/mesh_picking/ray_cast/intersections.rs
    // Before:
    None => ray_mesh_intersection::<usize>(ray, transform, positions, normals, None, uvs, cull),

    // After:
    None => ray_mesh_intersection::<u32>(ray, transform, positions, normals, None, uvs, cull),
    ```

3.  **与 PR 目标的关联**：这行修改直接实现了 PR 的目标——通过减少一次不必要的泛型函数单态化来小幅改进（优化）生成的代码大小。

## 进一步阅读

1.  **Rust 官方文档 - 泛型**：了解 Rust 中泛型（generics）和 trait bound 的基本概念。
2.  **Rust 性能手册 - 单态化**：深入理解 Rust 中泛型代码在编译时如何通过单态化（monomorphization）生成具体代码，及其对性能（包括编译时间和二进制大小）的影响。
3.  **`cargo-bloat` 工具**：学习如何使用这个工具来分析 Rust 编译产物中各个部分所占的空间，是进行二进制大小优化的必备工具。
4.  **Bevy 拾取系统**：查阅 Bevy 官方文档中关于拾取（Picking）系统的部分，了解 `ray_mesh_intersection` 函数在引擎交互系统中的作用。