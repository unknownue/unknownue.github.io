+++
title = "#22177 add features in bevy_input_focus matching bevy_input"
date = "2025-12-18T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22177-en-20251218" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22177-zh-cn-20251218" }}
+++

# Title
add features in bevy_input_focus matching bevy_input

## Basic Information
- **标题**: add features in bevy_input_focus matching bevy_input
- **PR链接**: https://github.com/bevyengine/bevy/pull/22177
- **作者**: mockersf
- **状态**: MERGED
- **标签**: A-Input, S-Ready-For-Final-Review, D-Straightforward
- **创建时间**: 2025-12-17T22:47:25Z
- **合并时间**: 2025-12-18T19:11:19Z
- **合并者**: alice-i-cecile

## Description Translation

# 目标

- #21447 在 bevy_input 中为输入源设置了特性门控，但在 bevy_input_focus 中没有。
- #22167 无条件启用了其中一些特性，并且遗漏了 `mouse`。

## 解决方案

- 添加特性，并在 crate 之间转发它们。

## The Story of This Pull Request

这个PR解决了一个因项目结构变动和代码库同步不及时而产生的依赖管理问题。

**问题与背景**：Bevy引擎采用了模块化的crate结构，并通过Cargo的特性（feature flags）来控制编译时包含的功能。PR #21447引入了一个重要的优化：为`bevy_input` crate中的不同输入源（如键盘、鼠标、游戏手柄）添加了独立的特性门控。这意味着开发者可以选择性地启用他们需要的输入模块，从而减少不必要的代码编译，缩短编译时间并减小最终二进制文件的大小。然而，这个改动只应用在了`bevy_input`本身。在代码库中，另一个负责处理输入焦点（即哪个窗口或UI元素接收输入）的crate——`bevy_input_focus`——重度依赖于`bevy_input`的功能。它仍然无条件地导入了键盘、鼠标和游戏手柄相关的模块，并注册了对应的处理系统。这导致了一个不一致的状态：即使用户在`bevy_input`中禁用了某个输入源（例如鼠标），由于`bevy_input_focus`的硬性依赖，相关的类型和逻辑仍然会被编译进程序。

随后，PR #22167尝试修复这个问题，但方法不正确，它选择无条件地启用`keyboard`和`gamepad`特性，却漏掉了`mouse`。这没有从根本上解决问题，只是把部分依赖从有条件变成了无条件，并且留下了不一致的缺口。

**解决方案与实现**：正确的解决方案是让`bevy_input_focus`也支持相同的特性门控，并将这些特性的启用决定权向上传递给根crate（`bevy_internal`），保持整个项目配置的一致性。

具体的实现分为三个步骤，清晰地体现在三个文件的修改中。

第一步是在`bevy_input_focus/Cargo.toml`中定义自己的特性，并正确转发给它的依赖项`bevy_input`。这是Cargo中特性转发的标准模式。

```toml
# crates/bevy_input_focus/Cargo.toml
# 修改前
[features]
default = ["std", "bevy_reflect", "bevy_ecs/async_executor"]
# 依赖声明中直接指定了features
bevy_input = { path = "../bevy_input", version = "0.18.0-dev", default-features = false, features = [
  "keyboard",
  "gamepad",
] }

# 修改后
[features]
default = [
  "std",
  "bevy_reflect",
  "bevy_ecs/async_executor",
  "gamepad",
  "keyboard",
  "mouse",
]
# 定义新特性，并转发给bevy_input的同名特性
gamepad = ["bevy_input/gamepad"]
keyboard = ["bevy_input/keyboard"]
mouse = ["bevy_input/mouse"]
# 依赖声明中不再硬编码特性，由上层特性控制
bevy_input = { path = "../bevy_input", version = "0.18.0-dev", default-features = false }
```

第二步是在`bevy_input_focus/src/lib.rs`的代码逻辑中，使用`#[cfg(feature = "...")]`属性来条件编译相关的导入和系统注册。这是Rust条件编译的核心机制，确保只有当对应的特性被启用时，相关的代码块才会被编译。

```rust
// crates/bevy_input_focus/src/lib.rs
// 修改前
use bevy_input::{gamepad::GamepadButtonChangedEvent, keyboard::KeyboardInput, mouse::MouseWheel};
// ...
    .add_systems(
        PreUpdate,
        (
            dispatch_focused_input::<KeyboardInput>,
            dispatch_focused_input::<GamepadButtonChangedEvent>,
            dispatch_focused_input::<MouseWheel>,
        )
            .in_set(InputFocusSystems::Dispatch),
    )

// 修改后
#[cfg(feature = "gamepad")]
use bevy_input::gamepad::GamepadButtonChangedEvent;
#[cfg(feature = "keyboard")]
use bevy_input::keyboard::KeyboardInput;
#[cfg(feature = "mouse")]
use bevy_input::mouse::MouseWheel;
// ...
    .add_systems(
        PreUpdate,
        (
            #[cfg(feature = "keyboard")]
            dispatch_focused_input::<KeyboardInput>,
            #[cfg(feature = "gamepad")]
            dispatch_focused_input::<GamepadButtonChangedEvent>,
            #[cfg(feature = "mouse")]
            dispatch_focused_input::<MouseWheel>,
        )
            .in_set(InputFocusSystems::Dispatch),
    )
```

第三步是在根crate `bevy_internal`中，将其定义的特性（如`mouse`、`keyboard`、`gamepad`）转发给`bevy_input_focus`。这一步至关重要，它确保了用户在主`Cargo.toml`中启用一个特性（如`features = ["mouse"]`）时，这个启用状态能正确传递到`bevy_input_focus`，进而传递到`bevy_input`。修改中使用了`bevy_input_focus?`语法，`?`表示这是一个可选依赖，只有在`bevy_input_focus`被启用时才转发特性，这是一种更稳健的写法。

```toml
# crates/bevy_internal/Cargo.toml
# 修改前
mouse = ["bevy_input/mouse"]
keyboard = ["bevy_input/keyboard"]
gamepad = ["bevy_input/gamepad"]

# 修改后
mouse = ["bevy_input/mouse", "bevy_input_focus?/mouse"]
keyboard = ["bevy_input/keyboard", "bevy_input_focus?/keyboard"]
gamepad = ["bevy_input/gamepad", "bevy_input_focus?/gamepad"]
```

**技术洞察与影响**：这个PR展示了在Rust中使用特性进行条件编译和依赖管理的一个最佳实践模式。通过“特性转发”，项目可以将编译时配置的选择权层层上推，最终由应用开发者决定。这带来了几个直接的好处：首先，它消除了不必要的代码编译，提升了构建速度。其次，它使得最终产出的二进制文件更精简，对于目标平台资源有限（如Web或嵌入式环境）的场景尤其有价值。最后，它提高了代码的清晰度和模块化程度，因为每个模块的功能边界通过特性定义得更加明确。

从工程协作的角度看，这个PR也提醒我们，在修改一个被多个下游crate依赖的核心crate时，需要仔细检查依赖链，确保变更在整个生态中保持一致。这次修正虽然改动点不多，但确保了Bevy输入系统特性门控设计的完整性和可用性。

## Visual Representation

```mermaid
graph TD
    subgraph “User's Cargo.toml”
        B[bevy_internal]
    end

    subgraph “Internal Crates”
        B -->|forwards features| C[bevy_input_focus]
        C -->|forwards features| D[bevy_input]
    end

    subgraph “Conditional Compilation”
        D -->|feature=”keyboard”| K[keyboard module]
        D -->|feature=”mouse”| M[mouse module]
        D -->|feature=”gamepad”| G[gamepad module]
        
        C -->|cfg(feature=”keyboard”)| CK[Uses KeyboardInput]
        C -->|cfg(feature=”mouse”)| CM[Uses MouseWheel]
        C -->|cfg(feature=”gamepad”)| CG[Uses GamepadButton]
    end
```

## Key Files Changed

1.  **`crates/bevy_input_focus/Cargo.toml`** (+12/-5)
    - **描述**：此文件是`bevy_input_focus` crate的清单文件。修改为其添加了与`bevy_input`对应的`keyboard`、`mouse`、`gamepad`特性定义，并设置了特性转发。同时，移除了对`bevy_input`依赖的硬编码特性列表，改为由上层特性控制。
    - **代码片段**：
        ```toml
        # 关键改动：添加特性定义和转发
        [features]
        default = [
          "std",
          "bevy_reflect",
          "bevy_ecs/async_executor",
          "gamepad",     # 新加入：默认启用
          "keyboard",    # 新加入：默认启用
          "mouse",       # 新加入：默认启用，修复了#22167的遗漏
        ]
        gamepad = ["bevy_input/gamepad"]   # 新特性定义
        keyboard = ["bevy_input/keyboard"] # 新特性定义
        mouse = ["bevy_input/mouse"]       # 新特性定义
        
        # 关键改动：移除硬编码特性
        [dependencies.bevy_input]
        # 之前: features = ["keyboard", "gamepad"]
        # 之后: default-features = false （由特性控制）
        ```

2.  **`crates/bevy_input_focus/src/lib.rs`** (+9/-1)
    - **描述**：此文件包含`bevy_input_focus`的主要逻辑。修改将特定输入类型（`KeyboardInput`, `MouseWheel`, `GamepadButtonChangedEvent`）的导入和对应的系统注册语句用`#[cfg(feature = "...")]`属性包装起来，实现了条件编译。
    - **代码片段**：
        ```rust
        // 关键改动：条件导入
        // 之前: use bevy_input::{gamepad::GamepadButtonChangedEvent, keyboard::KeyboardInput, mouse::MouseWheel};
        // 之后:
        #[cfg(feature = "gamepad")]
        use bevy_input::gamepad::GamepadButtonChangedEvent;
        #[cfg(feature = "keyboard")]
        use bevy_input::keyboard::KeyboardInput;
        #[cfg(feature = "mouse")]
        use bevy_input::mouse::MouseWheel;
        
        // 关键改动：条件系统注册
        .add_systems(
            PreUpdate,
            (
                #[cfg(feature = "keyboard")] // 新增属性
                dispatch_focused_input::<KeyboardInput>,
                #[cfg(feature = "gamepad")]  // 新增属性
                dispatch_focused_input::<GamepadButtonChangedEvent>,
                #[cfg(feature = "mouse")]    // 新增属性，修复了#22167的遗漏
                dispatch_focused_input::<MouseWheel>,
            )
                .in_set(InputFocusSystems::Dispatch),
        )
        ```

3.  **`crates/bevy_internal/Cargo.toml`** (+3/-3)
    - **描述**：此文件是Bevy的根crate清单，负责聚合和转发所有子crate的特性。修改将`bevy_input_focus`添加为`mouse`、`keyboard`、`gamepad`特性的可选转发目标，确保了用户在主项目中启用某个输入特性时，其效果能完整地传递到整个依赖链。
    - **代码片段**：
        ```toml
        # 关键改动：将特性转发至bevy_input_focus
        # 之前:
        # mouse = ["bevy_input/mouse"]
        # 之后:
        mouse = ["bevy_input/mouse", "bevy_input_focus?/mouse"] # 新增转发
        # `?`表示bevy_input_focus是可选的，只在被启用时转发特性
        ```

## Further Reading
- **[PR #21447](https://github.com/bevyengine/bevy/pull/21447)**: 最初为 `bevy_input` 引入输入源特性门控的PR，是本PR要解决的根源。
- **[PR #22167](https://github.com/bevyengine/bevy/pull/22167)**: 尝试修复本问题但方法不完整的PR，本PR修正了其遗漏。
- **[Cargo Book: Features](https://doc.rust-lang.org/cargo/reference/features.html)**: Rust Cargo官方文档中关于特性定义、依赖和转发的详细说明。
- **[The Rust Reference: Conditional Compilation](https://doc.rust-lang.org/reference/conditional-compilation.html)**: Rust语言参考中关于 `#[cfg]` 属性用法的文档。