+++
title = "#22042 enable easier modification of image samplers in image loaders"
date = "2025-12-07T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-12/pr-22042-en-20251207" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-12/pr-22042-zh-cn-20251207" }}
labels = ["A-Rendering", "C-Usability"]
+++

# Title: enable easier modification of image samplers in image loaders

## Basic Information
- **Title**: enable easier modification of image samplers in image loaders
- **PR Link**: https://github.com/bevyengine/bevy/pull/22042
- **Author**: ChristopherBiscardi
- **Status**: MERGED
- **Labels**: A-Rendering, C-Usability, S-Ready-For-Final-Review
- **Created**: 2025-12-06T03:36:34Z
- **Merged**: 2025-12-07T18:41:21Z
- **Merged By**: mockersf

## Description Translation

# Objective

Previously, to modify a sampler when loading an image with settings it was required to set all fields individually. Much of the time, these settings are all the same so to enable repeating textures you have to set the address_mode 3 times. To set filters you have to set them another 3 times.

```rust
MeshMaterial3d(materials.add(
    StandardMaterial {
        base_color_texture:
            Some(
                asset_server.load_with_settings(
                    "floor_graph_base_color.png",
                    |settings: &mut ImageLoaderSettings| {
                        let  descriptor = settings.sampler.get_or_init_descriptor();
                        descriptor.address_mode_u = bevy::image::ImageAddressMode::Repeat;
                        descriptor.address_mode_v = bevy::image::ImageAddressMode::Repeat;
                        descriptor.address_mode_w = bevy::image::ImageAddressMode::Repeat;
                        descriptor.mag_filter = ImageFilterMode::Linear;
                        descriptor.min_filter = ImageFilterMode::Linear;
                        descriptor.mipmap_filter = ImageFilterMode::Linear;
                    }
                ),
            ),
        unlit: true,
        cull_mode: None,
        uv_transform: Affine2::from_scale(Vec2::new(30., 90.)),
        ..default()
    },
)),
```

## Solution

Add two new helpers, loosely modeled after the `Transform::with_<field>` functions. Further modifications can still be made to the descriptor for use cases which want to set one of the three fields differently, or additionally set anisotropy_clamp, etc.

```rust
let descriptor = settings
    .sampler
    .get_or_init_descriptor()
    .set_address_mode(ImageAddressMode::Repeat)
    .set_filter(ImageFilterMode::Linear);
```

## Testing

New test in bevy_image

## Showcase

```rust
MeshMaterial3d(materials.add(
    StandardMaterial {
        base_color_texture:
            Some(
                asset_server.load_with_settings(
                    "floor_graph_base_color.png",
                    |settings: &mut ImageLoaderSettings| {
                        let descriptor = settings
                            .sampler
                            .get_or_init_descriptor()
                            .set_address_mode(ImageAddressMode::Repeat)
                            .set_filter(ImageFilterMode::Linear);
                    }
                ),
            ),
        unlit: true,
        cull_mode: None,
        uv_transform: Affine2::from_scale(Vec2::new(30., 90.)),
        ..default()
    },
)),
```

This PR now includes:

- `set_filter`
- `set_address_mode`
- `set_anisotropic_filter`

## The Story of This Pull Request

This PR addresses a common usability issue in Bevy's image loading system where configuring texture samplers required repetitive, error-prone code. When loading textures with custom sampler settings, developers had to set each field individually, even when applying the same value to multiple similar fields. For example, setting a texture to repeat in all three dimensions required three separate assignments, and setting filtering modes required another three assignments.

The problem manifested in real code like this:

```rust
let descriptor = settings.sampler.get_or_init_descriptor();
descriptor.address_mode_u = bevy::image::ImageAddressMode::Repeat;
descriptor.address_mode_v = bevy::image::ImageAddressMode::Repeat;
descriptor.address_mode_w = bevy::image::ImageAddressMode::Repeat;
descriptor.mag_filter = ImageFilterMode::Linear;
descriptor.min_filter = ImageFilterMode::Linear;
descriptor.mipmap_filter = ImageFilterMode::Linear;
```

This approach had several drawbacks: it was verbose (6 lines instead of 2), prone to copy-paste errors, and required developers to remember which fields needed to be set together for common use cases like anisotropic filtering.

The solution implemented follows a common pattern in Bevy's API design - the builder pattern with fluent interface methods, similar to what's used in `Transform::with_*` methods. By adding three new helper methods to `ImageSamplerDescriptor`, the PR significantly reduces boilerplate while maintaining full flexibility.

The implementation adds three methods:

1. **`set_filter()`**: Sets all three filter modes (min, mag, and mipmap) to the same value. This covers the common case where developers want consistent filtering across all filter types.

2. **`set_address_mode()`**: Sets all three address modes (U, V, and W) to the same value. This is particularly useful for textures that should repeat in all dimensions.

3. **`set_anisotropic_filter()`**: Configures anisotropic filtering by setting the anisotropy clamp value and automatically setting all filters to linear mode (a requirement for anisotropic filtering to work).

The methods are designed to be chainable (returning `&mut Self`) and marked as `#[inline]` for zero-cost abstraction. This design allows developers to write concise, readable code:

```rust
let descriptor = settings
    .sampler
    .get_or_init_descriptor()
    .set_address_mode(ImageAddressMode::Repeat)
    .set_filter(ImageFilterMode::Linear);
```

Importantly, the solution doesn't remove the ability to configure individual fields differently. Developers can still manually set `address_mode_u`, `address_mode_v`, and `address_mode_w` separately if they need different behaviors along different axes. The helper methods simply provide a convenient shorthand for the most common cases.

The PR includes comprehensive tests that verify both the basic functionality and the anisotropic filtering behavior. The tests demonstrate the expected usage pattern and ensure that the methods correctly modify the underlying descriptor fields.

One technical consideration worth noting is the `set_anisotropic_filter` method's implementation. It automatically sets all filter modes to `ImageFilterMode::Linear` because anisotropic filtering requires linear filtering to function correctly. This design choice prevents a common error where developers might enable anisotropy without setting the appropriate filter modes, which would otherwise result in incorrect rendering.

The impact of these changes is straightforward: less code, fewer errors, and better developer experience when working with texture samplers in Bevy. The changes are backward compatible - existing code continues to work unchanged, while new code can take advantage of the more ergonomic API.

## Visual Representation

```mermaid
graph TD
    A[ImageLoaderSettings] --> B[.sampler]
    B --> C[ImageSampler::get_or_init_descriptor()]
    C --> D[ImageSamplerDescriptor]
    D --> E[.set_address_mode()]
    D --> F[.set_filter()]
    D --> G[.set_anisotropic_filter()]
    E --> H[Modified Descriptor]
    F --> H
    G --> H
    H --> I[Image Loading Pipeline]
```

## Key Files Changed

### `crates/bevy_image/src/image.rs` (+60/-0)

This file contains the `ImageSamplerDescriptor` struct definition and its implementation. The PR adds three new helper methods to this struct:

1. **`set_filter()`**: A convenience method that sets all three filter modes (min, mag, and mipmap) to the same value.
2. **`set_address_mode()`**: A convenience method that sets all three address modes (U, V, and W) to the same value.
3. **`set_anisotropic_filter()`**: A specialized method that configures anisotropic filtering, automatically setting the required linear filter modes.

Code additions:

```rust
/// Returns this sampler descriptor with a new `ImageFilterMode` min, mag, and mipmap filters
#[inline]
pub fn set_filter(&mut self, filter: ImageFilterMode) -> &mut Self {
    self.mag_filter = filter;
    self.min_filter = filter;
    self.mipmap_filter = filter;
    self
}

/// Returns this sampler descriptor with a new `ImageAddressMode` for u, v, and w
#[inline]
pub fn set_address_mode(&mut self, address_mode: ImageAddressMode) -> &mut Self {
    self.address_mode_u = address_mode;
    self.address_mode_v = address_mode;
    self.address_mode_w = address_mode;
    self
}

/// Returns this sampler descriptor with an `anisotropy_clamp` value and also
/// set filters to `ImageFilterMode::Linear`, which is required to
/// use anisotropy.
#[inline]
pub fn set_anisotropic_filter(&mut self, anisotropy_clamp: u16) -> &mut Self {
    self.mag_filter = ImageFilterMode::Linear;
    self.min_filter = ImageFilterMode::Linear;
    self.mipmap_filter = ImageFilterMode::Linear;
    self.anisotropy_clamp = anisotropy_clamp;
    self
}
```

The PR also adds two test functions that verify the new functionality works correctly:

```rust
#[test]
fn get_or_init_sampler_modifications() {
    // given some sampler
    let mut default_sampler = ImageSampler::Default;
    // a load_with_settings call wants to customize the descriptor
    let my_sampler_in_a_loader = default_sampler
        .get_or_init_descriptor()
        .set_filter(ImageFilterMode::Linear)
        .set_address_mode(ImageAddressMode::Repeat);

    assert_eq!(
        my_sampler_in_a_loader.address_mode_u,
        ImageAddressMode::Repeat
    );
    assert_eq!(my_sampler_in_a_loader.min_filter, ImageFilterMode::Linear);
}

#[test]
fn get_or_init_sampler_anisotropy() {
    // given some sampler
    let mut default_sampler = ImageSampler::Default;
    // a load_with_settings call wants to customize the descriptor
    let my_sampler_in_a_loader = default_sampler
        .get_or_init_descriptor()
        .set_anisotropic_filter(8);

    assert_eq!(my_sampler_in_a_loader.min_filter, ImageFilterMode::Linear);
    assert_eq!(my_sampler_in_a_loader.anisotropy_clamp, 8);
}
```

These changes directly address the PR's goal by providing a more ergonomic API for configuring texture samplers while maintaining backward compatibility and full flexibility for advanced use cases.

## Further Reading

1. **Bevy Asset System Documentation**: Understanding how `load_with_settings` works in Bevy's asset system
2. **wgpu SamplerDescriptor**: The underlying WebGPU/WGPU sampler configuration that `ImageSamplerDescriptor` translates to
3. **Texture Filtering Modes**: Technical details about minification, magnification, and mipmap filtering
4. **Texture Addressing Modes**: Explanation of wrap, mirror, clamp, and border addressing modes
5. **Anisotropic Filtering**: How anisotropic filtering improves texture quality at oblique angles
6. **Builder Pattern**: The design pattern used in this implementation for creating fluent APIs