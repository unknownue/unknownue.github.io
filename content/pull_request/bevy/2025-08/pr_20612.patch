diff --git a/crates/bevy_feathers/src/cursor.rs b/crates/bevy_feathers/src/cursor.rs
index 8c6b5c103b20a..4a35e40a7af20 100644
--- a/crates/bevy_feathers/src/cursor.rs
+++ b/crates/bevy_feathers/src/cursor.rs
@@ -51,12 +51,14 @@ impl EntityCursor {
     /// Compare the [`EntityCursor`] to a [`CursorIcon`] so that we can see whether or not
     /// the window cursor needs to be changed.
     pub fn eq_cursor_icon(&self, cursor_icon: &CursorIcon) -> bool {
-        match (self, cursor_icon) {
+        // If feature custom_cursor is not enabled in bevy_feathers, we can't know if it is or not
+        // in bevy_window. So we use the wrapper function `as_system` to let bevy_window check its own feature.
+        // Otherwise it is not possible to have a match that both covers all cases and doesn't have unreachable
+        // branches under all feature combinations.
+        match (self, cursor_icon, cursor_icon.as_system()) {
             #[cfg(feature = "custom_cursor")]
-            (EntityCursor::Custom(custom), CursorIcon::Custom(other)) => custom == other,
-            (EntityCursor::System(system), CursorIcon::System(cursor_icon)) => {
-                *system == *cursor_icon
-            }
+            (EntityCursor::Custom(custom), CursorIcon::Custom(other), _) => custom == other,
+            (EntityCursor::System(system), _, Some(cursor_icon)) => *system == *cursor_icon,
             _ => false,
         }
     }
diff --git a/crates/bevy_image/src/ktx2.rs b/crates/bevy_image/src/ktx2.rs
index be9f8ecc5543b..74e8c0caadbda 100644
--- a/crates/bevy_image/src/ktx2.rs
+++ b/crates/bevy_image/src/ktx2.rs
@@ -43,12 +43,13 @@ pub fn ktx2_buffer_to_image(
     let depth = depth.max(1);
 
     // Handle supercompression
-    let mut levels = Vec::new();
+    let mut levels: Vec<Vec<u8>>;
     if let Some(supercompression_scheme) = supercompression_scheme {
-        for (level_index, level) in ktx2.levels().enumerate() {
-            match supercompression_scheme {
-                #[cfg(feature = "flate2")]
-                SupercompressionScheme::ZLIB => {
+        match supercompression_scheme {
+            #[cfg(feature = "flate2")]
+            SupercompressionScheme::ZLIB => {
+                levels = Vec::with_capacity(ktx2.levels().len());
+                for (level_index, level) in ktx2.levels().enumerate() {
                     let mut decoder = flate2::bufread::ZlibDecoder::new(level.data);
                     let mut decompressed = Vec::new();
                     decoder.read_to_end(&mut decompressed).map_err(|err| {
@@ -58,8 +59,11 @@ pub fn ktx2_buffer_to_image(
                     })?;
                     levels.push(decompressed);
                 }
-                #[cfg(all(feature = "zstd_rust", not(feature = "zstd_c")))]
-                SupercompressionScheme::Zstandard => {
+            }
+            #[cfg(all(feature = "zstd_rust", not(feature = "zstd_c")))]
+            SupercompressionScheme::Zstandard => {
+                levels = Vec::with_capacity(ktx2.levels().len());
+                for (level_index, level) in ktx2.levels().enumerate() {
                     let mut cursor = std::io::Cursor::new(level.data);
                     let mut decoder = ruzstd::decoding::StreamingDecoder::new(&mut cursor)
                         .map_err(|err| TextureError::SuperDecompressionError(err.to_string()))?;
@@ -71,19 +75,22 @@ pub fn ktx2_buffer_to_image(
                     })?;
                     levels.push(decompressed);
                 }
-                #[cfg(feature = "zstd_c")]
-                SupercompressionScheme::Zstandard => {
+            }
+            #[cfg(feature = "zstd_c")]
+            SupercompressionScheme::Zstandard => {
+                levels = Vec::with_capacity(ktx2.levels().len());
+                for (level_index, level) in ktx2.levels().enumerate() {
                     levels.push(zstd::decode_all(level.data).map_err(|err| {
                         TextureError::SuperDecompressionError(format!(
                             "Failed to decompress {supercompression_scheme:?} for mip {level_index}: {err:?}",
                         ))
                     })?);
                 }
-                _ => {
-                    return Err(TextureError::SuperDecompressionError(format!(
-                        "Unsupported supercompression scheme: {supercompression_scheme:?}",
-                    )));
-                }
+            }
+            _ => {
+                return Err(TextureError::SuperDecompressionError(format!(
+                    "Unsupported supercompression scheme: {supercompression_scheme:?}",
+                )));
             }
         }
     } else {
diff --git a/crates/bevy_window/src/cursor/mod.rs b/crates/bevy_window/src/cursor/mod.rs
index f35d0377901e3..58c3735813c99 100644
--- a/crates/bevy_window/src/cursor/mod.rs
+++ b/crates/bevy_window/src/cursor/mod.rs
@@ -36,3 +36,22 @@ impl From<SystemCursorIcon> for CursorIcon {
         CursorIcon::System(icon)
     }
 }
+
+impl CursorIcon {
+    /// Returns the system cursor icon if this is a system cursor.
+    pub fn as_system(&self) -> Option<&SystemCursorIcon> {
+        #[cfg(feature = "custom_cursor")]
+        {
+            if let CursorIcon::System(icon) = self {
+                Some(icon)
+            } else {
+                None
+            }
+        }
+        #[cfg(not(feature = "custom_cursor"))]
+        {
+            let CursorIcon::System(icon) = self;
+            Some(icon)
+        }
+    }
+}
