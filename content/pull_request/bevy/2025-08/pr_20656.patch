diff --git a/Cargo.toml b/Cargo.toml
index a8516f186dd73..f82e531aeb1f4 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -877,6 +877,17 @@ description = "Generates text in 2D"
 category = "2D Rendering"
 wasm = true
 
+[[example]]
+name = "multi_window_text"
+path = "examples/window/multi_window_text.rs"
+doc-scrape-examples = true
+
+[package.metadata.example.multi_window_text]
+name = "Multi-Window Text"
+description = "Renders text to multiple windows with different scale factors using both Text and Text2d"
+category = "2D Rendering"
+wasm = true
+
 [[example]]
 name = "texture_atlas"
 path = "examples/2d/texture_atlas.rs"
diff --git a/crates/bevy_sprite/src/lib.rs b/crates/bevy_sprite/src/lib.rs
index 29663e0302fd5..81874f37af24f 100644
--- a/crates/bevy_sprite/src/lib.rs
+++ b/crates/bevy_sprite/src/lib.rs
@@ -86,11 +86,7 @@ impl Plugin for SpritePlugin {
             (
                 bevy_text::detect_text_needs_rerender::<Text2d>,
                 update_text2d_layout
-                    // Potential conflict: `Assets<Image>`
-                    // In practice, they run independently since `bevy_render::camera_update_system`
-                    // will only ever observe its own render target, and `update_text2d_layout`
-                    // will never modify a pre-existing `Image` asset.
-                    .ambiguous_with(bevy_camera::CameraUpdateSystems)
+                    .after(bevy_camera::CameraUpdateSystems)
                     .after(bevy_text::remove_dropped_font_atlas_sets),
                 calculate_bounds_text2d.in_set(VisibilitySystems::CalculateBounds),
             )
diff --git a/crates/bevy_sprite/src/text2d.rs b/crates/bevy_sprite/src/text2d.rs
index cb3c6dde8d034..3c0e5fa56564f 100644
--- a/crates/bevy_sprite/src/text2d.rs
+++ b/crates/bevy_sprite/src/text2d.rs
@@ -1,13 +1,10 @@
-use bevy_text::{
-    ComputedTextBlock, CosmicFontSystem, Font, FontAtlasSets, LineBreak, SwashCache, TextBounds,
-    TextColor, TextError, TextFont, TextLayout, TextLayoutInfo, TextPipeline, TextReader, TextRoot,
-    TextSpanAccess, TextWriter,
-};
-
 use crate::{Anchor, Sprite};
 use bevy_asset::Assets;
 use bevy_camera::primitives::Aabb;
-use bevy_camera::visibility::{self, NoFrustumCulling, Visibility, VisibilityClass};
+use bevy_camera::visibility::{
+    self, NoFrustumCulling, RenderLayers, Visibility, VisibilityClass, VisibleEntities,
+};
+use bevy_camera::Camera;
 use bevy_color::Color;
 use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::entity::EntityHashSet;
@@ -15,15 +12,20 @@ use bevy_ecs::{
     change_detection::{DetectChanges, Ref},
     component::Component,
     entity::Entity,
-    prelude::{ReflectComponent, With},
+    prelude::ReflectComponent,
     query::{Changed, Without},
     system::{Commands, Local, Query, Res, ResMut},
 };
 use bevy_image::prelude::*;
-use bevy_math::{Vec2, Vec3};
+use bevy_math::{FloatOrd, Vec2, Vec3};
 use bevy_reflect::{prelude::ReflectDefault, Reflect};
+use bevy_text::{
+    ComputedTextBlock, CosmicFontSystem, Font, FontAtlasSets, LineBreak, SwashCache, TextBounds,
+    TextColor, TextError, TextFont, TextLayout, TextLayoutInfo, TextPipeline, TextReader, TextRoot,
+    TextSpanAccess, TextWriter,
+};
 use bevy_transform::components::Transform;
-use bevy_window::{PrimaryWindow, Window};
+use core::any::TypeId;
 
 /// The top-level 2D text component.
 ///
@@ -156,17 +158,18 @@ impl Default for Text2dShadow {
 /// [`ResMut<Assets<Image>>`](Assets<Image>) -- This system only adds new [`Image`] assets.
 /// It does not modify or observe existing ones.
 pub fn update_text2d_layout(
-    mut last_scale_factor: Local<Option<f32>>,
+    mut target_scale_factors: Local<Vec<(f32, RenderLayers)>>,
     // Text items which should be reprocessed again, generally when the font hasn't loaded yet.
     mut queue: Local<EntityHashSet>,
     mut textures: ResMut<Assets<Image>>,
     fonts: Res<Assets<Font>>,
-    windows: Query<&Window, With<PrimaryWindow>>,
+    camera_query: Query<(&Camera, &VisibleEntities, Option<&RenderLayers>)>,
     mut texture_atlases: ResMut<Assets<TextureAtlasLayout>>,
     mut font_atlas_sets: ResMut<FontAtlasSets>,
     mut text_pipeline: ResMut<TextPipeline>,
     mut text_query: Query<(
         Entity,
+        Option<&RenderLayers>,
         Ref<TextLayout>,
         Ref<TextBounds>,
         &mut TextLayoutInfo,
@@ -176,21 +179,46 @@ pub fn update_text2d_layout(
     mut font_system: ResMut<CosmicFontSystem>,
     mut swash_cache: ResMut<SwashCache>,
 ) {
-    // TODO: Support window-independent scaling: https://github.com/bevyengine/bevy/issues/5621
-    let scale_factor = windows
-        .single()
-        .ok()
-        .map(|window| window.resolution.scale_factor())
-        .or(*last_scale_factor)
-        .unwrap_or(1.);
-
-    let inverse_scale_factor = scale_factor.recip();
-
-    let factor_changed = *last_scale_factor != Some(scale_factor);
-    *last_scale_factor = Some(scale_factor);
+    target_scale_factors.clear();
+    target_scale_factors.extend(
+        camera_query
+            .iter()
+            .filter(|(_, visible_entities, _)| {
+                !visible_entities.get(TypeId::of::<Sprite>()).is_empty()
+            })
+            .filter_map(|(camera, _, maybe_camera_mask)| {
+                camera.target_scaling_factor().map(|scale_factor| {
+                    (scale_factor, maybe_camera_mask.cloned().unwrap_or_default())
+                })
+            }),
+    );
+
+    let mut previous_scale_factor = 0.;
+    let mut previous_mask = &RenderLayers::none();
+
+    for (entity, maybe_entity_mask, block, bounds, text_layout_info, mut computed) in
+        &mut text_query
+    {
+        let entity_mask = maybe_entity_mask.unwrap_or_default();
+
+        let scale_factor = if entity_mask == previous_mask && 0. < previous_scale_factor {
+            previous_scale_factor
+        } else {
+            // `Text2d` only supports generating a single text layout per Text2d entity. If a `Text2d` entity has multiple
+            // render targets with different scale factors, then we use the maximum of the scale factors.
+            let Some((scale_factor, mask)) = target_scale_factors
+                .iter()
+                .filter(|(_, camera_mask)| camera_mask.intersects(entity_mask))
+                .max_by_key(|(scale_factor, _)| FloatOrd(*scale_factor))
+            else {
+                continue;
+            };
+            previous_scale_factor = *scale_factor;
+            previous_mask = mask;
+            *scale_factor
+        };
 
-    for (entity, block, bounds, text_layout_info, mut computed) in &mut text_query {
-        if factor_changed
+        if scale_factor != text_layout_info.scale_factor
             || computed.needs_rerender()
             || bounds.is_changed()
             || (!queue.is_empty() && queue.remove(&entity))
@@ -209,7 +237,7 @@ pub fn update_text2d_layout(
                 text_layout_info,
                 &fonts,
                 text_reader.iter(entity),
-                scale_factor.into(),
+                scale_factor as f64,
                 &block,
                 text_bounds,
                 &mut font_atlas_sets,
@@ -228,7 +256,8 @@ pub fn update_text2d_layout(
                     panic!("Fatal error when processing text: {e}.");
                 }
                 Ok(()) => {
-                    text_layout_info.size *= inverse_scale_factor;
+                    text_layout_info.scale_factor = scale_factor;
+                    text_layout_info.size *= scale_factor.recip();
                 }
             }
         }
@@ -277,7 +306,9 @@ mod tests {
 
     use bevy_app::{App, Update};
     use bevy_asset::{load_internal_binary_asset, Handle};
+    use bevy_camera::{ComputedCameraValues, RenderTargetInfo};
     use bevy_ecs::schedule::IntoScheduleConfigs;
+    use bevy_math::UVec2;
     use bevy_text::{detect_text_needs_rerender, TextIterScratch};
 
     use super::*;
@@ -305,6 +336,23 @@ mod tests {
                     .chain(),
             );
 
+        let mut visible_entities = VisibleEntities::default();
+        visible_entities.push(Entity::PLACEHOLDER, TypeId::of::<Sprite>());
+
+        app.world_mut().spawn((
+            Camera {
+                computed: ComputedCameraValues {
+                    target_info: Some(RenderTargetInfo {
+                        physical_size: UVec2::splat(1000),
+                        scale_factor: 1.,
+                    }),
+                    ..Default::default()
+                },
+                ..Default::default()
+            },
+            visible_entities,
+        ));
+
         // A font is needed to ensure the text is laid out with an actual size.
         load_internal_binary_asset!(
             app,
diff --git a/crates/bevy_sprite_render/Cargo.toml b/crates/bevy_sprite_render/Cargo.toml
index ddf702398ab50..d0b20a3052750 100644
--- a/crates/bevy_sprite_render/Cargo.toml
+++ b/crates/bevy_sprite_render/Cargo.toml
@@ -35,7 +35,6 @@ bevy_derive = { path = "../bevy_derive", version = "0.17.0-dev" }
 bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev", default-features = false, features = [
   "std",
 ] }
-bevy_window = { path = "../bevy_window", version = "0.17.0-dev" }
 
 # other
 bytemuck = { version = "1", features = ["derive", "must_cast"] }
diff --git a/crates/bevy_sprite_render/src/text2d/mod.rs b/crates/bevy_sprite_render/src/text2d/mod.rs
index 940f1288387c3..5dbd603ed21df 100644
--- a/crates/bevy_sprite_render/src/text2d/mod.rs
+++ b/crates/bevy_sprite_render/src/text2d/mod.rs
@@ -6,7 +6,6 @@ use bevy_camera::visibility::ViewVisibility;
 use bevy_color::LinearRgba;
 use bevy_ecs::{
     entity::Entity,
-    prelude::With,
     system::{Commands, Query, Res, ResMut},
 };
 use bevy_image::prelude::*;
@@ -18,7 +17,6 @@ use bevy_text::{
     ComputedTextBlock, PositionedGlyph, TextBackgroundColor, TextBounds, TextColor, TextLayoutInfo,
 };
 use bevy_transform::prelude::GlobalTransform;
-use bevy_window::{PrimaryWindow, Window};
 
 /// This system extracts the sprites from the 2D text components and adds them to the
 /// "render world".
@@ -27,7 +25,6 @@ pub fn extract_text2d_sprite(
     mut extracted_sprites: ResMut<ExtractedSprites>,
     mut extracted_slices: ResMut<ExtractedSlices>,
     texture_atlases: Extract<Res<Assets<TextureAtlasLayout>>>,
-    windows: Extract<Query<&Window, With<PrimaryWindow>>>,
     text2d_query: Extract<
         Query<(
             Entity,
@@ -46,13 +43,6 @@ pub fn extract_text2d_sprite(
     let mut start = extracted_slices.slices.len();
     let mut end = start + 1;
 
-    // TODO: Support window-independent scaling: https://github.com/bevyengine/bevy/issues/5621
-    let scale_factor = windows
-        .single()
-        .map(|window| window.resolution.scale_factor())
-        .unwrap_or(1.0);
-    let scaling = GlobalTransform::from_scale(Vec2::splat(scale_factor.recip()).extend(1.));
-
     for (
         main_entity,
         view_visibility,
@@ -64,6 +54,9 @@ pub fn extract_text2d_sprite(
         global_transform,
     ) in text2d_query.iter()
     {
+        let scaling = GlobalTransform::from_scale(
+            Vec2::splat(text_layout_info.scale_factor.recip()).extend(1.),
+        );
         if !view_visibility.get() {
             continue;
         }
diff --git a/crates/bevy_text/src/pipeline.rs b/crates/bevy_text/src/pipeline.rs
index 73e30e3756b6b..ccf6245fad6b6 100644
--- a/crates/bevy_text/src/pipeline.rs
+++ b/crates/bevy_text/src/pipeline.rs
@@ -449,6 +449,8 @@ impl TextPipeline {
 #[derive(Component, Clone, Default, Debug, Reflect)]
 #[reflect(Component, Default, Debug, Clone)]
 pub struct TextLayoutInfo {
+    /// The target scale factor for this text layout
+    pub scale_factor: f32,
     /// Scaled and positioned glyphs in screenspace
     pub glyphs: Vec<PositionedGlyph>,
     /// Rects bounding the text block's text sections.
diff --git a/crates/bevy_ui/src/widget/text.rs b/crates/bevy_ui/src/widget/text.rs
index e021022512954..b008923a83d12 100644
--- a/crates/bevy_ui/src/widget/text.rs
+++ b/crates/bevy_ui/src/widget/text.rs
@@ -367,6 +367,7 @@ fn queue_text(
             panic!("Fatal error when processing text: {e}.");
         }
         Ok(()) => {
+            text_layout_info.scale_factor = scale_factor;
             text_layout_info.size *= inverse_scale_factor;
             text_flags.needs_recompute = false;
         }
diff --git a/examples/README.md b/examples/README.md
index 6b8cd0f25114b..16cfb5b47d3c3 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -119,6 +119,7 @@ Example | Description
 [Mesh2d Alpha Mode](../examples/2d/mesh2d_alpha_mode.rs) | Used to test alpha modes with mesh2d
 [Mesh2d Repeated Texture](../examples/2d/mesh2d_repeated_texture.rs) | Showcase of using `uv_transform` on the `ColorMaterial` of a `Mesh2d`
 [Move Sprite](../examples/2d/move_sprite.rs) | Changes the transform of a sprite
+[Multi-Window Text](../examples/window/multi_window_text.rs) | Renders text to multiple windows with different scale factors using both Text and Text2d
 [Pixel Grid Snapping](../examples/2d/pixel_grid_snap.rs) | Shows how to create graphics that snap to the pixel grid by rendering to a texture in 2D
 [Sprite](../examples/2d/sprite.rs) | Renders a sprite
 [Sprite Animation](../examples/2d/sprite_animation.rs) | Animates a sprite in response to an event
diff --git a/examples/window/multi_window_text.rs b/examples/window/multi_window_text.rs
new file mode 100644
index 0000000000000..448b67fd12b0a
--- /dev/null
+++ b/examples/window/multi_window_text.rs
@@ -0,0 +1,116 @@
+//! Renders text to multiple windows with different scale factors using both Text and Text2d.
+use bevy::{
+    camera::{visibility::RenderLayers, RenderTarget},
+    color::palettes::css::{LIGHT_CYAN, YELLOW},
+    prelude::*,
+    sprite::Text2dShadow,
+    window::{WindowRef, WindowResolution},
+};
+
+fn main() {
+    App::new()
+        // By default, a primary window is spawned by `WindowPlugin`, contained in `DefaultPlugins`.
+        // The primary window is given the `PrimaryWindow` marker component.
+        .add_plugins(DefaultPlugins.set(WindowPlugin {
+            primary_window: Some(Window {
+                title: "Primary window".to_owned(),
+                // Override the primary window's scale factor and use `1.` (no scaling).
+                resolution: WindowResolution::default().with_scale_factor_override(1.),
+                ..default()
+            }),
+            ..Default::default()
+        }))
+        .add_systems(Startup, setup_scene)
+        .run();
+}
+
+fn setup_scene(mut commands: Commands) {
+    // The first camera; no render target is specified, its render target will be set to the primary window automatically.
+    // This camera has no `RenderLayers` component, so it only renders entities belonging to render layer `0`.
+    commands.spawn(Camera2d);
+
+    // Spawn a second window
+    let secondary_window = commands
+        .spawn(Window {
+            title: "Secondary Window".to_owned(),
+            // Override the secondary window's scale factor and set it to double that of the primary window.
+            // This means the second window's text will use glyphs drawn at twice the resolution of the primary window's text,
+            // and they will be twice as big on screen.
+            resolution: WindowResolution::default().with_scale_factor_override(2.),
+            ..default()
+        })
+        .id();
+
+    // Spawn a second camera
+    let secondary_window_camera = commands
+        .spawn((
+            Camera2d,
+            // This camera will only render entities belonging to render layer `1`.
+            RenderLayers::layer(1),
+            Camera {
+                // Without an explicit render target, this camera would also target the primary window.
+                target: RenderTarget::Window(WindowRef::Entity(secondary_window)),
+                ..default()
+            },
+        ))
+        .id();
+
+    let node = Node {
+        position_type: PositionType::Absolute,
+        top: Val::Px(12.0),
+        left: Val::Px(12.0),
+        ..default()
+    };
+
+    let text_font = TextFont::from_font_size(30.);
+
+    // UI nodes can only be rendered by one camera at a time and ignore `RenderLayers`.
+    // This root UI node has no `UiTargetCamera` so `bevy_ui` will try to find a
+    // camera with the `IsDefaultUiCamera` marker component. When that fails (neither
+    // camera spawned here has an `IsDefaultUiCamera`), it queries for the
+    // first camera targeting the primary window and uses that.
+    commands.spawn(node.clone()).with_child((
+        Text::new("UI Text Primary Window"),
+        text_font.clone(),
+        TextShadow::default(),
+    ));
+
+    commands
+        .spawn((node, UiTargetCamera(secondary_window_camera)))
+        .with_child((
+            Text::new("UI Text Secondary Window"),
+            text_font.clone(),
+            TextShadow::default(),
+        ));
+
+    // `Text2d` belonging to render layer `0`.
+    commands.spawn((
+        Text2d::new("Text2d Primary Window"),
+        TextColor(YELLOW.into()),
+        text_font.clone(),
+        Text2dShadow::default(),
+    ));
+
+    // `Text2d` belonging to render layer `1`.
+    commands.spawn((
+        Text2d::new("Text2d Secondary Window"),
+        TextColor(YELLOW.into()),
+        text_font.clone(),
+        Text2dShadow::default(),
+        RenderLayers::layer(1),
+    ));
+
+    // This `Text2d` entity belongs to both render layers `0` and `1`, so it will be rendered by both
+    // cameras. A single text layout is generated per `Text2d` entity, targeting a specific scale
+    // factor. Since the two camera's render targets have different scale factors, the text layout
+    // will be generated using the higher scale factor (the secondary window's), and then downscaled when it is
+    // drawn by the camera targeting the primary window.
+    commands.spawn((
+        Text2d::new("Text2d Both Windows"),
+        TextColor(LIGHT_CYAN.into()),
+        text_font,
+        Text2dShadow::default(),
+        RenderLayers::from_layers(&[0, 1]),
+        Transform::from_xyz(0., -50., 0.),
+    ));
+}
diff --git a/release-content/release-notes/text2d-window-independent-scale-factor-support.md b/release-content/release-notes/text2d-window-independent-scale-factor-support.md
new file mode 100644
index 0000000000000..f756404220623
--- /dev/null
+++ b/release-content/release-notes/text2d-window-independent-scale-factor-support.md
@@ -0,0 +1,9 @@
+---
+title: "`Text2d` window independent scale factor support"
+authors: ["@Icksonpe"]
+pull_requests: [20656]
+---
+
+In previous versions of bevy, text rendered using `Text2d` would always use the scale factor of the primary window regardless of its render target. In 0.17, `Text2d` glyphs are rasterized to match the scale factor of the render target where the text is to be drawn.
+
+`Text2d` is still limited to generating only one text layout per `Text2d` entity. If a `Text2d` entity is simultaneously rendered to multiple targets with different scale factors then the maximum of the target scale factors is used.
