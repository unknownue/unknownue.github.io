+++
title = "#20675 Fix aabb area calculation"
date = "2025-08-20T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20675-en-20250820" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20675-zh-cn-20250820" }}
labels = ["C-Bug", "A-Math"]
+++

# Fix aabb area calculation

## Basic Information
- **Title**: Fix aabb area calculation
- **PR Link**: https://github.com/bevyengine/bevy/pull/20675
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: C-Bug, S-Ready-For-Final-Review, A-Math
- **Created**: 2025-08-20T17:22:27Z
- **Merged**: 2025-08-20T18:22:31Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- positive area can be reported for inverted Aabb2d, and negative area too in some cases. Invalid Aabbs (any(min > max)) should have zero area.

## Solution

- max 0

## Testing

- found at work, fixed at work, tested at work, works at work

## The Story of This Pull Request

This PR addresses a mathematical correctness issue in Bevy's axis-aligned bounding box (AABB) implementation. The problem occurred when dealing with invalid AABBs - specifically those where any component of the `min` vector was greater than the corresponding component of the `max` vector.

The core issue was in the `visible_area()` method implementation for both 2D and 3D AABBs. When calculating the area, the code simply computed `self.max - self.min` without validating whether the resulting dimensions were positive. For invalid AABBs where `min > max` in any dimension, this subtraction would produce negative values, leading to mathematically incorrect area calculations.

In 2D, the area calculation is `width * height`, and with negative dimensions, this could produce positive area values (when both dimensions are negative) or negative area values (when one dimension is negative). Similarly, in 3D, the surface area calculation `b.x * (b.y + b.z) + b.y * b.z` would produce nonsensical results with negative dimensions.

The fix is straightforward and mathematically sound: clamp each dimension to zero using `.max(Vec2::ZERO)` for 2D and `.max(Vec3A::ZERO)` for 3D. This ensures that invalid AABBs (where any dimension would be negative) report zero area, which is the correct behavior for degenerate bounding volumes.

The implementation maintains performance with `#[inline(always)]` directives and uses the existing vector math operations without introducing branching or complex logic. This approach ensures that valid AABBs continue to compute areas efficiently while handling edge cases correctly.

This fix is important because many algorithms that use AABBs for spatial partitioning, collision detection, or rendering optimizations rely on the assumption that area calculations are mathematically correct. Invalid area values could lead to incorrect behavior in systems that prioritize or cull objects based on their visible area.

## Visual Representation

```mermaid
graph TD
    A[Aabb2d.visible_area] --> B[Compute dimensions: max - min]
    B --> C[Clamp to zero: .max(ZERO)]
    C --> D[Calculate area]
    
    E[Aabb3d.visible_area] --> F[Compute dimensions: max - min]
    F --> G[Clamp to zero: .max(ZERO)]
    G --> H[Calculate surface area]
```

## Key Files Changed

### `crates/bevy_math/src/bounding/bounded2d/mod.rs` (+1/-1)
**Change**: Fixed area calculation for invalid 2D AABBs by clamping dimensions to zero.

```rust
// Before:
fn visible_area(&self) -> f32 {
    let b = self.max - self.min;
    b.x * b.y
}

// After:
fn visible_area(&self) -> f32 {
    let b = (self.max - self.min).max(Vec2::ZERO);
    b.x * b.y
}
```

### `crates/bevy_math/src/bounding/bounded3d/mod.rs` (+1/-1)
**Change**: Fixed surface area calculation for invalid 3D AABBs by clamping dimensions to zero.

```rust
// Before:
fn visible_area(&self) -> f32 {
    let b = self.max - self.min;
    b.x * (b.y + b.z) + b.y * b.z
}

// After:
fn visible_area(&self) -> f32 {
    let b = (self.max - self.min).max(Vec3A::ZERO);
    b.x * (b.y + b.z) + b.y * b.z
}
```

## Further Reading

- [Axis-aligned bounding boxes (AABBs) in computer graphics](https://en.wikipedia.org/wiki/Minimum_bounding_box#Axis-aligned_minimum_bounding_box)
- [Bevy's Bounding Volume documentation](https://docs.rs/bevy_math/latest/bevy_math/bounding/trait.BoundingVolume.html)
- [Vector math operations in Rust](https://docs.rs/glam/latest/glam/)