+++
title = "#15030"
date = "2025-08-06T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-15030-en-20250806" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-15030-zh-cn-20250806" }}
+++

## The Story of This Pull Request

### The Problem and Context
Before this PR, Bevy's reflection system required developers to manually register every top-level type that derived the `Reflect` trait. While nested types were automatically registered via #5781, forgetting to call `app.register_type::<T>()` for root types remained a common source of runtime errors. This was particularly problematic during rapid prototyping and when using tools like the inspector, where missing registration would silently break reflection capabilities. The manual process added cognitive overhead and was error-prone in larger codebases.

### The Solution Approach
This PR introduces automatic compile-time registration for non-generic types deriving `Reflect`. The implementation provides two pathways:
1. **Default inventory-based approach**: Uses the `inventory` crate for platforms it supports (Linux/macOS/Windows/WebAssembly/etc.) to collect type registrations at compile time.
2. **Static fallback**: For unsupported platforms, writes registration function names to disk during compilation, then loads them via a macro (`load_type_registrations!`) at runtime.

Key engineering decisions:
- Opt-out mechanism via `#[reflect(no_auto_register)]` attribute
- Minimal runtime overhead by leveraging compile-time registration
- Preserve existing manual registration APIs
- Platform-agnostic fallback to ensure broad compatibility

### The Implementation
The core changes extend Bevy's reflection infrastructure:

1. **TypeRegistry extensions**:
```rust
// Added to TypeRegistry
#[cfg(feature = "auto_register")]
pub fn register_derived_types(&mut self) {
    crate::__macro_exports::auto_register::register_types(self);
}
```
This method triggers registration of all types collected during compilation.

2. **Derive macro enhancements**:
```rust
// In container_attributes parsing
} else if lookahead.peek(kw::no_auto_register) {
    self.parse_no_auto_register(input)
```
The macro now generates registration code unless opted out. For static registration:
```rust
// Static registration writes function names to disk
let export_name = format!("_bevy_reflect_register_{}", uuid::Uuid::new_v4().as_u128());
// ... writes to target/bevy_reflect_type_registrations
```

3. **App initialization integration**:
```rust
// In app initialization
#[cfg(feature = "reflect_auto_register")]
app.insert_resource(AppTypeRegistry::new_with_derived_types());
```
Automatically registers types when the feature is enabled.

### Technical Insights
- **Platform Compatibility**: The dual-approach ensures coverage across all platforms. The static method uses UUIDs to avoid symbol collisions.
- **Performance**: Benchmarks show negligible startup impact (<40ms) but note WASM size increases (4.77-11.46%) due to including more type data. The actual overhead of auto-registration vs manual is minimal (0.2-0.64%).
- **Generics Limitation**: Automatic registration only works for concrete types. Generic types still require manual registration since their monomorphized forms can't be known at compile time.
- **Project Structure**: The static approach requires separating type definitions from the macro invocation (typically via lib/bin separation) to ensure registration functions are generated before being collected.

### The Impact
- **Ergonomics**: Eliminates the most common reflection-related boilerplate and pitfalls.
- **Safety**: Reduces runtime errors from missing registrations.
- **Flexibility**: Opt-out attribute and fallback implementation accommodate diverse use cases.
- **Documentation**: Includes comprehensive examples (auto_register_static) and release notes.

The solution maintains Bevy's focus on ergonomics without compromising flexibility, though the WASM size tradeoffs warrant consideration for constrained environments.

```mermaid
graph TD
    A[Derive(Reflect)] --> B{Platform Support}
    B -->|Supported| C[Inventory Registration]
    B -->|Unsupported| D[Static Registration]
    C --> E[Runtime TypeRegistry]
    D --> F[File-based Collection]
    F --> G[load_type_registrations! Macro]
    G --> E
    E --> H[Reflection System]
```

## Key Files Changed

### `crates/bevy_reflect/src/type_registry.rs`
- **Purpose**: Add auto-registration entry point
- **Key Change**:
```rust
#[cfg(feature = "auto_register")]
pub fn register_derived_types(&mut self) {
    crate::__macro_exports::auto_register::register_types(self);
}
```

### `crates/bevy_reflect/derive/src/impls/common.rs`
- **Purpose**: Generate registration code in derive macro
- **Key Addition**:
```rust
#[cfg(feature = "auto_register")]
pub fn reflect_auto_registration(meta: &ReflectMeta) -> Option<proc_macro2::TokenStream> {
    if meta.attrs().no_auto_register() {
        return None;
    }
    // ... generates platform-specific registration code
```

### `crates/bevy_reflect/derive/src/lib.rs`
- **Purpose**: Implement static registration collector
- **Key Addition**:
```rust
#[proc_macro]
pub fn load_type_registrations(_input: TokenStream) -> TokenStream {
    // ... reads generated registration functions from disk
    // ... generates code to register them at runtime
```

### `examples/reflection/auto_register_static/src/lib.rs`
- **Purpose**: Demonstrate static registration setup
- **Key Structure**:
```rust
#[derive(Reflect)]
struct Struct { a: i32 } // In lib crate

// Bin crate calls macro before app creation:
load_type_registrations!();
app.add_plugins(DefaultPlugins).run();
```

### `release-content/release-notes/reflect_auto_registration.md`
- **Purpose**: Document feature for release
- **Key Content**:
```markdown
## Automatic `Reflect` registration
Deriving `Reflect` now auto-registers non-generic types. Opt-out with:
`#[reflect(no_auto_register)]`
```

## Further Reading
- [Bevy Reflection Documentation](https://docs.rs/bevy/latest/bevy/reflect/index.html)
- [`inventory` Crate Details](https://github.com/dtolnay/inventory)
- [Static Registration Example](https://github.com/bevyengine/bevy/tree/main/examples/reflection/auto_register_static)