diff --git a/Cargo.toml b/Cargo.toml
index 7d4dd19cef186..d93b9245c320a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -153,6 +153,7 @@ default = [
   "bevy_scene",
   "bevy_sprite",
   "bevy_sprite_picking_backend",
+  "bevy_sprite_render",
   "bevy_state",
   "bevy_text",
   "bevy_ui",
@@ -267,8 +268,12 @@ bevy_solari = [
 ]
 
 # Provides sprite functionality
-bevy_sprite = [
-  "bevy_internal/bevy_sprite",
+bevy_sprite = ["bevy_internal/bevy_sprite", "bevy_color"]
+
+# Provides sprite rendering functionality
+bevy_sprite_render = [
+  "bevy_internal/bevy_sprite_render",
+  "bevy_sprite",
   "bevy_render",
   "bevy_core_pipeline",
   "bevy_color",
@@ -289,7 +294,12 @@ bevy_ui = [
 ]
 
 # Provides rendering functionality for bevy_ui
-bevy_ui_render = ["bevy_internal/bevy_ui_render", "bevy_render", "bevy_ui"]
+bevy_ui_render = [
+  "bevy_internal/bevy_ui_render",
+  "bevy_render",
+  "bevy_sprite_render",
+  "bevy_ui",
+]
 
 # Windowing layer
 bevy_window = ["bevy_internal/bevy_window"]
diff --git a/crates/bevy_gizmos/Cargo.toml b/crates/bevy_gizmos/Cargo.toml
index e5c0dc7058d88..1c2f5324855cd 100644
--- a/crates/bevy_gizmos/Cargo.toml
+++ b/crates/bevy_gizmos/Cargo.toml
@@ -17,6 +17,7 @@ bevy_render = ["dep:bevy_render", "bevy_core_pipeline"]
 # Bevy
 bevy_pbr = { path = "../bevy_pbr", version = "0.17.0-dev", optional = true }
 bevy_sprite = { path = "../bevy_sprite", version = "0.17.0-dev", optional = true }
+bevy_sprite_render = { path = "../bevy_sprite_render", version = "0.17.0-dev", optional = true }
 bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
 bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
 bevy_light = { path = "../bevy_light", version = "0.17.0-dev" }
diff --git a/crates/bevy_gizmos/src/pipeline_2d.rs b/crates/bevy_gizmos/src/pipeline_2d.rs
index fd7f8bfcc1572..48cd53c4e1420 100644
--- a/crates/bevy_gizmos/src/pipeline_2d.rs
+++ b/crates/bevy_gizmos/src/pipeline_2d.rs
@@ -29,7 +29,7 @@ use bevy_render::{
 };
 use bevy_render::{sync_world::MainEntity, RenderStartup};
 use bevy_shader::Shader;
-use bevy_sprite::{
+use bevy_sprite_render::{
     init_mesh_2d_pipeline, Mesh2dPipeline, Mesh2dPipelineKey, SetMesh2dViewBindGroup,
 };
 use bevy_utils::default;
@@ -53,9 +53,11 @@ impl Plugin for LineGizmo2dPlugin {
                 Render,
                 GizmoRenderSystems::QueueLineGizmos2d
                     .in_set(RenderSystems::Queue)
-                    .ambiguous_with(bevy_sprite::queue_sprites)
+                    .ambiguous_with(bevy_sprite_render::queue_sprites)
                     .ambiguous_with(
-                        bevy_sprite::queue_material2d_meshes::<bevy_sprite::ColorMaterial>,
+                        bevy_sprite_render::queue_material2d_meshes::<
+                            bevy_sprite_render::ColorMaterial,
+                        >,
                     ),
             )
             .add_systems(
diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index f7b98bef606ac..26197fddaffa2 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -172,7 +172,7 @@ webgl = [
   "bevy_pbr?/webgl",
   "bevy_render?/webgl",
   "bevy_gizmos?/webgl",
-  "bevy_sprite?/webgl",
+  "bevy_sprite_render?/webgl",
 ]
 
 webgpu = [
@@ -181,7 +181,7 @@ webgpu = [
   "bevy_pbr?/webgpu",
   "bevy_render?/webgpu",
   "bevy_gizmos?/webgpu",
-  "bevy_sprite?/webgpu",
+  "bevy_sprite_render?/webgpu",
 ]
 
 # enable systems that allow for automated testing on CI
@@ -190,7 +190,13 @@ bevy_ci_testing = ["bevy_dev_tools/bevy_ci_testing", "bevy_render?/ci_limits"]
 # Enable animation support, and glTF animation loading
 animation = ["bevy_animation", "bevy_gltf?/bevy_animation"]
 
-bevy_sprite = ["dep:bevy_sprite", "bevy_gizmos?/bevy_sprite", "bevy_image"]
+bevy_sprite = ["dep:bevy_sprite", "bevy_image"]
+bevy_sprite_render = [
+  "bevy_sprite",
+  "dep:bevy_sprite_render",
+  "bevy_gizmos?/bevy_sprite",
+  "bevy_gizmos?/bevy_sprite_render",
+]
 bevy_pbr = [
   "dep:bevy_pbr",
   "bevy_gizmos?/bevy_pbr",
@@ -461,6 +467,7 @@ bevy_render = { path = "../bevy_render", optional = true, version = "0.17.0-dev"
 bevy_scene = { path = "../bevy_scene", optional = true, version = "0.17.0-dev" }
 bevy_solari = { path = "../bevy_solari", optional = true, version = "0.17.0-dev" }
 bevy_sprite = { path = "../bevy_sprite", optional = true, version = "0.17.0-dev" }
+bevy_sprite_render = { path = "../bevy_sprite_render", optional = true, version = "0.17.0-dev" }
 bevy_state = { path = "../bevy_state", optional = true, version = "0.17.0-dev", default-features = false, features = [
   "bevy_app",
   "bevy_reflect",
diff --git a/crates/bevy_internal/src/default_plugins.rs b/crates/bevy_internal/src/default_plugins.rs
index 5a7b4773e4d4a..53101792b6b31 100644
--- a/crates/bevy_internal/src/default_plugins.rs
+++ b/crates/bevy_internal/src/default_plugins.rs
@@ -42,6 +42,8 @@ plugin_group! {
         bevy_anti_aliasing:::AntiAliasingPlugin,
         #[cfg(feature = "bevy_sprite")]
         bevy_sprite:::SpritePlugin,
+        #[cfg(feature = "bevy_sprite_render")]
+        bevy_sprite_render:::SpriteRenderingPlugin,
         #[cfg(feature = "bevy_text")]
         bevy_text:::TextPlugin,
         #[cfg(feature = "bevy_ui")]
diff --git a/crates/bevy_internal/src/lib.rs b/crates/bevy_internal/src/lib.rs
index 67b1e465e715f..9d8458397f663 100644
--- a/crates/bevy_internal/src/lib.rs
+++ b/crates/bevy_internal/src/lib.rs
@@ -78,6 +78,8 @@ pub use bevy_shader as shader;
 pub use bevy_solari as solari;
 #[cfg(feature = "bevy_sprite")]
 pub use bevy_sprite as sprite;
+#[cfg(feature = "bevy_sprite_render")]
+pub use bevy_sprite_render as sprite_render;
 #[cfg(feature = "bevy_state")]
 pub use bevy_state as state;
 pub use bevy_tasks as tasks;
diff --git a/crates/bevy_internal/src/prelude.rs b/crates/bevy_internal/src/prelude.rs
index e1be8d70cebb3..ea4a306d0a6d6 100644
--- a/crates/bevy_internal/src/prelude.rs
+++ b/crates/bevy_internal/src/prelude.rs
@@ -67,6 +67,10 @@ pub use crate::scene::prelude::*;
 #[cfg(feature = "bevy_sprite")]
 pub use crate::sprite::prelude::*;
 
+#[doc(hidden)]
+#[cfg(feature = "bevy_sprite_render")]
+pub use crate::sprite_render::prelude::*;
+
 #[doc(hidden)]
 #[cfg(feature = "bevy_text")]
 pub use crate::text::prelude::*;
diff --git a/crates/bevy_sprite/Cargo.toml b/crates/bevy_sprite/Cargo.toml
index b675bde5c05a5..d0ea9b6e51578 100644
--- a/crates/bevy_sprite/Cargo.toml
+++ b/crates/bevy_sprite/Cargo.toml
@@ -10,40 +10,26 @@ keywords = ["bevy"]
 
 [features]
 bevy_sprite_picking_backend = ["bevy_picking", "bevy_window"]
-webgl = []
-webgpu = []
 
 [dependencies]
 # bevy
 bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
 bevy_asset = { path = "../bevy_asset", version = "0.17.0-dev" }
 bevy_color = { path = "../bevy_color", version = "0.17.0-dev" }
-bevy_core_pipeline = { path = "../bevy_core_pipeline", version = "0.17.0-dev" }
 bevy_ecs = { path = "../bevy_ecs", version = "0.17.0-dev" }
 bevy_image = { path = "../bevy_image", version = "0.17.0-dev" }
 bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
-bevy_mesh = { path = "../bevy_mesh", version = "0.17.0-dev" }
 bevy_math = { path = "../bevy_math", version = "0.17.0-dev" }
-bevy_shader = { path = "../bevy_shader", version = "0.17.0-dev" }
 bevy_picking = { path = "../bevy_picking", version = "0.17.0-dev", optional = true }
 bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
-bevy_render = { path = "../bevy_render", version = "0.17.0-dev" }
 bevy_transform = { path = "../bevy_transform", version = "0.17.0-dev" }
-bevy_utils = { path = "../bevy_utils", version = "0.17.0-dev" }
 bevy_window = { path = "../bevy_window", version = "0.17.0-dev", optional = true }
 bevy_derive = { path = "../bevy_derive", version = "0.17.0-dev" }
-bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev", default-features = false, features = [
-  "std",
-] }
 
 # other
-bytemuck = { version = "1", features = ["derive", "must_cast"] }
-fixedbitset = "0.5"
-derive_more = { version = "2", default-features = false, features = ["from"] }
-bitflags = "2.3"
 radsort = "0.1"
-nonmax = "0.5"
 tracing = { version = "0.1", default-features = false, features = ["std"] }
+wgpu-types = { version = "26", default-features = false }
 
 [lints]
 workspace = true
diff --git a/crates/bevy_sprite/src/lib.rs b/crates/bevy_sprite/src/lib.rs
index 434e5d4b5ce1d..500ebdf778a3f 100644
--- a/crates/bevy_sprite/src/lib.rs
+++ b/crates/bevy_sprite/src/lib.rs
@@ -6,17 +6,14 @@
     html_favicon_url = "https://bevy.org/assets/icon.png"
 )]
 
-//! Provides 2D sprite rendering functionality.
+//! Provides 2D sprite functionality.
 
 extern crate alloc;
 
-mod mesh2d;
 #[cfg(feature = "bevy_sprite_picking_backend")]
 mod picking_backend;
-mod render;
 mod sprite;
 mod texture_slice;
-mod tilemap_chunk;
 
 /// The sprite prelude.
 ///
@@ -31,36 +28,20 @@ pub mod prelude {
     pub use crate::{
         sprite::{Sprite, SpriteImageMode},
         texture_slice::{BorderRect, SliceScaleMode, TextureSlice, TextureSlicer},
-        ColorMaterial, MeshMaterial2d, ScalingMode,
+        ScalingMode,
     };
 }
 
-use bevy_camera::{
-    primitives::{Aabb, MeshAabb as _},
-    visibility::{NoFrustumCulling, VisibilitySystems},
-};
-use bevy_shader::load_shader_library;
-pub use mesh2d::*;
 #[cfg(feature = "bevy_sprite_picking_backend")]
 pub use picking_backend::*;
-pub use render::*;
 pub use sprite::*;
 pub use texture_slice::*;
-pub use tilemap_chunk::*;
 
 use bevy_app::prelude::*;
-use bevy_asset::{embedded_asset, AssetEventSystems, Assets};
-use bevy_core_pipeline::core_2d::{AlphaMask2d, Opaque2d, Transparent2d};
 use bevy_ecs::prelude::*;
-use bevy_image::{prelude::*, TextureAtlasPlugin};
-use bevy_mesh::{Mesh, Mesh2d};
-use bevy_render::{
-    batching::sort_binned_render_phase, render_phase::AddRenderCommand,
-    render_resource::SpecializedRenderPipelines, ExtractSchedule, Render, RenderApp, RenderStartup,
-    RenderSystems,
-};
+use bevy_image::TextureAtlasPlugin;
 
-/// Adds support for 2D sprite rendering.
+/// Adds support for 2D sprites.
 #[derive(Default)]
 pub struct SpritePlugin;
 
@@ -77,272 +58,11 @@ pub type SpriteSystem = SpriteSystems;
 
 impl Plugin for SpritePlugin {
     fn build(&self, app: &mut App) {
-        load_shader_library!(app, "render/sprite_view_bindings.wgsl");
-
-        embedded_asset!(app, "render/sprite.wgsl");
-
         if !app.is_plugin_added::<TextureAtlasPlugin>() {
             app.add_plugins(TextureAtlasPlugin);
         }
 
-        app.add_plugins((
-            Mesh2dRenderPlugin,
-            ColorMaterialPlugin,
-            TilemapChunkPlugin,
-            TilemapChunkMaterialPlugin,
-        ))
-        .add_systems(
-            PostUpdate,
-            (
-                calculate_bounds_2d.in_set(VisibilitySystems::CalculateBounds),
-                (
-                    compute_slices_on_asset_event.before(AssetEventSystems),
-                    compute_slices_on_sprite_change,
-                )
-                    .in_set(SpriteSystems::ComputeSlices),
-            ),
-        );
-
         #[cfg(feature = "bevy_sprite_picking_backend")]
         app.add_plugins(SpritePickingPlugin);
-
-        if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
-            render_app
-                .init_resource::<ImageBindGroups>()
-                .init_resource::<SpecializedRenderPipelines<SpritePipeline>>()
-                .init_resource::<SpriteMeta>()
-                .init_resource::<ExtractedSprites>()
-                .init_resource::<ExtractedSlices>()
-                .init_resource::<SpriteAssetEvents>()
-                .init_resource::<SpriteBatches>()
-                .add_render_command::<Transparent2d, DrawSprite>()
-                .add_systems(RenderStartup, init_sprite_pipeline)
-                .add_systems(
-                    ExtractSchedule,
-                    (
-                        extract_sprites.in_set(SpriteSystems::ExtractSprites),
-                        extract_sprite_events,
-                    ),
-                )
-                .add_systems(
-                    Render,
-                    (
-                        queue_sprites
-                            .in_set(RenderSystems::Queue)
-                            .ambiguous_with(queue_material2d_meshes::<ColorMaterial>),
-                        prepare_sprite_image_bind_groups.in_set(RenderSystems::PrepareBindGroups),
-                        prepare_sprite_view_bind_groups.in_set(RenderSystems::PrepareBindGroups),
-                        sort_binned_render_phase::<Opaque2d>.in_set(RenderSystems::PhaseSort),
-                        sort_binned_render_phase::<AlphaMask2d>.in_set(RenderSystems::PhaseSort),
-                    ),
-                );
-        };
-    }
-}
-
-/// System calculating and inserting an [`Aabb`] component to entities with either:
-/// - a `Mesh2d` component,
-/// - a `Sprite` and `Handle<Image>` components,
-///   and without a [`NoFrustumCulling`] component.
-///
-/// Used in system set [`VisibilitySystems::CalculateBounds`].
-pub fn calculate_bounds_2d(
-    mut commands: Commands,
-    meshes: Res<Assets<Mesh>>,
-    images: Res<Assets<Image>>,
-    atlases: Res<Assets<TextureAtlasLayout>>,
-    meshes_without_aabb: Query<(Entity, &Mesh2d), (Without<Aabb>, Without<NoFrustumCulling>)>,
-    sprites_to_recalculate_aabb: Query<
-        (Entity, &Sprite, &Anchor),
-        (
-            Or<(Without<Aabb>, Changed<Sprite>, Changed<Anchor>)>,
-            Without<NoFrustumCulling>,
-        ),
-    >,
-) {
-    for (entity, mesh_handle) in &meshes_without_aabb {
-        if let Some(mesh) = meshes.get(&mesh_handle.0)
-            && let Some(aabb) = mesh.compute_aabb()
-        {
-            commands.entity(entity).try_insert(aabb);
-        }
-    }
-    for (entity, sprite, anchor) in &sprites_to_recalculate_aabb {
-        if let Some(size) = sprite
-            .custom_size
-            .or_else(|| sprite.rect.map(|rect| rect.size()))
-            .or_else(|| match &sprite.texture_atlas {
-                // We default to the texture size for regular sprites
-                None => images.get(&sprite.image).map(Image::size_f32),
-                // We default to the drawn rect for atlas sprites
-                Some(atlas) => atlas
-                    .texture_rect(&atlases)
-                    .map(|rect| rect.size().as_vec2()),
-            })
-        {
-            let aabb = Aabb {
-                center: (-anchor.as_vec() * size).extend(0.0).into(),
-                half_extents: (0.5 * size).extend(0.0).into(),
-            };
-            commands.entity(entity).try_insert(aabb);
-        }
-    }
-}
-
-#[cfg(test)]
-mod test {
-
-    use bevy_math::{Rect, Vec2, Vec3A};
-    use bevy_utils::default;
-
-    use super::*;
-
-    #[test]
-    fn calculate_bounds_2d_create_aabb_for_image_sprite_entity() {
-        // Setup app
-        let mut app = App::new();
-
-        // Add resources and get handle to image
-        let mut image_assets = Assets::<Image>::default();
-        let image_handle = image_assets.add(Image::default());
-        app.insert_resource(image_assets);
-        let mesh_assets = Assets::<Mesh>::default();
-        app.insert_resource(mesh_assets);
-        let texture_atlas_assets = Assets::<TextureAtlasLayout>::default();
-        app.insert_resource(texture_atlas_assets);
-
-        // Add system
-        app.add_systems(Update, calculate_bounds_2d);
-
-        // Add entities
-        let entity = app.world_mut().spawn(Sprite::from_image(image_handle)).id();
-
-        // Verify that the entity does not have an AABB
-        assert!(!app
-            .world()
-            .get_entity(entity)
-            .expect("Could not find entity")
-            .contains::<Aabb>());
-
-        // Run system
-        app.update();
-
-        // Verify the AABB exists
-        assert!(app
-            .world()
-            .get_entity(entity)
-            .expect("Could not find entity")
-            .contains::<Aabb>());
-    }
-
-    #[test]
-    fn calculate_bounds_2d_update_aabb_when_sprite_custom_size_changes_to_some() {
-        // Setup app
-        let mut app = App::new();
-
-        // Add resources and get handle to image
-        let mut image_assets = Assets::<Image>::default();
-        let image_handle = image_assets.add(Image::default());
-        app.insert_resource(image_assets);
-        let mesh_assets = Assets::<Mesh>::default();
-        app.insert_resource(mesh_assets);
-        let texture_atlas_assets = Assets::<TextureAtlasLayout>::default();
-        app.insert_resource(texture_atlas_assets);
-
-        // Add system
-        app.add_systems(Update, calculate_bounds_2d);
-
-        // Add entities
-        let entity = app
-            .world_mut()
-            .spawn(Sprite {
-                custom_size: Some(Vec2::ZERO),
-                image: image_handle,
-                ..default()
-            })
-            .id();
-
-        // Create initial AABB
-        app.update();
-
-        // Get the initial AABB
-        let first_aabb = *app
-            .world()
-            .get_entity(entity)
-            .expect("Could not find entity")
-            .get::<Aabb>()
-            .expect("Could not find initial AABB");
-
-        // Change `custom_size` of sprite
-        let mut binding = app
-            .world_mut()
-            .get_entity_mut(entity)
-            .expect("Could not find entity");
-        let mut sprite = binding
-            .get_mut::<Sprite>()
-            .expect("Could not find sprite component of entity");
-        sprite.custom_size = Some(Vec2::ONE);
-
-        // Re-run the `calculate_bounds_2d` system to get the new AABB
-        app.update();
-
-        // Get the re-calculated AABB
-        let second_aabb = *app
-            .world()
-            .get_entity(entity)
-            .expect("Could not find entity")
-            .get::<Aabb>()
-            .expect("Could not find second AABB");
-
-        // Check that the AABBs are not equal
-        assert_ne!(first_aabb, second_aabb);
-    }
-
-    #[test]
-    fn calculate_bounds_2d_correct_aabb_for_sprite_with_custom_rect() {
-        // Setup app
-        let mut app = App::new();
-
-        // Add resources and get handle to image
-        let mut image_assets = Assets::<Image>::default();
-        let image_handle = image_assets.add(Image::default());
-        app.insert_resource(image_assets);
-        let mesh_assets = Assets::<Mesh>::default();
-        app.insert_resource(mesh_assets);
-        let texture_atlas_assets = Assets::<TextureAtlasLayout>::default();
-        app.insert_resource(texture_atlas_assets);
-
-        // Add system
-        app.add_systems(Update, calculate_bounds_2d);
-
-        // Add entities
-        let entity = app
-            .world_mut()
-            .spawn((
-                Sprite {
-                    rect: Some(Rect::new(0., 0., 0.5, 1.)),
-                    image: image_handle,
-                    ..default()
-                },
-                Anchor::TOP_RIGHT,
-            ))
-            .id();
-
-        // Create AABB
-        app.update();
-
-        // Get the AABB
-        let aabb = *app
-            .world_mut()
-            .get_entity(entity)
-            .expect("Could not find entity")
-            .get::<Aabb>()
-            .expect("Could not find AABB");
-
-        // Verify that the AABB is at the expected position
-        assert_eq!(aabb.center, Vec3A::new(-0.25, -0.5, 0.));
-
-        // Verify that the AABB has the expected size
-        assert_eq!(aabb.half_extents, Vec3A::new(0.25, 0.5, 0.));
     }
 }
diff --git a/crates/bevy_sprite/src/mesh2d/mesh2d_view_types.wgsl b/crates/bevy_sprite/src/mesh2d/mesh2d_view_types.wgsl
deleted file mode 100644
index 7868a05d40ff8..0000000000000
--- a/crates/bevy_sprite/src/mesh2d/mesh2d_view_types.wgsl
+++ /dev/null
@@ -1,4 +0,0 @@
-#define_import_path bevy_sprite::mesh2d_view_types
-
-#import bevy_render::view
-#import bevy_render::globals
diff --git a/crates/bevy_sprite/src/sprite.rs b/crates/bevy_sprite/src/sprite.rs
index 47bbb18390cb9..065effa8d494b 100644
--- a/crates/bevy_sprite/src/sprite.rs
+++ b/crates/bevy_sprite/src/sprite.rs
@@ -6,14 +6,13 @@ use bevy_ecs::{component::Component, reflect::ReflectComponent};
 use bevy_image::{Image, TextureAtlas, TextureAtlasLayout};
 use bevy_math::{Rect, UVec2, Vec2};
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
-use bevy_render::sync_world::SyncToRenderWorld;
 use bevy_transform::components::Transform;
 
 use crate::TextureSlicer;
 
 /// Describes a sprite to be rendered to a 2D camera
 #[derive(Component, Debug, Default, Clone, Reflect)]
-#[require(Transform, Visibility, SyncToRenderWorld, VisibilityClass, Anchor)]
+#[require(Transform, Visibility, VisibilityClass, Anchor)]
 #[reflect(Component, Default, Debug, Clone)]
 #[component(on_add = visibility::add_visibility_class::<Sprite>)]
 pub struct Sprite {
@@ -282,7 +281,7 @@ mod tests {
     use bevy_image::{Image, ToExtents};
     use bevy_image::{TextureAtlas, TextureAtlasLayout};
     use bevy_math::{Rect, URect, UVec2, Vec2};
-    use bevy_render::render_resource::{TextureDimension, TextureFormat};
+    use wgpu_types::{TextureDimension, TextureFormat};
 
     use crate::Anchor;
 
diff --git a/crates/bevy_sprite/src/texture_slice/mod.rs b/crates/bevy_sprite/src/texture_slice/mod.rs
index 7b1a1e33e2168..3fb1549f15fb9 100644
--- a/crates/bevy_sprite/src/texture_slice/mod.rs
+++ b/crates/bevy_sprite/src/texture_slice/mod.rs
@@ -1,15 +1,10 @@
 mod border_rect;
-mod computed_slices;
 mod slicer;
 
 use bevy_math::{Rect, Vec2};
 pub use border_rect::BorderRect;
 pub use slicer::{SliceScaleMode, TextureSlicer};
 
-pub(crate) use computed_slices::{
-    compute_slices_on_asset_event, compute_slices_on_sprite_change, ComputedTextureSlices,
-};
-
 /// Single texture slice, representing a texture rect to draw in a given area
 #[derive(Debug, Clone, PartialEq)]
 pub struct TextureSlice {
diff --git a/crates/bevy_sprite_render/Cargo.toml b/crates/bevy_sprite_render/Cargo.toml
new file mode 100644
index 0000000000000..08113f7051849
--- /dev/null
+++ b/crates/bevy_sprite_render/Cargo.toml
@@ -0,0 +1,50 @@
+[package]
+name = "bevy_sprite_render"
+version = "0.17.0-dev"
+edition = "2024"
+description = "Provides sprite rendering functionality for Bevy Engine"
+homepage = "https://bevy.org"
+repository = "https://github.com/bevyengine/bevy"
+license = "MIT OR Apache-2.0"
+keywords = ["bevy"]
+
+[features]
+webgl = []
+webgpu = []
+
+[dependencies]
+# bevy
+bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
+bevy_asset = { path = "../bevy_asset", version = "0.17.0-dev" }
+bevy_color = { path = "../bevy_color", version = "0.17.0-dev" }
+bevy_core_pipeline = { path = "../bevy_core_pipeline", version = "0.17.0-dev" }
+bevy_ecs = { path = "../bevy_ecs", version = "0.17.0-dev" }
+bevy_image = { path = "../bevy_image", version = "0.17.0-dev" }
+bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
+bevy_mesh = { path = "../bevy_mesh", version = "0.17.0-dev" }
+bevy_math = { path = "../bevy_math", version = "0.17.0-dev" }
+bevy_shader = { path = "../bevy_shader", version = "0.17.0-dev" }
+bevy_sprite = { path = "../bevy_sprite", version = "0.17.0-dev" }
+bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
+bevy_render = { path = "../bevy_render", version = "0.17.0-dev" }
+bevy_transform = { path = "../bevy_transform", version = "0.17.0-dev" }
+bevy_utils = { path = "../bevy_utils", version = "0.17.0-dev" }
+bevy_derive = { path = "../bevy_derive", version = "0.17.0-dev" }
+bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev", default-features = false, features = [
+  "std",
+] }
+
+# other
+bytemuck = { version = "1", features = ["derive", "must_cast"] }
+fixedbitset = "0.5"
+derive_more = { version = "2", default-features = false, features = ["from"] }
+bitflags = "2.3"
+nonmax = "0.5"
+tracing = { version = "0.1", default-features = false, features = ["std"] }
+
+[lints]
+workspace = true
+
+[package.metadata.docs.rs]
+rustdoc-args = ["-Zunstable-options", "--generate-link-to-definition"]
+all-features = true
diff --git a/crates/bevy_sprite_render/LICENSE-APACHE b/crates/bevy_sprite_render/LICENSE-APACHE
new file mode 100644
index 0000000000000..d9a10c0d8e868
--- /dev/null
+++ b/crates/bevy_sprite_render/LICENSE-APACHE
@@ -0,0 +1,176 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
diff --git a/crates/bevy_sprite_render/LICENSE-MIT b/crates/bevy_sprite_render/LICENSE-MIT
new file mode 100644
index 0000000000000..9cf106272ac3b
--- /dev/null
+++ b/crates/bevy_sprite_render/LICENSE-MIT
@@ -0,0 +1,19 @@
+MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/crates/bevy_sprite_render/README.md b/crates/bevy_sprite_render/README.md
new file mode 100644
index 0000000000000..cd9d201616ffb
--- /dev/null
+++ b/crates/bevy_sprite_render/README.md
@@ -0,0 +1,7 @@
+# Bevy Sprite
+
+[![License](https://img.shields.io/badge/license-MIT%2FApache-blue.svg)](https://github.com/bevyengine/bevy#license)
+[![Crates.io](https://img.shields.io/crates/v/bevy_sprite_render.svg)](https://crates.io/crates/bevy_sprite_render)
+[![Downloads](https://img.shields.io/crates/d/bevy_sprite_render.svg)](https://crates.io/crates/bevy_sprite_render)
+[![Docs](https://docs.rs/bevy_sprite_render/badge.svg)](https://docs.rs/bevy_sprite_render/latest/bevy_sprite_render/)
+[![Discord](https://img.shields.io/discord/691052431525675048.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/bevy)
diff --git a/crates/bevy_sprite_render/src/lib.rs b/crates/bevy_sprite_render/src/lib.rs
new file mode 100644
index 0000000000000..d1a119cebd2a4
--- /dev/null
+++ b/crates/bevy_sprite_render/src/lib.rs
@@ -0,0 +1,333 @@
+#![expect(missing_docs, reason = "Not all docs are written yet, see #3492.")]
+#![cfg_attr(docsrs, feature(doc_auto_cfg))]
+#![forbid(unsafe_code)]
+#![doc(
+    html_logo_url = "https://bevy.org/assets/icon.png",
+    html_favicon_url = "https://bevy.org/assets/icon.png"
+)]
+
+//! Provides 2D sprite rendering functionality.
+
+extern crate alloc;
+
+mod mesh2d;
+mod render;
+mod texture_slice;
+mod tilemap_chunk;
+
+/// The sprite prelude.
+///
+/// This includes the most common types in this crate, re-exported for your convenience.
+pub mod prelude {
+    #[doc(hidden)]
+    pub use crate::{ColorMaterial, MeshMaterial2d};
+}
+
+use bevy_camera::{
+    primitives::{Aabb, MeshAabb as _},
+    visibility::{NoFrustumCulling, VisibilitySystems},
+};
+use bevy_shader::load_shader_library;
+pub use mesh2d::*;
+pub use render::*;
+pub(crate) use texture_slice::*;
+pub use tilemap_chunk::*;
+
+use bevy_app::prelude::*;
+use bevy_asset::{embedded_asset, AssetEventSystems, Assets};
+use bevy_core_pipeline::core_2d::{AlphaMask2d, Opaque2d, Transparent2d};
+use bevy_ecs::prelude::*;
+use bevy_image::{prelude::*, TextureAtlasPlugin};
+use bevy_mesh::{Mesh, Mesh2d};
+use bevy_render::{
+    batching::sort_binned_render_phase, render_phase::AddRenderCommand,
+    render_resource::SpecializedRenderPipelines, sync_world::SyncToRenderWorld, ExtractSchedule,
+    Render, RenderApp, RenderStartup, RenderSystems,
+};
+use bevy_sprite::{Anchor, Sprite};
+
+/// Adds support for 2D sprite rendering.
+#[derive(Default)]
+pub struct SpriteRenderingPlugin;
+
+/// System set for sprite rendering.
+#[derive(Debug, Hash, PartialEq, Eq, Clone, SystemSet)]
+pub enum SpriteSystems {
+    ExtractSprites,
+    ComputeSlices,
+}
+
+/// Deprecated alias for [`SpriteSystems`].
+#[deprecated(since = "0.17.0", note = "Renamed to `SpriteSystems`.")]
+pub type SpriteSystem = SpriteSystems;
+
+impl Plugin for SpriteRenderingPlugin {
+    fn build(&self, app: &mut App) {
+        load_shader_library!(app, "render/sprite_view_bindings.wgsl");
+
+        embedded_asset!(app, "render/sprite.wgsl");
+
+        if !app.is_plugin_added::<TextureAtlasPlugin>() {
+            app.add_plugins(TextureAtlasPlugin);
+        }
+
+        app.add_plugins((
+            Mesh2dRenderPlugin,
+            ColorMaterialPlugin,
+            TilemapChunkPlugin,
+            TilemapChunkMaterialPlugin,
+        ))
+        .add_systems(
+            PostUpdate,
+            (
+                calculate_bounds_2d.in_set(VisibilitySystems::CalculateBounds),
+                (
+                    compute_slices_on_asset_event.before(AssetEventSystems),
+                    compute_slices_on_sprite_change,
+                )
+                    .in_set(SpriteSystems::ComputeSlices),
+            ),
+        );
+
+        app.register_required_components::<Sprite, SyncToRenderWorld>();
+
+        if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
+            render_app
+                .init_resource::<ImageBindGroups>()
+                .init_resource::<SpecializedRenderPipelines<SpritePipeline>>()
+                .init_resource::<SpriteMeta>()
+                .init_resource::<ExtractedSprites>()
+                .init_resource::<ExtractedSlices>()
+                .init_resource::<SpriteAssetEvents>()
+                .init_resource::<SpriteBatches>()
+                .add_render_command::<Transparent2d, DrawSprite>()
+                .add_systems(RenderStartup, init_sprite_pipeline)
+                .add_systems(
+                    ExtractSchedule,
+                    (
+                        extract_sprites.in_set(SpriteSystems::ExtractSprites),
+                        extract_sprite_events,
+                    ),
+                )
+                .add_systems(
+                    Render,
+                    (
+                        queue_sprites
+                            .in_set(RenderSystems::Queue)
+                            .ambiguous_with(queue_material2d_meshes::<ColorMaterial>),
+                        prepare_sprite_image_bind_groups.in_set(RenderSystems::PrepareBindGroups),
+                        prepare_sprite_view_bind_groups.in_set(RenderSystems::PrepareBindGroups),
+                        sort_binned_render_phase::<Opaque2d>.in_set(RenderSystems::PhaseSort),
+                        sort_binned_render_phase::<AlphaMask2d>.in_set(RenderSystems::PhaseSort),
+                    ),
+                );
+        };
+    }
+}
+
+/// System calculating and inserting an [`Aabb`] component to entities with either:
+/// - a `Mesh2d` component,
+/// - a `Sprite` and `Handle<Image>` components,
+///   and without a [`NoFrustumCulling`] component.
+///
+/// Used in system set [`VisibilitySystems::CalculateBounds`].
+pub fn calculate_bounds_2d(
+    mut commands: Commands,
+    meshes: Res<Assets<Mesh>>,
+    images: Res<Assets<Image>>,
+    atlases: Res<Assets<TextureAtlasLayout>>,
+    meshes_without_aabb: Query<(Entity, &Mesh2d), (Without<Aabb>, Without<NoFrustumCulling>)>,
+    sprites_to_recalculate_aabb: Query<
+        (Entity, &Sprite, &Anchor),
+        (
+            Or<(Without<Aabb>, Changed<Sprite>, Changed<Anchor>)>,
+            Without<NoFrustumCulling>,
+        ),
+    >,
+) {
+    for (entity, mesh_handle) in &meshes_without_aabb {
+        if let Some(mesh) = meshes.get(&mesh_handle.0)
+            && let Some(aabb) = mesh.compute_aabb()
+        {
+            commands.entity(entity).try_insert(aabb);
+        }
+    }
+    for (entity, sprite, anchor) in &sprites_to_recalculate_aabb {
+        if let Some(size) = sprite
+            .custom_size
+            .or_else(|| sprite.rect.map(|rect| rect.size()))
+            .or_else(|| match &sprite.texture_atlas {
+                // We default to the texture size for regular sprites
+                None => images.get(&sprite.image).map(Image::size_f32),
+                // We default to the drawn rect for atlas sprites
+                Some(atlas) => atlas
+                    .texture_rect(&atlases)
+                    .map(|rect| rect.size().as_vec2()),
+            })
+        {
+            let aabb = Aabb {
+                center: (-anchor.as_vec() * size).extend(0.0).into(),
+                half_extents: (0.5 * size).extend(0.0).into(),
+            };
+            commands.entity(entity).try_insert(aabb);
+        }
+    }
+}
+
+#[cfg(test)]
+mod test {
+
+    use bevy_math::{Rect, Vec2, Vec3A};
+    use bevy_utils::default;
+
+    use super::*;
+
+    #[test]
+    fn calculate_bounds_2d_create_aabb_for_image_sprite_entity() {
+        // Setup app
+        let mut app = App::new();
+
+        // Add resources and get handle to image
+        let mut image_assets = Assets::<Image>::default();
+        let image_handle = image_assets.add(Image::default());
+        app.insert_resource(image_assets);
+        let mesh_assets = Assets::<Mesh>::default();
+        app.insert_resource(mesh_assets);
+        let texture_atlas_assets = Assets::<TextureAtlasLayout>::default();
+        app.insert_resource(texture_atlas_assets);
+
+        // Add system
+        app.add_systems(Update, calculate_bounds_2d);
+
+        // Add entities
+        let entity = app.world_mut().spawn(Sprite::from_image(image_handle)).id();
+
+        // Verify that the entity does not have an AABB
+        assert!(!app
+            .world()
+            .get_entity(entity)
+            .expect("Could not find entity")
+            .contains::<Aabb>());
+
+        // Run system
+        app.update();
+
+        // Verify the AABB exists
+        assert!(app
+            .world()
+            .get_entity(entity)
+            .expect("Could not find entity")
+            .contains::<Aabb>());
+    }
+
+    #[test]
+    fn calculate_bounds_2d_update_aabb_when_sprite_custom_size_changes_to_some() {
+        // Setup app
+        let mut app = App::new();
+
+        // Add resources and get handle to image
+        let mut image_assets = Assets::<Image>::default();
+        let image_handle = image_assets.add(Image::default());
+        app.insert_resource(image_assets);
+        let mesh_assets = Assets::<Mesh>::default();
+        app.insert_resource(mesh_assets);
+        let texture_atlas_assets = Assets::<TextureAtlasLayout>::default();
+        app.insert_resource(texture_atlas_assets);
+
+        // Add system
+        app.add_systems(Update, calculate_bounds_2d);
+
+        // Add entities
+        let entity = app
+            .world_mut()
+            .spawn(Sprite {
+                custom_size: Some(Vec2::ZERO),
+                image: image_handle,
+                ..default()
+            })
+            .id();
+
+        // Create initial AABB
+        app.update();
+
+        // Get the initial AABB
+        let first_aabb = *app
+            .world()
+            .get_entity(entity)
+            .expect("Could not find entity")
+            .get::<Aabb>()
+            .expect("Could not find initial AABB");
+
+        // Change `custom_size` of sprite
+        let mut binding = app
+            .world_mut()
+            .get_entity_mut(entity)
+            .expect("Could not find entity");
+        let mut sprite = binding
+            .get_mut::<Sprite>()
+            .expect("Could not find sprite component of entity");
+        sprite.custom_size = Some(Vec2::ONE);
+
+        // Re-run the `calculate_bounds_2d` system to get the new AABB
+        app.update();
+
+        // Get the re-calculated AABB
+        let second_aabb = *app
+            .world()
+            .get_entity(entity)
+            .expect("Could not find entity")
+            .get::<Aabb>()
+            .expect("Could not find second AABB");
+
+        // Check that the AABBs are not equal
+        assert_ne!(first_aabb, second_aabb);
+    }
+
+    #[test]
+    fn calculate_bounds_2d_correct_aabb_for_sprite_with_custom_rect() {
+        // Setup app
+        let mut app = App::new();
+
+        // Add resources and get handle to image
+        let mut image_assets = Assets::<Image>::default();
+        let image_handle = image_assets.add(Image::default());
+        app.insert_resource(image_assets);
+        let mesh_assets = Assets::<Mesh>::default();
+        app.insert_resource(mesh_assets);
+        let texture_atlas_assets = Assets::<TextureAtlasLayout>::default();
+        app.insert_resource(texture_atlas_assets);
+
+        // Add system
+        app.add_systems(Update, calculate_bounds_2d);
+
+        // Add entities
+        let entity = app
+            .world_mut()
+            .spawn((
+                Sprite {
+                    rect: Some(Rect::new(0., 0., 0.5, 1.)),
+                    image: image_handle,
+                    ..default()
+                },
+                Anchor::TOP_RIGHT,
+            ))
+            .id();
+
+        // Create AABB
+        app.update();
+
+        // Get the AABB
+        let aabb = *app
+            .world_mut()
+            .get_entity(entity)
+            .expect("Could not find entity")
+            .get::<Aabb>()
+            .expect("Could not find AABB");
+
+        // Verify that the AABB is at the expected position
+        assert_eq!(aabb.center, Vec3A::new(-0.25, -0.5, 0.));
+
+        // Verify that the AABB has the expected size
+        assert_eq!(aabb.half_extents, Vec3A::new(0.25, 0.5, 0.));
+    }
+}
diff --git a/crates/bevy_sprite/src/mesh2d/color_material.rs b/crates/bevy_sprite_render/src/mesh2d/color_material.rs
similarity index 98%
rename from crates/bevy_sprite/src/mesh2d/color_material.rs
rename to crates/bevy_sprite_render/src/mesh2d/color_material.rs
index ee5ef79fa6094..052be3186012d 100644
--- a/crates/bevy_sprite/src/mesh2d/color_material.rs
+++ b/crates/bevy_sprite_render/src/mesh2d/color_material.rs
@@ -87,7 +87,7 @@ impl From<Handle<Image>> for ColorMaterial {
     }
 }
 
-// NOTE: These must match the bit flags in bevy_sprite/src/mesh2d/color_material.wgsl!
+// NOTE: These must match the bit flags in bevy_sprite_render/src/mesh2d/color_material.wgsl!
 bitflags::bitflags! {
     #[repr(transparent)]
     pub struct ColorMaterialFlags: u32 {
diff --git a/crates/bevy_sprite/src/mesh2d/color_material.wgsl b/crates/bevy_sprite_render/src/mesh2d/color_material.wgsl
similarity index 98%
rename from crates/bevy_sprite/src/mesh2d/color_material.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/color_material.wgsl
index bb3972426bbe5..c969977bbc67f 100644
--- a/crates/bevy_sprite/src/mesh2d/color_material.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/color_material.wgsl
@@ -1,4 +1,4 @@
-#import bevy_sprite::{
+#import bevy_sprite_render::{
     mesh2d_vertex_output::VertexOutput,
     mesh2d_view_bindings::view,
 }
diff --git a/crates/bevy_sprite/src/mesh2d/material.rs b/crates/bevy_sprite_render/src/mesh2d/material.rs
similarity index 99%
rename from crates/bevy_sprite/src/mesh2d/material.rs
rename to crates/bevy_sprite_render/src/mesh2d/material.rs
index 9a1954688f4d5..947aece96b1f7 100644
--- a/crates/bevy_sprite/src/mesh2d/material.rs
+++ b/crates/bevy_sprite_render/src/mesh2d/material.rs
@@ -66,7 +66,7 @@ pub const MATERIAL_2D_BIND_GROUP_INDEX: usize = 2;
 /// check out the [`AsBindGroup`] documentation.
 ///
 /// ```
-/// # use bevy_sprite::{Material2d, MeshMaterial2d};
+/// # use bevy_sprite_render::{Material2d, MeshMaterial2d};
 /// # use bevy_ecs::prelude::*;
 /// # use bevy_image::Image;
 /// # use bevy_reflect::TypePath;
@@ -172,7 +172,7 @@ pub trait Material2d: AsBindGroup + Asset + Clone + Sized {
 /// # Example
 ///
 /// ```
-/// # use bevy_sprite::{ColorMaterial, MeshMaterial2d};
+/// # use bevy_sprite_render::{ColorMaterial, MeshMaterial2d};
 /// # use bevy_ecs::prelude::*;
 /// # use bevy_mesh::{Mesh, Mesh2d};
 /// # use bevy_color::palettes::basic::RED;
diff --git a/crates/bevy_sprite/src/mesh2d/mesh.rs b/crates/bevy_sprite_render/src/mesh2d/mesh.rs
similarity index 99%
rename from crates/bevy_sprite/src/mesh2d/mesh.rs
rename to crates/bevy_sprite_render/src/mesh2d/mesh.rs
index 9f494fec614ec..9a44bbfadd8f2 100644
--- a/crates/bevy_sprite/src/mesh2d/mesh.rs
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh.rs
@@ -221,7 +221,7 @@ impl Mesh2dUniform {
     }
 }
 
-// NOTE: These must match the bit flags in bevy_sprite/src/mesh2d/mesh2d.wgsl!
+// NOTE: These must match the bit flags in bevy_sprite_render/src/mesh2d/mesh2d.wgsl!
 bitflags::bitflags! {
     #[repr(transparent)]
     pub struct MeshFlags: u32 {
diff --git a/crates/bevy_sprite/src/mesh2d/mesh2d.wgsl b/crates/bevy_sprite_render/src/mesh2d/mesh2d.wgsl
similarity index 98%
rename from crates/bevy_sprite/src/mesh2d/mesh2d.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/mesh2d.wgsl
index e909608be8ba1..b5f0b45ae97ea 100644
--- a/crates/bevy_sprite/src/mesh2d/mesh2d.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh2d.wgsl
@@ -1,4 +1,4 @@
-#import bevy_sprite::{
+#import bevy_sprite_render::{
     mesh2d_functions as mesh_functions,
     mesh2d_vertex_output::VertexOutput,
     mesh2d_view_bindings::view,
diff --git a/crates/bevy_sprite/src/mesh2d/mesh2d_bindings.wgsl b/crates/bevy_sprite_render/src/mesh2d/mesh2d_bindings.wgsl
similarity index 68%
rename from crates/bevy_sprite/src/mesh2d/mesh2d_bindings.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/mesh2d_bindings.wgsl
index fc2bf643d5437..5f24007da573d 100644
--- a/crates/bevy_sprite/src/mesh2d/mesh2d_bindings.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh2d_bindings.wgsl
@@ -1,6 +1,6 @@
-#define_import_path bevy_sprite::mesh2d_bindings
+#define_import_path bevy_sprite_render::mesh2d_bindings
 
-#import bevy_sprite::mesh2d_types::Mesh2d
+#import bevy_sprite_render::mesh2d_types::Mesh2d
 
 #ifdef PER_OBJECT_BUFFER_BATCH_SIZE
 @group(1) @binding(0) var<uniform> mesh: array<Mesh2d, #{PER_OBJECT_BUFFER_BATCH_SIZE}u>;
diff --git a/crates/bevy_sprite/src/mesh2d/mesh2d_functions.wgsl b/crates/bevy_sprite_render/src/mesh2d/mesh2d_functions.wgsl
similarity index 94%
rename from crates/bevy_sprite/src/mesh2d/mesh2d_functions.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/mesh2d_functions.wgsl
index dbd73fb171f3f..7564514f77297 100644
--- a/crates/bevy_sprite/src/mesh2d/mesh2d_functions.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh2d_functions.wgsl
@@ -1,6 +1,6 @@
-#define_import_path bevy_sprite::mesh2d_functions
+#define_import_path bevy_sprite_render::mesh2d_functions
 
-#import bevy_sprite::{
+#import bevy_sprite_render::{
     mesh2d_view_bindings::view,
     mesh2d_bindings::mesh,
 }
diff --git a/crates/bevy_sprite/src/mesh2d/mesh2d_types.wgsl b/crates/bevy_sprite_render/src/mesh2d/mesh2d_types.wgsl
similarity index 91%
rename from crates/bevy_sprite/src/mesh2d/mesh2d_types.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/mesh2d_types.wgsl
index e29264e0bf4f3..f7aeee0cd4231 100644
--- a/crates/bevy_sprite/src/mesh2d/mesh2d_types.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh2d_types.wgsl
@@ -1,4 +1,4 @@
-#define_import_path bevy_sprite::mesh2d_types
+#define_import_path bevy_sprite_render::mesh2d_types
 
 struct Mesh2d {
     // Affine 4x3 matrix transposed to 3x4
diff --git a/crates/bevy_sprite/src/mesh2d/mesh2d_vertex_output.wgsl b/crates/bevy_sprite_render/src/mesh2d/mesh2d_vertex_output.wgsl
similarity index 88%
rename from crates/bevy_sprite/src/mesh2d/mesh2d_vertex_output.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/mesh2d_vertex_output.wgsl
index c7839caffeebb..32e5363024f13 100644
--- a/crates/bevy_sprite/src/mesh2d/mesh2d_vertex_output.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh2d_vertex_output.wgsl
@@ -1,4 +1,4 @@
-#define_import_path bevy_sprite::mesh2d_vertex_output
+#define_import_path bevy_sprite_render::mesh2d_vertex_output
 
 struct VertexOutput {
     // this is `clip position` when the struct is used as a vertex stage output 
diff --git a/crates/bevy_sprite/src/mesh2d/mesh2d_view_bindings.wgsl b/crates/bevy_sprite_render/src/mesh2d/mesh2d_view_bindings.wgsl
similarity index 82%
rename from crates/bevy_sprite/src/mesh2d/mesh2d_view_bindings.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/mesh2d_view_bindings.wgsl
index cc43da65ce35c..cb3635a9a2a8d 100644
--- a/crates/bevy_sprite/src/mesh2d/mesh2d_view_bindings.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh2d_view_bindings.wgsl
@@ -1,4 +1,4 @@
-#define_import_path bevy_sprite::mesh2d_view_bindings
+#define_import_path bevy_sprite_render::mesh2d_view_bindings
 
 #import bevy_render::view::View
 #import bevy_render::globals::Globals
diff --git a/crates/bevy_sprite_render/src/mesh2d/mesh2d_view_types.wgsl b/crates/bevy_sprite_render/src/mesh2d/mesh2d_view_types.wgsl
new file mode 100644
index 0000000000000..2b7b55b676cea
--- /dev/null
+++ b/crates/bevy_sprite_render/src/mesh2d/mesh2d_view_types.wgsl
@@ -0,0 +1,4 @@
+#define_import_path bevy_sprite_render::mesh2d_view_types
+
+#import bevy_render::view
+#import bevy_render::globals
diff --git a/crates/bevy_sprite/src/mesh2d/mod.rs b/crates/bevy_sprite_render/src/mesh2d/mod.rs
similarity index 100%
rename from crates/bevy_sprite/src/mesh2d/mod.rs
rename to crates/bevy_sprite_render/src/mesh2d/mod.rs
diff --git a/crates/bevy_sprite/src/mesh2d/wireframe2d.rs b/crates/bevy_sprite_render/src/mesh2d/wireframe2d.rs
similarity index 100%
rename from crates/bevy_sprite/src/mesh2d/wireframe2d.rs
rename to crates/bevy_sprite_render/src/mesh2d/wireframe2d.rs
diff --git a/crates/bevy_sprite/src/mesh2d/wireframe2d.wgsl b/crates/bevy_sprite_render/src/mesh2d/wireframe2d.wgsl
similarity index 76%
rename from crates/bevy_sprite/src/mesh2d/wireframe2d.wgsl
rename to crates/bevy_sprite_render/src/mesh2d/wireframe2d.wgsl
index c7bb3aa791b18..bc24e47c28fd3 100644
--- a/crates/bevy_sprite/src/mesh2d/wireframe2d.wgsl
+++ b/crates/bevy_sprite_render/src/mesh2d/wireframe2d.wgsl
@@ -1,4 +1,4 @@
-#import bevy_sprite::mesh2d_vertex_output::VertexOutput
+#import bevy_sprite_render::mesh2d_vertex_output::VertexOutput
 
 struct PushConstants {
     color: vec4<f32>
diff --git a/crates/bevy_sprite/src/render/mod.rs b/crates/bevy_sprite_render/src/render/mod.rs
similarity index 99%
rename from crates/bevy_sprite/src/render/mod.rs
rename to crates/bevy_sprite_render/src/render/mod.rs
index e24b5fb0482a1..788c372327e4e 100644
--- a/crates/bevy_sprite/src/render/mod.rs
+++ b/crates/bevy_sprite_render/src/render/mod.rs
@@ -1,6 +1,6 @@
 use core::ops::Range;
 
-use crate::{Anchor, ComputedTextureSlices, ScalingMode, Sprite};
+use crate::ComputedTextureSlices;
 use bevy_asset::{load_embedded_asset, AssetEvent, AssetId, AssetServer, Assets, Handle};
 use bevy_camera::visibility::ViewVisibility;
 use bevy_color::{ColorToComponents, LinearRgba};
@@ -39,6 +39,7 @@ use bevy_render::{
     Extract,
 };
 use bevy_shader::{Shader, ShaderDefVal};
+use bevy_sprite::{Anchor, ScalingMode, Sprite};
 use bevy_transform::components::GlobalTransform;
 use bevy_utils::default;
 use bytemuck::{Pod, Zeroable};
@@ -856,7 +857,7 @@ pub fn prepare_sprite_image_bind_groups(
             // The sprite shader can then use the two least significant bits as the vertex index.
             // The rest of the properties to transform the vertex positions and UVs (which are
             // implicit) are baked into the instance transform, and UV offset and scale.
-            // See bevy_sprite/src/render/sprite.wgsl for the details.
+            // See bevy_sprite_render/src/render/sprite.wgsl for the details.
             sprite_meta.sprite_index_buffer.push(2);
             sprite_meta.sprite_index_buffer.push(0);
             sprite_meta.sprite_index_buffer.push(1);
diff --git a/crates/bevy_sprite/src/render/sprite.wgsl b/crates/bevy_sprite_render/src/render/sprite.wgsl
similarity index 96%
rename from crates/bevy_sprite/src/render/sprite.wgsl
rename to crates/bevy_sprite_render/src/render/sprite.wgsl
index 03e43d0d5b5a3..f82332c02d630 100644
--- a/crates/bevy_sprite/src/render/sprite.wgsl
+++ b/crates/bevy_sprite_render/src/render/sprite.wgsl
@@ -7,7 +7,7 @@
     view::View,
 }
 
-#import bevy_sprite::sprite_view_bindings::view
+#import bevy_sprite_render::sprite_view_bindings::view
 
 struct VertexInput {
     @builtin(vertex_index) index: u32,
diff --git a/crates/bevy_sprite/src/render/sprite_view_bindings.wgsl b/crates/bevy_sprite_render/src/render/sprite_view_bindings.wgsl
similarity index 75%
rename from crates/bevy_sprite/src/render/sprite_view_bindings.wgsl
rename to crates/bevy_sprite_render/src/render/sprite_view_bindings.wgsl
index e3e990538c5f5..6826c0a8c5031 100644
--- a/crates/bevy_sprite/src/render/sprite_view_bindings.wgsl
+++ b/crates/bevy_sprite_render/src/render/sprite_view_bindings.wgsl
@@ -1,4 +1,4 @@
-#define_import_path bevy_sprite::sprite_view_bindings
+#define_import_path bevy_sprite_render::sprite_view_bindings
 
 #import bevy_render::view::View
 
diff --git a/crates/bevy_sprite/src/texture_slice/computed_slices.rs b/crates/bevy_sprite_render/src/texture_slice/computed_slices.rs
similarity index 98%
rename from crates/bevy_sprite/src/texture_slice/computed_slices.rs
rename to crates/bevy_sprite_render/src/texture_slice/computed_slices.rs
index d4972f03848fc..4011c2d34df65 100644
--- a/crates/bevy_sprite/src/texture_slice/computed_slices.rs
+++ b/crates/bevy_sprite_render/src/texture_slice/computed_slices.rs
@@ -1,10 +1,10 @@
-use super::TextureSlice;
-use crate::{ExtractedSlice, Sprite, SpriteImageMode, TextureAtlasLayout};
+use crate::{ExtractedSlice, TextureAtlasLayout};
 use bevy_asset::{AssetEvent, Assets};
 use bevy_ecs::prelude::*;
 use bevy_image::Image;
 use bevy_math::{Rect, Vec2};
 use bevy_platform::collections::HashSet;
+use bevy_sprite::{Sprite, SpriteImageMode, TextureSlice};
 
 /// Component storing texture slices for tiled or sliced sprite entities
 ///
diff --git a/crates/bevy_sprite_render/src/texture_slice/mod.rs b/crates/bevy_sprite_render/src/texture_slice/mod.rs
new file mode 100644
index 0000000000000..650e09f6cf49b
--- /dev/null
+++ b/crates/bevy_sprite_render/src/texture_slice/mod.rs
@@ -0,0 +1,5 @@
+mod computed_slices;
+
+pub(crate) use computed_slices::{
+    compute_slices_on_asset_event, compute_slices_on_sprite_change, ComputedTextureSlices,
+};
diff --git a/crates/bevy_sprite/src/tilemap_chunk/mod.rs b/crates/bevy_sprite_render/src/tilemap_chunk/mod.rs
similarity index 100%
rename from crates/bevy_sprite/src/tilemap_chunk/mod.rs
rename to crates/bevy_sprite_render/src/tilemap_chunk/mod.rs
diff --git a/crates/bevy_sprite/src/tilemap_chunk/tilemap_chunk_material.rs b/crates/bevy_sprite_render/src/tilemap_chunk/tilemap_chunk_material.rs
similarity index 100%
rename from crates/bevy_sprite/src/tilemap_chunk/tilemap_chunk_material.rs
rename to crates/bevy_sprite_render/src/tilemap_chunk/tilemap_chunk_material.rs
diff --git a/crates/bevy_sprite/src/tilemap_chunk/tilemap_chunk_material.wgsl b/crates/bevy_sprite_render/src/tilemap_chunk/tilemap_chunk_material.wgsl
similarity index 98%
rename from crates/bevy_sprite/src/tilemap_chunk/tilemap_chunk_material.wgsl
rename to crates/bevy_sprite_render/src/tilemap_chunk/tilemap_chunk_material.wgsl
index a1442aa006f9a..b6bf1321f256a 100644
--- a/crates/bevy_sprite/src/tilemap_chunk/tilemap_chunk_material.wgsl
+++ b/crates/bevy_sprite_render/src/tilemap_chunk/tilemap_chunk_material.wgsl
@@ -1,4 +1,4 @@
-#import bevy_sprite::{
+#import bevy_sprite_render::{
     mesh2d_functions as mesh_functions,
     mesh2d_view_bindings::view,
     mesh2d_vertex_output::VertexOutput,
diff --git a/crates/bevy_text/Cargo.toml b/crates/bevy_text/Cargo.toml
index e8b237f5e691d..50cd2f55c5e7b 100644
--- a/crates/bevy_text/Cargo.toml
+++ b/crates/bevy_text/Cargo.toml
@@ -23,7 +23,6 @@ bevy_log = { path = "../bevy_log", version = "0.17.0-dev" }
 bevy_math = { path = "../bevy_math", version = "0.17.0-dev" }
 bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
 bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
-bevy_render = { path = "../bevy_render", version = "0.17.0-dev" }
 bevy_sprite = { path = "../bevy_sprite", version = "0.17.0-dev" }
 bevy_transform = { path = "../bevy_transform", version = "0.17.0-dev" }
 bevy_window = { path = "../bevy_window", version = "0.17.0-dev" }
@@ -34,6 +33,7 @@ bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev", default-fea
 ] }
 
 # other
+wgpu-types = { version = "26", default-features = false }
 cosmic-text = { version = "0.14", features = ["shape-run-cache"] }
 thiserror = { version = "2", default-features = false }
 serde = { version = "1", features = ["derive"] }
diff --git a/crates/bevy_text/src/font_atlas.rs b/crates/bevy_text/src/font_atlas.rs
index 67a4703a59e2e..6cb03f4e66130 100644
--- a/crates/bevy_text/src/font_atlas.rs
+++ b/crates/bevy_text/src/font_atlas.rs
@@ -2,7 +2,7 @@ use bevy_asset::{Assets, Handle, RenderAssetUsages};
 use bevy_image::{prelude::*, ImageSampler, ToExtents};
 use bevy_math::{IVec2, UVec2};
 use bevy_platform::collections::HashMap;
-use bevy_render::render_resource::{TextureDimension, TextureFormat};
+use wgpu_types::{TextureDimension, TextureFormat};
 
 use crate::{FontSmoothing, GlyphAtlasLocation, TextError};
 
diff --git a/crates/bevy_text/src/font_atlas_set.rs b/crates/bevy_text/src/font_atlas_set.rs
index 7b3167cdc0abe..fd824041b4ac0 100644
--- a/crates/bevy_text/src/font_atlas_set.rs
+++ b/crates/bevy_text/src/font_atlas_set.rs
@@ -4,7 +4,7 @@ use bevy_image::prelude::*;
 use bevy_math::{IVec2, UVec2};
 use bevy_platform::collections::HashMap;
 use bevy_reflect::TypePath;
-use bevy_render::render_resource::{Extent3d, TextureDimension, TextureFormat};
+use wgpu_types::{Extent3d, TextureDimension, TextureFormat};
 
 use crate::{error::TextError, Font, FontAtlas, FontSmoothing, GlyphAtlasInfo};
 
diff --git a/crates/bevy_text/src/lib.rs b/crates/bevy_text/src/lib.rs
index 398e98fbc491c..b5b4381683b12 100644
--- a/crates/bevy_text/src/lib.rs
+++ b/crates/bevy_text/src/lib.rs
@@ -70,8 +70,6 @@ pub mod prelude {
 use bevy_app::{prelude::*, AnimationSystems};
 use bevy_asset::{AssetApp, AssetEventSystems};
 use bevy_ecs::prelude::*;
-use bevy_render::{ExtractSchedule, RenderApp};
-use bevy_sprite::SpriteSystems;
 
 /// The raw data for the default font used by `bevy_text`
 #[cfg(feature = "default_font")]
@@ -120,13 +118,6 @@ impl Plugin for TextPlugin {
             )
             .add_systems(Last, trim_cosmic_cache);
 
-        if let Some(render_app) = app.get_sub_app_mut(RenderApp) {
-            render_app.add_systems(
-                ExtractSchedule,
-                extract_text2d_sprite.after(SpriteSystems::ExtractSprites),
-            );
-        }
-
         #[cfg(feature = "default_font")]
         {
             use bevy_asset::{AssetId, Assets};
diff --git a/crates/bevy_text/src/text2d.rs b/crates/bevy_text/src/text2d.rs
index da17508dad14d..1b4c6923876ea 100644
--- a/crates/bevy_text/src/text2d.rs
+++ b/crates/bevy_text/src/text2d.rs
@@ -1,15 +1,13 @@
 use crate::pipeline::CosmicFontSystem;
 use crate::{
-    ComputedTextBlock, Font, FontAtlasSets, LineBreak, PositionedGlyph, SwashCache, TextBounds,
-    TextColor, TextError, TextFont, TextLayout, TextLayoutInfo, TextPipeline, TextReader, TextRoot,
+    ComputedTextBlock, Font, FontAtlasSets, LineBreak, SwashCache, TextBounds, TextColor,
+    TextError, TextFont, TextLayout, TextLayoutInfo, TextPipeline, TextReader, TextRoot,
     TextSpanAccess, TextWriter,
 };
 use bevy_asset::Assets;
 use bevy_camera::primitives::Aabb;
-use bevy_camera::visibility::{
-    self, NoFrustumCulling, ViewVisibility, Visibility, VisibilityClass,
-};
-use bevy_color::{Color, LinearRgba};
+use bevy_camera::visibility::{self, NoFrustumCulling, Visibility, VisibilityClass};
+use bevy_color::Color;
 use bevy_derive::{Deref, DerefMut};
 use bevy_ecs::entity::EntityHashSet;
 use bevy_ecs::{
@@ -23,13 +21,8 @@ use bevy_ecs::{
 use bevy_image::prelude::*;
 use bevy_math::{Vec2, Vec3};
 use bevy_reflect::{prelude::ReflectDefault, Reflect};
-use bevy_render::sync_world::TemporaryRenderEntity;
-use bevy_render::Extract;
-use bevy_sprite::{
-    Anchor, ExtractedSlice, ExtractedSlices, ExtractedSprite, ExtractedSprites, Sprite,
-};
+use bevy_sprite::{Anchor, Sprite};
 use bevy_transform::components::Transform;
-use bevy_transform::prelude::GlobalTransform;
 use bevy_window::{PrimaryWindow, Window};
 
 /// The top-level 2D text component.
@@ -154,174 +147,6 @@ impl Default for Text2dShadow {
     }
 }
 
-/// This system extracts the sprites from the 2D text components and adds them to the
-/// "render world".
-pub fn extract_text2d_sprite(
-    mut commands: Commands,
-    mut extracted_sprites: ResMut<ExtractedSprites>,
-    mut extracted_slices: ResMut<ExtractedSlices>,
-    texture_atlases: Extract<Res<Assets<TextureAtlasLayout>>>,
-    windows: Extract<Query<&Window, With<PrimaryWindow>>>,
-    text2d_query: Extract<
-        Query<(
-            Entity,
-            &ViewVisibility,
-            &ComputedTextBlock,
-            &TextLayoutInfo,
-            &TextBounds,
-            &Anchor,
-            Option<&Text2dShadow>,
-            &GlobalTransform,
-        )>,
-    >,
-    text_colors: Extract<Query<&TextColor>>,
-) {
-    let mut start = extracted_slices.slices.len();
-    let mut end = start + 1;
-
-    // TODO: Support window-independent scaling: https://github.com/bevyengine/bevy/issues/5621
-    let scale_factor = windows
-        .single()
-        .map(|window| window.resolution.scale_factor())
-        .unwrap_or(1.0);
-    let scaling = GlobalTransform::from_scale(Vec2::splat(scale_factor.recip()).extend(1.));
-
-    for (
-        main_entity,
-        view_visibility,
-        computed_block,
-        text_layout_info,
-        text_bounds,
-        anchor,
-        maybe_shadow,
-        global_transform,
-    ) in text2d_query.iter()
-    {
-        if !view_visibility.get() {
-            continue;
-        }
-
-        let size = Vec2::new(
-            text_bounds.width.unwrap_or(text_layout_info.size.x),
-            text_bounds.height.unwrap_or(text_layout_info.size.y),
-        );
-
-        let top_left = (Anchor::TOP_LEFT.0 - anchor.as_vec()) * size;
-
-        if let Some(shadow) = maybe_shadow {
-            let shadow_transform = *global_transform
-                * GlobalTransform::from_translation((top_left + shadow.offset).extend(0.))
-                * scaling;
-            let color = shadow.color.into();
-
-            for (
-                i,
-                PositionedGlyph {
-                    position,
-                    atlas_info,
-                    ..
-                },
-            ) in text_layout_info.glyphs.iter().enumerate()
-            {
-                let rect = texture_atlases
-                    .get(atlas_info.texture_atlas)
-                    .unwrap()
-                    .textures[atlas_info.location.glyph_index]
-                    .as_rect();
-                extracted_slices.slices.push(ExtractedSlice {
-                    offset: Vec2::new(position.x, -position.y),
-                    rect,
-                    size: rect.size(),
-                });
-
-                if text_layout_info
-                    .glyphs
-                    .get(i + 1)
-                    .is_none_or(|info| info.atlas_info.texture != atlas_info.texture)
-                {
-                    let render_entity = commands.spawn(TemporaryRenderEntity).id();
-                    extracted_sprites.sprites.push(ExtractedSprite {
-                        main_entity,
-                        render_entity,
-                        transform: shadow_transform,
-                        color,
-                        image_handle_id: atlas_info.texture,
-                        flip_x: false,
-                        flip_y: false,
-                        kind: bevy_sprite::ExtractedSpriteKind::Slices {
-                            indices: start..end,
-                        },
-                    });
-                    start = end;
-                }
-
-                end += 1;
-            }
-        }
-
-        let transform =
-            *global_transform * GlobalTransform::from_translation(top_left.extend(0.)) * scaling;
-        let mut color = LinearRgba::WHITE;
-        let mut current_span = usize::MAX;
-
-        for (
-            i,
-            PositionedGlyph {
-                position,
-                atlas_info,
-                span_index,
-                ..
-            },
-        ) in text_layout_info.glyphs.iter().enumerate()
-        {
-            if *span_index != current_span {
-                color = text_colors
-                    .get(
-                        computed_block
-                            .entities()
-                            .get(*span_index)
-                            .map(|t| t.entity)
-                            .unwrap_or(Entity::PLACEHOLDER),
-                    )
-                    .map(|text_color| LinearRgba::from(text_color.0))
-                    .unwrap_or_default();
-                current_span = *span_index;
-            }
-            let rect = texture_atlases
-                .get(atlas_info.texture_atlas)
-                .unwrap()
-                .textures[atlas_info.location.glyph_index]
-                .as_rect();
-            extracted_slices.slices.push(ExtractedSlice {
-                offset: Vec2::new(position.x, -position.y),
-                rect,
-                size: rect.size(),
-            });
-
-            if text_layout_info.glyphs.get(i + 1).is_none_or(|info| {
-                info.span_index != current_span || info.atlas_info.texture != atlas_info.texture
-            }) {
-                let render_entity = commands.spawn(TemporaryRenderEntity).id();
-                extracted_sprites.sprites.push(ExtractedSprite {
-                    main_entity,
-                    render_entity,
-                    transform,
-                    color,
-                    image_handle_id: atlas_info.texture,
-                    flip_x: false,
-                    flip_y: false,
-                    kind: bevy_sprite::ExtractedSpriteKind::Slices {
-                        indices: start..end,
-                    },
-                });
-                start = end;
-            }
-
-            end += 1;
-        }
-    }
-}
-
 /// Updates the layout and size information whenever the text or style is changed.
 /// This information is computed by the [`TextPipeline`] on insertion, then stored.
 ///
diff --git a/crates/bevy_ui_render/Cargo.toml b/crates/bevy_ui_render/Cargo.toml
index 8bb05d87c8f5a..455fc123ebc53 100644
--- a/crates/bevy_ui_render/Cargo.toml
+++ b/crates/bevy_ui_render/Cargo.toml
@@ -24,6 +24,7 @@ bevy_reflect = { path = "../bevy_reflect", version = "0.17.0-dev" }
 bevy_shader = { path = "../bevy_shader", version = "0.17.0-dev" }
 bevy_render = { path = "../bevy_render", version = "0.17.0-dev" }
 bevy_sprite = { path = "../bevy_sprite", version = "0.17.0-dev" }
+bevy_sprite_render = { path = "../bevy_sprite_render", version = "0.17.0-dev" }
 bevy_picking = { path = "../bevy_picking", version = "0.17.0-dev", optional = true }
 bevy_transform = { path = "../bevy_transform", version = "0.17.0-dev" }
 bevy_utils = { path = "../bevy_utils", version = "0.17.0-dev" }
@@ -32,6 +33,7 @@ bevy_platform = { path = "../bevy_platform", version = "0.17.0-dev", default-fea
 ] }
 bevy_ui = { path = "../bevy_ui", version = "0.17.0-dev" }
 bevy_text = { path = "../bevy_text", version = "0.17.0-dev", default-features = false }
+bevy_window = { path = "../bevy_window", version = "0.17.0-dev", default-features = false }
 
 # other
 bytemuck = { version = "1.5", features = ["derive"] }
diff --git a/crates/bevy_ui_render/src/lib.rs b/crates/bevy_ui_render/src/lib.rs
index f6a4524240ab4..16cd3a36128bb 100644
--- a/crates/bevy_ui_render/src/lib.rs
+++ b/crates/bevy_ui_render/src/lib.rs
@@ -11,10 +11,13 @@ pub mod box_shadow;
 mod gradient;
 mod pipeline;
 mod render_pass;
+mod text2d;
 pub mod ui_material;
 mod ui_material_pipeline;
 pub mod ui_texture_slice_pipeline;
 
+use text2d::extract_text2d_sprite;
+
 #[cfg(feature = "bevy_ui_debug")]
 mod debug_overlay;
 
@@ -52,7 +55,8 @@ use bevy_render::{
     view::{ExtractedView, Hdr, RetainedViewEntity, ViewUniforms},
     Extract, ExtractSchedule, Render, RenderApp, RenderStartup, RenderSystems,
 };
-use bevy_sprite::{BorderRect, SpriteAssetEvents};
+use bevy_sprite::{BorderRect, SpriteSystems};
+use bevy_sprite_render::SpriteAssetEvents;
 #[cfg(feature = "bevy_ui_debug")]
 pub use debug_overlay::UiDebugOptions;
 use gradient::GradientPlugin;
@@ -282,6 +286,11 @@ impl Plugin for UiRenderPlugin {
                 }
             });
 
+        render_app.add_systems(
+            ExtractSchedule,
+            extract_text2d_sprite.after(SpriteSystems::ExtractSprites),
+        );
+
         app.add_plugins(UiTextureSlicerPlugin);
         app.add_plugins(GradientPlugin);
         app.add_plugins(BoxShadowPlugin);
diff --git a/crates/bevy_ui_render/src/text2d.rs b/crates/bevy_ui_render/src/text2d.rs
new file mode 100644
index 0000000000000..c11c915b8c02c
--- /dev/null
+++ b/crates/bevy_ui_render/src/text2d.rs
@@ -0,0 +1,187 @@
+use bevy_asset::Assets;
+use bevy_camera::visibility::ViewVisibility;
+use bevy_color::LinearRgba;
+use bevy_ecs::{
+    entity::Entity,
+    prelude::With,
+    system::{Commands, Query, Res, ResMut},
+};
+use bevy_image::prelude::*;
+use bevy_math::Vec2;
+use bevy_render::sync_world::TemporaryRenderEntity;
+use bevy_render::Extract;
+use bevy_sprite::Anchor;
+use bevy_sprite_render::{ExtractedSlice, ExtractedSlices, ExtractedSprite, ExtractedSprites};
+use bevy_text::{
+    ComputedTextBlock, PositionedGlyph, Text2dShadow, TextBounds, TextColor, TextLayoutInfo,
+};
+use bevy_transform::prelude::GlobalTransform;
+use bevy_window::{PrimaryWindow, Window};
+
+/// This system extracts the sprites from the 2D text components and adds them to the
+/// "render world".
+pub fn extract_text2d_sprite(
+    mut commands: Commands,
+    mut extracted_sprites: ResMut<ExtractedSprites>,
+    mut extracted_slices: ResMut<ExtractedSlices>,
+    texture_atlases: Extract<Res<Assets<TextureAtlasLayout>>>,
+    windows: Extract<Query<&Window, With<PrimaryWindow>>>,
+    text2d_query: Extract<
+        Query<(
+            Entity,
+            &ViewVisibility,
+            &ComputedTextBlock,
+            &TextLayoutInfo,
+            &TextBounds,
+            &Anchor,
+            Option<&Text2dShadow>,
+            &GlobalTransform,
+        )>,
+    >,
+    text_colors: Extract<Query<&TextColor>>,
+) {
+    let mut start = extracted_slices.slices.len();
+    let mut end = start + 1;
+
+    // TODO: Support window-independent scaling: https://github.com/bevyengine/bevy/issues/5621
+    let scale_factor = windows
+        .single()
+        .map(|window| window.resolution.scale_factor())
+        .unwrap_or(1.0);
+    let scaling = GlobalTransform::from_scale(Vec2::splat(scale_factor.recip()).extend(1.));
+
+    for (
+        main_entity,
+        view_visibility,
+        computed_block,
+        text_layout_info,
+        text_bounds,
+        anchor,
+        maybe_shadow,
+        global_transform,
+    ) in text2d_query.iter()
+    {
+        if !view_visibility.get() {
+            continue;
+        }
+
+        let size = Vec2::new(
+            text_bounds.width.unwrap_or(text_layout_info.size.x),
+            text_bounds.height.unwrap_or(text_layout_info.size.y),
+        );
+
+        let top_left = (Anchor::TOP_LEFT.0 - anchor.as_vec()) * size;
+
+        if let Some(shadow) = maybe_shadow {
+            let shadow_transform = *global_transform
+                * GlobalTransform::from_translation((top_left + shadow.offset).extend(0.))
+                * scaling;
+            let color = shadow.color.into();
+
+            for (
+                i,
+                PositionedGlyph {
+                    position,
+                    atlas_info,
+                    ..
+                },
+            ) in text_layout_info.glyphs.iter().enumerate()
+            {
+                let rect = texture_atlases
+                    .get(atlas_info.texture_atlas)
+                    .unwrap()
+                    .textures[atlas_info.location.glyph_index]
+                    .as_rect();
+                extracted_slices.slices.push(ExtractedSlice {
+                    offset: Vec2::new(position.x, -position.y),
+                    rect,
+                    size: rect.size(),
+                });
+
+                if text_layout_info
+                    .glyphs
+                    .get(i + 1)
+                    .is_none_or(|info| info.atlas_info.texture != atlas_info.texture)
+                {
+                    let render_entity = commands.spawn(TemporaryRenderEntity).id();
+                    extracted_sprites.sprites.push(ExtractedSprite {
+                        main_entity,
+                        render_entity,
+                        transform: shadow_transform,
+                        color,
+                        image_handle_id: atlas_info.texture,
+                        flip_x: false,
+                        flip_y: false,
+                        kind: bevy_sprite_render::ExtractedSpriteKind::Slices {
+                            indices: start..end,
+                        },
+                    });
+                    start = end;
+                }
+
+                end += 1;
+            }
+        }
+
+        let transform =
+            *global_transform * GlobalTransform::from_translation(top_left.extend(0.)) * scaling;
+        let mut color = LinearRgba::WHITE;
+        let mut current_span = usize::MAX;
+
+        for (
+            i,
+            PositionedGlyph {
+                position,
+                atlas_info,
+                span_index,
+                ..
+            },
+        ) in text_layout_info.glyphs.iter().enumerate()
+        {
+            if *span_index != current_span {
+                color = text_colors
+                    .get(
+                        computed_block
+                            .entities()
+                            .get(*span_index)
+                            .map(|t| t.entity)
+                            .unwrap_or(Entity::PLACEHOLDER),
+                    )
+                    .map(|text_color| LinearRgba::from(text_color.0))
+                    .unwrap_or_default();
+                current_span = *span_index;
+            }
+            let rect = texture_atlases
+                .get(atlas_info.texture_atlas)
+                .unwrap()
+                .textures[atlas_info.location.glyph_index]
+                .as_rect();
+            extracted_slices.slices.push(ExtractedSlice {
+                offset: Vec2::new(position.x, -position.y),
+                rect,
+                size: rect.size(),
+            });
+
+            if text_layout_info.glyphs.get(i + 1).is_none_or(|info| {
+                info.span_index != current_span || info.atlas_info.texture != atlas_info.texture
+            }) {
+                let render_entity = commands.spawn(TemporaryRenderEntity).id();
+                extracted_sprites.sprites.push(ExtractedSprite {
+                    main_entity,
+                    render_entity,
+                    transform,
+                    color,
+                    image_handle_id: atlas_info.texture,
+                    flip_x: false,
+                    flip_y: false,
+                    kind: bevy_sprite_render::ExtractedSpriteKind::Slices {
+                        indices: start..end,
+                    },
+                });
+                start = end;
+            }
+
+            end += 1;
+        }
+    }
+}
diff --git a/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs b/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs
index 62000c5cd8cbb..62f15ea1c6dbf 100644
--- a/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs
+++ b/crates/bevy_ui_render/src/ui_texture_slice_pipeline.rs
@@ -25,7 +25,8 @@ use bevy_render::{
 };
 use bevy_render::{sync_world::MainEntity, RenderStartup};
 use bevy_shader::Shader;
-use bevy_sprite::{SliceScaleMode, SpriteAssetEvents, SpriteImageMode, TextureSlicer};
+use bevy_sprite::{SliceScaleMode, SpriteImageMode, TextureSlicer};
+use bevy_sprite_render::SpriteAssetEvents;
 use bevy_ui::widget;
 use bevy_utils::default;
 use binding_types::{sampler, texture_2d};
diff --git a/docs/cargo_features.md b/docs/cargo_features.md
index 967f1eaf5cd8f..e75a1693e61ff 100644
--- a/docs/cargo_features.md
+++ b/docs/cargo_features.md
@@ -34,6 +34,7 @@ The default feature set enables most of the expected features of a game engine,
 |bevy_scene|Provides scene functionality|
 |bevy_sprite|Provides sprite functionality|
 |bevy_sprite_picking_backend|Provides an implementation for picking sprites|
+|bevy_sprite_render|Provides sprite rendering functionality|
 |bevy_state|Enable built in global state machines|
 |bevy_text|Provides text functionality|
 |bevy_ui|A custom ECS-driven UI framework|
diff --git a/examples/2d/2d_shapes.rs b/examples/2d/2d_shapes.rs
index 03109baeee06e..a77882cd66143 100644
--- a/examples/2d/2d_shapes.rs
+++ b/examples/2d/2d_shapes.rs
@@ -15,7 +15,7 @@
 
 use bevy::prelude::*;
 #[cfg(not(target_arch = "wasm32"))]
-use bevy::sprite::{Wireframe2dConfig, Wireframe2dPlugin};
+use bevy::sprite_render::{Wireframe2dConfig, Wireframe2dPlugin};
 
 fn main() {
     let mut app = App::new();
diff --git a/examples/2d/custom_gltf_vertex_attribute.rs b/examples/2d/custom_gltf_vertex_attribute.rs
index 58d97dfe2a60a..cba292f7a1e5a 100644
--- a/examples/2d/custom_gltf_vertex_attribute.rs
+++ b/examples/2d/custom_gltf_vertex_attribute.rs
@@ -7,7 +7,7 @@ use bevy::{
     reflect::TypePath,
     render::render_resource::*,
     shader::ShaderRef,
-    sprite::{Material2d, Material2dKey, Material2dPlugin},
+    sprite_render::{Material2d, Material2dKey, Material2dPlugin},
 };
 
 /// This example uses a shader source file from the assets subdirectory
diff --git a/examples/2d/mesh2d_alpha_mode.rs b/examples/2d/mesh2d_alpha_mode.rs
index 60bb6ef3a6147..1e1df4a9ceb6e 100644
--- a/examples/2d/mesh2d_alpha_mode.rs
+++ b/examples/2d/mesh2d_alpha_mode.rs
@@ -4,7 +4,7 @@
 use bevy::{
     color::palettes::css::{BLUE, GREEN, WHITE},
     prelude::*,
-    sprite::AlphaMode2d,
+    sprite_render::AlphaMode2d,
 };
 
 fn main() {
diff --git a/examples/2d/mesh2d_manual.rs b/examples/2d/mesh2d_manual.rs
index f6af8e994b01b..8eb5c051c3deb 100644
--- a/examples/2d/mesh2d_manual.rs
+++ b/examples/2d/mesh2d_manual.rs
@@ -31,7 +31,7 @@ use bevy::{
         view::{ExtractedView, RenderVisibleEntities, ViewTarget},
         Extract, Render, RenderApp, RenderStartup, RenderSystems,
     },
-    sprite::{
+    sprite_render::{
         extract_mesh2d, init_mesh_2d_pipeline, DrawMesh2d, Material2dBindGroupId, Mesh2dPipeline,
         Mesh2dPipelineKey, Mesh2dTransforms, MeshFlags, RenderMesh2dInstance, SetMesh2dBindGroup,
         SetMesh2dViewBindGroup,
diff --git a/examples/2d/tilemap_chunk.rs b/examples/2d/tilemap_chunk.rs
index a7e30ee64eb44..ac2df4e26e577 100644
--- a/examples/2d/tilemap_chunk.rs
+++ b/examples/2d/tilemap_chunk.rs
@@ -2,7 +2,7 @@
 
 use bevy::{
     prelude::*,
-    sprite::{TileData, TilemapChunk, TilemapChunkTileData},
+    sprite_render::{TileData, TilemapChunk, TilemapChunkTileData},
 };
 use rand::{Rng, SeedableRng};
 use rand_chacha::ChaCha8Rng;
diff --git a/examples/2d/wireframe_2d.rs b/examples/2d/wireframe_2d.rs
index aac599fcb0dbe..0f02396a15416 100644
--- a/examples/2d/wireframe_2d.rs
+++ b/examples/2d/wireframe_2d.rs
@@ -16,7 +16,9 @@ use bevy::{
         settings::{RenderCreation, WgpuSettings},
         RenderPlugin,
     },
-    sprite::{NoWireframe2d, Wireframe2d, Wireframe2dColor, Wireframe2dConfig, Wireframe2dPlugin},
+    sprite_render::{
+        NoWireframe2d, Wireframe2d, Wireframe2dColor, Wireframe2dConfig, Wireframe2dPlugin,
+    },
 };
 
 fn main() {
diff --git a/examples/camera/2d_screen_shake.rs b/examples/camera/2d_screen_shake.rs
index d14fdc49eadcd..7fb9819446950 100644
--- a/examples/camera/2d_screen_shake.rs
+++ b/examples/camera/2d_screen_shake.rs
@@ -17,7 +17,7 @@
 
 use bevy::{
     input::common_conditions::input_just_pressed, math::ops::powf, prelude::*,
-    sprite::MeshMaterial2d,
+    sprite_render::MeshMaterial2d,
 };
 
 // Before we implement the code, let's quickly introduce the underlying constants.
diff --git a/examples/shader/shader_material_2d.rs b/examples/shader/shader_material_2d.rs
index 56e36fdb8cbbb..fc905c40539c4 100644
--- a/examples/shader/shader_material_2d.rs
+++ b/examples/shader/shader_material_2d.rs
@@ -5,7 +5,7 @@ use bevy::{
     reflect::TypePath,
     render::render_resource::AsBindGroup,
     shader::ShaderRef,
-    sprite::{AlphaMode2d, Material2d, Material2dPlugin},
+    sprite_render::{AlphaMode2d, Material2d, Material2dPlugin},
 };
 
 /// This example uses a shader source file from the assets subdirectory
diff --git a/examples/stress_tests/bevymark.rs b/examples/stress_tests/bevymark.rs
index a92a57ded5fa5..cfbad95952fc3 100644
--- a/examples/stress_tests/bevymark.rs
+++ b/examples/stress_tests/bevymark.rs
@@ -12,7 +12,7 @@ use bevy::{
     diagnostic::{DiagnosticsStore, FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin},
     prelude::*,
     render::render_resource::{Extent3d, TextureDimension, TextureFormat},
-    sprite::AlphaMode2d,
+    sprite_render::AlphaMode2d,
     window::{PresentMode, WindowResolution},
     winit::{UpdateMode, WinitSettings},
 };
