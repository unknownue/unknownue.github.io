+++
title = "#20710 use affine inverse in prepass"
date = "2025-08-23T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20710-en-20250823" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20710-zh-cn-20250823" }}
labels = ["A-Rendering"]
+++

# Title

## Basic Information
- **Title**: use affine inverse in prepass
- **PR Link**: https://github.com/bevyengine/bevy/pull/20710
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: A-Rendering, S-Needs-Review
- **Created**: 2025-08-22T08:33:42Z
- **Merged**: 2025-08-23T21:29:10Z
- **Merged By**: james7132

## Description Translation
**目标**
- 再次在可能的地方使用仿射逆变换

**解决方案**
- 由我实现

**测试**
- 延迟渲染示例

## The Story of This Pull Request

这个PR解决了Bevy渲染管线中矩阵运算的一个性能优化问题。在计算机图形学中，视图变换矩阵的逆运算是一个常见的计算需求，特别是在处理相机变换和投影变换时。

问题的核心在于之前的实现使用了完整的4x4矩阵求逆运算，而实际上相机变换矩阵属于仿射变换（affine transformation），具有更简单的数学结构和更高效的计算方法。仿射变换的逆可以通过更优化的方式计算，避免了完整的4x4矩阵求逆的开销。

开发者采用了直接的技术方案：将`GlobalTransform`的`to_matrix()`方法替换为`affine()`方法，并使用`Mat4::from(world_from_view.inverse())`来显式构造仿射逆变换矩阵。这种改变利用了仿射变换的数学特性，在保持相同功能的同时提高了计算效率。

在实现细节上，修改主要集中在两个函数中：`update_previous_view_data`和`prepare_previous_view_uniforms`。这两个函数负责处理视图数据的更新和前帧视图uniform的准备工作，是渲染管线的关键组成部分。

从技术角度看，这个优化有几个重要优势：
1. **性能提升**：仿射逆变换的计算比完整矩阵求逆更高效
2. **数值稳定性**：针对仿射变换的特化算法通常有更好的数值稳定性
3. **代码清晰性**：明确表达了变换的数学性质，使代码意图更清晰

这个修改是Bevy引擎持续性能优化的一部分，特别是在渲染管线这种对性能敏感的区域。虽然单个修改的收益可能不大，但在大规模渲染场景中，这类优化可以累积产生显著的效果。

测试方面，开发者使用了延迟渲染示例来验证修改的正确性，确保优化不会引入视觉差异或渲染错误。

## Visual Representation

```mermaid
graph TD
    A[GlobalTransform] --> B[affine()转换]
    B --> C[计算仿射逆变换]
    C --> D[构建Mat4矩阵]
    D --> E[PreviousViewData]
    E --> F[渲染管线使用]
```

## Key Files Changed

### `crates/bevy_pbr/src/prepass/mod.rs` (+7/-7)

这个文件包含了prepass相关的渲染逻辑，主要修改了两个函数中的矩阵计算方式。

**关键修改1：update_previous_view_data函数**
```rust
// 修改前：
let world_from_view = camera_transform.to_matrix();
let view_from_world = world_from_view.inverse();

// 修改后：
let world_from_view = camera_transform.affine();
let view_from_world = Mat4::from(world_from_view.inverse());
```

**关键修改2：prepare_previous_view_uniforms函数**
```rust
// 修改前：
let world_from_view = camera.world_from_view.to_matrix();
let view_from_world = world_from_view.inverse();

// 修改后：
let world_from_view = camera.world_from_view.affine();
let view_from_world = Mat4::from(world_from_view.inverse());
```

这些修改将完整的4x4矩阵求逆替换为更高效的仿射逆变换计算，同时保持相同的功能输出。

## Further Reading

1. **仿射变换与投影变换**：了解计算机图形学中的不同变换类型及其数学特性
2. **Bevy渲染管线架构**：理解Bevy的渲染系统如何组织和管理渲染资源
3. **性能优化模式**：学习游戏引擎中常见的性能优化技术和模式
4. **矩阵运算优化**：深入研究线性代数在实时图形中的应用和优化方法

# Full Code Diff
diff --git a/crates/bevy_pbr/src/prepass/mod.rs b/crates/bevy_pbr/src/prepass/mod.rs
index a06d15594d29f..69113359f5808 100644
--- a/crates/bevy_pbr/src/prepass/mod.rs
+++ b/crates/bevy_pbr/src/prepass/mod.rs
@@ -21,7 +21,7 @@ use bevy_ecs::{
         SystemParamItem,
     },
 };
-use bevy_math::{Affine3A, Vec4};
+use bevy_math::{Affine3A, Mat4, Vec4};
 use bevy_mesh::{Mesh, Mesh3d, MeshVertexBufferLayoutRef};
 use bevy_render::{
     alpha::AlphaMode,
@@ -201,15 +201,15 @@ pub fn update_previous_view_data(
     query: Query<(Entity, &Camera, &GlobalTransform), Or<(With<Camera3d>, With<ShadowView>)>>,
 ) {
     for (entity, camera, camera_transform) in &query {
-        let world_from_view = camera_transform.to_matrix();
-        let view_from_world = world_from_view.inverse();
+        let world_from_view = camera_transform.affine();
+        let view_from_world = Mat4::from(world_from_view.inverse());
         let view_from_clip = camera.clip_from_view().inverse();
 
         commands.entity(entity).try_insert(PreviousViewData {
             view_from_world,
             clip_from_world: camera.clip_from_view() * view_from_world,
             clip_from_view: camera.clip_from_view(),
-            world_from_clip: world_from_view * view_from_clip,
+            world_from_clip: Mat4::from(world_from_view) * view_from_clip,
             view_from_clip,
         });
     }
@@ -672,15 +672,15 @@ pub fn prepare_previous_view_uniforms(
         let prev_view_data = match maybe_previous_view_uniforms {
             Some(previous_view) => previous_view.clone(),
             None => {
-                let world_from_view = camera.world_from_view.to_matrix();
-                let view_from_world = world_from_view.inverse();
+                let world_from_view = camera.world_from_view.affine();
+                let view_from_world = Mat4::from(world_from_view.inverse());
                 let view_from_clip = camera.clip_from_view.inverse();
 
                 PreviousViewData {
                     view_from_world,
                     clip_from_world: camera.clip_from_view * view_from_world,
                     clip_from_view: camera.clip_from_view,
-                    world_from_clip: world_from_view * view_from_clip,
+                    world_from_clip: Mat4::from(world_from_view) * view_from_clip,
                     view_from_clip,
                 }
             }
```