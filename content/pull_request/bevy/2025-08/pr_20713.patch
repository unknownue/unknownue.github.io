diff --git a/benches/benches/bevy_picking/ray_mesh_intersection.rs b/benches/benches/bevy_picking/ray_mesh_intersection.rs
index e9fd0caf9f1e0..2f49a7a9145e7 100644
--- a/benches/benches/bevy_picking/ray_mesh_intersection.rs
+++ b/benches/benches/bevy_picking/ray_mesh_intersection.rs
@@ -2,7 +2,7 @@ use core::hint::black_box;
 use std::time::Duration;
 
 use benches::bench;
-use bevy_math::{Dir3, Mat4, Ray3d, Vec3};
+use bevy_math::{Affine3A, Dir3, Ray3d, Vec3};
 use bevy_picking::mesh_picking::ray_cast::{self, Backfaces};
 use criterion::{criterion_group, AxisScale, BenchmarkId, Criterion, PlotConfiguration};
 
@@ -103,8 +103,8 @@ impl Benchmarks {
         )
     }
 
-    fn mesh_to_world(&self) -> Mat4 {
-        Mat4::IDENTITY
+    fn mesh_to_world(&self) -> Affine3A {
+        Affine3A::IDENTITY
     }
 
     fn backface_culling(&self) -> Backfaces {
diff --git a/crates/bevy_picking/src/mesh_picking/ray_cast/intersections.rs b/crates/bevy_picking/src/mesh_picking/ray_cast/intersections.rs
index d521fe1213a6d..24c6effab046c 100644
--- a/crates/bevy_picking/src/mesh_picking/ray_cast/intersections.rs
+++ b/crates/bevy_picking/src/mesh_picking/ray_cast/intersections.rs
@@ -1,4 +1,4 @@
-use bevy_math::{bounding::Aabb3d, Dir3, Mat4, Ray3d, Vec2, Vec3, Vec3A};
+use bevy_math::{bounding::Aabb3d, Affine3A, Dir3, Ray3d, Vec2, Vec3, Vec3A};
 use bevy_mesh::{Indices, Mesh, PrimitiveTopology, VertexAttributeValues};
 use bevy_reflect::Reflect;
 
@@ -38,7 +38,7 @@ pub struct RayTriangleHit {
 /// Casts a ray on a mesh, and returns the intersection.
 pub(super) fn ray_intersection_over_mesh(
     mesh: &Mesh,
-    transform: &Mat4,
+    transform: &Affine3A,
     ray: Ray3d,
     cull: Backfaces,
 ) -> Option<RayMeshHit> {
@@ -74,7 +74,7 @@ pub(super) fn ray_intersection_over_mesh(
 /// Checks if a ray intersects a mesh, and returns the nearest intersection if one exists.
 pub fn ray_mesh_intersection<I>(
     ray: Ray3d,
-    mesh_transform: &Mat4,
+    mesh_transform: &Affine3A,
     positions: &[[f32; 3]],
     vertex_normals: Option<&[[f32; 3]]>,
     indices: Option<&[I]>,
@@ -285,7 +285,11 @@ fn ray_triangle_intersection(
 //       In our case, the ray is transformed to model space, which could involve scaling.
 /// Checks if the ray intersects with the AABB of a mesh, returning the distance to the point of intersection.
 /// The distance is zero if the ray starts inside the AABB.
-pub fn ray_aabb_intersection_3d(ray: Ray3d, aabb: &Aabb3d, model_to_world: &Mat4) -> Option<f32> {
+pub fn ray_aabb_intersection_3d(
+    ray: Ray3d,
+    aabb: &Aabb3d,
+    model_to_world: &Affine3A,
+) -> Option<f32> {
     // Transform the ray to model space
     let world_to_model = model_to_world.inverse();
     let ray_direction: Vec3A = world_to_model.transform_vector3a((*ray.direction).into());
@@ -351,7 +355,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_simple() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals = None;
         let indices: Option<&[u16]> = None;
@@ -373,7 +377,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_indices() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals = None;
         let indices: Option<&[u16]> = Some(&[0, 1, 2]);
@@ -395,7 +399,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_indices_vertex_normals() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals: Option<&[[f32; 3]]> =
             Some(&[[-1., 0., 0.], [-1., 0., 0.], [-1., 0., 0.]]);
@@ -418,7 +422,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_vertex_normals() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals: Option<&[[f32; 3]]> =
             Some(&[[-1., 0., 0.], [-1., 0., 0.], [-1., 0., 0.]]);
@@ -441,7 +445,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_missing_vertex_normals() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals: Option<&[[f32; 3]]> = Some(&[]);
         let indices: Option<&[u16]> = None;
@@ -463,7 +467,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_indices_missing_vertex_normals() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals: Option<&[[f32; 3]]> = Some(&[]);
         let indices: Option<&[u16]> = Some(&[0, 1, 2]);
@@ -485,7 +489,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_not_enough_indices() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals = None;
         let indices: Option<&[u16]> = Some(&[0]);
@@ -507,7 +511,7 @@ mod tests {
     #[test]
     fn ray_mesh_intersection_bad_indices() {
         let ray = Ray3d::new(Vec3::ZERO, Dir3::X);
-        let mesh_transform = GlobalTransform::IDENTITY.to_matrix();
+        let mesh_transform = GlobalTransform::IDENTITY.affine();
         let positions = &[V0, V1, V2];
         let vertex_normals = None;
         let indices: Option<&[u16]> = Some(&[0, 1, 3]);
diff --git a/crates/bevy_picking/src/mesh_picking/ray_cast/mod.rs b/crates/bevy_picking/src/mesh_picking/ray_cast/mod.rs
index f7e3a887f31cc..5fbcc370e1e98 100644
--- a/crates/bevy_picking/src/mesh_picking/ray_cast/mod.rs
+++ b/crates/bevy_picking/src/mesh_picking/ray_cast/mod.rs
@@ -236,7 +236,7 @@ impl<'w, 's> MeshRayCast<'w, 's> {
                     && let Some(distance) = ray_aabb_intersection_3d(
                         ray,
                         &Aabb3d::new(aabb.center, aabb.half_extents),
-                        &transform.to_matrix(),
+                        &transform.affine(),
                     )
                 {
                     aabb_hits_tx.send((FloatOrd(distance), entity)).ok();
@@ -290,7 +290,7 @@ impl<'w, 's> MeshRayCast<'w, 's> {
 
                 // Perform the actual ray cast.
                 let _ray_cast_guard = ray_cast_guard.enter();
-                let transform = transform.to_matrix();
+                let transform = transform.affine();
                 let intersection = ray_intersection_over_mesh(mesh, &transform, ray, backfaces);
 
                 if let Some(intersection) = intersection {
