diff --git a/Cargo.toml b/Cargo.toml
index 28612f1c0a516..bcdba11dce57d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -3405,6 +3405,17 @@ description = "Illustrates creating and updating a button"
 category = "UI (User Interface)"
 wasm = true
 
+[[example]]
+name = "ui_drag_and_drop"
+path = "examples/ui/ui_drag_and_drop.rs"
+doc-scrape-examples = true
+
+[package.metadata.example.ui_drag_and_drop]
+name = "UI Drag and Drop"
+description = "Demonstrates dragging and dropping UI nodes"
+category = "UI (User Interface)"
+wasm = true
+
 [[example]]
 name = "display_and_visibility"
 path = "examples/ui/display_and_visibility.rs"
diff --git a/examples/README.md b/examples/README.md
index 6b8cd0f25114b..433c00a3431ba 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -575,6 +575,7 @@ Example | Description
 [Text Debug](../examples/ui/text_debug.rs) | An example for debugging text layout
 [Text Wrap Debug](../examples/ui/text_wrap_debug.rs) | Demonstrates text wrapping
 [Transparency UI](../examples/ui/transparency_ui.rs) | Demonstrates transparency for UI
+[UI Drag and Drop](../examples/ui/ui_drag_and_drop.rs) | Demonstrates dragging and dropping UI nodes
 [UI Material](../examples/ui/ui_material.rs) | Demonstrates creating and using custom Ui materials
 [UI Scaling](../examples/ui/ui_scaling.rs) | Illustrates how to scale the UI
 [UI Texture Atlas](../examples/ui/ui_texture_atlas.rs) | Illustrates how to use TextureAtlases in UI
diff --git a/examples/ui/ui_drag_and_drop.rs b/examples/ui/ui_drag_and_drop.rs
new file mode 100644
index 0000000000000..fdaf8de0add07
--- /dev/null
+++ b/examples/ui/ui_drag_and_drop.rs
@@ -0,0 +1,102 @@
+//! Demonstrates dragging and dropping UI nodes
+
+use bevy::{prelude::*, winit::WinitSettings};
+
+fn main() {
+    App::new()
+        .add_plugins(DefaultPlugins)
+        // Only run the app when there is user input. This will significantly reduce CPU/GPU use.
+        .insert_resource(WinitSettings::desktop_app())
+        .add_systems(Startup, setup)
+        .run();
+}
+
+const COLUMNS: i16 = 10;
+const ROWS: i16 = 10;
+const TILE_SIZE: f32 = 40.;
+
+fn setup(mut commands: Commands) {
+    commands.spawn(Camera2d);
+    commands
+        .spawn((Node {
+            display: Display::Grid,
+            align_self: AlignSelf::Center,
+            justify_self: JustifySelf::Center,
+            ..Default::default()
+        }, Pickable::IGNORE, BackgroundColor(Color::srgb(0.4, 0.4, 0.4))))
+        .with_children(|parent| {
+            let tile_colors = [
+                Color::srgb(0.2, 0.2, 0.8),
+                Color::srgb(0.8, 0.2, 0.2)
+            ];
+            for column in 0..COLUMNS {
+                for row in 0..ROWS {
+                    let i = column + row * COLUMNS;
+                    let tile_color = tile_colors[((row % 2) + column) as usize % tile_colors.len()];
+                    let tile_border_color = tile_color.darker(0.025);
+                    parent
+                        .spawn((
+                            Node {
+                                width: Val::Px(TILE_SIZE),
+                                height: Val::Px(TILE_SIZE),
+                                border: UiRect::all(Val::Px(4.)),
+                                grid_row: GridPlacement::start(row + 1),
+                                grid_column: GridPlacement::start(column + 1),
+                                align_items: AlignItems::Center,
+                                justify_content: JustifyContent::Center,
+                                ..Default::default()
+                            },
+                            BorderColor::all(tile_border_color),
+                            BackgroundColor(tile_color),
+                            Outline {
+                                width: Val::Px(2.),
+                                offset: Val::ZERO,
+                                color: Color::NONE,
+                            },
+                            Pickable {
+                                should_block_lower: false,
+                                is_hoverable: true,
+                            },
+                            GlobalZIndex::default()
+                        ))
+                        .observe(move |on_over: On<Pointer<Over>>, mut query: Query<(&mut BackgroundColor, &mut BorderColor)>| {
+                            if let Ok((mut background_color, mut border_color)) = query.get_mut(on_over.entity()) {
+                                background_color.0 = tile_color.lighter(0.1);
+                                border_color.set_all(tile_border_color.lighter(0.1));
+                            }
+                        })
+                        .observe(move |on_out: On<Pointer<Out>>, mut query: Query<(&mut BackgroundColor, &mut BorderColor)>| {
+                            if let Ok((mut background_color, mut border_color)) = query.get_mut(on_out.entity()) {
+                                background_color.0 = tile_color;
+                                border_color.set_all(tile_border_color);
+                            }
+                        })
+                        .observe(|on_drag_start: On<Pointer<DragStart>>, mut query: Query<(&mut Outline, &mut GlobalZIndex)>| {
+                            if let Ok((mut outline, mut global_zindex, )) = query.get_mut(on_drag_start.entity()) {
+                                outline.color = Color::WHITE;
+                                global_zindex.0 = 1;
+                            }
+                        })
+                        .observe(|on_drag: On<Pointer<Drag>>, mut query: Query<&mut UiTransform>| {
+                            if let Ok(mut transform) = query.get_mut(on_drag.entity()) {
+                                transform.translation = Val2::px(on_drag.distance.x, on_drag.distance.y);
+                            }
+                        })
+                        .observe(move |on_drag_end: On<Pointer<DragEnd>>, mut query: Query<(&mut UiTransform, &mut Outline, &mut GlobalZIndex)>| {
+                            if let Ok((mut transform, mut outline, mut global_zindex)) = query.get_mut(on_drag_end.entity()) {
+                                transform.translation = Val2::ZERO;
+                                outline.color = Color::NONE;
+                                global_zindex.0 = 0;
+                            }
+                        })
+                        .observe(|on_drag_drop: On<Pointer<DragDrop>>, mut query: Query<&mut Node>| {
+                            if let Ok([mut a, mut b]) = query.get_many_mut([on_drag_drop.entity(), on_drag_drop.dropped]) {
+                                core::mem::swap(&mut a.grid_row, &mut b.grid_row);
+                                core::mem::swap(&mut a.grid_column, &mut b.grid_column);
+                            }
+                        })
+                        .with_child((Text::new(format!("{i}")), Pickable::IGNORE));
+                }
+            }
+        });
+}
