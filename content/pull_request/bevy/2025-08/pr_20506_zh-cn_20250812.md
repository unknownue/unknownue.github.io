+++
title = "#20506 Fix App::get_added_plugins not working inside finish and cleanup"
date = "2025-08-12T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20506-en-20250812" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20506-zh-cn-20250812" }}
+++

### 标题：修复 App::get_added_plugins 在 finish 和 cleanup 中的行为问题

## 基本信息
- **标题**: Fix App::get_added_plugins not working inside finish and cleanup
- **PR链接**: https://github.com/bevyengine/bevy/pull/20506
- **作者**: atlv24
- **状态**: 已合并
- **标签**: C-Bug, S-Ready-For-Final-Review, A-App
- **创建时间**: 2025-08-11T05:00:35Z
- **合并时间**: 2025-08-12T02:11:14Z
- **合并者**: alice-i-cecile

## 描述翻译
### 目标  
当在 finish 或 cleanup 内部调用时，此断言失败：  
```rs  
assert_eq!(  
    app.is_plugin_added::<ImagePlugin>(),  
    app.get_added_plugins::<ImagePlugin>().len() > 0  
);  
```  

### 解决方案  
- 使用逐个插件处理的"hokey pokey"方法  
- 采用 swap_remove 保持 O(1) 复杂度，处理后再交换回原位以保持插件顺序  

### 测试  
- 需要为此编写单元测试并记录其"hokey pokey"行为，尽管在 finish/cleanup 中有 self 参数的情况下，可能没人会调用 `get_added_plugins<Self>`  

---

## PR技术分析  

### 问题背景  
在 Bevy 的插件生命周期中，`finish()` 和 `cleanup()` 方法执行时存在一个关键问题：  
```rs  
let plugins = core::mem::take(&mut self.main_mut().plugin_registry);  
for plugin in &plugins {  
    plugin.finish(self);  // 此时插件注册表为空!  
}  
```  
原实现通过 `core::mem::take` 移除了整个插件注册表，导致在 `plugin.finish(app)` 或 `plugin.cleanup(app)` 内部调用 `app.get_added_plugins()` 时，注册表处于空状态。这与 `is_plugin_added()` 的行为不一致，引发逻辑错误。  

### 解决方案设计  
采用"hokey pokey"交换技术：  
1. 创建零大小类型(ZST)的占位插件 `HokeyPokey` 避免内存分配  
2. 遍历插件注册表索引而非直接获取所有权  
3. 对每个插件：  
   - 与占位插件交换位置（实际插件移入临时变量）  
   - 执行其 finish/cleanup 方法  
   - 交换回原位  

```mermaid  
graph LR  
A[调用finish/cleanup] --> B[遍历插件索引]  
B --> C[交换插件与HokeyPokey]  
C --> D[执行当前插件方法]  
D --> E[交换回原位]  
```  

### 关键技术实现  
**核心变更 in app.rs**:  
```rust  
// Before: 错误实现  
let plugins = core::mem::take(&mut self.main_mut().plugin_registry);  
for plugin in &plugins {  
    plugin.finish(self);  
}  

// After: 正确实现  
let mut hokeypokey: Box<dyn Plugin> = Box::new(HokeyPokey);  
for i in 0..self.main().plugin_registry.len() {  
    core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);  
    hokeypokey.finish(self);  
    core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);  
}  
```  
**优化点**:  
- 保持 O(1) 时间复杂度：使用索引访问避免集合重组  
- 顺序保留：交换操作维持原始插件顺序  
- 零分配：`HokeyPokey` 作为 ZST 不产生堆开销  

**sub_app.rs 同步修改**:  
相同逻辑应用于子应用：  
```rust  
let mut hokeypokey: Box<dyn Plugin> = Box::new(crate::HokeyPokey);  
for i in 0..self.plugin_registry.len() {  
    core::mem::swap(&mut self.plugin_registry[i], &mut hokeypokey);  
    self.run_as_app(|app| {  
        hokeypokey.cleanup(app);  
    });  
    core::mem::swap(&mut self.plugin_registry[i], &mut hokeypokey);  
}  
```  

### 验证测试  
新增测试用例覆盖关键场景：  
**场景1**: 验证 finish 期间插件可见性  
```rust  
impl Plugin for PluginF {  
    fn finish(&self, app: &mut App) {  
        assert_eq!(  
            app.is_plugin_added::<PluginA>(),  
            !app.get_added_plugins::<PluginA>().is_empty(),  
        );  
    }  
}  
```  

**场景2**: 验证 finish 期间添加插件  
```rust  
impl Plugin for PluginG {  
    fn finish(&self, app: &mut App) {  
        app.add_plugins(PluginB);  // 动态添加新插件  
    }  
}  

// 验证插件顺序保持  
assert_eq!(app.main().plugin_registry[1].name(), "...PluginA");  
assert_eq!(app.main().plugin_registry[3].name(), "...PluginB");  
```  

### 影响分析  
1. **行为修正**：  
   - `get_added_plugins()` 在生命周期方法中返回正确结果  
   - 修复 `is_plugin_added()` 与 `get_added_plugins()` 的不一致  

2. **架构影响**：  
   - 保持插件系统的状态一致性  
   - 支持插件在 finish/cleanup 阶段查询其他插件  

3. **性能保持**：  
   - 交换操作维持 O(1) 时间复杂度  
   - 无额外内存分配  

---

## 关键文件变更  

### crates/bevy_app/src/app.rs (+85/-12)  
**变更重点**:  
1. 重构 finish/cleanup 的插件遍历逻辑  
2. 新增 HokeyPokey 占位插件  
3. 添加验证测试用例  

```rust  
// 新增占位插件  
pub(crate) struct HokeyPokey;  
impl Plugin for HokeyPokey {  
    fn build(&self, _: &mut App) {}  
}  

// 重构后的 finish 方法  
pub fn finish(&mut self) {  
    let mut hokeypokey: Box<dyn Plugin> = Box::new(HokeyPokey);  
    for i in 0..self.main().plugin_registry.len() {  
        core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);  
        hokeypokey.finish(self);  
        core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);  
    }  
    self.main_mut().plugins_state = PluginsState::Finished;  
}  
```  

### crates/bevy_app/src/sub_app.rs (+18/-14)  
**变更重点**:  
子应用同步采用相同交换逻辑  

```rust  
// 重构前的清理方法 (有缺陷)  
let plugins = core::mem::take(&mut self.plugin_registry);  
self.run_as_app(|app| {  
    for plugin in &plugins {  
        plugin.cleanup(app);  
    }  
});  

// 重构后的方法  
let mut hokeypokey: Box<dyn Plugin> = Box::new(crate::HokeyPokey);  
for i in 0..self.plugin_registry.len() {  
    core::mem::swap(&mut self.plugin_registry[i], &mut hokeypokey);  
    self.run_as_app(|app| {  
        hokeypokey.cleanup(app);  
    });  
    core::mem::swap(&mut self.plugin_registry[i], &mut hokeypokey);  
}  
```  

---

## 延伸阅读  
1. [Bevy 插件系统文档](https://bevyengine.org/learn/book/getting-started/plugins/)  
2. Rust 所有权管理：  
   - [std::mem::swap 文档](https://doc.rust-lang.org/std/mem/fn.swap.html)  
   - [零大小类型(ZST)优化](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts)  
3. [测试驱动开发(TDD)实践](https://en.wikipedia.org/wiki/Test-driven_development)