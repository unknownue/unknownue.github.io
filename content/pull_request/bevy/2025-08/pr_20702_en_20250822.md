+++
title = "#20702 Don't invert an affine matrix as if it was a mat4"
date = "2025-08-22T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20702-en-20250822" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20702-zh-cn-20250822" }}
labels = ["C-Bug", "D-Trivial", "A-Rendering"]
+++

# Title: Don't invert an affine matrix as if it was a mat4

## Basic Information
- **Title**: Don't invert an affine matrix as if it was a mat4
- **PR Link**: https://github.com/bevyengine/bevy/pull/20702
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: C-Bug, D-Trivial, A-Rendering, S-Ready-For-Final-Review
- **Created**: 2025-08-22T06:45:52Z
- **Merged**: 2025-08-22T21:53:48Z
- **Merged By**: james7132

## Description Translation
# Objective

- Don't invert an affine matrix as if it was a mat4

## Solution

- keep it affine

## Testing

shadow biases example

## The Story of This Pull Request

This PR addresses a performance optimization in Bevy's camera projection system. The core issue was in the `compute_frustum` method of the `CameraProjection` trait, where camera transforms were being inverted using a general-purpose 4x4 matrix inversion when they could have been handled more efficiently as affine transformations.

The problem stemmed from how `GlobalTransform` matrices were being processed. While `GlobalTransform` represents an affine transformation (composed of rotation, translation, and scale), the original code was treating it as a general 4x4 matrix and using `Mat4::inverse()`, which performs a full matrix inversion without leveraging the known structure of affine transformations.

The solution was straightforward but impactful: instead of converting the transform to a full 4x4 matrix and inverting it, the code now extracts the affine component using `GlobalTransform::affine()` and calls `Affine3A::inverse()`. This approach is mathematically equivalent but computationally more efficient because it takes advantage of the known structure of affine transformations, avoiding unnecessary calculations for the bottom row of the matrix which is always `[0, 0, 0, 1]` in affine transforms.

The change is minimal - just a single line modification - but it demonstrates an important optimization principle: using the most specific mathematical operation available rather than general-purpose computations. This is particularly valuable in graphics programming where matrix operations are performed frequently in hot paths like frustum calculation.

The fix was tested using the shadow biases example, ensuring that the mathematical correctness was preserved while gaining performance benefits. This type of optimization is especially valuable in rendering systems where every matrix operation counts, particularly when dealing with multiple cameras or complex scenes.

## Visual Representation

```mermaid
graph TD
    A[CameraProjection.compute_frustum] --> B[Get clip from view matrix]
    B --> C[Get camera transform]
    C --> D[Inverse transform]
    D --> E[Multiply matrices]
    E --> F[Create frustum]
    
    subgraph "Optimization Change"
        D -.-> G[Use affine().inverse() instead of to_matrix().inverse()]
    end
```

## Key Files Changed

**File: `crates/bevy_camera/src/projection.rs`**

This file contains the `CameraProjection` trait and its implementations. The change was made to the `compute_frustum` method which calculates the viewing frustum for a camera.

**Change:**
```rust
// Before:
let clip_from_world = self.get_clip_from_view() * camera_transform.to_matrix().inverse();

// After:
let clip_from_world = self.get_clip_from_view() * camera_transform.affine().inverse();
```

The modification replaces the general matrix inversion (`to_matrix().inverse()`) with a specialized affine inversion (`affine().inverse()`). This change improves performance by leveraging the known structure of affine transformations, avoiding unnecessary computations for the bottom row of the 4x4 matrix which is always `[0, 0, 0, 1]` in affine transforms.

## Further Reading

- [Affine transformation - Wikipedia](https://en.wikipedia.org/wiki/Affine_transformation)
- [Matrix inversion - Wikipedia](https://en.wikipedia.org/wiki/Invertible_matrix)
- [Bevy Camera Projection Documentation](https://docs.rs/bevy_camera/latest/bevy_camera/projection/trait.CameraProjection.html)
- [glam crate (Bevy's math library) Affine3A documentation](https://docs.rs/glam/latest/glam/struct.Affine3A.html)

## Full Code Diff
```diff
diff --git a/crates/bevy_camera/src/projection.rs b/crates/bevy_camera/src/projection.rs
index f95959c43986c..9a1d61f4ee981 100644
--- a/crates/bevy_camera/src/projection.rs
+++ b/crates/bevy_camera/src/projection.rs
@@ -68,7 +68,7 @@ pub trait CameraProjection {
     /// This code is called by [`update_frusta`](crate::visibility::update_frusta) system
     /// for each camera to update its frustum.
     fn compute_frustum(&self, camera_transform: &GlobalTransform) -> Frustum {
-        let clip_from_world = self.get_clip_from_view() * camera_transform.to_matrix().inverse();
+        let clip_from_world = self.get_clip_from_view() * camera_transform.affine().inverse();
         Frustum::from_clip_from_world_custom_far(
             &clip_from_world,
             &camera_transform.translation(),
```