diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index ee1540ba6eb91..9e3a611c318af 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -74,10 +74,13 @@ bluenoise_texture = ["bevy_pbr?/bluenoise_texture"]
 smaa_luts = ["bevy_anti_aliasing/smaa_luts"]
 
 # NVIDIA Deep Learning Super Sampling
-dlss = ["bevy_anti_aliasing/dlss"]
+dlss = ["bevy_anti_aliasing/dlss", "bevy_solari?/dlss"]
 
 # Forcibly disable DLSS so that cargo build --all-features works without the DLSS SDK being installed. Not meant for users.
-force_disable_dlss = ["bevy_anti_aliasing?/force_disable_dlss"]
+force_disable_dlss = [
+  "bevy_anti_aliasing?/force_disable_dlss",
+  "bevy_solari?/force_disable_dlss",
+]
 
 # Audio format support (vorbis is enabled by default)
 flac = ["bevy_audio/flac"]
diff --git a/crates/bevy_solari/Cargo.toml b/crates/bevy_solari/Cargo.toml
index 1b80c65c8a8c9..4cfb46c742f6e 100644
--- a/crates/bevy_solari/Cargo.toml
+++ b/crates/bevy_solari/Cargo.toml
@@ -10,6 +10,7 @@ keywords = ["bevy"]
 
 [dependencies]
 # bevy
+bevy_anti_aliasing = { path = "../bevy_anti_aliasing", version = "0.17.0-dev" }
 bevy_app = { path = "../bevy_app", version = "0.17.0-dev" }
 bevy_asset = { path = "../bevy_asset", version = "0.17.0-dev" }
 bevy_camera = { path = "../bevy_camera", version = "0.17.0-dev" }
@@ -36,6 +37,10 @@ bytemuck = { version = "1" }
 derive_more = { version = "2", default-features = false, features = ["from"] }
 tracing = { version = "0.1", default-features = false, features = ["std"] }
 
+[features]
+dlss = ["bevy_anti_aliasing/dlss"]
+force_disable_dlss = ["bevy_anti_aliasing/force_disable_dlss"]
+
 [lints]
 workspace = true
 
diff --git a/crates/bevy_solari/src/realtime/mod.rs b/crates/bevy_solari/src/realtime/mod.rs
index ac0ef457022f3..04e3528e63004 100644
--- a/crates/bevy_solari/src/realtime/mod.rs
+++ b/crates/bevy_solari/src/realtime/mod.rs
@@ -39,6 +39,9 @@ impl Plugin for SolariLightingPlugin {
         embedded_asset!(app, "world_cache_compact.wgsl");
         embedded_asset!(app, "world_cache_update.wgsl");
 
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        embedded_asset!(app, "resolve_dlss_rr_textures.wgsl");
+
         app.insert_resource(DefaultOpaqueRendererMethod::deferred());
     }
 
diff --git a/crates/bevy_solari/src/realtime/node.rs b/crates/bevy_solari/src/realtime/node.rs
index 02ec72e729bab..79a4eda3d9dff 100644
--- a/crates/bevy_solari/src/realtime/node.rs
+++ b/crates/bevy_solari/src/realtime/node.rs
@@ -3,6 +3,8 @@ use super::{
     SolariLighting,
 };
 use crate::scene::RaytracingSceneBindings;
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_anti_aliasing::dlss::ViewDlssRayReconstructionTextures;
 use bevy_asset::{load_embedded_asset, Handle};
 use bevy_core_pipeline::prepass::{
     PreviousViewData, PreviousViewUniformOffset, PreviousViewUniforms, ViewPrepassTextures,
@@ -40,6 +42,8 @@ pub mod graph {
 pub struct SolariLightingNode {
     bind_group_layout: BindGroupLayout,
     bind_group_layout_world_cache_active_cells_dispatch: BindGroupLayout,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    bind_group_layout_resolve_dlss_rr_textures: BindGroupLayout,
     decay_world_cache_pipeline: CachedComputePipelineId,
     compact_world_cache_single_block_pipeline: CachedComputePipelineId,
     compact_world_cache_blocks_pipeline: CachedComputePipelineId,
@@ -51,9 +55,12 @@ pub struct SolariLightingNode {
     di_spatial_and_shade_pipeline: CachedComputePipelineId,
     gi_initial_and_temporal_pipeline: CachedComputePipelineId,
     gi_spatial_and_shade_pipeline: CachedComputePipelineId,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    resolve_dlss_rr_textures_pipeline: CachedComputePipelineId,
 }
 
 impl ViewNode for SolariLightingNode {
+    #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))]
     type ViewQuery = (
         &'static SolariLighting,
         &'static SolariLightingResources,
@@ -62,12 +69,22 @@ impl ViewNode for SolariLightingNode {
         &'static ViewUniformOffset,
         &'static PreviousViewUniformOffset,
     );
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    type ViewQuery = (
+        &'static SolariLighting,
+        &'static SolariLightingResources,
+        &'static ViewTarget,
+        &'static ViewPrepassTextures,
+        &'static ViewUniformOffset,
+        &'static PreviousViewUniformOffset,
+        Option<&'static ViewDlssRayReconstructionTextures>,
+    );
 
     fn run(
         &self,
         _graph: &mut RenderGraphContext,
         render_context: &mut RenderContext,
-        (
+        #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))] (
             solari_lighting,
             solari_lighting_resources,
             view_target,
@@ -75,6 +92,15 @@ impl ViewNode for SolariLightingNode {
             view_uniform_offset,
             previous_view_uniform_offset,
         ): QueryItem<Self::ViewQuery>,
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] (
+            solari_lighting,
+            solari_lighting_resources,
+            view_target,
+            view_prepass_textures,
+            view_uniform_offset,
+            previous_view_uniform_offset,
+            view_dlss_rr_textures,
+        ): QueryItem<Self::ViewQuery>,
         world: &World,
     ) -> Result<(), NodeRunError> {
         let pipeline_cache = world.resource::<PipelineCache>();
@@ -123,6 +149,12 @@ impl ViewNode for SolariLightingNode {
         else {
             return Ok(());
         };
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let Some(resolve_dlss_rr_textures_pipeline) =
+            pipeline_cache.get_compute_pipeline(self.resolve_dlss_rr_textures_pipeline)
+        else {
+            return Ok(());
+        };
 
         let s = solari_lighting_resources;
         let bind_group = render_context.render_device().create_bind_group(
@@ -160,6 +192,19 @@ impl ViewNode for SolariLightingNode {
                 &self.bind_group_layout_world_cache_active_cells_dispatch,
                 &BindGroupEntries::single(s.world_cache_active_cells_dispatch.as_entire_binding()),
             );
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let bind_group_resolve_dlss_rr_textures = view_dlss_rr_textures.map(|d| {
+            render_context.render_device().create_bind_group(
+                "solari_lighting_bind_group_resolve_dlss_rr_textures",
+                &self.bind_group_layout_resolve_dlss_rr_textures,
+                &BindGroupEntries::sequential((
+                    &d.diffuse_albedo.default_view,
+                    &d.specular_albedo.default_view,
+                    &d.normal_roughness.default_view,
+                    &d.specular_motion_vectors.default_view,
+                )),
+            )
+        });
 
         // Choice of number here is arbitrary
         let frame_index = frame_count.0.wrapping_mul(5782582);
@@ -185,6 +230,14 @@ impl ViewNode for SolariLightingNode {
                 previous_view_uniform_offset.offset,
             ],
         );
+
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        if let Some(bind_group_resolve_dlss_rr_textures) = bind_group_resolve_dlss_rr_textures {
+            pass.set_bind_group(2, &bind_group_resolve_dlss_rr_textures, &[]);
+            pass.set_pipeline(resolve_dlss_rr_textures_pipeline);
+            pass.dispatch_workgroups(dx, dy, 1);
+        }
+
         pass.set_bind_group(2, &bind_group_world_cache_active_cells_dispatch, &[]);
 
         pass.set_pipeline(decay_world_cache_pipeline);
@@ -333,6 +386,20 @@ impl FromWorld for SolariLightingNode {
                 ),
             );
 
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let bind_group_layout_resolve_dlss_rr_textures = render_device.create_bind_group_layout(
+            "solari_lighting_bind_group_layout_resolve_dlss_rr_textures",
+            &BindGroupLayoutEntries::sequential(
+                ShaderStages::COMPUTE,
+                (
+                    texture_storage_2d(TextureFormat::Rgba8Unorm, StorageTextureAccess::WriteOnly),
+                    texture_storage_2d(TextureFormat::Rgba8Unorm, StorageTextureAccess::WriteOnly),
+                    texture_storage_2d(TextureFormat::Rgba16Float, StorageTextureAccess::WriteOnly),
+                    texture_storage_2d(TextureFormat::Rg16Float, StorageTextureAccess::WriteOnly),
+                ),
+            ),
+        );
+
         let create_pipeline = |label: &'static str,
                                entry_point: &'static str,
                                shader: Handle<Shader>,
@@ -370,6 +437,9 @@ impl FromWorld for SolariLightingNode {
             bind_group_layout: bind_group_layout.clone(),
             bind_group_layout_world_cache_active_cells_dispatch:
                 bind_group_layout_world_cache_active_cells_dispatch.clone(),
+            #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+            bind_group_layout_resolve_dlss_rr_textures: bind_group_layout_resolve_dlss_rr_textures
+                .clone(),
             decay_world_cache_pipeline: create_pipeline(
                 "solari_lighting_decay_world_cache_pipeline",
                 "decay_world_cache",
@@ -447,6 +517,14 @@ impl FromWorld for SolariLightingNode {
                 None,
                 vec![],
             ),
+            #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+            resolve_dlss_rr_textures_pipeline: create_pipeline(
+                "solari_lighting_resolve_dlss_rr_textures_pipeline",
+                "resolve_dlss_rr_textures",
+                load_embedded_asset!(world, "resolve_dlss_rr_textures.wgsl"),
+                Some(&bind_group_layout_resolve_dlss_rr_textures),
+                vec![],
+            ),
         }
     }
 }
diff --git a/crates/bevy_solari/src/realtime/prepare.rs b/crates/bevy_solari/src/realtime/prepare.rs
index 68e8af9dd26b4..b803269a07a01 100644
--- a/crates/bevy_solari/src/realtime/prepare.rs
+++ b/crates/bevy_solari/src/realtime/prepare.rs
@@ -1,6 +1,12 @@
 use super::SolariLighting;
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_anti_aliasing::dlss::{
+    Dlss, DlssRayReconstructionFeature, ViewDlssRayReconstructionTextures,
+};
 use bevy_camera::MainPassResolutionOverride;
 use bevy_core_pipeline::{core_3d::CORE_3D_DEPTH_FORMAT, deferred::DEFERRED_PREPASS_FORMAT};
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_ecs::query::Has;
 use bevy_ecs::{
     component::Component,
     entity::Entity,
@@ -9,6 +15,8 @@ use bevy_ecs::{
 };
 use bevy_image::ToExtents;
 use bevy_math::UVec2;
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy_render::texture::CachedTexture;
 use bevy_render::{
     camera::ExtractedCamera,
     render_resource::{
@@ -58,19 +66,35 @@ pub struct SolariLightingResources {
 }
 
 pub fn prepare_solari_lighting_resources(
-    query: Query<
+    #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))] query: Query<
+        (
+            Entity,
+            &ExtractedCamera,
+            Option<&SolariLightingResources>,
+            Option<&MainPassResolutionOverride>,
+        ),
+        With<SolariLighting>,
+    >,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] query: Query<
         (
             Entity,
             &ExtractedCamera,
             Option<&SolariLightingResources>,
             Option<&MainPassResolutionOverride>,
+            Has<Dlss<DlssRayReconstructionFeature>>,
         ),
         With<SolariLighting>,
     >,
     render_device: Res<RenderDevice>,
     mut commands: Commands,
 ) {
-    for (entity, camera, solari_lighting_resources, resolution_override) in &query {
+    for query_item in &query {
+        #[cfg(any(not(feature = "dlss"), feature = "force_disable_dlss"))]
+        let (entity, camera, solari_lighting_resources, resolution_override) = query_item;
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        let (entity, camera, solari_lighting_resources, resolution_override, has_dlss_rr) =
+            query_item;
+
         let Some(mut view_size) = camera.physical_viewport_size else {
             continue;
         };
@@ -241,5 +265,80 @@ pub fn prepare_solari_lighting_resources(
             world_cache_active_cells_dispatch,
             view_size,
         });
+
+        #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+        if has_dlss_rr {
+            let diffuse_albedo = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_diffuse_albedo"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rgba8Unorm,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let diffuse_albedo_view = diffuse_albedo.create_view(&TextureViewDescriptor::default());
+
+            let specular_albedo = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_specular_albedo"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rgba8Unorm,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let specular_albedo_view =
+                specular_albedo.create_view(&TextureViewDescriptor::default());
+
+            let normal_roughness = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_normal_roughness"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rgba16Float,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let normal_roughness_view =
+                normal_roughness.create_view(&TextureViewDescriptor::default());
+
+            let specular_motion_vectors = render_device.create_texture(&TextureDescriptor {
+                label: Some("solari_lighting_specular_motion_vectors"),
+                size: view_size.to_extents(),
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: TextureDimension::D2,
+                format: TextureFormat::Rg16Float,
+                usage: TextureUsages::TEXTURE_BINDING | TextureUsages::STORAGE_BINDING,
+                view_formats: &[],
+            });
+            let specular_motion_vectors_view =
+                specular_motion_vectors.create_view(&TextureViewDescriptor::default());
+
+            commands
+                .entity(entity)
+                .insert(ViewDlssRayReconstructionTextures {
+                    diffuse_albedo: CachedTexture {
+                        texture: diffuse_albedo,
+                        default_view: diffuse_albedo_view,
+                    },
+                    specular_albedo: CachedTexture {
+                        texture: specular_albedo,
+                        default_view: specular_albedo_view,
+                    },
+                    normal_roughness: CachedTexture {
+                        texture: normal_roughness,
+                        default_view: normal_roughness_view,
+                    },
+                    specular_motion_vectors: CachedTexture {
+                        texture: specular_motion_vectors,
+                        default_view: specular_motion_vectors_view,
+                    },
+                });
+        }
     }
 }
diff --git a/crates/bevy_solari/src/realtime/resolve_dlss_rr_textures.wgsl b/crates/bevy_solari/src/realtime/resolve_dlss_rr_textures.wgsl
new file mode 100644
index 0000000000000..007498968bfb0
--- /dev/null
+++ b/crates/bevy_solari/src/realtime/resolve_dlss_rr_textures.wgsl
@@ -0,0 +1,28 @@
+#import bevy_pbr::pbr_deferred_types::unpack_24bit_normal
+#import bevy_pbr::utils::octahedral_decode
+#import bevy_render::view::View
+
+@group(1) @binding(7) var gbuffer: texture_2d<u32>;
+@group(1) @binding(12) var<uniform> view: View;
+
+@group(2) @binding(0) var diffuse_albedo: texture_storage_2d<rgba8unorm, write>;
+@group(2) @binding(1) var specular_albedo: texture_storage_2d<rgba8unorm, write>;
+@group(2) @binding(2) var normal_roughness: texture_storage_2d<rgba16float, write>;
+@group(2) @binding(3) var specular_motion_vectors: texture_storage_2d<rg16float, write>;
+
+@compute @workgroup_size(8, 8, 1)
+fn resolve_dlss_rr_textures(@builtin(global_invocation_id) global_id: vec3<u32>) {
+    let pixel_id = global_id.xy;
+    if any(pixel_id >= vec2u(view.main_pass_viewport.zw)) { return; }
+
+    let gpixel = textureLoad(gbuffer, pixel_id, 0);
+    let base_rough = unpack4x8unorm(gpixel.r);
+    let base_color = pow(base_rough.rgb, vec3(2.2));
+    let world_normal = octahedral_decode(unpack_24bit_normal(gpixel.a));
+    let perceptual_roughness = base_rough.a;
+
+    textureStore(diffuse_albedo, pixel_id, vec4(base_color, 0.0));
+    textureStore(specular_albedo, pixel_id, vec4(0.0)); // TODO
+    textureStore(normal_roughness, pixel_id, vec4(world_normal, perceptual_roughness));
+    textureStore(specular_motion_vectors, pixel_id, vec4(0.0)); // TODO
+}
diff --git a/crates/bevy_solari/src/realtime/restir_gi.wgsl b/crates/bevy_solari/src/realtime/restir_gi.wgsl
index f4043b685b6d9..f98546e96b40e 100644
--- a/crates/bevy_solari/src/realtime/restir_gi.wgsl
+++ b/crates/bevy_solari/src/realtime/restir_gi.wgsl
@@ -25,7 +25,7 @@ struct PushConstants { frame_index: u32, reset: u32 }
 var<push_constant> constants: PushConstants;
 
 const SPATIAL_REUSE_RADIUS_PIXELS = 30.0;
-const CONFIDENCE_WEIGHT_CAP = 30.0;
+const CONFIDENCE_WEIGHT_CAP = 8.0;
 
 @compute @workgroup_size(8, 8, 1)
 fn initial_and_temporal(@builtin(global_invocation_id) global_id: vec3<u32>) {
@@ -42,12 +42,15 @@ fn initial_and_temporal(@builtin(global_invocation_id) global_id: vec3<u32>) {
     let gpixel = textureLoad(gbuffer, global_id.xy, 0);
     let world_position = reconstruct_world_position(global_id.xy, depth);
     let world_normal = octahedral_decode(unpack_24bit_normal(gpixel.a));
+    let base_color = pow(unpack4x8unorm(gpixel.r).rgb, vec3(2.2));
+    let diffuse_brdf = base_color / PI;
 
     let initial_reservoir = generate_initial_reservoir(world_position, world_normal, &rng);
-    let temporal_reservoir = load_temporal_reservoir(global_id.xy, depth, world_position, world_normal);
-    let combined_reservoir = merge_reservoirs(initial_reservoir, temporal_reservoir, &rng);
+    let temporal = load_temporal_reservoir(global_id.xy, depth, world_position, world_normal);
+    let merge_result = merge_reservoirs(initial_reservoir, world_position, world_normal, diffuse_brdf,
+        temporal.reservoir, temporal.world_position, temporal.world_normal, temporal.diffuse_brdf, &rng);
 
-    gi_reservoirs_b[pixel_index] = combined_reservoir;
+    gi_reservoirs_b[pixel_index] = merge_result.merged_reservoir;
 }
 
 @compute @workgroup_size(8, 8, 1)
@@ -70,7 +73,7 @@ fn spatial_and_shade(@builtin(global_invocation_id) global_id: vec3<u32>) {
 
     let input_reservoir = gi_reservoirs_b[pixel_index];
     let spatial = load_spatial_reservoir(global_id.xy, depth, world_position, world_normal, &rng);
-    let merge_result = merge_reservoirs_spatial(input_reservoir, world_position, world_normal, diffuse_brdf,
+    let merge_result = merge_reservoirs(input_reservoir, world_position, world_normal, diffuse_brdf,
         spatial.reservoir, spatial.world_position, spatial.world_normal, spatial.diffuse_brdf, &rng);
     let combined_reservoir = merge_result.merged_reservoir;
 
@@ -116,42 +119,52 @@ fn generate_initial_reservoir(world_position: vec3<f32>, world_normal: vec3<f32>
     return reservoir;
 }
 
-fn load_temporal_reservoir(pixel_id: vec2<u32>, depth: f32, world_position: vec3<f32>, world_normal: vec3<f32>) -> Reservoir {
+fn load_temporal_reservoir(pixel_id: vec2<u32>, depth: f32, world_position: vec3<f32>, world_normal: vec3<f32>) -> NeighborInfo {
     let motion_vector = textureLoad(motion_vectors, pixel_id, 0).xy;
     let temporal_pixel_id_float = round(vec2<f32>(pixel_id) - (motion_vector * view.main_pass_viewport.zw));
-    let temporal_pixel_id = vec2<u32>(temporal_pixel_id_float);
 
     // Check if the current pixel was off screen during the previous frame (current pixel is newly visible),
     // or if all temporal history should assumed to be invalid
     if any(temporal_pixel_id_float < vec2(0.0)) || any(temporal_pixel_id_float >= view.main_pass_viewport.zw) || bool(constants.reset) {
-        return empty_reservoir();
+        return NeighborInfo(empty_reservoir(), vec3(0.0), vec3(0.0), vec3(0.0));
     }
 
-    // Check if the pixel features have changed heavily between the current and previous frame
-    let temporal_depth = textureLoad(previous_depth_buffer, temporal_pixel_id, 0);
-    let temporal_gpixel = textureLoad(previous_gbuffer, temporal_pixel_id, 0);
-    let temporal_world_position = reconstruct_previous_world_position(temporal_pixel_id, temporal_depth);
-    let temporal_world_normal = octahedral_decode(unpack_24bit_normal(temporal_gpixel.a));
-    if pixel_dissimilar(depth, world_position, temporal_world_position, world_normal, temporal_world_normal) {
-        return empty_reservoir();
-    }
+    let temporal_pixel_id_base = vec2<u32>(round(temporal_pixel_id_float));
+    for (var i = 0u; i < 4u; i++) {
+        let temporal_pixel_id = permute_pixel(temporal_pixel_id_base, i);
 
-    let temporal_pixel_index = temporal_pixel_id.x + temporal_pixel_id.y * u32(view.main_pass_viewport.z);
-    var temporal_reservoir = gi_reservoirs_a[temporal_pixel_index];
+        // Check if the pixel features have changed heavily between the current and previous frame
+        let temporal_depth = textureLoad(previous_depth_buffer, temporal_pixel_id, 0);
+        let temporal_gpixel = textureLoad(previous_gbuffer, temporal_pixel_id, 0);
+        let temporal_world_position = reconstruct_previous_world_position(temporal_pixel_id, temporal_depth);
+        let temporal_world_normal = octahedral_decode(unpack_24bit_normal(temporal_gpixel.a));
+        let temporal_base_color = pow(unpack4x8unorm(temporal_gpixel.r).rgb, vec3(2.2));
+        let temporal_diffuse_brdf = temporal_base_color / PI;
+        if pixel_dissimilar(depth, world_position, temporal_world_position, world_normal, temporal_world_normal) {
+            continue;
+        }
 
-    temporal_reservoir.confidence_weight = min(temporal_reservoir.confidence_weight, CONFIDENCE_WEIGHT_CAP);
+        let temporal_pixel_index = temporal_pixel_id.x + temporal_pixel_id.y * u32(view.main_pass_viewport.z);
+        var temporal_reservoir = gi_reservoirs_a[temporal_pixel_index];
+
+        temporal_reservoir.confidence_weight = min(temporal_reservoir.confidence_weight, CONFIDENCE_WEIGHT_CAP);
+
+        return NeighborInfo(temporal_reservoir, temporal_world_position, temporal_world_normal, temporal_diffuse_brdf);
+    }
 
-    return temporal_reservoir;
+    return NeighborInfo(empty_reservoir(), vec3(0.0), vec3(0.0), vec3(0.0));
 }
 
-struct SpatialInfo {
-    reservoir: Reservoir,
-    world_position: vec3<f32>,
-    world_normal: vec3<f32>,
-    diffuse_brdf: vec3<f32>,
+fn permute_pixel(pixel_id: vec2<u32>, i: u32) -> vec2<u32> {
+    let r = constants.frame_index + i;
+    let offset = vec2(r & 3u, (r >> 2u) & 3u);
+    var shifted_pixel_id = pixel_id + offset;
+    shifted_pixel_id ^= vec2(3u);
+    shifted_pixel_id -= offset;
+    return min(shifted_pixel_id, vec2<u32>(view.main_pass_viewport.zw - 1.0));
 }
 
-fn load_spatial_reservoir(pixel_id: vec2<u32>, depth: f32, world_position: vec3<f32>, world_normal: vec3<f32>, rng: ptr<function, u32>) -> SpatialInfo {
+fn load_spatial_reservoir(pixel_id: vec2<u32>, depth: f32, world_position: vec3<f32>, world_normal: vec3<f32>, rng: ptr<function, u32>) -> NeighborInfo {
     let spatial_pixel_id = get_neighbor_pixel_id(pixel_id, rng);
 
     let spatial_depth = textureLoad(depth_buffer, spatial_pixel_id, 0);
@@ -161,13 +174,15 @@ fn load_spatial_reservoir(pixel_id: vec2<u32>, depth: f32, world_position: vec3<
     let spatial_base_color = pow(unpack4x8unorm(spatial_gpixel.r).rgb, vec3(2.2));
     let spatial_diffuse_brdf = spatial_base_color / PI;
     if pixel_dissimilar(depth, world_position, spatial_world_position, world_normal, spatial_world_normal) {
-        return SpatialInfo(empty_reservoir(), spatial_world_position, spatial_world_normal, spatial_diffuse_brdf);
+        return NeighborInfo(empty_reservoir(), spatial_world_position, spatial_world_normal, spatial_diffuse_brdf);
     }
 
     let spatial_pixel_index = spatial_pixel_id.x + spatial_pixel_id.y * u32(view.main_pass_viewport.z);
-    let spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
+    var spatial_reservoir = gi_reservoirs_b[spatial_pixel_index];
+
+    spatial_reservoir.radiance *= trace_point_visibility(world_position, spatial_reservoir.sample_point_world_position);
 
-    return SpatialInfo(spatial_reservoir, spatial_world_position, spatial_world_normal, spatial_diffuse_brdf);
+    return NeighborInfo(spatial_reservoir, spatial_world_position, spatial_world_normal, spatial_diffuse_brdf);
 }
 
 fn get_neighbor_pixel_id(center_pixel_id: vec2<u32>, rng: ptr<function, u32>) -> vec2<u32> {
@@ -176,6 +191,13 @@ fn get_neighbor_pixel_id(center_pixel_id: vec2<u32>, rng: ptr<function, u32>) ->
     return vec2<u32>(spatial_id);
 }
 
+struct NeighborInfo {
+    reservoir: Reservoir,
+    world_position: vec3<f32>,
+    world_normal: vec3<f32>,
+    diffuse_brdf: vec3<f32>,
+}
+
 fn jacobian(
     new_world_position: vec3<f32>,
     original_world_position: vec3<f32>,
@@ -255,51 +277,12 @@ fn empty_reservoir() -> Reservoir {
     );
 }
 
-fn merge_reservoirs(
-    canonical_reservoir: Reservoir,
-    other_reservoir: Reservoir,
-    rng: ptr<function, u32>,
-) -> Reservoir {
-    var combined_reservoir = empty_reservoir();
-    combined_reservoir.confidence_weight = canonical_reservoir.confidence_weight + other_reservoir.confidence_weight;
-
-    let mis_weight_denominator = select(0.0, 1.0 / combined_reservoir.confidence_weight, combined_reservoir.confidence_weight > 0.0);
-
-    let canonical_mis_weight = canonical_reservoir.confidence_weight * mis_weight_denominator;
-    let canonical_target_function = luminance(canonical_reservoir.radiance);
-    let canonical_resampling_weight = canonical_mis_weight * (canonical_target_function * canonical_reservoir.unbiased_contribution_weight);
-
-    let other_mis_weight = other_reservoir.confidence_weight * mis_weight_denominator;
-    let other_target_function = luminance(other_reservoir.radiance);
-    let other_resampling_weight = other_mis_weight * (other_target_function * other_reservoir.unbiased_contribution_weight);
-
-    combined_reservoir.weight_sum = canonical_resampling_weight + other_resampling_weight;
-
-    if rand_f(rng) < other_resampling_weight / combined_reservoir.weight_sum {
-        combined_reservoir.sample_point_world_position = other_reservoir.sample_point_world_position;
-        combined_reservoir.sample_point_world_normal = other_reservoir.sample_point_world_normal;
-        combined_reservoir.radiance = other_reservoir.radiance;
-
-        let inverse_target_function = select(0.0, 1.0 / other_target_function, other_target_function > 0.0);
-        combined_reservoir.unbiased_contribution_weight = combined_reservoir.weight_sum * inverse_target_function;
-    } else {
-        combined_reservoir.sample_point_world_position = canonical_reservoir.sample_point_world_position;
-        combined_reservoir.sample_point_world_normal = canonical_reservoir.sample_point_world_normal;
-        combined_reservoir.radiance = canonical_reservoir.radiance;
-
-        let inverse_target_function = select(0.0, 1.0 / canonical_target_function, canonical_target_function > 0.0);
-        combined_reservoir.unbiased_contribution_weight = combined_reservoir.weight_sum * inverse_target_function;
-    }
-
-    return combined_reservoir;
-}
-
 struct ReservoirMergeResult {
     merged_reservoir: Reservoir,
     selected_sample_radiance: vec3<f32>,
 }
 
-fn merge_reservoirs_spatial(
+fn merge_reservoirs(
     canonical_reservoir: Reservoir,
     canonical_world_position: vec3<f32>,
     canonical_world_normal: vec3<f32>,
@@ -318,8 +301,7 @@ fn merge_reservoirs_spatial(
     let other_sample_radiance =
         other_reservoir.radiance *
         saturate(dot(normalize(other_reservoir.sample_point_world_position - canonical_world_position), canonical_world_normal)) *
-        canonical_diffuse_brdf *
-        trace_point_visibility(canonical_world_position, other_reservoir.sample_point_world_position);
+        canonical_diffuse_brdf;
 
     // Target functions for resampling and MIS
     let canonical_target_function_canonical_sample = luminance(canonical_sample_radiance);
@@ -351,6 +333,11 @@ fn merge_reservoirs_spatial(
         canonical_reservoir.sample_point_world_normal
     );
 
+    // Don't merge samples with huge jacobians, as it explodes the variance
+    if canonical_target_function_other_sample_jacobian > 2.0 {
+        return ReservoirMergeResult(canonical_reservoir, canonical_sample_radiance);
+    }
+
     // Resampling weight for canonical sample
     let canonical_sample_mis_weight = balance_heuristic(
         canonical_reservoir.confidence_weight * canonical_target_function_canonical_sample,
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 57a9ddd4ac517..8907f8433f99f 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -18,6 +18,11 @@ use bevy::{
 use camera_controller::{CameraController, CameraControllerPlugin};
 use std::f32::consts::PI;
 
+#[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+use bevy::anti_aliasing::dlss::{
+    Dlss, DlssProjectId, DlssRayReconstructionFeature, DlssRayReconstructionSupported,
+};
+
 /// `bevy_solari` demo.
 #[derive(FromArgs, Resource, Clone, Copy)]
 struct Args {
@@ -30,6 +35,12 @@ fn main() {
     let args: Args = argh::from_env();
 
     let mut app = App::new();
+
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    app.insert_resource(DlssProjectId(bevy_asset::uuid::uuid!(
+        "5417916c-0291-4e3f-8f65-326c1858ab96" // Don't copy paste this - generate your own UUID!
+    )));
+
     app.add_plugins((DefaultPlugins, SolariPlugins, CameraControllerPlugin))
         .insert_resource(args)
         .add_systems(Startup, setup);
@@ -41,7 +52,14 @@ fn main() {
     app.run();
 }
 
-fn setup(mut commands: Commands, asset_server: Res<AssetServer>, args: Res<Args>) {
+fn setup(
+    mut commands: Commands,
+    asset_server: Res<AssetServer>,
+    args: Res<Args>,
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))] dlss_rr_supported: Option<
+        Res<DlssRayReconstructionSupported>,
+    >,
+) {
     commands
         .spawn(SceneRoot(asset_server.load(
             GltfAssetLabel::Scene(0).from_asset("models/CornellBox/CornellBox.glb"),
@@ -73,11 +91,22 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>, args: Res<Args>
         CameraMainTextureUsages::default().with(TextureUsages::STORAGE_BINDING),
         Msaa::Off,
     ));
+
     if args.pathtracer == Some(true) {
         camera.insert(Pathtracer::default());
     } else {
         camera.insert(SolariLighting::default());
     }
+
+    // Using DLSS Ray Reconstruction for denoising (and cheaper rendering via upscaling) is _highly_ recommended when using Solari
+    #[cfg(all(feature = "dlss", not(feature = "force_disable_dlss")))]
+    if dlss_rr_supported.is_some() {
+        camera.insert(Dlss::<DlssRayReconstructionFeature> {
+            perf_quality_mode: Default::default(),
+            reset: Default::default(),
+            _phantom_data: Default::default(),
+        });
+    }
 }
 
 fn add_raytracing_meshes_on_scene_load(
diff --git a/release-content/release-notes/bevy_solari.md b/release-content/release-notes/bevy_solari.md
index f2f99ce3d09a9..cfe89f6576927 100644
--- a/release-content/release-notes/bevy_solari.md
+++ b/release-content/release-notes/bevy_solari.md
@@ -1,9 +1,11 @@
 ---
 title: Initial raytraced lighting progress (bevy_solari)
 authors: ["@JMS55", "@SparkyPotato"]
-pull_requests: [19058, 19620, 19790, 20020, 20113, 20156, 20213, 20242, 20259, 20406, 20457]
+pull_requests: [19058, 19620, 19790, 20020, 20113, 20156, 20213, 20242, 20259, 20406, 20457, 20580, 20596]
 ---
 
+## Overview
+
 (TODO: Embed solari example screenshot here)
 
 In Bevy 0.17, we've made the first steps towards realtime raytraced lighting in the form of the new bevy_solari crate.
@@ -25,7 +27,23 @@ The problem with these methods is that they all have large downsides:
 
 Bevy Solari is intended as a completely alternate, high-end lighting solution for Bevy that uses GPU-accelerated raytracing to fix all of the above problems. Emissive meshes properly cast light and shadows, you can have hundreds of shadow casting lights, quality is much better, it requires no baking time, and it supports _fully_ dynamic scenes!
 
-While Bevy 0.17 adds the bevy_solari crate, it's intended as a long-term project. It is not yet usable by game developers. However, feel free to run the solari example (`cargo run --release --example solari --features bevy_solari` (realtime, no denoising) or `cargo run --release --example solari --features bevy_solari -- --pathtracer` (non-realtime)) to check out the progress we've made, and look forward to more work on Bevy Solari in future releases!
+## Try it out
+
+While Bevy 0.17 adds the bevy_solari crate, it is not yet production ready.
+
+However, feel free to run the solari example to check out the progress we've made. There are two different modes you can try out:
+
+A non-realtime "reference" mode that uses pathtracing: `cargo run --release --example solari --features bevy_solari -- --pathtracer`.
+
+A realtime mode that uses a combination of techniques, and currently supports only diffuse materials: `cargo run --release --example solari --features bevy_solari`.
+
+Additionally, if you have a NVIDIA GPU, you can enable DLSS Ray Reconstruction with the realtime mode for a combination of denoising (Bevy Solari does not otherwise come with a denoiser), lower rendering times, and anti aliasing: `cargo run --release --example solari --features bevy_solari,dlss`.
+
+## How it works
+
+TODO: Showcase the different aspects/steps of Solari (direct initial+temporal+spatial, indirect initial+temporal+spatial, world cache, DLSS RR)
+
+Look forward to more work on Bevy Solari in future releases!
 
 (TODO: Embed bevy_solari logo here, or somewhere else that looks good)
 
