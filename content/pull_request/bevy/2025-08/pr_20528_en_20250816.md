+++
title = "#20528 Use the capacity from the entities Vec to initialize Table columns"
date = "2025-08-16T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20528-en-20250816" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20528-zh-cn-20250816" }}
labels = ["D-Trivial", "A-ECS", "P-Unsound", "D-Unsafe"]
+++

### Title: Use the capacity from the entities Vec to initialize Table columns

## Basic Information
- **Title**: Use the capacity from the entities Vec to initialize Table columns
- **PR Link**: https://github.com/bevyengine/bevy/pull/20528
- **Author**: james7132
- **Status**: MERGED
- **Labels**: D-Trivial, A-ECS, P-Unsound, D-Unsafe
- **Created**: 2025-08-12T09:35:22Z
- **Merged**: 2025-08-16T00:46:59Z
- **Merged By**: james7132

## Description Translation
### Objective
When working with `realloc`, it's a safety invariant to pass in the existing layout of the allocation that is being reallocated. This may not be the case with newly created `Table`s. `Vec::with_capacity`'s documentation states that it will return an allocation with enough space for *at least* `capacity` elements, not exactly `capacity`. This means that `entities.capacity()` may be greater than the provided capacity. As the `ThinColumn`s use this as their capacity, the new Layout fed to `realloc` will not match the allocation originally provided to `alloc`. This is unsound.

While investigating this, I also found that we were not validating that the total capacity of `BlobArray`'s layout upon reallocation were less than `isize::MAX` via `array_layout_unchecked`.

### Solution
Begin `Table` construction by allocating the `entities` Vec, and use it's capacity to allocate the columns instead of directly feeding the provided capacity into `ThinColumn::with_capacity`.

Replace the `array_layout_unchecked` call with a safe call to `array_layout`, and panic if it fails.

### Testing
Tested this locally against existing unit tests and miri.

## The Story of This Pull Request

This PR addresses a critical memory safety issue in Bevy's ECS table initialization. The problem originated from how table columns were allocated using a user-provided capacity value rather than the actual allocation size from the `entities` vector. Rust's `Vec::with_capacity` may allocate more space than requested, creating a mismatch between the expected and actual allocation layouts. This violated a fundamental safety requirement of `realloc`, which demands that layout parameters match the original allocation.

During investigation, an additional issue was discovered: `BlobArray` used an unsafe layout calculation that could potentially overflow. Both issues required immediate attention due to their unsound nature.

The solution modifies `TableBuilder` to use the actual capacity of the pre-allocated `entities` vector when initializing columns. This ensures the allocation layout matches what will be passed to `realloc` later. The implementation required changes to:
1. Store the `entities` vector directly in `TableBuilder`
2. Use `entities.capacity()` for column initialization
3. Add safety documentation about capacity invariants
4. Replace unsafe layout calculations with safe alternatives

For `BlobArray`, the unsafe `array_layout_unchecked` was replaced with `array_layout` which performs proper overflow checks. This prevents potential layout calculation overflows that could lead to undefined behavior.

The changes maintain existing functionality while enforcing critical memory safety invariants. All modifications were validated against existing tests and through Miri verification to confirm no undefined behavior remains.

## Visual Representation

```mermaid
graph TD
    A[TableBuilder] --> B[Allocate entities Vec]
    B --> C[Use entities.capacity()]
    C --> D[Initialize ThinColumn]
    D --> E[Safe realloc operations]
    F[BlobArray] --> G[Use array_layout]
    G --> H[Layout overflow check]
```

## Key Files Changed

### 1. `crates/bevy_ecs/src/storage/table/mod.rs` (+23/-4)
**Purpose**: Fixes table column initialization to use actual allocation size

**Key Changes:**
```rust
// Before:
struct TableBuilder {
    columns: SparseSet<ComponentId, ThinColumn>,
    capacity: usize,
}

fn with_capacity(capacity: usize, column_capacity: usize) -> Self {
    Self {
        columns: SparseSet::with_capacity(column_capacity),
        capacity,
    }
}

fn add_column(mut self, component_info: &ComponentInfo) -> Self {
    self.columns.insert(
        component_info.id(),
        ThinColumn::with_capacity(component_info, self.capacity),
    );
    self
}

// After:
struct TableBuilder {
    columns: SparseSet<ComponentId, ThinColumn>,
    entities: Vec<Entity>,
}

fn with_capacity(capacity: usize, column_capacity: usize) -> Self {
    Self {
        columns: SparseSet::with_capacity(column_capacity),
        entities: Vec::with_capacity(capacity),
    }
}

fn add_column(mut self, component_info: &ComponentInfo) -> Self {
    self.columns.insert(
        component_info.id(),
        ThinColumn::with_capacity(component_info, self.entities.capacity()),
    );
    self
}
```

**Impact**: Ensures column allocations match the actual capacity of the entities vector, maintaining realloc safety invariants.

### 2. `crates/bevy_ecs/src/storage/blob_array.rs` (+2/-3)
**Purpose**: Replaces unsafe layout calculation with safe alternative

**Key Changes:**
```rust
// Before:
let new_layout = unsafe { array_layout_unchecked(&self.item_layout, new_capacity.get()) };

// After:
let new_layout = array_layout(&self.item_layout, new_capacity.get())
    .expect("array layout should be valid");
```

**Impact**: Prevents potential layout calculation overflows by using safe API with explicit panic on failure.

## Further Reading
1. [Rust's Vec::with_capacity documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity) - explains capacity guarantees
2. [Memory Layout Safety in Rust](https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#safety) - requirements for safe allocator usage
3. [Miri - Rust Undefined Behavior Checker](https://github.com/rust-lang/miri) - tool used to verify fixes