diff --git a/release-content/release-notes/atmosphere_environment_map.md b/release-content/release-notes/atmosphere_environment_map.md
deleted file mode 100644
index bbb9361775d70..0000000000000
--- a/release-content/release-notes/atmosphere_environment_map.md
+++ /dev/null
@@ -1,25 +0,0 @@
----
-title: Generated environment map for procedural atmosphere
-authors: ["@mate-h"]
-pull_requests: [20529]
----
-
-(TODO: Embed screenshot of atmosphere-generated reflections)
-
-You can now have dynamic reflections and ambient light in your scene that match the procedural sky.
-
-As the sky changes, reflections on shiny and rough materials update automatically to stay consistent â€” no pre-baked environment maps needed.
-
-To enable this for a camera, add the new component `AtmosphereEnvironmentMapLight` to the camera entity:
-
-```rust
-commands.spawn((
-    Camera3d::default(),
-    // Generates an environment cubemap from the atmosphere for this view
-    AtmosphereEnvironmentMapLight::default(),
-));
-```
-
-Note that this is a per-view effect (per camera). Light probes are not yet supported.
-
-Special thanks to @atlv24, @JMS55 and @ecoskey for reviews and feedback.
diff --git a/release-content/release-notes/bevy_solari.md b/release-content/release-notes/bevy_solari.md
index c5d497ceba339..cbb6122b30ece 100644
--- a/release-content/release-notes/bevy_solari.md
+++ b/release-content/release-notes/bevy_solari.md
@@ -8,7 +8,7 @@ pull_requests: [19058, 19620, 19790, 20020, 20113, 20156, 20213, 20242, 20259, 2
 
 (TODO: Embed solari example screenshot here)
 
-In Bevy 0.17, we've made the first steps towards realtime raytraced lighting in the form of the new bevy_solari crate.
+With the new `bevy_solari` crate, we're making our first steps towards realtime raytraced lighting.
 
 For some background, lighting in video games can be split into two parts: direct and indirect lighting.
 
@@ -37,7 +37,7 @@ A non-realtime "reference" mode that uses pathtracing: `cargo run --release --ex
 
 A realtime mode that uses a combination of techniques, and currently supports only diffuse materials: `cargo run --release --example solari --features bevy_solari`.
 
-Additionally, if you have a NVIDIA GPU, you can enable DLSS Ray Reconstruction with the realtime mode for a combination of denoising (Bevy Solari does not otherwise come with a denoiser), lower rendering times, and anti aliasing: `cargo run --release --example solari --features bevy_solari,dlss`.
+Additionally, if you have a NVIDIA GPU, you can enable DLSS Ray Reconstruction with the realtime mode for a combination of denoising (Bevy Solari does not currently come with any alternate denoisers), lower rendering times, and anti-aliasing: `cargo run --release --example solari --features bevy_solari,dlss`.
 
 ## How it works
 
diff --git a/release-content/release-notes/dlss.md b/release-content/release-notes/dlss.md
index 6d67739da2bed..0310d4729e865 100644
--- a/release-content/release-notes/dlss.md
+++ b/release-content/release-notes/dlss.md
@@ -12,7 +12,7 @@ Additionally, we've open sourced <https://github.com/bevyengine/dlss_wgpu> as a
 
 Compared to Bevy's built-in TAA, DLSS:
 
-* Is much higher quality
+* Produces higher quality and more stable images
 * Supports upscaling in addition to anti-aliasing, leading to much cheaper render times, particularly when used with GPU-heavy features like Bevy Solari
 * Requires a NVIDIA RTX GPU
 * Requires running via the Vulkan backend on Windows/Linux (no macOS, web, or mobile support)
diff --git a/release-content/release-notes/entity-spawn-ticks.md b/release-content/release-notes/entity-spawn-ticks.md
index c90500f1a1470..aa319cb2a1158 100644
--- a/release-content/release-notes/entity-spawn-ticks.md
+++ b/release-content/release-notes/entity-spawn-ticks.md
@@ -6,7 +6,7 @@ pull_requests: [19047, 19350]
 
 Keeping track which entities have been spawned since the last time a system ran could only be done indirectly by inserting marker components and do your logic on entities that match an `Added<MyMarker>` filter or in `MyMarker`'s `on_add` hook.
 
-This has the issue however that not every add reacts on a spawn but also on insertions at existing entities. Sometimes you cannot even add your marker because the spawn call is hidden in some non-public API.
+This has the issue however: add events react to component insertions on existing entities too. Sometimes you cannot even add your marker because the spawn call is hidden in some non-public API.
 
 The new `SpawnDetails` query data and `Spawned` query filter enable you to find recently spawned entities without any marker components.
 
diff --git a/release-content/release-notes/feathers.md b/release-content/release-notes/feathers.md
index 33c8bb8b94b9d..0051fb5bc37bd 100644
--- a/release-content/release-notes/feathers.md
+++ b/release-content/release-notes/feathers.md
@@ -4,6 +4,8 @@ authors: ["@viridia", "@Atlas16A", "@ickshonpe", "@amedoeyes"]
 pull_requests: [19730, 19900, 19928, 20237, 20169, 20422, 20350, 20548]
 ---
 
+TODO: add screenshot of `feathers` in practice
+
 To make it easier for Bevy engine developers and third-party tool creators to make comfortable, visually cohesive tooling,
 we're pleased to introduce "Feathers" - a comprehensive widget set that offers:
 
@@ -12,7 +14,7 @@ we're pleased to introduce "Feathers" - a comprehensive widget set that offers:
 - Essential UI elements including buttons, sliders, checkboxes, menu buttons, and more
 - Layout containers for organizing and structuring UI elements
 - Decorative elements such as icons for visual enhancement
-- Robust theming support ensuring consistent visual styling across applications
+- Robust-if-primitive theming support ensuring consistent visual styling across applications
 - Accessibility features with built-in screen reader and assistive technology support
 - Interactive cursor behavior that changes appropriately when hovering over widgets
 - A virtual keyboard suitable for touchscreen text input
@@ -20,8 +22,14 @@ we're pleased to introduce "Feathers" - a comprehensive widget set that offers:
 Feathers isn't meant as a toolkit for building exciting and cool game UIs: it has a somewhat plain
 and utilitarian look and feel suitable for editors and graphical utilities. That being said, using
 the themeing framework, you can spice up the colors quite a bit.
-It can also serve as a helpful base to understand how to extend and style `bevy_ui` and our new core widgets;
-copy the code into your project and start hacking!
 
-Feathers is still in development, and is currently hidden behind an experimental feature flag,
+This is still early in development, and is currently hidden behind an experimental feature flag:
 `experimental_bevy_feathers`.
+If you're looking to experiment with building tooling for Bevy, turn that on and use `feathers` as is!
+Let us know what problems you run into, and feel free to contribute missing widgets and bugs upstream.
+
+But if you can't wait to get your hands on `bevy_ui` widgets for your game,
+copy the code into your project and start hacking away at it!
+While it deliberately does not expose very many tuning levers (keeping a coherent visual style in an open source project is *hard*),
+it's a helpful base to understand how to extend and style `bevy_ui` and our new headless widgets
+to meet the unique style and design patterns of your project.
diff --git a/release-content/release-notes/light-textures.md b/release-content/release-notes/light-textures.md
index b586b04732d44..29b0451ee5f0c 100644
--- a/release-content/release-notes/light-textures.md
+++ b/release-content/release-notes/light-textures.md
@@ -5,6 +5,6 @@ pull_requests: [18031]
 ---
 
 New components `PointLightTexture`, `SpotLightTexture`, and `DirectionalLightTexture` allow specifying light textures for lights, also commonly known as light cookies.
-These modulate the intensity of light cast upon surfaces for various artistic effects. See the light_textures example for usage.
+These modulate the intensity of light cast upon surfaces for various artistic effects. See the `light_textures` example for usage.
 
 (TODO: Embed light_textures example screenshot here)
diff --git a/release-content/release-notes/observer_overhaul.md b/release-content/release-notes/observer_overhaul.md
index e21b8058a553a..a2d716bc856fe 100644
--- a/release-content/release-notes/observer_overhaul.md
+++ b/release-content/release-notes/observer_overhaul.md
@@ -4,6 +4,8 @@ authors: ["@Jondolf", "@alice-i-cecile", "@hukasu", "oscar-benderstone", "Zeophl
 pull_requests: [19596, 19663, 19611, 19935, 20274]
 ---
 
+TODO: merge with Event split release notes
+
 ## Rename `Trigger` to `On`
 
 In past releases, the observer API looked like this:
diff --git a/release-content/release-notes/realtime-environment-map-filtering.md b/release-content/release-notes/realtime-environment-map-filtering.md
index e608df3095150..8de10e5285f3a 100644
--- a/release-content/release-notes/realtime-environment-map-filtering.md
+++ b/release-content/release-notes/realtime-environment-map-filtering.md
@@ -1,23 +1,29 @@
 ---
 title: Realtime-filtered environment maps
 authors: ["@mate-h"]
-pull_requests: [19076]
+pull_requests: [19076, 20529]
 ---
 
+(TODO: Embed screenshot of atmosphere-generated reflections)
+
 An environment map needs to be processed to be able to support uses beyond a simple skybox,
 such as reflections at different roughness levels, and ambient light contribution.
 This process is called filtering, and can either be done ahead of time (prefiltering), or
 in realtime, although at a reduced quality.
 
 Bevy already supported prefiltering, but its not always possible to prefilter: sometimes,
-you only gain access to an environment map at runtime, for whatever reason.
-Typically this is from realtime reflection probes, but can also be from other sources
-for example, from a procedural skybox.
+your environment map is not available until runtime.
+Typically this is from realtime reflection probes, but you might also, for example,
+be using a procedural skybox.
 
 Now, Bevy supports both modes of filtering!
 Adding a `GeneratedEnvironmentMapLight` to a `Camera` entity lets you use any environment map
 with Bevy's renderer, and enjoy all the benefits of prefiltering with none of the asset processing.
 
-(TODO: Embed screenshot of realtime filtering)
+We've made sure works with our built-in atmosphere shader too.
+To enable this, add the new component `AtmosphereEnvironmentMapLight` to the camera entity.
+
+This is fully dynamic per-view effect: no pre-baked environment maps are needed.
+However, please be aware that light probes are not yet supported.
 
-Special thanks to @JMS55 for the feedback and @atlv24 for contributing and helping the PR get over the finish line!
+Special thanks to @atlv24, @JMS55 and @ecoskey for reviews, feedback, and assistance.
diff --git a/release-content/release-notes/scene-type-crates.md b/release-content/release-notes/scene-type-crates.md
index 2616bcadf4446..9a3abd33120d8 100644
--- a/release-content/release-notes/scene-type-crates.md
+++ b/release-content/release-notes/scene-type-crates.md
@@ -4,7 +4,7 @@ authors: ["@atlv24", "@Ickshonpe", "@zeophlite"]
 pull_requests: [20485, 20330, 18703, 20587, 20502, 19997, 19991, 20000, 19949, 19943, 19953, 20498, 20496, 20493, 20492, 20491, 20488, 20487, 20486, 20483, 20480, 20479, 20478, 20477, 20473, 20472, 20471, 20470, 20392, 20390, 20388, 20345, 20344, 20051, 19985, 19973, 19965, 19963, 19962, 19960, 19959, 19958, 19957, 19956, 19955, 19954, 16620, 16619, 15700, 15666, 15650]
 ---
 
-It is now possible to use cameras, lights, shaders, images, meshes, sprites, text, ui, picking, animation, and scenes without depending on the Bevy renderer. This makes it possible for 3rd party custom renderers to be drop-in replacements for rendering existing scenes.
+It is now possible to use cameras, lights, shaders, images, meshes, sprites, text, ui, picking, animation, and scenes without depending on the Bevy renderer. This makes it possible for 3rd party custom renderers (as might be required on console, or for teams with divergent goals) to act as drop-in replacements for rendering existing scenes.
 
 This is incredibly important for reducing compile time, especially for 3rd party crates: crate authors can now depend more granularly on the specific crates they need, meaning greater chances for compilation parallelism emerge as not everything is bottlenecked on waiting for the bevy_render -> bevy_core_pipelines -> bevy_pbr/bevy_sprite chain to compile.
 
diff --git a/release-content/release-notes/specialized_ui_transform.md b/release-content/release-notes/specialized_ui_transform.md
index c1c7ae4811234..f98e3dfdf7082 100644
--- a/release-content/release-notes/specialized_ui_transform.md
+++ b/release-content/release-notes/specialized_ui_transform.md
@@ -5,3 +5,6 @@ pull_requests: [16615]
 ---
 
 In Bevy UI `Transform` and `GlobalTransform` have been replaced by `UiTransform` and `UiGlobalTransform`.  `UiTransform` is a specialized 2D UI transform which supports responsive translations.
+
+This is only the first step in a broader effort to dethrone `Transform` as the do-everything position-rotation-scale type.
+Don't worry, we haven't forgotten about 2D: we know that working with quaternions is a headache, and are hoping to define a dedicated 2D transform type, saving space and frustration.
diff --git a/release-content/release-notes/system_set_naming_convention.md b/release-content/release-notes/system_set_naming_convention.md
index 095c3b1d54f23..576123c9356da 100644
--- a/release-content/release-notes/system_set_naming_convention.md
+++ b/release-content/release-notes/system_set_naming_convention.md
@@ -13,38 +13,18 @@ for their own types, to search for system sets on docs.rs, or to even discern wh
 *are* system sets.
 
 To reign in the inconsistency and help unify the ecosystem, **Bevy 0.17** has renamed most of
-its own system sets to follow a consistent `*Systems` naming convention. Renamed types include:
+its own system sets to follow a consistent `*Systems` naming convention.
+As you can see by this very incomplete list of renames, our naming was all over the place:
 
-- `AccessibilitySystem` â†’ `AccessibilitySystems`
 - `GizmoRenderSystem` â†’ `GizmoRenderSystems`
 - `PickSet` â†’ `PickingSystems`
-- `RunFixedMainLoopSystem` â†’ `RunFixedMainLoopSystems`
-- `TransformSystem` â†’ `TransformSystems`
-- `RemoteSet` â†’ `RemoteSystems`
-- `RenderSet` â†’ `RenderSystems`
-- `SpriteSystem` â†’ `SpriteSystems`
-- `StateTransitionSteps` â†’ `StateTransitionSystems`
-- `RenderUiSystem` â†’ `RenderUiSystems`
-- `UiSystem` â†’ `UiSystems`
 - `Animation` â†’ `AnimationSystems`
-- `AssetEvents` â†’ `AssetEventSystems`
-- `TrackAssets` â†’ `AssetTrackingSystems`
-- `UpdateGizmoMeshes` â†’ `GizmoMeshSystems`
-- `InputSystem` â†’ `InputSystems`
-- `InputFocusSet` â†’ `InputFocusSystems`
-- `ExtractMaterialsSet` â†’ `MaterialExtractionSystems`
-- `ExtractMeshesSet` â†’ `MeshExtractionSystems`
-- `RumbleSystem` â†’ `RumbleSystems`
-- `CameraUpdateSystem` â†’ `CameraUpdateSystems`
-- `ExtractAssetsSet` â†’ `AssetExtractionSystems`
 - `Update2dText` â†’ `Text2dUpdateSystems`
-- `TimeSystem` â†’ `TimeSystems`
-- `EventUpdates` â†’ `EventUpdateSystems`
 
 The `Systems` suffix was chosen over the other popular suffix `Set`,
 because `Systems` more clearly communicates that it is specifically
 a collection of systems, and it has a lower risk of naming conflicts
 with other set types.
 
-It is recommended for ecosystem crates and users to follow suit and also adopt
+For consistency, we recommend that ecosystem crates and users to follow suit and also adopt
 the `*Systems` naming convention for their system sets where applicable.
