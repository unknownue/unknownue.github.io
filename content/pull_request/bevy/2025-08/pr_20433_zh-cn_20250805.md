+++
title = "#20433 Make `HierarchyPropagatePlugin` scheduling configurable"
date = "2025-08-05T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20433-en-20250805" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20433-zh-cn-20250805" }}
+++

### Make `HierarchyPropagatePlugin` scheduling configurable

#### 基本信息
- **标题**: Make `HierarchyPropagatePlugin` scheduling configurable
- **PR链接**: https://github.com/bevyengine/bevy/pull/20433
- **作者**: tim-blackbird
- **状态**: MERGED
- **标签**: C-Usability, A-App, X-Contentious, D-Straightforward, S-Needs-Review
- **创建时间**: 2025-08-05T21:40:59Z
- **合并时间**: 2025-08-05T23:12:47Z
- **合并者**: cart

#### 描述翻译
使传播系统运行的 schedule 可配置

### PR 分析报告

#### 问题背景
`HierarchyPropagatePlugin` 是 Bevy 引擎中负责组件值沿实体层级传播的核心机制。该插件将传播系统硬编码在 `Update` schedule 中运行，这限制了用户根据特定场景调整系统执行顺序的能力。在实际项目中，开发者可能需要：
1. 在 `PostUpdate` 等不同 schedule 中运行传播系统
2. 控制传播系统与其他系统的执行顺序关系
3. 避免与自定义系统发生执行顺序冲突

原实现缺乏配置灵活性，导致以下问题：
```rust
// 原实现硬编码在 Update schedule
app.add_systems(
    Update,  // 不可修改的固定 schedule
    (update_source, update_stopped, ...)
);
```

#### 解决方案
PR 通过重构 `HierarchyPropagatePlugin` 结构体，增加 schedule 配置参数：
1. 移除默认实现，强制显式指定 schedule
2. 新增构造函数接收任意 `ScheduleLabel`
3. 在插件构建时使用配置的 schedule

关键设计决策：
- 保留原有泛型参数（`C`/`F`/`R`）确保传播逻辑不变
- 使用 `Interned<dyn ScheduleLabel>` 高效存储 schedule 标识
- 完全向后兼容（需将 `default()` 替换为 `new(Update)`）

#### 实现细节
主要修改集中在插件初始化和调用逻辑：

**插件结构重构**：
```rust
// 修改前：
pub struct HierarchyPropagatePlugin<...>(PhantomData<...>);

// 修改后：
pub struct HierarchyPropagatePlugin<...> {
    schedule: Interned<dyn ScheduleLabel>,  // 新增 schedule 存储
    _marker: PhantomData<...>,
}
```

**新增构造函数**：
```rust
pub fn new(schedule: impl ScheduleLabel) -> Self {
    Self {
        schedule: schedule.intern(),  // 转换并存储 schedule
        _marker: PhantomData,
    }
}
```

**系统注册改造**：
```diff
 fn build(&self, app: &mut App) {
     app.add_systems(
-        Update,
+        self.schedule,  // 使用配置的 schedule
         (update_source, update_stopped, ...)
     );
 }
```

**测试用例更新**：
所有测试用例统一改用新构造函数：
```rust
// 之前：
app.add_plugins(HierarchyPropagatePlugin::<TestValue>::default());

// 之后：
app.add_plugins(HierarchyPropagatePlugin::<TestValue>::new(Update));
```

#### 影响分析
1. **灵活性提升**：用户可自由选择传播系统的执行 schedule
   ```rust
   // 在 PostUpdate 运行传播
   app.add_plugins(HierarchyPropagatePlugin::<Transform>::new(PostUpdate));
   ```
2. **执行顺序控制**：解决与自定义系统的执行冲突
3. **破坏性变更**：移除 `Default` 实现需更新现有代码
4. **性能无损**：`Interned` 确保 schedule 查询零开销

#### 技术洞察
1. **Schedule 抽象**：利用 `Interned<dyn ScheduleLabel>` 实现类型擦除，平衡灵活性与性能
2. **显式接口**：强制通过 `new()` 初始化，避免隐含行为
3. **测试覆盖**：保持 100% 测试通过率，验证修改不影响核心传播逻辑

### 组件关系图
```mermaid
graph LR
    A[用户代码] --> B[new(schedule)]
    B --> C[HierarchyPropagatePlugin]
    C --> D[build()]
    D --> E[add_systems(schedule)]
    E --> F[传播系统]
```

### 关键文件变更

#### 1. `crates/bevy_app/src/propagate.rs` (+32/-22)
**变更目的**：实现 schedule 可配置化  
**核心修改**：
```rust
// 结构定义变更
pub struct HierarchyPropagatePlugin<...> {
    schedule: Interned<dyn ScheduleLabel>, // 新增字段
    _marker: PhantomData<...>,
}

// 新增构造函数
pub fn new(schedule: impl ScheduleLabel) -> Self {
    Self { schedule: schedule.intern(), ... }
}

// 系统注册改造
fn build(&self, app: &mut App) {
    app.add_systems(
        self.schedule, // 动态替换 Update
        (update_source, ...) 
    );
}

// 移除 Default 实现
-impl<...> Default for ... { ... }
```

#### 2. `crates/bevy_feathers/src/lib.rs` (+3/-3)
**变更目的**：适配新接口  
**修改内容**：
```diff
 app.add_plugins((
     ...
-    HierarchyPropagatePlugin::<TextColor, ...>::default(),
-    HierarchyPropagatePlugin::<TextFont, ...>::default(),
+    HierarchyPropagatePlugin::<TextColor, ...>::new(Update),
+    HierarchyPropagatePlugin::<TextFont, ...>::new(Update),
 ));
```

### 延伸阅读
1. [Bevy Schedules 系统](https://bevyengine.org/learn/book/next/schedules/)
2. [ECS 组件传播模式](https://www.gamedeveloper.com/programming/component-based-engine-design)
3. [泛型插件实现规范](https://github.com/bevyengine/bevy/discussions/1947)