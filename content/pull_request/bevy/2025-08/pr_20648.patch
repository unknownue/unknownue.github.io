diff --git a/benches/benches/bevy_ecs/observers/propagation.rs b/benches/benches/bevy_ecs/observers/propagation.rs
index 2622ecdddd16c..3b862cc1a631f 100644
--- a/benches/benches/bevy_ecs/observers/propagation.rs
+++ b/benches/benches/bevy_ecs/observers/propagation.rs
@@ -113,6 +113,6 @@ fn add_listeners_to_hierarchy<const DENSITY: usize, const N: usize>(
     }
 }
 
-fn empty_listener<const N: usize>(trigger: On<TestEvent<N>>) {
-    black_box(trigger);
+fn empty_listener<const N: usize>(event: On<TestEvent<N>>) {
+    black_box(event);
 }
diff --git a/benches/benches/bevy_ecs/observers/simple.rs b/benches/benches/bevy_ecs/observers/simple.rs
index 29ade4d2d1032..a4915e6afa807 100644
--- a/benches/benches/bevy_ecs/observers/simple.rs
+++ b/benches/benches/bevy_ecs/observers/simple.rs
@@ -46,8 +46,8 @@ pub fn observe_simple(criterion: &mut Criterion) {
     group.finish();
 }
 
-fn empty_listener_base(trigger: On<EventBase>) {
-    black_box(trigger);
+fn empty_listener_base(event: On<EventBase>) {
+    black_box(event);
 }
 
 fn send_base_event(world: &mut World, entities: impl TriggerTargets) {
diff --git a/crates/bevy_app/src/app.rs b/crates/bevy_app/src/app.rs
index bdb79cc495433..26a89d9f3ea3e 100644
--- a/crates/bevy_app/src/app.rs
+++ b/crates/bevy_app/src/app.rs
@@ -1332,8 +1332,8 @@ impl App {
     /// # struct Friend;
     /// #
     ///
-    /// app.add_observer(|trigger: On<Party>, friends: Query<Entity, With<Friend>>, mut commands: Commands| {
-    ///     if trigger.event().friends_allowed {
+    /// app.add_observer(|event: On<Party>, friends: Query<Entity, With<Friend>>, mut commands: Commands| {
+    ///     if event.friends_allowed {
     ///         for friend in friends.iter() {
     ///             commands.trigger_targets(Invite, friend);
     ///         }
diff --git a/crates/bevy_core_widgets/src/core_button.rs b/crates/bevy_core_widgets/src/core_button.rs
index 70b6fb1cb355f..059a2751c863d 100644
--- a/crates/bevy_core_widgets/src/core_button.rs
+++ b/crates/bevy_core_widgets/src/core_button.rs
@@ -30,44 +30,44 @@ pub struct CoreButton {
 }
 
 fn button_on_key_event(
-    mut trigger: On<FocusedInput<KeyboardInput>>,
+    mut event: On<FocusedInput<KeyboardInput>>,
     q_state: Query<(&CoreButton, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((bstate, disabled)) = q_state.get(trigger.target())
+    if let Ok((bstate, disabled)) = q_state.get(event.entity())
         && !disabled
     {
-        let event = &trigger.event().input;
-        if !event.repeat
-            && event.state == ButtonState::Pressed
-            && (event.key_code == KeyCode::Enter || event.key_code == KeyCode::Space)
+        let input_event = &event.input;
+        if !input_event.repeat
+            && input_event.state == ButtonState::Pressed
+            && (input_event.key_code == KeyCode::Enter || input_event.key_code == KeyCode::Space)
         {
-            trigger.propagate(false);
-            commands.notify_with(&bstate.on_activate, Activate(trigger.target()));
+            event.propagate(false);
+            commands.notify_with(&bstate.on_activate, Activate(event.entity()));
         }
     }
 }
 
 fn button_on_pointer_click(
-    mut trigger: On<Pointer<Click>>,
+    mut event: On<Pointer<Click>>,
     mut q_state: Query<(&CoreButton, Has<Pressed>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((bstate, pressed, disabled)) = q_state.get_mut(trigger.target()) {
-        trigger.propagate(false);
+    if let Ok((bstate, pressed, disabled)) = q_state.get_mut(event.entity()) {
+        event.propagate(false);
         if pressed && !disabled {
-            commands.notify_with(&bstate.on_activate, Activate(trigger.target()));
+            commands.notify_with(&bstate.on_activate, Activate(event.entity()));
         }
     }
 }
 
 fn button_on_pointer_down(
-    mut trigger: On<Pointer<Press>>,
+    mut event: On<Pointer<Press>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(trigger.target()) {
-        trigger.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
+        event.propagate(false);
         if !disabled && !pressed {
             commands.entity(button).insert(Pressed);
         }
@@ -75,12 +75,12 @@ fn button_on_pointer_down(
 }
 
 fn button_on_pointer_up(
-    mut trigger: On<Pointer<Release>>,
+    mut event: On<Pointer<Release>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(trigger.target()) {
-        trigger.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
+        event.propagate(false);
         if !disabled && pressed {
             commands.entity(button).remove::<Pressed>();
         }
@@ -88,12 +88,12 @@ fn button_on_pointer_up(
 }
 
 fn button_on_pointer_drag_end(
-    mut trigger: On<Pointer<DragEnd>>,
+    mut event: On<Pointer<DragEnd>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(trigger.target()) {
-        trigger.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
+        event.propagate(false);
         if !disabled && pressed {
             commands.entity(button).remove::<Pressed>();
         }
@@ -101,12 +101,12 @@ fn button_on_pointer_drag_end(
 }
 
 fn button_on_pointer_cancel(
-    mut trigger: On<Pointer<Cancel>>,
+    mut event: On<Pointer<Cancel>>,
     mut q_state: Query<(Entity, Has<InteractionDisabled>, Has<Pressed>), With<CoreButton>>,
     mut commands: Commands,
 ) {
-    if let Ok((button, disabled, pressed)) = q_state.get_mut(trigger.target()) {
-        trigger.propagate(false);
+    if let Ok((button, disabled, pressed)) = q_state.get_mut(event.entity()) {
+        event.propagate(false);
         if !disabled && pressed {
             commands.entity(button).remove::<Pressed>();
         }
diff --git a/crates/bevy_core_widgets/src/core_checkbox.rs b/crates/bevy_core_widgets/src/core_checkbox.rs
index 6ac92e6cce3c5..ed84efd44d259 100644
--- a/crates/bevy_core_widgets/src/core_checkbox.rs
+++ b/crates/bevy_core_widgets/src/core_checkbox.rs
@@ -42,14 +42,14 @@ fn checkbox_on_key_input(
     q_checkbox: Query<(&CoreCheckbox, Has<Checked>), Without<InteractionDisabled>>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked)) = q_checkbox.get(ev.target()) {
+    if let Ok((checkbox, is_checked)) = q_checkbox.get(ev.entity()) {
         let event = &ev.event().input;
         if event.state == ButtonState::Pressed
             && !event.repeat
             && (event.key_code == KeyCode::Enter || event.key_code == KeyCode::Space)
         {
             ev.propagate(false);
-            set_checkbox_state(&mut commands, ev.target(), checkbox, !is_checked);
+            set_checkbox_state(&mut commands, ev.entity(), checkbox, !is_checked);
         }
     }
 }
@@ -61,11 +61,11 @@ fn checkbox_on_pointer_click(
     focus_visible: Option<ResMut<InputFocusVisible>>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.target()) {
+    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.entity()) {
         // Clicking on a button makes it the focused input,
         // and hides the focus ring if it was visible.
         if let Some(mut focus) = focus {
-            focus.0 = Some(ev.target());
+            focus.0 = Some(ev.entity());
         }
         if let Some(mut focus_visible) = focus_visible {
             focus_visible.0 = false;
@@ -73,7 +73,7 @@ fn checkbox_on_pointer_click(
 
         ev.propagate(false);
         if !disabled {
-            set_checkbox_state(&mut commands, ev.target(), checkbox, !is_checked);
+            set_checkbox_state(&mut commands, ev.entity(), checkbox, !is_checked);
         }
     }
 }
@@ -127,7 +127,7 @@ fn checkbox_on_set_checked(
     q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.target()) {
+    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.entity()) {
         ev.propagate(false);
         if disabled {
             return;
@@ -135,7 +135,7 @@ fn checkbox_on_set_checked(
 
         let will_be_checked = ev.event().0;
         if will_be_checked != is_checked {
-            set_checkbox_state(&mut commands, ev.target(), checkbox, will_be_checked);
+            set_checkbox_state(&mut commands, ev.entity(), checkbox, will_be_checked);
         }
     }
 }
@@ -145,13 +145,13 @@ fn checkbox_on_toggle_checked(
     q_checkbox: Query<(&CoreCheckbox, Has<Checked>, Has<InteractionDisabled>)>,
     mut commands: Commands,
 ) {
-    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.target()) {
+    if let Ok((checkbox, is_checked, disabled)) = q_checkbox.get(ev.entity()) {
         ev.propagate(false);
         if disabled {
             return;
         }
 
-        set_checkbox_state(&mut commands, ev.target(), checkbox, !is_checked);
+        set_checkbox_state(&mut commands, ev.entity(), checkbox, !is_checked);
     }
 }
 
diff --git a/crates/bevy_core_widgets/src/core_radio.rs b/crates/bevy_core_widgets/src/core_radio.rs
index 4cea61e717517..e5ba867a3410f 100644
--- a/crates/bevy_core_widgets/src/core_radio.rs
+++ b/crates/bevy_core_widgets/src/core_radio.rs
@@ -61,7 +61,7 @@ fn radio_group_on_key_input(
     q_children: Query<&Children>,
     mut commands: Commands,
 ) {
-    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.target()) {
+    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.entity()) {
         let event = &ev.event().input;
         if event.state == ButtonState::Pressed
             && !event.repeat
@@ -80,7 +80,7 @@ fn radio_group_on_key_input(
 
             // Find all radio descendants that are not disabled
             let radio_buttons = q_children
-                .iter_descendants(ev.target())
+                .iter_descendants(ev.entity())
                 .filter_map(|child_id| match q_radio.get(child_id) {
                     Ok((checked, false)) => Some((child_id, checked)),
                     Ok((_, true)) | Err(_) => None,
@@ -149,14 +149,14 @@ fn radio_group_on_button_click(
     q_children: Query<&Children>,
     mut commands: Commands,
 ) {
-    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.target()) {
+    if let Ok(CoreRadioGroup { on_change }) = q_group.get(ev.entity()) {
         // Starting with the original target, search upward for a radio button.
-        let radio_id = if q_radio.contains(ev.original_target()) {
-            ev.original_target()
+        let radio_id = if q_radio.contains(ev.original_entity()) {
+            ev.original_entity()
         } else {
             // Search ancestors for the first radio button
             let mut found_radio = None;
-            for ancestor in q_parents.iter_ancestors(ev.original_target()) {
+            for ancestor in q_parents.iter_ancestors(ev.original_entity()) {
                 if q_group.contains(ancestor) {
                     // We reached a radio group before finding a radio button, bail out
                     return;
@@ -180,7 +180,7 @@ fn radio_group_on_button_click(
 
         // Gather all the enabled radio group descendants for exclusion.
         let radio_buttons = q_children
-            .iter_descendants(ev.target())
+            .iter_descendants(ev.entity())
             .filter_map(|child_id| match q_radio.get(child_id) {
                 Ok((checked, false)) => Some((child_id, checked)),
                 Ok((_, true)) | Err(_) => None,
diff --git a/crates/bevy_core_widgets/src/core_scrollbar.rs b/crates/bevy_core_widgets/src/core_scrollbar.rs
index 01582cd0234fa..00569243ec593 100644
--- a/crates/bevy_core_widgets/src/core_scrollbar.rs
+++ b/crates/bevy_core_widgets/src/core_scrollbar.rs
@@ -110,10 +110,10 @@ fn scrollbar_on_pointer_down(
     mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<CoreScrollbar>>,
     ui_scale: Res<UiScale>,
 ) {
-    if q_thumb.contains(ev.target()) {
+    if q_thumb.contains(ev.entity()) {
         // If they click on the thumb, do nothing. This will be handled by the drag event.
         ev.propagate(false);
-    } else if let Ok((scrollbar, node, node_target, transform)) = q_scrollbar.get_mut(ev.target()) {
+    } else if let Ok((scrollbar, node, node_target, transform)) = q_scrollbar.get_mut(ev.entity()) {
         // If they click on the scrollbar track, page up or down.
         ev.propagate(false);
 
@@ -162,7 +162,7 @@ fn scrollbar_on_drag_start(
     q_scrollbar: Query<&CoreScrollbar>,
     q_scroll_area: Query<&ScrollPosition>,
 ) {
-    if let Ok((ChildOf(thumb_parent), mut drag)) = q_thumb.get_mut(ev.target()) {
+    if let Ok((ChildOf(thumb_parent), mut drag)) = q_thumb.get_mut(ev.entity()) {
         ev.propagate(false);
         if let Ok(scrollbar) = q_scrollbar.get(*thumb_parent)
             && let Ok(scroll_area) = q_scroll_area.get(scrollbar.target)
@@ -183,7 +183,7 @@ fn scrollbar_on_drag(
     mut q_scroll_pos: Query<(&mut ScrollPosition, &ComputedNode), Without<CoreScrollbar>>,
     ui_scale: Res<UiScale>,
 ) {
-    if let Ok((ChildOf(thumb_parent), drag)) = q_thumb.get_mut(ev.target())
+    if let Ok((ChildOf(thumb_parent), drag)) = q_thumb.get_mut(ev.entity())
         && let Ok((node, scrollbar)) = q_scrollbar.get_mut(*thumb_parent)
     {
         ev.propagate(false);
@@ -219,7 +219,7 @@ fn scrollbar_on_drag_end(
     mut ev: On<Pointer<DragEnd>>,
     mut q_thumb: Query<&mut CoreScrollbarDragState, With<CoreScrollbarThumb>>,
 ) {
-    if let Ok(mut drag) = q_thumb.get_mut(ev.target()) {
+    if let Ok(mut drag) = q_thumb.get_mut(ev.entity()) {
         ev.propagate(false);
         if drag.dragging {
             drag.dragging = false;
@@ -231,7 +231,7 @@ fn scrollbar_on_drag_cancel(
     mut ev: On<Pointer<Cancel>>,
     mut q_thumb: Query<&mut CoreScrollbarDragState, With<CoreScrollbarThumb>>,
 ) {
-    if let Ok(mut drag) = q_thumb.get_mut(ev.target()) {
+    if let Ok(mut drag) = q_thumb.get_mut(ev.entity()) {
         ev.propagate(false);
         if drag.dragging {
             drag.dragging = false;
diff --git a/crates/bevy_core_widgets/src/core_slider.rs b/crates/bevy_core_widgets/src/core_slider.rs
index 58bf44a1a76b3..e680b849eda63 100644
--- a/crates/bevy_core_widgets/src/core_slider.rs
+++ b/crates/bevy_core_widgets/src/core_slider.rs
@@ -228,7 +228,7 @@ pub struct CoreSliderDragState {
 }
 
 pub(crate) fn slider_on_pointer_down(
-    mut trigger: On<Pointer<Press>>,
+    mut event: On<Pointer<Press>>,
     q_slider: Query<(
         &CoreSlider,
         &SliderValue,
@@ -245,9 +245,9 @@ pub(crate) fn slider_on_pointer_down(
     mut commands: Commands,
     ui_scale: Res<UiScale>,
 ) {
-    if q_thumb.contains(trigger.target()) {
+    if q_thumb.contains(event.entity()) {
         // Thumb click, stop propagation to prevent track click.
-        trigger.propagate(false);
+        event.propagate(false);
     } else if let Ok((
         slider,
         value,
@@ -258,10 +258,10 @@ pub(crate) fn slider_on_pointer_down(
         node_target,
         transform,
         disabled,
-    )) = q_slider.get(trigger.target())
+    )) = q_slider.get(event.entity())
     {
         // Track click
-        trigger.propagate(false);
+        event.propagate(false);
 
         if disabled {
             return;
@@ -269,13 +269,13 @@ pub(crate) fn slider_on_pointer_down(
 
         // Find thumb size by searching descendants for the first entity with CoreSliderThumb
         let thumb_size = q_children
-            .iter_descendants(trigger.target())
+            .iter_descendants(event.entity())
             .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
             .unwrap_or(0.0);
 
         // Detect track click.
         let local_pos = transform.try_inverse().unwrap().transform_point2(
-            trigger.event().pointer_location.position * node_target.scale_factor() / ui_scale.0,
+            event.pointer_location.position * node_target.scale_factor() / ui_scale.0,
         );
         let track_width = node.size().x - thumb_size;
         // Avoid division by zero
@@ -304,13 +304,13 @@ pub(crate) fn slider_on_pointer_down(
 
         if matches!(slider.on_change, Callback::Ignore) {
             commands
-                .entity(trigger.target())
+                .entity(event.entity())
                 .insert(SliderValue(new_value));
         } else {
             commands.notify_with(
                 &slider.on_change,
                 ValueChange {
-                    source: trigger.target(),
+                    source: event.entity(),
                     value: new_value,
                 },
             );
@@ -319,7 +319,7 @@ pub(crate) fn slider_on_pointer_down(
 }
 
 pub(crate) fn slider_on_drag_start(
-    mut trigger: On<Pointer<DragStart>>,
+    mut event: On<Pointer<DragStart>>,
     mut q_slider: Query<
         (
             &SliderValue,
@@ -329,8 +329,8 @@ pub(crate) fn slider_on_drag_start(
         With<CoreSlider>,
     >,
 ) {
-    if let Ok((value, mut drag, disabled)) = q_slider.get_mut(trigger.target()) {
-        trigger.propagate(false);
+    if let Ok((value, mut drag, disabled)) = q_slider.get_mut(event.entity()) {
+        event.propagate(false);
         if !disabled {
             drag.dragging = true;
             drag.offset = value.0;
@@ -339,7 +339,7 @@ pub(crate) fn slider_on_drag_start(
 }
 
 pub(crate) fn slider_on_drag(
-    mut trigger: On<Pointer<Drag>>,
+    mut event: On<Pointer<Drag>>,
     mut q_slider: Query<(
         &ComputedNode,
         &CoreSlider,
@@ -355,16 +355,16 @@ pub(crate) fn slider_on_drag(
     ui_scale: Res<UiScale>,
 ) {
     if let Ok((node, slider, range, precision, transform, drag, disabled)) =
-        q_slider.get_mut(trigger.target())
+        q_slider.get_mut(event.entity())
     {
-        trigger.propagate(false);
+        event.propagate(false);
         if drag.dragging && !disabled {
-            let mut distance = trigger.event().distance / ui_scale.0;
+            let mut distance = event.distance / ui_scale.0;
             distance.y *= -1.;
             let distance = transform.transform_vector2(distance);
             // Find thumb size by searching descendants for the first entity with CoreSliderThumb
             let thumb_size = q_children
-                .iter_descendants(trigger.target())
+                .iter_descendants(event.entity())
                 .find_map(|child_id| q_thumb.get(child_id).ok().map(|thumb| thumb.size().x))
                 .unwrap_or(0.0);
             let slider_width = ((node.size().x - thumb_size) * node.inverse_scale_factor).max(1.0);
@@ -382,13 +382,13 @@ pub(crate) fn slider_on_drag(
 
             if matches!(slider.on_change, Callback::Ignore) {
                 commands
-                    .entity(trigger.target())
+                    .entity(event.entity())
                     .insert(SliderValue(rounded_value));
             } else {
                 commands.notify_with(
                     &slider.on_change,
                     ValueChange {
-                        source: trigger.target(),
+                        source: event.entity(),
                         value: rounded_value,
                     },
                 );
@@ -398,11 +398,11 @@ pub(crate) fn slider_on_drag(
 }
 
 pub(crate) fn slider_on_drag_end(
-    mut trigger: On<Pointer<DragEnd>>,
+    mut event: On<Pointer<DragEnd>>,
     mut q_slider: Query<(&CoreSlider, &mut CoreSliderDragState)>,
 ) {
-    if let Ok((_slider, mut drag)) = q_slider.get_mut(trigger.target()) {
-        trigger.propagate(false);
+    if let Ok((_slider, mut drag)) = q_slider.get_mut(event.entity()) {
+        event.propagate(false);
         if drag.dragging {
             drag.dragging = false;
         }
@@ -410,7 +410,7 @@ pub(crate) fn slider_on_drag_end(
 }
 
 fn slider_on_key_input(
-    mut trigger: On<FocusedInput<KeyboardInput>>,
+    mut event: On<FocusedInput<KeyboardInput>>,
     q_slider: Query<(
         &CoreSlider,
         &SliderValue,
@@ -420,10 +420,10 @@ fn slider_on_key_input(
     )>,
     mut commands: Commands,
 ) {
-    if let Ok((slider, value, range, step, disabled)) = q_slider.get(trigger.target()) {
-        let event = &trigger.event().input;
-        if !disabled && event.state == ButtonState::Pressed {
-            let new_value = match event.key_code {
+    if let Ok((slider, value, range, step, disabled)) = q_slider.get(event.entity()) {
+        let input_event = &event.input;
+        if !disabled && input_event.state == ButtonState::Pressed {
+            let new_value = match input_event.key_code {
                 KeyCode::ArrowLeft => range.clamp(value.0 - step.0),
                 KeyCode::ArrowRight => range.clamp(value.0 + step.0),
                 KeyCode::Home => range.start(),
@@ -432,16 +432,16 @@ fn slider_on_key_input(
                     return;
                 }
             };
-            trigger.propagate(false);
+            event.propagate(false);
             if matches!(slider.on_change, Callback::Ignore) {
                 commands
-                    .entity(trigger.target())
+                    .entity(event.entity())
                     .insert(SliderValue(new_value));
             } else {
                 commands.notify_with(
                     &slider.on_change,
                     ValueChange {
-                        source: trigger.target(),
+                        source: event.entity(),
                         value: new_value,
                     },
                 );
@@ -450,23 +450,23 @@ fn slider_on_key_input(
     }
 }
 
-pub(crate) fn slider_on_insert(trigger: On<Insert, CoreSlider>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn slider_on_insert(event: On<Insert, CoreSlider>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_orientation(Orientation::Horizontal);
     }
 }
 
-pub(crate) fn slider_on_insert_value(trigger: On<Insert, SliderValue>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn slider_on_insert_value(event: On<Insert, SliderValue>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     let value = entity.get::<SliderValue>().unwrap().0;
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_numeric_value(value.into());
     }
 }
 
-pub(crate) fn slider_on_insert_range(trigger: On<Insert, SliderRange>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn slider_on_insert_range(event: On<Insert, SliderRange>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     let range = *entity.get::<SliderRange>().unwrap();
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_min_numeric_value(range.start().into());
@@ -474,8 +474,8 @@ pub(crate) fn slider_on_insert_range(trigger: On<Insert, SliderRange>, mut world
     }
 }
 
-pub(crate) fn slider_on_insert_step(trigger: On<Insert, SliderStep>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn slider_on_insert_step(event: On<Insert, SliderStep>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     let step = entity.get::<SliderStep>().unwrap().0;
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_numeric_value_step(step.into());
@@ -518,13 +518,13 @@ pub enum SetSliderValue {
 }
 
 fn slider_on_set_value(
-    mut trigger: On<SetSliderValue>,
+    mut event: On<SetSliderValue>,
     q_slider: Query<(&CoreSlider, &SliderValue, &SliderRange, Option<&SliderStep>)>,
     mut commands: Commands,
 ) {
-    if let Ok((slider, value, range, step)) = q_slider.get(trigger.target()) {
-        trigger.propagate(false);
-        let new_value = match trigger.event() {
+    if let Ok((slider, value, range, step)) = q_slider.get(event.entity()) {
+        event.propagate(false);
+        let new_value = match event.event() {
             SetSliderValue::Absolute(new_value) => range.clamp(*new_value),
             SetSliderValue::Relative(delta) => range.clamp(value.0 + *delta),
             SetSliderValue::RelativeStep(delta) => {
@@ -533,13 +533,13 @@ fn slider_on_set_value(
         };
         if matches!(slider.on_change, Callback::Ignore) {
             commands
-                .entity(trigger.target())
+                .entity(event.entity())
                 .insert(SliderValue(new_value));
         } else {
             commands.notify_with(
                 &slider.on_change,
                 ValueChange {
-                    source: trigger.target(),
+                    source: event.entity(),
                     value: new_value,
                 },
             );
diff --git a/crates/bevy_ecs/README.md b/crates/bevy_ecs/README.md
index 302ab44bfe23c..9ca4e9300044a 100644
--- a/crates/bevy_ecs/README.md
+++ b/crates/bevy_ecs/README.md
@@ -313,8 +313,8 @@ struct Speak {
 
 let mut world = World::new();
 
-world.add_observer(|trigger: On<Speak>| {
-    println!("{}", trigger.message);
+world.add_observer(|event: On<Speak>| {
+    println!("{}", event.message);
 });
 
 world.flush();
@@ -339,9 +339,9 @@ struct Explode;
 let mut world = World::new();
 let entity = world.spawn_empty().id();
 
-world.add_observer(|trigger: On<Explode>, mut commands: Commands| {
-    println!("Entity {} goes BOOM!", trigger.target());
-    commands.entity(trigger.target()).despawn();
+world.add_observer(|event: On<Explode>, mut commands: Commands| {
+    println!("Entity {} goes BOOM!", event.entity());
+    commands.entity(event.entity()).despawn();
 });
 
 world.flush();
diff --git a/crates/bevy_ecs/src/event/base.rs b/crates/bevy_ecs/src/event/base.rs
index a5924d60f4a07..2ba0de493eb7a 100644
--- a/crates/bevy_ecs/src/event/base.rs
+++ b/crates/bevy_ecs/src/event/base.rs
@@ -53,8 +53,8 @@ use core::{
 /// #
 /// # let mut world = World::new();
 /// #
-/// world.add_observer(|trigger: On<Speak>| {
-///     println!("{}", trigger.message);
+/// world.add_observer(|event: On<Speak>| {
+///     println!("{}", event.message);
 /// });
 /// ```
 ///
@@ -70,8 +70,8 @@ use core::{
 /// #
 /// # let mut world = World::new();
 /// #
-/// # world.add_observer(|trigger: On<Speak>| {
-/// #     println!("{}", trigger.message);
+/// # world.add_observer(|event: On<Speak>| {
+/// #     println!("{}", event.message);
 /// # });
 /// #
 /// # world.flush();
@@ -187,10 +187,10 @@ pub trait Event: Send + Sync + 'static {
 /// // which can then handle the event with its own observer.
 /// let armor_piece = world
 ///     .spawn((ArmorPiece, Health(25.0), ChildOf(enemy)))
-///     .observe(|trigger: On<Damage>, mut query: Query<&mut Health>| {
-///         // Note: `On::target` only exists because this is an `EntityEvent`.
-///         let mut health = query.get_mut(trigger.target()).unwrap();
-///         health.0 -= trigger.amount;
+///     .observe(|event: On<Damage>, mut query: Query<&mut Health>| {
+///         // Note: `On::entity` only exists because this is an `EntityEvent`.
+///         let mut health = query.get_mut(event.entity()).unwrap();
+///         health.0 -= event.amount;
 ///     })
 ///     .id();
 /// ```
@@ -221,10 +221,10 @@ pub trait Event: Send + Sync + 'static {
 /// # let enemy = world.spawn((Enemy, Health(100.0))).id();
 /// # let armor_piece = world
 /// #     .spawn((ArmorPiece, Health(25.0), ChildOf(enemy)))
-/// #     .observe(|trigger: On<Damage>, mut query: Query<&mut Health>| {
-/// #         // Note: `On::target` only exists because this is an `EntityEvent`.
-/// #         let mut health = query.get_mut(trigger.target()).unwrap();
-/// #         health.0 -= trigger.amount;
+/// #     .observe(|event: On<Damage>, mut query: Query<&mut Health>| {
+/// #         // Note: `On::entity` only exists because this is an `EntityEvent`.
+/// #         let mut health = query.get_mut(event.entity()).unwrap();
+/// #         health.0 -= event.amount;
 /// #     })
 /// #     .id();
 /// #
diff --git a/crates/bevy_ecs/src/observer/centralized_storage.rs b/crates/bevy_ecs/src/observer/centralized_storage.rs
index 544f2f1f6ade7..2e3b78a8daf83 100644
--- a/crates/bevy_ecs/src/observer/centralized_storage.rs
+++ b/crates/bevy_ecs/src/observer/centralized_storage.rs
@@ -76,7 +76,7 @@ impl Observers {
         mut world: DeferredWorld,
         event_key: EventKey,
         current_target: Option<Entity>,
-        original_target: Option<Entity>,
+        original_entity: Option<Entity>,
         components: impl Iterator<Item = ComponentId> + Clone,
         data: &mut T,
         propagate: &mut bool,
@@ -104,8 +104,8 @@ impl Observers {
                     observer,
                     event_key,
                     components: components.clone().collect(),
-                    current_target,
-                    original_target,
+                    entity: current_target,
+                    original_entity,
                     caller,
                 },
                 data.into(),
diff --git a/crates/bevy_ecs/src/observer/distributed_storage.rs b/crates/bevy_ecs/src/observer/distributed_storage.rs
index 37ee4f4d6b83e..4610e26047b8b 100644
--- a/crates/bevy_ecs/src/observer/distributed_storage.rs
+++ b/crates/bevy_ecs/src/observer/distributed_storage.rs
@@ -52,8 +52,8 @@ use crate::prelude::ReflectComponent;
 ///     message: String,
 /// }
 ///
-/// world.add_observer(|trigger: On<Speak>| {
-///     println!("{}", trigger.event().message);
+/// world.add_observer(|event: On<Speak>| {
+///     println!("{}", event.message);
 /// });
 ///
 /// // Observers currently require a flush() to be registered. In the context of schedules,
@@ -73,8 +73,8 @@ use crate::prelude::ReflectComponent;
 /// # #[derive(Event)]
 /// # struct Speak;
 /// // These are functionally the same:
-/// world.add_observer(|trigger: On<Speak>| {});
-/// world.spawn(Observer::new(|trigger: On<Speak>| {}));
+/// world.add_observer(|event: On<Speak>| {});
+/// world.spawn(Observer::new(|event: On<Speak>| {}));
 /// ```
 ///
 /// Observers are systems. They can access arbitrary [`World`] data by adding [`SystemParam`]s:
@@ -86,7 +86,7 @@ use crate::prelude::ReflectComponent;
 /// # struct PrintNames;
 /// # #[derive(Component, Debug)]
 /// # struct Name;
-/// world.add_observer(|trigger: On<PrintNames>, names: Query<&Name>| {
+/// world.add_observer(|event: On<PrintNames>, names: Query<&Name>| {
 ///     for name in &names {
 ///         println!("{name:?}");
 ///     }
@@ -104,7 +104,7 @@ use crate::prelude::ReflectComponent;
 /// # struct SpawnThing;
 /// # #[derive(Component, Debug)]
 /// # struct Thing;
-/// world.add_observer(|trigger: On<SpawnThing>, mut commands: Commands| {
+/// world.add_observer(|event: On<SpawnThing>, mut commands: Commands| {
 ///     commands.spawn(Thing);
 /// });
 /// ```
@@ -118,7 +118,7 @@ use crate::prelude::ReflectComponent;
 /// # struct A;
 /// # #[derive(Event)]
 /// # struct B;
-/// world.add_observer(|trigger: On<A>, mut commands: Commands| {
+/// world.add_observer(|event: On<A>, mut commands: Commands| {
 ///     commands.trigger(B);
 /// });
 /// ```
@@ -137,9 +137,9 @@ use crate::prelude::ReflectComponent;
 /// #[derive(EntityEvent)]
 /// struct Explode;
 ///
-/// world.add_observer(|trigger: On<Explode>, mut commands: Commands| {
-///     println!("Entity {} goes BOOM!", trigger.target());
-///     commands.entity(trigger.target()).despawn();
+/// world.add_observer(|event: On<Explode>, mut commands: Commands| {
+///     println!("Entity {} goes BOOM!", event.entity());
+///     commands.entity(event.entity()).despawn();
 /// });
 ///
 /// world.flush();
@@ -170,12 +170,12 @@ use crate::prelude::ReflectComponent;
 /// # let e2 = world.spawn_empty().id();
 /// # #[derive(EntityEvent)]
 /// # struct Explode;
-/// world.entity_mut(e1).observe(|trigger: On<Explode>, mut commands: Commands| {
+/// world.entity_mut(e1).observe(|event: On<Explode>, mut commands: Commands| {
 ///     println!("Boom!");
-///     commands.entity(trigger.target()).despawn();
+///     commands.entity(event.entity()).despawn();
 /// });
 ///
-/// world.entity_mut(e2).observe(|trigger: On<Explode>, mut commands: Commands| {
+/// world.entity_mut(e2).observe(|event: On<Explode>, mut commands: Commands| {
 ///     println!("The explosion fizzles! This entity is immune!");
 /// });
 /// ```
@@ -192,7 +192,7 @@ use crate::prelude::ReflectComponent;
 /// # let entity = world.spawn_empty().id();
 /// # #[derive(EntityEvent)]
 /// # struct Explode;
-/// let mut observer = Observer::new(|trigger: On<Explode>| {});
+/// let mut observer = Observer::new(|event: On<Explode>| {});
 /// observer.watch_entity(entity);
 /// world.spawn(observer);
 /// ```
diff --git a/crates/bevy_ecs/src/observer/mod.rs b/crates/bevy_ecs/src/observer/mod.rs
index 17aaa80f96367..cae06c810dda7 100644
--- a/crates/bevy_ecs/src/observer/mod.rs
+++ b/crates/bevy_ecs/src/observer/mod.rs
@@ -25,7 +25,7 @@
 //! Observers can request other data from the world, such as via a [`Query`] or [`Res`].
 //! Commonly, you might want to verify that the entity that the observable event is targeting
 //! has a specific component, or meets some other condition. [`Query::get`] or [`Query::contains`]
-//! on the [`On::target`] entity is a good way to do this.
+//! on the [`On::entity`] entity is a good way to do this.
 //!
 //! [`Commands`] can also be used inside of observers.
 //! This can be particularly useful for triggering other observers!
@@ -641,20 +641,20 @@ mod tests {
         world.add_observer(
             |obs: On<Add, A>, mut res: ResMut<Order>, mut commands: Commands| {
                 res.observed("add_a");
-                commands.entity(obs.target()).insert(B);
+                commands.entity(obs.entity()).insert(B);
             },
         );
         world.add_observer(
             |obs: On<Remove, A>, mut res: ResMut<Order>, mut commands: Commands| {
                 res.observed("remove_a");
-                commands.entity(obs.target()).remove::<B>();
+                commands.entity(obs.entity()).remove::<B>();
             },
         );
 
         world.add_observer(
             |obs: On<Add, B>, mut res: ResMut<Order>, mut commands: Commands| {
                 res.observed("add_b");
-                commands.entity(obs.target()).remove::<A>();
+                commands.entity(obs.entity()).remove::<A>();
             },
         );
         world.add_observer(|_: On<Remove, B>, mut res: ResMut<Order>| {
@@ -675,9 +675,9 @@ mod tests {
     fn observer_trigger_ref() {
         let mut world = World::new();
 
-        world.add_observer(|mut trigger: On<EventWithData>| trigger.event_mut().counter += 1);
-        world.add_observer(|mut trigger: On<EventWithData>| trigger.event_mut().counter += 2);
-        world.add_observer(|mut trigger: On<EventWithData>| trigger.event_mut().counter += 4);
+        world.add_observer(|mut event: On<EventWithData>| event.counter += 1);
+        world.add_observer(|mut event: On<EventWithData>| event.counter += 2);
+        world.add_observer(|mut event: On<EventWithData>| event.counter += 4);
 
         let mut event = EventWithData { counter: 0 };
         world.trigger_ref(&mut event);
@@ -688,14 +688,14 @@ mod tests {
     fn observer_trigger_targets_ref() {
         let mut world = World::new();
 
-        world.add_observer(|mut trigger: On<EventWithData, A>| {
-            trigger.event_mut().counter += 1;
+        world.add_observer(|mut event: On<EventWithData, A>| {
+            event.counter += 1;
         });
-        world.add_observer(|mut trigger: On<EventWithData, B>| {
-            trigger.event_mut().counter += 2;
+        world.add_observer(|mut event: On<EventWithData, B>| {
+            event.counter += 2;
         });
-        world.add_observer(|mut trigger: On<EventWithData, A>| {
-            trigger.event_mut().counter += 4;
+        world.add_observer(|mut event: On<EventWithData, A>| {
+            event.counter += 4;
         });
 
         let mut event = EventWithData { counter: 0 };
@@ -823,7 +823,7 @@ mod tests {
         };
         world.spawn_empty().observe(system);
         world.add_observer(move |obs: On<EventA>, mut res: ResMut<Order>| {
-            assert_eq!(obs.target(), Entity::PLACEHOLDER);
+            assert_eq!(obs.entity(), Entity::PLACEHOLDER);
             res.observed("event_a");
         });
 
@@ -846,7 +846,7 @@ mod tests {
             .observe(|_: On<EventA>, mut res: ResMut<Order>| res.observed("a_1"))
             .id();
         world.add_observer(move |obs: On<EventA>, mut res: ResMut<Order>| {
-            assert_eq!(obs.target(), entity);
+            assert_eq!(obs.entity(), entity);
             res.observed("a_2");
         });
 
@@ -1011,19 +1011,19 @@ mod tests {
         let child = world.spawn(ChildOf(parent)).id();
 
         world.entity_mut(parent).observe(
-            move |trigger: On<EventPropagating>, mut res: ResMut<Order>| {
+            move |event: On<EventPropagating>, mut res: ResMut<Order>| {
                 res.observed("parent");
 
-                assert_eq!(trigger.target(), parent);
-                assert_eq!(trigger.original_target(), child);
+                assert_eq!(event.entity(), parent);
+                assert_eq!(event.original_entity(), child);
             },
         );
 
         world.entity_mut(child).observe(
-            move |trigger: On<EventPropagating>, mut res: ResMut<Order>| {
+            move |event: On<EventPropagating>, mut res: ResMut<Order>| {
                 res.observed("child");
-                assert_eq!(trigger.target(), child);
-                assert_eq!(trigger.original_target(), child);
+                assert_eq!(event.entity(), child);
+                assert_eq!(event.original_entity(), child);
             },
         );
 
@@ -1099,12 +1099,10 @@ mod tests {
 
         let child = world
             .spawn(ChildOf(parent))
-            .observe(
-                |mut trigger: On<EventPropagating>, mut res: ResMut<Order>| {
-                    res.observed("child");
-                    trigger.propagate(false);
-                },
-            )
+            .observe(|mut event: On<EventPropagating>, mut res: ResMut<Order>| {
+                res.observed("child");
+                event.propagate(false);
+            })
             .id();
 
         world.trigger_targets(EventPropagating, child);
@@ -1176,12 +1174,10 @@ mod tests {
 
         let child_a = world
             .spawn(ChildOf(parent_a))
-            .observe(
-                |mut trigger: On<EventPropagating>, mut res: ResMut<Order>| {
-                    res.observed("child_a");
-                    trigger.propagate(false);
-                },
-            )
+            .observe(|mut event: On<EventPropagating>, mut res: ResMut<Order>| {
+                res.observed("child_a");
+                event.propagate(false);
+            })
             .id();
 
         let parent_b = world
@@ -1230,8 +1226,8 @@ mod tests {
         world.init_resource::<Order>();
 
         world.add_observer(
-            |trigger: On<EventPropagating>, query: Query<&A>, mut res: ResMut<Order>| {
-                if query.get(trigger.target()).is_ok() {
+            |event: On<EventPropagating>, query: Query<&A>, mut res: ResMut<Order>| {
+                if query.get(event.entity()).is_ok() {
                     res.observed("event");
                 }
             },
@@ -1249,9 +1245,9 @@ mod tests {
     // Originally for https://github.com/bevyengine/bevy/issues/18452
     #[test]
     fn observer_modifies_relationship() {
-        fn on_add(trigger: On<Add, A>, mut commands: Commands) {
+        fn on_add(event: On<Add, A>, mut commands: Commands) {
             commands
-                .entity(trigger.target())
+                .entity(event.entity())
                 .with_related_entities::<crate::hierarchy::ChildOf>(|rsc| {
                     rsc.spawn_empty();
                 });
@@ -1327,8 +1323,8 @@ mod tests {
 
         let caller = MaybeLocation::caller();
         let mut world = World::new();
-        world.add_observer(move |trigger: On<EventA>| {
-            assert_eq!(trigger.caller(), caller);
+        world.add_observer(move |event: On<EventA>| {
+            assert_eq!(event.caller(), caller);
         });
         world.trigger(EventA);
     }
@@ -1341,11 +1337,11 @@ mod tests {
 
         let caller = MaybeLocation::caller();
         let mut world = World::new();
-        world.add_observer(move |trigger: On<Add, Component>| {
-            assert_eq!(trigger.caller(), caller);
+        world.add_observer(move |event: On<Add, Component>| {
+            assert_eq!(event.caller(), caller);
         });
-        world.add_observer(move |trigger: On<Remove, Component>| {
-            assert_eq!(trigger.caller(), caller);
+        world.add_observer(move |event: On<Remove, Component>| {
+            assert_eq!(event.caller(), caller);
         });
         world.commands().spawn(Component).clear();
     }
@@ -1360,13 +1356,11 @@ mod tests {
         let a_id = world.register_component::<A>();
         let b_id = world.register_component::<B>();
 
-        world.add_observer(
-            |trigger: On<EventA, (A, B)>, mut counter: ResMut<Counter>| {
-                for &component in trigger.components() {
-                    *counter.0.entry(component).or_default() += 1;
-                }
-            },
-        );
+        world.add_observer(|event: On<EventA, (A, B)>, mut counter: ResMut<Counter>| {
+            for &component in event.components() {
+                *counter.0.entry(component).or_default() += 1;
+            }
+        });
 
         world.trigger_targets(EventA, [a_id, b_id]);
         world.trigger_targets(EventA, a_id);
diff --git a/crates/bevy_ecs/src/observer/runner.rs b/crates/bevy_ecs/src/observer/runner.rs
index d843fb4589090..7f2536f5f8318 100644
--- a/crates/bevy_ecs/src/observer/runner.rs
+++ b/crates/bevy_ecs/src/observer/runner.rs
@@ -41,7 +41,7 @@ pub(super) fn observer_system_runner<E: Event, B: Bundle, S: ObserverSystem<E, B
     }
     state.last_trigger_id = last_trigger;
 
-    let trigger: On<E, B> = On::new(
+    let on: On<E, B> = On::new(
         // SAFETY: Caller ensures `ptr` is castable to `&mut T`
         unsafe { ptr.deref_mut() },
         propagate,
@@ -78,7 +78,7 @@ pub(super) fn observer_system_runner<E: Event, B: Bundle, S: ObserverSystem<E, B
         if let Err(RunSystemError::Failed(err)) = (*system)
             .validate_param_unsafe(world)
             .map_err(From::from)
-            .and_then(|()| (*system).run_unsafe(trigger, world))
+            .and_then(|()| (*system).run_unsafe(on, world))
         {
             let handler = state
                 .error_handler
diff --git a/crates/bevy_ecs/src/observer/system_param.rs b/crates/bevy_ecs/src/observer/system_param.rs
index 6637a0ce2472c..a09cda0676c8b 100644
--- a/crates/bevy_ecs/src/observer/system_param.rs
+++ b/crates/bevy_ecs/src/observer/system_param.rs
@@ -86,8 +86,8 @@ impl<'w, E, B: Bundle> On<'w, E, B> {
     /// #[derive(EntityEvent)]  
     /// struct AssertEvent;  
     ///
-    /// fn assert_observer(trigger: On<AssertEvent>) {  
-    ///     assert_eq!(trigger.observer(), trigger.target());  
+    /// fn assert_observer(event: On<AssertEvent>) {  
+    ///     assert_eq!(event.observer(), event.entity());  
     /// }  
     ///
     /// let mut world = World::new();  
@@ -109,20 +109,20 @@ impl<'w, E: EntityEvent, B: Bundle> On<'w, E, B> {
     /// Returns the [`Entity`] that was targeted by the `event` that triggered this observer.
     ///
     /// Note that if event propagation is enabled, this may not be the same as the original target of the event,
-    /// which can be accessed via [`On::original_target`].
+    /// which can be accessed via [`On::original_entity`].
     ///
     /// If the event was not targeted at a specific entity, this will return [`Entity::PLACEHOLDER`].
-    pub fn target(&self) -> Entity {
-        self.trigger.current_target.unwrap_or(Entity::PLACEHOLDER)
+    pub fn entity(&self) -> Entity {
+        self.trigger.entity.unwrap_or(Entity::PLACEHOLDER)
     }
 
     /// Returns the original [`Entity`] that the `event` was targeted at when it was first triggered.
     ///
-    /// If event propagation is not enabled, this will always return the same value as [`On::target`].
+    /// If event propagation is not enabled, this will always return the same value as [`On::entity`].
     ///
     /// If the event was not targeted at a specific entity, this will return [`Entity::PLACEHOLDER`].
-    pub fn original_target(&self) -> Entity {
-        self.trigger.original_target.unwrap_or(Entity::PLACEHOLDER)
+    pub fn original_entity(&self) -> Entity {
+        self.trigger.original_entity.unwrap_or(Entity::PLACEHOLDER)
     }
 
     /// Enables or disables event propagation, allowing the same event to trigger observers on a chain of different entities.
@@ -187,13 +187,13 @@ pub struct ObserverTrigger {
     pub components: SmallVec<[ComponentId; 2]>,
     /// The entity that the entity-event targeted, if any.
     ///
-    /// Note that if event propagation is enabled, this may not be the same as [`ObserverTrigger::original_target`].
-    pub current_target: Option<Entity>,
+    /// Note that if event propagation is enabled, this may not be the same as [`ObserverTrigger::original_entity`].
+    pub entity: Option<Entity>,
     /// The entity that the entity-event was originally targeted at, if any.
     ///
     /// If event propagation is enabled, this will be the first entity that the event was targeted at,
     /// even if the event was propagated to other entities.
-    pub original_target: Option<Entity>,
+    pub original_entity: Option<Entity>,
     /// The location of the source code that triggered the observer.
     pub caller: MaybeLocation,
 }
diff --git a/crates/bevy_ecs/src/relationship/related_methods.rs b/crates/bevy_ecs/src/relationship/related_methods.rs
index dbbe015f6b7f5..7cd539c7312e1 100644
--- a/crates/bevy_ecs/src/relationship/related_methods.rs
+++ b/crates/bevy_ecs/src/relationship/related_methods.rs
@@ -905,10 +905,10 @@ mod tests {
         let result_entity = world.spawn(ObserverResult::default()).id();
 
         world.add_observer(
-            move |trigger: On<Replace, MyComponent>,
+            move |event: On<Replace, MyComponent>,
                   has_relationship: Query<Has<ChildOf>>,
                   mut results: Query<&mut ObserverResult>| {
-                let entity = trigger.target();
+                let entity = event.entity();
                 if has_relationship.get(entity).unwrap_or(false) {
                     results.get_mut(result_entity).unwrap().success = true;
                 }
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index 26c767b0514df..d971e312a7034 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -1907,14 +1907,14 @@ mod tests {
         schedule.add_systems(|_query: Query<&Name>| todo!());
         schedule.add_systems(|_query: Query<&Name>| -> () { todo!() });
 
-        fn obs(_trigger: On<Add, Name>) {
+        fn obs(_event: On<Add, Name>) {
             todo!()
         }
 
         world.add_observer(obs);
-        world.add_observer(|_trigger: On<Add, Name>| {});
-        world.add_observer(|_trigger: On<Add, Name>| todo!());
-        world.add_observer(|_trigger: On<Add, Name>| -> () { todo!() });
+        world.add_observer(|_event: On<Add, Name>| {});
+        world.add_observer(|_event: On<Add, Name>| todo!());
+        world.add_observer(|_event: On<Add, Name>| -> () { todo!() });
 
         fn my_command(_world: &mut World) {
             todo!()
diff --git a/crates/bevy_ecs/src/world/deferred_world.rs b/crates/bevy_ecs/src/world/deferred_world.rs
index 92d2e98e5da69..9c247bcab2638 100644
--- a/crates/bevy_ecs/src/world/deferred_world.rs
+++ b/crates/bevy_ecs/src/world/deferred_world.rs
@@ -811,7 +811,7 @@ impl<'w> DeferredWorld<'w> {
         &mut self,
         event_key: EventKey,
         current_target: Option<Entity>,
-        original_target: Option<Entity>,
+        original_entity: Option<Entity>,
         components: impl Iterator<Item = ComponentId> + Clone,
         data: &mut E,
         mut propagate: bool,
@@ -823,7 +823,7 @@ impl<'w> DeferredWorld<'w> {
             self.reborrow(),
             event_key,
             current_target,
-            original_target,
+            original_entity,
             components.clone(),
             data,
             &mut propagate,
@@ -851,7 +851,7 @@ impl<'w> DeferredWorld<'w> {
                 self.reborrow(),
                 event_key,
                 Some(current_target),
-                original_target,
+                original_entity,
                 components.clone(),
                 data,
                 &mut propagate,
diff --git a/crates/bevy_ecs/src/world/entity_ref.rs b/crates/bevy_ecs/src/world/entity_ref.rs
index 643c4f1a029c1..5bdd86282efe7 100644
--- a/crates/bevy_ecs/src/world/entity_ref.rs
+++ b/crates/bevy_ecs/src/world/entity_ref.rs
@@ -6089,8 +6089,8 @@ mod tests {
         let mut world = World::new();
         let entity = world
             .spawn_empty()
-            .observe(|trigger: On<TestEvent>, mut commands: Commands| {
-                commands.entity(trigger.target()).insert(TestComponent(0));
+            .observe(|event: On<TestEvent>, mut commands: Commands| {
+                commands.entity(event.entity()).insert(TestComponent(0));
             })
             .id();
 
@@ -6108,8 +6108,8 @@ mod tests {
     #[should_panic]
     fn location_on_despawned_entity_panics() {
         let mut world = World::new();
-        world.add_observer(|trigger: On<Add, TestComponent>, mut commands: Commands| {
-            commands.entity(trigger.target()).despawn();
+        world.add_observer(|event: On<Add, TestComponent>, mut commands: Commands| {
+            commands.entity(event.entity()).despawn();
         });
         let entity = world.spawn_empty().id();
         let mut a = world.entity_mut(entity);
@@ -6198,19 +6198,19 @@ mod tests {
             .push("OrdA hook on_remove");
     }
 
-    fn ord_a_observer_on_add(_trigger: On<Add, OrdA>, mut res: ResMut<TestVec>) {
+    fn ord_a_observer_on_add(_event: On<Add, OrdA>, mut res: ResMut<TestVec>) {
         res.0.push("OrdA observer on_add");
     }
 
-    fn ord_a_observer_on_insert(_trigger: On<Insert, OrdA>, mut res: ResMut<TestVec>) {
+    fn ord_a_observer_on_insert(_event: On<Insert, OrdA>, mut res: ResMut<TestVec>) {
         res.0.push("OrdA observer on_insert");
     }
 
-    fn ord_a_observer_on_replace(_trigger: On<Replace, OrdA>, mut res: ResMut<TestVec>) {
+    fn ord_a_observer_on_replace(_event: On<Replace, OrdA>, mut res: ResMut<TestVec>) {
         res.0.push("OrdA observer on_replace");
     }
 
-    fn ord_a_observer_on_remove(_trigger: On<Remove, OrdA>, mut res: ResMut<TestVec>) {
+    fn ord_a_observer_on_remove(_event: On<Remove, OrdA>, mut res: ResMut<TestVec>) {
         res.0.push("OrdA observer on_remove");
     }
 
@@ -6249,19 +6249,19 @@ mod tests {
             .push("OrdB hook on_remove");
     }
 
-    fn ord_b_observer_on_add(_trigger: On<Add, OrdB>, mut res: ResMut<TestVec>) {
+    fn ord_b_observer_on_add(_event: On<Add, OrdB>, mut res: ResMut<TestVec>) {
         res.0.push("OrdB observer on_add");
     }
 
-    fn ord_b_observer_on_insert(_trigger: On<Insert, OrdB>, mut res: ResMut<TestVec>) {
+    fn ord_b_observer_on_insert(_event: On<Insert, OrdB>, mut res: ResMut<TestVec>) {
         res.0.push("OrdB observer on_insert");
     }
 
-    fn ord_b_observer_on_replace(_trigger: On<Replace, OrdB>, mut res: ResMut<TestVec>) {
+    fn ord_b_observer_on_replace(_event: On<Replace, OrdB>, mut res: ResMut<TestVec>) {
         res.0.push("OrdB observer on_replace");
     }
 
-    fn ord_b_observer_on_remove(_trigger: On<Remove, OrdB>, mut res: ResMut<TestVec>) {
+    fn ord_b_observer_on_remove(_event: On<Remove, OrdB>, mut res: ResMut<TestVec>) {
         res.0.push("OrdB observer on_remove");
     }
 
diff --git a/crates/bevy_ecs/src/world/error.rs b/crates/bevy_ecs/src/world/error.rs
index 49a904e201005..d04c28a5dfe10 100644
--- a/crates/bevy_ecs/src/world/error.rs
+++ b/crates/bevy_ecs/src/world/error.rs
@@ -91,15 +91,15 @@ mod tests {
         #[derive(EntityEvent)]
         struct FollowupEvent;
 
-        fn despawn(trigger: On<Kill>, mut commands: Commands) {
-            commands.entity(trigger.target()).despawn();
+        fn despawn(event: On<Kill>, mut commands: Commands) {
+            commands.entity(event.entity()).despawn();
         }
 
         fn followup(on: On<Kill>, mut commands: Commands) {
             // When using a simple .trigger() here, this panics because the entity has already been despawned.
             // Instead, we need to use `.queue_handled` or `.queue_silenced` to avoid the panic.
             commands
-                .entity(on.target())
+                .entity(on.entity())
                 .queue_silenced(trigger(FollowupEvent));
         }
 
diff --git a/crates/bevy_feathers/src/alpha_pattern.rs b/crates/bevy_feathers/src/alpha_pattern.rs
index 8252fb713847d..1a2732a2e57e8 100644
--- a/crates/bevy_feathers/src/alpha_pattern.rs
+++ b/crates/bevy_feathers/src/alpha_pattern.rs
@@ -47,7 +47,7 @@ fn on_add_alpha_pattern(
     mut q_material_node: Query<&mut MaterialNode<AlphaPatternMaterial>>,
     r_material: Res<AlphaPatternResource>,
 ) {
-    if let Ok(mut material) = q_material_node.get_mut(ev.target()) {
+    if let Ok(mut material) = q_material_node.get_mut(ev.entity()) {
         material.0 = r_material.0.clone();
     }
 }
diff --git a/crates/bevy_feathers/src/font_styles.rs b/crates/bevy_feathers/src/font_styles.rs
index 6419696bb70f4..96e76c5787ca3 100644
--- a/crates/bevy_feathers/src/font_styles.rs
+++ b/crates/bevy_feathers/src/font_styles.rs
@@ -50,13 +50,13 @@ pub(crate) fn on_changed_font(
     assets: Res<AssetServer>,
     mut commands: Commands,
 ) {
-    if let Ok(style) = font_style.get(ev.target())
+    if let Ok(style) = font_style.get(ev.entity())
         && let Some(font) = match style.font {
             HandleOrPath::Handle(ref h) => Some(h.clone()),
             HandleOrPath::Path(ref p) => Some(assets.load::<Font>(p)),
         }
     {
-        commands.entity(ev.target()).insert(Propagate(TextFont {
+        commands.entity(ev.entity()).insert(Propagate(TextFont {
             font,
             font_size: style.font_size,
             ..Default::default()
diff --git a/crates/bevy_feathers/src/theme.rs b/crates/bevy_feathers/src/theme.rs
index 1bb8f08e61825..1fd095b764c8e 100644
--- a/crates/bevy_feathers/src/theme.rs
+++ b/crates/bevy_feathers/src/theme.rs
@@ -109,7 +109,7 @@ pub(crate) fn on_changed_background(
     theme: Res<UiTheme>,
 ) {
     // Update background colors where the design token has changed.
-    if let Ok((mut bg, theme_bg)) = q_background.get_mut(ev.target()) {
+    if let Ok((mut bg, theme_bg)) = q_background.get_mut(ev.entity()) {
         bg.0 = theme.color(theme_bg.0);
     }
 }
@@ -120,7 +120,7 @@ pub(crate) fn on_changed_border(
     theme: Res<UiTheme>,
 ) {
     // Update background colors where the design token has changed.
-    if let Ok((mut border, theme_border)) = q_border.get_mut(ev.target()) {
+    if let Ok((mut border, theme_border)) = q_border.get_mut(ev.entity()) {
         border.set_all(theme.color(theme_border.0));
     }
 }
@@ -133,10 +133,10 @@ pub(crate) fn on_changed_font_color(
     theme: Res<UiTheme>,
     mut commands: Commands,
 ) {
-    if let Ok(token) = font_color.get(ev.target()) {
+    if let Ok(token) = font_color.get(ev.entity()) {
         let color = theme.color(token.0);
         commands
-            .entity(ev.target())
+            .entity(ev.entity())
             .insert(Propagate(TextColor(color)));
     }
 }
diff --git a/crates/bevy_input_focus/src/lib.rs b/crates/bevy_input_focus/src/lib.rs
index 3d1f8851350d8..9809a7627bd79 100644
--- a/crates/bevy_input_focus/src/lib.rs
+++ b/crates/bevy_input_focus/src/lib.rs
@@ -419,11 +419,11 @@ mod tests {
     struct GatherKeyboardEvents(String);
 
     fn gather_keyboard_events(
-        trigger: On<FocusedInput<KeyboardInput>>,
+        event: On<FocusedInput<KeyboardInput>>,
         mut query: Query<&mut GatherKeyboardEvents>,
     ) {
-        if let Ok(mut gather) = query.get_mut(trigger.target()) {
-            if let Key::Character(c) = &trigger.input.logical_key {
+        if let Ok(mut gather) = query.get_mut(event.entity()) {
+            if let Key::Character(c) = &event.input.logical_key {
                 gather.0.push_str(c.as_str());
             }
         }
diff --git a/crates/bevy_input_focus/src/tab_navigation.rs b/crates/bevy_input_focus/src/tab_navigation.rs
index e8eb6d85ce0dc..2599054313b65 100644
--- a/crates/bevy_input_focus/src/tab_navigation.rs
+++ b/crates/bevy_input_focus/src/tab_navigation.rs
@@ -322,14 +322,14 @@ pub(crate) fn acquire_focus(
     mut focus: ResMut<InputFocus>,
 ) {
     // If the entity has a TabIndex
-    if focusable.contains(ev.target()) {
+    if focusable.contains(ev.entity()) {
         // Stop and focus it
         ev.propagate(false);
         // Don't mutate unless we need to, for change detection
-        if focus.0 != Some(ev.target()) {
-            focus.0 = Some(ev.target());
+        if focus.0 != Some(ev.entity()) {
+            focus.0 = Some(ev.entity());
         }
-    } else if windows.contains(ev.target()) {
+    } else if windows.contains(ev.entity()) {
         // Stop and clear focus
         ev.propagate(false);
         // Don't mutate unless we need to, for change detection
@@ -366,7 +366,7 @@ fn click_to_focus(
     // for every ancestor, but only for the original entity. Also, users may want to stop
     // propagation on the pointer event at some point along the bubbling chain, so we need our
     // own dedicated event whose propagation we can control.
-    if ev.target() == ev.original_target() {
+    if ev.entity() == ev.original_entity() {
         // Clicking hides focus
         if focus_visible.0 {
             focus_visible.0 = false;
@@ -374,7 +374,7 @@ fn click_to_focus(
         // Search for a focusable parent entity, defaulting to window if none.
         if let Ok(window) = windows.single() {
             commands
-                .entity(ev.target())
+                .entity(ev.entity())
                 .trigger(AcquireFocus { window });
         }
     }
@@ -387,14 +387,14 @@ fn click_to_focus(
 ///
 /// Any [`TabNavigationError`]s that occur during tab navigation are logged as warnings.
 pub fn handle_tab_navigation(
-    mut trigger: On<FocusedInput<KeyboardInput>>,
+    mut event: On<FocusedInput<KeyboardInput>>,
     nav: TabNavigation,
     mut focus: ResMut<InputFocus>,
     mut visible: ResMut<InputFocusVisible>,
     keys: Res<ButtonInput<KeyCode>>,
 ) {
     // Tab navigation.
-    let key_event = &trigger.event().input;
+    let key_event = &event.input;
     if key_event.key_code == KeyCode::Tab
         && key_event.state == ButtonState::Pressed
         && !key_event.repeat
@@ -410,7 +410,7 @@ pub fn handle_tab_navigation(
 
         match maybe_next {
             Ok(next) => {
-                trigger.propagate(false);
+                event.propagate(false);
                 focus.set(next);
                 visible.0 = true;
             }
@@ -418,7 +418,7 @@ pub fn handle_tab_navigation(
                 warn!("Tab navigation error: {e}");
                 // This failure mode is recoverable, but still indicates a problem.
                 if let TabNavigationError::NoTabGroupForCurrentFocus { new_focus, .. } = e {
-                    trigger.propagate(false);
+                    event.propagate(false);
                     focus.set(new_focus);
                     visible.0 = true;
                 }
diff --git a/crates/bevy_pbr/src/render/light.rs b/crates/bevy_pbr/src/render/light.rs
index c9da2887ddfbf..155f2b2f2b9e9 100644
--- a/crates/bevy_pbr/src/render/light.rs
+++ b/crates/bevy_pbr/src/render/light.rs
@@ -614,30 +614,30 @@ pub struct LightViewEntities(EntityHashMap<Vec<Entity>>);
 
 // TODO: using required component
 pub(crate) fn add_light_view_entities(
-    trigger: On<Add, (ExtractedDirectionalLight, ExtractedPointLight)>,
+    event: On<Add, (ExtractedDirectionalLight, ExtractedPointLight)>,
     mut commands: Commands,
 ) {
-    if let Ok(mut v) = commands.get_entity(trigger.target()) {
+    if let Ok(mut v) = commands.get_entity(event.entity()) {
         v.insert(LightViewEntities::default());
     }
 }
 
 /// Removes [`LightViewEntities`] when light is removed. See [`add_light_view_entities`].
 pub(crate) fn extracted_light_removed(
-    trigger: On<Remove, (ExtractedDirectionalLight, ExtractedPointLight)>,
+    event: On<Remove, (ExtractedDirectionalLight, ExtractedPointLight)>,
     mut commands: Commands,
 ) {
-    if let Ok(mut v) = commands.get_entity(trigger.target()) {
+    if let Ok(mut v) = commands.get_entity(event.entity()) {
         v.try_remove::<LightViewEntities>();
     }
 }
 
 pub(crate) fn remove_light_view_entities(
-    trigger: On<Remove, LightViewEntities>,
+    event: On<Remove, LightViewEntities>,
     query: Query<&LightViewEntities>,
     mut commands: Commands,
 ) {
-    if let Ok(entities) = query.get(trigger.target()) {
+    if let Ok(entities) = query.get(event.entity()) {
         for v in entities.0.values() {
             for e in v.iter().copied() {
                 if let Ok(mut v) = commands.get_entity(e) {
diff --git a/crates/bevy_picking/src/events.rs b/crates/bevy_picking/src/events.rs
index b2f603562d2fe..f74ea32e7dcc7 100644
--- a/crates/bevy_picking/src/events.rs
+++ b/crates/bevy_picking/src/events.rs
@@ -11,7 +11,7 @@
 //! # use bevy_picking::prelude::*;
 //! # let mut world = World::default();
 //! world.spawn_empty()
-//!     .observe(|trigger: On<Pointer<Over>>| {
+//!     .observe(|event: On<Pointer<Over>>| {
 //!         println!("I am being hovered over");
 //!     });
 //! ```
diff --git a/crates/bevy_picking/src/lib.rs b/crates/bevy_picking/src/lib.rs
index 7a0e1dfb2b82d..266c0971822f9 100644
--- a/crates/bevy_picking/src/lib.rs
+++ b/crates/bevy_picking/src/lib.rs
@@ -17,12 +17,11 @@
 //! # struct MyComponent;
 //! # let mut world = World::new();
 //! world.spawn(MyComponent)
-//!     .observe(|mut trigger: On<Pointer<Click>>| {
-//!         println!("I was just clicked!");
-//!         // Get the underlying pointer event data
-//!         let click_event: &Pointer<Click> = trigger.event();
+//!     .observe(|mut event: On<Pointer<Click>>| {
+//!         // Read the underlying pointer event data
+//!         println!("Pointer {:?} was just clicked!", event.pointer_id);
 //!         // Stop the event from bubbling up the entity hierarchy
-//!         trigger.propagate(false);
+//!         event.propagate(false);
 //!     });
 //! ```
 //!
@@ -54,16 +53,15 @@
 //!     commands.spawn(Transform::default())
 //!         // Spawn your entity here, e.g. a `Mesh3d`.
 //!         // When dragged, mutate the `Transform` component on the dragged target entity:
-//!         .observe(|trigger: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>| {
-//!             let mut transform = transforms.get_mut(trigger.target()).unwrap();
-//!             let drag = trigger.event();
-//!             transform.rotate_local_y(drag.delta.x / 50.0);
+//!         .observe(|event: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>| {
+//!             let mut transform = transforms.get_mut(event.entity()).unwrap();
+//!             transform.rotate_local_y(event.delta.x / 50.0);
 //!         })
-//!         .observe(|trigger: On<Pointer<Click>>, mut commands: Commands| {
-//!             println!("Entity {} goes BOOM!", trigger.target());
-//!             commands.entity(trigger.target()).despawn();
+//!         .observe(|event: On<Pointer<Click>>, mut commands: Commands| {
+//!             println!("Entity {} goes BOOM!", event.entity());
+//!             commands.entity(event.entity()).despawn();
 //!         })
-//!         .observe(|trigger: On<Pointer<Over>>, mut events: EventWriter<Greeting>| {
+//!         .observe(|event: On<Pointer<Over>>, mut events: EventWriter<Greeting>| {
 //!             events.write(Greeting);
 //!         });
 //! }
diff --git a/crates/bevy_render/src/sync_world.rs b/crates/bevy_render/src/sync_world.rs
index 77643ba809052..f5cdff8fba38b 100644
--- a/crates/bevy_render/src/sync_world.rs
+++ b/crates/bevy_render/src/sync_world.rs
@@ -94,15 +94,15 @@ impl Plugin for SyncWorldPlugin {
     fn build(&self, app: &mut bevy_app::App) {
         app.init_resource::<PendingSyncEntity>();
         app.add_observer(
-            |trigger: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
-                pending.push(EntityRecord::Added(trigger.target()));
+            |event: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
+                pending.push(EntityRecord::Added(event.entity()));
             },
         );
         app.add_observer(
-            |trigger: On<Remove, SyncToRenderWorld>,
+            |event: On<Remove, SyncToRenderWorld>,
              mut pending: ResMut<PendingSyncEntity>,
              query: Query<&RenderEntity>| {
-                if let Ok(e) = query.get(trigger.target()) {
+                if let Ok(e) = query.get(event.entity()) {
                     pending.push(EntityRecord::Removed(*e));
                 };
             },
@@ -526,15 +526,15 @@ mod tests {
         main_world.init_resource::<PendingSyncEntity>();
 
         main_world.add_observer(
-            |trigger: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
-                pending.push(EntityRecord::Added(trigger.target()));
+            |event: On<Add, SyncToRenderWorld>, mut pending: ResMut<PendingSyncEntity>| {
+                pending.push(EntityRecord::Added(event.entity()));
             },
         );
         main_world.add_observer(
-            |trigger: On<Remove, SyncToRenderWorld>,
+            |event: On<Remove, SyncToRenderWorld>,
              mut pending: ResMut<PendingSyncEntity>,
              query: Query<&RenderEntity>| {
-                if let Ok(e) = query.get(trigger.target()) {
+                if let Ok(e) = query.get(event.entity()) {
                     pending.push(EntityRecord::Removed(*e));
                 };
             },
diff --git a/crates/bevy_render/src/view/window/screenshot.rs b/crates/bevy_render/src/view/window/screenshot.rs
index b87d76252c557..b613063a9532c 100644
--- a/crates/bevy_render/src/view/window/screenshot.rs
+++ b/crates/bevy_render/src/view/window/screenshot.rs
@@ -124,8 +124,8 @@ struct RenderScreenshotsSender(Sender<(Entity, Image)>);
 /// Saves the captured screenshot to disk at the provided path.
 pub fn save_to_disk(path: impl AsRef<Path>) -> impl FnMut(On<ScreenshotCaptured>) {
     let path = path.as_ref().to_owned();
-    move |trigger| {
-        let img = trigger.event().deref().clone();
+    move |event| {
+        let img = event.0.clone();
         match img.try_into_dynamic() {
             Ok(dyn_img) => match image::ImageFormat::from_path(&path) {
                 Ok(format) => {
diff --git a/crates/bevy_scene/src/scene_spawner.rs b/crates/bevy_scene/src/scene_spawner.rs
index 4abc70d81d18c..f3a9ab7e149de 100644
--- a/crates/bevy_scene/src/scene_spawner.rs
+++ b/crates/bevy_scene/src/scene_spawner.rs
@@ -880,21 +880,21 @@ mod tests {
     fn observe_trigger(app: &mut App, scene_id: InstanceId, scene_entity: Option<Entity>) {
         // Add observer
         app.world_mut().add_observer(
-            move |trigger: On<SceneInstanceReady>,
+            move |event: On<SceneInstanceReady>,
                   scene_spawner: Res<SceneSpawner>,
                   mut trigger_count: ResMut<TriggerCount>| {
                 assert_eq!(
-                    trigger.event().instance_id,
+                    event.event().instance_id,
                     scene_id,
                     "`SceneInstanceReady` contains the wrong `InstanceId`"
                 );
                 assert_eq!(
-                    trigger.target(),
+                    event.entity(),
                     scene_entity.unwrap_or(Entity::PLACEHOLDER),
                     "`SceneInstanceReady` triggered on the wrong parent entity"
                 );
                 assert!(
-                    scene_spawner.instance_is_ready(trigger.event().instance_id),
+                    scene_spawner.instance_is_ready(event.event().instance_id),
                     "`InstanceId` is not ready"
                 );
                 trigger_count.0 += 1;
diff --git a/crates/bevy_ui/src/interaction_states.rs b/crates/bevy_ui/src/interaction_states.rs
index b50f4cc245a64..88df5eebb9681 100644
--- a/crates/bevy_ui/src/interaction_states.rs
+++ b/crates/bevy_ui/src/interaction_states.rs
@@ -18,18 +18,15 @@ use bevy_ecs::{
 #[derive(Component, Debug, Clone, Copy, Default)]
 pub struct InteractionDisabled;
 
-pub(crate) fn on_add_disabled(trigger: On<Add, InteractionDisabled>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn on_add_disabled(event: On<Add, InteractionDisabled>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_disabled();
     }
 }
 
-pub(crate) fn on_remove_disabled(
-    trigger: On<Remove, InteractionDisabled>,
-    mut world: DeferredWorld,
-) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn on_remove_disabled(event: On<Remove, InteractionDisabled>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.clear_disabled();
     }
@@ -48,8 +45,8 @@ pub struct Checkable;
 #[derive(Component, Default, Debug)]
 pub struct Checked;
 
-pub(crate) fn on_add_checkable(trigger: On<Add, Checked>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn on_add_checkable(event: On<Add, Checked>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     let checked = entity.get::<Checked>().is_some();
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_toggled(match checked {
@@ -59,23 +56,23 @@ pub(crate) fn on_add_checkable(trigger: On<Add, Checked>, mut world: DeferredWor
     }
 }
 
-pub(crate) fn on_remove_checkable(trigger: On<Add, Checked>, mut world: DeferredWorld) {
+pub(crate) fn on_remove_checkable(event: On<Add, Checked>, mut world: DeferredWorld) {
     // Remove the 'toggled' attribute entirely.
-    let mut entity = world.entity_mut(trigger.target());
+    let mut entity = world.entity_mut(event.entity());
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.clear_toggled();
     }
 }
 
-pub(crate) fn on_add_checked(trigger: On<Add, Checked>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn on_add_checked(event: On<Add, Checked>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_toggled(accesskit::Toggled::True);
     }
 }
 
-pub(crate) fn on_remove_checked(trigger: On<Remove, Checked>, mut world: DeferredWorld) {
-    let mut entity = world.entity_mut(trigger.target());
+pub(crate) fn on_remove_checked(event: On<Remove, Checked>, mut world: DeferredWorld) {
+    let mut entity = world.entity_mut(event.entity());
     if let Some(mut accessibility) = entity.get_mut::<AccessibilityNode>() {
         accessibility.set_toggled(accesskit::Toggled::False);
     }
diff --git a/crates/bevy_winit/src/cursor/mod.rs b/crates/bevy_winit/src/cursor/mod.rs
index a1b6b55e50f90..c946a5160fefb 100644
--- a/crates/bevy_winit/src/cursor/mod.rs
+++ b/crates/bevy_winit/src/cursor/mod.rs
@@ -222,10 +222,10 @@ fn update_cursors(
 }
 
 /// Resets the cursor to the default icon when `CursorIcon` is removed.
-fn on_remove_cursor_icon(trigger: On<Remove, CursorIcon>, mut commands: Commands) {
+fn on_remove_cursor_icon(event: On<Remove, CursorIcon>, mut commands: Commands) {
     // Use `try_insert` to avoid panic if the window is being destroyed.
     commands
-        .entity(trigger.target())
+        .entity(event.entity())
         .try_insert(PendingCursor(Some(CursorSource::System(
             convert_system_cursor_icon(SystemCursorIcon::Default),
         ))));
diff --git a/examples/3d/edit_material_on_gltf.rs b/examples/3d/edit_material_on_gltf.rs
index f3aab3d4ccb45..de540f19f745a 100644
--- a/examples/3d/edit_material_on_gltf.rs
+++ b/examples/3d/edit_material_on_gltf.rs
@@ -58,7 +58,7 @@ fn setup_scene(mut commands: Commands, asset_server: Res<AssetServer>) {
 }
 
 fn change_material(
-    trigger: On<SceneInstanceReady>,
+    event: On<SceneInstanceReady>,
     mut commands: Commands,
     children: Query<&Children>,
     color_override: Query<&ColorOverride>,
@@ -66,12 +66,12 @@ fn change_material(
     mut asset_materials: ResMut<Assets<StandardMaterial>>,
 ) {
     // Get the `ColorOverride` of the entity, if it does not have a color override, skip
-    let Ok(color_override) = color_override.get(trigger.target()) else {
+    let Ok(color_override) = color_override.get(event.entity()) else {
         return;
     };
 
     // Iterate over all children recursively
-    for descendants in children.iter_descendants(trigger.target()) {
+    for descendants in children.iter_descendants(event.entity()) {
         // Get the material of the descendant
         if let Some(material) = mesh_materials
             .get(descendants)
diff --git a/examples/3d/solari.rs b/examples/3d/solari.rs
index 8907f8433f99f..3e3e8d4c07487 100644
--- a/examples/3d/solari.rs
+++ b/examples/3d/solari.rs
@@ -110,7 +110,7 @@ fn setup(
 }
 
 fn add_raytracing_meshes_on_scene_load(
-    trigger: On<SceneInstanceReady>,
+    event: On<SceneInstanceReady>,
     children: Query<&Children>,
     mesh: Query<&Mesh3d>,
     mut meshes: ResMut<Assets<Mesh>>,
@@ -132,7 +132,7 @@ fn add_raytracing_meshes_on_scene_load(
     }
 
     // Add raytracing mesh handles
-    for descendant in children.iter_descendants(trigger.target()) {
+    for descendant in children.iter_descendants(event.entity()) {
         if let Ok(mesh) = mesh.get(descendant) {
             commands
                 .entity(descendant)
diff --git a/examples/animation/animated_mesh.rs b/examples/animation/animated_mesh.rs
index cf1320115a4cf..7ae660c30d224 100644
--- a/examples/animation/animated_mesh.rs
+++ b/examples/animation/animated_mesh.rs
@@ -62,7 +62,7 @@ fn setup_mesh_and_animation(
 }
 
 fn play_animation_when_ready(
-    trigger: On<SceneInstanceReady>,
+    event: On<SceneInstanceReady>,
     mut commands: Commands,
     children: Query<&Children>,
     animations_to_play: Query<&AnimationToPlay>,
@@ -70,12 +70,12 @@ fn play_animation_when_ready(
 ) {
     // The entity we spawned in `setup_mesh_and_animation` is the trigger's target.
     // Start by finding the AnimationToPlay component we added to that entity.
-    if let Ok(animation_to_play) = animations_to_play.get(trigger.target()) {
+    if let Ok(animation_to_play) = animations_to_play.get(event.entity()) {
         // The SceneRoot component will have spawned the scene as a hierarchy
         // of entities parented to our entity. Since the asset contained a skinned
         // mesh and animations, it will also have spawned an animation player
         // component. Search our entity's descendants to find the animation player.
-        for child in children.iter_descendants(trigger.target()) {
+        for child in children.iter_descendants(event.entity()) {
             if let Ok(mut player) = players.get_mut(child) {
                 // Tell the animation player to start the animation and keep
                 // repeating it.
diff --git a/examples/animation/animated_mesh_events.rs b/examples/animation/animated_mesh_events.rs
index 6682f2e374349..776b8a0e21503 100644
--- a/examples/animation/animated_mesh_events.rs
+++ b/examples/animation/animated_mesh_events.rs
@@ -41,13 +41,13 @@ struct Animations {
 struct OnStep;
 
 fn observe_on_step(
-    trigger: On<OnStep>,
+    event: On<OnStep>,
     particle: Res<ParticleAssets>,
     mut commands: Commands,
     transforms: Query<&GlobalTransform>,
     mut seeded_rng: ResMut<SeededRng>,
 ) {
-    let translation = transforms.get(trigger.target()).unwrap().translation();
+    let translation = transforms.get(event.entity()).unwrap().translation();
     // Spawn a bunch of particles.
     for _ in 0..14 {
         let horizontal = seeded_rng.0.random::<Dir2>() * seeded_rng.0.random_range(8.0..12.0);
diff --git a/examples/animation/animation_events.rs b/examples/animation/animation_events.rs
index 8fcb7f9d64da8..b6e86a7f1b64a 100644
--- a/examples/animation/animation_events.rs
+++ b/examples/animation/animation_events.rs
@@ -25,12 +25,12 @@ struct MessageEvent {
 }
 
 fn edit_message(
-    trigger: On<MessageEvent>,
+    event: On<MessageEvent>,
     text: Single<(&mut Text2d, &mut TextColor), With<MessageText>>,
 ) {
     let (mut text, mut color) = text.into_inner();
-    text.0 = trigger.event().value.clone();
-    color.0 = trigger.event().color;
+    text.0 = event.value.clone();
+    color.0 = event.color;
 }
 
 fn setup(
diff --git a/examples/animation/morph_targets.rs b/examples/animation/morph_targets.rs
index 73cd8d7995db9..63e374ed7b1b4 100644
--- a/examples/animation/morph_targets.rs
+++ b/examples/animation/morph_targets.rs
@@ -56,14 +56,14 @@ fn setup(
 }
 
 fn play_animation_when_ready(
-    trigger: On<SceneInstanceReady>,
+    event: On<SceneInstanceReady>,
     mut commands: Commands,
     children: Query<&Children>,
     animations_to_play: Query<&AnimationToPlay>,
     mut players: Query<&mut AnimationPlayer>,
 ) {
-    if let Ok(animation_to_play) = animations_to_play.get(trigger.target()) {
-        for child in children.iter_descendants(trigger.target()) {
+    if let Ok(animation_to_play) = animations_to_play.get(event.entity()) {
+        for child in children.iter_descendants(event.entity()) {
             if let Ok(mut player) = players.get_mut(child) {
                 player.play(animation_to_play.index).repeat();
 
diff --git a/examples/ecs/entity_disabling.rs b/examples/ecs/entity_disabling.rs
index 3fc895cd09aac..0819d4d841d09 100644
--- a/examples/ecs/entity_disabling.rs
+++ b/examples/ecs/entity_disabling.rs
@@ -36,11 +36,11 @@ fn main() {
 struct DisableOnClick;
 
 fn disable_entities_on_click(
-    trigger: On<Pointer<Click>>,
+    event: On<Pointer<Click>>,
     valid_query: Query<&DisableOnClick>,
     mut commands: Commands,
 ) {
-    let clicked_entity = trigger.target();
+    let clicked_entity = event.entity();
     // Windows and text are entities and can be clicked!
     // We definitely don't want to disable the window itself,
     // because that would cause the app to close!
diff --git a/examples/ecs/error_handling.rs b/examples/ecs/error_handling.rs
index 7d3e007b8ae7e..e7ec1b54a1a0a 100644
--- a/examples/ecs/error_handling.rs
+++ b/examples/ecs/error_handling.rs
@@ -123,12 +123,12 @@ fn setup(
 
 // Observer systems can also return a `Result`.
 fn fallible_observer(
-    trigger: On<Pointer<Move>>,
+    event: On<Pointer<Move>>,
     mut world: DeferredWorld,
     mut step: Local<f32>,
 ) -> Result {
     let mut transform = world
-        .get_mut::<Transform>(trigger.target())
+        .get_mut::<Transform>(event.entity())
         .ok_or("No transform found.")?;
 
     *step = if transform.translation.x > 3. {
diff --git a/examples/ecs/observer_propagation.rs b/examples/ecs/observer_propagation.rs
index 5973e41922de0..d995f24d794f5 100644
--- a/examples/ecs/observer_propagation.rs
+++ b/examples/ecs/observer_propagation.rs
@@ -77,16 +77,16 @@ fn attack_armor(entities: Query<Entity, With<Armor>>, mut commands: Commands) {
     }
 }
 
-fn attack_hits(trigger: On<Attack>, name: Query<&Name>) {
-    if let Ok(name) = name.get(trigger.target()) {
+fn attack_hits(event: On<Attack>, name: Query<&Name>) {
+    if let Ok(name) = name.get(event.entity()) {
         info!("Attack hit {}", name);
     }
 }
 
 /// A callback placed on [`Armor`], checking if it absorbed all the [`Attack`] damage.
-fn block_attack(mut trigger: On<Attack>, armor: Query<(&Armor, &Name)>) {
-    let (armor, name) = armor.get(trigger.target()).unwrap();
-    let attack = trigger.event_mut();
+fn block_attack(mut event: On<Attack>, armor: Query<(&Armor, &Name)>) {
+    let (armor, name) = armor.get(event.entity()).unwrap();
+    let attack = event.event_mut();
     let damage = attack.damage.saturating_sub(**armor);
     if damage > 0 {
         info!(" {} damage passed through {}", damage, name);
@@ -96,7 +96,7 @@ fn block_attack(mut trigger: On<Attack>, armor: Query<(&Armor, &Name)>) {
     } else {
         info!("  {} damage blocked by {}", attack.damage, name);
         // Armor stopped the attack, the event stops here.
-        trigger.propagate(false);
+        event.propagate(false);
         info!("(propagation halted early)\n");
     }
 }
@@ -104,20 +104,20 @@ fn block_attack(mut trigger: On<Attack>, armor: Query<(&Armor, &Name)>) {
 /// A callback on the armor wearer, triggered when a piece of armor is not able to block an attack,
 /// or the wearer is attacked directly.
 fn take_damage(
-    trigger: On<Attack>,
+    event: On<Attack>,
     mut hp: Query<(&mut HitPoints, &Name)>,
     mut commands: Commands,
     mut app_exit: EventWriter<AppExit>,
 ) {
-    let attack = trigger.event();
-    let (mut hp, name) = hp.get_mut(trigger.target()).unwrap();
+    let attack = event.event();
+    let (mut hp, name) = hp.get_mut(event.entity()).unwrap();
     **hp = hp.saturating_sub(attack.damage);
 
     if **hp > 0 {
         info!("{} has {:.1} HP", name, hp.0);
     } else {
         warn!(" {} has died a gruesome death", name);
-        commands.entity(trigger.target()).despawn();
+        commands.entity(event.entity()).despawn();
         app_exit.write(AppExit::Success);
     }
 
diff --git a/examples/ecs/observers.rs b/examples/ecs/observers.rs
index fa399f3ab4ea3..4c9fbea4a3f92 100644
--- a/examples/ecs/observers.rs
+++ b/examples/ecs/observers.rs
@@ -16,12 +16,10 @@ fn main() {
         // Observers are systems that run when an event is "triggered". This observer runs whenever
         // `ExplodeMines` is triggered.
         .add_observer(
-            |trigger: On<ExplodeMines>,
+            |event: On<ExplodeMines>,
              mines: Query<&Mine>,
              index: Res<SpatialIndex>,
              mut commands: Commands| {
-                // You can access the trigger data via the `Observer`
-                let event = trigger.event();
                 // Access resources
                 for e in index.get_nearby(event.pos) {
                     // Run queries
@@ -112,30 +110,30 @@ fn setup(mut commands: Commands) {
     commands.spawn(observer);
 }
 
-fn on_add_mine(trigger: On<Add, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
-    let mine = query.get(trigger.target()).unwrap();
+fn on_add_mine(event: On<Add, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
+    let mine = query.get(event.entity()).unwrap();
     let tile = (
         (mine.pos.x / CELL_SIZE).floor() as i32,
         (mine.pos.y / CELL_SIZE).floor() as i32,
     );
-    index.map.entry(tile).or_default().insert(trigger.target());
+    index.map.entry(tile).or_default().insert(event.entity());
 }
 
 // Remove despawned mines from our index
-fn on_remove_mine(trigger: On<Remove, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
-    let mine = query.get(trigger.target()).unwrap();
+fn on_remove_mine(event: On<Remove, Mine>, query: Query<&Mine>, mut index: ResMut<SpatialIndex>) {
+    let mine = query.get(event.entity()).unwrap();
     let tile = (
         (mine.pos.x / CELL_SIZE).floor() as i32,
         (mine.pos.y / CELL_SIZE).floor() as i32,
     );
     index.map.entry(tile).and_modify(|set| {
-        set.remove(&trigger.target());
+        set.remove(&event.entity());
     });
 }
 
-fn explode_mine(trigger: On<Explode>, query: Query<&Mine>, mut commands: Commands) {
+fn explode_mine(event: On<Explode>, query: Query<&Mine>, mut commands: Commands) {
     // If a triggered event is targeting a specific entity you can access it with `.target()`
-    let id = trigger.target();
+    let id = event.entity();
     let Ok(mut entity) = commands.get_entity(id) else {
         return;
     };
diff --git a/examples/ecs/removal_detection.rs b/examples/ecs/removal_detection.rs
index a55fc70887616..88d4c4a54dd74 100644
--- a/examples/ecs/removal_detection.rs
+++ b/examples/ecs/removal_detection.rs
@@ -48,9 +48,9 @@ fn remove_component(
     }
 }
 
-fn react_on_removal(trigger: On<Remove, MyComponent>, mut query: Query<&mut Sprite>) {
-    // The `Remove` trigger was automatically called on the `Entity` that had its `MyComponent` removed.
-    let entity = trigger.target();
+fn react_on_removal(event: On<Remove, MyComponent>, mut query: Query<&mut Sprite>) {
+    // The `Remove` event was automatically triggered for the `Entity` that had its `MyComponent` removed.
+    let entity = event.entity();
     if let Ok(mut sprite) = query.get_mut(entity) {
         sprite.color = Color::srgb(0.5, 1., 1.);
     }
diff --git a/examples/no_std/library/src/lib.rs b/examples/no_std/library/src/lib.rs
index 3893d76d60a10..734417571d7b7 100644
--- a/examples/no_std/library/src/lib.rs
+++ b/examples/no_std/library/src/lib.rs
@@ -125,12 +125,12 @@ fn tick_timers(
     }
 }
 
-fn unwrap<B: Bundle>(trigger: On<Unwrap>, world: &mut World) {
-    if let Ok(mut target) = world.get_entity_mut(trigger.target())
+fn unwrap<B: Bundle>(event: On<Unwrap>, world: &mut World) {
+    if let Ok(mut target) = world.get_entity_mut(event.entity())
         && let Some(DelayedComponent(bundle)) = target.take::<DelayedComponent<B>>()
     {
         target.insert(bundle);
     }
 
-    world.despawn(trigger.observer());
+    world.despawn(event.observer());
 }
diff --git a/examples/picking/debug_picking.rs b/examples/picking/debug_picking.rs
index de6fbf0bcab24..da817c20a8873 100644
--- a/examples/picking/debug_picking.rs
+++ b/examples/picking/debug_picking.rs
@@ -48,13 +48,13 @@ fn setup_scene(
         .observe(on_click_spawn_cube)
         .observe(
             |out: On<Pointer<Out>>, mut texts: Query<&mut TextColor>| {
-                let mut text_color = texts.get_mut(out.target()).unwrap();
+                let mut text_color = texts.get_mut(out.entity()).unwrap();
                 text_color.0 = Color::WHITE;
             },
         )
         .observe(
             |over: On<Pointer<Over>>, mut texts: Query<&mut TextColor>| {
-                let mut color = texts.get_mut(over.target()).unwrap();
+                let mut color = texts.get_mut(over.entity()).unwrap();
                 color.0 = bevy::color::palettes::tailwind::CYAN_400.into();
             },
         );
@@ -102,7 +102,7 @@ fn on_click_spawn_cube(
 }
 
 fn on_drag_rotate(drag: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>) {
-    if let Ok(mut transform) = transforms.get_mut(drag.target()) {
+    if let Ok(mut transform) = transforms.get_mut(drag.entity()) {
         transform.rotate_y(drag.delta.x * 0.02);
         transform.rotate_x(drag.delta.y * 0.02);
     }
diff --git a/examples/picking/mesh_picking.rs b/examples/picking/mesh_picking.rs
index d1fa90c93f01e..da571ddbcd4f0 100644
--- a/examples/picking/mesh_picking.rs
+++ b/examples/picking/mesh_picking.rs
@@ -164,7 +164,7 @@ fn update_material_on<E: EntityEvent>(
     // versions of this observer, each triggered by a different event and with a different hardcoded
     // material. Instead, the event type is a generic, and the material is passed in.
     move |trigger, mut query| {
-        if let Ok(mut material) = query.get_mut(trigger.target()) {
+        if let Ok(mut material) = query.get_mut(trigger.entity()) {
             material.0 = new_material.clone();
         }
     }
@@ -191,7 +191,7 @@ fn rotate(mut query: Query<&mut Transform, With<Shape>>, time: Res<Time>) {
 
 /// An observer to rotate an entity when it is dragged
 fn rotate_on_drag(drag: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>) {
-    let mut transform = transforms.get_mut(drag.target()).unwrap();
+    let mut transform = transforms.get_mut(drag.entity()).unwrap();
     transform.rotate_y(drag.delta.x * 0.02);
     transform.rotate_x(drag.delta.y * 0.02);
 }
diff --git a/examples/picking/simple_picking.rs b/examples/picking/simple_picking.rs
index 04895ee034f97..2df796687e54a 100644
--- a/examples/picking/simple_picking.rs
+++ b/examples/picking/simple_picking.rs
@@ -26,12 +26,12 @@ fn setup_scene(
         ))
         .observe(on_click_spawn_cube)
         .observe(|out: On<Pointer<Out>>, mut texts: Query<&mut TextColor>| {
-            let mut text_color = texts.get_mut(out.target()).unwrap();
+            let mut text_color = texts.get_mut(out.entity()).unwrap();
             text_color.0 = Color::WHITE;
         })
         .observe(
             |over: On<Pointer<Over>>, mut texts: Query<&mut TextColor>| {
-                let mut color = texts.get_mut(over.target()).unwrap();
+                let mut color = texts.get_mut(over.entity()).unwrap();
                 color.0 = bevy::color::palettes::tailwind::CYAN_400.into();
             },
         );
@@ -78,7 +78,7 @@ fn on_click_spawn_cube(
 }
 
 fn on_drag_rotate(drag: On<Pointer<Drag>>, mut transforms: Query<&mut Transform>) {
-    if let Ok(mut transform) = transforms.get_mut(drag.target()) {
+    if let Ok(mut transform) = transforms.get_mut(drag.entity()) {
         transform.rotate_y(drag.delta.x * 0.02);
         transform.rotate_x(drag.delta.y * 0.02);
     }
diff --git a/examples/picking/sprite_picking.rs b/examples/picking/sprite_picking.rs
index 6c49f21e94d0d..09bfc34d438aa 100644
--- a/examples/picking/sprite_picking.rs
+++ b/examples/picking/sprite_picking.rs
@@ -154,7 +154,7 @@ fn recolor_on<E: EntityEvent + Debug + Clone + Reflect>(
     color: Color,
 ) -> impl Fn(On<E>, Query<&mut Sprite>) {
     move |ev, mut sprites| {
-        let Ok(mut sprite) = sprites.get_mut(ev.target()) else {
+        let Ok(mut sprite) = sprites.get_mut(ev.entity()) else {
             return;
         };
         sprite.color = color;
diff --git a/examples/shader/gpu_readback.rs b/examples/shader/gpu_readback.rs
index 7a2e6f373f868..8984256a5ee45 100644
--- a/examples/shader/gpu_readback.rs
+++ b/examples/shader/gpu_readback.rs
@@ -103,10 +103,10 @@ fn setup(
     // to stop reading back the data.
     commands
         .spawn(Readback::buffer(buffer.clone()))
-        .observe(|trigger: On<ReadbackComplete>| {
+        .observe(|event: On<ReadbackComplete>| {
             // This matches the type which was used to create the `ShaderStorageBuffer` above,
             // and is a convenient way to interpret the data.
-            let data: Vec<u32> = trigger.event().to_shader_type();
+            let data: Vec<u32> = event.to_shader_type();
             info!("Buffer {:?}", data);
         });
 
@@ -117,8 +117,8 @@ fn setup(
             4 * u32::SHADER_SIZE.get(), // skip the first four elements
             8 * u32::SHADER_SIZE.get(), // read eight elements
         ))
-        .observe(|trigger: On<ReadbackComplete>| {
-            let data: Vec<u32> = trigger.event().to_shader_type();
+        .observe(|event: On<ReadbackComplete>| {
+            let data: Vec<u32> = event.to_shader_type();
             info!("Buffer range {:?}", data);
         });
 
@@ -129,11 +129,11 @@ fn setup(
     // texture, as it will affect how the data is interpreted.
     commands
         .spawn(Readback::texture(image.clone()))
-        .observe(|trigger: On<ReadbackComplete>| {
+        .observe(|event: On<ReadbackComplete>| {
             // You probably want to interpret the data as a color rather than a `ShaderType`,
             // but in this case we know the data is a single channel storage texture, so we can
             // interpret it as a `Vec<u32>`
-            let data: Vec<u32> = trigger.event().to_shader_type();
+            let data: Vec<u32> = event.to_shader_type();
             info!("Image {:?}", data);
         });
     commands.insert_resource(ReadbackImage(image));
diff --git a/examples/stress_tests/many_foxes.rs b/examples/stress_tests/many_foxes.rs
index f6c56b1d1447b..f54fe6533cb18 100644
--- a/examples/stress_tests/many_foxes.rs
+++ b/examples/stress_tests/many_foxes.rs
@@ -232,18 +232,18 @@ fn setup(
 
 // Once the scene is loaded, start the animation
 fn setup_scene_once_loaded(
-    trigger: On<SceneInstanceReady>,
+    event: On<SceneInstanceReady>,
     animations: Res<Animations>,
     foxes: Res<Foxes>,
     mut commands: Commands,
     children: Query<&Children>,
     mut players: Query<&mut AnimationPlayer>,
 ) {
-    for child in children.iter_descendants(trigger.target()) {
+    for child in children.iter_descendants(event.entity()) {
         if let Ok(mut player) = players.get_mut(child) {
             let playing_animation = player.play(animations.node_indices[0]).repeat();
             if !foxes.sync {
-                playing_animation.seek_to(trigger.target().index() as f32 / 10.0);
+                playing_animation.seek_to(event.entity().index() as f32 / 10.0);
             }
             commands
                 .entity(child)
diff --git a/examples/testbed/3d.rs b/examples/testbed/3d.rs
index bfa2fbf648591..4a3a09d8e75c7 100644
--- a/examples/testbed/3d.rs
+++ b/examples/testbed/3d.rs
@@ -286,13 +286,13 @@ mod animation {
     }
 
     fn pause_animation_frame(
-        trigger: On<SceneInstanceReady>,
+        event: On<SceneInstanceReady>,
         children: Query<&Children>,
         mut commands: Commands,
         animation: Res<Animation>,
         mut players: Query<(Entity, &mut AnimationPlayer)>,
     ) {
-        for child in children.iter_descendants(trigger.target()) {
+        for child in children.iter_descendants(event.entity()) {
             if let Ok((entity, mut player)) = players.get_mut(child) {
                 let mut transitions = AnimationTransitions::new();
                 transitions
@@ -407,13 +407,13 @@ mod gltf_coordinate_conversion {
     }
 
     pub fn show_aabbs(
-        trigger: On<SceneInstanceReady>,
+        event: On<SceneInstanceReady>,
         mut commands: Commands,
         children: Query<&Children>,
         meshes: Query<(), With<Mesh3d>>,
     ) {
         for child in children
-            .iter_descendants(trigger.target())
+            .iter_descendants(event.entity())
             .filter(|&e| meshes.contains(e))
         {
             commands.entity(child).insert(ShowAabbGizmo {
diff --git a/examples/ui/core_widgets_observers.rs b/examples/ui/core_widgets_observers.rs
index 3cee538700bf5..38c0c6f072dc0 100644
--- a/examples/ui/core_widgets_observers.rs
+++ b/examples/ui/core_widgets_observers.rs
@@ -161,7 +161,7 @@ fn button(asset_server: &AssetServer, on_click: Callback<In<Activate>>) -> impl
 }
 
 fn button_on_add_pressed(
-    trigger: On<Add, Pressed>,
+    event: On<Add, Pressed>,
     mut buttons: Query<
         (
             &Hovered,
@@ -175,7 +175,7 @@ fn button_on_add_pressed(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((hovered, disabled, mut color, mut border_color, children)) =
-        buttons.get_mut(trigger.target())
+        buttons.get_mut(event.entity())
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -190,7 +190,7 @@ fn button_on_add_pressed(
 }
 
 fn button_on_remove_pressed(
-    trigger: On<Remove, Pressed>,
+    event: On<Remove, Pressed>,
     mut buttons: Query<
         (
             &Hovered,
@@ -204,7 +204,7 @@ fn button_on_remove_pressed(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((hovered, disabled, mut color, mut border_color, children)) =
-        buttons.get_mut(trigger.target())
+        buttons.get_mut(event.entity())
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -219,7 +219,7 @@ fn button_on_remove_pressed(
 }
 
 fn button_on_add_disabled(
-    trigger: On<Add, InteractionDisabled>,
+    event: On<Add, InteractionDisabled>,
     mut buttons: Query<
         (
             Has<Pressed>,
@@ -233,7 +233,7 @@ fn button_on_add_disabled(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((pressed, hovered, mut color, mut border_color, children)) =
-        buttons.get_mut(trigger.target())
+        buttons.get_mut(event.entity())
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -248,7 +248,7 @@ fn button_on_add_disabled(
 }
 
 fn button_on_remove_disabled(
-    trigger: On<Remove, InteractionDisabled>,
+    event: On<Remove, InteractionDisabled>,
     mut buttons: Query<
         (
             Has<Pressed>,
@@ -262,7 +262,7 @@ fn button_on_remove_disabled(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((pressed, hovered, mut color, mut border_color, children)) =
-        buttons.get_mut(trigger.target())
+        buttons.get_mut(event.entity())
     {
         let mut text = text_query.get_mut(children[0]).unwrap();
         set_button_style(
@@ -277,7 +277,7 @@ fn button_on_remove_disabled(
 }
 
 fn button_on_change_hover(
-    trigger: On<Insert, Hovered>,
+    event: On<Insert, Hovered>,
     mut buttons: Query<
         (
             Has<Pressed>,
@@ -292,7 +292,7 @@ fn button_on_change_hover(
     mut text_query: Query<&mut Text>,
 ) {
     if let Ok((pressed, hovered, disabled, mut color, mut border_color, children)) =
-        buttons.get_mut(trigger.target())
+        buttons.get_mut(event.entity())
     {
         if children.is_empty() {
             return;
@@ -424,12 +424,12 @@ fn slider(
 }
 
 fn slider_on_add_disabled(
-    trigger: On<Add, InteractionDisabled>,
+    event: On<Add, InteractionDisabled>,
     sliders: Query<(Entity, &Hovered), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut BackgroundColor, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, hovered)) = sliders.get(trigger.target()) {
+    if let Ok((slider_ent, hovered)) = sliders.get(event.entity()) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_bg, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -441,12 +441,12 @@ fn slider_on_add_disabled(
 }
 
 fn slider_on_remove_disabled(
-    trigger: On<Remove, InteractionDisabled>,
+    event: On<Remove, InteractionDisabled>,
     sliders: Query<(Entity, &Hovered), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut BackgroundColor, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, hovered)) = sliders.get(trigger.target()) {
+    if let Ok((slider_ent, hovered)) = sliders.get(event.entity()) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_bg, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -458,12 +458,12 @@ fn slider_on_remove_disabled(
 }
 
 fn slider_on_change_hover(
-    trigger: On<Insert, Hovered>,
+    event: On<Insert, Hovered>,
     sliders: Query<(Entity, &Hovered, Has<InteractionDisabled>), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut BackgroundColor, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, hovered, disabled)) = sliders.get(trigger.target()) {
+    if let Ok((slider_ent, hovered, disabled)) = sliders.get(event.entity()) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_bg, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -475,12 +475,12 @@ fn slider_on_change_hover(
 }
 
 fn slider_on_change_value(
-    trigger: On<Insert, SliderValue>,
+    event: On<Insert, SliderValue>,
     sliders: Query<(Entity, &SliderValue, &SliderRange), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut Node, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, value, range)) = sliders.get(trigger.target()) {
+    if let Ok((slider_ent, value, range)) = sliders.get(event.entity()) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_node, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -492,12 +492,12 @@ fn slider_on_change_value(
 }
 
 fn slider_on_change_range(
-    trigger: On<Insert, SliderRange>,
+    event: On<Insert, SliderRange>,
     sliders: Query<(Entity, &SliderValue, &SliderRange), With<DemoSlider>>,
     children: Query<&Children>,
     mut thumbs: Query<(&mut Node, Has<DemoSliderThumb>), Without<DemoSlider>>,
 ) {
-    if let Ok((slider_ent, value, range)) = sliders.get(trigger.target()) {
+    if let Ok((slider_ent, value, range)) = sliders.get(event.entity()) {
         for child in children.iter_descendants(slider_ent) {
             if let Ok((mut thumb_node, is_thumb)) = thumbs.get_mut(child)
                 && is_thumb
@@ -580,23 +580,23 @@ fn checkbox(
 }
 
 fn checkbox_on_add_disabled(
-    trigger: On<Add, InteractionDisabled>,
+    event: On<Add, InteractionDisabled>,
     checkboxes: Query<(&Hovered, Has<Checked>, &Children), With<DemoCheckbox>>,
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, checked, children)) = checkboxes.get(trigger.target()) {
+    if let Ok((hovered, checked, children)) = checkboxes.get(event.entity()) {
         set_checkbox_style(children, &mut borders, &mut marks, true, hovered.0, checked);
     }
 }
 
 fn checkbox_on_remove_disabled(
-    trigger: On<Remove, InteractionDisabled>,
+    event: On<Remove, InteractionDisabled>,
     checkboxes: Query<(&Hovered, Has<Checked>, &Children), With<DemoCheckbox>>,
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, checked, children)) = checkboxes.get(trigger.target()) {
+    if let Ok((hovered, checked, children)) = checkboxes.get(event.entity()) {
         set_checkbox_style(
             children,
             &mut borders,
@@ -609,7 +609,7 @@ fn checkbox_on_remove_disabled(
 }
 
 fn checkbox_on_change_hover(
-    trigger: On<Insert, Hovered>,
+    event: On<Insert, Hovered>,
     checkboxes: Query<
         (&Hovered, Has<InteractionDisabled>, Has<Checked>, &Children),
         With<DemoCheckbox>,
@@ -617,7 +617,7 @@ fn checkbox_on_change_hover(
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(trigger.target()) {
+    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(event.entity()) {
         set_checkbox_style(
             children,
             &mut borders,
@@ -630,7 +630,7 @@ fn checkbox_on_change_hover(
 }
 
 fn checkbox_on_add_checked(
-    trigger: On<Add, Checked>,
+    event: On<Add, Checked>,
     checkboxes: Query<
         (&Hovered, Has<InteractionDisabled>, Has<Checked>, &Children),
         With<DemoCheckbox>,
@@ -638,7 +638,7 @@ fn checkbox_on_add_checked(
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(trigger.target()) {
+    if let Ok((hovered, disabled, checked, children)) = checkboxes.get(event.entity()) {
         set_checkbox_style(
             children,
             &mut borders,
@@ -651,12 +651,12 @@ fn checkbox_on_add_checked(
 }
 
 fn checkbox_on_remove_checked(
-    trigger: On<Remove, Checked>,
+    event: On<Remove, Checked>,
     checkboxes: Query<(&Hovered, Has<InteractionDisabled>, &Children), With<DemoCheckbox>>,
     mut borders: Query<(&mut BorderColor, &mut Children), Without<DemoCheckbox>>,
     mut marks: Query<&mut BackgroundColor, (Without<DemoCheckbox>, Without<Children>)>,
 ) {
-    if let Ok((hovered, disabled, children)) = checkboxes.get(trigger.target()) {
+    if let Ok((hovered, disabled, children)) = checkboxes.get(event.entity()) {
         set_checkbox_style(
             children,
             &mut borders,
diff --git a/examples/ui/directional_navigation.rs b/examples/ui/directional_navigation.rs
index 60cc8370ca89b..91c14782c582c 100644
--- a/examples/ui/directional_navigation.rs
+++ b/examples/ui/directional_navigation.rs
@@ -67,10 +67,10 @@ const FOCUSED_BORDER: Srgba = bevy::color::palettes::tailwind::BLUE_50;
 // In a real project, each button would also have its own unique behavior,
 // to capture the actual intent of the user
 fn universal_button_click_behavior(
-    mut trigger: On<Pointer<Click>>,
+    mut event: On<Pointer<Click>>,
     mut button_query: Query<(&mut BackgroundColor, &mut ResetTimer)>,
 ) {
-    let button_entity = trigger.target();
+    let button_entity = event.entity();
     if let Ok((mut color, mut reset_timer)) = button_query.get_mut(button_entity) {
         // This would be a great place to play a little sound effect too!
         color.0 = PRESSED_BUTTON.into();
@@ -78,7 +78,7 @@ fn universal_button_click_behavior(
 
         // Picking events propagate up the hierarchy,
         // so we need to stop the propagation here now that we've handled it
-        trigger.propagate(false);
+        event.propagate(false);
     }
 }
 
diff --git a/examples/ui/drag_to_scroll.rs b/examples/ui/drag_to_scroll.rs
index b66d85c80056c..e3e048b4b3744 100644
--- a/examples/ui/drag_to_scroll.rs
+++ b/examples/ui/drag_to_scroll.rs
@@ -63,7 +63,7 @@ fn setup(mut commands: Commands) {
                 &mut ScrollStart),
                 With<ScrollableNode>,
             >| {
-                if on.target() != on.original_target() {
+                if on.entity() != on.original_entity() {
                     return;
                 }
                 if let Ok((computed_node, mut start)) = scroll_position_query.single_mut() {
@@ -104,12 +104,12 @@ fn setup(mut commands: Commands) {
                                 BackgroundColor(tile_color),
                             ))
                             .observe(|on_enter: On<Pointer<Over>>, mut query: Query<&mut BackgroundColor>, | {
-                                if let Ok(mut background_color) = query.get_mut(on_enter.target()) {
+                                if let Ok(mut background_color) = query.get_mut(on_enter.entity()) {
                                     background_color.0 = RED.into();
                                 }
                             })
                             .observe(|on_enter: On<Pointer<Out>>, mut query: Query<(&mut BackgroundColor, &TileColor)>,| {
-                                if let Ok((mut background_color, tile_color)) = query.get_mut(on_enter.target()) {
+                                if let Ok((mut background_color, tile_color)) = query.get_mut(on_enter.entity()) {
                                     background_color.0 = tile_color.0;
                                 }
                             });
diff --git a/examples/ui/gradients.rs b/examples/ui/gradients.rs
index a01ecedd68928..a5dedb0cc7065 100644
--- a/examples/ui/gradients.rs
+++ b/examples/ui/gradients.rs
@@ -201,17 +201,17 @@ fn setup(mut commands: Commands) {
                             TextShadow::default(),
                         )]
                 )).observe(
-                    |_trigger: On<Pointer<Over>>, mut border_query: Query<&mut BorderColor, With<Button>>| {
+                    |_event: On<Pointer<Over>>, mut border_query: Query<&mut BorderColor, With<Button>>| {
                     *border_query.single_mut().unwrap() = BorderColor::all(RED);
 
 
                 })
                 .observe(
-                    |_trigger: On<Pointer<Out>>, mut border_query: Query<&mut BorderColor, With<Button>>| {
+                    |_event: On<Pointer<Out>>, mut border_query: Query<&mut BorderColor, With<Button>>| {
                     *border_query.single_mut().unwrap() = BorderColor::all(Color::WHITE);
                 })
                 .observe(
-                        |_trigger: On<Pointer<Click>>,
+                        |_event: On<Pointer<Click>>,
                             mut gradients_query: Query<&mut BackgroundGradient>,
                             mut label_query: Query<
                             &mut Text,
diff --git a/examples/ui/render_ui_to_texture.rs b/examples/ui/render_ui_to_texture.rs
index 7c5e2810fb1f8..e3be16cb4156e 100644
--- a/examples/ui/render_ui_to_texture.rs
+++ b/examples/ui/render_ui_to_texture.rs
@@ -101,7 +101,7 @@ fn setup(
                 ))
                 .observe(
                     |pointer: On<Pointer<Drag>>, mut nodes: Query<(&mut Node, &ComputedNode)>| {
-                        let (mut node, computed) = nodes.get_mut(pointer.target()).unwrap();
+                        let (mut node, computed) = nodes.get_mut(pointer.entity()).unwrap();
                         node.left =
                             Val::Px(pointer.pointer_location.position.x - computed.size.x / 2.0);
                         node.top = Val::Px(pointer.pointer_location.position.y - 50.0);
@@ -109,12 +109,12 @@ fn setup(
                 )
                 .observe(
                     |pointer: On<Pointer<Over>>, mut colors: Query<&mut BackgroundColor>| {
-                        colors.get_mut(pointer.target()).unwrap().0 = RED.into();
+                        colors.get_mut(pointer.entity()).unwrap().0 = RED.into();
                     },
                 )
                 .observe(
                     |pointer: On<Pointer<Out>>, mut colors: Query<&mut BackgroundColor>| {
-                        colors.get_mut(pointer.target()).unwrap().0 = BLUE.into();
+                        colors.get_mut(pointer.entity()).unwrap().0 = BLUE.into();
                     },
                 )
                 .with_children(|parent| {
diff --git a/examples/ui/scroll.rs b/examples/ui/scroll.rs
index 33f88cd6c1814..46f5ca362005b 100644
--- a/examples/ui/scroll.rs
+++ b/examples/ui/scroll.rs
@@ -58,11 +58,11 @@ struct Scroll {
 }
 
 fn on_scroll_handler(
-    mut trigger: On<Scroll>,
+    mut event: On<Scroll>,
     mut query: Query<(&mut ScrollPosition, &Node, &ComputedNode)>,
 ) {
-    let target = trigger.target();
-    let delta = &mut trigger.event_mut().delta;
+    let target = event.entity();
+    let delta = &mut event.delta;
 
     let Ok((mut scroll_position, node, computed)) = query.get_mut(target) else {
         return;
@@ -102,7 +102,7 @@ fn on_scroll_handler(
 
     // Stop propagating when the delta is fully consumed.
     if *delta == Vec2::ZERO {
-        trigger.propagate(false);
+        event.propagate(false);
     }
 }
 
@@ -174,9 +174,9 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                                         },
                                     ))
                                     .observe(
-                                        |trigger: On<Pointer<Press>>, mut commands: Commands| {
-                                            if trigger.event().button == PointerButton::Primary {
-                                                commands.entity(trigger.target()).despawn();
+                                        |event: On<Pointer<Press>>, mut commands: Commands| {
+                                            if event.event().button == PointerButton::Primary {
+                                                commands.entity(event.entity()).despawn();
                                             }
                                         },
                                     );
diff --git a/examples/ui/tab_navigation.rs b/examples/ui/tab_navigation.rs
index cf5457c3ea566..766016fb1a3f3 100644
--- a/examples/ui/tab_navigation.rs
+++ b/examples/ui/tab_navigation.rs
@@ -83,9 +83,9 @@ fn setup(mut commands: Commands) {
             ..default()
         })
         .observe(
-            |mut trigger: On<Pointer<Click>>, mut focus: ResMut<InputFocus>| {
+            |mut event: On<Pointer<Click>>, mut focus: ResMut<InputFocus>| {
                 focus.0 = None;
-                trigger.propagate(false);
+                event.propagate(false);
             },
         )
         .with_children(|parent| {
@@ -140,10 +140,10 @@ fn setup(mut commands: Commands) {
                                     )],
                                 ))
                                 .observe(
-                                    |mut trigger: On<Pointer<Click>>,
+                                    |mut event: On<Pointer<Click>>,
                                     mut focus: ResMut<InputFocus>| {
-                                        focus.0 = Some(trigger.target());
-                                        trigger.propagate(false);
+                                        focus.0 = Some(event.entity());
+                                        event.propagate(false);
                                     },
                                 );
                         }
diff --git a/examples/ui/viewport_node.rs b/examples/ui/viewport_node.rs
index 4e10477817c7b..0438004886758 100644
--- a/examples/ui/viewport_node.rs
+++ b/examples/ui/viewport_node.rs
@@ -89,7 +89,7 @@ fn test(
 
 fn on_drag_viewport(drag: On<Pointer<Drag>>, mut node_query: Query<&mut Node>) {
     if matches!(drag.button, PointerButton::Secondary) {
-        let mut node = node_query.get_mut(drag.target()).unwrap();
+        let mut node = node_query.get_mut(drag.entity()).unwrap();
 
         if let (Val::Px(top), Val::Px(left)) = (node.top, node.left) {
             node.left = Val::Px(left + drag.delta.x);
@@ -100,7 +100,7 @@ fn on_drag_viewport(drag: On<Pointer<Drag>>, mut node_query: Query<&mut Node>) {
 
 fn on_drag_cuboid(drag: On<Pointer<Drag>>, mut transform_query: Query<&mut Transform>) {
     if matches!(drag.button, PointerButton::Primary) {
-        let mut transform = transform_query.get_mut(drag.target()).unwrap();
+        let mut transform = transform_query.get_mut(drag.entity()).unwrap();
         transform.rotate_y(drag.delta.x * 0.02);
         transform.rotate_x(drag.delta.y * 0.02);
     }
diff --git a/examples/usage/context_menu.rs b/examples/usage/context_menu.rs
index 9ccd3e4b4b7e3..cb1316fd783ea 100644
--- a/examples/usage/context_menu.rs
+++ b/examples/usage/context_menu.rs
@@ -40,13 +40,13 @@ fn main() {
 fn text_color_on_hover<T: Debug + Clone + Reflect>(
     color: Color,
 ) -> impl FnMut(On<Pointer<T>>, Query<&mut TextColor>, Query<&Children>) {
-    move |mut trigger: On<Pointer<T>>,
+    move |mut event: On<Pointer<T>>,
           mut text_color: Query<&mut TextColor>,
           children: Query<&Children>| {
-        let Ok(children) = children.get(trigger.original_target()) else {
+        let Ok(children) = children.get(event.original_entity()) else {
             return;
         };
-        trigger.propagate(false);
+        event.propagate(false);
 
         // find the text among children and change its color
         for child in children.iter() {
@@ -69,7 +69,7 @@ fn setup(mut commands: Commands) {
 }
 
 fn on_trigger_close_menus(
-    _trigger: On<CloseContextMenus>,
+    _event: On<CloseContextMenus>,
     mut commands: Commands,
     menus: Query<Entity, With<ContextMenu>>,
 ) {
@@ -78,10 +78,10 @@ fn on_trigger_close_menus(
     }
 }
 
-fn on_trigger_menu(trigger: On<OpenContextMenu>, mut commands: Commands) {
+fn on_trigger_menu(event: On<OpenContextMenu>, mut commands: Commands) {
     commands.trigger(CloseContextMenus);
 
-    let pos = trigger.pos;
+    let pos = event.pos;
 
     debug!("open context menu at: {pos}");
 
@@ -108,11 +108,11 @@ fn on_trigger_menu(trigger: On<OpenContextMenu>, mut commands: Commands) {
             ],
         ))
         .observe(
-            |trigger: On<Pointer<Press>>,
+            |event: On<Pointer<Press>>,
              menu_items: Query<&ContextMenuItem>,
              mut clear_col: ResMut<ClearColor>,
              mut commands: Commands| {
-                let target = trigger.original_target();
+                let target = event.original_entity();
 
                 if let Ok(item) = menu_items.get(target) {
                     clear_col.0 = item.0.into();
@@ -181,15 +181,15 @@ fn background_and_button() -> impl Bundle {
                         TextShadow::default(),
                     )],
                 ))
-                .observe(|mut trigger: On<Pointer<Press>>, mut commands: Commands| {
+                .observe(|mut event: On<Pointer<Press>>, mut commands: Commands| {
                     // by default this event would bubble up further leading to the `CloseContextMenus`
                     // event being triggered and undoing the opening of one here right away.
-                    trigger.propagate(false);
+                    event.propagate(false);
 
-                    debug!("click: {}", trigger.pointer_location.position);
+                    debug!("click: {}", event.pointer_location.position);
 
                     commands.trigger(OpenContextMenu {
-                        pos: trigger.pointer_location.position,
+                        pos: event.pointer_location.position,
                     });
                 });
         })),
diff --git a/release-content/migration-guides/dragenter_includes_dragged_entity.md b/release-content/migration-guides/dragenter_includes_dragged_entity.md
index 37fb022d58be8..319275d359ba0 100644
--- a/release-content/migration-guides/dragenter_includes_dragged_entity.md
+++ b/release-content/migration-guides/dragenter_includes_dragged_entity.md
@@ -5,4 +5,4 @@ pull_requests: [19179]
 
 DragEnter events are now triggered when entering any entity, even the originally dragged one. This makes the behavior more consistent.
 
-The old behavior can be achieved by checking if trigger.target != trigger.dragged
+The old behavior can be achieved by checking if trigger.entity != trigger.dragged
diff --git a/release-content/migration-guides/observer_triggers.md b/release-content/migration-guides/observer_triggers.md
index c3f82f85d8050..6a2f7d298c594 100644
--- a/release-content/migration-guides/observer_triggers.md
+++ b/release-content/migration-guides/observer_triggers.md
@@ -8,12 +8,12 @@ The `Trigger` type used inside observers has been renamed to `On` for a cleaner
 ```rust
 // Old
 commands.add_observer(|trigger: Trigger<OnAdd, Player>| {
-    info!("Spawned player {}", trigger.target());
+    info!("Spawned player {}", trigger.entity());
 });
 
 // New
-commands.add_observer(|trigger: On<Add, Player>| {
-    info!("Spawned player {}", trigger.target());
+commands.add_observer(|event: On<Add, Player>| {
+    info!("Spawned player {}", event.entity());
 });
 ```
 
@@ -26,7 +26,7 @@ Observers may be triggered on particular entities or globally.
 Previously, a global trigger would claim to trigger on a particular `Entity`, `Entity::PLACEHOLDER`.
 For correctness and transparency, triggers have been changed to `Option<Entity>`.
 
-`On::target` (previously `Trigger::target`) now returns `Option<Entity>`, and `ObserverTrigger::target`
+`On::entity` (previously `Trigger::target`) now returns `Option<Entity>`, and `ObserverTrigger::target`
 is now of type `Option<Entity>`. If you were checking for `Entity::PLACEHOLDER`, migrate to handling the `None` case.
 If you were not checking for `Entity::PLACEHOLDER`, migrate to unwrapping, as `Entity::PLACEHOLDER`
 would have caused a panic before, at a later point.
diff --git a/release-content/migration-guides/pointer_target.md b/release-content/migration-guides/pointer_target.md
index 912296164736c..57fc4f578d730 100644
--- a/release-content/migration-guides/pointer_target.md
+++ b/release-content/migration-guides/pointer_target.md
@@ -4,7 +4,7 @@ pull_requests: [19663]
 ---
 
 The `Pointer.target` field, which tracks the original target of the pointer event before bubbling, has been removed.
-Instead, all observers now track this information, available via the `On::original_target()` method.
+Instead, all observers now track this information, available via the `On::original_entity()` method.
 
 If you were using this information via the buffered event API of picking, please migrate to observers.
 If you cannot for performance reasons, please open an issue explaining your exact use case!
@@ -20,11 +20,14 @@ struct TransformedEntityEvent<E: EntityEvent> {
 }
 
 // A generic observer that handles this transformation
-fn transform_entity_event<E: EntityEvent>(trigger: On<E>, event_writer: EventWriter<TransformedEntityEvent<E>>){
-    if trigger.target() == trigger.original_target(){
-        event_writer.send(trigger.event())
+fn transform_entity_event<E: EntityEvent>(event: On<E>, event_writer: EventWriter<TransformedEntityEvent<E>>){
+    if event.entity() == event.original_entity() {
+        event_writer.send(TransformedEntityEvent {
+            event: event.event().clone(),
+            entity: event.entity(),
+        );
     }
 }
 ```
 
-Additionally, the `ObserverTrigger::target` field has been renamed to `ObserverTrigger::current_target` and a new `ObserverTrigger::original_target` field has been added.
+Additionally, the `ObserverTrigger::target` field has been renamed to `ObserverTrigger::entity` and a new `ObserverTrigger::original_entity` field has been added.
diff --git a/release-content/release-notes/event_split.md b/release-content/release-notes/event_split.md
index b650c29e73303..a1b90f4edc514 100644
--- a/release-content/release-notes/event_split.md
+++ b/release-content/release-notes/event_split.md
@@ -46,8 +46,8 @@ struct Speak {
 You can then `trigger` the event, and use a global observer for reacting to it.
 
 ```rust
-app.add_observer(|trigger: On<Speak>| {
-    println!("{}", trigger.message);
+app.add_observer(|event: On<Speak>| {
+    println!("{}", event.message);
 });
 
 // ...
@@ -81,10 +81,10 @@ let enemy = commands.spawn((Enemy, Health(100.0))).id();
 // which can then handle the event with its own observer.
 let armor_piece = commands
     .spawn((ArmorPiece, Health(25.0), ChildOf(enemy)))
-    .observe(|trigger: On<Damage>, mut query: Query<&mut Health>| {
-        // Note: `On::target` only exists because this is an `EntityEvent`.
-        let mut health = query.get(trigger.target()).unwrap();
-        health.0 -= trigger.amount();
+    .observe(|event: On<Damage>, mut query: Query<&mut Health>| {
+        // Note: `On::entity` only exists because this is an `EntityEvent`.
+        let mut health = query.get(event.entity()).unwrap();
+        health.0 -= event.amount();
     })
     .id();
 
diff --git a/release-content/release-notes/observer_overhaul.md b/release-content/release-notes/observer_overhaul.md
index 7cb2409743845..e21b8058a553a 100644
--- a/release-content/release-notes/observer_overhaul.md
+++ b/release-content/release-notes/observer_overhaul.md
@@ -10,7 +10,7 @@ In past releases, the observer API looked like this:
 
 ```rust
 app.add_observer(|trigger: Trigger<OnAdd, Player>| {
-    info!("Added player {}", trigger.target());
+    info!("Added player {}", trigger.entity());
 });
 ```
 
@@ -21,8 +21,8 @@ for a `Player`.
 such as `OnAdd` and `OnRemove`:
 
 ```rust
-app.add_observer(|trigger: On<Add, Player>| {
-    info!("Added player {}", trigger.target());
+app.add_observer(|event: On<Add, Player>| {
+    info!("Added player {}", event.entity());
 });
 ```
 
@@ -39,7 +39,7 @@ to disambiguate by using `ops::Add`, for example.
 allowing you to bubble events up your hierarchy to see if any of the parents care,
 then act on the entity that was actually picked in the first place.
 
-This was handy! We've enabled this functionality for all entity-events: simply call `On::original_target`.
+This was handy! We've enabled this functionality for all entity-events: simply call `On::original_entity`.
 
 ## Expose name of the Observer's system
 
