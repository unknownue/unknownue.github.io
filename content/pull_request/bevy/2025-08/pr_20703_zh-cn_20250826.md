+++
title = "#20703 Use a correct default value for half space initialization in from_clip_from_world_no_far"
date = "2025-08-26T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = false

[extra]
current_language = "zh-cn"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20703-en-20250826" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20703-zh-cn-20250826" }}
labels = ["C-Bug", "A-Rendering", "D-Straightforward"]
+++

# Title

## Basic Information
- **Title**: Use a correct default value for half space initialization in from_clip_from_world_no_far
- **PR Link**: https://github.com/bevyengine/bevy/pull/20703
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: C-Bug, A-Rendering, S-Ready-For-Final-Review, D-Straightforward
- **Created**: 2025-08-22T07:28:23Z
- **Merged**: 2025-08-26T03:49:23Z
- **Merged By**: alice-i-cecile

## Description Translation
**Objective**

- 修复一个bug：当启用远平面裁剪时，通过from_clip_from_world_no_far构造的Frustums会将所有Aabbs和所有零半径球体视为不在视锥体内

**Solution**

- 初始化为正确的默认值

**Testing**

- 该bug在实际使用中尚未被发现，仅通过代码审计发现。例如，在intersects_obb函数中的半空间循环中：
```rs
let relative_radius = aabb.relative_radius(&p_normal, &world_from_local.matrix3);
if half_space.normal_d().dot(aabb_center_world) + relative_radius <= 0.0 {
    return false;
}
```
relative_radius是与视锥体平面（值为0）进行一系列点积运算的结果，因此为0。
法向量与AABB中心的点积再次为0，0 + 0 = 0，小于等于0。if条件被触发，intersects错误地返回false。

将d改为f32::MAX后，法向量与中心扩展1后的点积结果为f32::MAX，不小于等于0，因此相交检测可以成功。

## The Story of This Pull Request

这个PR解决了一个在Bevy渲染系统中的视锥体裁剪bug。问题出现在`Frustum::from_clip_from_world_no_far`方法中，该方法用于构造一个不包含远平面的视锥体。

**问题根源**

在视锥体相交检测算法中，代码使用六个半空间（half spaces）来定义视锥体的边界。当使用`from_clip_from_world_no_far`方法时，第六个半空间（对应远平面）没有被正确初始化。具体来说，这个半空间的法向量和距离值被设置为零向量和零值。

这导致了一个严重的逻辑错误：在进行AABB或球体与视锥体的相交检测时，计算relative_radius的公式`aabb.relative_radius(&p_normal, &world_from_local.matrix3)`会返回0，因为p_normal是零向量。同样，`half_space.normal_d().dot(aabb_center_world)`也返回0。最终条件`0 + 0 <= 0.0`为真，导致函数错误地返回false，即认为物体不在视锥体内。

**解决方案**

修复方法很简单但很关键：将第六个半空间初始化为一个有效的默认值。具体来说，将half_spaces[5]设置为`HalfSpace::new(Vec4::new(0.0, 0.0, 0.0, f32::MAX))`。

这个修改的意义在于：
1. 法向量部分保持为(0.0, 0.0, 0.0)，因为远平面实际上不存在
2. 距离部分设置为f32::MAX，确保在相交检测计算中不会错误地排除物体

**技术细节**

在计算机图形学中，视锥体通常由六个平面定义（近、远、左、右、上、下）。每个平面用一个半空间表示，包含一个法向量和一个距离值。相交检测算法通过计算物体与这些半空间的关系来确定物体是否在视锥体内。

当没有远平面时，我们需要确保第六个半空间不会错误地排除任何物体。通过将距离设置为f32::MAX，我们实际上创建了一个"无限远"的平面，不会对相交检测产生负面影响。

**影响评估**

这个修复确保了：
1. 使用`from_clip_from_world_no_far`构造的视锥体能够正确进行相交检测
2. AABB和零半径球体不会被错误地排除在视锥体外
3. 远平面裁剪功能正常工作

虽然这个bug在实际使用中尚未被发现（说明它可能影响的是边缘情况），但修复它对于确保渲染系统的正确性至关重要。

## Visual Representation

```mermaid
graph TD
    A[Frustum::from_clip_from_world_no_far] --> B[初始化6个半空间]
    B --> C[前5个半空间正确初始化]
    B --> D[第6个半空间错误初始化为零]
    D --> E[相交检测计算错误]
    E --> F[AABB/球体被错误排除]
    
    G[修复: 设置half_spaces[5]为有效值] --> H[相交检测计算正确]
    H --> I[AABB/球体正确包含]
```

## Key Files Changed

**crates/bevy_camera/src/primitives.rs** (+1/-0)

这个文件包含了视锥体相关的数据结构和方法的定义。修改发生在`Frustum::from_clip_from_world_no_far`方法中，添加了一行代码来正确初始化第六个半空间。

修改前的代码（隐含问题）：
```rust
impl Frustum {
    pub fn from_clip_from_world_no_far(clip_from_world: &Mat4) -> Self {
        // ... 其他初始化代码 ...
        // 第六个半空间没有被显式初始化，可能包含无效值
        Self { half_spaces }
    }
}
```

修改后的代码：
```rust
impl Frustum {
    pub fn from_clip_from_world_no_far(clip_from_world: &Mat4) -> Self {
        // ... 其他初始化代码 ...
        half_spaces[5] = HalfSpace::new(Vec4::new(0.0, 0.0, 0.0, f32::MAX));
        Self { half_spaces }
    }
}
```

这行添加的代码确保了第六个半空间被正确初始化为一个不会错误排除任何物体的值。

## Further Reading

1. **视锥体裁剪原理**: [LearnOpenGL - Frustum Culling](https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling)
2. **半空间表示法**: [Wikipedia - Half-space](https://en.wikipedia.org/wiki/Half-space_(geometry))
3. **Bevy相机系统**: [Bevy Camera Documentation](https://docs.rs/bevy_camera/latest/bevy_camera/)
4. **平面方程与相交检测**: [Real-Time Rendering, 4th Edition](https://www.realtimerendering.com/) 中的视锥体相关章节