+++
title = "#19158 bevy_reflect: Fix `FromReflect` derive for opaque remote wrappers"
date = "2025-08-28T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-19158-en-20250828" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-19158-zh-cn-20250828" }}
labels = ["C-Bug", "A-Reflection", "D-Straightforward", "D-Macros"]
+++

# Title
bevy_reflect: Fix `FromReflect` derive for opaque remote wrappers

## Basic Information
- **Title**: bevy_reflect: Fix `FromReflect` derive for opaque remote wrappers
- **PR Link**: https://github.com/bevyengine/bevy/pull/19158
- **Author**: MrGVSV
- **Status**: MERGED
- **Labels**: C-Bug, S-Ready-For-Final-Review, A-Reflection, D-Straightforward, D-Macros
- **Created**: 2025-05-10T06:41:25Z
- **Merged**: 2025-08-28T23:05:06Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

Fixes #19017

## Solution

The `FromReflect` derive logic for opaque types was not properly accounting for remote reflection. This PR fixes that by making it downcast to the remote type and then converting it back to the wrapper.

## Testing

You can test locally by running:

```
cargo test -p bevy_reflect
```

## The Story of This Pull Request

This PR addresses a specific issue in Bevy's reflection system where opaque remote wrapper types couldn't be properly deserialized using the `FromReflect` trait. The problem occurred when using `#[reflect_remote]` on types from external crates that were wrapped in opaque local types.

The core issue was in the derive macro for `FromReflect` on opaque types. When dealing with remote types (types from external crates wrapped with local opaque types), the macro was attempting to downcast directly to the wrapper type instead of first downcasting to the remote type and then converting it to the wrapper.

The solution modifies the `impl_opaque` function in the derive macro to check if the type has a remote type association. If it does, the generated code now:
1. Downcasts to the remote type instead of the wrapper type
2. Uses the `ReflectRemote::into_wrapper` method to convert the remote type to the wrapper type
3. Falls back to the original behavior for non-remote opaque types

This approach maintains backward compatibility while fixing the remote type handling. The implementation correctly leverages the existing `ReflectRemote` trait that was already designed for this conversion purpose.

To ensure the fix works correctly, a comprehensive test was added that covers:
- Defining an external type simulation
- Creating an opaque wrapper with remote reflection
- Serialization and deserialization through the reflection system
- Verification that the deserialized data matches the original

The test uses RON serialization format and verifies that the entire reflection pipeline works correctly for remote opaque types, preventing future regressions in this functionality.

## Visual Representation

```mermaid
graph TD
    A[PartialReflect input] --> B{Is opaque type?}
    B -->|No| C[Standard FromReflect logic]
    B -->|Yes| D{Has remote type?}
    D -->|No| E[Downcast to local type]
    D -->|Yes| F[Downcast to remote type]
    F --> G[Convert to wrapper via ReflectRemote]
    E --> H[Return cloned value]
    G --> H
    H --> I[Return Some(Self)]
```

## Key Files Changed

### `crates/bevy_reflect/derive/src/from_reflect.rs`
This file contains the derive macro implementation for `FromReflect`. The key change was in the `impl_opaque` function to handle remote types correctly.

**Before:**
```rust
quote! {
    impl #impl_generics #bevy_reflect_path::FromReflect for #type_path #ty_generics #where_from_reflect_clause  {
        fn from_reflect(reflect: &dyn #bevy_reflect_path::PartialReflect) -> #FQOption<Self> {
            #FQOption::Some(
                #FQClone::clone(
                    <dyn #bevy_reflect_path::PartialReflect>::try_downcast_ref::<#type_path #ty_generics>(reflect)?
                )
            )
        }
    }
}
```

**After:**
```rust
let downcast = match meta.remote_ty() {
    Some(remote) => {
        let remote_ty = remote.type_path();
        quote! {
            <Self as #bevy_reflect_path::ReflectRemote>::into_wrapper(
                #FQClone::clone(
                    <dyn #bevy_reflect_path::PartialReflect>::try_downcast_ref::<#remote_ty>(reflect)?
                )
            )
        }
    }
    None => quote! {
        #FQClone::clone(
            <dyn #bevy_reflect_path::PartialReflect>::try_downcast_ref::<#type_path #ty_generics>(reflect)?
        )
    },
};

quote! {
    impl #impl_generics #bevy_reflect_path::FromReflect for #type_path #ty_generics #where_from_reflect_clause  {
        fn from_reflect(reflect: &dyn #bevy_reflect_path::PartialReflect) -> #FQOption<Self> {
            #FQOption::Some(#downcast)
        }
    }
}
```

### `crates/bevy_reflect/src/lib.rs`
Added a comprehensive test case to verify the fix works correctly and prevent regressions.

**Added test:**
```rust
// https://github.com/bevyengine/bevy/issues/19017
#[test]
fn should_serialize_opaque_remote_type() {
    mod external_crate {
        use serde::{Deserialize, Serialize};
        #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
        pub struct Vector2<T>(pub [T; 2]);
    }

    #[reflect_remote(external_crate::Vector2<i32>)]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[reflect(Serialize, Deserialize)]
    #[reflect(opaque)]
    struct Vector2Wrapper([i32; 2]);

    #[derive(Reflect, Debug, PartialEq)]
    struct Point(#[reflect(remote = Vector2Wrapper)] external_crate::Vector2<i32>);

    let point = Point(external_crate::Vector2([1, 2]));

    let mut registry = TypeRegistry::new();
    registry.register::<Point>();
    registry.register::<Vector2Wrapper>();

    let serializer = ReflectSerializer::new(&point, &registry);
    let serialized = ron::to_string(&serializer).unwrap();
    assert_eq!(serialized, r#"{"bevy_reflect::tests::Point":((((1,2))))}"#);

    let mut deserializer = Deserializer::from_str(&serialized).unwrap();
    let reflect_deserializer = ReflectDeserializer::new(&registry);
    let deserialized = reflect_deserializer.deserialize(&mut deserializer).unwrap();
    let point = <Point as FromReflect>::from_reflect(&*deserialized).unwrap();
    assert_eq!(point, Point(external_crate::Vector2([1, 2])));
}
```

## Further Reading

- [Bevy Reflection Documentation](https://docs.rs/bevy_reflect/latest/bevy_reflect/)
- [FromReflect Trait](https://docs.rs/bevy_reflect/latest/bevy_reflect/trait.FromReflect.html)
- [Remote Reflection Pattern](https://github.com/bevyengine/bevy/blob/main/docs/patterns/reflection.md#remote-types)
- [Macro-based Reflection in Rust](https://doc.rust-lang.org/book/ch19-06-macros.html)