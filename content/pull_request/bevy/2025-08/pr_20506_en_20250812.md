+++
title = "#20506 Fix App::get_added_plugins not working inside finish and cleanup"
date = "2025-08-12T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20506-en-20250812" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20506-zh-cn-20250812" }}
labels = ["C-Bug", "A-App"]
+++

## Fix App::get_added_plugins not working inside finish and cleanup

### Basic Information
- **Title**: Fix App::get_added_plugins not working inside finish and cleanup
- **PR Link**: https://github.com/bevyengine/bevy/pull/20506
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: C-Bug, S-Ready-For-Final-Review, A-App
- **Created**: 2025-08-11T05:00:35Z
- **Merged**: 2025-08-12T02:11:14Z
- **Merged By**: alice-i-cecile

### Description Translation
# Objective

This assertion fails when called inside finish or cleanup:
```rs
assert_eq!(
    app.is_plugin_added::<ImagePlugin>(),
    app.get_added_plugins::<ImagePlugin>().len() > 0
);
```

## Solution

- Do the hokey pokey one plugin at a time
- swap_remove to stay O(1), then push and swap back to preserve plugin order

## Testing

- Someone should write unit tests for this and probably document that it hokey pokeys, although i dont think anyone will `get_added_plugins<Self>` because you have a `self` param in finish and cleanup anyways.

### The Story of This Pull Request

**The Problem and Context**  
In Bevy's plugin system, `App::get_added_plugins` unexpectedly returned empty results when called during `finish()` or `cleanup()` lifecycle methods. This occurred because the original implementation used `core::mem::take()` to remove all plugins from the registry before iterating through them:

```rust
// Before implementation
let plugins = core::mem::take(&mut self.main_mut().plugin_registry);
for plugin in &plugins {
    plugin.finish(self);
}
```

This approach temporarily emptied the plugin registry during iteration, causing `get_added_plugins` to return incorrect results when called from within a plugin's `finish()` or `cleanup()` method. This violated the expectation that plugins could query information about other plugins during these lifecycle stages.

**The Solution Approach**  
The fix replaces the bulk removal approach with a temporary per-plugin swapping technique using a zero-sized type (ZST) placeholder plugin called `HokeyPokey`. The solution maintains O(1) complexity per operation while preserving plugin order:

1. Create a dummy `HokeyPokey` plugin (ZST, no allocation)
2. Iterate through plugin indices
3. Swap current plugin with dummy
4. Process plugin method (`finish`/`cleanup`)
5. Swap plugin back into registry

This ensures the plugin registry always contains all plugins except the one currently being processed, maintaining valid state for API queries.

**The Implementation**  
The core change modifies both `finish()` and `cleanup()` methods in `App` and `SubApp`:

```rust
// New implementation in App
let mut hokeypokey: Box<dyn Plugin> = Box::new(HokeyPokey);
for i in 0..self.main().plugin_registry.len() {
    core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);
    hokeypokey.finish(self);
    core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);
}
```

A dummy plugin is implemented to enable the swapping:
```rust
pub(crate) struct HokeyPokey;
impl Plugin for HokeyPokey {
    fn build(&self, _: &mut App) {}
}
```

**Testing and Verification**  
New unit tests validate the fix by:
1. Verifying plugin detection during lifecycle methods
2. Testing plugin addition during `finish()`

```rust
// Tests plugin availability during finish()
fn finish(&self, app: &mut App) {
    assert_eq!(
        app.is_plugin_added::<PluginA>(),
        !app.get_added_plugins::<PluginA>().is_empty(),
    );
}

// Tests adding plugins during finish()
fn finish(&self, app: &mut App) {
    app.add_plugins(PluginB);
}
```

**Technical Insights**  
Key technical aspects:
- **ZST Advantage**: `HokeyPokey` uses zero bytes at runtime (no allocation overhead)
- **Order Preservation**: Swapping maintains original plugin order
- **Complexity**: O(n) time complexity same as original, with O(1) space
- **Safety**: Avoids potential double-borrow issues from simultaneous access

**The Impact**  
This fix:
1. Corrects inconsistent plugin registry state during lifecycle methods
2. Enables plugins to safely query other plugins during `finish()`/`cleanup()`
3. Maintains existing performance characteristics
4. Adds test coverage for edge case behavior

### Visual Representation

```mermaid
graph LR
    A[App.finish/cleanup] --> B[Plugin Registry]
    B --> C[Swap Plugin with HokeyPokey]
    C --> D[Call Plugin Method]
    D --> E[Swap Back]
    E --> F[Next Plugin]
```

### Key Files Changed

1. **crates/bevy_app/src/app.rs**  
   Rewrote finish/cleanup methods and added tests

```rust
// Before
let plugins = core::mem::take(&mut self.main_mut().plugin_registry);
for plugin in &plugins {
    plugin.finish(self);
}
let main = self.main_mut();
main.plugin_registry = plugins;

// After
let mut hokeypokey: Box<dyn Plugin> = Box::new(HokeyPokey);
for i in 0..self.main().plugin_registry.len() {
    core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);
    hokeypokey.finish(self);
    core::mem::swap(&mut self.main_mut().plugin_registry[i], &mut hokeypokey);
}
```

2. **crates/bevy_app/src/sub_app.rs**  
   Mirror changes for SubApp

```rust
// Before
let plugins = core::mem::take(&mut self.plugin_registry);
self.run_as_app(|app| {
    for plugin in &plugins {
        plugin.finish(app);
    }
});

// After
let mut hokeypokey: Box<dyn Plugin> = Box::new(crate::HokeyPokey);
for i in 0..self.plugin_registry.len() {
    core::mem::swap(&mut self.plugin_registry[i], &mut hokeypokey);
    self.run_as_app(|app| {
        hokeypokey.finish(app);
    });
    core::mem::swap(&mut self.plugin_registry[i], &mut hokeypokey);
}
```

### Further Reading
1. [Bevy Plugin System Documentation](https://bevyengine.org/learn/book/getting-started/plugins/)
2. [Rust Memory Management](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
3. [Zero-Sized Types in Rust](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts)