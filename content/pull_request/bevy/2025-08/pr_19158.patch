diff --git a/crates/bevy_reflect/derive/src/from_reflect.rs b/crates/bevy_reflect/derive/src/from_reflect.rs
index a0e6e444d32a9..bf7867903e84c 100644
--- a/crates/bevy_reflect/derive/src/from_reflect.rs
+++ b/crates/bevy_reflect/derive/src/from_reflect.rs
@@ -27,16 +27,31 @@ pub(crate) fn impl_opaque(meta: &ReflectMeta) -> proc_macro2::TokenStream {
     let bevy_reflect_path = meta.bevy_reflect_path();
     let (impl_generics, ty_generics, where_clause) = type_path.generics().split_for_impl();
     let where_from_reflect_clause = WhereClauseOptions::new(meta).extend_where_clause(where_clause);
-    quote! {
-        impl #impl_generics #bevy_reflect_path::FromReflect for #type_path #ty_generics #where_from_reflect_clause  {
-            fn from_reflect(reflect: &dyn #bevy_reflect_path::PartialReflect) -> #FQOption<Self> {
-                #FQOption::Some(
+
+    let downcast = match meta.remote_ty() {
+        Some(remote) => {
+            let remote_ty = remote.type_path();
+            quote! {
+                <Self as #bevy_reflect_path::ReflectRemote>::into_wrapper(
                     #FQClone::clone(
-                        <dyn #bevy_reflect_path::PartialReflect>::try_downcast_ref::<#type_path #ty_generics>(reflect)?
+                        <dyn #bevy_reflect_path::PartialReflect>::try_downcast_ref::<#remote_ty>(reflect)?
                     )
                 )
             }
         }
+        None => quote! {
+            #FQClone::clone(
+                <dyn #bevy_reflect_path::PartialReflect>::try_downcast_ref::<#type_path #ty_generics>(reflect)?
+            )
+        },
+    };
+
+    quote! {
+        impl #impl_generics #bevy_reflect_path::FromReflect for #type_path #ty_generics #where_from_reflect_clause  {
+            fn from_reflect(reflect: &dyn #bevy_reflect_path::PartialReflect) -> #FQOption<Self> {
+                #FQOption::Some(#downcast)
+            }
+        }
     }
 }
 
diff --git a/crates/bevy_reflect/src/lib.rs b/crates/bevy_reflect/src/lib.rs
index a719732c45d2d..477c222a345ce 100644
--- a/crates/bevy_reflect/src/lib.rs
+++ b/crates/bevy_reflect/src/lib.rs
@@ -3469,6 +3469,41 @@ bevy_reflect::tests::Test {
         );
     }
 
+    // https://github.com/bevyengine/bevy/issues/19017
+    #[test]
+    fn should_serialize_opaque_remote_type() {
+        mod external_crate {
+            use serde::{Deserialize, Serialize};
+            #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
+            pub struct Vector2<T>(pub [T; 2]);
+        }
+
+        #[reflect_remote(external_crate::Vector2<i32>)]
+        #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
+        #[reflect(Serialize, Deserialize)]
+        #[reflect(opaque)]
+        struct Vector2Wrapper([i32; 2]);
+
+        #[derive(Reflect, Debug, PartialEq)]
+        struct Point(#[reflect(remote = Vector2Wrapper)] external_crate::Vector2<i32>);
+
+        let point = Point(external_crate::Vector2([1, 2]));
+
+        let mut registry = TypeRegistry::new();
+        registry.register::<Point>();
+        registry.register::<Vector2Wrapper>();
+
+        let serializer = ReflectSerializer::new(&point, &registry);
+        let serialized = ron::to_string(&serializer).unwrap();
+        assert_eq!(serialized, r#"{"bevy_reflect::tests::Point":((((1,2))))}"#);
+
+        let mut deserializer = Deserializer::from_str(&serialized).unwrap();
+        let reflect_deserializer = ReflectDeserializer::new(&registry);
+        let deserialized = reflect_deserializer.deserialize(&mut deserializer).unwrap();
+        let point = <Point as FromReflect>::from_reflect(&*deserialized).unwrap();
+        assert_eq!(point, Point(external_crate::Vector2([1, 2])));
+    }
+
     #[cfg(feature = "auto_register")]
     mod auto_register_reflect {
         use super::*;
