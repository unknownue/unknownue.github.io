diff --git a/crates/bevy_asset/src/asset_changed.rs b/crates/bevy_asset/src/asset_changed.rs
index b43a8625e783d..1e338ca11caf9 100644
--- a/crates/bevy_asset/src/asset_changed.rs
+++ b/crates/bevy_asset/src/asset_changed.rs
@@ -229,7 +229,7 @@ unsafe impl<A: AsAssetId> WorldQuery for AssetChanged<A> {
     }
 
     #[inline]
-    fn update_component_access(state: &Self::State, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(state: &Self::State, access: &mut FilteredAccess) {
         <&A>::update_component_access(&state.asset_id, access);
         access.add_resource_read(state.resource_id);
     }
diff --git a/crates/bevy_ecs/macros/src/lib.rs b/crates/bevy_ecs/macros/src/lib.rs
index 234a8cf8595dd..964bc56adbbb2 100644
--- a/crates/bevy_ecs/macros/src/lib.rs
+++ b/crates/bevy_ecs/macros/src/lib.rs
@@ -453,7 +453,7 @@ pub fn derive_system_param(input: TokenStream) -> TokenStream {
                     }
                 }
 
-                fn init_access(state: &Self::State, system_meta: &mut #path::system::SystemMeta, component_access_set: &mut #path::query::FilteredAccessSet<#path::component::ComponentId>, world: &mut #path::world::World) {
+                fn init_access(state: &Self::State, system_meta: &mut #path::system::SystemMeta, component_access_set: &mut #path::query::FilteredAccessSet, world: &mut #path::world::World) {
                     <#fields_alias::<'_, '_, #punctuated_generic_idents> as #path::system::SystemParam>::init_access(&state.state, system_meta, component_access_set, world);
                 }
 
diff --git a/crates/bevy_ecs/macros/src/query_data.rs b/crates/bevy_ecs/macros/src/query_data.rs
index 12d9c2bf1c1fa..e558e2e634985 100644
--- a/crates/bevy_ecs/macros/src/query_data.rs
+++ b/crates/bevy_ecs/macros/src/query_data.rs
@@ -281,8 +281,8 @@ pub fn derive_query_data_impl(input: TokenStream) -> TokenStream {
 
                     fn provide_extra_access(
                         state: &mut Self::State,
-                        access: &mut #path::query::Access<#path::component::ComponentId>,
-                        available_access: &#path::query::Access<#path::component::ComponentId>,
+                        access: &mut #path::query::Access,
+                        available_access: &#path::query::Access,
                     ) {
                         #(<#field_types>::provide_extra_access(&mut state.#named_field_idents, access, available_access);)*
                     }
@@ -339,8 +339,8 @@ pub fn derive_query_data_impl(input: TokenStream) -> TokenStream {
 
                 fn provide_extra_access(
                     state: &mut Self::State,
-                    access: &mut #path::query::Access<#path::component::ComponentId>,
-                    available_access: &#path::query::Access<#path::component::ComponentId>,
+                    access: &mut #path::query::Access,
+                    available_access: &#path::query::Access,
                 ) {
                     #(<#field_types>::provide_extra_access(&mut state.#named_field_idents, access, available_access);)*
                 }
diff --git a/crates/bevy_ecs/macros/src/world_query.rs b/crates/bevy_ecs/macros/src/world_query.rs
index 5a7d164b8021d..ccd01c425ecab 100644
--- a/crates/bevy_ecs/macros/src/world_query.rs
+++ b/crates/bevy_ecs/macros/src/world_query.rs
@@ -152,7 +152,7 @@ pub(crate) fn world_query_impl(
                 #(<#field_types>::set_table(&mut _fetch.#named_field_idents, &_state.#named_field_idents, _table);)*
             }
 
-            fn update_component_access(state: &Self::State, _access: &mut #path::query::FilteredAccess<#path::component::ComponentId>) {
+            fn update_component_access(state: &Self::State, _access: &mut #path::query::FilteredAccess) {
                 #( <#field_types>::update_component_access(&state.#named_field_idents, _access); )*
             }
 
diff --git a/crates/bevy_ecs/src/entity_disabling.rs b/crates/bevy_ecs/src/entity_disabling.rs
index 652cd1fdb28a3..d60f3ab08bdf6 100644
--- a/crates/bevy_ecs/src/entity_disabling.rs
+++ b/crates/bevy_ecs/src/entity_disabling.rs
@@ -241,7 +241,7 @@ impl DefaultQueryFilters {
     }
 
     /// Modifies the provided [`FilteredAccess`] to include the filters from this [`DefaultQueryFilters`].
-    pub(super) fn modify_access(&self, component_access: &mut FilteredAccess<ComponentId>) {
+    pub(super) fn modify_access(&self, component_access: &mut FilteredAccess) {
         for component_id in self.disabling_ids() {
             if !component_access.contains(component_id) {
                 component_access.and_without(component_id);
@@ -276,7 +276,7 @@ mod tests {
         filters.register_disabling_component(ComponentId::new(1));
 
         // A component access with an unrelated component
-        let mut component_access = FilteredAccess::<ComponentId>::default();
+        let mut component_access = FilteredAccess::default();
         component_access
             .access_mut()
             .add_component_read(ComponentId::new(2));
diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index 4d7c330f6b405..5307b3785e7cc 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -160,7 +160,7 @@ mod tests {
     use crate::{
         bundle::Bundle,
         change_detection::Ref,
-        component::{Component, ComponentId},
+        component::Component,
         entity::{Entity, EntityMapper},
         entity_disabling::DefaultQueryFilters,
         prelude::Or,
@@ -1536,7 +1536,7 @@ mod tests {
         world.remove_resource::<DefaultQueryFilters>();
         let query = world.query_filtered::<&mut A, Changed<B>>();
 
-        let mut expected = FilteredAccess::<ComponentId>::default();
+        let mut expected = FilteredAccess::default();
         let a_id = world.components.get_id(TypeId::of::<A>()).unwrap();
         let b_id = world.components.get_id(TypeId::of::<B>()).unwrap();
         expected.add_component_write(a_id);
diff --git a/crates/bevy_ecs/src/lifecycle.rs b/crates/bevy_ecs/src/lifecycle.rs
index 62a731499a13f..e45f9eefa0113 100644
--- a/crates/bevy_ecs/src/lifecycle.rs
+++ b/crates/bevy_ecs/src/lifecycle.rs
@@ -632,7 +632,7 @@ unsafe impl<'a> SystemParam for &'a RemovedComponentEvents {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
diff --git a/crates/bevy_ecs/src/query/access.rs b/crates/bevy_ecs/src/query/access.rs
index 51ef320f38f7e..346c131457bb7 100644
--- a/crates/bevy_ecs/src/query/access.rs
+++ b/crates/bevy_ecs/src/query/access.rs
@@ -1,17 +1,16 @@
 use crate::component::ComponentId;
-use crate::storage::SparseSetIndex;
 use crate::world::World;
 use alloc::{format, string::String, vec, vec::Vec};
-use core::{fmt, fmt::Debug, marker::PhantomData};
+use core::{fmt, fmt::Debug};
 use derive_more::From;
 use fixedbitset::FixedBitSet;
 use thiserror::Error;
 
 /// A wrapper struct to make Debug representations of [`FixedBitSet`] easier
-/// to read, when used to store [`SparseSetIndex`].
+/// to read.
 ///
 /// Instead of the raw integer representation of the `FixedBitSet`, the list of
-/// `T` valid for [`SparseSetIndex`] is shown.
+/// indexes are shown.
 ///
 /// Normal `FixedBitSet` `Debug` output:
 /// ```text
@@ -22,27 +21,21 @@ use thiserror::Error;
 /// the set. With `FormattedBitSet`, we convert the present set entries into
 /// what they stand for, it is much clearer what is going on:
 /// ```text
-/// read_and_writes: [ ComponentId(5), ComponentId(7) ]
+/// read_and_writes: [ 5, 7 ]
 /// ```
-struct FormattedBitSet<'a, T: SparseSetIndex> {
+struct FormattedBitSet<'a> {
     bit_set: &'a FixedBitSet,
-    _marker: PhantomData<T>,
 }
 
-impl<'a, T: SparseSetIndex> FormattedBitSet<'a, T> {
+impl<'a> FormattedBitSet<'a> {
     fn new(bit_set: &'a FixedBitSet) -> Self {
-        Self {
-            bit_set,
-            _marker: PhantomData,
-        }
+        Self { bit_set }
     }
 }
 
-impl<'a, T: SparseSetIndex + Debug> Debug for FormattedBitSet<'a, T> {
+impl<'a> Debug for FormattedBitSet<'a> {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        f.debug_list()
-            .entries(self.bit_set.ones().map(T::get_sparse_set_index))
-            .finish()
+        f.debug_list().entries(self.bit_set.ones()).finish()
     }
 }
 
@@ -50,8 +43,8 @@ impl<'a, T: SparseSetIndex + Debug> Debug for FormattedBitSet<'a, T> {
 ///
 /// Used internally to ensure soundness during system initialization and execution.
 /// See the [`is_compatible`](Access::is_compatible) and [`get_conflicts`](Access::get_conflicts) functions.
-#[derive(Eq, PartialEq)]
-pub struct Access<T: SparseSetIndex> {
+#[derive(Eq, PartialEq, Default)]
+pub struct Access {
     /// All accessed components, or forbidden components if
     /// `Self::component_read_and_writes_inverted` is set.
     component_read_and_writes: FixedBitSet,
@@ -76,11 +69,10 @@ pub struct Access<T: SparseSetIndex> {
     writes_all_resources: bool,
     // Components that are not accessed, but whose presence in an archetype affect query results.
     archetypal: FixedBitSet,
-    marker: PhantomData<T>,
 }
 
 // This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.
-impl<T: SparseSetIndex> Clone for Access<T> {
+impl Clone for Access {
     fn clone(&self) -> Self {
         Self {
             component_read_and_writes: self.component_read_and_writes.clone(),
@@ -92,7 +84,6 @@ impl<T: SparseSetIndex> Clone for Access<T> {
             reads_all_resources: self.reads_all_resources,
             writes_all_resources: self.writes_all_resources,
             archetypal: self.archetypal.clone(),
-            marker: PhantomData,
         }
     }
 
@@ -111,24 +102,24 @@ impl<T: SparseSetIndex> Clone for Access<T> {
     }
 }
 
-impl<T: SparseSetIndex + Debug> Debug for Access<T> {
+impl Debug for Access {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         f.debug_struct("Access")
             .field(
                 "component_read_and_writes",
-                &FormattedBitSet::<T>::new(&self.component_read_and_writes),
+                &FormattedBitSet::new(&self.component_read_and_writes),
             )
             .field(
                 "component_writes",
-                &FormattedBitSet::<T>::new(&self.component_writes),
+                &FormattedBitSet::new(&self.component_writes),
             )
             .field(
                 "resource_read_and_writes",
-                &FormattedBitSet::<T>::new(&self.resource_read_and_writes),
+                &FormattedBitSet::new(&self.resource_read_and_writes),
             )
             .field(
                 "resource_writes",
-                &FormattedBitSet::<T>::new(&self.resource_writes),
+                &FormattedBitSet::new(&self.resource_writes),
             )
             .field(
                 "component_read_and_writes_inverted",
@@ -137,18 +128,12 @@ impl<T: SparseSetIndex + Debug> Debug for Access<T> {
             .field("component_writes_inverted", &self.component_writes_inverted)
             .field("reads_all_resources", &self.reads_all_resources)
             .field("writes_all_resources", &self.writes_all_resources)
-            .field("archetypal", &FormattedBitSet::<T>::new(&self.archetypal))
+            .field("archetypal", &FormattedBitSet::new(&self.archetypal))
             .finish()
     }
 }
 
-impl<T: SparseSetIndex> Default for Access<T> {
-    fn default() -> Self {
-        Self::new()
-    }
-}
-
-impl<T: SparseSetIndex> Access<T> {
+impl Access {
     /// Creates an empty [`Access`] collection.
     pub const fn new() -> Self {
         Self {
@@ -161,7 +146,6 @@ impl<T: SparseSetIndex> Access<T> {
             resource_read_and_writes: FixedBitSet::new(),
             resource_writes: FixedBitSet::new(),
             archetypal: FixedBitSet::new(),
-            marker: PhantomData,
         }
     }
 
@@ -208,30 +192,27 @@ impl<T: SparseSetIndex> Access<T> {
     }
 
     /// Adds access to the component given by `index`.
-    pub fn add_component_read(&mut self, index: T) {
-        let sparse_set_index = index.sparse_set_index();
+    pub fn add_component_read(&mut self, index: ComponentId) {
+        let sparse_set_index = index.index();
         self.add_component_sparse_set_index_read(sparse_set_index);
     }
 
     /// Adds exclusive access to the component given by `index`.
-    pub fn add_component_write(&mut self, index: T) {
-        let sparse_set_index = index.sparse_set_index();
+    pub fn add_component_write(&mut self, index: ComponentId) {
+        let sparse_set_index = index.index();
         self.add_component_sparse_set_index_read(sparse_set_index);
         self.add_component_sparse_set_index_write(sparse_set_index);
     }
 
     /// Adds access to the resource given by `index`.
-    pub fn add_resource_read(&mut self, index: T) {
-        self.resource_read_and_writes
-            .grow_and_insert(index.sparse_set_index());
+    pub fn add_resource_read(&mut self, index: ComponentId) {
+        self.resource_read_and_writes.grow_and_insert(index.index());
     }
 
     /// Adds exclusive access to the resource given by `index`.
-    pub fn add_resource_write(&mut self, index: T) {
-        self.resource_read_and_writes
-            .grow_and_insert(index.sparse_set_index());
-        self.resource_writes
-            .grow_and_insert(index.sparse_set_index());
+    pub fn add_resource_write(&mut self, index: ComponentId) {
+        self.resource_read_and_writes.grow_and_insert(index.index());
+        self.resource_writes.grow_and_insert(index.index());
     }
 
     fn remove_component_sparse_set_index_read(&mut self, index: usize) {
@@ -258,8 +239,8 @@ impl<T: SparseSetIndex> Access<T> {
     /// can't replace a call to `remove_component_read` followed by a call to
     /// `extend` with a call to `extend` followed by a call to
     /// `remove_component_read`.
-    pub fn remove_component_read(&mut self, index: T) {
-        let sparse_set_index = index.sparse_set_index();
+    pub fn remove_component_read(&mut self, index: ComponentId) {
+        let sparse_set_index = index.index();
         self.remove_component_sparse_set_index_write(sparse_set_index);
         self.remove_component_sparse_set_index_read(sparse_set_index);
     }
@@ -272,8 +253,8 @@ impl<T: SparseSetIndex> Access<T> {
     /// can't replace a call to `remove_component_write` followed by a call to
     /// `extend` with a call to `extend` followed by a call to
     /// `remove_component_write`.
-    pub fn remove_component_write(&mut self, index: T) {
-        let sparse_set_index = index.sparse_set_index();
+    pub fn remove_component_write(&mut self, index: ComponentId) {
+        let sparse_set_index = index.index();
         self.remove_component_sparse_set_index_write(sparse_set_index);
     }
 
@@ -286,16 +267,14 @@ impl<T: SparseSetIndex> Access<T> {
     ///
     /// [`Has<T>`]: crate::query::Has
     /// [`Allows<T>`]: crate::query::filter::Allows
-    pub fn add_archetypal(&mut self, index: T) {
-        self.archetypal.grow_and_insert(index.sparse_set_index());
+    pub fn add_archetypal(&mut self, index: ComponentId) {
+        self.archetypal.grow_and_insert(index.index());
     }
 
     /// Returns `true` if this can access the component given by `index`.
-    pub fn has_component_read(&self, index: T) -> bool {
+    pub fn has_component_read(&self, index: ComponentId) -> bool {
         self.component_read_and_writes_inverted
-            ^ self
-                .component_read_and_writes
-                .contains(index.sparse_set_index())
+            ^ self.component_read_and_writes.contains(index.index())
     }
 
     /// Returns `true` if this can access any component.
@@ -304,8 +283,8 @@ impl<T: SparseSetIndex> Access<T> {
     }
 
     /// Returns `true` if this can exclusively access the component given by `index`.
-    pub fn has_component_write(&self, index: T) -> bool {
-        self.component_writes_inverted ^ self.component_writes.contains(index.sparse_set_index())
+    pub fn has_component_write(&self, index: ComponentId) -> bool {
+        self.component_writes_inverted ^ self.component_writes.contains(index.index())
     }
 
     /// Returns `true` if this accesses any component mutably.
@@ -314,11 +293,8 @@ impl<T: SparseSetIndex> Access<T> {
     }
 
     /// Returns `true` if this can access the resource given by `index`.
-    pub fn has_resource_read(&self, index: T) -> bool {
-        self.reads_all_resources
-            || self
-                .resource_read_and_writes
-                .contains(index.sparse_set_index())
+    pub fn has_resource_read(&self, index: ComponentId) -> bool {
+        self.reads_all_resources || self.resource_read_and_writes.contains(index.index())
     }
 
     /// Returns `true` if this can access any resource.
@@ -327,8 +303,8 @@ impl<T: SparseSetIndex> Access<T> {
     }
 
     /// Returns `true` if this can exclusively access the resource given by `index`.
-    pub fn has_resource_write(&self, index: T) -> bool {
-        self.writes_all_resources || self.resource_writes.contains(index.sparse_set_index())
+    pub fn has_resource_write(&self, index: ComponentId) -> bool {
+        self.writes_all_resources || self.resource_writes.contains(index.index())
     }
 
     /// Returns `true` if this accesses any resource mutably.
@@ -354,8 +330,8 @@ impl<T: SparseSetIndex> Access<T> {
     /// Currently, this is only used for [`Has<T>`].
     ///
     /// [`Has<T>`]: crate::query::Has
-    pub fn has_archetypal(&self, index: T) -> bool {
-        self.archetypal.contains(index.sparse_set_index())
+    pub fn has_archetypal(&self, index: ComponentId) -> bool {
+        self.archetypal.contains(index.index())
     }
 
     /// Sets this as having access to all components (i.e. `EntityRef`).
@@ -455,7 +431,7 @@ impl<T: SparseSetIndex> Access<T> {
     }
 
     /// Adds all access from `other`.
-    pub fn extend(&mut self, other: &Access<T>) {
+    pub fn extend(&mut self, other: &Access) {
         invertible_union_with(
             &mut self.component_read_and_writes,
             &mut self.component_read_and_writes_inverted,
@@ -480,7 +456,7 @@ impl<T: SparseSetIndex> Access<T> {
     /// Removes any access from `self` that would conflict with `other`.
     /// This removes any reads and writes for any component written by `other`,
     /// and removes any writes for any component read by `other`.
-    pub fn remove_conflicting_access(&mut self, other: &Access<T>) {
+    pub fn remove_conflicting_access(&mut self, other: &Access) {
         invertible_difference_with(
             &mut self.component_read_and_writes,
             &mut self.component_read_and_writes_inverted,
@@ -513,7 +489,7 @@ impl<T: SparseSetIndex> Access<T> {
     ///
     /// [`Access`] instances are incompatible if one can write
     /// an element that the other can read or write.
-    pub fn is_components_compatible(&self, other: &Access<T>) -> bool {
+    pub fn is_components_compatible(&self, other: &Access) -> bool {
         // We have a conflict if we write and they read or write, or if they
         // write and we read or write.
         for (
@@ -563,7 +539,7 @@ impl<T: SparseSetIndex> Access<T> {
     ///
     /// [`Access`] instances are incompatible if one can write
     /// an element that the other can read or write.
-    pub fn is_resources_compatible(&self, other: &Access<T>) -> bool {
+    pub fn is_resources_compatible(&self, other: &Access) -> bool {
         if self.writes_all_resources {
             return !other.has_any_resource_read();
         }
@@ -591,13 +567,13 @@ impl<T: SparseSetIndex> Access<T> {
     ///
     /// [`Access`] instances are incompatible if one can write
     /// an element that the other can read or write.
-    pub fn is_compatible(&self, other: &Access<T>) -> bool {
+    pub fn is_compatible(&self, other: &Access) -> bool {
         self.is_components_compatible(other) && self.is_resources_compatible(other)
     }
 
     /// Returns `true` if the set's component access is a subset of another, i.e. `other`'s component access
     /// contains at least all the values in `self`.
-    pub fn is_subset_components(&self, other: &Access<T>) -> bool {
+    pub fn is_subset_components(&self, other: &Access) -> bool {
         for (
             our_components,
             their_components,
@@ -644,7 +620,7 @@ impl<T: SparseSetIndex> Access<T> {
 
     /// Returns `true` if the set's resource access is a subset of another, i.e. `other`'s resource access
     /// contains at least all the values in `self`.
-    pub fn is_subset_resources(&self, other: &Access<T>) -> bool {
+    pub fn is_subset_resources(&self, other: &Access) -> bool {
         if self.writes_all_resources {
             return other.writes_all_resources;
         }
@@ -668,11 +644,11 @@ impl<T: SparseSetIndex> Access<T> {
 
     /// Returns `true` if the set is a subset of another, i.e. `other` contains
     /// at least all the values in `self`.
-    pub fn is_subset(&self, other: &Access<T>) -> bool {
+    pub fn is_subset(&self, other: &Access) -> bool {
         self.is_subset_components(other) && self.is_subset_resources(other)
     }
 
-    fn get_component_conflicts(&self, other: &Access<T>) -> AccessConflicts {
+    fn get_component_conflicts(&self, other: &Access) -> AccessConflicts {
         let mut conflicts = FixedBitSet::new();
 
         // We have a conflict if we write and they read or write, or if they
@@ -712,7 +688,7 @@ impl<T: SparseSetIndex> Access<T> {
     }
 
     /// Returns a vector of elements that the access and `other` cannot access at the same time.
-    pub fn get_conflicts(&self, other: &Access<T>) -> AccessConflicts {
+    pub fn get_conflicts(&self, other: &Access) -> AccessConflicts {
         let mut conflicts = match self.get_component_conflicts(other) {
             AccessConflicts::All => return AccessConflicts::All,
             AccessConflicts::Individual(conflicts) => conflicts,
@@ -751,22 +727,20 @@ impl<T: SparseSetIndex> Access<T> {
     }
 
     /// Returns the indices of the resources this has access to.
-    pub fn resource_reads_and_writes(&self) -> impl Iterator<Item = T> + '_ {
-        self.resource_read_and_writes
-            .ones()
-            .map(T::get_sparse_set_index)
+    pub fn resource_reads_and_writes(&self) -> impl Iterator<Item = ComponentId> + '_ {
+        self.resource_read_and_writes.ones().map(ComponentId::new)
     }
 
     /// Returns the indices of the resources this has non-exclusive access to.
-    pub fn resource_reads(&self) -> impl Iterator<Item = T> + '_ {
+    pub fn resource_reads(&self) -> impl Iterator<Item = ComponentId> + '_ {
         self.resource_read_and_writes
             .difference(&self.resource_writes)
-            .map(T::get_sparse_set_index)
+            .map(ComponentId::new)
     }
 
     /// Returns the indices of the resources this has exclusive access to.
-    pub fn resource_writes(&self) -> impl Iterator<Item = T> + '_ {
-        self.resource_writes.ones().map(T::get_sparse_set_index)
+    pub fn resource_writes(&self) -> impl Iterator<Item = ComponentId> + '_ {
+        self.resource_writes.ones().map(ComponentId::new)
     }
 
     /// Returns the indices of the components that this has an archetypal access to.
@@ -777,8 +751,8 @@ impl<T: SparseSetIndex> Access<T> {
     /// Currently, this is only used for [`Has<T>`].
     ///
     /// [`Has<T>`]: crate::query::Has
-    pub fn archetypal(&self) -> impl Iterator<Item = T> + '_ {
-        self.archetypal.ones().map(T::get_sparse_set_index)
+    pub fn archetypal(&self) -> impl Iterator<Item = ComponentId> + '_ {
+        self.archetypal.ones().map(ComponentId::new)
     }
 
     /// Returns an iterator over the component IDs and their [`ComponentAccessKind`].
@@ -791,11 +765,12 @@ impl<T: SparseSetIndex> Access<T> {
     ///
     /// ```rust
     /// # use bevy_ecs::query::{Access, ComponentAccessKind};
-    /// let mut access = Access::<usize>::default();
+    /// # use bevy_ecs::component::ComponentId;
+    /// let mut access = Access::default();
     ///
-    /// access.add_component_read(1);
-    /// access.add_component_write(2);
-    /// access.add_archetypal(3);
+    /// access.add_component_read(ComponentId::new(1));
+    /// access.add_component_write(ComponentId::new(2));
+    /// access.add_archetypal(ComponentId::new(3));
     ///
     /// let result = access
     ///     .try_iter_component_access()
@@ -804,15 +779,15 @@ impl<T: SparseSetIndex> Access<T> {
     /// assert_eq!(
     ///     result,
     ///     Ok(vec![
-    ///         ComponentAccessKind::Shared(1),
-    ///         ComponentAccessKind::Exclusive(2),
-    ///         ComponentAccessKind::Archetypal(3),
+    ///         ComponentAccessKind::Shared(ComponentId::new(1)),
+    ///         ComponentAccessKind::Exclusive(ComponentId::new(2)),
+    ///         ComponentAccessKind::Archetypal(ComponentId::new(3)),
     ///     ]),
     /// );
     /// ```
     pub fn try_iter_component_access(
         &self,
-    ) -> Result<impl Iterator<Item = ComponentAccessKind<T>> + '_, UnboundedAccessError> {
+    ) -> Result<impl Iterator<Item = ComponentAccessKind> + '_, UnboundedAccessError> {
         // component_writes_inverted is only ever true when component_read_and_writes_inverted is
         // also true. Therefore it is sufficient to check just component_read_and_writes_inverted.
         if self.component_read_and_writes_inverted {
@@ -823,7 +798,7 @@ impl<T: SparseSetIndex> Access<T> {
         }
 
         let reads_and_writes = self.component_read_and_writes.ones().map(|index| {
-            let sparse_index = T::get_sparse_set_index(index);
+            let sparse_index = ComponentId::new(index);
 
             if self.component_writes.contains(index) {
                 ComponentAccessKind::Exclusive(sparse_index)
@@ -839,7 +814,7 @@ impl<T: SparseSetIndex> Access<T> {
                 !self.component_writes.contains(index)
                     && !self.component_read_and_writes.contains(index)
             })
-            .map(|index| ComponentAccessKind::Archetypal(T::get_sparse_set_index(index)));
+            .map(|index| ComponentAccessKind::Archetypal(ComponentId::new(index)));
 
         Ok(reads_and_writes.chain(archetypal))
     }
@@ -909,18 +884,18 @@ pub struct UnboundedAccessError {
 
 /// Describes the level of access for a particular component as defined in an [`Access`].
 #[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]
-pub enum ComponentAccessKind<T> {
+pub enum ComponentAccessKind {
     /// Archetypical access, such as `Has<Foo>`.
-    Archetypal(T),
+    Archetypal(ComponentId),
     /// Shared access, such as `&Foo`.
-    Shared(T),
+    Shared(ComponentId),
     /// Exclusive access, such as `&mut Foo`.
-    Exclusive(T),
+    Exclusive(ComponentId),
 }
 
-impl<T> ComponentAccessKind<T> {
+impl ComponentAccessKind {
     /// Gets the index of this `ComponentAccessKind`.
-    pub fn index(&self) -> &T {
+    pub fn index(&self) -> &ComponentId {
         let (Self::Archetypal(value) | Self::Shared(value) | Self::Exclusive(value)) = self;
         value
     }
@@ -947,16 +922,16 @@ impl<T> ComponentAccessKind<T> {
 ///
 /// See comments the [`WorldQuery`](super::WorldQuery) impls of [`AnyOf`](super::AnyOf)/`Option`/[`Or`](super::Or) for more information.
 #[derive(Debug, Eq, PartialEq)]
-pub struct FilteredAccess<T: SparseSetIndex> {
-    pub(crate) access: Access<T>,
+pub struct FilteredAccess {
+    pub(crate) access: Access,
     pub(crate) required: FixedBitSet,
     // An array of filter sets to express `With` or `Without` clauses in disjunctive normal form, for example: `Or<(With<A>, With<B>)>`.
     // Filters like `(With<A>, Or<(With<B>, Without<C>)>` are expanded into `Or<((With<A>, With<B>), (With<A>, Without<C>))>`.
-    pub(crate) filter_sets: Vec<AccessFilters<T>>,
+    pub(crate) filter_sets: Vec<AccessFilters>,
 }
 
 // This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.
-impl<T: SparseSetIndex> Clone for FilteredAccess<T> {
+impl Clone for FilteredAccess {
     fn clone(&self) -> Self {
         Self {
             access: self.access.clone(),
@@ -972,15 +947,15 @@ impl<T: SparseSetIndex> Clone for FilteredAccess<T> {
     }
 }
 
-impl<T: SparseSetIndex> Default for FilteredAccess<T> {
+impl Default for FilteredAccess {
     fn default() -> Self {
         Self::matches_everything()
     }
 }
 
-impl<T: SparseSetIndex> From<FilteredAccess<T>> for FilteredAccessSet<T> {
-    fn from(filtered_access: FilteredAccess<T>) -> Self {
-        let mut base = FilteredAccessSet::<T>::default();
+impl From<FilteredAccess> for FilteredAccessSet {
+    fn from(filtered_access: FilteredAccess) -> Self {
+        let mut base = FilteredAccessSet::default();
         base.add(filtered_access);
         base
     }
@@ -1026,7 +1001,7 @@ impl AccessConflicts {
                         "{}",
                         world
                             .components
-                            .get_name(ComponentId::get_sparse_set_index(index))
+                            .get_name(ComponentId::new(index))
                             .unwrap()
                             .shortname()
                     )
@@ -1042,13 +1017,13 @@ impl AccessConflicts {
     }
 }
 
-impl<T: SparseSetIndex> From<Vec<T>> for AccessConflicts {
-    fn from(value: Vec<T>) -> Self {
-        Self::Individual(value.iter().map(T::sparse_set_index).collect())
+impl From<Vec<ComponentId>> for AccessConflicts {
+    fn from(value: Vec<ComponentId>) -> Self {
+        Self::Individual(value.iter().map(|c| c.index()).collect())
     }
 }
 
-impl<T: SparseSetIndex> FilteredAccess<T> {
+impl FilteredAccess {
     /// Returns a `FilteredAccess` which has no access and matches everything.
     /// This is the equivalent of a `TRUE` logic atom.
     pub fn matches_everything() -> Self {
@@ -1071,51 +1046,51 @@ impl<T: SparseSetIndex> FilteredAccess<T> {
 
     /// Returns a reference to the underlying unfiltered access.
     #[inline]
-    pub fn access(&self) -> &Access<T> {
+    pub fn access(&self) -> &Access {
         &self.access
     }
 
     /// Returns a mutable reference to the underlying unfiltered access.
     #[inline]
-    pub fn access_mut(&mut self) -> &mut Access<T> {
+    pub fn access_mut(&mut self) -> &mut Access {
         &mut self.access
     }
 
     /// Adds access to the component given by `index`.
-    pub fn add_component_read(&mut self, index: T) {
-        self.access.add_component_read(index.clone());
-        self.add_required(index.clone());
+    pub fn add_component_read(&mut self, index: ComponentId) {
+        self.access.add_component_read(index);
+        self.add_required(index);
         self.and_with(index);
     }
 
     /// Adds exclusive access to the component given by `index`.
-    pub fn add_component_write(&mut self, index: T) {
-        self.access.add_component_write(index.clone());
-        self.add_required(index.clone());
+    pub fn add_component_write(&mut self, index: ComponentId) {
+        self.access.add_component_write(index);
+        self.add_required(index);
         self.and_with(index);
     }
 
     /// Adds access to the resource given by `index`.
-    pub fn add_resource_read(&mut self, index: T) {
-        self.access.add_resource_read(index.clone());
+    pub fn add_resource_read(&mut self, index: ComponentId) {
+        self.access.add_resource_read(index);
     }
 
     /// Adds exclusive access to the resource given by `index`.
-    pub fn add_resource_write(&mut self, index: T) {
-        self.access.add_resource_write(index.clone());
+    pub fn add_resource_write(&mut self, index: ComponentId) {
+        self.access.add_resource_write(index);
     }
 
-    fn add_required(&mut self, index: T) {
-        self.required.grow_and_insert(index.sparse_set_index());
+    fn add_required(&mut self, index: ComponentId) {
+        self.required.grow_and_insert(index.index());
     }
 
     /// Adds a `With` filter: corresponds to a conjunction (AND) operation.
     ///
     /// Suppose we begin with `Or<(With<A>, With<B>)>`, which is represented by an array of two `AccessFilter` instances.
     /// Adding `AND With<C>` via this method transforms it into the equivalent of  `Or<((With<A>, With<C>), (With<B>, With<C>))>`.
-    pub fn and_with(&mut self, index: T) {
+    pub fn and_with(&mut self, index: ComponentId) {
         for filter in &mut self.filter_sets {
-            filter.with.grow_and_insert(index.sparse_set_index());
+            filter.with.grow_and_insert(index.index());
         }
     }
 
@@ -1123,9 +1098,9 @@ impl<T: SparseSetIndex> FilteredAccess<T> {
     ///
     /// Suppose we begin with `Or<(With<A>, With<B>)>`, which is represented by an array of two `AccessFilter` instances.
     /// Adding `AND Without<C>` via this method transforms it into the equivalent of  `Or<((With<A>, Without<C>), (With<B>, Without<C>))>`.
-    pub fn and_without(&mut self, index: T) {
+    pub fn and_without(&mut self, index: ComponentId) {
         for filter in &mut self.filter_sets {
-            filter.without.grow_and_insert(index.sparse_set_index());
+            filter.without.grow_and_insert(index.index());
         }
     }
 
@@ -1134,17 +1109,17 @@ impl<T: SparseSetIndex> FilteredAccess<T> {
     /// As the underlying array of filters represents a disjunction,
     /// where each element (`AccessFilters`) represents a conjunction,
     /// we can simply append to the array.
-    pub fn append_or(&mut self, other: &FilteredAccess<T>) {
+    pub fn append_or(&mut self, other: &FilteredAccess) {
         self.filter_sets.append(&mut other.filter_sets.clone());
     }
 
     /// Adds all of the accesses from `other` to `self`.
-    pub fn extend_access(&mut self, other: &FilteredAccess<T>) {
+    pub fn extend_access(&mut self, other: &FilteredAccess) {
         self.access.extend(&other.access);
     }
 
     /// Returns `true` if this and `other` can be active at the same time.
-    pub fn is_compatible(&self, other: &FilteredAccess<T>) -> bool {
+    pub fn is_compatible(&self, other: &FilteredAccess) -> bool {
         // Resources are read from the world rather than the filtered archetypes,
         // so they must be compatible even if the filters are disjoint.
         if !self.access.is_resources_compatible(&other.access) {
@@ -1171,7 +1146,7 @@ impl<T: SparseSetIndex> FilteredAccess<T> {
     }
 
     /// Returns a vector of elements that this and `other` cannot access at the same time.
-    pub fn get_conflicts(&self, other: &FilteredAccess<T>) -> AccessConflicts {
+    pub fn get_conflicts(&self, other: &FilteredAccess) -> AccessConflicts {
         if !self.is_compatible(other) {
             // filters are disjoint, so we can just look at the unfiltered intersection
             return self.access.get_conflicts(&other.access);
@@ -1185,7 +1160,7 @@ impl<T: SparseSetIndex> FilteredAccess<T> {
     ///
     /// Extending `Or<(With<A>, Without<B>)>` with `Or<(With<C>, Without<D>)>` will result in
     /// `Or<((With<A>, With<C>), (With<A>, Without<D>), (Without<B>, With<C>), (Without<B>, Without<D>))>`.
-    pub fn extend(&mut self, other: &FilteredAccess<T>) {
+    pub fn extend(&mut self, other: &FilteredAccess) {
         self.access.extend(&other.access);
         self.required.union_with(&other.required);
 
@@ -1233,50 +1208,48 @@ impl<T: SparseSetIndex> FilteredAccess<T> {
 
     /// Returns `true` if the set is a subset of another, i.e. `other` contains
     /// at least all the values in `self`.
-    pub fn is_subset(&self, other: &FilteredAccess<T>) -> bool {
+    pub fn is_subset(&self, other: &FilteredAccess) -> bool {
         self.required.is_subset(&other.required) && self.access().is_subset(other.access())
     }
 
     /// Returns the indices of the elements that this access filters for.
-    pub fn with_filters(&self) -> impl Iterator<Item = T> + '_ {
+    pub fn with_filters(&self) -> impl Iterator<Item = ComponentId> + '_ {
         self.filter_sets
             .iter()
-            .flat_map(|f| f.with.ones().map(T::get_sparse_set_index))
+            .flat_map(|f| f.with.ones().map(ComponentId::new))
     }
 
     /// Returns the indices of the elements that this access filters out.
-    pub fn without_filters(&self) -> impl Iterator<Item = T> + '_ {
+    pub fn without_filters(&self) -> impl Iterator<Item = ComponentId> + '_ {
         self.filter_sets
             .iter()
-            .flat_map(|f| f.without.ones().map(T::get_sparse_set_index))
+            .flat_map(|f| f.without.ones().map(ComponentId::new))
     }
 
     /// Returns true if the index is used by this `FilteredAccess` in filters or archetypal access.
     /// This includes most ways to access a component, but notably excludes `EntityRef` and `EntityMut`
     /// along with anything inside `Option<T>`.
-    pub fn contains(&self, index: T) -> bool {
-        self.access().has_archetypal(index.clone())
-            || self.filter_sets.iter().any(|f| {
-                f.with.contains(index.sparse_set_index())
-                    || f.without.contains(index.sparse_set_index())
-            })
+    pub fn contains(&self, index: ComponentId) -> bool {
+        self.access().has_archetypal(index)
+            || self
+                .filter_sets
+                .iter()
+                .any(|f| f.with.contains(index.index()) || f.without.contains(index.index()))
     }
 }
 
-#[derive(Eq, PartialEq)]
-pub(crate) struct AccessFilters<T> {
+#[derive(Eq, PartialEq, Default)]
+pub(crate) struct AccessFilters {
     pub(crate) with: FixedBitSet,
     pub(crate) without: FixedBitSet,
-    _index_type: PhantomData<T>,
 }
 
 // This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.
-impl<T: SparseSetIndex> Clone for AccessFilters<T> {
+impl Clone for AccessFilters {
     fn clone(&self) -> Self {
         Self {
             with: self.with.clone(),
             without: self.without.clone(),
-            _index_type: PhantomData,
         }
     }
 
@@ -1286,26 +1259,16 @@ impl<T: SparseSetIndex> Clone for AccessFilters<T> {
     }
 }
 
-impl<T: SparseSetIndex + Debug> Debug for AccessFilters<T> {
+impl Debug for AccessFilters {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         f.debug_struct("AccessFilters")
-            .field("with", &FormattedBitSet::<T>::new(&self.with))
-            .field("without", &FormattedBitSet::<T>::new(&self.without))
+            .field("with", &FormattedBitSet::new(&self.with))
+            .field("without", &FormattedBitSet::new(&self.without))
             .finish()
     }
 }
 
-impl<T: SparseSetIndex> Default for AccessFilters<T> {
-    fn default() -> Self {
-        Self {
-            with: FixedBitSet::default(),
-            without: FixedBitSet::default(),
-            _index_type: PhantomData,
-        }
-    }
-}
-
-impl<T: SparseSetIndex> AccessFilters<T> {
+impl AccessFilters {
     fn is_ruled_out_by(&self, other: &Self) -> bool {
         // Although not technically complete, we don't consider the case when `AccessFilters`'s
         // `without` bitset contradicts its own `with` bitset (e.g. `(With<A>, Without<A>)`).
@@ -1323,14 +1286,14 @@ impl<T: SparseSetIndex> AccessFilters<T> {
 /// It stores multiple sets of accesses.
 /// - A "combined" set, which is the access of all filters in this set combined.
 /// - The set of access of each individual filters in this set.
-#[derive(Debug, PartialEq, Eq)]
-pub struct FilteredAccessSet<T: SparseSetIndex> {
-    combined_access: Access<T>,
-    filtered_accesses: Vec<FilteredAccess<T>>,
+#[derive(Debug, PartialEq, Eq, Default)]
+pub struct FilteredAccessSet {
+    combined_access: Access,
+    filtered_accesses: Vec<FilteredAccess>,
 }
 
 // This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.
-impl<T: SparseSetIndex> Clone for FilteredAccessSet<T> {
+impl Clone for FilteredAccessSet {
     fn clone(&self) -> Self {
         Self {
             combined_access: self.combined_access.clone(),
@@ -1344,7 +1307,7 @@ impl<T: SparseSetIndex> Clone for FilteredAccessSet<T> {
     }
 }
 
-impl<T: SparseSetIndex> FilteredAccessSet<T> {
+impl FilteredAccessSet {
     /// Creates an empty [`FilteredAccessSet`].
     pub const fn new() -> Self {
         Self {
@@ -1355,7 +1318,7 @@ impl<T: SparseSetIndex> FilteredAccessSet<T> {
 
     /// Returns a reference to the unfiltered access of the entire set.
     #[inline]
-    pub fn combined_access(&self) -> &Access<T> {
+    pub fn combined_access(&self) -> &Access {
         &self.combined_access
     }
 
@@ -1371,7 +1334,7 @@ impl<T: SparseSetIndex> FilteredAccessSet<T> {
     ///    mutually exclusive. The fine grained phase iterates over all filters in
     ///    the `self` set and compares it to all the filters in the `other` set,
     ///    making sure they are all mutually compatible.
-    pub fn is_compatible(&self, other: &FilteredAccessSet<T>) -> bool {
+    pub fn is_compatible(&self, other: &FilteredAccessSet) -> bool {
         if self.combined_access.is_compatible(other.combined_access()) {
             return true;
         }
@@ -1386,7 +1349,7 @@ impl<T: SparseSetIndex> FilteredAccessSet<T> {
     }
 
     /// Returns a vector of elements that this set and `other` cannot access at the same time.
-    pub fn get_conflicts(&self, other: &FilteredAccessSet<T>) -> AccessConflicts {
+    pub fn get_conflicts(&self, other: &FilteredAccessSet) -> AccessConflicts {
         // if the unfiltered access is incompatible, must check each pair
         let mut conflicts = AccessConflicts::empty();
         if !self.combined_access.is_compatible(other.combined_access()) {
@@ -1400,7 +1363,7 @@ impl<T: SparseSetIndex> FilteredAccessSet<T> {
     }
 
     /// Returns a vector of elements that this set and `other` cannot access at the same time.
-    pub fn get_conflicts_single(&self, filtered_access: &FilteredAccess<T>) -> AccessConflicts {
+    pub fn get_conflicts_single(&self, filtered_access: &FilteredAccess) -> AccessConflicts {
         // if the unfiltered access is incompatible, must check each pair
         let mut conflicts = AccessConflicts::empty();
         if !self.combined_access.is_compatible(filtered_access.access()) {
@@ -1412,20 +1375,20 @@ impl<T: SparseSetIndex> FilteredAccessSet<T> {
     }
 
     /// Adds the filtered access to the set.
-    pub fn add(&mut self, filtered_access: FilteredAccess<T>) {
+    pub fn add(&mut self, filtered_access: FilteredAccess) {
         self.combined_access.extend(&filtered_access.access);
         self.filtered_accesses.push(filtered_access);
     }
 
     /// Adds a read access to a resource to the set.
-    pub fn add_unfiltered_resource_read(&mut self, index: T) {
+    pub fn add_unfiltered_resource_read(&mut self, index: ComponentId) {
         let mut filter = FilteredAccess::default();
         filter.add_resource_read(index);
         self.add(filter);
     }
 
     /// Adds a write access to a resource to the set.
-    pub fn add_unfiltered_resource_write(&mut self, index: T) {
+    pub fn add_unfiltered_resource_write(&mut self, index: ComponentId) {
         let mut filter = FilteredAccess::default();
         filter.add_resource_write(index);
         self.add(filter);
@@ -1446,7 +1409,7 @@ impl<T: SparseSetIndex> FilteredAccessSet<T> {
     }
 
     /// Adds all of the accesses from the passed set to `self`.
-    pub fn extend(&mut self, filtered_access_set: FilteredAccessSet<T>) {
+    pub fn extend(&mut self, filtered_access_set: FilteredAccessSet) {
         self.combined_access
             .extend(&filtered_access_set.combined_access);
         self.filtered_accesses
@@ -1474,48 +1437,44 @@ impl<T: SparseSetIndex> FilteredAccessSet<T> {
     }
 }
 
-impl<T: SparseSetIndex> Default for FilteredAccessSet<T> {
-    fn default() -> Self {
-        Self::new()
-    }
-}
-
 #[cfg(test)]
 mod tests {
     use super::{invertible_difference_with, invertible_union_with};
-    use crate::query::{
-        access::AccessFilters, Access, AccessConflicts, ComponentAccessKind, FilteredAccess,
-        FilteredAccessSet, UnboundedAccessError,
+    use crate::{
+        component::ComponentId,
+        query::{
+            access::AccessFilters, Access, AccessConflicts, ComponentAccessKind, FilteredAccess,
+            FilteredAccessSet, UnboundedAccessError,
+        },
     };
     use alloc::{vec, vec::Vec};
-    use core::marker::PhantomData;
     use fixedbitset::FixedBitSet;
 
-    fn create_sample_access() -> Access<usize> {
-        let mut access = Access::<usize>::default();
+    fn create_sample_access() -> Access {
+        let mut access = Access::default();
 
-        access.add_component_read(1);
-        access.add_component_read(2);
-        access.add_component_write(3);
-        access.add_archetypal(5);
+        access.add_component_read(ComponentId::new(1));
+        access.add_component_read(ComponentId::new(2));
+        access.add_component_write(ComponentId::new(3));
+        access.add_archetypal(ComponentId::new(5));
         access.read_all();
 
         access
     }
 
-    fn create_sample_filtered_access() -> FilteredAccess<usize> {
-        let mut filtered_access = FilteredAccess::<usize>::default();
+    fn create_sample_filtered_access() -> FilteredAccess {
+        let mut filtered_access = FilteredAccess::default();
 
-        filtered_access.add_component_write(1);
-        filtered_access.add_component_read(2);
-        filtered_access.add_required(3);
-        filtered_access.and_with(4);
+        filtered_access.add_component_write(ComponentId::new(1));
+        filtered_access.add_component_read(ComponentId::new(2));
+        filtered_access.add_required(ComponentId::new(3));
+        filtered_access.and_with(ComponentId::new(4));
 
         filtered_access
     }
 
-    fn create_sample_access_filters() -> AccessFilters<usize> {
-        let mut access_filters = AccessFilters::<usize>::default();
+    fn create_sample_access_filters() -> AccessFilters {
+        let mut access_filters = AccessFilters::default();
 
         access_filters.with.grow_and_insert(3);
         access_filters.without.grow_and_insert(5);
@@ -1523,11 +1482,11 @@ mod tests {
         access_filters
     }
 
-    fn create_sample_filtered_access_set() -> FilteredAccessSet<usize> {
-        let mut filtered_access_set = FilteredAccessSet::<usize>::default();
+    fn create_sample_filtered_access_set() -> FilteredAccessSet {
+        let mut filtered_access_set = FilteredAccessSet::default();
 
-        filtered_access_set.add_unfiltered_resource_read(2);
-        filtered_access_set.add_unfiltered_resource_write(4);
+        filtered_access_set.add_unfiltered_resource_read(ComponentId::new(2));
+        filtered_access_set.add_unfiltered_resource_write(ComponentId::new(4));
         filtered_access_set.read_all();
 
         filtered_access_set
@@ -1535,7 +1494,7 @@ mod tests {
 
     #[test]
     fn test_access_clone() {
-        let original: Access<usize> = create_sample_access();
+        let original = create_sample_access();
         let cloned = original.clone();
 
         assert_eq!(original, cloned);
@@ -1543,12 +1502,12 @@ mod tests {
 
     #[test]
     fn test_access_clone_from() {
-        let original: Access<usize> = create_sample_access();
-        let mut cloned = Access::<usize>::default();
+        let original = create_sample_access();
+        let mut cloned = Access::default();
 
-        cloned.add_component_write(7);
-        cloned.add_component_read(4);
-        cloned.add_archetypal(8);
+        cloned.add_component_write(ComponentId::new(7));
+        cloned.add_component_read(ComponentId::new(4));
+        cloned.add_archetypal(ComponentId::new(8));
         cloned.write_all();
 
         cloned.clone_from(&original);
@@ -1558,7 +1517,7 @@ mod tests {
 
     #[test]
     fn test_filtered_access_clone() {
-        let original: FilteredAccess<usize> = create_sample_filtered_access();
+        let original = create_sample_filtered_access();
         let cloned = original.clone();
 
         assert_eq!(original, cloned);
@@ -1566,11 +1525,11 @@ mod tests {
 
     #[test]
     fn test_filtered_access_clone_from() {
-        let original: FilteredAccess<usize> = create_sample_filtered_access();
-        let mut cloned = FilteredAccess::<usize>::default();
+        let original = create_sample_filtered_access();
+        let mut cloned = FilteredAccess::default();
 
-        cloned.add_component_write(7);
-        cloned.add_component_read(4);
+        cloned.add_component_write(ComponentId::new(7));
+        cloned.add_component_read(ComponentId::new(4));
         cloned.append_or(&FilteredAccess::default());
 
         cloned.clone_from(&original);
@@ -1580,7 +1539,7 @@ mod tests {
 
     #[test]
     fn test_access_filters_clone() {
-        let original: AccessFilters<usize> = create_sample_access_filters();
+        let original = create_sample_access_filters();
         let cloned = original.clone();
 
         assert_eq!(original, cloned);
@@ -1588,8 +1547,8 @@ mod tests {
 
     #[test]
     fn test_access_filters_clone_from() {
-        let original: AccessFilters<usize> = create_sample_access_filters();
-        let mut cloned = AccessFilters::<usize>::default();
+        let original = create_sample_access_filters();
+        let mut cloned = AccessFilters::default();
 
         cloned.with.grow_and_insert(1);
         cloned.without.grow_and_insert(2);
@@ -1601,7 +1560,7 @@ mod tests {
 
     #[test]
     fn test_filtered_access_set_clone() {
-        let original: FilteredAccessSet<usize> = create_sample_filtered_access_set();
+        let original = create_sample_filtered_access_set();
         let cloned = original.clone();
 
         assert_eq!(original, cloned);
@@ -1609,11 +1568,11 @@ mod tests {
 
     #[test]
     fn test_filtered_access_set_from() {
-        let original: FilteredAccessSet<usize> = create_sample_filtered_access_set();
-        let mut cloned = FilteredAccessSet::<usize>::default();
+        let original = create_sample_filtered_access_set();
+        let mut cloned = FilteredAccessSet::default();
 
-        cloned.add_unfiltered_resource_read(7);
-        cloned.add_unfiltered_resource_write(9);
+        cloned.add_unfiltered_resource_read(ComponentId::new(7));
+        cloned.add_unfiltered_resource_write(ComponentId::new(9));
         cloned.write_all();
 
         cloned.clone_from(&original);
@@ -1624,19 +1583,19 @@ mod tests {
     #[test]
     fn read_all_access_conflicts() {
         // read_all / single write
-        let mut access_a = Access::<usize>::default();
-        access_a.add_component_write(0);
+        let mut access_a = Access::default();
+        access_a.add_component_write(ComponentId::new(0));
 
-        let mut access_b = Access::<usize>::default();
+        let mut access_b = Access::default();
         access_b.read_all();
 
         assert!(!access_b.is_compatible(&access_a));
 
         // read_all / read_all
-        let mut access_a = Access::<usize>::default();
+        let mut access_a = Access::default();
         access_a.read_all();
 
-        let mut access_b = Access::<usize>::default();
+        let mut access_b = Access::default();
         access_b.read_all();
 
         assert!(access_b.is_compatible(&access_a));
@@ -1644,92 +1603,98 @@ mod tests {
 
     #[test]
     fn access_get_conflicts() {
-        let mut access_a = Access::<usize>::default();
-        access_a.add_component_read(0);
-        access_a.add_component_read(1);
+        let mut access_a = Access::default();
+        access_a.add_component_read(ComponentId::new(0));
+        access_a.add_component_read(ComponentId::new(1));
 
-        let mut access_b = Access::<usize>::default();
-        access_b.add_component_read(0);
-        access_b.add_component_write(1);
+        let mut access_b = Access::default();
+        access_b.add_component_read(ComponentId::new(0));
+        access_b.add_component_write(ComponentId::new(1));
 
-        assert_eq!(access_a.get_conflicts(&access_b), vec![1_usize].into());
+        assert_eq!(
+            access_a.get_conflicts(&access_b),
+            vec![ComponentId::new(1)].into()
+        );
 
-        let mut access_c = Access::<usize>::default();
-        access_c.add_component_write(0);
-        access_c.add_component_write(1);
+        let mut access_c = Access::default();
+        access_c.add_component_write(ComponentId::new(0));
+        access_c.add_component_write(ComponentId::new(1));
 
         assert_eq!(
             access_a.get_conflicts(&access_c),
-            vec![0_usize, 1_usize].into()
+            vec![ComponentId::new(0), ComponentId::new(1)].into()
         );
         assert_eq!(
             access_b.get_conflicts(&access_c),
-            vec![0_usize, 1_usize].into()
+            vec![ComponentId::new(0), ComponentId::new(1)].into()
         );
 
-        let mut access_d = Access::<usize>::default();
-        access_d.add_component_read(0);
+        let mut access_d = Access::default();
+        access_d.add_component_read(ComponentId::new(0));
 
         assert_eq!(access_d.get_conflicts(&access_a), AccessConflicts::empty());
         assert_eq!(access_d.get_conflicts(&access_b), AccessConflicts::empty());
-        assert_eq!(access_d.get_conflicts(&access_c), vec![0_usize].into());
+        assert_eq!(
+            access_d.get_conflicts(&access_c),
+            vec![ComponentId::new(0)].into()
+        );
     }
 
     #[test]
     fn filtered_combined_access() {
-        let mut access_a = FilteredAccessSet::<usize>::default();
-        access_a.add_unfiltered_resource_read(1);
+        let mut access_a = FilteredAccessSet::default();
+        access_a.add_unfiltered_resource_read(ComponentId::new(1));
 
-        let mut filter_b = FilteredAccess::<usize>::default();
-        filter_b.add_resource_write(1);
+        let mut filter_b = FilteredAccess::default();
+        filter_b.add_resource_write(ComponentId::new(1));
 
         let conflicts = access_a.get_conflicts_single(&filter_b);
         assert_eq!(
             &conflicts,
-            &AccessConflicts::from(vec![1_usize]),
+            &AccessConflicts::from(vec![ComponentId::new(1)]),
             "access_a: {access_a:?}, filter_b: {filter_b:?}"
         );
     }
 
     #[test]
     fn filtered_access_extend() {
-        let mut access_a = FilteredAccess::<usize>::default();
-        access_a.add_component_read(0);
-        access_a.add_component_read(1);
-        access_a.and_with(2);
+        let mut access_a = FilteredAccess::default();
+        access_a.add_component_read(ComponentId::new(0));
+        access_a.add_component_read(ComponentId::new(1));
+        access_a.and_with(ComponentId::new(2));
 
-        let mut access_b = FilteredAccess::<usize>::default();
-        access_b.add_component_read(0);
-        access_b.add_component_write(3);
-        access_b.and_without(4);
+        let mut access_b = FilteredAccess::default();
+        access_b.add_component_read(ComponentId::new(0));
+        access_b.add_component_write(ComponentId::new(3));
+        access_b.and_without(ComponentId::new(4));
 
         access_a.extend(&access_b);
 
-        let mut expected = FilteredAccess::<usize>::default();
-        expected.add_component_read(0);
-        expected.add_component_read(1);
-        expected.and_with(2);
-        expected.add_component_write(3);
-        expected.and_without(4);
+        let mut expected = FilteredAccess::default();
+        expected.add_component_read(ComponentId::new(0));
+        expected.add_component_read(ComponentId::new(1));
+        expected.and_with(ComponentId::new(2));
+        expected.add_component_write(ComponentId::new(3));
+        expected.and_without(ComponentId::new(4));
 
         assert!(access_a.eq(&expected));
     }
 
     #[test]
     fn filtered_access_extend_or() {
-        let mut access_a = FilteredAccess::<usize>::default();
+        let mut access_a = FilteredAccess::default();
         // Exclusive access to `(&mut A, &mut B)`.
-        access_a.add_component_write(0);
-        access_a.add_component_write(1);
+        access_a.add_component_write(ComponentId::new(0));
+        access_a.add_component_write(ComponentId::new(1));
 
         // Filter by `With<C>`.
-        let mut access_b = FilteredAccess::<usize>::default();
-        access_b.and_with(2);
+        let mut access_b = FilteredAccess::default();
+        access_b.and_with(ComponentId::new(2));
 
         // Filter by `(With<D>, Without<E>)`.
-        let mut access_c = FilteredAccess::<usize>::default();
-        access_c.and_with(3);
-        access_c.and_without(4);
+        let mut access_c = FilteredAccess::default();
+        access_c.and_with(ComponentId::new(3));
+        access_c.and_without(ComponentId::new(4));
 
         // Turns `access_b` into `Or<(With<C>, (With<D>, Without<D>))>`.
         access_b.append_or(&access_c);
@@ -1740,20 +1705,18 @@ mod tests {
         // Construct the expected `FilteredAccess` struct.
         // The intention here is to test that exclusive access implied by `add_write`
         // forms correct normalized access structs when extended with `Or` filters.
-        let mut expected = FilteredAccess::<usize>::default();
-        expected.add_component_write(0);
-        expected.add_component_write(1);
+        let mut expected = FilteredAccess::default();
+        expected.add_component_write(ComponentId::new(0));
+        expected.add_component_write(ComponentId::new(1));
         // The resulted access is expected to represent `Or<((With<A>, With<B>, With<C>), (With<A>, With<B>, With<D>, Without<E>))>`.
         expected.filter_sets = vec![
             AccessFilters {
                 with: FixedBitSet::with_capacity_and_blocks(3, [0b111]),
                 without: FixedBitSet::default(),
-                _index_type: PhantomData,
             },
             AccessFilters {
                 with: FixedBitSet::with_capacity_and_blocks(4, [0b1011]),
                 without: FixedBitSet::with_capacity_and_blocks(5, [0b10000]),
-                _index_type: PhantomData,
             },
         ];
 
@@ -1762,12 +1725,12 @@ mod tests {
 
     #[test]
     fn try_iter_component_access_simple() {
-        let mut access = Access::<usize>::default();
+        let mut access = Access::default();
 
-        access.add_component_read(1);
-        access.add_component_read(2);
-        access.add_component_write(3);
-        access.add_archetypal(5);
+        access.add_component_read(ComponentId::new(1));
+        access.add_component_read(ComponentId::new(2));
+        access.add_component_write(ComponentId::new(3));
+        access.add_archetypal(ComponentId::new(5));
 
         let result = access
             .try_iter_component_access()
@@ -1776,20 +1739,20 @@ mod tests {
         assert_eq!(
             result,
             Ok(vec![
-                ComponentAccessKind::Shared(1),
-                ComponentAccessKind::Shared(2),
-                ComponentAccessKind::Exclusive(3),
-                ComponentAccessKind::Archetypal(5),
+                ComponentAccessKind::Shared(ComponentId::new(1)),
+                ComponentAccessKind::Shared(ComponentId::new(2)),
+                ComponentAccessKind::Exclusive(ComponentId::new(3)),
+                ComponentAccessKind::Archetypal(ComponentId::new(5)),
             ]),
         );
     }
 
     #[test]
     fn try_iter_component_access_unbounded_write_all() {
-        let mut access = Access::<usize>::default();
+        let mut access = Access::default();
 
-        access.add_component_read(1);
-        access.add_component_read(2);
+        access.add_component_read(ComponentId::new(1));
+        access.add_component_read(ComponentId::new(2));
         access.write_all();
 
         let result = access
@@ -1807,10 +1770,10 @@ mod tests {
 
     #[test]
     fn try_iter_component_access_unbounded_read_all() {
-        let mut access = Access::<usize>::default();
+        let mut access = Access::default();
 
-        access.add_component_read(1);
-        access.add_component_read(2);
+        access.add_component_read(ComponentId::new(1));
+        access.add_component_read(ComponentId::new(2));
         access.read_all();
 
         let result = access
diff --git a/crates/bevy_ecs/src/query/builder.rs b/crates/bevy_ecs/src/query/builder.rs
index b545caad8f92c..8ba34a34f9ee7 100644
--- a/crates/bevy_ecs/src/query/builder.rs
+++ b/crates/bevy_ecs/src/query/builder.rs
@@ -36,7 +36,7 @@ use super::{FilteredAccess, QueryData, QueryFilter};
 /// let (entity, b) = query.single(&world).unwrap();
 /// ```
 pub struct QueryBuilder<'w, D: QueryData = (), F: QueryFilter = ()> {
-    access: FilteredAccess<ComponentId>,
+    access: FilteredAccess,
     world: &'w mut World,
     or: bool,
     first: bool,
@@ -105,7 +105,7 @@ impl<'w, D: QueryData, F: QueryFilter> QueryBuilder<'w, D, F> {
     }
 
     /// Adds access to self's underlying [`FilteredAccess`] respecting [`Self::or`] and [`Self::and`]
-    pub fn extend_access(&mut self, mut access: FilteredAccess<ComponentId>) {
+    pub fn extend_access(&mut self, mut access: FilteredAccess) {
         if self.or {
             if self.first {
                 access.required.clear();
@@ -231,7 +231,7 @@ impl<'w, D: QueryData, F: QueryFilter> QueryBuilder<'w, D, F> {
     }
 
     /// Returns a reference to the [`FilteredAccess`] that will be provided to the built [`Query`].
-    pub fn access(&self) -> &FilteredAccess<ComponentId> {
+    pub fn access(&self) -> &FilteredAccess {
         &self.access
     }
 
diff --git a/crates/bevy_ecs/src/query/fetch.rs b/crates/bevy_ecs/src/query/fetch.rs
index 57babe6f95f7b..4beb4e9a62044 100644
--- a/crates/bevy_ecs/src/query/fetch.rs
+++ b/crates/bevy_ecs/src/query/fetch.rs
@@ -308,8 +308,8 @@ pub unsafe trait QueryData: WorldQuery {
     /// Called when constructing a [`QueryLens`](crate::system::QueryLens) or calling [`QueryState::from_builder`](super::QueryState::from_builder)
     fn provide_extra_access(
         _state: &mut Self::State,
-        _access: &mut Access<ComponentId>,
-        _available_access: &Access<ComponentId>,
+        _access: &mut Access,
+        _available_access: &Access,
     ) {
     }
 
@@ -391,7 +391,7 @@ unsafe impl WorldQuery for Entity {
     ) {
     }
 
-    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess<ComponentId>) {}
+    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess) {}
 
     fn init_state(_world: &mut World) {}
 
@@ -481,7 +481,7 @@ unsafe impl WorldQuery for EntityLocation {
     ) {
     }
 
-    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess<ComponentId>) {}
+    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess) {}
 
     fn init_state(_world: &mut World) {}
 
@@ -642,7 +642,7 @@ unsafe impl WorldQuery for SpawnDetails {
     ) {
     }
 
-    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess<ComponentId>) {}
+    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess) {}
 
     fn init_state(_world: &mut World) {}
 
@@ -757,7 +757,7 @@ unsafe impl<'a> WorldQuery for EntityRef<'a> {
     ) {
     }
 
-    fn update_component_access(_state: &Self::State, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(_state: &Self::State, access: &mut FilteredAccess) {
         assert!(
             !access.access().has_any_component_write(),
             "EntityRef conflicts with a previous access in this query. Shared access cannot coincide with exclusive access.",
@@ -860,7 +860,7 @@ unsafe impl<'a> WorldQuery for EntityMut<'a> {
     ) {
     }
 
-    fn update_component_access(_state: &Self::State, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(_state: &Self::State, access: &mut FilteredAccess) {
         assert!(
             !access.access().has_any_component_read(),
             "EntityMut conflicts with a previous access in this query. Exclusive access cannot coincide with any other accesses.",
@@ -922,7 +922,7 @@ impl ReleaseStateQueryData for EntityMut<'_> {
 /// SAFETY: The accesses of `Self::ReadOnly` are a subset of the accesses of `Self`
 unsafe impl WorldQuery for FilteredEntityRef<'_, '_> {
     type Fetch<'w> = EntityFetch<'w>;
-    type State = Access<ComponentId>;
+    type State = Access;
 
     fn shrink_fetch<'wlong: 'wshort, 'wshort>(fetch: Self::Fetch<'wlong>) -> Self::Fetch<'wshort> {
         fetch
@@ -960,10 +960,7 @@ unsafe impl WorldQuery for FilteredEntityRef<'_, '_> {
     ) {
     }
 
-    fn update_component_access(
-        state: &Self::State,
-        filtered_access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(state: &Self::State, filtered_access: &mut FilteredAccess) {
         assert!(
             filtered_access.access().is_compatible(state),
             "FilteredEntityRef conflicts with a previous access in this query. Exclusive access cannot coincide with any other accesses.",
@@ -1002,8 +999,8 @@ unsafe impl QueryData for FilteredEntityRef<'_, '_> {
     #[inline]
     fn provide_extra_access(
         state: &mut Self::State,
-        access: &mut Access<ComponentId>,
-        available_access: &Access<ComponentId>,
+        access: &mut Access,
+        available_access: &Access,
     ) {
         // Claim any extra access that doesn't conflict with other subqueries
         // This is used when constructing a `QueryLens` or creating a query from a `QueryBuilder`
@@ -1043,7 +1040,7 @@ unsafe impl ReadOnlyQueryData for FilteredEntityRef<'_, '_> {}
 /// SAFETY: The accesses of `Self::ReadOnly` are a subset of the accesses of `Self`
 unsafe impl WorldQuery for FilteredEntityMut<'_, '_> {
     type Fetch<'w> = EntityFetch<'w>;
-    type State = Access<ComponentId>;
+    type State = Access;
 
     fn shrink_fetch<'wlong: 'wshort, 'wshort>(fetch: Self::Fetch<'wlong>) -> Self::Fetch<'wshort> {
         fetch
@@ -1081,10 +1078,7 @@ unsafe impl WorldQuery for FilteredEntityMut<'_, '_> {
     ) {
     }
 
-    fn update_component_access(
-        state: &Self::State,
-        filtered_access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(state: &Self::State, filtered_access: &mut FilteredAccess) {
         assert!(
             filtered_access.access().is_compatible(state),
             "FilteredEntityMut conflicts with a previous access in this query. Exclusive access cannot coincide with any other accesses.",
@@ -1123,8 +1117,8 @@ unsafe impl<'a, 'b> QueryData for FilteredEntityMut<'a, 'b> {
     #[inline]
     fn provide_extra_access(
         state: &mut Self::State,
-        access: &mut Access<ComponentId>,
-        available_access: &Access<ComponentId>,
+        access: &mut Access,
+        available_access: &Access,
     ) {
         // Claim any extra access that doesn't conflict with other subqueries
         // This is used when constructing a `QueryLens` or creating a query from a `QueryBuilder`
@@ -1164,7 +1158,7 @@ where
     B: Bundle,
 {
     type Fetch<'w> = EntityFetch<'w>;
-    type State = Access<ComponentId>;
+    type State = Access;
 
     fn shrink_fetch<'wlong: 'wshort, 'wshort>(fetch: Self::Fetch<'wlong>) -> Self::Fetch<'wshort> {
         fetch
@@ -1195,10 +1189,7 @@ where
 
     unsafe fn set_table<'w, 's>(_: &mut Self::Fetch<'w>, _: &'s Self::State, _: &'w Table) {}
 
-    fn update_component_access(
-        state: &Self::State,
-        filtered_access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(state: &Self::State, filtered_access: &mut FilteredAccess) {
         let access = filtered_access.access_mut();
         assert!(
             access.is_compatible(state),
@@ -1280,7 +1271,7 @@ where
     B: Bundle,
 {
     type Fetch<'w> = EntityFetch<'w>;
-    type State = Access<ComponentId>;
+    type State = Access;
 
     fn shrink_fetch<'wlong: 'wshort, 'wshort>(fetch: Self::Fetch<'wlong>) -> Self::Fetch<'wshort> {
         fetch
@@ -1311,10 +1302,7 @@ where
 
     unsafe fn set_table<'w, 's>(_: &mut Self::Fetch<'w>, _: &'s Self::State, _: &'w Table) {}
 
-    fn update_component_access(
-        state: &Self::State,
-        filtered_access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(state: &Self::State, filtered_access: &mut FilteredAccess) {
         let access = filtered_access.access_mut();
         assert!(
             access.is_compatible(state),
@@ -1426,7 +1414,7 @@ unsafe impl WorldQuery for &Archetype {
     ) {
     }
 
-    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess<ComponentId>) {}
+    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess) {}
 
     fn init_state(_world: &mut World) {}
 
@@ -1569,10 +1557,7 @@ unsafe impl<T: Component> WorldQuery for &T {
         unsafe { fetch.components.set_table(table_data) };
     }
 
-    fn update_component_access(
-        &component_id: &ComponentId,
-        access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(&component_id: &ComponentId, access: &mut FilteredAccess) {
         assert!(
             !access.access().has_component_write(component_id),
             "&{} conflicts with a previous access in this query. Shared access cannot coincide with exclusive access.",
@@ -1755,10 +1740,7 @@ unsafe impl<'__w, T: Component> WorldQuery for Ref<'__w, T> {
         unsafe { fetch.components.set_table(table_data) };
     }
 
-    fn update_component_access(
-        &component_id: &ComponentId,
-        access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(&component_id: &ComponentId, access: &mut FilteredAccess) {
         assert!(
             !access.access().has_component_write(component_id),
             "&{} conflicts with a previous access in this query. Shared access cannot coincide with exclusive access.",
@@ -1964,10 +1946,7 @@ unsafe impl<'__w, T: Component> WorldQuery for &'__w mut T {
         unsafe { fetch.components.set_table(table_data) };
     }
 
-    fn update_component_access(
-        &component_id: &ComponentId,
-        access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(&component_id: &ComponentId, access: &mut FilteredAccess) {
         assert!(
             !access.access().has_component_read(component_id),
             "&mut {} conflicts with a previous access in this query. Mutable component access must be unique.",
@@ -2111,10 +2090,7 @@ unsafe impl<'__w, T: Component> WorldQuery for Mut<'__w, T> {
     }
 
     // NOT forwarded to `&mut T`
-    fn update_component_access(
-        &component_id: &ComponentId,
-        access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(&component_id: &ComponentId, access: &mut FilteredAccess) {
         // Update component access here instead of in `<&mut T as WorldQuery>` to avoid erroneously referencing
         // `&mut T` in error message.
         assert!(
@@ -2254,7 +2230,7 @@ unsafe impl<T: WorldQuery> WorldQuery for Option<T> {
         }
     }
 
-    fn update_component_access(state: &T::State, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(state: &T::State, access: &mut FilteredAccess) {
         // FilteredAccess::add_[write,read] adds the component to the `with` filter.
         // Those methods are called on `access` in `T::update_component_access`.
         // But in `Option<T>`, we specifically don't filter on `T`,
@@ -2438,10 +2414,7 @@ unsafe impl<T: Component> WorldQuery for Has<T> {
         *fetch = table.has_column(*state);
     }
 
-    fn update_component_access(
-        &component_id: &Self::State,
-        access: &mut FilteredAccess<ComponentId>,
-    ) {
+    fn update_component_access(&component_id: &Self::State, access: &mut FilteredAccess) {
         access.access_mut().add_archetypal(component_id);
     }
 
@@ -2536,8 +2509,8 @@ macro_rules! impl_tuple_query_data {
             #[inline]
             fn provide_extra_access(
                 state: &mut Self::State,
-                access: &mut Access<ComponentId>,
-                available_access: &Access<ComponentId>,
+                access: &mut Access,
+                available_access: &Access,
             ) {
                 let ($($name,)*) = state;
                 $($name::provide_extra_access($name, access, available_access);)*
@@ -2651,7 +2624,7 @@ macro_rules! impl_anytuple_fetch {
                 )*
             }
 
-            fn update_component_access(state: &Self::State, access: &mut FilteredAccess<ComponentId>) {
+            fn update_component_access(state: &Self::State, access: &mut FilteredAccess) {
                 // update the filters (Or<(With<$name>,)>)
                 let ($($name,)*) = state;
 
@@ -2813,7 +2786,7 @@ unsafe impl<D: QueryData> WorldQuery for NopWorldQuery<D> {
     #[inline(always)]
     unsafe fn set_table<'w>(_fetch: &mut (), _state: &D::State, _table: &Table) {}
 
-    fn update_component_access(_state: &D::State, _access: &mut FilteredAccess<ComponentId>) {}
+    fn update_component_access(_state: &D::State, _access: &mut FilteredAccess) {}
 
     fn init_state(world: &mut World) -> Self::State {
         D::init_state(world)
@@ -2897,7 +2870,7 @@ unsafe impl<T: ?Sized> WorldQuery for PhantomData<T> {
     ) {
     }
 
-    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess<ComponentId>) {}
+    fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess) {}
 
     fn init_state(_world: &mut World) -> Self::State {}
 
@@ -3099,11 +3072,7 @@ mod tests {
             ) {
             }
 
-            fn update_component_access(
-                _state: &Self::State,
-                _access: &mut FilteredAccess<ComponentId>,
-            ) {
-            }
+            fn update_component_access(_state: &Self::State, _access: &mut FilteredAccess) {}
 
             fn init_state(_world: &mut World) {}
 
diff --git a/crates/bevy_ecs/src/query/filter.rs b/crates/bevy_ecs/src/query/filter.rs
index f9f4861b796ee..6269fc95b8db9 100644
--- a/crates/bevy_ecs/src/query/filter.rs
+++ b/crates/bevy_ecs/src/query/filter.rs
@@ -180,7 +180,7 @@ unsafe impl<T: Component> WorldQuery for With<T> {
     unsafe fn set_table(_fetch: &mut (), _state: &ComponentId, _table: &Table) {}
 
     #[inline]
-    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess) {
         access.and_with(id);
     }
 
@@ -281,7 +281,7 @@ unsafe impl<T: Component> WorldQuery for Without<T> {
     unsafe fn set_table(_fetch: &mut (), _state: &Self::State, _table: &Table) {}
 
     #[inline]
-    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess) {
         access.and_without(id);
     }
 
@@ -444,7 +444,7 @@ macro_rules! impl_or_query_filter {
                 )*
             }
 
-            fn update_component_access(state: &Self::State, access: &mut FilteredAccess<ComponentId>) {
+            fn update_component_access(state: &Self::State, access: &mut FilteredAccess) {
                 let ($($filter,)*) = state;
 
                 let mut new_access = FilteredAccess::matches_nothing();
@@ -595,7 +595,7 @@ unsafe impl<T: Component> WorldQuery for Allows<T> {
     unsafe fn set_table(_: &mut (), _: &ComponentId, _: &Table) {}
 
     #[inline]
-    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess) {
         access.access_mut().add_archetypal(id);
     }
 
@@ -793,7 +793,7 @@ unsafe impl<T: Component> WorldQuery for Added<T> {
     }
 
     #[inline]
-    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess) {
         if access.access().has_component_write(id) {
             panic!("$state_name<{}> conflicts with a previous access in this query. Shared access cannot coincide with exclusive access.", DebugName::type_name::<T>());
         }
@@ -1020,7 +1020,7 @@ unsafe impl<T: Component> WorldQuery for Changed<T> {
     }
 
     #[inline]
-    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess<ComponentId>) {
+    fn update_component_access(&id: &ComponentId, access: &mut FilteredAccess) {
         if access.access().has_component_write(id) {
             panic!("$state_name<{}> conflicts with a previous access in this query. Shared access cannot coincide with exclusive access.", DebugName::type_name::<T>());
         }
@@ -1185,7 +1185,7 @@ unsafe impl WorldQuery for Spawned {
     unsafe fn set_table<'w, 's>(_fetch: &mut Self::Fetch<'w>, _state: &'s (), _table: &'w Table) {}
 
     #[inline]
-    fn update_component_access(_state: &(), _access: &mut FilteredAccess<ComponentId>) {}
+    fn update_component_access(_state: &(), _access: &mut FilteredAccess) {}
 
     fn init_state(_world: &mut World) {}
 
diff --git a/crates/bevy_ecs/src/query/mod.rs b/crates/bevy_ecs/src/query/mod.rs
index 94772cc9b9c66..607b239f7059b 100644
--- a/crates/bevy_ecs/src/query/mod.rs
+++ b/crates/bevy_ecs/src/query/mod.rs
@@ -851,10 +851,7 @@ mod tests {
         ) {
         }
 
-        fn update_component_access(
-            &component_id: &Self::State,
-            access: &mut FilteredAccess<ComponentId>,
-        ) {
+        fn update_component_access(&component_id: &Self::State, access: &mut FilteredAccess) {
             assert!(
                 !access.access().has_resource_write(component_id),
                 "ReadsRData conflicts with a previous access in this query. Shared access cannot coincide with exclusive access."
diff --git a/crates/bevy_ecs/src/query/state.rs b/crates/bevy_ecs/src/query/state.rs
index 14736f8ced91d..dd940b88c97cc 100644
--- a/crates/bevy_ecs/src/query/state.rs
+++ b/crates/bevy_ecs/src/query/state.rs
@@ -76,7 +76,7 @@ pub struct QueryState<D: QueryData, F: QueryFilter = ()> {
     /// Note that because we do a zero-cost reference conversion in `Query::as_readonly`,
     /// the access for a read-only query may include accesses for the original mutable version,
     /// but the `Query` does not have exclusive access to those components.
-    pub(crate) component_access: FilteredAccess<ComponentId>,
+    pub(crate) component_access: FilteredAccess,
     // NOTE: we maintain both a bitset and a vec because iterating the vec is faster
     pub(super) matched_storage_ids: Vec<StorageId>,
     // Represents whether this query iteration is dense or not. When this is true
@@ -145,7 +145,7 @@ impl<D: QueryData, F: QueryFilter> QueryState<D, F> {
     }
 
     /// Returns the components accessed by this query.
-    pub fn component_access(&self) -> &FilteredAccess<ComponentId> {
+    pub fn component_access(&self) -> &FilteredAccess {
         &self.component_access
     }
 
diff --git a/crates/bevy_ecs/src/query/world_query.rs b/crates/bevy_ecs/src/query/world_query.rs
index 1c739927acf05..ec669a589a10f 100644
--- a/crates/bevy_ecs/src/query/world_query.rs
+++ b/crates/bevy_ecs/src/query/world_query.rs
@@ -112,7 +112,7 @@ pub unsafe trait WorldQuery {
     /// Used to check which queries are disjoint and can run in parallel
     // This does not have a default body of `{}` because 99% of cases need to add accesses
     // and forgetting to do so would be unsound.
-    fn update_component_access(state: &Self::State, access: &mut FilteredAccess<ComponentId>);
+    fn update_component_access(state: &Self::State, access: &mut FilteredAccess);
 
     /// Creates and initializes a [`State`](WorldQuery::State) for this [`WorldQuery`] type.
     fn init_state(world: &mut World) -> Self::State;
@@ -200,7 +200,7 @@ macro_rules! impl_tuple_world_query {
             }
 
 
-            fn update_component_access(state: &Self::State, access: &mut FilteredAccess<ComponentId>) {
+            fn update_component_access(state: &Self::State, access: &mut FilteredAccess) {
                 let ($($name,)*) = state;
                 $($name::update_component_access($name, access);)*
             }
diff --git a/crates/bevy_ecs/src/schedule/executor/mod.rs b/crates/bevy_ecs/src/schedule/executor/mod.rs
index 655a71caa70e6..08fdf2374c9fd 100644
--- a/crates/bevy_ecs/src/schedule/executor/mod.rs
+++ b/crates/bevy_ecs/src/schedule/executor/mod.rs
@@ -16,7 +16,7 @@ pub use self::multi_threaded::{MainThreadExecutor, MultiThreadedExecutor};
 use fixedbitset::FixedBitSet;
 
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
+    component::{CheckChangeTicks, Tick},
     error::{BevyError, ErrorContext, Result},
     prelude::{IntoSystemSet, SystemSet},
     query::FilteredAccessSet,
@@ -208,7 +208,7 @@ impl System for ApplyDeferred {
         Ok(())
     }
 
-    fn initialize(&mut self, _world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, _world: &mut World) -> FilteredAccessSet {
         FilteredAccessSet::new()
     }
 
diff --git a/crates/bevy_ecs/src/schedule/node.rs b/crates/bevy_ecs/src/schedule/node.rs
index 75c5c71ae8ce8..cf235f655af3a 100644
--- a/crates/bevy_ecs/src/schedule/node.rs
+++ b/crates/bevy_ecs/src/schedule/node.rs
@@ -10,7 +10,7 @@ use bevy_platform::collections::HashMap;
 use slotmap::{new_key_type, Key, KeyData, SecondaryMap, SlotMap};
 
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
+    component::{CheckChangeTicks, Tick},
     prelude::{SystemIn, SystemSet},
     query::FilteredAccessSet,
     schedule::{
@@ -35,7 +35,7 @@ pub struct SystemWithAccess {
     pub system: ScheduleSystem,
     /// The access returned by [`System::initialize`].
     /// This will be empty if the system has not been initialized yet.
-    pub access: FilteredAccessSet<ComponentId>,
+    pub access: FilteredAccessSet,
 }
 
 impl SystemWithAccess {
@@ -104,7 +104,7 @@ impl System for SystemWithAccess {
     }
 
     #[inline]
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         self.system.initialize(world)
     }
 
@@ -135,7 +135,7 @@ pub struct ConditionWithAccess {
     pub condition: BoxedCondition,
     /// The access returned by [`System::initialize`].
     /// This will be empty if the system has not been initialized yet.
-    pub access: FilteredAccessSet<ComponentId>,
+    pub access: FilteredAccessSet,
 }
 
 impl ConditionWithAccess {
@@ -204,7 +204,7 @@ impl System for ConditionWithAccess {
     }
 
     #[inline]
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         self.condition.initialize(world)
     }
 
diff --git a/crates/bevy_ecs/src/system/adapter_system.rs b/crates/bevy_ecs/src/system/adapter_system.rs
index 6b1334862eb35..3bae1615e8122 100644
--- a/crates/bevy_ecs/src/system/adapter_system.rs
+++ b/crates/bevy_ecs/src/system/adapter_system.rs
@@ -171,10 +171,7 @@ where
         unsafe { self.system.validate_param_unsafe(world) }
     }
 
-    fn initialize(
-        &mut self,
-        world: &mut crate::prelude::World,
-    ) -> crate::query::FilteredAccessSet<crate::component::ComponentId> {
+    fn initialize(&mut self, world: &mut crate::prelude::World) -> crate::query::FilteredAccessSet {
         self.system.initialize(world)
     }
 
diff --git a/crates/bevy_ecs/src/system/combinator.rs b/crates/bevy_ecs/src/system/combinator.rs
index 2d037eef16c37..a2a3d0d79857c 100644
--- a/crates/bevy_ecs/src/system/combinator.rs
+++ b/crates/bevy_ecs/src/system/combinator.rs
@@ -3,7 +3,7 @@ use bevy_utils::prelude::DebugName;
 use core::marker::PhantomData;
 
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
+    component::{CheckChangeTicks, Tick},
     prelude::World,
     query::FilteredAccessSet,
     schedule::InternedSystemSet,
@@ -203,7 +203,7 @@ where
         unsafe { self.a.validate_param_unsafe(world) }
     }
 
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         let mut a_access = self.a.initialize(world);
         let b_access = self.b.initialize(world);
         a_access.extend(b_access);
@@ -402,7 +402,7 @@ where
         unsafe { self.a.validate_param_unsafe(world) }
     }
 
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         let mut a_access = self.a.initialize(world);
         let b_access = self.b.initialize(world);
         a_access.extend(b_access);
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index d786cdb697f3b..c2df1823f70ea 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -131,7 +131,7 @@ const _: () = {
         fn init_access(
             state: &Self::State,
             system_meta: &mut bevy_ecs::system::SystemMeta,
-            component_access_set: &mut bevy_ecs::query::FilteredAccessSet<ComponentId>,
+            component_access_set: &mut bevy_ecs::query::FilteredAccessSet,
             world: &mut World,
         ) {
             <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::init_access(
diff --git a/crates/bevy_ecs/src/system/exclusive_function_system.rs b/crates/bevy_ecs/src/system/exclusive_function_system.rs
index 241f9955dfa4d..a9cb1104a5630 100644
--- a/crates/bevy_ecs/src/system/exclusive_function_system.rs
+++ b/crates/bevy_ecs/src/system/exclusive_function_system.rs
@@ -1,5 +1,5 @@
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
+    component::{CheckChangeTicks, Tick},
     error::Result,
     query::FilteredAccessSet,
     schedule::{InternedSystemSet, SystemSet},
@@ -176,7 +176,7 @@ where
     }
 
     #[inline]
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         self.system_meta.last_run = world.change_tick().relative_to(Tick::MAX);
         self.param_state = Some(F::Param::init(world, &mut self.system_meta));
         FilteredAccessSet::new()
diff --git a/crates/bevy_ecs/src/system/function_system.rs b/crates/bevy_ecs/src/system/function_system.rs
index 89740a9dceebc..5ee2805772129 100644
--- a/crates/bevy_ecs/src/system/function_system.rs
+++ b/crates/bevy_ecs/src/system/function_system.rs
@@ -1,5 +1,5 @@
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
+    component::{CheckChangeTicks, Tick},
     error::{BevyError, Result},
     never::Never,
     prelude::FromWorld,
@@ -733,7 +733,7 @@ where
     }
 
     #[inline]
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         if let Some(state) = &self.state {
             assert_eq!(
                 state.world_id,
diff --git a/crates/bevy_ecs/src/system/schedule_system.rs b/crates/bevy_ecs/src/system/schedule_system.rs
index e2a853dbe9d25..150b748e88679 100644
--- a/crates/bevy_ecs/src/system/schedule_system.rs
+++ b/crates/bevy_ecs/src/system/schedule_system.rs
@@ -1,7 +1,7 @@
 use bevy_utils::prelude::DebugName;
 
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
+    component::{CheckChangeTicks, Tick},
     error::Result,
     query::FilteredAccessSet,
     system::{input::SystemIn, BoxedSystem, RunSystemError, System, SystemInput},
@@ -90,7 +90,7 @@ where
         self.system.validate_param_unsafe(world)
     }
 
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         self.system.initialize(world)
     }
 
@@ -187,7 +187,7 @@ where
         self.system.validate_param_unsafe(world)
     }
 
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
+    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet {
         if self.value.is_none() {
             self.value = Some(T::from_world(world));
         }
diff --git a/crates/bevy_ecs/src/system/system.rs b/crates/bevy_ecs/src/system/system.rs
index 1f2a3ab608fba..048835f397776 100644
--- a/crates/bevy_ecs/src/system/system.rs
+++ b/crates/bevy_ecs/src/system/system.rs
@@ -8,7 +8,7 @@ use core::fmt::{Debug, Display};
 use log::warn;
 
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
+    component::{CheckChangeTicks, Tick},
     error::BevyError,
     query::FilteredAccessSet,
     schedule::InternedSystemSet,
@@ -181,7 +181,7 @@ pub trait System: Send + Sync + 'static {
     /// Initialize the system.
     ///
     /// Returns a [`FilteredAccessSet`] with the access required to run the system.
-    fn initialize(&mut self, _world: &mut World) -> FilteredAccessSet<ComponentId>;
+    fn initialize(&mut self, _world: &mut World) -> FilteredAccessSet;
 
     /// Checks any [`Tick`]s stored on this system and wraps their value if they get too old.
     ///
diff --git a/crates/bevy_ecs/src/system/system_name.rs b/crates/bevy_ecs/src/system/system_name.rs
index e0c3c952cf4ad..0bc54a9c3cfe3 100644
--- a/crates/bevy_ecs/src/system/system_name.rs
+++ b/crates/bevy_ecs/src/system/system_name.rs
@@ -1,5 +1,5 @@
 use crate::{
-    component::{ComponentId, Tick},
+    component::Tick,
     prelude::World,
     query::FilteredAccessSet,
     system::{ExclusiveSystemParam, ReadOnlySystemParam, SystemMeta, SystemParam},
@@ -54,7 +54,7 @@ unsafe impl SystemParam for SystemName {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index cb41a8dcb2b47..dcf5f4f3327fe 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -232,7 +232,7 @@ pub unsafe trait SystemParam: Sized {
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     );
 
@@ -343,7 +343,7 @@ unsafe impl<D: QueryData + 'static, F: QueryFilter + 'static> SystemParam for Qu
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         assert_component_access_compatibility(
@@ -376,8 +376,8 @@ fn assert_component_access_compatibility(
     system_name: &DebugName,
     query_type: DebugName,
     filter_type: DebugName,
-    system_access: &FilteredAccessSet<ComponentId>,
-    current: &FilteredAccess<ComponentId>,
+    system_access: &FilteredAccessSet,
+    current: &FilteredAccess,
     world: &World,
 ) {
     let conflicts = system_access.get_conflicts_single(current);
@@ -407,7 +407,7 @@ unsafe impl<'a, 'b, D: QueryData + 'static, F: QueryFilter + 'static> SystemPara
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         Query::init_access(state, system_meta, component_access_set, world);
@@ -478,7 +478,7 @@ unsafe impl<D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         Query::init_access(state, system_meta, component_access_set, world);
@@ -678,7 +678,7 @@ macro_rules! impl_param_set {
                 non_snake_case,
                 reason = "Certain variable names are provided by the caller, not by us."
             )]
-            fn init_access(state: &Self::State, system_meta: &mut SystemMeta, component_access_set: &mut FilteredAccessSet<ComponentId>, world: &mut World) {
+            fn init_access(state: &Self::State, system_meta: &mut SystemMeta, component_access_set: &mut FilteredAccessSet, world: &mut World) {
                 let ($($param,)*) = state;
                 $(
                     // Call `init_access` on a clone of the original access set to check for conflicts
@@ -765,7 +765,7 @@ unsafe impl<'a, T: Resource> SystemParam for Res<'a, T> {
     fn init_access(
         &component_id: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         let combined_access = component_access_set.combined_access();
@@ -842,7 +842,7 @@ unsafe impl<'a, T: Resource> SystemParam for ResMut<'a, T> {
     fn init_access(
         &component_id: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         let combined_access = component_access_set.combined_access();
@@ -920,7 +920,7 @@ unsafe impl SystemParam for &'_ World {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         let mut filtered_access = FilteredAccess::default();
@@ -957,7 +957,7 @@ unsafe impl<'w> SystemParam for DeferredWorld<'w> {
     fn init_access(
         _state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         assert!(
@@ -1102,7 +1102,7 @@ unsafe impl<'a, T: FromWorld + Send + 'static> SystemParam for Local<'a, T> {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
@@ -1290,7 +1290,7 @@ unsafe impl<T: SystemBuffer> SystemParam for Deferred<'_, T> {
     fn init_access(
         _state: &Self::State,
         system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         system_meta.set_has_deferred();
@@ -1329,7 +1329,7 @@ unsafe impl SystemParam for NonSendMarker {
     fn init_access(
         _state: &Self::State,
         system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         system_meta.set_non_send();
@@ -1433,7 +1433,7 @@ unsafe impl<'a, T: 'static> SystemParam for NonSend<'a, T> {
     fn init_access(
         &component_id: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         system_meta.set_non_send();
@@ -1509,7 +1509,7 @@ unsafe impl<'a, T: 'static> SystemParam for NonSendMut<'a, T> {
     fn init_access(
         &component_id: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
         system_meta.set_non_send();
@@ -1585,7 +1585,7 @@ unsafe impl<'a> SystemParam for &'a Archetypes {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
@@ -1614,7 +1614,7 @@ unsafe impl<'a> SystemParam for &'a Components {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
@@ -1643,7 +1643,7 @@ unsafe impl<'a> SystemParam for &'a Entities {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
@@ -1672,7 +1672,7 @@ unsafe impl<'a> SystemParam for &'a Bundles {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
@@ -1730,7 +1730,7 @@ unsafe impl SystemParam for SystemChangeTick {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
@@ -1762,7 +1762,7 @@ unsafe impl<T: SystemParam> SystemParam for Option<T> {
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         T::init_access(state, system_meta, component_access_set, world);
@@ -1805,7 +1805,7 @@ unsafe impl<T: SystemParam> SystemParam for Result<T, SystemParamValidationError
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         T::init_access(state, system_meta, component_access_set, world);
@@ -1900,7 +1900,7 @@ unsafe impl<T: SystemParam> SystemParam for If<T> {
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         T::init_access(state, system_meta, component_access_set, world);
@@ -1954,7 +1954,7 @@ unsafe impl<T: SystemParam> SystemParam for Vec<T> {
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         for state in state {
@@ -2018,7 +2018,7 @@ unsafe impl<T: SystemParam> SystemParam for ParamSet<'_, '_, Vec<T>> {
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         for state in state {
@@ -2124,7 +2124,7 @@ macro_rules! impl_system_param_tuple {
                 (($($param::init_state(world),)*))
             }
 
-            fn init_access(state: &Self::State, _system_meta: &mut SystemMeta, _component_access_set: &mut FilteredAccessSet<ComponentId>, _world: &mut World) {
+            fn init_access(state: &Self::State, _system_meta: &mut SystemMeta, _component_access_set: &mut FilteredAccessSet, _world: &mut World) {
                 let ($($param,)*) = state;
                 $($param::init_access($param, _system_meta, _component_access_set, _world);)*
             }
@@ -2301,7 +2301,7 @@ unsafe impl<P: SystemParam + 'static> SystemParam for StaticSystemParam<'_, '_,
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         P::init_access(state, system_meta, component_access_set, world);
@@ -2346,7 +2346,7 @@ unsafe impl<T: ?Sized> SystemParam for PhantomData<T> {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
@@ -2565,7 +2565,7 @@ trait DynParamState: Sync + Send + Any {
     fn init_access(
         &self,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     );
 
@@ -2595,7 +2595,7 @@ impl<T: SystemParam + 'static> DynParamState for ParamState<T> {
     fn init_access(
         &self,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         T::init_access(&self.0, system_meta, component_access_set, world);
@@ -2623,7 +2623,7 @@ unsafe impl SystemParam for DynSystemParam<'_, '_> {
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         state
@@ -2667,7 +2667,7 @@ unsafe impl SystemParam for DynSystemParam<'_, '_> {
 // SAFETY: Resource ComponentId access is applied to the access. If this FilteredResources
 // conflicts with any prior access, a panic will occur.
 unsafe impl SystemParam for FilteredResources<'_, '_> {
-    type State = Access<ComponentId>;
+    type State = Access;
 
     type Item<'world, 'state> = FilteredResources<'world, 'state>;
 
@@ -2678,7 +2678,7 @@ unsafe impl SystemParam for FilteredResources<'_, '_> {
     fn init_access(
         access: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         let combined_access = component_access_set.combined_access();
@@ -2716,7 +2716,7 @@ unsafe impl ReadOnlySystemParam for FilteredResources<'_, '_> {}
 // SAFETY: Resource ComponentId access is applied to the access. If this FilteredResourcesMut
 // conflicts with any prior access, a panic will occur.
 unsafe impl SystemParam for FilteredResourcesMut<'_, '_> {
-    type State = Access<ComponentId>;
+    type State = Access;
 
     type Item<'world, 'state> = FilteredResourcesMut<'world, 'state>;
 
@@ -2727,7 +2727,7 @@ unsafe impl SystemParam for FilteredResourcesMut<'_, '_> {
     fn init_access(
         access: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         let combined_access = component_access_set.combined_access();
diff --git a/crates/bevy_ecs/src/world/entity_ref.rs b/crates/bevy_ecs/src/world/entity_ref.rs
index 9260301474b46..643c4f1a029c1 100644
--- a/crates/bevy_ecs/src/world/entity_ref.rs
+++ b/crates/bevy_ecs/src/world/entity_ref.rs
@@ -3516,7 +3516,7 @@ impl<'w, 'a, T: Component> VacantComponentEntry<'w, 'a, T> {
 #[derive(Clone, Copy)]
 pub struct FilteredEntityRef<'w, 's> {
     entity: UnsafeEntityCell<'w>,
-    access: &'s Access<ComponentId>,
+    access: &'s Access,
 }
 
 impl<'w, 's> FilteredEntityRef<'w, 's> {
@@ -3526,10 +3526,7 @@ impl<'w, 's> FilteredEntityRef<'w, 's> {
     ///   component can exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes any access for a component `entity` must have that component.
     #[inline]
-    pub(crate) unsafe fn new(
-        entity: UnsafeEntityCell<'w>,
-        access: &'s Access<ComponentId>,
-    ) -> Self {
+    pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: &'s Access) -> Self {
         Self { entity, access }
     }
 
@@ -3554,7 +3551,7 @@ impl<'w, 's> FilteredEntityRef<'w, 's> {
 
     /// Returns a reference to the underlying [`Access`].
     #[inline]
-    pub fn access(&self) -> &Access<ComponentId> {
+    pub fn access(&self) -> &Access {
         self.access
     }
 
@@ -3834,7 +3831,7 @@ unsafe impl EntityEquivalent for FilteredEntityRef<'_, '_> {}
 /// ```
 pub struct FilteredEntityMut<'w, 's> {
     entity: UnsafeEntityCell<'w>,
-    access: &'s Access<ComponentId>,
+    access: &'s Access,
 }
 
 impl<'w, 's> FilteredEntityMut<'w, 's> {
@@ -3846,10 +3843,7 @@ impl<'w, 's> FilteredEntityMut<'w, 's> {
     ///   may exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes any access for a component `entity` must have that component.
     #[inline]
-    pub(crate) unsafe fn new(
-        entity: UnsafeEntityCell<'w>,
-        access: &'s Access<ComponentId>,
-    ) -> Self {
+    pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: &'s Access) -> Self {
         Self { entity, access }
     }
 
@@ -3887,7 +3881,7 @@ impl<'w, 's> FilteredEntityMut<'w, 's> {
 
     /// Returns a reference to the underlying [`Access`].
     #[inline]
-    pub fn access(&self) -> &Access<ComponentId> {
+    pub fn access(&self) -> &Access {
         self.access
     }
 
@@ -4162,7 +4156,7 @@ where
     B: Bundle,
 {
     entity: UnsafeEntityCell<'w>,
-    access: &'s Access<ComponentId>,
+    access: &'s Access,
     phantom: PhantomData<B>,
 }
 
@@ -4172,10 +4166,7 @@ where
 {
     /// # Safety
     /// Other users of `UnsafeEntityCell` must only have mutable access to the components in `B`.
-    pub(crate) unsafe fn new(
-        entity: UnsafeEntityCell<'w>,
-        access: &'s Access<ComponentId>,
-    ) -> Self {
+    pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: &'s Access) -> Self {
         Self {
             entity,
             access,
@@ -4400,7 +4391,7 @@ where
     B: Bundle,
 {
     entity: UnsafeEntityCell<'w>,
-    access: &'s Access<ComponentId>,
+    access: &'s Access,
     phantom: PhantomData<B>,
 }
 
@@ -4410,10 +4401,7 @@ where
 {
     /// # Safety
     /// Other users of `UnsafeEntityCell` must not have access to any components not in `B`.
-    pub(crate) unsafe fn new(
-        entity: UnsafeEntityCell<'w>,
-        access: &'s Access<ComponentId>,
-    ) -> Self {
+    pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: &'s Access) -> Self {
         Self {
             entity,
             access,
diff --git a/crates/bevy_ecs/src/world/filtered_resource.rs b/crates/bevy_ecs/src/world/filtered_resource.rs
index ed3672bef95a3..668b45257ed32 100644
--- a/crates/bevy_ecs/src/world/filtered_resource.rs
+++ b/crates/bevy_ecs/src/world/filtered_resource.rs
@@ -117,7 +117,7 @@ use super::error::ResourceFetchError;
 #[derive(Clone, Copy)]
 pub struct FilteredResources<'w, 's> {
     world: UnsafeWorldCell<'w>,
-    access: &'s Access<ComponentId>,
+    access: &'s Access,
     last_run: Tick,
     this_run: Tick,
 }
@@ -128,7 +128,7 @@ impl<'w, 's> FilteredResources<'w, 's> {
     /// It is the callers responsibility to ensure that nothing else may access the any resources in the `world` in a way that conflicts with `access`.
     pub(crate) unsafe fn new(
         world: UnsafeWorldCell<'w>,
-        access: &'s Access<ComponentId>,
+        access: &'s Access,
         last_run: Tick,
         this_run: Tick,
     ) -> Self {
@@ -141,7 +141,7 @@ impl<'w, 's> FilteredResources<'w, 's> {
     }
 
     /// Returns a reference to the underlying [`Access`].
-    pub fn access(&self) -> &Access<ComponentId> {
+    pub fn access(&self) -> &Access {
         self.access
     }
 
@@ -220,8 +220,8 @@ impl<'w, 's> From<&'w FilteredResourcesMut<'_, 's>> for FilteredResources<'w, 's
 
 impl<'w> From<&'w World> for FilteredResources<'w, 'static> {
     fn from(value: &'w World) -> Self {
-        const READ_ALL_RESOURCES: &Access<ComponentId> = {
-            const ACCESS: Access<ComponentId> = {
+        const READ_ALL_RESOURCES: &Access = {
+            const ACCESS: Access = {
                 let mut access = Access::new();
                 access.read_all_resources();
                 access
@@ -373,7 +373,7 @@ impl<'w> From<&'w mut World> for FilteredResources<'w, 'static> {
 /// ```
 pub struct FilteredResourcesMut<'w, 's> {
     world: UnsafeWorldCell<'w>,
-    access: &'s Access<ComponentId>,
+    access: &'s Access,
     last_run: Tick,
     this_run: Tick,
 }
@@ -384,7 +384,7 @@ impl<'w, 's> FilteredResourcesMut<'w, 's> {
     /// It is the callers responsibility to ensure that nothing else may access the any resources in the `world` in a way that conflicts with `access`.
     pub(crate) unsafe fn new(
         world: UnsafeWorldCell<'w>,
-        access: &'s Access<ComponentId>,
+        access: &'s Access,
         last_run: Tick,
         this_run: Tick,
     ) -> Self {
@@ -409,7 +409,7 @@ impl<'w, 's> FilteredResourcesMut<'w, 's> {
     }
 
     /// Returns a reference to the underlying [`Access`].
-    pub fn access(&self) -> &Access<ComponentId> {
+    pub fn access(&self) -> &Access {
         self.access
     }
 
@@ -510,8 +510,8 @@ impl<'w, 's> FilteredResourcesMut<'w, 's> {
 
 impl<'w> From<&'w mut World> for FilteredResourcesMut<'w, 'static> {
     fn from(value: &'w mut World) -> Self {
-        const WRITE_ALL_RESOURCES: &Access<ComponentId> = {
-            const ACCESS: Access<ComponentId> = {
+        const WRITE_ALL_RESOURCES: &Access = {
+            const ACCESS: Access = {
                 let mut access = Access::new();
                 access.write_all_resources();
                 access
@@ -538,7 +538,7 @@ impl<'w> From<&'w mut World> for FilteredResourcesMut<'w, 'static> {
 /// This is passed to a callback in [`FilteredResourcesParamBuilder`](crate::system::FilteredResourcesParamBuilder).
 pub struct FilteredResourcesBuilder<'w> {
     world: &'w mut World,
-    access: Access<ComponentId>,
+    access: Access,
 }
 
 impl<'w> FilteredResourcesBuilder<'w> {
@@ -551,7 +551,7 @@ impl<'w> FilteredResourcesBuilder<'w> {
     }
 
     /// Returns a reference to the underlying [`Access`].
-    pub fn access(&self) -> &Access<ComponentId> {
+    pub fn access(&self) -> &Access {
         &self.access
     }
 
@@ -574,7 +574,7 @@ impl<'w> FilteredResourcesBuilder<'w> {
     }
 
     /// Create an [`Access`] that represents the accesses of the builder.
-    pub fn build(self) -> Access<ComponentId> {
+    pub fn build(self) -> Access {
         self.access
     }
 }
@@ -584,7 +584,7 @@ impl<'w> FilteredResourcesBuilder<'w> {
 /// This is passed to a callback in [`FilteredResourcesMutParamBuilder`](crate::system::FilteredResourcesMutParamBuilder).
 pub struct FilteredResourcesMutBuilder<'w> {
     world: &'w mut World,
-    access: Access<ComponentId>,
+    access: Access,
 }
 
 impl<'w> FilteredResourcesMutBuilder<'w> {
@@ -597,7 +597,7 @@ impl<'w> FilteredResourcesMutBuilder<'w> {
     }
 
     /// Returns a reference to the underlying [`Access`].
-    pub fn access(&self) -> &Access<ComponentId> {
+    pub fn access(&self) -> &Access {
         &self.access
     }
 
@@ -638,7 +638,7 @@ impl<'w> FilteredResourcesMutBuilder<'w> {
     }
 
     /// Create an [`Access`] that represents the accesses of the builder.
-    pub fn build(self) -> Access<ComponentId> {
+    pub fn build(self) -> Access {
         self.access
     }
 }
diff --git a/crates/bevy_ecs/src/world/identifier.rs b/crates/bevy_ecs/src/world/identifier.rs
index 51f9a0ee2c6f5..37e71110e55d6 100644
--- a/crates/bevy_ecs/src/world/identifier.rs
+++ b/crates/bevy_ecs/src/world/identifier.rs
@@ -1,5 +1,5 @@
 use crate::{
-    component::{ComponentId, Tick},
+    component::Tick,
     query::FilteredAccessSet,
     storage::SparseSetIndex,
     system::{ExclusiveSystemParam, ReadOnlySystemParam, SystemMeta, SystemParam},
@@ -59,7 +59,7 @@ unsafe impl SystemParam for WorldId {
     fn init_access(
         _state: &Self::State,
         _system_meta: &mut SystemMeta,
-        _component_access_set: &mut FilteredAccessSet<ComponentId>,
+        _component_access_set: &mut FilteredAccessSet,
         _world: &mut World,
     ) {
     }
diff --git a/crates/bevy_gizmos/src/gizmos.rs b/crates/bevy_gizmos/src/gizmos.rs
index e0f139a1a8662..0299b4700a3a1 100644
--- a/crates/bevy_gizmos/src/gizmos.rs
+++ b/crates/bevy_gizmos/src/gizmos.rs
@@ -9,7 +9,7 @@ use core::{
 
 use bevy_color::{Color, LinearRgba};
 use bevy_ecs::{
-    component::{ComponentId, Tick},
+    component::Tick,
     query::FilteredAccessSet,
     resource::Resource,
     system::{
@@ -209,7 +209,7 @@ where
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         GizmosState::<Config, Clear>::init_access(
diff --git a/crates/bevy_render/src/extract_param.rs b/crates/bevy_render/src/extract_param.rs
index e97c758260939..e7701843fb2df 100644
--- a/crates/bevy_render/src/extract_param.rs
+++ b/crates/bevy_render/src/extract_param.rs
@@ -1,6 +1,6 @@
 use crate::MainWorld;
 use bevy_ecs::{
-    component::{ComponentId, Tick},
+    component::Tick,
     prelude::*,
     query::FilteredAccessSet,
     system::{
@@ -83,7 +83,7 @@ where
     fn init_access(
         state: &Self::State,
         system_meta: &mut SystemMeta,
-        component_access_set: &mut FilteredAccessSet<ComponentId>,
+        component_access_set: &mut FilteredAccessSet,
         world: &mut World,
     ) {
         Res::<MainWorld>::init_access(
diff --git a/crates/bevy_render/src/sync_world.rs b/crates/bevy_render/src/sync_world.rs
index b216b5fd32e3f..77643ba809052 100644
--- a/crates/bevy_render/src/sync_world.rs
+++ b/crates/bevy_render/src/sync_world.rs
@@ -336,10 +336,7 @@ mod render_entities_world_query_impls {
             unsafe { <&RenderEntity as WorldQuery>::set_table(fetch, &component_id, table) }
         }
 
-        fn update_component_access(
-            &component_id: &ComponentId,
-            access: &mut FilteredAccess<ComponentId>,
-        ) {
+        fn update_component_access(&component_id: &ComponentId, access: &mut FilteredAccess) {
             <&RenderEntity as WorldQuery>::update_component_access(&component_id, access);
         }
 
@@ -445,10 +442,7 @@ mod render_entities_world_query_impls {
             unsafe { <&MainEntity as WorldQuery>::set_table(fetch, &component_id, table) }
         }
 
-        fn update_component_access(
-            &component_id: &ComponentId,
-            access: &mut FilteredAccess<ComponentId>,
-        ) {
+        fn update_component_access(&component_id: &ComponentId, access: &mut FilteredAccess) {
             <&MainEntity as WorldQuery>::update_component_access(&component_id, access);
         }
 
diff --git a/release-content/migration-guides/non-generic-access.md b/release-content/migration-guides/non-generic-access.md
new file mode 100644
index 0000000000000..d3b38135a23c7
--- /dev/null
+++ b/release-content/migration-guides/non-generic-access.md
@@ -0,0 +1,17 @@
+---
+title: Non-generic `Access`
+pull_requests: [TODO]
+---
+
+Now that `archetype_component_id` has been removed,
+`Access`, `AccessFilters`, `FilteredAccess`, and `FilteredAccessSet`
+were only ever parameterized by `ComponentId`.
+To simplify use of those types, the generic parameter has been removed.
+Remove the `<Component>` generic from any use of those types.
+
+```rust
+// 0.16
+fn update_component_access(state: &Self::State, access: &mut FilteredAccess<ComponentId>) {}
+// 0.17
+fn update_component_access(state: &Self::State, access: &mut FilteredAccess) {}
+```
