+++
title = "#20708 use affine not mat4 inverse in light probes"
date = "2025-08-24T00:00:00"
draft = false
template = "pull_request_page.html"
in_search_index = true

[taxonomies]
list_display = ["show"]

[extra]
current_language = "en"
available_languages = {"en" = { name = "English", url = "/pull_request/bevy/2025-08/pr-20708-en-20250824" }, "zh-cn" = { name = "中文", url = "/pull_request/bevy/2025-08/pr-20708-zh-cn-20250824" }}
labels = ["A-Rendering"]
+++

# Title
use affine not mat4 inverse in light probes

## Basic Information
- **Title**: use affine not mat4 inverse in light probes
- **PR Link**: https://github.com/bevyengine/bevy/pull/20708
- **Author**: atlv24
- **Status**: MERGED
- **Labels**: A-Rendering, S-Ready-For-Final-Review
- **Created**: 2025-08-22T08:16:30Z
- **Merged**: 2025-08-24T21:19:39Z
- **Merged By**: alice-i-cecile

## Description Translation
# Objective

- keep it affine for better inverse

## Solution

- 

## Testing

- reflection probes example

## The Story of This Pull Request

This PR addresses a mathematical optimization in Bevy's light probe system. The core issue was that light probe transforms were being handled as general 4x4 matrices when they are specifically affine transformations. This distinction matters because affine transforms have more efficient and numerically stable inversion operations compared to general matrices.

The problem originated in how light probe space transformations were calculated. Light probes use two complementary transforms: world_from_light (world space to light probe space) and light_from_world (light probe space to world space). Previously, both were stored and computed using different representations, with light_from_world being computed through a general matrix inverse operation.

The solution involved standardizing on Affine3A for both transformations. Affine3A is specifically designed for affine transformations (translation, rotation, scale, shear) and provides a more efficient inverse() operation compared to Mat4's general matrix inverse. This change improves both performance and numerical stability.

The implementation required three key changes:
1. Changing the light_from_world field type from Mat4 to Affine3A
2. Updating the inverse calculation to use Affine3A's inverse method
3. Maintaining GPU compatibility by converting back to Mat4 when uploading to shaders

This approach maintains the existing API and functionality while providing better mathematical properties under the hood. The changes are minimal but impactful, affecting only the internal representation and computation of the inverse transform.

## Visual Representation

```mermaid
graph TD
    A[LightProbe Transform] --> B[Affine3A representation]
    B --> C[Affine3A.inverse()]
    C --> D[Efficient inverse calculation]
    D --> E[Mat4 conversion for GPU]
```

## Key Files Changed

### `crates/bevy_pbr/src/light_probe/mod.rs` (+3/-3)

This file contains the core light probe implementation. The changes optimize the mathematical representation of light probe transformations.

**Key changes:**

1. **Field type change** - Updated light_from_world from Mat4 to Affine3A:
```rust
// Before:
light_from_world: Mat4,

// After:
light_from_world: Affine3A,
```

2. **Inverse calculation optimization** - Used affine inverse instead of matrix inverse:
```rust
// Before:
light_from_world: light_probe_transform.to_matrix().inverse(),

// After:
light_from_world: light_probe_transform.affine().inverse(),
```

3. **GPU compatibility maintenance** - Converted back to Mat4 for shader upload:
```rust
// Before:
let light_from_world_transposed = light_probe.light_from_world.transpose();

// After:
let light_from_world_transposed = Mat4::from(light_probe.light_from_world).transpose();
```

These changes ensure that:
- Light probe transforms are handled as affine transformations throughout the system
- Inverse calculations use the optimized affine inverse operation
- The GPU continues to receive the expected Mat4 format

## Further Reading

- [Affine transformations](https://en.wikipedia.org/wiki/Affine_transformation)
- [Bevy Affine3A documentation](https://docs.rs/bevy/latest/bevy/math/struct.Affine3A.html)
- [Matrix inverse vs affine inverse performance](https://graphics.stanford.edu/courses/cs248-98-fall/Final/q4.html)
- [Numerical stability in computer graphics](https://developer.nvidia.com/content/understanding-affine-transformations-matrix-math)